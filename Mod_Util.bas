Attribute VB_Name = "Module2"
Option Explicit
Const CSIDL_TEMPLATES = &H15&
Global Const OpSq = "«"
Global Const ClSq = "»"
Const MAX_PATH = 260
Public Errorlog As New Document
Private Const mProp = "PropReference"
Private Const mHdlr = "mHandler"
Private Const mGroup = "Group"
Private ExecBaseStack As basetask, ExecHere$
Public SHOWCODE As Boolean
Public doslast As Double
Dim FontList As FastCollection
Public PLM, PTM, PRM, PBM
Public Trush() As VarItem
Public TrushCount As Long, TrushWait As Boolean
Public Nonbsp As Boolean
Public k1 As Currency, Kform As Boolean
Private Const doc = "Document"
Public Check2SaveModules As Boolean
Dim oldback As Long, oldfore As Long, USEOLD As Boolean
Dim ObjectCatalog As FastCollection, loadcatalog As New FastCollection
Private oldpanel1 As String, oldpanel2 As String
Public tracecode As String, lasttracecode As Long
Private Declare Function OpenClipboard Lib "user32" (ByVal hWnd As Long) As Long
Private Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathW" (ByVal nBufferLength As Long, ByVal lpBuffer As Long) As Long
Private Declare Function ShellExecute Lib "shell32.dll" Alias "ShellExecuteW" (ByVal hWnd As Long, ByVal lpszOp As Long, ByVal lpszFile As Long, ByVal lpszParams As Long, ByVal LpszDir As String, ByVal FsShowCmd As Long) As Long
Private Declare Function SHGetSpecialFolderLocation Lib "shell32.dll" (ByVal hWndOwner As Long, ByVal nFolder As Long, pidl As Long) As Long
Private Declare Function SHGetPathFromIDList Lib "shell32.dll" Alias "SHGetPathFromIDListW" (ByVal pidl As Long, ByVal lpszPath As Long) As Long
Private Declare Function FindExecutable Lib "shell32.dll" Alias "FindExecutableW" (ByVal lpFile As Long, ByVal lpDirectory As Long, ByVal lpResult As Long) As Long
Private Declare Function GetForegroundWindow Lib "user32" () As Long
Private Declare Function SelectClipRgn Lib "gdi32" (ByVal Hdc As Long, ByVal hRgn As Long) As Long
Private Declare Function MessageBeep Lib "user32" (ByVal wType As Long) As Long
Public Declare Function GetLocaleInfoW Lib "kernel32" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As Long, ByVal cchData As Long) As Long
Private Declare Function GetKeyboardLayout& Lib "user32" (ByVal dwLayout&) ' not NT?
Private Const DWL_ANYTHREAD& = 0
Const LOCALE_ILANGUAGE = 1
Private Const LOCALE_SENGLANGUAGE& = 4097&
Private Const LOCALE_SLANGUAGE& = &H2& '  localized name of language

'Public Declare Function IsWindow Lib "user32" (ByVal hWnd As Long) As Long
'Public Declare Function IsWindowEnabled Lib "user32" (ByVal hWnd As Long) As Long
'Public Declare Function IsWindowVisible Lib "user32" (ByVal hWnd As Long) As Long
Public stackshowonly As Boolean, NoBackFormFirstUse As Boolean
Private Declare Function IsBadCodePtr Lib "kernel32" (ByVal lpfn As Long) As Long
Declare Function ExpandEnvironmentStrings _
   Lib "kernel32" Alias "ExpandEnvironmentStringsW" _
   (ByVal lpSrc As Long, ByVal lpDst As Long, _
   ByVal nSize As Long) As Long
Private Declare Function GetTempFileNameW Lib "kernel32" _
    (ByVal lpszPath As Long, ByVal lpPrefixString As Long, _
     ByVal wUnique As Long, ByVal lpTempFileName As Long) _
     As Long
Private Const UNIQUE_NAME = &H0&
Public Pow2(33) As Currency, Pow2minusOne(33) As Currency
Public nMath As New Math
Public nMath2 As New MATH2
Public Type Counters
    k1 As Currency
    RRCOUNTER As Currency
End Type
Public Type basket
    used As Long
    X As Long  ' for hotspot
    Y As Long  '
    XGRAPH As Long  ' graphic cursor
    YGRAPH As Long
    MAXXGRAPH As Long
    MAXYGRAPH As Long
    dv15 As Long  ' not used
    curpos As Long   ' text cursor
    currow As Long
    mypen As Long
    mypentrans As Long
    mysplit As Long
    Paper As Long
    ShowCaret As Boolean
    italics As Boolean  ' removed from process, only in current
    bold As Boolean
    double As Boolean
    osplit As Long  '(for double size letters)
    Column As Long
    OCOLUMN As Long
    pageframe As Long
    basicpageframe As Long
    MineLineSpace As Long
    uMineLineSpace As Long
    LastReportLines As Double
    SZ As Single
    UseDouble As Single
    Xt As Long
    Yt As Long
    mX As Long
    mY As Long
    FontName As String
    charset As Long
    FTEXT As Long
    FTXT As String
    lastprint As Boolean  ' if true then we have to place letters using currentX
    ' gdi drawing enabled Smooth On, disabled with Smooth Of
    NoGDI As Boolean
    IamEmf As Boolean
    pathgdi As Long  ' only for gdi+
    pathcolor As Long ' only for gdi+
    pathfillstyle As Integer
    LastIcon As Integer  ' 1..   / 99 loaded
    LastIconPic As StdPicture
    HideIcon As Boolean
    ReportTab As Long
    overrideTextHeight As Long
    HotSpotX As Long
    HotSpotY As Long
    hRgn As Long
    ControlName As String
End Type
Private stopwatch As Long
Private Const myArray = "mArray"
Private Const LOCALE_SYSTEM_DEFAULT As Long = &H800
Private Const LOCALE_USER_DEFAULT As Long = &H800
Private Const C3_DIACRITIC As Long = &H2
Private Const CT_CTYPE3 As Byte = &H4
Private Declare Function GetStringTypeExW Lib "kernel32.dll" (ByVal Locale As Long, ByVal dwInfoType As Long, ByVal lpSrcStr As Long, ByVal cchSrc As Long, ByRef lpCharType As Integer) As Long
Private Declare Function SetTextCharacterExtra Lib "gdi32" (ByVal Hdc As Long, ByVal nCharExtra As Long) As Long
Private Declare Function WideCharToMultiByte Lib "kernel32" (ByVal CodePage As Long, ByVal dwFlags As Long, ByVal lpWideCharStr As Long, ByVal cchWideChar As Long, ByVal lpMultiByteStr As Long, ByVal cchMultiByte As Long, ByVal lpDefaultChar As Long, ByVal lpUsedDefaultChar As Long) As Long
Private Declare Function GdiFlush Lib "gdi32" () As Long
Public iamactive As Boolean
Declare Function MultiByteToWideChar& Lib "kernel32" (ByVal CodePage&, ByVal dwFlags&, MultiBytes As Any, ByVal cBytes&, ByVal pWideChars&, ByVal cWideChars&)
Private Declare Function FillRect Lib "user32" (ByVal Hdc As Long, lpRect As RECT, ByVal hBrush As Long) As Long
Private Declare Function CreateSolidBrush Lib "gdi32" (ByVal crColor As Long) As Long
Private Declare Function GetClipRgn Lib "gdi32" (ByVal Hdc As Long, _
         hRgn As Long) As Long
Declare Function CreateRectRgn Lib "gdi32" (ByVal x1 As Long, ByVal y1 As Long, ByVal x2 As Long, ByVal y2 As Long) As Long
Private Declare Function DeleteObject Lib "gdi32" (ByVal hObject As Long) As Long
Public Type RECT
        Left As Long
        top As Long
        Right As Long
        Bottom As Long
End Type
Public Const LOCALE_SDECIMAL = &HE&
Public Const LOCALE_SGROUPING = &H10&
Public Const LOCALE_STHOUSAND = &HF&
Public Const LOCALE_SMONDECIMALSEP = &H16&
Public Const LOCALE_SMONTHOUSANDSEP = &H17&
Public Const LOCALE_SMONGROUPING = &H18&
Private Declare Function timeGetTime Lib "kernel32.dll" Alias "GetTickCount" () As Long
Private Const DT_BOTTOM As Long = &H8&
Private Const DT_CALCRECT As Long = &H400&
Private Const DT_CENTER As Long = &H1&
Private Const DT_EDITCONTROL As Long = &H2000&
Private Const DT_END_ELLIPSIS As Long = &H8000&
Private Const DT_EXPANDTABS As Long = &H40&
Private Const DT_EXTERNALLEADING As Long = &H200&
Private Const DT_HIDEPREFIX As Long = &H100000
Private Const DT_INTERNAL As Long = &H1000&
Private Const DT_LEFT As Long = &H0&
Private Const DT_MODIFYSTRING As Long = &H10000
Private Const DT_NOCLIP As Long = &H100&
Private Const DT_NOFULLWIDTHCHARBREAK As Long = &H80000
Private Const DT_NOPREFIX As Long = &H800&
Private Const DT_PATH_ELLIPSIS As Long = &H4000&
Private Const DT_PREFIXONLY As Long = &H200000
Private Const DT_RIGHT As Long = &H2&
Private Const DT_SINGLELINE As Long = &H20&
Private Const DT_TABSTOP As Long = &H80&
Private Const DT_TOP As Long = &H0&
Private Const DT_VCENTER As Long = &H4&
Private Const DT_WORDBREAK As Long = &H10&
Private Const DT_WORD_ELLIPSIS As Long = &H40000
Public Declare Function DestroyCaret Lib "user32" () As Long
Public Declare Function CreateCaret Lib "user32" (ByVal hWnd As Long, ByVal hBitmap As Long, ByVal nWidth As Long, ByVal nHeight As Long) As Long
Public Declare Function ShowCaret Lib "user32" (ByVal hWnd As Long) As Long
Public Declare Function GetFocus Lib "user32" () As Long
Public Declare Function SetCaretPos Lib "user32" (ByVal X As Long, ByVal Y As Long) As Long
Public Declare Function HideCaret Lib "user32" (ByVal hWnd As Long) As Long
Const dv = 0.877551020408163
Public QUERYLIST As String
Public LASTQUERYLIST As Long
Private Declare Function GetSysColor Lib "user32" (ByVal nIndex As Long) As Long
Public releasemouse As Boolean
Public LASTPROG$
Public NORUN1 As Boolean
Public UseEnter As Boolean
Public dv20 As Single  ' = 24.5
Public dv15 As Long
Public mHelp As Boolean
Public abt As Boolean
Public vH_title$
Public vH_doc$
Public vH_x As Long
Public vH_y As Long
Public ttl As Boolean
Public Const SRCCOPY = &HCC0020
Public Release As Boolean
Private Declare Function SetBkMode Lib "gdi32" (ByVal Hdc As Long, ByVal nBkMode As Long) As Long
Declare Function BitBlt Lib "gdi32" (ByVal hDestDC As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hSrcDC As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal dwRop As Long) As Long
Declare Function RoundRect Lib "gdi32" (ByVal Hdc As Long, ByVal x1 As Long, ByVal y1 As Long, ByVal x2 As Long, ByVal y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long
Declare Function UpdateWindow Lib "user32" (ByVal hWnd As Long) As Long
Declare Function ScrollDC Lib "user32" (ByVal Hdc As Long, ByVal dX As Long, ByVal dY As Long, lprcScroll As RECT, lprcClip As RECT, ByVal hrgnUpdate As Long, lprcUpdate As RECT) As Long
Public LastErName As String
Public LastErNameGR As String
Public LastErNum As Long
Public LastErNum1 As Long, LastErNum2 As Long
Private Declare Sub PutMem1 Lib "msvbvm60" (ByVal Addr As Long, ByVal NewVal As Byte)
Private Declare Sub PutMem4 Lib "msvbvm60" (ByVal Addr As Long, ByVal NewVal As Long)

Type POINTAPI
        X As Long
        Y As Long
End Type
Private Declare Function GetTextExtentPoint32 Lib "gdi32" Alias "GetTextExtentPoint32W" (ByVal Hdc As Long, ByVal lpsz As Long, ByVal cbString As Long, lpSize As POINTAPI) As Long

Declare Function GetDC Lib "user32" (ByVal hWnd As Long) As Long
Declare Function PaintDesktop Lib "user32" (ByVal Hdc As Long) As Long
Declare Function SelectClipPath Lib "gdi32" (ByVal Hdc As Long, ByVal iMode As Long) As Long
  Public Const RGN_AND = 1
    Public Const RGN_COPY = 5
    Public Const RGN_DIFF = 4
    Public Const RGN_MAX = RGN_COPY
    Public Const RGN_MIN = RGN_AND
    Public Const RGN_OR = 2
    Public Const RGN_XOR = 3
Declare Function StrokePath Lib "gdi32" (ByVal Hdc As Long) As Long
Declare Function Polygon Lib "gdi32" (ByVal Hdc As Long, lpPoint As POINTAPI, ByVal nCount As Long) As Long
Declare Function PolyBezier Lib "gdi32.dll" (ByVal Hdc As Long, lppt As POINTAPI, ByVal cPoints As Long) As Long
Declare Function PolyBezierTo Lib "gdi32.dll" (ByVal Hdc As Long, lppt As POINTAPI, ByVal cCount As Long) As Long
Declare Function BeginPath Lib "gdi32" (ByVal Hdc As Long) As Long
Declare Function EndPath Lib "gdi32" (ByVal Hdc As Long) As Long
Declare Function FillPath Lib "gdi32" (ByVal Hdc As Long) As Long
Declare Function StrokeAndFillPath Lib "gdi32" (ByVal Hdc As Long) As Long

Public PLG() As POINTAPI
Private Declare Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" ( _
    lpvDest As Any, lpvSource As Any, ByVal cbCopy As Long)

Public lckfrm As Long
Public NERR As Boolean
Public moux As Single, mouy As Single, MOUB As Long
Public mouxb As Single, mouyb As Single, MOUBb As Long
Public vol As Long
Public MyFont As String, myCharSet As Integer, myBold As Boolean
Public FFONT As String

Public escok As Boolean
Public NOEDIT As Boolean
Public CancelEDIT As Boolean

Global Const HWND_TOP = 0

Global Const HWND_TOPMOST = -1
Global Const HWND_NOTOPMOST = -2
Global Const SWP_NOACTIVATE = &H10
Global Const SWP_SHOWWINDOW = &H40
Declare Sub SetWindowPos Lib "user32" (ByVal hWnd As Long, ByVal hWndInsertAfter As Long, ByVal X As Long, ByVal Y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long)
Declare Function ExtFloodFill Lib "gdi32" (ByVal Hdc As Long, ByVal X As Long, ByVal Y As Long, ByVal crColor As Long, ByVal wFillType As Long) As Long
Public Const FLOODFILLSURFACE = 1
Public Const FLOODFILLBORDER = 0

Public avifile As String
Public BigPi As Variant
Public Const Pi = 3.14159265358979
Public Const PI2 = 6.28318530717958
Public EditTabWidth As Long, ReportTabWidth As Long
Public result As Long, Use13 As Boolean
Public mcd As String
Public NOEXECUTION As Boolean, RoundDouble As Boolean
Public QRY As Boolean, GFQRY As Boolean
Public nomore As Boolean
Private Declare Function CallWindowProc _
 Lib "user32.dll" Alias "CallWindowProcW" ( _
 ByVal lpPrevWndFunc As Long, _
 ByVal hWnd As Long, _
 ByVal Msg As Long, _
 ByVal wParam As Long, _
 ByVal lParam As Long) As Long

'== MCI Wave API Declarations ================================================
Public ExTarget As Boolean
''Public pageframe As Long
''Public basicpageframe As Long

Public q() As target
Public Targets As Boolean
Public SzOne As Single
Public PenOne As Long
Public NoAction As Boolean
Public StartLine As Boolean
Public www&
Public WWX&, ins&
Public INK$, MINK$
Public MKEY$
Public Type target
    Comm As String
    Tag As String ' specified by id
    id As Long ' function id
    ' THIS IS POINTS AT CHARACTER RESOLUTION
    SZ As Single
    ' SO WE NEED SZ
    lX As Long
    lY As Long
    tx As Long
    ty As Long
    back As Long 'background fill color' -1 no fill
    fore As Long 'border line ' -1 no line
    barC As Long
    Enable As Boolean ' in use
    Vertical As Boolean
    pen As Long
    layer As Long
    Xt As Long
    Yt As Long
    sUAddTwipsTop As Long
    topval As Long  ' 0 to 10000 (10000/10000= width of target
    botval As Long
    imagesize As Long
    drawimage As MemBlock
End Type

Public here$, PaperOne As Long
Const PROOF_QUALITY = 2
Const NONANTIALIASED_QUALITY = 3
Private Type LOGFONT
  lfHeight As Long
  lfWidth As Long
  lfEscapement As Long
  lfOrientation As Long
  lfWeight As Long
  lfItalic As Byte
  lfUnderline As Byte
  lfStrikeOut As Byte
  lfCharSet As Byte
  lfOutPrecision As Byte
  lfClipPrecision As Byte
  lfQuality As Byte
  lfPitchAndFamily As Byte
' lfFaceName(LF_FACESIZE) As Byte 'THIS WAS DEFINED IN API-CHANGES MY OWN
  lfFaceName As String * 33
End Type
Private Declare Function CreateRoundRectRgn Lib "gdi32" (ByVal x1 As Long, ByVal y1 As Long, ByVal x2 As Long, ByVal y2 As Long, ByVal X3 As Long, ByVal Y3 As Long) As Long

Private Declare Function PathToRegion Lib "gdi32" (ByVal Hdc As Long) As Long
Private Declare Function SetWindowRgn Lib "user32" (ByVal hWnd As Long, ByVal hRgn As Long, ByVal bRedraw As Boolean) As Long
Private Declare Function CreateFontIndirect Lib "gdi32" Alias "CreateFontIndirectA" (lpLogFont As LOGFONT) As Long
Private Declare Function SelectObject Lib "gdi32" (ByVal Hdc As Long, ByVal hObject As Long) As Long

' OCTOBER 2000
Public dStyle As Long
' Jule 2001
Const DC_ACTIVE = &H1
Const DC_ICON = &H4
Const DC_TEXT = &H8
Const BDR_SUNKENOUTER = &H2
Const BDR_RAISEDINNER = &H4
Const EDGE_ETCHED = (BDR_SUNKENOUTER Or BDR_RAISEDINNER)
Const BF_BOTTOM = &H8
Const BF_LEFT = &H1
Const BF_RIGHT = &H4
Const BF_TOP = &H2
Const BF_RECT = (BF_LEFT Or BF_TOP Or BF_RIGHT Or BF_BOTTOM)
Const DFC_BUTTON = 4
Const DFC_POPUPMENU = 5            'Only Win98/2000 !!
Const DFCS_BUTTON3STATE = &H10
Const DC_GRADIENT = &H20          'Only Win98/2000 !!

Private Declare Function DrawCaption Lib "user32" (ByVal hWnd As Long, ByVal Hdc As Long, pcRect As RECT, ByVal un As Long) As Long
Private Declare Function DrawEdge Lib "user32" (ByVal Hdc As Long, qrc As RECT, ByVal edge As Long, ByVal grfFlags As Long) As Long
Private Declare Function DrawFocusRect Lib "user32" (ByVal Hdc As Long, lpRect As RECT) As Long
Private Declare Function DrawFrameControl Lib "user32" (ByVal Hdc As Long, lpRect As RECT, ByVal un1 As Long, ByVal un2 As Long) As Long
Private Declare Function DrawText Lib "user32" Alias "DrawTextW" (ByVal Hdc As Long, ByVal lpStr As Long, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long) As Long
Private Declare Function DrawTextEx Lib "user32" Alias "DrawTextExW" (ByVal Hdc As Long, ByVal lpsz As Long, ByVal nCount As Long, lpRect As RECT, ByVal wFormat As Long, ByVal lpDrawTextParams As Long) As Long
Private Declare Function SetRect Lib "user32" (lpRect As RECT, ByVal x1 As Long, ByVal y1 As Long, ByVal x2 As Long, ByVal y2 As Long) As Long
Private Declare Function OffsetRect Lib "user32" (lpRect As RECT, ByVal X As Long, ByVal Y As Long) As Long
''API declarations
' old api..
Private Declare Function AddFontResource Lib "gdi32" Alias "AddFontResourceW" (ByVal lpFileName As Long) As Long
Private Declare Function RemoveFontResource Lib "gdi32" Alias "RemoveFontResourceW" (ByVal lpFileName As Long) As Long
Public Declare Function GetCursorPos Lib "user32" (lpPoint As POINTAPI) As Long
Private Declare Function GetAsyncKeyState Lib "user32" _
    (ByVal vKey As Long) As Long
Public TextEditLineHeight As Long
Public LablelEditLineHeight As Long
Private Const Utf8CodePage As Long = 65001
Public Type DRAWTEXTPARAMS
     cbSize As Long
     iTabLength As Long
     iLeftMargin As Long
     iRightMargin As Long
     uiLengthDrawn As Long
End Type
Public tParam As DRAWTEXTPARAMS

Public Const TA_LEFT = 0
Public Const TA_RIGHT = 2
Public Const TA_CENTER = 6
Public Const TA_RTLREADING = &H100&
Public Declare Function SetTextJustification Lib "gdi32" (ByVal Hdc As Long, ByVal nBreakExtra As Long, ByVal nBreakCount As Long) As Long
Public Declare Function SetTextAlign Lib "gdi32" (ByVal Hdc As Long, ByVal wFlags As Long) As Long
Public Declare Function TabbedTextOut Lib "user32" Alias "TabbedTextOutW" (ByVal Hdc As Long, ByVal X As Long, ByVal Y As Long, ByVal lpString As Long, ByVal nCount As Long, ByVal nTabPositions As Long, ByRef lpnTabStopPositions As Long, ByVal nTabOrigin As Long) As Long
Public Declare Function TextOut Lib "gdi32" Alias "TextOutW" (ByVal Hdc As Long, ByVal X As Long, ByVal Y As Long, ByVal lpString As Long, ByVal nCount As Long) As Long
Public Declare Function GetTabbedTextExtent Lib "user32" Alias "GetTabbedTextExtentW" (ByVal Hdc As Long, ByVal lpString As Long, ByVal nCount As Long, ByVal nTabPositions As Long, lpnTabStopPositions As Long) As Long
Public Form3AppIcon As StdPicture
Function CheckItemType(bstackstr As basetask, v As Variant, A$, r$, Optional ByVal wasarr As Boolean = False, Optional UseCase As Boolean) As Boolean
Dim usehandler As mHandler, fastcol As FastCollection, pppp As mArray, w1 As Long, p As Variant, s$
Dim sr As refArray
UseCase = False
CheckItemType = True
Dim vv
If MyIsObject(v) Then
    Set vv = v
Else
   r$ = VarTypeName(v)
   CheckItemType = FastSymbol(A$, ")")
   Exit Function
End If
againtype:
        r$ = Typename(vv)
        If r$ = "mHandler" Then
            Set usehandler = vv
            Select Case usehandler.T1
            Case 1
            If TypeOf usehandler.objref Is mHandler Then
            Set usehandler = usehandler.objref
            Set fastcol = usehandler.objref
            Else
            Set fastcol = usehandler.objref
            End If
                If FastSymbol(A$, ",") Then
contHandler:

                    If IsExp(bstackstr, A$, p) Then
                        If myVarType(p, vbString) Then s$ = p: GoTo ch1234
                        If Not fastcol.Find(p) Then GoTo keynotexist
                        If fastcol.IsObj Then
                            Set vv = fastcol.ValueObj
                            GoTo againtype
                        Else
                            wasarr = True
                            GoTo Checkit
                        End If
                    ElseIf IsStrExp(bstackstr, A$, s$, Len(bstackstr.tmpstr) = 0) Then
ch1234:
                        If Not fastcol.Find(s$) Then GoTo keynotexist
                        If fastcol.IsObj Then
                            Set vv = fastcol.ValueObj
                            GoTo againtype
                        Else
                            If fastcol.structLen > 0 Then GoTo Checkit
                                r$ = Typename(fastcol.Value)
                            End If
                        Else
                            MissParam A$
                            CheckItemType = False
                            Exit Function
keynotexist:
                            errOutOfLimit
                            CheckItemType = False
                            Exit Function
                    End If
                ElseIf FastSymbol(A$, ")(", , 2) Then
                    GoTo contHandler
   
                Else
                    ' new
Checkit:
                    If fastcol.structLen > 0 Then
                                    Select Case fastcol.sValue
                                    Case Is < 0
                                        r$ = "String"
                                    Case 1
                                        r$ = "Byte"
                                    Case 2
                                        r$ = "Integer"
                                    Case 4
                                        r$ = "Long"
                                    Case 8
                                        r$ = "LongLong"  ' can be double or two longs or ...etc
                                    Case Else
                                        r$ = "Structure"
                                    End Select
                    ElseIf wasarr Then
                    r$ = Typename(fastcol.Value)
                    
                    ElseIf FastSymbol(A$, "!") Then
                        If fastcol.IsQueue Then
                            r$ = "Queue"
                        Else
                            r$ = "List"
                        End If
                    Else
                        r$ = "Inventory"
                    End If
                End If
            Case 2
                
                If Left$(A$, 1) = "|" Then
                If TakeOffset(bstackstr, usehandler, A$, p) Then
                    r$ = Typename(p)
                Else
                    MyEr "unknown structure field", "Üãíùóôï ðåäßï äïìÞò"
                    r$ = ""
                    CheckItemType = False
                    Exit Function
                End If
                Else
                    r$ = "Buffer"
                    
                End If
            Case 3
                w1 = usehandler.indirect
                If w1 > -1 And w1 <= var2used Then
                                r$ = VarTypeName(var(w1))
                                If r$ = "mHandler" Then Set vv = var(w1): GoTo againtype
                    Else
                            r$ = Typename(usehandler.objref)
                                       If FastSymbol(A$, ",") Then
contarr0:
                                        If r$ = "mArray" Then

                                            Set pppp = usehandler.objref
                                                If IsExp(bstackstr, A$, p, nostring:=True) Then
                                                   pppp.Index = p
                                                    If MyIsObject(pppp.Value) Then
                                                         Set vv = pppp.Value
                                                         wasarr = False
                                                         GoTo againtype
                                                    Else
                                                        r$ = VarTypeName(pppp.Value)
                                                    End If
                                                Else
                                                MissParam A$
                                                CheckItemType = False
                                                Exit Function
                                            End If
                                        ElseIf FastSymbol(A$, ")(", , 2) Then
                                        GoTo contarr0
            
                                        Else
                                                MyEr "Use STACKTYPE$() ", " ×ñçóéìïðïßçóå ôçí ÓÙÑÏÕÔÕÐÏÓ$()"
                                                CheckItemType = False
                                                Exit Function
                                        End If
                                        
                                        End If
                                        
                                        End If
                                    
            Case 4
                    UseCase = True
                    r$ = usehandler.objref.EnumName
            Case Else
                Set usehandler = vv
                r$ = Typename(usehandler.objref)
                Set usehandler = Nothing
            End Select
        ElseIf Typename(vv) = "PropReference" Then
                p = vv.Value
        
            r$ = Typename$(vv.lastobjfinal)
            If r$ = "Nothing" Then
            If VarType(p) <> vbEmpty Then
            r$ = VarTypeName(p)
            End If
            End If
        ElseIf Typename(vv) = "mArray" Then
        
         If FastSymbol(A$, ",") Then
contarr1:
            Set pppp = vv

            If IsExp(bstackstr, A$, p, nostring:=True) Then

                pppp.Index = p
                If MyIsObject(pppp.Value) Then
                     Set vv = pppp.Value
                     wasarr = False
                     GoTo againtype
                Else
                    r$ = VarTypeName(pppp.Value)
                End If
                Else
                MissParam A$
                CheckItemType = False
                Exit Function
                End If
            ElseIf FastSymbol(A$, ")(", , 2) Then
          GoTo contarr1
            Else
            r$ = "mArray"
            End If
        ElseIf Typename(vv) = "lambda" Then
        If FastSymbol(A$, ")(", , 2) Then
            Set bstackstr.lastobj = vv
            Set bstackstr.lastpointer = Nothing
            s$ = BlockParam(A$)
            If Len(s$) > 0 Then Mid$(A$, 1, Len(s$)) = space$(Len(s$))
            s$ = s$ + ")"
            If CallLambdaASAP(bstackstr, s$, p, False) Then
                If bstackstr.lastobj Is Nothing Then
                    r$ = Typename$(p)
                Else
                    Set vv = bstackstr.lastobj
                    Set bstackstr.lastobj = Nothing
                    GoTo againtype
                End If
            Else
            Exit Function
            End If
            Else
            r$ = "lambda"
            End If
        ElseIf Typename(vv) = "Group" Then
        If FastSymbol(A$, ")(", , 2) Then
            s$ = BlockParam(A$)
            If Len(s$) > 0 Then Mid$(A$, 1, Len(s$)) = space$(Len(s$))
            If FastSymbol(s$, "@") Then
            s$ = NLtrim(s$)
                    If Len(s$) > 0 Then
                        Set pppp = New mArray
                        pppp.Arr = False
                        Set pppp.GroupRef = vv
                        Set vv = bstackstr.soros
                        Set bstackstr.Sorosref = New mStiva
                        
                        SpeedGroup bstackstr, pppp, "FOR", "", "{Push type$(" + String$(bstackstr.ForLevel + 1, ".") + s$ + ")}", -2
                        If bstackstr.soros.IsEmpty Then
                           Set bstackstr.Sorosref = vv
                           Exit Function
                        Else
                           r$ = bstackstr.soros.PopStr
                        End If
                        Set bstackstr.Sorosref = vv
                     Else
                        SyntaxError
                        Exit Function
                End If
                ' check member
            ElseIf vv.IamApointer Then
                r$ = "Group"   ' not decide yet
            ElseIf vv.HasStrValue Then
                r$ = "String"
            ElseIf vv.HasValue Then
            Set pppp = New mArray
            pppp.Arr = False
            Set pppp.GroupRef = vv
             If SpeedGroup(bstackstr, pppp, "VAL", "", s$ + ")", -2) = 1 Then
                If bstackstr.lastobj Is Nothing Then
                    r$ = Typename$(bstackstr.LastValue)
                Else
                    Set vv = bstackstr.lastobj
                    Set bstackstr.lastobj = Nothing
                    GoTo againtype
                End If

             End If

            End If
        End If
        ElseIf Typename(vv) = "RefArray" Then
            Set sr = vv
            If FastSymbol(A$, ",") Then
                If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                    w1 = CLng(Abs(p))
                        p = VarType(sr(0, w1))
                        If p = 20 Then
                            r$ = "Long Long"
                        ElseIf p = vbObject Then
                        If sr(0, w1) Is Nothing Then
                            r$ = "Object"
                        Else
                            r$ = Typename(sr(0, w1))
                        End If
                        Else
                        r$ = Typename(sr(0, w1))
                        End If
                Else
                    MissParam A$
                    Exit Function
                End If
            Else
             r$ = "RefArray"
           
            End If
        
        End If
        Set bstackstr.lastobj = Nothing
        Set bstackstr.lastpointer = Nothing
        While FastSymbol(A$, "!")
        Wend
        CheckItemType = FastSymbol(A$, ")", True)
End Function

Function M2000color(q) As Long
Dim w1 As Long
For w1 = 0 To 15
If QBColor(w1) = q Then
M2000color = w1: Exit Function
End If
Next w1
M2000color = -(q And &HFFFFFF)
End Function

Sub NoValidCodePage()
    MyEr "Invalid code page", "áíýðáñêôç êùäéêïóåëßäá"
End Sub
Sub NoValidLocale()
    MyEr "Invalid Locale ID", "áíýðáñêôïò êùäéêüò ôïðéêïý"
End Sub

Public Function Utf16toUtf8(s As String) As Byte()
    ' code from vbforum
    ' UTF-8 returned to VB6 as a byte array (zero based) because it's pretty useless to VB6 as anything else.
    Dim iLen As Long
    Dim bbBuf() As Byte
    '
    iLen = WideCharToMultiByte(Utf8CodePage, 0, StrPtr(s), Len(s), 0, 0, 0, 0)
    If iLen = 0 Then bbBuf() = vbNullString: Exit Function
    ReDim bbBuf(0 To iLen - 1) ' Will be initialized as all &h00.
    iLen = WideCharToMultiByte(Utf8CodePage, 0, StrPtr(s), Len(s), VarPtr(bbBuf(0)), iLen, 0, 0)
    Utf16toUtf8 = bbBuf
End Function
Public Function KeyPressedLong(ByVal VirtKeyCode As Long) As Long
On Error GoTo KEXIT
If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow = Screen.ActiveForm.hWnd Then
KeyPressedLong = GetAsyncKeyState(VirtKeyCode)
End If
End If
KEXIT:
End Function
Public Function KeyPressed2(ByVal VirtKeyCode As Long, ByVal VirtKeyCode2 As Long) As Boolean
On Error GoTo KEXIT
If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow = Screen.ActiveForm.hWnd Then
KeyPressed2 = CBool((GetAsyncKeyState(VirtKeyCode) And &H8000&) = &H8000&) And CBool((GetAsyncKeyState(VirtKeyCode2) And &H8000&) = &H8000&)
End If
End If
KEXIT:
End Function
Public Function KeyPressed(ByVal VirtKeyCode As Long) As Boolean
On Error GoTo KEXIT
If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow = Screen.ActiveForm.hWnd Then
KeyPressed = CBool((GetAsyncKeyState(VirtKeyCode) And &H8000&) = &H8000&)
End If
End If
KEXIT:
End Function
Public Function mouse2() As Long
On Error GoTo MEXIT
If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow = Screen.ActiveForm.hWnd Then

mouse2 = (UINT(GetAsyncKeyState((1))) And &HFF) + (UINT(GetAsyncKeyState((2))) And &HFF) * 2 + (UINT(GetAsyncKeyState((4))) And &HFF) * 4
End If
End If
MEXIT:
End Function
Public Function mouse() As Long
On Error GoTo MEXIT
If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow = Screen.ActiveForm.hWnd Then
''If Screen.ActiveForm Is Form1 Then If Form1.lockme Then Exit Function

mouse = -1 * CBool((GetAsyncKeyState(1) And &H8000&) = &H8000&) - 2 * CBool((GetAsyncKeyState(2) And &H8000&) = &H8000&) - 4 * CBool((GetAsyncKeyState(4) And &H8000&) = &H8000&)
End If
End If
MEXIT:
End Function

Public Function MOUSEX(Optional Offset As Long = 0) As Long
Static X As Long
On Error GoTo MOUSEX
Dim tp As POINTAPI
MOUSEX = X
If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow = Screen.ActiveForm.hWnd Then
   GetCursorPos tp
   X = tp.X * dv15 - Offset
  MOUSEX = X
  End If
End If
MOUSEX:
End Function
Public Function MOUSEY(Optional Offset As Long = 0) As Long
Static Y As Long
On Error GoTo MOUSEY
Dim tp As POINTAPI
MOUSEY = Y
If Not Screen.ActiveForm Is Nothing Then
If GetForegroundWindow = Screen.ActiveForm.hWnd Then
   GetCursorPos tp
   Y = tp.Y * dv15 - Offset
   MOUSEY = Y
  End If
End If
MOUSEY:
End Function
Public Sub OnlyInAGroup()
    MyEr "Only in a group", "Ìüíï óå ìéá ïìÜäá"
End Sub
Public Sub WrongOperator()
MyEr "Wrong operator", "ëÜèïò ôåëåóôÞò"
End Sub
Public Sub NoOperatorForThatObject(ss$)
If ss$ = "g" Then ss$ = "<="
    MyEr "Object not support operator " + ss$, "Ôï áíôéêåßìåíï äåí õðïóôçñßæåé ôï ôåëåóôÞ " + ss$
End Sub
Public Sub NoStackObjectFound(A$)
    MyErMacro A$, "Not stack object found", "Äåí âñÞêá áíôéêåßìåíï óùñïý"
End Sub
Public Sub NoStackObjectToMerge()
    MyEr "Not stack object to merge", "Äåí âñÞêá áíôéêåßìåíï óùñïý íá åíþóù"
End Sub
Public Sub Unsignlongnegative(A$)
    MyErMacro A$, "Unsigned long can't be negative", "Ï áêÝñáéïò ÷ùñßò ðñïóçìï äåí ìðïñåß íá åßíáé áñíçôéêüò"
End Sub
Public Sub Unsignlongfailed(A$)
MyErMacro A$, "Unsigned long to sign failed", "Ç ìåôáôñïðÞ áêÝñáéïõ ÷ùñßò ðñüóçìï óå áêÝñáéï ìå ðñüóçìï, áðÝôõ÷å"
End Sub
Public Sub NoProperObject()
MyEr "This object not supported", "Áõôü ôï áíôéêåßìåíï äåí õðïóôçñßæåôáé"
End Sub

Public Sub MyEr(er$, ergr$)
Dim mName$
If skiperror Then Exit Sub
If Not er$ = vbNullString Then
    If Not lckfrm Then
        If SecureNames Then
            GetThisModuleName mName$
        Else
            mName$ = here$
        End If
        If mName$ <> vbNullString Then mName$ = " [" + mName$ + "]"
        If pagio$ = "GREEK" Then
            mName$ = (timeGetTime And &HFFFFF) & ": " + ergr$ + mName$
        Else
            mName$ = (timeGetTime And &HFFFFF) & ": " + er$ + mName$
        End If
        
        Errorlog.AppendParagraphOneLine mName$
        If Form4Loaded Then

        If vH_title$ = "Error Log" Or vH_title$ = "Êáôáãñáöéêü Ëáèþí" Then
        Form4.label1.SelLengthSilent = 0
        Form4.label1.SelStartSilent = Form4.label1.Length + 1
        Form4.label1.InsertTextNoRender = vbCrLf + mName$
        
        'vHelp Not Form4.Visible
        Form4.label1.SetRowColumn Form4.label1.glistN.listcount - 1, 1
        Form4.label1.ReColor
            End If

        End If
        If Form2.Visible Then
                 If stoponerror And Not STbyST Then
                    trace = True
                    STq = False
                    STbyST = False
 Form2.Busy = False
        Do
            BLOCKkey = False
            If Not IsWine Then If Form2.Process.Owner.Visible Then Form2.Process.Owner.Refresh
            ProcTask2 Form2.Process
        Loop Until STbyST Or STq Or STEXIT Or bypassST Or NOEXECUTION Or myexit(Form2.Process) Or Not Form2.Visible

        If Not TaskMaster Is Nothing Then
           If TaskMaster.QueueCount > 0 And Not TaskMaster.Processing Then TaskMaster.StartProcess
        End If
        If Not STEXIT Then
            If Not STq Then
                Form2.gList4.ListIndex = 0
            End If
        End If
        STq = False
        If STEXIT Then
            NOEXECUTION = True
            trace = False
            STEXIT = False
            
            Form2.Busy = False
        ElseIf STbyST Then
            
            Exit Sub
        End If
                End If
         End If
    End If
End If
If Left$(LastErName, 1) = Chr(0) Then
    LastErName = vbNullString
    LastErNameGR = vbNullString
End If
If er$ = vbNullString Then
LastErNum = 0
LastErNum1 = 0
LastErName = vbNullString
LastErNameGR = vbNullString
Else
er$ = Split(er$, ChrW(&H1FFF))(0)
ergr$ = Split(ergr$, ChrW(&H1FFF))(0)
If rinstr(er$, " ") = 0 Then
LastErNum = 1001
Else

LastErNum = val(" " + Mid$(er$, rinstr(er$, " ")) + ".0")
End If
If LastErNum = 0 Then LastErNum = -1
LastErNum1 = LastErNum

If InStr("*" + LastErName, NLtrim$(er$)) = 0 Then
LastErName = RTrim$(LastErName) + " " + NLtrim$(er$)
LastErNameGR = RTrim$(LastErNameGR) + " " + NLtrim$(ergr$)
End If
End If
End Sub
Sub UnknownVariable1(A$, v$)
Dim I As Long
I = rinstr(v$, "." + ChrW(8191))
If I > 0 Then
    I = rinstr(v$, ".")
    MyErMacro A$, "Unknown Variable " + Mid$(v$, I), "¢ãíùóôç ìåôáâëçôÞ " + Mid$(v$, I)
Else
    I = rinstr(v$, "».")
    If I > 0 Then
        MyErMacro A$, "Unknown Variable " + Mid$(v$, I + 2), "¢ãíùóôç ìåôáâëçôÞ " + Mid$(v$, I + 2)
    Else
        I = rinstr(v$, ChrW(8191))
    If I > 0 Then
        I = InStr(I + 1, v$, ".")
        If I > 0 Then
            MyErMacro A$, "Unknown Variable " + Mid$(v$, I + 1), "¢ãíùóôç ìåôáâëçôÞ " + Mid$(v$, I + 1)
        Else
            MyErMacro A$, "Unknown Variable", "¢ãíùóôç ìåôáâëçôÞ"
        End If
    Else
        MyErMacro A$, "Unknown Variable " + v$, "¢ãíùóôç ìåôáâëçôÞ " + v$
    End If
    End If
End If

End Sub
Sub UnknownProperty1(A$, v$)
MyErMacro A$, "Unknown Property " + v$, "¢ãíùóôç éäéüôçôá " + v$
End Sub
Sub UnknownMethod1(A$, v$)
 MyErMacro A$, "unknown method/array  " + v$, "¢ãíùóôç ìÝèïäïò/ðßíáêáò " + v$
End Sub
Sub UnknownFunction1(A$, v$)
 MyErMacro A$, "unknown function/array " + v$, "¢ãíùóôç óõíÜñôçóç/ðßíáêáò " + v$
End Sub

Sub InternalError()
 MyEr "Internal Error", "Åóùôåñéêü Ðñüâëçìá"
End Sub
Public Function LoadFont(ByVal FntFileName As String) As Boolean
    Dim FntRC As Long
    If FontList Is Nothing Then
    Set FontList = New FastCollection
    End If
    FntFileName = mylcasefILE(FntFileName)
    If FontList.ExistKey(FntFileName) Then
        LoadFont = True
    Else
        FntRC = AddFontResource(StrPtr(FntFileName))
        If FntRC = 0 Then 'no success
         LoadFont = False
        Else 'success
        FontList.AddKey FntFileName
     LoadFont = True
    End If
        End If
End Function
'FntFileName includes also path
Public Function RemoveFont(ByVal FntFileName As String) As Boolean
     Dim rc As Long, Inc As Integer
     If FontList Is Nothing Then Exit Function
        FntFileName = mylcasefILE(FntFileName)
     If FontList.ExistKey(FntFileName) Then
     Do
       rc = RemoveFontResource(StrPtr(FntFileName))
       Inc = Inc + 1
     Loop Until rc = 0 Or Inc > 10
     If rc = 0 Then
        FontList.Remove (FntFileName)
        RemoveFont = True
     End If
    End If
End Function
Public Sub RemoveAllFonts()
Dim I As Long, FntFileName As String, Inc As Integer, rc As Long
If FontList Is Nothing Then Exit Sub
For I = 0 To FontList.count - 1
    FontList.Index = I
    FntFileName = FontList.KeyToString
    Inc = 0
    FntFileName = mylcasefILE(FntFileName)
    Do
      rc = RemoveFontResource(StrPtr(FntFileName))
      Inc = Inc + 1
    Loop Until rc = 0 Or Inc > 10
Next I
Set FontList = Nothing
End Sub



Sub myform(M As Object, X As Long, Y As Long, x1 As Long, y1 As Long, Optional t As Boolean = False, Optional factor As Single = 1)
Dim hRgn As Long
If y1 = 0 Then Exit Sub
M.move X, Y, x1, y1
If Int(25 * factor) > 2 Then
M.ScaleMode = vbPixels

hRgn = CreateRoundRectRgn(0, 0, M.ScaleX(x1, 1, 3), M.ScaleY(y1, 1, 3), 25 * factor, 25 * factor)
SetWindowRgn M.hWnd, hRgn, t
'DeleteObject hRgn
M.ScaleMode = vbTwips

M.Line (0, 0)-(M.ScaleWidth - dv15, M.ScaleHeight - dv15), M.BackColor, BF
End If
End Sub

Sub MyRect(M As Object, mb As basket, x1 As Long, y1 As Long, way As Long, par As Variant, Optional zoom As Long = 0)
Dim r As RECT, b$
With mb
Dim x0&, y0&, X As Long, Y As Long
GetXYb M, mb, x0&, y0&
X = M.ScaleX(x0& * .Xt - DXP, 1, 3)
Y = M.ScaleY(y0& * .Yt - DYP, 1, 3)
If x1 >= .mX Then x1 = M.ScaleX(M.ScaleWidth, 1, 3) Else x1 = M.ScaleX(x1 * .Xt, 1, 3)
If y1 >= .mY Then y1 = M.ScaleY(M.ScaleHeight, 1, 3) Else y1 = M.ScaleY(y1 * .Yt + .Yt, 1, 3)

SetRect r, X + zoom, Y + zoom, x1 - zoom, y1 - zoom
Select Case way
Case 0
DrawEdge M.Hdc, r, CLng(par) Mod 256, CLng(par) \ 256
Case 1
DrawCaption M.hWnd, M.Hdc, r, CLng(par)
Case 2
DrawEdge M.Hdc, r, CLng(par), BF_RECT
Case 3
DrawFocusRect M.Hdc, r
Case 4
DrawFrameControl M.Hdc, r, DFC_BUTTON, DFCS_BUTTON3STATE
Case 5
b$ = Replace(CStr(par), ChrW(&HFFFFF8FB), ChrW(&H2007))
DrawText M.Hdc, StrPtr(b$), Len(CStr(par)), r, DT_CENTER + DT_NOCLIP
Case 6
DrawFrameControl M.Hdc, r, CLng(par) Mod 256, CLng(par) \ 256
Case Else
k1 = 0
MyDoEvents1 Form1
End Select
LCTbasket M, mb, y0&, x0&
End With
End Sub
Sub MyFill(M As Object, x1 As Long, y1 As Long, way As Long, par As Variant, Optional zoom As Long = 0)
Dim r As RECT, b$
Dim X As Long, Y As Long
Const sp$ = " "
With players(GetCode(M))
x1 = .XGRAPH + x1
y1 = .YGRAPH + y1
x1 = M.ScaleX(x1, 1, 3)
y1 = M.ScaleY(y1, 1, 3)
X = M.ScaleX(.XGRAPH, 1, 3)
Y = M.ScaleY(.YGRAPH, 1, 3)
SetRect r, X + zoom, Y + zoom, x1 - zoom, y1 - zoom
Select Case way
Case 0
DrawEdge M.Hdc, r, CLng(par) Mod 256, CLng(par) \ 256
Case 1
DrawCaption M.hWnd, M.Hdc, r, CLng(par)
Case 2
DrawEdge M.Hdc, r, CLng(par), BF_RECT
Case 3
DrawFocusRect M.Hdc, r
Case 4
DrawFrameControl M.Hdc, r, DFC_BUTTON, DFCS_BUTTON3STATE
Case 5
b$ = Replace(CStr(par), ChrW(&HFFFFF8FB), ChrW(&H2007))
DrawText M.Hdc, StrPtr(b$), Len(CStr(par)), r, DT_CENTER + DT_NOCLIP
Case 6
DrawFrameControl M.Hdc, r, CLng(par) Mod 256, CLng(par) \ 256
Case Else
k1 = 0
MyDoEvents1 Form1
End Select
End With
End Sub
' ***************


Public Sub TextColor(D As Object, tc As Long)
D.ForeColor = tc And &HFFFFFF
End Sub
Public Sub TextColorB(D As Object, mb As basket, tc As Long)
D.ForeColor = tc And &HFFFFFF
mb.mypen = D.ForeColor
End Sub

Public Sub LCTNo(DqQQ As Object, ByVal Y As Long, ByVal X As Long)

''DqQQ.CurrentX = x * Xt
''DqQQ.CurrentY = y * Yt + UAddTwipsTop
''xPos = x
''yPos = y
End Sub

Public Sub LCTbasketCur(DqQQ As Object, mybasket As basket)
With mybasket
DqQQ.currentX = .curpos * .Xt
DqQQ.currentY = .currow * .Yt + .uMineLineSpace

End With
End Sub
Public Sub LCTbasket(DqQQ As Object, mybasket As basket, ByVal Y As Long, ByVal X As Long)
DqQQ.currentX = X * mybasket.Xt
DqQQ.currentY = Y * mybasket.Yt + mybasket.uMineLineSpace
mybasket.curpos = X
mybasket.currow = Y
End Sub
Public Sub nomoveLCTC(dqq As Object, mb As basket, Y As Long, X As Long, t&)
Dim oldx&, oldy&
With mb
oldx& = dqq.currentX
oldy& = dqq.currentY
dqq.DrawMode = vbXorPen
If t& = 1 Then
dqq.Line (X * .Xt, Int(Y * .Yt + .uMineLineSpace))-(X * .Xt + .Xt - DXP, Y * .Yt - .uMineLineSpace + .Yt - DYP), (mycolor(.mypen) Xor dqq.BackColor), BF
Else
dqq.Line (X * .Xt, Int((Y + 1) * .Yt - .uMineLineSpace - .Yt \ 6 - DYP))-(X * .Xt + .Xt - DXP, (Y + 1) * .Yt - .uMineLineSpace - DYP), (mycolor(.mypen) Xor dqq.BackColor), BF
End If
dqq.DrawMode = vbCopyPen
dqq.currentX = oldx&
dqq.currentY = oldy&
End With
End Sub

Public Sub oldLCTCB(dqq As Object, mb As basket, t&)

dqq.DrawMode = vbXorPen
With mb
'QRY = Not QRY
If IsWine Then
If t& = 1 Then
dqq.Line (.curpos * .Xt, .currow * .Yt + .uMineLineSpace)-(.curpos * .Xt + .Xt, .currow * .Yt - .uMineLineSpace + .Yt), (mycolor(.mypen) Xor dqq.BackColor), BF
Else
dqq.Line (.curpos * .Xt, (dqq.ScaleY((.currow + 1) * .Yt - .uMineLineSpace, 1, 3) - .Yt \ DYP \ 6 - 1) * DYP)-(.curpos * .Xt + .Xt - DXP, (.currow + 1) * .Yt - .uMineLineSpace - DYP), (mycolor(.mypen) Xor dqq.BackColor), BF

End If
Else
If t& = 1 Then
dqq.Line (.curpos * .Xt, .currow * .Yt + .uMineLineSpace)-(.curpos * .Xt + .Xt, .currow * .Yt - .uMineLineSpace + .Yt), &HFFFFFF, BF
Else
dqq.Line (.curpos * .Xt, (dqq.ScaleY((.currow + 1) * .Yt - .uMineLineSpace, 1, 3) - .Yt \ DYP \ 6 - 1) * DYP)-(.curpos * .Xt + .Xt - DXP, (.currow + 1) * .Yt - .uMineLineSpace - DYP), &HFFFFFF, BF
End If
End If
End With
dqq.DrawMode = vbCopyPen
End Sub
Public Sub LCTCnew(dqq As Object, mb As basket, Y As Long, X As Long)
DestroyCaret
With mb
CreateCaret dqq.hWnd, 0, dqq.ScaleX(.Xt, 1, 3), dqq.ScaleY((.Yt - .uMineLineSpace * 2) * 0.2, 1, 3)
SetCaretPos dqq.ScaleX(X * .Xt, 1, 3), dqq.ScaleY((Y + 0.8) * .Yt, 1, 3)
End With
End Sub
Public Sub LCTCB(dqq As Object, mb As basket, t&)
With mb
If t& = -1 Or Not Form1.ActiveControl Is dqq Then
        If Not t& = -1 Then
        
        Else
        If Form1.ActiveControl Is Nothing Then
        Else
            CreateCaret Form1.ActiveControl.hWnd, 0, -1, 0
            End If
            CreateCaret dqq.hWnd, 0, -1, 0
        End If
        Exit Sub
End If

If t& = 1 Then
       ' CreateCaret dqq.hWnd, 0, dqq.ScaleX(.Xt, 1, 3), dqq.ScaleY((.Yt - .uMineLineSpace * 2), 1, 3)
       CreateCaret dqq.hWnd, 0, dqq.ScaleX(.Xt, 1, 3), dqq.ScaleY(.Yt - .uMineLineSpace * 2, 1, 3)
        SetCaretPos dqq.ScaleX(.curpos * .Xt, 1, 3), dqq.ScaleY(.currow * .Yt + .uMineLineSpace, 1, 3)
        On Error Resume Next
        If Not extreme Then If INK$ = vbNullString Then dqq.Refresh
Else
    CreateCaret dqq.hWnd, 0, dqq.ScaleX(.Xt, 1, 3), .Yt \ DYP \ 6 + 1
        
            SetCaretPos dqq.ScaleX(.curpos * .Xt, 1, 3), dqq.ScaleY((.currow + 1) * .Yt - .uMineLineSpace, 1, 3) - .Yt \ DYP \ 6 - 1
        On Error Resume Next
        If Not extreme Then If INK$ = vbNullString Then dqq.Refresh
End If
dqq.DrawMode = vbCopyPen
dqq.currentX = .curpos * .Xt
dqq.currentY = .currow * .Yt + .uMineLineSpace
End With
End Sub
Public Sub SetDouble(dq As Object)
'With players(GetCode(dq))
'    SetTextSZ dq, .SZ, 2
'End With
SetTextSZ dq, players(GetCode(dq)).SZ, 2
End Sub

Public Sub SetNormal(dq As Object)
With players(GetCode(dq))
If .currow >= .mY - 1 And .double Then
SetTextSZ dq, .SZ, 1
.currow = .currow + 1
Else
SetTextSZ dq, .SZ, 1
End If
End With
End Sub

Sub BoxBigNew(dqq As Object, mb As basket, x1&, y1&, C As Long)
Dim mm As MetaDc
With mb

 If TypeOf dqq Is MetaDc Then
 Set mm = dqq
 mm.Line2 .curpos * .Xt - DXP, .currow * .Yt - DYP, x1& * .Xt - DXP + .Xt, y1& * .Yt + .Yt - DYP, mycolor(C), , True
 
 Else
Dim oldf As Integer
oldf = dqq.FillStyle
dqq.FillStyle = vbFSTransparent
dqq.Line (.curpos * .Xt - DXP, .currow * .Yt - DYP)-(x1& * .Xt - DXP + .Xt, y1& * .Yt + .Yt - DYP), mycolor(C), B
dqq.FillStyle = oldf
End If
End With

End Sub
Sub CircleBig(dqq As Object, mb As basket, x1&, y1&, C As Long, el As Boolean)
Dim X&, Y&
With mb
X& = .curpos
Y& = .currow
dqq.FillColor = mycolor(C)
dqq.FillStyle = vbFSSolid
If TypeOf dqq Is MetaDc Then
If el Then
DrawCircleApi dqq, Form1.ScaleX(((X& + x1& + 1) / 2 * .Xt) - DXP, 1, 3), Form1.ScaleY(((Y& + y1& + 1) / 2 * .Yt) - DYP, 1, 3), Form1.ScaleX(RMAX((x1& - X& + 1) * .Xt, (y1& - Y& + 1) * .Yt) / 2 - DYP, 1, 3), mycolor(C), ((y1& - Y& + 1) * .Yt - DYP) / ((x1& - X& + 1) * .Xt - DXP)
Else
DrawCircleApi dqq, Form1.ScaleX(((X& + x1& + 1) / 2 * .Xt) - DXP, 1, 3), Form1.ScaleY(((Y& + y1& + 1) / 2 * .Yt) - DYP, 1, 3), Form1.ScaleX(RMAX((x1& - X& + 1) * .Xt, (y1& - Y& + 1) * .Yt) / 2 - DYP, 1, 3), mycolor(C)
End If
Else
If el Then
dqq.Circle (((X& + x1& + 1) / 2 * .Xt) - DXP, ((Y& + y1& + 1) / 2 * .Yt) - DYP), RMAX((x1& - X& + 1) * .Xt, (y1& - Y& + 1) * .Yt) / 2 - DYP, mycolor(C), , , ((y1& - Y& + 1) * .Yt - DYP) / ((x1& - X& + 1) * .Xt - DXP)
Else
dqq.Circle (((X& + x1& + 1) / 2 * .Xt) - DXP, ((Y& + y1& + 1) / 2 * .Yt) - DYP), (RMIN((x1& - X& + 1) * .Xt, (y1& - Y& + 1) * .Yt) / 2 - DYP), mycolor(C)

End If
End If
dqq.FillStyle = vbFSTransparent
End With
End Sub
Sub Ffill(dqq As Object, x1 As Long, y1 As Long, C As Long, v As Boolean)
Dim osm
With players(GetCode(dqq))

If Not .IamEmf Then
osm = dqq.ScaleMode
dqq.ScaleMode = vbPixels
End If
dqq.FillColor = mycolor(C)
dqq.FillStyle = vbFSSolid
If v Then
ExtFloodFill dqq.Hdc, dqq.ScaleX(x1, 1, 3), dqq.ScaleY(y1, 1, 3), dqq.point(dqq.ScaleX(x1, 1, 3), dqq.ScaleY(y1, 1, 3)), FLOODFILLSURFACE
Else
ExtFloodFill dqq.Hdc, dqq.ScaleX(x1, 1, 3), dqq.ScaleY(y1, 1, 3), mycolor(.mypen), FLOODFILLBORDER
End If
If Not .IamEmf Then
dqq.ScaleMode = osm
End If
dqq.FillStyle = vbFSTransparent
End With
'LCT Dqq, y&, x&
End Sub

Sub BoxColorNew(dqq As Object, mb As basket, x1&, y1&, C As Long)
With mb
If TypeOf dqq Is MetaDc Then
dqq.Line2 .curpos * .Xt, .currow * .Yt, x1& * .Xt + .Xt - 2& * DXP, y1& * .Yt + .Yt - 2& * DYP, mycolor(C), True, True
Else
dqq.Line (.curpos * .Xt, .currow * .Yt)-(x1& * .Xt + .Xt - 2& * DXP, y1& * .Yt + .Yt - 2& * DYP), mycolor(C), BF
End If
End With
End Sub
Sub BoxColorNewBarVer(dqq As Object, mb As basket, x1&, y1&, C As Long, ByVal st&, ByVal en&)
' st& 10000 ---> 10000/10000
' en& 10000 ---> 10000/10000
If en& > 10000& Then en& = 10000&
If en& < st& Then Exit Sub
If st& < 0& Then st& = 0&
Dim stA&, ste&
With mb
stA& = ((y1& - .currow + 1) * .Yt - 2 * DYP) * st& \ 10000&
ste& = ((y1& - .currow + 1) * .Yt - 2 * DYP) * en& \ 10000&
If (ste& - stA&) <= DYP Then
stA& = ((y1& - .currow + 1) * .Yt - 2 * DYP) - stA&
If TypeOf dqq Is MetaDc Then
    dqq.Line2 .curpos * .Xt, .currow * .Yt + stA&, x1& * .Xt + .Xt - 2& * DXP, .currow * .Yt + stA&, mycolor(C)
Else
    dqq.Line (.curpos * .Xt, .currow * .Yt + stA&)-(x1& * .Xt + .Xt - 2& * DXP, .currow * .Yt + stA&), mycolor(C)
End If
Else
stA& = ((y1& - .currow + 1) * .Yt - 2 * DYP) - stA&
ste& = ((y1& - .currow + 1) * .Yt - 2 * DYP) - ste&
If TypeOf dqq Is MetaDc Then
    dqq.Line2 .curpos * .Xt, .currow * .Yt + ste&, x1& * .Xt + .Xt - 2& * DXP, .currow * .Yt + stA&, mycolor(C), True, True
Else
    dqq.Line (.curpos * .Xt, .currow * .Yt + ste&)-(x1& * .Xt + .Xt - 2& * DXP, .currow * .Yt + stA&), mycolor(C), BF
End If
End If
End With
End Sub

Sub BoxColorNewBarHor(dqq As Object, mb As basket, x1&, y1&, C As Long, ByVal st&, ByVal en&)
' st& 10000 ---> 10000/10000
' en& 10000 ---> 10000/10000
If en& > 10000& Then en& = 10000&
If en& < st& Then Exit Sub
If st& < 0& Then st& = 0&
Dim stA&, ste&
With mb
stA& = ((x1& - .curpos + 1) * .Xt - 2 * DYP) * st& \ 10000&
ste& = ((x1& - .curpos + 1) * .Xt - 2 * DYP) * en& \ 10000&
If (ste& - stA&) <= DYP Then
If TypeOf dqq Is MetaDc Then
    dqq.Line2 .curpos * .Xt + stA&, .currow * .Yt, .curpos * .Xt + stA&, y1& * .Yt + .Yt - 2& * DYP, mycolor(C)
Else
    dqq.Line (.curpos * .Xt + stA&, .currow * .Yt)-(.curpos * .Xt + stA&, y1& * .Yt + .Yt - 2 * DYP), mycolor(C)
End If

Else
If TypeOf dqq Is MetaDc Then
dqq.Line2 .curpos * .Xt + stA&, .currow * .Yt, .curpos * .Xt + stA& - 2 * DXP, y1& * .Yt + .Yt - 2& * DYP, mycolor(C), True, True
Else
dqq.Line (.curpos * .Xt + stA&, .currow * .Yt)-(.curpos * .Xt + ste&, y1& * .Yt + .Yt - 2 * DYP), mycolor(C), BF
End If
End If
End With
End Sub
Sub BoxImage(d1 As Object, mb As basket, x1&, y1&, f As String, df&, s As Boolean)
'
Dim p As Picture, scl As Double, x2&, dib As Object, aPic As StdPicture

If df& > 0 Then
df& = df& * DXP '* 20

Else

df& = 0
End If
With mb
x1& = .curpos + x1& - 1
x2& = x1&
y1& = .currow + y1& - 1
On Error Resume Next
 If (Left$(f$, 4) = "cDIB" And Len(f$) > 12) Then
   Set dib = New cDIBSection
  If Not cDib(f$, dib) Then
    dib.create x1&, y1&
    dib.Cls d1.BackColor
  End If
      Set p = dib.Picture
    Set dib = Nothing
 Else
        If ExtractType(f, 0) = vbNullString Then
        f = f + ".bmp"
        End If
        FixPath f
        
    If CFname(f) <> "" Then
    f = CFname(f)
    Set aPic = LoadMyPicture(GetDosPath(f$))
     If aPic Is Nothing Then Exit Sub
    Set p = aPic
                                            

    Else
    Set dib = New cDIBSection
    dib.create x1&, y1&
    dib.Cls d1.BackColor
    Set p = dib.Picture
    Set dib = Nothing
    End If
End If

If Err.Number > 0 Then Exit Sub

If s Then
scl = (y1& - .currow + 1) * .Yt - df&
If p.Type = vbPicTypeBitmap Then
d1.PaintPicture p, .curpos * .Xt, .currow * .Yt, (x1& - .curpos + 1) * .Xt - df&, scl, , , , , vbSrcCopy
Else
d1.PaintPicture p, .curpos * .Xt, .currow * .Yt, (x1& - .curpos + 1) * .Xt - df&, scl
End If
Else
scl = p.Height * ((x1& - .curpos + 1) * .Xt - df&) / p.Width
If p.Type = vbPicTypeBitmap Then
d1.PaintPicture p, .curpos * .Xt, .currow * .Yt, (x1& - .curpos + 1) * .Xt - df&, scl, , , , , vbSrcCopy
Else
d1.PaintPicture p, .curpos * .Xt, .currow * .Yt, (x1& - .curpos + 1) * .Xt - df&, scl
End If
End If
y1& = -Int(-((scl) / .Yt))
Set p = Nothing
''LCT d1, .currow, .curpos
End With
End Sub

Sub sprite(bstack As basetask, ByVal f As String, rst As String)

On Error GoTo SPerror
Dim d1 As Object, amask$, aPic As StdPicture
Set d1 = bstack.Owner
Dim raster As New cDIBSection
Dim p As Double, I As Long, rot As Double, sp As Double
Dim Pcw As Long, Pch As Long, blend As Double, NoUseBack As Boolean

If Not cDib(f, raster) Then
    If CFname(f) <> "" Then
        f = CFname(f)
        Set aPic = LoadMyPicture(GetDosPath(f$))
        If aPic Is Nothing Then Exit Sub
        If aPic.Type = 4 Then
        With players(GetCode(bstack.Owner))
        raster.emfSizeFactor = 100 '.MAXXGRAPH \ dv15
        End With
        
        
        End If
        
        raster.CreateFromPicture aPic
        If raster.bitsPerPixel <> 24 Then
            Conv24 raster
        Else
            CheckOrientation raster, f
        End If
    Else
        
        BACKSPRITE = vbNullString
        Exit Sub
    End If
End If
If raster.Width = 0 Then
    BACKSPRITE = vbNullString
    Set raster = Nothing
    Set d1 = Nothing
    Exit Sub
End If
I = -1
sp = 100!
blend = 100!
If FastSymbol(rst$, ",") Then
    If IsExp(bstack, rst$, p, , True, nostring:=True) Then I = CLng(p) Else I = -players(GetCode(d1)).Paper
    If FastSymbol(rst$, ",") Then
        If IsExp(bstack, rst$, p, , True, nostring:=True) Then rot = p
        If FastSymbol(rst$, ",") Then
            If Not IsExp(bstack, rst$, sp, nostring:=True) Then sp = 100!
            If FastSymbol(rst$, ",") Then
                If IsExp(bstack, rst$, blend) Then
                    If myVarType(blend, vbString) Then
                    amask$ = blend
                    GoTo c18364
                    End If
                    blend = Abs(Int(blend)) Mod 101
                    If FastSymbol(rst$, ",") Then GoTo cont0
                ElseIf IsStrExp(bstack, rst$, amask$, Len(bstack.tmpstr) = 0) Then
c18364:
                    blend = 100!
                    If FastSymbol(rst$, ",") Then GoTo cont0
                ElseIf FastSymbol(rst$, ",") Then
                blend = 100!
cont0:
                    If Not IsExp(bstack, rst$, p, , True, nostring:=True) Then
                            MissPar
                            Exit Sub
                    End If
                    NoUseBack = CBool(p)
                Else
                    MissPar
                End If
                
                
            End If
            End If
        End If
Else
        Pcw = raster.Width \ 2
        Pch = raster.Height \ 2
        With players(GetCode(d1))
        raster.PaintPicture d1.Hdc, Int(d1.ScaleX(.XGRAPH, 1, 3) - Pcw), Int(d1.ScaleX(.YGRAPH, 1, 3) - Pch)
        End With
    GoTo cont1
End If
If sp <= 0 Then sp = 0
If I > 0 Then I = QBColor(I) Else I = -I
RotateDib bstack, raster, rot, sp, I, NoUseBack, (blend), amask$
Pcw = raster.Width \ 2
Pch = raster.Height \ 2
With players(GetCode(d1))
raster.PaintPicture d1.Hdc, Int(d1.ScaleX(.XGRAPH, 1, 3) - Pcw), Int(d1.ScaleX(.YGRAPH, 1, 3) - Pch)
End With
cont1:
If Not bstack.toprinter Then
GdiFlush
End If
Set raster = Nothing
'MyDoEvents1 d1
Set d1 = Nothing
Exit Sub
SPerror:
 BACKSPRITE = vbNullString
Set raster = Nothing
End Sub
Sub spriteGDI(bstack As basetask, rst As String)
Dim NoUseBack As Boolean, usehandler As mHandler
If bstack.lastobj Is Nothing Then
Err1:
    MyEr "Expecting a memory Buffer", "Ðåñßìåíá äéÜñèñùóç ìíÞìçò"
    Exit Sub
End If
If Not TypeOf bstack.lastobj Is mHandler Then GoTo Err1
Set usehandler = bstack.lastobj
If Not usehandler.T1 = 2 Then GoTo Err1
Dim d1 As Object
Set d1 = bstack.Owner
Dim p, I As Long, mem As MemBlock, blend, sp, rot As Single
Set mem = usehandler.objref
I = -1
sp = 100!
blend = 0!
If FastSymbol(rst$, ",") Then
    If IsExp(bstack, rst$, p, , True, nostring:=True) Then I = CLng(p) Else I = -players(GetCode(d1)).Paper
    If FastSymbol(rst$, ",") Then
        If IsExp(bstack, rst$, p, , True, nostring:=True) Then rot = p
        If FastSymbol(rst$, ",") Then
            If Not IsExp(bstack, rst$, sp, , True, nostring:=True) Then sp = 100!
            If FastSymbol(rst$, ",") Then
                If IsExp(bstack, rst$, blend, nostring:=True) Then blend = 100 - Abs(Int(blend)) Mod 101
                If FastSymbol(rst$, ",") Then
                    If Not IsExp(bstack, rst$, p, nostring:=True) Then
                        MissPar
                        Exit Sub
                    End If
                    NoUseBack = CBool(p)
                End If
            End If
        End If
    End If
End If
If sp <= 0 Then sp = 0
If I > 0 Then I = QBColor(I Mod 16) Else I = -I
If Not bstack.toprinter Then
GdiFlush
End If
mem.DrawSpriteToHdc bstack, NoUseBack, rot, (sp), (blend), I

'MyDoEvents1 d1
Set d1 = Nothing
Set bstack.lastobj = Nothing
Exit Sub
SPerror:
Set bstack.lastobj = Nothing
 BACKSPRITE = vbNullString
End Sub

Sub ThumbImage(d1 As Object, x1 As Long, y1 As Long, f As String, Border As Long, tpp As Long, ttl1$)
On Error Resume Next
With players(GetCode(d1))
If Left$(f, 4) = "cDIB" And Len(f) > 12 Then
Dim ph As New cDIBSection
If cDib(f, ph) Then
ph.ThumbnailPartPaint d1, x1 / tpp, y1 / tpp, 0, 0, Border <> 0, , ttl1$, .XGRAPH / tpp, .YGRAPH / tpp
End If
End If
End With
End Sub
Sub ThumbImageDib(d1 As Object, x1 As Long, y1 As Long, ph As Object, Border As Long, tpp As Long, ttl1$)
On Error Resume Next
Dim pointer2dib As cDIBSection
Set pointer2dib = ph
With players(GetCode(d1))
    pointer2dib.ThumbnailPartPaint d1, x1 / tpp, y1 / tpp, 0, 0, Border <> 0, , ttl1$, .XGRAPH / tpp, .YGRAPH / tpp
End With
Set pointer2dib = Nothing
End Sub
Sub SImage(d1 As Object, x1 As Long, y1 As Long, f As String)
'
Dim p As Picture, aPic As StdPicture
On Error Resume Next
With players(GetCode(d1))
If Left$(f, 4) = "cDIB" And Len(f) > 12 Then
Dim ph As New cDIBSection
If cDib(f, ph) Then
If x1 = 0 Then
ph.PaintPicture d1.Hdc, CLng(d1.ScaleX(.XGRAPH, 1, 3)), CLng(d1.ScaleX(.YGRAPH, 1, 3))
Exit Sub
Else
If y1 = 0 Then y1 = Abs(ph.Height * x1 / ph.Width)
ph.StretchPictureH d1.Hdc, CLng(d1.ScaleX(.XGRAPH, 1, 3)), CLng(d1.ScaleX(.YGRAPH, 1, 3)), CLng(d1.ScaleX(x1, 1, 3)), CLng(d1.ScaleX(y1, 1, 3))
Exit Sub
End If
End If
ElseIf CFname(f) <> "" Then
    f = CFname(f)
     Set aPic = LoadMyPicture(GetDosPath(f$), , , True)
     If aPic Is Nothing Then Exit Sub
     Set p = aPic
Else
If y1 = 0 Then y1 = x1
d1.Line (.XGRAPH, .YGRAPH)-(x1, y1), .Paper, BF
d1.currentX = .XGRAPH
d1.currentY = .YGRAPH
Exit Sub
End If
If x1 = 0 Then
x1 = d1.ScaleX(p.Width, vbHimetric, vbTwips)

If y1 = 0 Then y1 = p.Height * d1.ScaleX(p.Width, vbHimetric, vbTwips) / p.Width
Else
If y1 = 0 Then y1 = p.Height * x1 / p.Width
End If
If Err.Number > 0 Then Exit Sub

If p.Type = vbPicTypeBitmap Then
d1.PaintPicture p, .XGRAPH, .YGRAPH, x1, y1, , , , , vbSrcCopy
Else
d1.PaintPicture p, .XGRAPH, .YGRAPH, x1, y1
End If
Set p = Nothing
End With
' UpdateWindow d1.hwnd
End Sub
Public Function LoadMyPicture(s1$, Optional useback As Boolean = False, Optional bColor As Variant = 0&, Optional includeico As Boolean = False) As StdPicture
Dim s As String
Err.Clear
   On Error Resume Next
                    If s1$ <> vbNullString Then
                        s$ = UCase(ExtractType(s1$))
                        If LenB(s$) = 0 Then s$ = "Bmp": s1$ = s1$ + ".bmp"
                        Select Case s
                        Case "JPG", "BMP", "WMF", "EMF", "ICO", "DIB"
                        
                           Set LoadMyPicture = LoadPicture(s1$)
                           If Err.Number > 0 Then
                           Err.Clear
                           If useback Then
                              Set LoadMyPicture = LoadPictureGDIPlus(s1$, , , bColor)
                           Else
                              Set LoadMyPicture = LoadPictureGDIPlus(s1$)
                            End If
                           ElseIf useback Then
                                Set LoadMyPicture = LoadPictureGDIPlus(s1$, , , bColor)
                                If Err.Number > 0 Then Err.Clear
                           End If
                           If Err.Number > 0 Then
                           Err.Clear
                           
                           Set LoadMyPicture = LoadPicture("")
                           End If
                           If LoadMyPicture Is Nothing Then
                           Set LoadMyPicture = LoadPicture("")
                           End If
                        Case Else
                            If includeico And Not useback Then
                            Set LoadMyPicture = LoadPicture(s1$)
                                If Err.Number > 0 Then
                                    Err.Clear
                                    GoTo conthere
                                End If
                            Else
conthere:
                          If useback Then
                              Set LoadMyPicture = LoadPictureGDIPlus(s1$, , , bColor)
                           Else
                              Set LoadMyPicture = LoadPictureGDIPlus(s1$)
                            End If
                            End If
                            If Err.Number > 0 Then
                           Err.Clear
                          
                           Set LoadMyPicture = LoadPicture("")
                           End If
                           If LoadMyPicture Is Nothing Then
                           Set LoadMyPicture = LoadPicture("")
                           End If
                        End Select
                    End If
                          
End Function

Public Function MyTextWidth(D As Object, A$) As Long
Dim nr As RECT
CalcRect D.Hdc, A$, nr
'MyTextWidth = nr.Right * d.ScaleX(1, 3, 1)
MyTextWidth = nr.Right * DXP
End Function
Public Sub CalcRect(mHdc As Long, C As String, r As RECT)
r.top = 0
r.Left = 0
r.Right = 20000
r.Bottom = 20000
DrawTextEx mHdc, StrPtr(C), -1, r, DT_CALCRECT Or DT_NOPREFIX Or DT_SINGLELINE Or DT_NOCLIP Or DT_EXPANDTABS Or DT_TABSTOP, VarPtr(tParam)
End Sub
Public Sub CalcRectNoSingle(mHdc As Long, C As String, r As RECT)
r.top = 0
r.Left = 0
r.Right = 20000
r.Bottom = 20000
DrawTextEx mHdc, StrPtr(C), -1, r, DT_CALCRECT Or DT_NOPREFIX Or DT_NOCLIP Or DT_EXPANDTABS Or DT_TABSTOP, VarPtr(tParam)
End Sub

Public Sub PrintLineControlSingle(mHdc As Long, C As String, r As RECT)
    DrawTextEx mHdc, StrPtr(C), -1, r, DT_SINGLELINE Or DT_NOPREFIX Or DT_NOCLIP Or DT_EXPANDTABS Or DT_TABSTOP, VarPtr(tParam)
    End Sub
'
Public Sub MyPrintNew(DDD As Object, UAddTwipsTop, s$, Optional cr As Boolean = False, Optional fake As Boolean = False)

Dim nr As RECT, nl As Long, mytop As Long
mytop = DDD.currentY
If s$ = vbNullString Then
nr.Left = 0: nr.Right = 0: nr.top = 0: nr.Bottom = 0
CalcRect DDD.Hdc, " ", nr
nr.Left = DDD.currentX / dv15
nr.Right = nr.Right + nr.Left
nr.top = DDD.currentY / dv15
nr.Bottom = nr.top + nr.Bottom
nl = (nr.Bottom + 1) * dv15
If cr Then
DDD.currentY = (nr.Bottom + 1) * dv15 + UAddTwipsTop ''2
DDD.currentX = 0
Else
DDD.currentX = nr.Right * dv15
End If
Else
nr.Left = 0: nr.Right = 0: nr.top = 0: nr.Bottom = 0
CalcRect DDD.Hdc, s$, nr
nr.Left = DDD.currentX / dv15
nr.Right = nr.Right + nr.Left
nr.top = DDD.currentY / dv15
nr.Bottom = nr.top + nr.Bottom
nl = (nr.Bottom + 1) * dv15
If Not fake Then
If nr.Left * dv15 < DDD.Width Then PrintLineControlSingle DDD.Hdc, s$, nr
End If
If cr Then
DDD.currentY = nl + UAddTwipsTop ''* 2
DDD.currentX = 0
Else
DDD.currentY = mytop
DDD.currentX = nr.Right * dv15
End If
End If

End Sub
Public Sub MyPrint(DDD As Object, s$)
Dim nr As RECT, nl As Long
If s$ = vbNullString Then
    nr.Left = 0: nr.Right = 0: nr.top = 0: nr.Bottom = 0
    CalcRect DDD.Hdc, " ", nr
    nr.Left = DDD.currentX / dv15
    nr.Right = nr.Right + nr.Left
    nr.top = DDD.currentY / dv15
    nr.Bottom = nr.top + nr.Bottom
    nl = (nr.Bottom + 1) * dv15
    DDD.currentY = (nr.Bottom + 1) * dv15
    DDD.currentX = 0
Else
nr.Left = 0: nr.Right = 0: nr.top = 0: nr.Bottom = 0
CalcRect DDD.Hdc, s$, nr
nr.Left = DDD.currentX / dv15
nr.Right = nr.Right + nr.Left
nr.top = DDD.currentY / dv15
nr.Bottom = nr.top + nr.Bottom
nl = (nr.Bottom + 1) * dv15
If nr.Left * dv15 <= DDD.Width Then PrintLineControlSingle DDD.Hdc, s$, nr
DDD.currentY = nl
DDD.currentX = 0
End If
End Sub

Public Function TextWidth(DDD As Object, A$) As Long
Dim nr As RECT
CalcRect DDD.Hdc, A$, nr
TextWidth = nr.Right * dv15
End Function
Public Function TextWidth2(DDD As Object, A$) As Long
Dim nr As RECT
CalcRectNoSingle DDD.Hdc, A$, nr
TextWidth2 = nr.Right * dv15

End Function
Public Function TextWidthPixels(DDD As Object, A$) As Long
Dim nr As RECT
CalcRect DDD.Hdc, A$, nr
TextWidthPixels = nr.Right
End Function
Private Function TextHeight(DDD As Object, A$) As Long
Dim nr As RECT
CalcRect DDD.Hdc, A$, nr

TextHeight = nr.Bottom * dv15
End Function
Private Function TextHeight2(DDD As Object, A$) As Long
Dim nr As RECT
CalcRectNoSingle DDD.Hdc, A$, nr

TextHeight2 = nr.Bottom * dv15
End Function

Public Sub PlainBaSket(DDD As Object, mybasket As basket, ByVal what As String, Optional ONELINE As Boolean = False, Optional nocr As Boolean = False, Optional plusone As Long = 2, Optional clearline As Boolean = False, Optional processcr As Boolean = False, Optional semicolon As Boolean = False)

Dim PX As Long, PY As Long, r As Long, p$, C$, LEAVEME As Boolean, nr As RECT, nr2 As RECT, W As Integer
Dim P2 As Long, mUAddPixelsTop As Long
Dim pixX As Long, pixY As Long
Dim rTop As Long, rBottom As Long
Dim lenw&, realR&, realstop&, r1 As Long, WHAT1$, ff As Long, LL$(), must As Long
If processcr Then
    If Len(what$) = 0 Then Exit Sub
    LL$() = Split(what, vbLf)
    what = LL$(0)
    ff = 0
End If

Dim a1() As Integer, A2() As Integer
'' LEAVEME = False -  NOT NEEDED
again:
nr.Left = 0
realR& = 0

With mybasket
    mUAddPixelsTop = mybasket.uMineLineSpace \ dv15  ' for now
    PX = .curpos
    PY = .currow
    If PY = .mY And .double Then
        If DDD Is Form1.PrinterDocument1 Then
            getnextpage
            With nr
                .top = PY * pixY + mUAddPixelsTop
                .Bottom = .top + pixY - P2
            End With
            PY = 0
            .currow = 0
        Else
            ScrollUpNew DDD, mybasket
        End If
        PY = .currow
    End If
    P2 = mUAddPixelsTop * 2
    pixX = .Xt / dv15
    pixY = .Yt / dv15
    With nr
        .Left = PX * pixX
        .Right = .Left + pixX
        .top = PY * pixY + mUAddPixelsTop
        .Bottom = .top + pixY - mUAddPixelsTop * 2
    End With
    rTop = PY * pixY
    rBottom = rTop + pixY - plusone
    lenw& = RealLen(what)
    WHAT1$ = what + " "
    ReDim a1(Len(WHAT1$) + 10)
    ReDim A2(Len(WHAT1$) + 10)
    Dim skip As Boolean
    skip = GetStringTypeExW(&HB, 4, StrPtr(WHAT1$), Len(WHAT1$), a1(0)) = 0
    skip = GetStringTypeExW(&HB, 2, StrPtr(WHAT1$), Len(WHAT1$), A2(0)) = 0 Or skip
    Dim ii As Long, mark1 As Long, mr As Long, ML As Long
    
    Do While (lenw& - r) >= .mX - PX And (.mX - PX) > 0
     If DDD.FontTransparent = False Then
        With nr2
            .Left = PX * pixX
            .Right = mybasket.mX * pixX + 1
            .top = rTop
            .Bottom = rBottom
        End With
         FillBack DDD.Hdc, nr2, .Paper
         End If
        DDD.currentX = PX * .Xt
        DDD.currentY = PY * .Yt + .uMineLineSpace
        r1 = .mX - PX - 1 + r

        If DDD.currentX = 0 And clearline Then
            If Not TypeOf DDD Is MetaDc Then DDD.Line (0&, PY * .Yt)-((.mX - 1) * .Xt + .Xt * 2, (PY) * .Yt + .Yt - 1 * DYP), .Paper, BF
        End If
        
        Do
            If ONELINE And nocr And PX > .mX Then what = vbNullString: Exit Do
            C$ = Mid$(WHAT1$, r + 1, 1)
            W = AscW(C$)
            If W > -10241 And W < -9216 Then
                C$ = Mid$(WHAT1$, r + 1, 2)
                r = r + 1
                GoTo checkcombine
            ElseIf A2(r) = 0 And a1(r) = 0 Then
                If W >= 0 And W < 32 Then
                    GoTo CHECK100
                End If
                'R = R + 1
                GoTo cont0
            ElseIf (A2(r) And 254) = 2 And (a1(r) And &H8000) <> 0 Then
                mark1 = r + 1
                If processcr Then
                For ii = r + 2 To Len(what$)
                    If Not A2(ii) > 2 Then If (A2(ii) And 2) <> 2 And (a1(ii) And 7) = 0 Then Exit For
                   If (RealLen(Mid$(what$, mark1, ii - mark1 + 2)) + .curpos) > .mX Then
                   If TextWidth(DDD, Mid$(what$, mark1, ii - mark1 + 2)) \ .Xt > (.mX - .curpos - 1) Then
                   C$ = Mid$(what$, mark1, ii - mark1 + 1)
                
                LL(ff) = Mid$(what$, mark1 + Len(C$) + 1)
                If Len(LL(ff)) > 0 Then ff = ff - 1
                lenw& = r + Len(C$) - 1
             
                   
                   Exit For
                   End If
                   End If
                Next ii
                Else
                For ii = r + 2 To Len(what$)
                    If Not A2(ii) > 2 Then If (A2(ii) And 2) <> 2 And (a1(ii) And 7) = 0 Then Exit For
                Next ii
                End If
                C$ = Mid$(what$, mark1, ii - mark1 + 1)
                r = r + Len(C$): If ii > mark1 Then r = r - 1
                mark1 = nr.Right
                nr.Right = (PX + Len(what$)) * pixX + 1
                DrawText DDD.Hdc, StrPtr(C$), -1, nr, DT_SINGLELINE Or DT_NOPREFIX + DT_NOCLIP
                mark1 = TextWidth(DDD, C$)
                mark1 = mark1 \ .Xt - (mark1 Mod .Xt > 0)
                nr.Right = nr.Left + mark1 * pixX + 1
                realR& = realR + mark1
                DDD.currentX = nr.Right * DXP
                If processcr Then
                
                .curpos = 0
                End If
                ElseIf nounder32(C$) Then
checkcombine:
                If Not skip Then
                    If (a1(r + 1) And &H87F8) = 0 And (a1(r + 1) And 7) <> 0 Then
                        Do
                            p$ = Mid$(WHAT1$, r + 2, 1)
                            If Not nounder32(p$) Then Mid$(WHAT1$, r + 2, 1) = " ": Exit Do
                            C$ = C$ + p$
                            r = r + 1
                            If r >= r1 Then Exit Do
                         Loop Until (a1(r + 1) And 7) = 0
                     End If
                 End If
                 DrawText DDD.Hdc, StrPtr(C$), -1, nr, DT_SINGLELINE Or DT_CENTER Or DT_NOPREFIX + DT_NOCLIP
            Else
CHECK100:
                If C$ = Chr$(7) Then
                    If Not TypeOf DDD Is MetaDc Then
                    If Not processcr Then If Not DDD Is Form1.PrinterDocument1 Then Beep
                    End If
                    'R = R + 1: realR = realR - 1:
                End If
                If processcr Then
                    realR& = realR + 1
                    If C$ = ChrW(9) Then
                        what$ = space$(.Column - (PX + realR - 1) Mod (.Column + 1)) + Mid$(WHAT1$, r + 2)
                        r = 0
                        .curpos = PX + realR
                        If Len(what$) > 0 Then what$ = Mid$(what$, 1, Len(what$) - 1)
                        GoTo again
                    ElseIf C$ = ChrW(13) Then
                        If Mid$(WHAT1$, r + 2, 1) = ChrW(10) Then r = r + 1
                        .curpos = 0
                        If PY + 1 >= .mY Then
                            If DDD Is Form1.PrinterDocument1 Then
                                getnextpage
                                With nr
                                    .top = PY * pixY + mUAddPixelsTop
                                    .Bottom = .top + pixY - P2
                                End With
                                PY = 0
                                .currow = 0
                            Else
                                ScrollUpNew DDD, mybasket
                            End If
                        Else
                            .currow = PY + 1
                        End If
                        ff = ff + 1
                        If ff < UBound(LL) Then
                            If Right$(LL$(ff), 1) <> vbCr Then
                                what = LL$(ff) + vbCr
                            Else
                                what = LL$(ff)
                            End If
                            r = 0
                            GoTo again
                        ElseIf ff = UBound(LL) Then
                            what = LL$(ff)
                            r = 0
                            GoTo again
                        Else
                            Exit Do
                        End If
                    ElseIf C$ = ChrW(10) Then
                        .curpos = 0
                        If Not TypeOf DDD Is MetaDc Then
                        If PY + 1 = .mY Then
                            If DDD Is Form1.PrinterDocument1 Then
                                getnextpage
                                With nr
                                    .top = PY * pixY + mUAddPixelsTop
                                    .Bottom = .top + pixY - P2
                                End With
                                PY = 0
                                .currow = 0
                            Else
                                ScrollUpNew DDD, mybasket
                            End If
                        Else
                            .currow = PY + 1
                        End If
                        Else
                            .currow = PY + 1
                        End If
                        what$ = Mid$(WHAT1$, r + 2)
                        If Len(what$) > 0 Then what$ = Mid$(what$, 1, Len(what$) - 1)
                        r = 0
                        GoTo again
                    End If
                End If
                C$ = ChrW(AscW(C$) + &H2400)
            End If
            r = r + 1
            With nr
                .Left = .Right
                .Right = .Left + pixX
            End With
cont0:
            DDD.currentX = (PX + realR) * .Xt
            realR = realR + 1
            If r >= lenw& Then
                r = lenw& + 1
                lenw& = lenw& - 1
                Exit Do
            End If
            If realR > .mX - PX - 1 Then Exit Do
        Loop
        If realR < .mX - PX - 1 Then GoTo cont1
        .curpos = PX + realR
        If Not ONELINE Then PX = 0
        If nocr Then GoTo jumpexit Else PY = PY + 1
        If PY >= .mY And Not ONELINE Then
       ' If processcr Then
       ' If ff >= UBound(LL) Then
       ' GoTo skipthis
       ' End If
       ' End If
        If Not TypeOf DDD Is MetaDc Then
        If DDD Is Form1.PrinterDocument1 Then
                getnextpage
                With nr
                    .top = PY * pixY + mUAddPixelsTop
                    .Bottom = .top + pixY - P2
                End With
                PY = 0
                .currow = 0
            Else
                ScrollUpNew DDD, mybasket
            End If
            PY = PY - 1
        End If
        End If
skipthis:
        
        If ONELINE Then
            LEAVEME = True
            Exit Do
        Else
            With nr
               .Left = PX * pixX
               .Right = .Left + pixX
               .top = PY * pixY + mUAddPixelsTop
               .Bottom = .top + pixY - P2
            End With
            rTop = PY * pixY
            rBottom = rTop + pixY - plusone
        End If
        realR& = 0
    Loop
    If LEAVEME Then
        With mybasket
            .curpos = PX
            .currow = PY
        End With
        GoTo jumpexit
    End If
    If DDD.FontTransparent = False Then
        With nr2
            .Left = PX * pixX
            .Right = (PX + Len(what$)) * pixX + 1
            .top = rTop
            .Bottom = rBottom
        End With
        FillBack DDD.Hdc, nr2, mybasket.Paper
    End If
    realR& = 0
    If Len(what$) > r Then
        DDD.currentX = PX * .Xt
        DDD.currentY = PY * .Yt + .uMineLineSpace
        If DDD.currentX = 0 And clearline Then
            If Not TypeOf DDD Is MetaDc Then DDD.Line (0&, PY * .Yt)-((.mX - 1) * .Xt + .Xt * 2, (PY) * .Yt + .Yt - 1 * DYP), .Paper, BF
        End If
        r1 = Len(what$) - 1
        For r = r To r1
            C$ = Mid$(WHAT1$, r + 1, 1)
            W = AscW(C$)
            If W > -10241 And W < -9216 Then
                C$ = Mid$(WHAT1$, r + 1, 2)
                r = r + 1
                GoTo checkcombine1
            ElseIf A2(r) = 0 And a1(r) = 0 Then
                If W >= 0 And W < 32 Then
                    GoTo CHECK1
                End If
                GoTo cont1
            ElseIf (A2(r) And 254) = 2 And (a1(r) And &H8000) <> 0 Then
                mark1 = r + 1
                For ii = r + 2 To Len(what$)
                    If Not A2(ii) > 2 Then If (A2(ii) And 2) <> 2 And (a1(ii) And 7) = 0 Then Exit For
                Next ii
                C$ = Mid$(what$, mark1, ii - mark1 + 1)
                r = r + Len(C$)
                If ii > mark1 Then r = r - 1
                mark1 = TextWidth(DDD, C$) \ DXP
                nr.Right = nr.Left + mark1 + 1
                DrawTextEx DDD.Hdc, StrPtr(C$), -1, nr, DT_SINGLELINE Or DT_NOPREFIX + DT_NOCLIP, 0
                .curpos = nr.Right \ pixX
                realR& = realR + mark1 \ pixX - (mark1 Mod pixX > 0) * 1
                DDD.currentX = .curpos * .Xt
                If Not processcr Then GoTo contNew
                
                GoTo again
            ElseIf nounder32(C$) Then
checkcombine1:
                If Not skip Then
                    If (a1(r + 1) And &H87F8) = 0 And (a1(r + 1) And 7) <> 0 Then
                        Do
                            p$ = Mid$(WHAT1$, r + 2, 1)
                            If Not nounder32(p$) Then Mid$(WHAT1$, r + 2, 1) = " ": Exit Do
                            C$ = C$ + p$
                            r = r + 1
                            If r >= r1 Then Exit Do
                        Loop Until (a1(r + 1) And 7) = 0
                    End If
                End If
                DDD.currentX = DDD.currentX + .Xt
            Else
CHECK1:
                If C$ = Chr$(7) Then
                    If Not TypeOf DDD Is MetaDc Then
                    If Not processcr Then If Not DDD Is Form1.PrinterDocument1 Then Beep
                    End If
                End If
                If processcr Then
                    realR& = realR + 1
                    If C$ = ChrW(9) Then
                        what$ = space$(.Column - (PX + realR - 1) Mod (.Column + 1)) + Mid$(WHAT1$, r + 2)
                        r = 0
                        .curpos = PX + realR
                        If Len(what$) > 0 Then what$ = Mid$(what$, 1, Len(what$) - 1)
                        GoTo again
                    ElseIf C$ = ChrW(13) Then
                        If Mid$(WHAT1$, r + 2, 1) = ChrW(10) Then r = r + 1
                        .curpos = 0
                        PX = 0
                        DDD.currentX = 0
                        realR& = 0
                        C$ = ""
                        If Not TypeOf DDD Is MetaDc Then
                            If PY + 1 = .mY Then
                                If DDD Is Form1.PrinterDocument1 Then
                                    getnextpage
                                    With nr
                                        .top = PY * pixY + mUAddPixelsTop
                                        .Bottom = .top + pixY - P2
                                    End With
                                    PY = 0
                                    .currow = 0
                                Else
                                    ScrollUpNew DDD, mybasket
                                End If
                            Else
                                .currow = PY + 1
                            End If
                        Else
                                .currow = PY + 1
                        End If
                        ff = ff + 1
                        If ff < UBound(LL) Then
                            If Right$(LL$(ff), 2) <> vbCr Then
                                what = LL$(ff) + vbCrLf
                            Else
                                what = LL$(ff)
                            End If
                            r = 0
                            GoTo again
                        ElseIf ff = UBound(LL) Then
                            what = LL$(ff)
                            r = 0
                            GoTo again
                        Else
                            Exit For
                        End If
                    ElseIf C$ = ChrW(10) Then
                        .curpos = 0
                        If Not TypeOf DDD Is MetaDc Then
                        If PY + 1 >= .mY Then
                            If DDD Is Form1.PrinterDocument1 Then
                                getnextpage
                                With nr
                                    .top = PY * pixY + mUAddPixelsTop
                                    .Bottom = .top + pixY - P2
                                End With
                                PY = 0
                                .currow = 0
                            Else
                                ScrollUpNew DDD, mybasket
                            End If
                        Else
                            .currow = PY + 1
                        End If
                        Else
                            .currow = PY + 1
                        End If
                        what$ = Mid$(WHAT1$, r + 2)
                        If Len(what$) > 0 Then what$ = Mid$(what$, 1, Len(what$) - 1)
                        r = 0
                        If Len(what$) = 0 Then GoTo contNew
                        GoTo again
                    End If
                End If
                C$ = ChrW(AscW(C$) + &H2400)
            End If
            DrawText DDD.Hdc, StrPtr(C$), -1, nr, DT_SINGLELINE Or DT_CENTER Or DT_NOPREFIX + DT_NOCLIP
            realR& = realR + 1
contNew:
            With nr
               .Left = .Right
               .Right = .Left + pixX
            End With
cont1:
        Next r
        If Not processcr Then
            If semicolon Then
            ElseIf lenw& > realR& Then
                realR& = ((realR& + .Column + 1) \ (.Column + 1)) * (.Column + 1)
            End If
        ElseIf ff < UBound(LL) Then
        If ff < UBound(LL) Then
            r = 0
            what = Chr$(13)
            GoTo again
        End If
        End If
        .curpos = PX + realR
        .currow = PY
        GoTo jumpexit
    ElseIf processcr Then
        If ff < UBound(LL) Then
            r = 0
            what = Chr$(13)
            GoTo again
        End If
    End If
    
    .curpos = PX
    .currow = PY
    End With
jumpexit:

End Sub


Public Function nTextY(basestack As basetask, ByVal what As String, ByVal Font As String, ByVal Size As Single, Optional ByVal Degree As Double = 0#, Optional ByVal ExtraWidth As Long = 0)
Dim DDD As Object
Set DDD = basestack.Owner
Dim PX As Long, PY As Long, OLDFONT As String, OLDSIZE As String, DE#
Dim f As LOGFONT, hPrevFont As Long, hFont As Long, fline$
Dim BFONT As String
Dim prive As Long
prive = GetCode(DDD)
ExtraWidth = ExtraWidth \ dv15
If ExtraWidth <> 0 Then
SetTextCharacterExtra DDD.Hdc, ExtraWidth
End If
On Error Resume Next
With players(prive)
BFONT = DDD.Font.Name
If Font <> "" Then
If Size = 0 Then Size = DDD.FontSize
StoreFont Font, Size, .charset
DDD.Font.charset = 0
DDD.FontSize = 9
DDD.FontName = .FontName
DDD.Font.charset = .charset
DDD.FontSize = Size
Else
Font = .FontName
End If

DE# = 0 '(degree) * 180# / Pi
   f.lfItalic = Abs(.italics)
f.lfWeight = Abs(.bold) * 800
  f.lfEscapement = CLng(10 * DE#)
  f.lfFaceName = Left$(Font, 30) + Chr$(0)
  f.lfCharSet = .charset
  f.lfQuality = 3 ' PROOF_QUALITY
  f.lfHeight = (Size * -20) / DYP

  hFont = CreateFontIndirect(f)
  hPrevFont = SelectObject(DDD.Hdc, hFont)
 what$ = Replace$(what, vbCrLf, vbCr) + vbCr
Dim textmetrics As POINTAPI, Max, maxx As Long, sumy As Long
Do While what$ <> ""
If Left$(what$, 1) = vbCr Then
fline$ = vbNullString
what$ = Mid$(what$, 2)
Else
fline$ = GetStrUntil(vbCr, what$)
End If
If Len(what$) = 0 And Len(fline$) = 0 Then If sumy > 0 Then Exit Do
  
textmetrics.X = 0
textmetrics.Y = 0
    If Len(fline$) = 0 Then
        fline$ = " "
        GetTextExtentPoint32 DDD.Hdc, StrPtr(fline$), Len(fline$), textmetrics
        textmetrics.X = 0
    Else
        GetTextExtentPoint32 DDD.Hdc, StrPtr(fline$), Len(fline$), textmetrics
    End If
sumy = sumy + textmetrics.Y
If maxx < textmetrics.X Then maxx = textmetrics.X
Loop
nTextY = Int(Abs(maxx * dv15 * Sin(Degree)) + Abs(sumy * dv15 * Cos(Degree)))
  hFont = SelectObject(DDD.Hdc, hPrevFont)
  DeleteObject hFont
If ExtraWidth <> 0 Then SetTextCharacterExtra DDD.Hdc, 0
End With
PlaceBasket DDD, players(prive)


End Function
Public Function nText(basestack As basetask, ByVal what As String, ByVal Font As String, ByVal Size As Single, Optional ByVal Degree As Double = 0#, Optional ByVal ExtraWidth As Long = 0)
Dim DDD As Object
Set DDD = basestack.Owner
Dim PX As Long, PY As Long, OLDFONT As String, OLDSIZE As String, DE#
Dim f As LOGFONT, hPrevFont As Long, hFont As Long, fline$
Dim BFONT As String
Dim prive As Long
prive = GetCode(DDD)
On Error Resume Next
With players(prive)
ExtraWidth = ExtraWidth \ dv15
If ExtraWidth <> 0 Then
SetTextCharacterExtra DDD.Hdc, ExtraWidth
End If
BFONT = DDD.Font.Name
If Font <> "" Then
If Size = 0 Then Size = DDD.FontSize
StoreFont Font, Size, .charset
DDD.Font.charset = 0
DDD.FontSize = 9
DDD.FontName = .FontName
DDD.Font.charset = .charset
DDD.FontSize = Size
Else
Font = .FontName
End If


DE# = 0 '(degree) * 180# / Pi
   f.lfItalic = Abs(.italics)
f.lfWeight = Abs(.bold) * 800
    f.lfEscapement = 0
  'F.lfEscapement = CLNG(10 * DE#)
  f.lfFaceName = Left$(Font, 30) + Chr$(0)
  f.lfCharSet = .charset
  f.lfQuality = 3 ' NONANTIALIASED_QUALITY
  f.lfHeight = (Size * -20) / DYP

  hFont = CreateFontIndirect(f)
  hPrevFont = SelectObject(DDD.Hdc, hFont)
  what$ = Replace$(what, vbCrLf, vbCr) + vbCr
Dim textmetrics As POINTAPI, Max, maxx As Long, sumy As Long
Do While what$ <> ""
If Left$(what$, 1) = vbCr Then
fline$ = vbNullString
what$ = Mid$(what$, 2)
Else
fline$ = GetStrUntil(vbCr, what$)
End If
If Len(what$) = 0 And Len(fline$) = 0 Then If sumy > 0 Then Exit Do
  
textmetrics.X = 0
textmetrics.Y = 0
    If Len(fline$) = 0 Then
        fline$ = " "
        GetTextExtentPoint32 DDD.Hdc, StrPtr(fline$), Len(fline$), textmetrics
        textmetrics.X = 0
    Else
        GetTextExtentPoint32 DDD.Hdc, StrPtr(fline$), Len(fline$), textmetrics
    End If
sumy = sumy + textmetrics.Y
If maxx < textmetrics.X Then maxx = textmetrics.X
Loop

nText = Int(Abs(maxx * dv15 * Cos(Degree)) + Abs(sumy * dv15 * Sin(Degree)))

  hFont = SelectObject(DDD.Hdc, hPrevFont)
  DeleteObject hFont
If ExtraWidth <> 0 Then SetTextCharacterExtra DDD.Hdc, 0

End With
PlaceBasket DDD, players(prive)


End Function
Public Sub fullPlain(dd As Object, mb As basket, ByVal wh$, ByVal wi, Optional fake As Boolean = False, Optional nocr As Boolean = False)
Dim whNoSpace$, Displ As Long, DisplLeft As Long, I As Long, whSpace$, INTD As Long, MinDispl As Long, some As Long
Dim st As Long, CROP As Long, curx As Long
st = DXP
MinDispl = (TextWidth(dd, "A") \ 2) \ st
If MinDispl <= 1 Then MinDispl = 3
MinDispl = st * MinDispl
INTD = TextWidth(dd, space$(MyTrimL3Len(wh$)))
dd.currentX = dd.currentX + INTD

wi = wi - INTD
wh$ = NLTrim2$(wh$)
If Len(wh$) > 1 And Right$(wh$, 1) = "_" Then
wh$ = Left$(wh$, Len(wh$) - 1) + "-"

End If
INTD = wi + dd.currentX
CROP = rinstr(wh$, Chr$(9))
If CROP > 0 Then
curx = dd.currentX
MyPrintNew dd, mb.uMineLineSpace, Left$(wh$, CROP), nocr, fake
wi = wi - (dd.currentX - curx)
wh$ = Mid$(wh$, CROP + 1)
End If
whNoSpace$ = Replace$(wh$, " ", "")
Dim magicratio As Double, whsp As Long, whl As Double

If whNoSpace$ = wh$ Then
If CROP > 0 Then
dd.currentX = dd.currentX + (wi - TextWidth(dd, whNoSpace))
End If
MyPrintNew dd, mb.uMineLineSpace, wh$, Not nocr, fake

    'dd.Print wh$
Else



 If Len(whNoSpace$) > 0 Then
   whSpace$ = space$(Len(Trim$(wh$)) - Len(whNoSpace$))
   
        Displ = st * ((wi - (TextWidth(dd, whNoSpace))) \ (Len(whSpace)) \ st)
        some = (wi - TextWidth(dd, whNoSpace) - Len(whSpace) * Displ) \ st
        magicratio = some / Len(whNoSpace)
        whsp = Len(whSpace)
                whNoSpace$ = vbNullString
        For I = 1 To Len(wh$)
            If Mid$(wh$, I, 1) = " " Then
            whsp = whsp - 1
            
               If whNoSpace$ <> "" Then
               whl = Len(whNoSpace$) * magicratio + whl

                    MyPrintNew dd, mb.uMineLineSpace, whNoSpace$, , fake
                whNoSpace$ = vbNullString
                End If
                If some > 0 Then
                '
                some = some - whl
                dd.currentX = ((dd.currentX + Displ) \ st) * st + CLng(whl) * st
                whl = whl - CLng(whl)
                Else
             dd.currentX = ((dd.currentX + Displ) \ st) * st
              End If
           
            Else
                whNoSpace$ = whNoSpace$ + Mid$(wh$, I, 1)
            End If
        Next I

          whl = Len(whNoSpace$) * magicratio + whl
      dd.currentX = dd.currentX + CLng(whl) * st
          MyPrintNew dd, mb.uMineLineSpace, whNoSpace$, , fake
    Else

            MyPrintNew dd, mb.uMineLineSpace, wh$, Not nocr, fake
    End If
End If
End Sub
Public Sub fullPlainWhere(dd As Object, mb As basket, ByVal wh$, ByVal wi As Long, whr As Long, Optional fake As Boolean = False, Optional nocr As Boolean = False)
Dim whNoSpace$, Displ As Long, DisplLeft As Long, I As Long, whSpace$, INTD As Long, MinDispl As Long
Dim stdisp As Long, ratio As Double

'If Left$(LTrim(wh$), 1) = Chr$(9) Then
'MyPrintNew dd, mb.uMineLineSpace, wh$, Not nocr, fake
'Exit Sub
'End If
If TextWidth(dd, "W") = TextWidth(dd, " ") Then
MinDispl = TextWidth(dd, " ")
Else
MinDispl = (TextWidth(dd, "A") \ 2) \ DXP

If MinDispl <= 1 Then MinDispl = 3

MinDispl = DXP * MinDispl
End If


If whr = 3 Or whr = 0 Then INTD = TextWidth(dd, space$(MyTrimL3Len(wh$)))
dd.currentX = dd.currentX + INTD
wi = wi - INTD
If Len(wh$) > 1 And Right$(wh$, 1) = "_" Then
wh$ = Left$(wh$, Len(wh$) - 1) + "-"
ElseIf Len(wh$) > 1 And Right$(wh$, 1) = Chr$(9) Then
wh$ = Left$(wh$, Len(wh$) - 1)
End If
wh$ = NLTrim2$(wh$)
INTD = wi + dd.currentX
whNoSpace$ = Replace$(Replace$(wh$, Chr$(9), ""), " ", "")
If whr = 2 Then
    wh$ = Trim$(wh$)
    whNoSpace$ = Replace$(Replace$(wh$, Chr$(9), ""), " ", "")
    dd.currentX = dd.currentX + wi \ 2 - (TextWidth(dd, wh$) + (Len(wh$) - Len(Replace$(wh$, " ", ""))) * (MinDispl - TextWidth(dd, " "))) / 2
ElseIf whr = 1 Then
    dd.currentX = dd.currentX + wi - TextWidth(dd, wh$) - (Len(wh$) - Len(Replace$(wh$, " ", ""))) * (MinDispl - TextWidth(dd, " "))
Else

INTD = (wi - TextWidth(dd, whNoSpace)) * 0.2 + dd.currentX

End If

If whNoSpace$ = wh$ Then
 MyPrintNew dd, mb.uMineLineSpace, wh$, Not nocr, fake
Else
 If Len(whNoSpace$) > 0 Then
   whSpace$ = space$(Len(Trim$(wh$)) - Len(whNoSpace$))
   INTD = TextWidth(dd, Trim$(wh$)) - TextWidth(dd, whNoSpace$) + dd.currentX
  ' INTD = TextWidth(dd, whSpace$) + dd.CurrentX
   
   wh$ = Trim$(wh$)
   Displ = MinDispl
   If Displ * Len(whSpace$) + TextWidth(dd, whNoSpace$) > wi Then
   Displ = (wi - TextWidth(dd, whNoSpace$)) / (Len(wh$))
   
   End If
     
    stdisp = dd.currentX
                whNoSpace$ = vbNullString
        For I = 1 To Len(wh$)
            If Mid$(wh$, I, 1) = " " Then
            whSpace$ = Mid$(whSpace$, 2)
               If whNoSpace$ <> "" Then
               
                 MyPrintNew dd, mb.uMineLineSpace, whNoSpace$, , fake
                whNoSpace$ = vbNullString
                
                End If
              dd.currentX = dd.currentX + Displ
 
            ElseIf Mid$(wh$, I, 1) = Chr$(9) Then
           
             whSpace$ = Mid$(whSpace$, 2)
                 MyPrintNew dd, mb.uMineLineSpace, whNoSpace$ + Chr$(9), , fake
                dd.currentX = TextWidth(dd, Left$(wh$, I)) + stdisp
                whNoSpace$ = vbNullString
               
            Else
                whNoSpace$ = whNoSpace$ + Mid$(wh$, I, 1)
            End If
        Next I

          MyPrintNew dd, mb.uMineLineSpace, whNoSpace$, Not nocr, fake
    Else
    
    MyPrintNew dd, mb.uMineLineSpace, wh$, Not nocr, fake
    
    End If
End If
End Sub

Public Sub wPlain(DDD As Object, mb As basket, ByVal what As String, ByVal wi&, ByVal Hi&, Optional nocr As Boolean = False)
Dim PX As Long, PY As Long, ttt As Long, ruller&
Dim buf$, b$, npy As Long ', npx As long

With mb
PlaceBasket DDD, mb
tParam.iTabLength = .ReportTab
If what = vbNullString Then Exit Sub
PX = .curpos
PY = .currow
If .mX - PX < wi& Then wi& = .mX - PX
If .mY - PY < Hi& Then Hi& = .mY - PY
If wi& = 0 Or Hi& < 0 Then Exit Sub
npy = PY
ruller& = wi&
For ttt = 1 To Len(what)
    b$ = Mid$(what, ttt, 1)
   ' If nounder32(b$) Then
   
   If Not (b$ = vbCr Or b$ = vbLf) Then
    If TextWidth(DDD, buf$ + b$) <= (wi& * .Xt) Then
    buf$ = buf$ + b$
    End If
    ElseIf b$ = vbCr Then
    
    If nocr Then Exit For
    MyPrintNew DDD, mb.uMineLineSpace, buf$, Not nocr
    
    
    buf$ = vbNullString
    Hi& = Hi& - 1
    npy = npy + 1
    LCTbasket DDD, mb, npy, PX
    End If
    If Hi& < 0 Then Exit For
Next ttt
If Hi& >= 0 And buf$ <> "" Then MyPrintNew DDD, mb.uMineLineSpace, buf$, Not nocr
If Not nocr Then LCTbasket DDD, mb, PY, PX
End With
End Sub
Public Sub FeedFont2Stack(basestack As basetask, ok As Boolean)
Dim ms As New mStiva
If ok Then
ms.PushVal CDbl(ReturnBold)
ms.PushVal CDbl(ReturnItalic)
ms.PushVal CDbl(ReturnCharset)
ms.PushVal CDbl(ReturnSize)
ms.PushStr ReturnFontName
ms.PushVal CDbl(1)
Else
ms.PushVal CDbl(0)
End If
basestack.soros.MergeTop ms
End Sub
Public Sub nPlain(basestack As basetask, ByVal what As String, ByVal Font As String, ByVal Size As Single, Optional ByVal Degree As Double = 0#, Optional ByVal JUSTIFY As Long = 0, Optional ByVal qual As Boolean = True, Optional ByVal ExtraWidth As Long = 0)
Dim DDD As Object
Set DDD = basestack.Owner
Dim PX As Long, PY As Long, OLDFONT As String, OLDSIZE As Long, DEGR As Double
Dim f As LOGFONT, hPrevFont As Long, hFont As Long, fline$, TT As Long
Dim BFONT As String

On Error Resume Next
BFONT = DDD.Font.Name
If ExtraWidth <> 0 Then
SetTextCharacterExtra DDD.Hdc, ExtraWidth
End If
Dim icx As Long, icy As Long, X As Long, Y As Long, icH As Long

If JUSTIFY < 0 Then Degree = 0
DEGR = (Degree) * 180# / Pi
  f.lfItalic = Abs(basestack.myitalic)
  f.lfWeight = Abs(basestack.myBold) * 800
  f.lfEscapement = 0
  f.lfFaceName = Left$(Font, 30) + Chr$(0)
  f.lfCharSet = basestack.myCharSet
  If qual Then
    f.lfQuality = PROOF_QUALITY 'NONANTIALIASED_QUALITY '
  Else
    f.lfQuality = NONANTIALIASED_QUALITY
  End If
  f.lfHeight = (Size * -20) / DYP
  hFont = CreateFontIndirect(f)
  hPrevFont = SelectObject(DDD.Hdc, hFont)
  icH = TextHeight(DDD, "fq")
  hFont = SelectObject(DDD.Hdc, hPrevFont)
  DeleteObject hFont
  f.lfItalic = Abs(basestack.myitalic)
  f.lfWeight = Abs(basestack.myBold) * 800
  f.lfEscapement = CLng(10 * DEGR)
  f.lfFaceName = Left$(Font, 30) + Chr$(0)
  f.lfCharSet = basestack.myCharSet
  If qual Then
  f.lfQuality = PROOF_QUALITY 'NONANTIALIASED_QUALITY '
  Else
  f.lfQuality = NONANTIALIASED_QUALITY
  End If
  f.lfHeight = (Size * -20) / DYP
  

  
    hFont = CreateFontIndirect(f)
  hPrevFont = SelectObject(DDD.Hdc, hFont)

TT = ExtraWidth \ 2
icy = CLng(Cos(Degree) * icH)
icx = CLng(Sin(Degree) * icH)

With players(GetCode(DDD))
If JUSTIFY < 0 Then
JUSTIFY = Abs(JUSTIFY) - 1
If JUSTIFY = 0 Then
Y = .YGRAPH - icy
X = .XGRAPH - icx * 2
ElseIf JUSTIFY = 1 Then
Y = .YGRAPH
X = .XGRAPH
Else
Y = .YGRAPH - icy / 2
X = .XGRAPH - icx
End If
Else
Y = .YGRAPH - icy
X = .XGRAPH - icx

End If
End With
If TT > 0 Then
X = X + (Cos(Degree) * TT * dv15)
Y = Y - (Sin(Degree) * TT * dv15)
End If
what$ = Replace$(what, vbCrLf, vbCr) + vbCr
Dim textmetrics As POINTAPI

Do While what$ <> ""
If Left$(what$, 1) = vbCr Then
fline$ = vbNullString
what$ = Mid$(what$, 2)
Else
fline$ = GetStrUntil(vbCr, what$)
End If
textmetrics.X = 0
textmetrics.Y = 0
GetTextExtentPoint32 DDD.Hdc, StrPtr(fline$), Len(fline$), textmetrics
X = X + icx
Y = Y + icy
If JUSTIFY = 1 Then
    DDD.currentX = X - Int((textmetrics.X * Cos(Degree) + textmetrics.Y * Sin(Degree)) * dv15)
    DDD.currentY = Y + Int((textmetrics.X * Sin(Degree) - textmetrics.Y * Cos(Degree)) * dv15)
ElseIf JUSTIFY = 2 Then
'If tt <> 0 Then textmetrics.X = textmetrics.X - tt * 1.5

     DDD.currentX = X - Int((textmetrics.X * Cos(Degree) + textmetrics.Y * Sin(Degree)) * dv15) \ 2
    DDD.currentY = Y + Int((textmetrics.X * Sin(Degree) - textmetrics.Y * Cos(Degree)) * dv15) \ 2
Else

    DDD.currentX = X
    DDD.currentY = Y
End If
MyPrint DDD, fline$
Loop
  hFont = SelectObject(DDD.Hdc, hPrevFont)
  DeleteObject hFont
If ExtraWidth <> 0 Then SetTextCharacterExtra DDD.Hdc, 0
End Sub

Public Sub nForm(bstack As basetask, TheSize As Single, nW As Long, nH As Long, myLineSpace As Long)
    On Error Resume Next
    StoreFont bstack.Owner.Font.Name, TheSize, bstack.myCharSet
    nH = fonttest.TextHeight("Wq") + myLineSpace * 2
    nW = fonttest.TextWidth("W") + dv15
End Sub
Sub crNew(bstack As basetask, mb As basket)

Dim D As Object
Set D = bstack.Owner
With mb
Dim PX As Long, PY As Long, r As Long
PX = .curpos
PY = .currow
PX = 0
PY = PY + 1
If TypeOf D Is MetaDc Then

ElseIf PY >= .mY Then
    If Not bstack.toprinter Then
        ScrollUpNew D, mb
        PY = .mY - 1
    Else
        PY = 0
        PX = 0
        getnextpage
    End If
End If
.curpos = PX
.currow = PY

End With
End Sub

Public Sub CdESK()
Dim X, Y, ff As Form, useform1 As Boolean
If Form1.Visible Then
    If Form5.Visible Then
    Set ff = Form5
    Form5.RestoreSizePos
    Form5.BackColor = 0
    useform1 = True
    Else
    Set ff = Form1
    End If
    X = ff.Left / DXP
    Y = ff.top / DYP
    If useform1 Then Form1.Visible = False
    ff.Hide
    Sleep 50
    MyDoEvents1 ff, True
    
    Dim aa As New cDIBSection
    aa.CreateFromPicture hDCToPicture(GetDC(0), X, Y, ff.Width / DXP, ff.Height / DYP)
    aa.ThumbnailPaint ff
    GdiFlush
      ff.Visible = True
      
    If useform1 Then Form1.Visible = True
    
End If
Set ff = Nothing
End Sub
Private Sub FillBack(thathDC As Long, there As RECT, bgcolor As Long)
' create brush
Dim my_brush As Long
my_brush = CreateSolidBrush(bgcolor)
FillRect thathDC, there, my_brush
DeleteObject my_brush
End Sub

Public Sub ScrollUpNew(D As Object, mb As basket)
If TypeOf D Is MetaDc Then Exit Sub
Dim Ar As RECT, r As Long
Dim p As Long
With mb
Ar.Left = 0
Ar.Bottom = D.Height / dv15
Ar.Right = D.Width / dv15
Ar.top = .mysplit * .Yt / dv15
p = .Yt / dv15
r = BitBlt(D.Hdc, CLng(Ar.Left), CLng(Ar.top), CLng(Ar.Right), CLng(Ar.Bottom - p), D.Hdc, CLng(Ar.Left), CLng(Ar.top + p), SRCCOPY)

 
  Ar.top = Ar.Bottom - p
FillBack D.Hdc, Ar, .Paper
.curpos = 0
.currow = .mY - 1
End With
GdiFlush
End Sub
Public Sub ScrollDownNew(D As Object, mb As basket)
If TypeOf D Is MetaDc Then Exit Sub
Dim Ar As RECT, r As Long
Dim p As Long
With mb
Ar.Left = 0
Ar.Bottom = D.ScaleY(D.Height, 1, 3)
Ar.Right = D.ScaleX(D.Width, 1, 3)
Ar.top = D.ScaleY(.mysplit * .Yt, 1, 3)
p = D.ScaleY(.Yt, 1, 3)
r = BitBlt(D.Hdc, CLng(Ar.Left), CLng(Ar.top + p), CLng(Ar.Right), CLng(Ar.Bottom - p), D.Hdc, CLng(Ar.Left), CLng(Ar.top), SRCCOPY)
D.Line (0, .mysplit * .Yt)-(D.ScaleWidth, .mysplit * .Yt + .Yt), .Paper, BF
.currow = .mysplit
.curpos = 0
End With
End Sub

Public Sub SetText(dq As Object, Optional alinespace As Long = -1, Optional ResetColumns As Boolean = False)
' can be used for first time also
Dim mymul As Long
On Error Resume Next
With players(GetCode(dq))
If .FontName = vbNullString Or alinespace = -2 Then
' we have to make it
If alinespace = -2 Then alinespace = 0
ResetColumns = True
.FontName = dq.FontName
.charset = dq.Font.charset
.SZ = dq.FontSize

Else
If Not (fonttest.FontName = .FontName And fonttest.Font.charset = dq.Font.charset And fonttest.Font.Size = .SZ) Then
fonttest.Font.charset = .charset
If fonttest.Font.charset = .charset Then
StoreFont .FontName, .SZ, .charset
dq.Font.charset = 0
dq.FontSize = 9
dq.FontName = .FontName
dq.Font.charset = .charset
dq.FontSize = .SZ
End If
End If
End If
If alinespace <> -1 Then
If .uMineLineSpace = .MineLineSpace * 2 And .MineLineSpace <> 0 Then
.MineLineSpace = alinespace
.uMineLineSpace = alinespace * 2
Else
.MineLineSpace = alinespace
.uMineLineSpace = alinespace ' so now we have normal
End If
End If
.SZ = dq.FontSize
.Xt = fonttest.TextWidth("W") + dv15
.Yt = fonttest.TextHeight("fj")
.overrideTextHeight = .Yt

.mX = Int(dq.Width / .Xt)
.mY = Int(dq.Height / (.Yt + .uMineLineSpace * 2))
''.Paper = dq.BackColor
If .mY <= 0 Then .mY = 1
If .mX <= 0 Then .mX = 1
.Yt = .Yt + .uMineLineSpace * 2
If ResetColumns Then
mymul = Int(.mX / 8)
If mymul = 1 Then mymul = 2
If mymul = 0 Then
.Column = .mX \ 2 - 1
Else
.Column = Int(.mX / mymul)
While (.mX Mod .Column) > 0 And (.mX / .Column >= 3)
.Column = .Column + 1
Wend
End If
If .Column = 0 Then .Column = .mX
.Column = .Column - 1
If .Column < 4 Then .Column = 4
End If
.MAXXGRAPH = dq.Width
.MAXYGRAPH = dq.Height
End With

End Sub

Public Sub SetTextSZ(dq As Object, mSz As Single, Optional factor As Single = 1, Optional AddTwipsTop As Long = -1)
' Used for making specific basket
On Error Resume Next
With players(GetCode(dq))
If AddTwipsTop < 0 Then
    If .double And factor = 1 Then
    .mysplit = .osplit
    .Column = .OCOLUMN
    .currow = (.currow + 1) * 2 - 2
    .curpos = .curpos * 2
    If .UseDouble > 0 Then
        mSz = .UseDouble
        .UseDouble = 0 ' .SZ
    Else
        mSz = .SZ / 2
    End If
    .uMineLineSpace = .MineLineSpace
    .double = False
    ElseIf factor = 2 And Not .double Then
     .osplit = .mysplit
     .OCOLUMN = .Column
     .Column = .Column \ 2
     .mysplit = .mysplit \ 2
     .currow = (.currow + 1) \ 2
     .curpos = .curpos / 2
     If .UseDouble > 0 Then
        mSz = .UseDouble
        .UseDouble = 0
     Else
     If Not .IamEmf Then
    Dim oldTH As Long
    oldTH = dq.TextHeight("A")
    .UseDouble = .SZ
     mSz = .SZ * 2
     dq.FontSize = mSz
     Do While oldTH * 2 < dq.TextHeight("A")
     mSz = mSz - 0.25
     If mSz < 1 Then mSz = 1: Exit Do
     dq.FontSize = mSz
     Loop
     Else
     .UseDouble = .SZ
     mSz = .SZ * 2
     dq.FontSize = mSz
     End If
     
     End If
    .uMineLineSpace = .MineLineSpace * 2
    .double = True
    End If
Else

mSz = mSz * factor
.MineLineSpace = AddTwipsTop
.uMineLineSpace = AddTwipsTop * factor
.double = factor <> 1
End If
dq.FontSize = mSz
.SZ = mSz
StoreFont dq.Font.Name, mSz, dq.Font.charset
If .double Then
    Dim nowtextheight As Long
    nowtextheight = fonttest.TextHeight("fj")
    If .MineLineSpace = 0 Then
    Else
    If (.Yt - .MineLineSpace * 2) * 2 <> nowtextheight Then
    .uMineLineSpace = Int((.MAXYGRAPH - nowtextheight * .mY / 2) / .mY)
    End If
    
    End If
End If
SetText dq



If .mY <= 0 Then .mY = 1
If .mX <= 0 Then .mX = 1
.SZ = dq.FontSize
.MAXXGRAPH = dq.Width
.MAXYGRAPH = dq.Height
End With

End Sub

Public Sub SetTextBasketBack(dq As Object, mb As basket, Optional noerase As Boolean = False)
' set minimum display parameters for current object
' need an already filled basket
On Error Resume Next
With mb
.UseDouble = 0
If Not (dq.FontName = .FontName And dq.Font.charset = .charset And dq.Font.Size = .SZ) Then

StoreFont .FontName, .SZ, .charset
dq.Font.charset = 0
dq.FontSize = 9
dq.FontName = .FontName
dq.Font.charset = .charset
dq.FontSize = .SZ
End If
dq.ForeColor = .mypen And &HFFFFFF
If Not noerase Then
If Not dq.BackColor = .Paper Then
   dq.BackColor = .Paper
End If
End If
End With
End Sub

Function gf$(bstack As basetask, ByVal Y&, ByVal X&, ByVal A$, C&, f&, Optional STAR As Boolean = False)
On Error Resume Next
Dim cLast&, b$, cc$, dq As Object, ownLinespace, oldrefresh As Double, noinp As Double
oldrefresh = REFRESHRATE
Dim mybasket As basket, addpixels As Long
GFQRY = True
Set dq = bstack.Owner
SetText dq
mybasket = players(GetCode(dq))

With mybasket
If InternalLeadingSpace() = 0 And .MineLineSpace = 0 Then
addpixels = 0
Else
addpixels = 2
End If
If dq.Visible = False Then dq.Visible = True
If exWnd = 0 Then dq.SetFocus
dq.FontTransparent = False
LCTbasket dq, mybasket, Y&, X&
Dim o$
o$ = A$
If A$ = vbNullString Then A$ = " "
INK$ = vbNullString

Dim XX&
XX& = X&

X& = X& - 1

cLast& = Len(A$)
'*****************
If cLast& + X& >= .mX Then
MyDoEvents
If dq.Font.charset = 161 Then
b$ = InputBoxN("ÅéóáãùãÞ ÔéìÞò Ðåäßïõ", MesTitle$, A$, noinp)
Else
b$ = InputBoxN("Input Field Value", MesTitle$, A$, noinp)
End If
If noinp <> 1 Then b$ = A$
If MyTrim(b$) < "A" Then b$ = Right$(String$(cLast&, " ") + b$, cLast&) Else b$ = Left$(b$ + String$(cLast&, " "), cLast&)
gf$ = b$
If XX& < .mX Then
dq.FontTransparent = False
If STAR Then
PlainBaSket dq, mybasket, StarSTR(Left$(b$, .mX - X&)), True, , addpixels
Else
PlainBaSket dq, mybasket, Left$(b$, .mX - X&), True, , addpixels
End If
End If
GoTo GFEND
Else
dq.FontTransparent = False
If STAR Then
PlainBaSket dq, mybasket, StarSTR(A$), True, , addpixels
Else
PlainBaSket dq, mybasket, A$, True, , addpixels
End If
End If

'************
b$ = A$
.currow = Y&
.curpos = C& + X&
LCTCB dq, mybasket, ins&

Do
MyDoEvents1 Form1, , True
If bstack.IamThread Then If myexit(bstack) Then GoTo contgfhere
If Not TaskMaster Is Nothing Then
If TaskMaster.QueueCount > 0 Then
dq.FontTransparent = True
TaskMaster.RestEnd1
TaskMasterTick
End If
End If
 cc$ = INKEY$
 If cc$ <> "" Then
If Not TaskMaster Is Nothing Then TaskMaster.rest
SetTextBasketBack dq, mybasket, True
 Else
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd
SetTextBasketBack dq, mybasket, True
        If iamactive Then
           If Screen.ActiveForm Is Nothing Then
                            DestroyCaret
                      nomoveLCTC dq, mybasket, Y&, C& + X&, ins&
                      iamactive = False
           Else
                If Not (GetForegroundWindow = Screen.ActiveForm.hWnd And Screen.ActiveForm.Name = "Form1") Then
                 
                      DestroyCaret
                      nomoveLCTC dq, mybasket, Y&, C& + X&, ins&
                      iamactive = False
             Else
                         If ShowCaret(dq.hWnd) = 0 Then
                                   HideCaret dq.hWnd
                                   .currow = Y&
                                   .curpos = C& + X&
                                   LCTCB dq, mybasket, ins&
                                   ShowCaret dq.hWnd
                         End If
                End If
                End If
     Else
  If Not Screen.ActiveForm Is Nothing Then
            If GetForegroundWindow = Screen.ActiveForm.hWnd And Screen.ActiveForm.Name = "Form1" Then
           
                          nomoveLCTC dq, mybasket, Y&, C& + X&, ins&
                             iamactive = True
                              If ShowCaret(dq.hWnd) = 0 And Screen.ActiveForm.Name = "Form1" Then
                                   HideCaret dq.hWnd
                                   .currow = Y&
                                   .curpos = C& + X&
                                   LCTCB dq, mybasket, ins&
                                   ShowCaret dq.hWnd
                         End If
                         End If
            End If
     End If

 End If

 
        If NOEXECUTION Then
        If KeyPressed(&H1B) Then
                       f& = 99 'ESC  ****************
                        C& = 1
                        gf$ = o$
                        b$ = o$
                                          NOEXECUTION = False
                                         BLOCKkey = True
                                    While KeyPressed(&H1B)
                                    If Not TaskMaster Is Nothing Then
                             If TaskMaster.Processing Then
                                                TaskMaster.RestEnd1
                                                TaskMaster.TimerTick
                                                TaskMaster.rest
                                                MyDoEvents1 dq
                                                Else
                                                MyDoEvents
                                                
                                                End If
                                                Else
                                                DoEvents
                                                End If
'''sleepwait 1
                                    Wend
                        BLOCKkey = False
                        End If
                 Exit Do
        End If
        Select Case Len(cc$)
        Case 0
        If Fkey > 0 Then
        If FK$(Fkey) <> "" And Fkey <> 13 Then
            cc$ = FK$(Fkey)
            interpret Basestack1, cc$
        
        End If
        Fkey = 0
        Else
        
        End If
        
        Case 1
        If STAR And cc$ = " " Then cc$ = Chr$(127)
                Select Case AscW(cc$)
                Case 8
                        If C& > 1 Then
                        Mid$(b$, C& - 1) = Mid$(b$, C&) + " "
                         C& = C& - 1
                         dq.FontTransparent = False
                                   .currow = Y&
                                   .curpos = C& + X&
                                   LCTCB dq, mybasket, ins&
                        If STAR Then
                        PlainBaSket dq, mybasket, StarSTR(Mid$(b$, C&)), True, , addpixels
                        Else
                        PlainBaSket dq, mybasket, Mid$(b$, C&), True, , addpixels
                        End If
                         dq.Refresh
                                   .currow = Y&
                                   .curpos = C& + X&
                                   LCTCB dq, mybasket, ins&
                        End If
                Case 6
                f& = -1
                 gf$ = b$
                Exit Do
                Case 13, 9
                f& = 1 'NEXT  *************
                gf$ = b$
                Exit Do

                Case 27
                        f& = 99 'ESC  ****************
                        C& = 1
                        gf$ = o$
                        b$ = o$
                                    NOEXECUTION = False
                                    BLOCKkey = True
                                    While KeyPressed(&H1B)
                                    If Not TaskMaster Is Nothing Then
                                    If TaskMaster.Processing Then
                                            TaskMaster.RestEnd1
                                            TaskMaster.TimerTick
                                            TaskMaster.rest
                                            MyDoEvents1 dq
                                            Else
                                            MyDoEvents
                                            
                                            End If
                                            Else
                                            DoEvents
                                            End If
                                    '''
                                    Wend
                                                                        BLOCKkey = False
                        NOEXECUTION = False
                        Exit Do
                       Case 32 To 126, Is > 128
           
                        .currow = Y&
                        .curpos = C& + X&
                        LCTCB dq, mybasket, ins&
                        If ins& = 1 Then
                          If AscW(cc$) = 32 And STAR Then
                If AscW(Mid$(b$, C& + 1)) > 32 Then
                 Mid$(b$, C&) = Mid$(b$, C& + 1) + " "
                End If
                
                
                Else
                        
                                                
                        Mid$(b$, C&, 1) = cc$
                        dq.FontTransparent = False
                        If STAR Then
                        PlainBaSket dq, mybasket, StarSTR(Mid$(b$, C&)), True, , addpixels
                        Else
                        PlainBaSket dq, mybasket, Mid$(b$, C&), True, , addpixels
                        End If
                         dq.Refresh
                        End If
                        If C& < Len(b$) Then C& = C& + 1
                                   .currow = Y&
                                   .curpos = C& + X&
                                   LCTCB dq, mybasket, ins&
                        Else
                                 If AscW(cc$) = 32 And STAR Then
            
                
                
                Else
                     
                        LSet b$ = Left$(b$, C& - 1) + cc$ + Mid$(b$, C&)
                        dq.FontTransparent = False
                        If STAR Then
                        PlainBaSket dq, mybasket, StarSTR(Mid$(b$, C&)), True, , addpixels
                        Else
                        PlainBaSket dq, mybasket, Mid$(b$, C&), True, , addpixels
                        End If
                         dq.Refresh
                        'LCTC Dq, Y&, X& + C& + 1, INS&
                        End If
                        If C& < cLast& Then C& = C& + 1
                                .currow = Y&
                                .curpos = C& + X&
                                LCTCB dq, mybasket, ins&
                        End If
                End Select
        Case 2
                Select Case AscW(Right$(cc$, 1))
                Case 81
                f& = 10 ' exit - pagedown ***************
                gf$ = b$
                Exit Do
                Case 73
                f& = -10 ' exit - pageup
                gf$ = b$
                Exit Do
                Case 79
                f& = 20 ' End
                gf$ = b$
                Exit Do
                Case 71
                f& = -20 ' exit - home
                gf$ = b$
                Exit Do
                Case 75 'LEFT
                        If C& > 1 Then
                                   .currow = Y&
                                .curpos = C& + X&
                                LCTCB dq, mybasket, ins&
                        C& = C& - 1:
                        .currow = Y&
                        .curpos = C& + X&
                        LCTCB dq, mybasket, ins&
                        End If
                Case 77 'RIGHT
                        If C& < cLast& Then
                      
                If Not (AscW(Mid$(b$, C&)) = 32 And STAR) Then
                
             
                                    .currow = Y&
                                .curpos = C& + X&
                                LCTCB dq, mybasket, ins&
                        C& = C& + 1:
                        .currow = Y&
                                .curpos = C& + X&
                                LCTCB dq, mybasket, ins&
                        End If
                        End If
                Case 72 ' EXIT UP
                f& = -1 ' PREVIUS ***************
                gf$ = b$
                Exit Do
                Case 80 'EXIT DOWN OR ENTER OR TAB
                f& = 1 'NEXT  *************
                gf$ = b$
                Exit Do
                Case 82
                            .currow = Y&
                                .curpos = C& + X&
                                LCTCB dq, mybasket, ins&
                ins& = 1 - ins&
                           .currow = Y&
                                .curpos = C& + X&
                                LCTCB dq, mybasket, ins&
                Case 83
                        Mid$(b$, C&) = Mid$(b$, C& + 1) + " "
                        dq.FontTransparent = False
                        LCTbasket dq, mybasket, Y&, C& + X&
                        If STAR Then
                        PlainBaSket dq, mybasket, StarSTR(Mid$(b$, C&)), True, , addpixels
                        Else
                        PlainBaSket dq, mybasket, Mid$(b$, C&), True, , addpixels
                        End If
                               .currow = Y&
                                .curpos = C& + X&
                                LCTCB dq, mybasket, ins&
                     dq.Refresh
                End Select
        End Select
      If GFQRY = False Then Exit Do
Loop

GFEND:
REFRESHRATE = oldrefresh
LCTbasket dq, mybasket, Y&, X& + 1
If X& < .mX And Not XX& > .mX Then
If STAR Then
 PlainBaSket dq, mybasket, StarSTR(b$), True, , addpixels
Else
PlainBaSket dq, mybasket, b$, True, , addpixels
End If
contgfhere:
 dq.Refresh
If Not TaskMaster Is Nothing Then If TaskMaster.QueueCount > 0 Then TaskMaster.RestEnd
End If
dq.FontTransparent = True
 DestroyCaret
Set dq = Nothing
TaskMaster.RestEnd1
GFQRY = False
End With
End Function

Function StarSTR(ByVal sStr As String) As String
Dim L As Long, s As Long
L = Len(sStr)
sStr = RTrim$(sStr)
s = L - Len(sStr)
StarSTR = String$(L - s, "*") + String$(s, " ")

End Function
Function ProcBeep(bstack As basetask, rest$) As Boolean
Dim p As Variant
If IsExp(bstack, rest$, p, nostring:=True) Then
MessageBeep CLng(p)
Else
Beep
End If
ProcBeep = True
End Function
Public Sub ResetPrefresh()
Dim I As Long
For I = -2 To 131
    Prefresh(I).k1 = 0
    Prefresh(I).RRCOUNTER = 0
Next I

End Sub

Sub original(bstack As basetask, COM$)
Dim D As Object, b$

If Len(COM$) > 0 Then QUERYLIST = vbNullString
If Form1.Visible Then REFRESHRATE = 25: ResetPrefresh
If bstack.toprinter Then
bstack.toprinter = False
Form1.PrinterDocument1.Cls
Set D = bstack.Owner
Else
Set D = bstack.Owner
End If
On Error Resume Next
Dim basketcode As Long
basketcode = GetCode(D)


Form1.IEUP ""
Form1.KeyPreview = True
Dim dummy As Boolean, rs As String, mPen As Long, ICO As Long, BAR As Long, bar2 As Long
BAR = 1
Form1.DIS.Visible = True
GDILines = False  ' reset to normal ' use Smooth on to change this to true
If COM$ <> "" Then D.Visible = False
ClrSprites
mPen = PenOne
D.Font.bold = bstack.myBold
D.Font.Italic = bstack.myitalic
GetMonitorsNow
Console = FindFormSScreen(Form1)
'' Console = FindPrimary
With ScrInfo(Console)
If SzOne < 4 Then SzOne = 4
    'Form1.Visible = False
   ' If IsWine Then
    Sleep 30
    .Width = .Width - 1
    .Height = .Height - 1
   ' End If
    If Not Form1.WindowState = 0 Then Form1.WindowState = 0
    Sleep 10
    If Form1.WindowState = 0 Then
        Form1.move .Left, .top, .Width - 1, .Height - 1
        If Form1.top <> .Left Or Form1.Left <> .top Then
            Form1.Cls
            Form1.move .Left, .top, .Width - 1, .Height - 1
        End If
    Else
        Sleep 100
        On Error Resume Next
        Form1.WindowState = 0
        Form1.move .Left, .top, .Width - 1, .Height - 1
        If Form1.top <> .top Or Form1.Left <> .Left Then
        Form1.Cls
        Form1.move .Left, .top, .Width - 1, .Height - 1
        End If
    End If
NoBackFormFirstUse = False
If players(-1).MAXXGRAPH <> 0 Then ClearScrNew Form1, players(-1), 0&
Form1.DIS.Visible = True
FrameText D, SzOne, (.Width + .Left - 1 - Form1.Left), (.Height + .top - 1 - Form1.top), PaperOne
End With
Form1.DIS.BackColor = mycolor(PaperOne)
If lckfrm = 0 Then
SetText D
bstack.Owner.Font.charset = bstack.myCharSet
StoreFont bstack.Owner.Font.Name, SzOne, bstack.myCharSet
 
 With players(basketcode)
.mypen = PenOne
.XGRAPH = 0
.YGRAPH = 0
.bold = bstack.myBold '' I have to change that
.italics = bstack.myitalic
.FontName = bstack.Owner.FontName
.SZ = SzOne
.charset = bstack.myCharSet
.MAXXGRAPH = Form1.Width
.MAXYGRAPH = Form1.Height
.Paper = bstack.Owner.BackColor
.mypen = mycolor(PenOne)
End With


 
' check to see if
Dim ss$, skipthat As Boolean
If Not IsSupervisor Then
    ss$ = ReadUnicodeOrANSI(userfiles + "desktop.inf")
    LastErNum = 0
    If ss$ <> "" Then
     skipthat = interpret(bstack, ss$)
     If mycolor(PenOne) <> D.ForeColor Then
     PenOne = -D.ForeColor
     End If
    End If
End If
If SzOne < 36 And D.Height / SzOne > 250 Then SetDouble D: BAR = BAR + 1
If SzOne < 83 Then

If bstack.myCharSet = 161 Then
b$ = "ÐÅÑÉÂÁËËÏÍ "
Else
b$ = "ENVIRONMENT "
End If
D.ForeColor = mycolor(PenOne)
LCTbasket D, players(DisForm), 0, 0
wwPlain2 bstack, players(DisForm), b$ + "M2000", D.Width, 0, 0 '',True
ICO = TextWidth(D, b$ + "M2000") + 100
' draw graphic'
Dim iX As Long, iY As Long
With players(DisForm)
If Form1.icon.Height = 0 Then
Else
iX = (.Xt \ 25) * 25
iY = Form1.icon.Height * iX / Form1.icon.Width
If IsWine Then
Form1.DIS.PaintPicture Form1.icon, ICO, (.Yt - iY) / 2, iX, iY
Form1.DIS.PaintPicture Form1.icon, ICO, (.Yt - iY) / 2, iX, iY
Else
Dim myico As New cDIBSection
myico.BackColor = Form1.DIS.BackColor
myico.CreateFromPicture Form1.icon
Form1.DIS.PaintPicture myico.Picture(1), ICO, (.Yt - iY) / 2, iX, iY
End If
End If
End With

' ********
SetNormal D
   Dim osbit As String
   If Is64bit Then osbit = " (64-bit)" Else osbit = " (32-bit)"
        LCTbasket D, players(basketcode), BAR, 0
        rs = vbNullString
            If bstack.myCharSet = 161 Then
            If Revision = 0 Then
            wwPlain2 bstack, players(DisForm), "¸êäïóç ÄéåñìçíåõôÞ: " + CStr(VerMajor) + "." + CStr(VerMinor), D.Width, 0, True
            Else
                    wwPlain2 bstack, players(DisForm), "¸êäïóç ÄéåñìçíåõôÞ: " + CStr(VerMajor) + "." + Left$(CStr(VerMinor), 1) + " (" + CStr(Revision) + ")", D.Width, 0, True
                End If
                   wwPlain2 bstack, players(DisForm), "Ëåéôïõñãéêü Óýóôçìá: " + os + osbit, D.Width, 0, True
            
                      wwPlain2 bstack, players(DisForm), "¼íïìá ×ñÞóôç: " + Tcase(Originalusername), D.Width, 0, True
                
            Else
             If Revision = 0 Then
              wwPlain2 bstack, players(DisForm), "Interpreter Version: " + CStr(VerMajor) + "." + CStr(VerMinor), D.Width, 0, True
             Else
                    wwPlain2 bstack, players(DisForm), "Interpreter Version: " + CStr(VerMajor) + "." + Left$(CStr(VerMinor), 1) + " rev. (" + CStr(Revision) + ")", D.Width, 0, True
                 End If
              
                      wwPlain2 bstack, players(DisForm), "Operating System: " + os + osbit, D.Width, 0, True
                
                   wwPlain2 bstack, players(DisForm), "User Name: " + Tcase(Originalusername), D.Width, 0, True
        
                 End If
                        '    cr bstack
            GetXYb D, players(basketcode), bar2, BAR
             players(basketcode).curpos = bar2
            players(basketcode).currow = BAR
           BAR = BAR + 1
            If BAR >= players(basketcode).mY Then ScrollUpNew D, players(basketcode)
                    LCTbasket D, players(basketcode), BAR, 0
                    players(basketcode).curpos = 0
            players(basketcode).currow = BAR
    End If
If Not ASKINUSE Then Load NeoMsgBox
If Not skipthat Then

ProcPen bstack, CStr(mPen) + ", 255"
ProcCls bstack, "," & (BAR)
' dummy = interpret(bstack, "PEN " & CStr(mPen) & ":CLS ," & CStr(BAR))
End If
If Not ASKINUSE Then Unload NeoMsgBox
End If
If Not skipthat Then
    If Len(COM$) > 0 Then dummy = interpret(bstack, COM$)
End If
'cr bstack
End Sub
Sub ClearScr(D As Object, c1 As Long)
Dim aa As Long
With players(GetCode(D))
.Paper = c1
.curpos = 0
.currow = 0
.lastprint = False
End With
If Not TypeOf D Is MetaDc Then
D.Line (0, 0)-(D.ScaleWidth - dv15, D.ScaleHeight - dv15), c1, BF
End If
D.currentX = 0
D.currentY = 0

End Sub
Sub ClearScrNew(D As Object, mb As basket, c1 As Long)
Dim iM As New StdPicture, spl As Long
If TypeOf D Is MetaDc Then
D.BackColor = c1
Exit Sub
End If
With mb
spl = .mysplit * .Yt
Set iM = D.Image
.Paper = c1

If TypeOf D Is GuiM2000 Then
If .mysplit = 0 Then
    If Not D.BackColor = c1 Then D.BackColor = c1
    D.Cls
Else
    D.Line (0, spl)-(D.ScaleWidth - dv15, D.ScaleHeight - dv15), .Paper, BF
    End If
    .currow = .mysplit
ElseIf D.Name = "Form1" Or mb.used Then
D.Line (0, spl)-(D.ScaleWidth - dv15, D.ScaleHeight - dv15), .Paper, BF
.curpos = 0
.currow = .mysplit
Else
D.BackColor = c1
If spl > 0 Then D.PaintPicture iM, 0, 0, D.Width, spl, 0, 0, D.Width, spl, vbSrcCopy
.curpos = 0
.currow = .mysplit

End If
.lastprint = False
D.currentX = 0
D.currentY = 0
End With
End Sub
Function iText(bb As basetask, ByVal v$, wi&, Hi&, aTitle$, n As Long, Optional NumberOnly As Boolean = False, Optional UseIntOnly As Boolean = False, Optional curset = -1&) As String
Dim X&, Y&, dd As Object, wh&, shiftlittle As Long, oldV$
Set dd = bb.Owner
With players(GetCode(dd))
If .lastprint Then
X& = (dd.currentX + .Xt - dv15) \ .Xt
Y& = dd.currentY \ .Yt
shiftlittle = X& * .Xt - dd.currentX
If Y& > .mX Then
Y& = .mX - 1
crNew bb, players(GetCode(dd))

End If
Else
X& = .curpos
Y& = .currow
End If
If .mX - X& - 1 < wi& Then wi& = .mX - X&
If .mY - Y& - 1 < Hi& Then Hi& = .mY - Y& - 1
If wi& = 0 Or Hi& < 0 Then
iText = v$
Exit Function
End If
wi& = wi& + X&
Hi& = Hi& + Y&
Form1.EditTextWord = True
wh& = CLng(curset)
Dim oldshow As Boolean
With Form1.TEXT1
     oldshow = .showparagraph
    .showparagraph = False
    
    If n <= 0 Then .Title = aTitle$ + " ": If wh& = -1& Then wh& = Abs(n - 1)
    If NumberOnly Then
     .glistN.UseTab = False
        .NumberOnly = True
        .NumberIntOnly = UseIntOnly
        oldV$ = v$
        ScreenEdit bb, v$, X&, Y&, wi& - 1, Hi&, wh&, , n, shiftlittle
        If result = 99 Then v$ = oldV$
        .NumberIntOnly = False
        .NumberOnly = False
    Else
    .glistN.UseTab = True
        oldV$ = v$
        ScreenEdit bb, v$, X&, Y&, wi& - 1, Hi&, wh&, , n, shiftlittle
        If result = 99 And Hi& = wi& Then v$ = oldV$
    End If
    .showparagraph = oldshow
    .glistN.UseTab = UseTabInForm1Text1
End With
iText = v$
End With
End Function
Sub ScreenEditDOC(bstack As basetask, aaa As Variant, X&, Y&, x1&, y1&, Optional L As Long = 0, Optional usecol As Boolean = False, Optional Col As Long)
On Error Resume Next
Dim ot As Boolean, back As New Document, I As Long, D As Object
Dim prive As basket
Set D = bstack.Owner
prive = players(GetCode(D))
With prive
Dim oldesc As Boolean
oldesc = escok
escok = False
' we have a limit here
If Not aaa.IsEmpty Then
For I = 1 To aaa.DocParagraphs
back.AppendParagraph aaa.TextParagraph(I)
Next I
End If
I = back.LastSelStart
Dim Aaaa As Document, tcol As Long, trans As Boolean
If usecol Then tcol = mycolor(Col) Else tcol = D.BackColor
If Not Form1.Visible Then newshow Basestack1

'd.Enabled = False
If Not bstack.toback Then D.TabStop = False
If D Is Form1 Then
D.lockme = True
Else
D.Parent.lockme = True
End If
If y1& - Y& = 0 Then Y& = Y& - 1: If y1& < 0 Then Y& = Y& + 1: y1& = y1& + 1
TextEditLineHeight = y1& - Y& + 1

With Form1.TEXT1

ProcTask2 bstack
.glistN.UseTab = True
Hook Form1.hWnd, Nothing '.glistN
.AutoNumber = Not Form1.EditTextWord

.UsedAsTextBox = False
.glistN.LeftMarginPixels = 10
.glistN.maxchar = 0
If D.ForeColor = tcol Then
Set Form1.Point2Me = D
If D.Name = "Form1" Then
.glistN.SkipForm = False
Else
.glistN.SkipForm = True
End If
Form1.TEXT1.glistN.BackStyle = 1
End If
Dim scope As Long
scope = ChooseByHue(D.ForeColor, rgb(16, 12, 8), rgb(253, 245, 232))
If D.BackColor = ChooseByHue(scope, D.BackColor, rgb(128, 128, 128)) Then
If lightconv(scope) > 192 Then
scope = lightconv(scope) - 128
.glistN.CapColor = rgb(128 + scope / 2, 128 + scope / 2, 128 + scope / 2)
Else
.glistN.CapColor = scope
End If
Else
scope = lightconv(scope) - 128

If scope > 0 Then
.glistN.CapColor = rgb(128 + scope / 2, 128 + scope / 2, 128 + scope / 2)
Else
.glistN.CapColor = rgb(128, 128, 128)
End If
End If
.SelectionColor = .glistN.CapColor
.glistN.addpixels = 2 * prive.uMineLineSpace / dv15
.EditDoc = True
.enabled = True
.glistN.ZOrder 0

.BackColor = tcol

.ForeColor = D.ForeColor
Form1.SetText1
.glistN.overrideTextHeight = prive.overrideTextHeight '         fonttest.TextHeight("fj")
.Font.Name = D.Font.Name
.Font.Size = D.Font.Size ' SZ 'Int(d.font.Size) Why
.Font.charset = D.Font.charset
.Font.Italic = D.Font.Italic
.Font.bold = D.Font.bold
.Font.Name = D.Font.Name
.Font.charset = D.Font.charset
.Font.Size = prive.SZ
With prive
If bstack.toback Then

Form1.TEXT1.move X& * .Xt, Y& * .Yt, (x1& - X&) * .Xt + .Xt, (y1& - Y&) * .Yt + .Yt
Else
Form1.TEXT1.move X& * .Xt + D.Left, Y& * .Yt + D.top, (x1& - X&) * .Xt + .Xt, (y1& - Y&) * .Yt + .Yt
End If
End With
If D.ForeColor = tcol Then
If D.Name = "Form1" Then
Form1.TEXT1.glistN.RepaintFromOut D.Image, D.Left, D.top
Else
Form1.TEXT1.glistN.RepaintFromOut D.Image, 0, 0
End If

End If

Set .mDoc = aaa
.mDoc.ColorEvent = True
.nowrap = False


With Form1.TEXT1
.Form1mn1Enabled = False
.Form1mn2Enabled = False
.Form1mn3Enabled = Clipboard.GetFormat(13) Or Clipboard.GetFormat(1)
End With

Form1.KeyPreview = False
NOEDIT = False

.WrapAll
.Render

.Visible = True
.SetFocus
If L <> 0 Then
    If L > 0 Then
        If aaa.SizeCRLF < L Then L = aaa.SizeCRLF
        
        .SelStart = L
        Else
        .SelStart = 0
    End If
Else
If aaa.SizeCRLF < .LastSelStart Then
.SelStart = 1
Else
 .SelStart = .LastSelStart
End If
End If
    .ResetUndoRedo

End With
'
ProcTask2 bstack
CancelEDIT = False
Do
BLOCKkey = False

 If bstack.IamThread Then If myexit(bstack) Then GoTo contScreenEditThere1

ProcTask2 bstack


'End If

Loop Until NOEDIT
 NOEXECUTION = False
 BLOCKkey = True
While KeyPressed(&H1B)
ProcTask2 bstack

Wend
BLOCKkey = False
contScreenEditThere1:
Form1.StoreBookMarks
TaskMaster.RestEnd1
If Form1.TEXT1.Visible Then Form1.TEXT1.Visible = False
 L = Form1.TEXT1.LastSelStart


If D Is Form1 Then
D.lockme = False
Else
D.Parent.lockme = False
End If
If Not CancelEDIT Then

Else
Set aaa = back
back.LastSelStart = I
End If
Set Form1.TEXT1.mDoc = New Document
Form1.TEXT1.glistN.UseTab = UseTabInForm1Text1
Form1.TEXT1.glistN.BackStyle = 0
Set Form1.Point2Me = Nothing
UnHook Form1.hWnd
Form1.KeyPreview = True

INK$ = vbNullString
escok = oldesc
Set D = Nothing
End With
End Sub
Sub ScreenEdit(bstack As basetask, A$, X&, Y&, x1&, y1&, Optional L As Long = 0, Optional changelinefeeds As Long = 0, Optional maxchar As Long = 0, Optional ExcludeThisLeft As Long = 0, Optional internal As Boolean = False)
On Error Resume Next
' allways a$ enter with crlf,but exit with crlf or cr or lf depents from changelinefeeds
Dim oldesc As Boolean, D As Object
Set D = bstack.Owner

''SetTextSZ d, Sz

Dim prive As basket
prive = players(GetCode(D))
oldesc = escok
escok = False
Dim ot As Boolean

If Not bstack.toback Then
D.TabStop = False
D.Parent.lockme = True
Else
D.lockme = True
End If
If Not Form1.Visible Then newshow Basestack1
D.Visible = True
If D.Visible Then D.SetFocus
With Form1.TEXT1

ProcTask2 bstack
Hook Form1.hWnd, Nothing
'.Filename = VbNullString
.AutoNumber = Not Form1.EditTextWord

If maxchar > 0 Then
ot = .glistN.DragEnabled
 .glistN.DragEnabled = True
y1& = Y&
TextEditLineHeight = 1
.glistN.BorderStyle = 0
.glistN.BackStyle = 1
Set Form1.Point2Me = D
If D.Name = "Form1" Then
.glistN.SkipForm = False
Else
.glistN.SkipForm = True
End If

.glistN.HeadLine = vbNullString
.glistN.HeadLine = vbNullString
.glistN.LeftMarginPixels = 1
.glistN.maxchar = maxchar
.nowrap = True
If Len(A$) > maxchar Then
A$ = Left$(A$, maxchar)
End If
If L = -1 Then
L = Len(A$) + 1
Else
L = 1
End If

.UsedAsTextBox = True

Else
.glistN.BorderStyle = 0
.glistN.BackStyle = 0

If y1& - Y& = 0 Then Y& = Y& - 1: If y1& < 0 Then Y& = Y& + 1: y1& = y1& + 1
TextEditLineHeight = y1& - Y& + 1
.UsedAsTextBox = False
.glistN.LeftMarginPixels = 10
.glistN.maxchar = 0

End If

If Form1.EditTextWord Then
.glistN.WordCharLeft = ConCat(":", "{", "}", "[", "]", ",", "(", ")", "!", ";", "=", ">", "<", """", " ", "+", "-", "/", "*", "^", "$", "%", "_", "@")
.glistN.WordCharRight = ConCat(".", ":", "{", "}", "[", "]", ",", ")", "!", ";", "=", ">", "<", """", " ", "+", "-", "/", "*", "^", "$", "%", "_")
.glistN.WordCharRightButIncluded = vbNullString
.glistN.WordCharLeftButIncluded = vbNullString

Else
.glistN.WordCharLeft = ConCat(":", "{", "}", "[", "]", ",", "(", ")", "!", ";", "=", ">", "<", "'", """", " ", "+", "-", "/", "*", "^", "@", Chr$(9), "#", "%", "&")
.glistN.WordCharRight = ConCat(".", ":", "{", "}", "[", "]", ",", ")", "!", ";", "=", ">", "<", "'", """", " ", "+", "-", "/", "*", "^", Chr$(9), "#")
.glistN.WordCharRightButIncluded = "(" ' so aaa(sdd) give aaa( as word
.glistN.WordCharLeftButIncluded = "#"
End If

Dim scope As Long
scope = ChooseByHue(D.ForeColor, rgb(16, 12, 8), rgb(253, 245, 232))
If D.BackColor = ChooseByHue(scope, D.BackColor, rgb(128, 128, 128)) Then
If lightconv(scope) > 192 Then
scope = lightconv(scope) - 128
.glistN.CapColor = rgb(128 + scope / 2, 128 + scope / 2, 128 + scope / 2)
Else
.glistN.CapColor = scope
End If
Else
scope = lightconv(scope) - 128

If scope > 0 Then
.glistN.CapColor = rgb(128 + scope / 2, 128 + scope / 2, 128 + scope / 2)
Else
.glistN.CapColor = rgb(128, 128, 128)
End If
End If
.SelectionColor = .glistN.CapColor
.glistN.addpixels = 2 * prive.uMineLineSpace / dv15
.enabled = False
.EditDoc = True
.enabled = True
'.glistN.AddPixels = 0
.glistN.ZOrder 0
.BackColor = D.BackColor
.ForeColor = D.ForeColor
.Font.Name = D.Font.Name
Form1.SetText1
.glistN.overrideTextHeight = prive.overrideTextHeight '   fonttest.TextHeight("fj")
.Font.Size = D.Font.Size ' SZ 'Int(d.font.Size) Why
.Font.charset = D.Font.charset
.Font.Italic = D.Font.Italic
.Font.bold = D.Font.bold

.Font.Name = D.Font.Name

.Font.charset = D.Font.charset
.Font.Size = prive.SZ 'Int(d.font.Size)
If bstack.toback Then
If maxchar > 0 Then

.move X& * prive.Xt - ExcludeThisLeft, Y& * prive.Yt, (x1& - X&) * prive.Xt + prive.Xt, (y1& - Y&) * prive.Yt + prive.Yt
If D.Name = "Form1" Then
.glistN.RepaintFromOut D.Image, D.Left, D.top
Else
.glistN.RepaintFromOut D.Image, 0, 0
End If
Else
.move X& * prive.Xt, Y& * prive.Yt, (x1& - X&) * prive.Xt + prive.Xt, (y1& - Y&) * prive.Yt + prive.Yt
End If
Else
If maxchar > 0 Then
.move X& * prive.Xt + D.Left - ExcludeThisLeft, Y& * prive.Yt + D.top, (x1& - X&) * prive.Xt + prive.Xt, (y1& - Y&) * prive.Yt + prive.Yt
If D.Name = "Form1" Then
.glistN.RepaintFromOut D.Image, D.Left, D.top
Else
.glistN.RepaintFromOut D.Image, 0, 0
End If
Else
.move X& * prive.Xt + D.Left, Y& * prive.Yt + D.top, (x1& - X&) * prive.Xt + prive.Xt, (y1& - Y&) * prive.Yt + prive.Yt
End If
End If
If A$ <> "" Then
If .Text <> A$ Then .LastSelStart = 0
If internal Then
.Text2 = A$
Else
.Text = A$
End If
Else
.Text = vbNullString
.LastSelStart = 0
End If
'.glistN.NoFreeMoveUpDown = True

'With Form1.TEXT1
.Form1mn1Enabled = False
.Form1mn2Enabled = False
.Form1mn3Enabled = Clipboard.GetFormat(13) Or Clipboard.GetFormat(1)
'End With

Form1.KeyPreview = False

NOEDIT = False

If maxchar = 0 Then
If .nowrap Then
.nowrap = False
End If

.Charpos = 1
If Len(A$) < 100000 Then .Render
Else
.Render
End If
If L <> 0 Then
    If L > 0 Then
        If Len(A$) < L Then L = Len(A$) Else L = L - 1
        If .NumberOnly Then
        .SelStart = 0
        .SelLength = L
        Else
        .SelStart = L
        End If
        
                Else
        .SelStart = 0
    End If
Else
If Len(A$) < .LastSelStart Then
.SelStart = 1
L = Len(A$)
Else
    .SelStart = .LastSelStart
End If
End If
.Visible = True
'
ProcTask2 bstack
.SetFocus


    .ResetUndoRedo



End With

ProcTask2 bstack
CancelEDIT = False
Dim Timeout As Long


Do
BLOCKkey = False

 If bstack.IamThread Then If myexit(bstack) Then GoTo contScreenEditThere

ProcTask2 bstack

 Loop Until NOEDIT
 NOEXECUTION = False
 BLOCKkey = True
While KeyPressed(&H1B)
'
ProcTask2 bstack


Wend
BLOCKkey = False
contScreenEditThere:
TaskMaster.RestEnd1
If Form1.TEXT1.Visible Then Form1.TEXT1.Visible = False

 L = Form1.TEXT1.LastSelStart + 1

If bstack.toback Then
D.lockme = False
Else
D.Parent.lockme = False
End If
If Not CancelEDIT Then

If changelinefeeds > 10 Then
A$ = Form1.TEXT1.TextFormatBreak(vbCr)
ElseIf changelinefeeds > 9 Then
A$ = Form1.TEXT1.TextFormatBreak(vbLf)
Else
If changelinefeeds = -1 Then changelinefeeds = 0
A$ = Form1.TEXT1.Text
End If
Else
changelinefeeds = -1
End If

Form1.KeyPreview = True
If maxchar > 0 Then Form1.TEXT1.glistN.DragEnabled = ot

UnHook Form1.hWnd
INK$ = vbNullString
Form1.TEXT1.glistN.UseTab = False
escok = oldesc
Set D = Nothing
End Sub

Function blockCheck(ByVal s$, ByVal Lang As Long, countlines As Long, Optional ByVal sbname$ = vbNullString, Optional Column As Long) As Boolean
If s$ = vbNullString Then blockCheck = True: Exit Function
Dim I As Long, j As Long, C As Long, b$, resp&
Dim openpar As Long, oldi As Long, lastlabel$, oldjump As Boolean, st As Long, stc As Long
Dim paren As New mStiva2
countlines = 1
Column = 0
Lang = Not Lang
Dim a1 As Boolean
Dim jump As Boolean
If Trim$(s$) = vbNullString Then Exit Function
C = Len(s$)
a1 = True
I = 1
Do
Column = Column + 1
Select Case AscW(Mid$(s$, I, 1))
Case 10
Column = 0
Case 13
lastlabel$ = ""
If openpar <> 0 Then
GoTo pareprob
End If
oldjump = False
jump = False
If Len(s$) > I + 1 Then countlines = countlines + 1
Column = 0
Case 58
lastlabel$ = ""
oldjump = False
jump = False
Case 32, 160, 9
If Len(lastlabel$) > 0 Then
lastlabel$ = myUcase(lastlabel$)
If Not ismine1(lastlabel$) Then
If Not ismine2(lastlabel$) Then
If Not ismine22(lastlabel$) Then
    jump = Not oldjump
Else
    oldjump = True
    jump = False
End If
Else
oldjump = True
jump = False
End If
Else
oldjump = False
jump = False
End If
lastlabel$ = ""
End If
Case 34
lastlabel$ = ""
oldi = I
Do While I < C
I = I + 1
Select Case AscW(Mid$(s$, I, 1))
Case 34
Exit Do
Case 13

Checkit:
    If Not Lang Then
        b$ = sbname$ + "Problem in string in paragraph " & (countlines)
    Else
        b$ = sbname$ + "Ðñüâëçìá ìå ôï áëöáñéèìçôéêü óôç ðáñÜãñáöï " & (countlines)
    End If
    resp& = ask(b$, True)
If resp& <> 4 Then
blockCheck = True
End If
Exit Function
End Select

Loop
If oldi <> I Then
Else
I = oldi + 1
GoTo Checkit
End If

Case 40
lastlabel$ = ""
jump = True
openpar = openpar + 1
paren.PushVal countlines
Case 41
lastlabel$ = ""
openpar = openpar - 1
If openpar = 0 Then jump = False
If openpar < 0 Then Exit Do
paren.drop 1
Case 47
If Mid$(s$, I + 1, 1) = "/" Then I = I + 1: GoTo a1111
Case 39, 92
a1111:
lastlabel$ = ""
Do While I < C
I = I + 1
If Mid$(s$, I, 2) = vbCrLf Then Exit Do
Loop
countlines = countlines + 1
If openpar > 0 Then Exit Do
Case 61, 43, 44
lastlabel$ = ""
jump = True
Case 123
If Len(lastlabel$) > 0 Then
lastlabel$ = myUcase(lastlabel$)
If Not ismine1(lastlabel$) Then
If Not ismine2(lastlabel$) Then
If Not ismine22(lastlabel$) Then
    jump = Not oldjump
Else
    oldjump = True
    jump = False
End If
Else
oldjump = True
jump = False
End If
Else
oldjump = False
jump = False
End If
lastlabel$ = ""
End If

If jump Then
jump = False
' we have a multiline text
Dim target As Long, t4 As Long, st1 As Long, stc1 As Long
target = j
st = countlines
stc = Column
    Do
    Select Case AscW(Mid$(s$, I, 1))
            Case 34
            t4 = I
            st1 = countlines
            stc1 = Column
            Do While I < C
            I = I + 1
            Column = Column + 1
            If AscW(Mid$(s$, I, 1)) = 34 Then
            
            Exit Do
            End If
            If AscW(Mid$(s$, I, 1)) = 13 Then
                 countlines = st1
                I = t4: Exit Do
            End If
            Loop
        Case 13
        countlines = countlines + 1
        Column = 1
        Case 123
        Column = Column + 1
        j = j - 1
        Case 125
        j = j + 1: If j = target Then Exit Do
        Column = Column + 1
        Case Else
        Column = Column + 1
    End Select
    I = I + 1
    Loop Until I > C
     If MaybeIsSymbol3(s$, "{", I + 1) Then
    I = C + 1
    Column = Column + 1
        If Not Lang Then
            b$ = sbname$ + "Problem starting a second block {"
        Else
        b$ = sbname$ + "Ðñüâëçìá äåõôåñï ìðëïê {"
        End If
        resp& = ask(b$, True)
    
    End If
    If j <> target Then

    countlines = st
    Column = stc
    Exit Do
    End If
    Else
j = j - 1
oldjump = False
End If
Case 13

Case 125
If openpar <> 0 And j > 0 Then
pareprob:
If paren.count > 0 Then countlines = paren.PopVal
If Not Lang Then
        b$ = sbname$ + "Problem in parenthesis in paragraph" + str$(countlines)
    Else
        b$ = sbname$ + "Ðñüâëçìá ìå ôéò ðáñåíèÝóåéò óôç ðáñÜãñáöï" + str$(countlines)
    End If
    resp& = ask(b$, True)
If resp& <> 4 Then
blockCheck = True
End If
    Exit Function

End If
j = j + 1: If j = 1 Then Exit Do
Case 65 To 93, 97 To 122, Is > 127
jump = False
lastlabel$ = lastlabel$ + Mid$(s$, I, 1)
Case 46
jump = False
lastlabel$ = lastlabel$ + Mid$(s$, I, 1)

Case 48 To 57, 95
jump = False
If Len(lastlabel$) > 0 Then lastlabel$ = lastlabel$ + Mid$(s$, I, 1)
Case Else
jump = False
lastlabel$ = ""
End Select
I = I + 1
Loop Until I > C
If openpar <> 0 Then
GoTo pareprob
End If
If j = 0 Then

ElseIf j < 0 Then
    If Not Lang Then
        b$ = sbname$ + "Problem in blocks - look } are less " & (Abs(j))
    Else
        b$ = sbname$ + "Ðñüâëçìá ìå ôá ôìÞìáôá - äåò ôá } åßíáé ëéãüôåñá " & (Abs(j))
    End If
resp& = ask(b$, True)
Else
If Not Lang Then
b$ = sbname$ + "Problem in blocks - look { are less " & (j)
Else
b$ = sbname$ + "Ðñüâëçìá ìå ôá ôìÞìáôá - äåò ôá { åßíáé ëéãüôåñá " & (j)
End If
resp& = ask(b$, True)
End If
If resp& <> 4 Then
blockCheck = True
End If

End Function

Sub ListChoise(bstack As basetask, A$, X&, Y&, x1&, y1&)
On Error Resume Next
Dim D As Object, oldh As Long
Dim s$, prive As basket
If NOEXECUTION Then Exit Sub
Set D = bstack.Owner
prive = players(GetCode(D))
Dim ot As Boolean, drop
With Form1.List1
.Font.Name = D.Font.Name
Form1.Font.charset = D.Font.charset
Form1.Font.Strikethrough = False
.Font.Size = D.Font.Size
.Font.Name = D.Font.Name
Form1.Font.charset = D.Font.charset
.Font.Size = D.Font.Size
If LEVCOLMENU < 2 Then .BackColor = D.ForeColor
If LEVCOLMENU < 3 Then .ForeColor = D.BackColor
If ((.ForeColor Xor .BackColor) = &HFFFFFF) And .ForeColor <> 0 Then
oldback = .BackColor
oldfore = .ForeColor
USEOLD = True
.ForeColor = .ForeColor Xor &HFCF6F1
.BackColor = .BackColor Xor &HFCF6F1
End If
.Font.bold = D.Font.bold
.Font.Italic = D.Font.Italic
.addpixels = 2 * prive.uMineLineSpace / dv15
.VerticalCenterText = True
If D.Visible = False Then D.Visible = True
.StickBar = True
s$ = .HeadLine
.HeadLine = vbNullString
.HeadLine = s$
.enabled = False
If .Visible Then
If .BorderStyle = 0 Then

Else
End If

Else
.restrictLines = (y1& - Y&) + 1
If .BorderStyle = 0 Then
.move X& * prive.Xt + D.Left, Y& * prive.Yt + D.top, (x1& - X&) * prive.Xt + prive.Xt, (y1& - Y&) * prive.Yt + prive.Yt + .HeadlineHeight * dv15
Else
.move X& * prive.Xt - dv15 + D.Left, Y& * prive.Yt - dv15 + D.top, (x1& - X&) * prive.Xt + prive.Xt + 2 * dv15, (y1& - Y&) * prive.Yt + prive.Yt + 2 * dv15 + .HeadlineHeight * dv15
End If
End If
.enabled = True
.ShowBar = False

If .LeaveonChoose Then
.CalcAndShowBar
Exit Sub
End If



ot = Targets
Targets = False

.PanPos = 0

If .ListIndex < 0 Then
.ShowThis 1
Else
.ShowThis .ListIndex + 1
End If
.Visible = True
.ZOrder 0
NOEDIT = False
.Tag = A$

If A$ = vbNullString Then
    drop = mouse
    MyDoEvents
    ' Form1.KeyPreview = False
    .enabled = True
    .SetFocus
    .LeaveonChoose = True
    If .HeadLine <> "" Then
    oldh = 0
    Else
    oldh = .HeadlineHeight
    End If
    Else
        .enabled = True
    .SetFocus
    .LeaveonChoose = False
    
    End If
    .ShowMe
            If bstack.TaskMain Or TaskMaster.Processing Then
            If TaskMaster.QueueCount > 0 Then
            mywait bstack, 100
              Else
            MyDoEvents
            End If
        Else
         DoEvents
         Sleep 1
         End If

    If .HeadlineHeight <> oldh Then
    If .BorderStyle = 0 Then
    If ((y1& - Y&) * prive.Yt + prive.Yt + 2 * dv15 + .HeadlineHeight * dv15) + .top > ScrY() Then
    .move .Left, .top - (((y1& - Y&) * prive.Yt + prive.Yt + 2 * dv15 + .HeadlineHeight * dv15) + .top - ScrY()), (x1& - X&) * prive.Xt + prive.Xt, (y1& - Y&) * prive.Yt + prive.Yt + .HeadlineHeight * dv15
    Else
.move .Left, .top, (x1& - X&) * prive.Xt + prive.Xt, (y1& - Y&) * prive.Yt + prive.Yt + .HeadlineHeight * dv15
End If
Else
If ((y1& - Y&) * prive.Yt + prive.Yt + 2 * dv15 + .HeadlineHeight * dv15) + .top > ScrY() Then
.move .Left, .top - (((y1& - Y&) * prive.Yt + prive.Yt + 2 * dv15 + .HeadlineHeight * dv15) + .top - ScrY()), (x1& - X&) * prive.Xt + prive.Xt + 2 * dv15, (y1& - Y&) * prive.Yt + prive.Yt + 2 * dv15 + .HeadlineHeight * dv15
Else
.move .Left, .top, (x1& - X&) * prive.Xt + prive.Xt + 2 * dv15, (y1& - Y&) * prive.Yt + prive.Yt + 2 * dv15 + .HeadlineHeight * dv15
End If
End If
  
oldh = .HeadlineHeight
    End If
    .FloatLimitTop = Form1.Height - prive.Yt * 2
     .FloatLimitLeft = Form1.Width - prive.Xt * 2
    MyDoEvents
    End With
If A$ = vbNullString Then
    Do
        If bstack.TaskMain Or TaskMaster.Processing Then
            If TaskMaster.QueueCount > 0 Then
          mywait bstack, 2
             TaskMaster.RestEnd1
   TaskMaster.TimerTick
TaskMaster.rest
''SleepWait 1
  Sleep 1
              Else
            MyDoEvents
            End If
        Else
         DoEvents
                  Sleep 1
         End If
    
    Loop Until Form1.List1.Visible = False
    If USEOLD Then
    With Form1.List1
        .BackColor = oldback
        .ForeColor = oldfore
        USEOLD = False
    End With
    End If
    
    If Not NOEXECUTION Then MOUT = False
    Do
    drop = mouse
    MyDoEvents
    Loop Until drop = 0 Or MOUT
    MOUT = False
    While KeyPressed(&H1B)
ProcTask2 bstack
Wend
MOUT = False: NOEXECUTION = False
    If Form1.List1.ListIndex >= 0 Then
    A$ = Form1.List1.list(Form1.List1.ListIndex)
    Else
    A$ = vbNullString
    End If
   Form1.List1.enabled = False
    Else
        Form1.List1.enabled = True
    
  If A$ = vbNullString Then
  Form1.List1.SetFocus
  Form1.List1.LeaveonChoose = True
  Else
  D.TabStop = True
  End If
  End If
NOEDIT = True
Set D = Nothing
Form1.KeyPreview = True
Targets = ot
End Sub
Private Sub mywait11(bstack As basetask, pp As Double)
Dim p As Boolean, E As Boolean
On Error Resume Next
If bstack.Process Is Nothing Then
''If extreme Then MyDoEvents
If pp = 0 Then Exit Sub
Else

Err.Clear
p = bstack.Process.Done
If Err.Number = 0 Then
E = True
If p <> 0 Then
Exit Sub
End If
End If
End If
Dim tn As Long, dt As Long
tn = timeGetTime
If pp < 1 Then dt = 1 Else dt = Signed(pp)
Do


If TaskMaster.Processing And Not bstack.TaskMain Then
        If Not bstack.toprinter Then bstack.Owner.Refresh
        TaskMaster.TimerTick  'Now
       MyDoEvents
       
Else
        ' SleepWait 1
        MyDoEvents
        End If
If E Then
p = bstack.Process.Done
If Err.Number = 0 Then
If p <> 0 Then
Exit Do
End If
End If
End If
Loop Until UnsignedSub(timeGetTime, tn) > dt Or NOEXECUTION

If exWnd <> 0 Then MyTitle$ bstack
End Sub
Public Sub WaitDialog(bstack As basetask)
Dim oldesc As Boolean, XX As GuiM2000
oldesc = escok
escok = False
Dim D As Object
Set D = bstack.Owner
Dim ot As Boolean, drop
ot = Targets
Targets = False  ' do not use targets for now
'NOEDIT = False
    drop = mouse
    ''SleepWait3 100
    Sleep 1
    If bstack.ThreadsNumber = 0 Then
    If Not (bstack.toback Or bstack.toprinter) Then If bstack.Owner.Visible Then bstack.Owner.Refresh

    End If
    Dim mycode As Double, oldcodeid As Double
mycode = Rnd * 1233312231
oldcodeid = Modalid
Dim X As Form, zz As Form
Set zz = Screen.ActiveForm
For Each X In Forms
    If X.Name = "GuiM2000" Then
        Set XX = X
        If XX.Enablecontrol Then
            If XX.Modal = 0 Then XX.Modal = mycode
        End If
        XX.Enablecontrol = False
    End If
Next X
On Error Resume Next
If zz.enabled Then zz.SetFocus
Set zz = Nothing
Do
    mywait11 bstack, 5
    Sleep 1
Loop Until loadfileiamloaded = False Or LastErNum <> 0
Modalid = mycode
MOUT = False
Do
    drop = mouse Or KeyPressed(&H1B)
    MyDoEvents
Loop Until drop = 0 Or MOUT Or LastErNum <> 0
 ' NOEDIT = True
BLOCKkey = True

While KeyPressed(&H1B)
    ProcTask2 bstack
    NOEXECUTION = False
Wend
For Each X In Forms
    If X.Name = "GuiM2000" Then
        Set XX = X
        If XX.TrueVisible Then
            If Not XX.Enablecontrol Then
                XX.TestModal mycode
            End If
         '   If Not Screen.ActiveForm Is Nothing Then
         '       If Screen.ActiveForm Is x Then x.Enablecontrol = True
         '   End If
        End If
    End If
Next X
Modalid = oldcodeid
BLOCKkey = False
escok = oldesc
INK$ = vbNullString
If Form1.Visible Then Form1.KeyPreview = Not Form1.gList1.Visible
Targets = ot
mywait11 bstack, 5
End Sub

Public Sub FrameText(dd As Object, ByVal Size As Single, X As Long, Y As Long, cc As Long, Optional myCut As Boolean = False)
Dim I As Long, mymul As Long

If dd Is Form1.PrinterDocument1 Then
' check this please
dd.Width = X
dd.Height = Y
Pr_Back dd, Size
Exit Sub
End If


Dim basketcode As Long
basketcode = GetCode(dd)
With players(basketcode)
.curpos = 0
.currow = 0
.XGRAPH = 0
.YGRAPH = 0
If X = 0 Then
X = dd.Width
Y = dd.Height
End If

.mysplit = 0

''dd.BackColor = 0 '' mycolor(cc)    ' check if paper...

.Paper = mycolor(cc)
dd.currentX = 0
dd.currentY = 0

''ClearScreenNew dd, mybasket, cc
dd.currentY = 0
dd.Font.Size = Size
Size = dd.Font.Size

''Sleep 1  '' USED TO GIVE TIME TO LOAD FONT
If fonttest.FontName = dd.Font.Name And dd.Font.Size = fonttest.Font.Size Then
Else
StoreFont dd.Font.Name, Size, dd.Font.charset
End If
.Yt = fonttest.TextHeight("fj")
.Xt = fonttest.TextWidth("W")

While TextHeight(fonttest, "fj") / (.Yt / 2 + dv15) < dv
Size = Size + 0.2
fonttest.Font.Size = Size
Wend
dd.Font.Size = Size
.overrideTextHeight = fonttest.TextHeight("fj")
.Yt = TextHeight(fonttest, "fj")
.Xt = fonttest.TextWidth("W") + dv15

.mX = Int(X / .Xt)
.mY = Int(Y / (.Yt + .MineLineSpace * 2))
.Yt = .Yt + .MineLineSpace * 2
If .mX < 2 Then .mX = 2: X = 2 * .Xt
If .mY < 2 Then .mY = 2: Y = 2 * .Yt
If (.mX Mod 2) = 1 And .mX > 1 Then
.mX = .mX - 1
End If
mymul = Int(.mX / 8)
If mymul = 1 Then mymul = 2
If mymul = 0 Then
.Column = .mX \ 2 - 1
Else
.Column = Int(.mX / mymul)

While (.mX Mod .Column) > 0 And (.mX / .Column >= 3)
.Column = .Column + 1
Wend
End If
If .Column = 0 Then .Column = .mX
' second stage
If .mX Mod .Column > 0 Then


If .mX Mod 4 <> 0 Then .mX = 4 * (.mX \ 4)
If .mX < 4 Then .mX = 4
'.My = Int(y / (.Yt + .MineLineSpace * 2))
'.Yt = .Yt + .MineLineSpace * 2
If .mX < 2 Then .mX = 2: X = 2 * .Xt
If .mY < 2 Then .mY = 2: Y = 2 * .Yt
If (.mX Mod 2) = 1 And .mX > 1 Then
.mX = .mX - 1
End If
mymul = Int(.mX / 8)
If mymul = 1 Then mymul = 2
If mymul = 0 Then
.Column = .mX \ 2 - 1
Else
.Column = Int(.mX / mymul)

While (.mX Mod .Column) > 0 And (.mX / .Column >= 3)
.Column = .Column + 1
Wend
End If
If .Column = 0 Then .Column = .mX

End If

.Column = .Column - 1 ' FOR PRINT 0 TO COLUMN-1

If .Column < 4 Then .Column = 4


.SZ = Size

If dd.Name = "Form1" Then
' no change
Else
If dd.Name <> "dSprite" And Typename(dd) <> "GuiM2000" And Not TypeOf dd Is MetaDc Then
Dim mmxx As Long, mmyy As Long, XX As Long, YY As Long
mmxx = .mX * CLng(.Xt)
mmyy = .mY * CLng(.Yt)

XX = (dd.Parent.ScaleWidth - mmxx) \ 2
YY = (dd.Parent.ScaleHeight - mmyy) \ 2
dd.move XX, YY, mmxx, mmyy
ElseIf myCut And Not TypeOf dd Is MetaDc Then
Dim mmxx1, mmyy1
mmxx1 = .mX * .Xt
mmyy1 = .mY * .Yt
dd.move dd.Left, dd.top, mmxx1, mmyy1
End If

End If

.MAXXGRAPH = dd.Width
.MAXYGRAPH = dd.Height
.FTEXT = 0
.FTXT = vbNullString

Form1.MY_BACK.ClearUp
If dd.Visible Then
ClearScr dd, .Paper
Else
dd.BackColor = .Paper
End If
End With



End Sub

Sub Pr_Back(dd As Object, Optional msize As Single = 0)

SetText dd
If msize <> 0 Then players(GetCode(dd)).SZ = msize
If msize > 0 Then
SetTextSZ dd, msize
End If

End Sub
Function INKEY$()
Dim W As Long
If LenB(MKEY$) > 1 Then
    INK$ = MKEY$ + INK$
    MKEY$ = vbNullString
Else
    MKEY = ""
End If
If LenB(INK$) > 1 Then
' åéäéêÞ ðåñßðôùóç áí Ý÷ïõìå 0 óôï ðñþôï Byte, Ý÷ïõìå åéäéêü ê
        W = AscW(INK$)
    If W = 0 Then
        INKEY$ = Left$(INK$, 2)
        INK$ = Mid$(INK$, 3)
    ElseIf W > -10241 And W < -9216 Then
    INKEY$ = Left$(INK$, 2)
    INK$ = Mid$(INK$, 3)
    Else
    ' áëëéþò óçêþíïõìå Ýíá ÷áñáêôÞñá ìå üôé Ý÷åé áêüìá
    INKEY$ = PopOne(INK$)
    
   
        
    End If
Else
    INKEY$ = ""
End If

End Function
Function UINKEY$()
Dim W As Long
' mink$ used for reinput keystrokes
' MINK$ = MINK$ & UINK$
If UKEY$ <> "" Then MINK$ = MINK$ + UKEY$: UKEY$ = vbNullString
If Len(MINK$) > 1 Then
W = AscW(MINK$)
If W = 0 Then
    UINKEY$ = Left$(MINK$, 2)
    MINK$ = Mid$(MINK$, 3)
ElseIf W > -10241 And W < -9216 Then
    UINKEY$ = Left$(MINK$, 2)
    MINK$ = Mid$(MINK$, 3)
Else
    UINKEY$ = Left$(MINK$, 1)
    MINK$ = Mid$(MINK$, 2)
End If
Else
    UINKEY$ = ""
End If

End Function

Function QUERY(bstack As basetask, Prompt$, s$, M&, Optional USELIST As Boolean = True, Optional endchars As String = vbCr, Optional excludechars As String = vbNullString, Optional checknumber As Boolean = False) As String
'NoAction = True
On Error Resume Next
Dim dX As Long, dY As Long, safe$, oldREFRESHRATE As Double, AUX As Long
oldREFRESHRATE = REFRESHRATE

If excludechars = vbNullString Then excludechars = Chr$(0)
If QUERYLIST = vbNullString Then QUERYLIST = Chr$(13): LASTQUERYLIST = 1
Dim q1 As Long, sp$, once As Boolean, dq As Object
 
Set dq = bstack.Owner
SetText dq
Dim basketcode As Long, prive As basket
prive = players(GetCode(dq))
With prive
If .currow >= .mY Or .lastprint Then
crNew bstack, prive: .lastprint = False
ElseIf USELIST Then
If .curpos > 0 Then crNew bstack, prive: .lastprint = False
 .curpos = 0
End If
LCTbasketCur dq, prive
ins& = 0
Dim fr1 As Long, fr2 As Long, p As Double
UseEnter = False
If dq.Name = "DIS" Then
If Form1.Visible = False Then
    If Not Form3.Visible Then
        Form1.Hide: Sleep 100
    Else
        'Form3.PREPARE
    End If

    If Form1.WindowState = vbMinimized Then Form1.WindowState = vbNormal
    Form1.Show , Form5
    If ttl Then
    If Form3.Visible Then
    If Not Form3.WindowState = 0 Then
    Form3.skiptimer = True: Form3.WindowState = 0
    End If
    End If
    End If
    MyDoEvents
    Sleep 100
    End If
Else
    Console = FindFormSScreen(Form1)
If Form1.top >= VirtualScreenHeight() Then Form1.move ScrInfo(Console).Left, ScrInfo(Console).top
End If
If dq.Visible = False Then dq.Visible = True
If exWnd = 0 Then Form1.KeyPreview = True
QRY = True
If GetForegroundWindow = Form1.hWnd Then
If exWnd = 0 Then dq.SetFocus
End If


Dim DE$

PlainBaSket dq, prive, Prompt$, , , 0
dq.Refresh

 

INK$ = vbNullString
dq.FontTransparent = False

Dim A$
s$ = vbNullString
oldLCTCB dq, prive, 0
Do
If Not once Then
If USELIST Then
 DoEvents
  If Not iamactive Then
  Sleep 1
  Else
  If Not (bstack.IamChild Or bstack.IamAnEvent) Then Sleep 1
  End If
 ''If MKEY$ = VbNullString Then Dq.refresh
Else
If Not bstack.IamThread Then

 If Not iamactive Then
 If Not Form1.Visible Then
 If Form1.WindowState = 1 Then Form1.WindowState = 0
 If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top
 Form1.Visible = True
 If Form3.Visible Then Form3.skiptimer = True: Form3.WindowState = 0
 End If
 k1 = 0: MyDoEvents1 Form1, , True
 End If
If LastErNum <> 0 Then
      LCTCB dq, prive, -1: DestroyCaret
 oldLCTCB dq, prive, 0
Exit Do
End If
 Else
 
LCTbasketCur dq, prive                       ' here
 End If
 End If
 End If
If Not QRY Then HideCaret dq.hWnd:   Exit Do

 BLOCKkey = False
 If USELIST Then

 If Not once Then
 once = True

 If QUERYLIST <> "" Then  ' up down
 
    If INK = vbNullString Then MyDoEvents
If clickMe = 38 Then

 If Len(QUERYLIST) < LASTQUERYLIST Then LASTQUERYLIST = 2
  q1 = InStr(LASTQUERYLIST, QUERYLIST, vbCr)
         If q1 < 2 Or q1 <= LASTQUERYLIST Then
         q1 = 1: LASTQUERYLIST = 1
         End If
        MKEY$ = vbNullString
        INK = String$(Len(s$), 8) + Mid$(QUERYLIST, LASTQUERYLIST, q1 - LASTQUERYLIST)
        LASTQUERYLIST = q1 + 1

    ElseIf clickMe = 40 Then
    
    If LASTQUERYLIST < 3 Then LASTQUERYLIST = Len(QUERYLIST)
    q1 = InStrRev(QUERYLIST, vbCr, LASTQUERYLIST - 2)
         If q1 < 2 Then
                   q1 = Len(QUERYLIST)
         End If
         If q1 > 1 Then
         LASTQUERYLIST = InStrRev(QUERYLIST, vbCr, q1 - 1) + 1
         If LASTQUERYLIST < 2 Then LASTQUERYLIST = 2
         
        MKEY$ = vbNullString
        INK = String$(RealLen(s$), 8) + Mid$(QUERYLIST, LASTQUERYLIST, q1 - LASTQUERYLIST)
   LASTQUERYLIST = q1 + 1

      End If
 End If
 clickMe = -2
 End If
 
 ElseIf INK <> "" Then
 MKEY$ = vbNullString
 Else
 clickMe = 0
 once = False
 End If
 End If

  
againquery:
 A$ = INKEY$
 
If A$ = vbNullString Then
If TaskMaster Is Nothing Then Set TaskMaster = New TaskMaster
    If TaskMaster.QueueCount > 0 Then
  ProcTask2 bstack
  If Not NOEDIT Or Not QRY Then
  LCTCB dq, prive, -1: DestroyCaret
   oldLCTCB dq, prive, 0
  Exit Do
  End If
  SetText dq

LCTbasket dq, prive, .currow, .curpos
    Else
  
   End If
      If iamactive Then
 If ShowCaret(dq.hWnd) = 0 Then
 
   LCTCB dq, prive, 0
  End If
If Not bstack.IamThread Then

MyDoEvents1 Form1, , True
End If

 If Screen.ActiveForm Is Nothing Then
 iamactive = False:  If ShowCaret(dq.hWnd) <> 0 Then HideCaret dq.hWnd
Else
 
    If Not GetForegroundWindow = Screen.ActiveForm.hWnd Then
    iamactive = False:  If ShowCaret(dq.hWnd) <> 0 Then HideCaret dq.hWnd
  
    End If
    End If
    End If

  End If
    If bstack Is Nothing Then
    Set bstack = Basestack1
    NOEXECUTION = True
    MOUT = True
     Modalid = 0
                         ShutEnabledGuiM2000
                         MyDoEvents
                         GoTo contqueryhere
    End If
   If bstack.IamThread Then If myexit(bstack) Then GoTo contqueryhere

If Screen.ActiveForm Is Nothing Then
iamactive = False
Else
If Screen.ActiveForm.Name <> "Form1" Then
iamactive = False
Else
iamactive = GetForegroundWindow = Screen.ActiveForm.hWnd
End If
End If
If Fkey > 0 And iamactive Then
If FK$(Fkey) <> "" Then
s$ = FK$(Fkey)
Fkey = 0
             ''  here
      LCTCB dq, prive, -1: DestroyCaret
 oldLCTCB dq, prive, 0
 Exit Do
End If
End If

If bstack.Owner Is Nothing Then
NOEXECUTION = True
MOUT = True
Exit Do
End If
dq.FontTransparent = False
If RealLen(A$) = 1 Or Len(A$) = 1 Or (RealLen(A$) = 0 And Len(A$) = 1 And Len(s$) > 1) Then
   '
   
   If Len(A$) = 1 Then
    If InStr(endchars, A$) > 0 Then
     If A$ = vbCr Then
        If A$ <> Left$(endchars, 1) Then
            A$ = Left$(endchars, 1)
            If checknumber And Len(s$) = 0 Then
                s$ = "0": PlainBaSket dq, prive, "0", , , 0
                oldLCTCB dq, prive, 0
                LCTCB dq, prive, 0
            End If
        Else
            If checknumber And Len(s$) = 0 Then
                s$ = "0": PlainBaSket dq, prive, "0", , , 0
                oldLCTCB dq, prive, 0
                LCTCB dq, prive, 0
            End If
            LCTCB dq, prive, -1: DestroyCaret
            oldLCTCB dq, prive, 0
            Exit Do
        End If
        Else
                If checknumber And Len(s$) = 0 Then
                s$ = "0": PlainBaSket dq, prive, "0", , , 0
                oldLCTCB dq, prive, 0
                LCTCB dq, prive, 0
            End If
     End If
     End If
     End If
    If Asc(A$) = 27 And (escok Or Not checknumber) Then
        
      LCTCB dq, prive, -1: DestroyCaret
 oldLCTCB dq, prive, 0
    s$ = vbNullString
    A$ = ""
    INK$ = ""
    MKEY$ = ""
    'If ExTarget Then End
    result = 99
    Exit Do
ElseIf Asc(A$) = 27 Then
A$ = Chr$(0)
End If
If A$ = Chr(8) Then
DE$ = " "
    If Len(s$) > 0 Then
    AUX = RealLen(s$)
    
        ExcludeOne s$
             LCTCB dq, prive, -1: DestroyCaret
            oldLCTCB dq, prive, 0

        
        .curpos = .curpos - 1
        If .curpos < 0 Then
            .curpos = .mX - 1: .currow = .currow - 1

            If .currow < .mysplit Then
                ScrollDownNew dq, prive
                
                PlainBaSket dq, prive, RealRight(Prompt$ + s$, .mX - 1), , , 0
                DE$ = vbNullString
            End If
        End If

       LCTbasketCur dq, prive
        dX = .curpos
        dY = .currow
       PlainBaSket dq, prive, DE$, , , 0
       .curpos = dX
       .currow = dY
         
         
            oldLCTCB dq, prive, 0
            
    End If
End If
If safe$ <> "" Then
        A$ = 65
End If
If LenB(A$) > 1 Then W = AscW(A$) Else W = 0
If W < 0 Then
GoTo cont12345

ElseIf W > 31 And (RealLen(s$) < M& Or RealLen(A$, True) = 0) Then
If RealLen(A$, True) = 0 Then
    If Asc(A$) = 63 And s$ <> "" Then
        s$ = s$ + A$: A$ = s$: ExcludeOne s$: A$ = Mid$(A$, Len(s$) + 1)
        s$ = s$ + A$
        MKEY$ = vbNullString
        'UINK = VbNullString
        safe$ = A$
       INK = Chr$(8) + INK
    ElseIf A$ = vbNullString Then
        A$ = A$ + s$
        safe$ = A$
       
    Else
       ' If s$ = vbNullString Then a$ = " "
        GoTo cont12345
    End If
Else
cont12345:
    If InStr(excludechars, A$) > 0 Then

    Else
            If checknumber Then
                    fr1 = 1
                    If (s$ = vbNullString And A$ = "-") Or IsNumberQuery(s$ + A$, fr1, p, fr2) Then
                            If fr2 - 1 = RealLen(s$) + 1 Or (s$ = vbNullString And A$ = "-") Then
   If ShowCaret(dq.hWnd) <> 0 Then DestroyCaret
                If A$ = "." Then
                If Not NoUseDec Then
                    If OverideDec Then
                    PlainBaSket dq, prive, NowDec$, , , 0
                    Else
                    PlainBaSket dq, prive, ".", , , 0
                    End If
                Else
                    PlainBaSket dq, prive, QueryDecString, , , 0
                End If
                Else
                   PlainBaSket dq, prive, A$, , , 0
                   End If
                   s$ = s$ + A$
                 
              oldLCTCB dq, prive, 0
                  LCTCB dq, prive, 0
GdiFlush
                            End If
                    
                    End If
            Else
            If ShowCaret(dq.hWnd) <> 0 Then DestroyCaret
                   If safe$ <> "" Then
        A$ = safe$: safe$ = vbNullString
End If
 If InStr(endchars, A$) = 0 Then PlainBaSket dq, prive, A$, , , 0: s$ = s$ + A$
              If .curpos >= .mX Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
              oldLCTCB dq, prive, 0
                  LCTCB dq, prive, 0
                  GdiFlush
                
            End If
    End If
End If
If InStr(endchars, A$) > 0 Then
    If A$ >= " " Then
                     PlainBaSket dq, prive, A$, , , 0
              
      LCTCB dq, prive, -1: DestroyCaret
                                GdiFlush
                                End If
QUERY = A$
Exit Do
End If
 .pageframe = 0
 End If
End If
If Not QRY Then
      LCTCB dq, prive, -1: DestroyCaret
 oldLCTCB dq, prive, 0
Exit Do
''HideCaret dq.hWnd:


End If
Loop


 
If Not QRY Then s$ = vbNullString
dq.FontTransparent = True
SetBkMode dq.Hdc, 1
QRY = False

Call mouse

If s$ <> "" And USELIST Then
q1 = InStr(QUERYLIST, Chr$(13) + s$ + Chr$(13))
If q1 = 1 Then ' same place
ElseIf q1 > 1 Then ' reorder
sp$ = Mid$(QUERYLIST, q1 + RealLen(s$) + 1)
QUERYLIST = Chr$(13) + s$ + Mid$(QUERYLIST, 1, q1 - 1) + sp$
Else ' insert
QUERYLIST = Chr$(13) + s$ + QUERYLIST
End If
LASTQUERYLIST = 2
End If
End With
contqueryhere:
If Not bstack.IamThread Then
MyDoEvents1 Form1, , True
End If
REFRESHRATE = oldREFRESHRATE
If TaskMaster Is Nothing Then Exit Function
If TaskMaster.QueueCount > 0 Then TaskMaster.RestEnd
players(GetCode(dq)) = prive
Set dq = Nothing
TaskMaster.RestEnd1

End Function


Public Sub GetXYb(dd As Object, mb As basket, X As Long, Y As Long)
With mb
If dd.currentY Mod .Yt <= dv15 Then
Y = (dd.currentY) \ .Yt
Else
Y = (dd.currentY - .uMineLineSpace) \ .Yt
End If
X = dd.currentX \ .Xt

''
End With
End Sub
Public Sub GetXYb2(dd As Object, mb As basket, X As Long, Y As Long)
With mb
X = dd.currentX \ .Xt
Y = Int((dd.currentY / .Yt) + 0.5)
End With
End Sub
Sub Gradient(TheObject As Object, ByVal f&, ByVal t&, ByVal xx1&, ByVal xx2&, ByVal yy1&, ByVal yy2&, ByVal hor As Boolean, ByVal all As Boolean)
    Dim Redval&, Greenval&, Blueval&
    Dim r1&, G1&, b1&, sr&, sg&, sb&
    Dim obj As MetaDc
    f& = f& Mod &H1000000
    t& = t& Mod &H1000000
    Redval& = f& And &H10000FF
    Greenval& = (f& And &H100FF00) / &H100
    Blueval& = (f& And &HFF0000) / &H10000
    r1& = t& And &H10000FF
    G1& = (t& And &H100FF00) / &H100
    b1& = (t& And &HFF0000) / &H10000
    sr& = (r1& - Redval&) * 1000 / 127
    sg& = (G1& - Greenval&) * 1000 / 127
    sb& = (b1& - Blueval&) * 1000 / 127
    Redval& = Redval& * 1000
    
    Greenval& = Greenval& * 1000
    Blueval& = Blueval& * 1000
    Dim Step&, Reps&, FillTop As Single, FillLeft As Single, FillRight As Single, FillBottom As Single
     If TypeOf TheObject Is MetaDc Then
    If hor Then
    yy2& = TheObject.Height + 2 * dv15 - yy2&
    If all Then
    Step = ((yy2& - yy1&) / 127)
    Else
    Step = ((TheObject.Height + 2 * dv15) / 127)
    End If
    If all Then
    FillTop = yy1&
    Else
    FillTop = 0
    End If
    FillLeft = xx1&
    FillRight = TheObject.Width + 4 * dv15 - xx2&
    FillBottom = FillTop + Step * 2
    
    Else ' vertical
    
        xx2& = TheObject.Width + 4 * dv15 - xx2&
    If all Then
    Step = ((xx2& - xx1&) / 127)
    Else
    Step = ((TheObject.Width + 4 * dv15) / 127)
    End If
    If all Then
    FillLeft = xx1&
    Else
    FillLeft = 0
    End If
    FillTop = yy1&
    FillBottom = TheObject.Height + 2 * dv15 - yy2&
    FillRight = FillLeft + Step * 2
    
    End If
    Else
    If hor Then
    yy2& = TheObject.Height - yy2&
    If all Then
    Step = ((yy2& - yy1&) / 127)
    Else
    Step = ((TheObject.Height) / 127)
    End If
    If all Then
    FillTop = yy1&
    Else
    FillTop = 0
    End If
    FillLeft = xx1&
    FillRight = TheObject.Width - xx2&
    FillBottom = FillTop + Step * 2
    
    Else ' vertical
    
        xx2& = TheObject.Width - xx2&
    If all Then
    Step = ((xx2& - xx1&) / 127)
    Else
    Step = (TheObject.Width / 127)
    End If
    If all Then
    FillLeft = xx1&
    Else
    FillLeft = 0
    End If
    FillTop = yy1&
    FillBottom = TheObject.Height - yy2&
    FillRight = FillLeft + Step * 2
    
    End If
    
    
    
    
    End If
    If TypeOf TheObject Is MetaDc Then
    Set obj = TheObject
    
    For Reps = 1 To 127
    If hor Then
    
        If FillTop <= yy2& And FillBottom >= yy1& Then
        obj.Line2 FillLeft, RMAX(FillTop, yy1&), FillRight, RMIN(FillBottom, yy2&), rgb(Redval& / 1000, Greenval& / 1000, Blueval& / 1000), True
        End If
        Redval& = Redval& + sr&
        Greenval& = Greenval& + sg&
        Blueval& = Blueval& + sb&
        FillTop = FillBottom
        FillBottom = FillTop + Step
    Else
        If FillLeft <= xx2& And FillRight >= xx1& Then
        obj.Line2 RMAX(FillLeft, xx1&), FillTop, RMIN(FillRight, xx2&), FillBottom, rgb(Redval& / 1000, Greenval& / 1000, Blueval& / 1000), True
        End If
        Redval& = Redval& + sr&
        Greenval& = Greenval& + sg&
        Blueval& = Blueval& + sb&
        FillLeft = FillRight
        FillRight = FillRight + Step
    End If
    Next
        
    Else
    
    For Reps = 1 To 127
    If hor Then
        If FillTop <= yy2& And FillBottom >= yy1& Then
        TheObject.Line (FillLeft, RMAX(FillTop, yy1&))-(FillRight, RMIN(FillBottom, yy2&)), rgb(Redval& / 1000, Greenval& / 1000, Blueval& / 1000), BF
        End If
        Redval& = Redval& + sr&
        Greenval& = Greenval& + sg&
        Blueval& = Blueval& + sb&
        FillTop = FillBottom
        FillBottom = FillTop + Step
    Else
        If FillLeft <= xx2& And FillRight >= xx1& Then
        TheObject.Line (RMAX(FillLeft, xx1&), FillTop)-(RMIN(FillRight, xx2&), FillBottom), rgb(Redval& / 1000, Greenval& / 1000, Blueval& / 1000), BF
        End If
        Redval& = Redval& + sr&
        Greenval& = Greenval& + sg&
        Blueval& = Blueval& + sb&
        FillLeft = FillRight
        FillRight = FillRight + Step
    End If
    Next
    End If
End Sub
Function mycolor(q)
If Abs(q) > 2147483392# Then
If q < 0 Then
mycolor = GetSysColor(q And &HFF) And &HFFFFFF
Else
mycolor = GetSysColor((q - 4294967296#) And &HFF) And &HFFFFFF
End If
Exit Function
End If
If q = 0 Then
mycolor = 0
ElseIf q < 0 Or q > 15 Then

 mycolor = Abs(q) And &HFFFFFF
Else
mycolor = QBColor(q Mod 16)
End If
End Function



Sub ICOPY(d1 As Object, x1 As Long, y1 As Long, W As Long, h As Long)
Dim sV As Long
With players(GetCode(d1))
sV = BitBlt(d1.Hdc, CLng(d1.ScaleX(x1, 1, 3)), CLng(d1.ScaleY(y1, 1, 3)), CLng(d1.ScaleX(W, 1, 3)), CLng(d1.ScaleY(h, 1, 3)), d1.Hdc, CLng(d1.ScaleX(.XGRAPH, 1, 3)), CLng(d1.ScaleY(.YGRAPH, 1, 3)), SRCCOPY)
'sv = UpdateWindow(d1.hwnd)
End With
End Sub

Sub sHelp(Title$, doc$, X As Long, Y As Long)
vH_title$ = Title$
vH_doc$ = doc$
vH_x = X
vH_y = Y
End Sub

Sub vHelp(Optional ByVal bypassshow As Boolean = False)
Dim huedif As Long
Dim UAddPixelsTop As Long, monitor As Long

If abt Then
If vH_title$ = lastAboutHTitle Then Exit Sub
vH_title$ = lastAboutHTitle
vH_doc$ = LastAboutText
Else
If vH_title$ = vbNullString Then Exit Sub
End If
If bypassshow Then
monitor = FindMonitorFromMouse
Else
monitor = FindFormSScreen(Form4)
End If
If Not Form4.Visible Then Form4.Show , Form1: bypassshow = True

If bypassshow Then

    If (ScrInfo(monitor).Height - vH_y * Helplastfactor + ScrInfo(monitor).top) < MinMonitorTop Then
        Helplastfactor = (ScrInfo(monitor).Height + ScrInfo(monitor).top) / vH_y
    End If

    If (ScrInfo(monitor).Width - vH_x * Helplastfactor + ScrInfo(monitor).Left) < MinMonitorLeft Then
         Helplastfactor = (ScrInfo(monitor).Left + ScrInfo(monitor).Width) / vH_x
    End If
    If VirtualScreenWidth * 0.8 < vH_x * Helplastfactor Then
        Helplastfactor = VirtualScreenWidth * 0.8 / vH_x
    End If

    myform Form4, ScrInfo(monitor).Width - vH_x * Helplastfactor + ScrInfo(monitor).Left, ScrInfo(monitor).Height - vH_y * Helplastfactor + ScrInfo(monitor).top, vH_x * Helplastfactor, vH_y * Helplastfactor, True, Helplastfactor
Else
If Screen.Width <= Form4.Left - ScrInfo(monitor).Left Then
    myform Form4, Screen.Width - vH_x * Helplastfactor + ScrInfo(monitor).Left, Form4.top, vH_x * Helplastfactor, vH_y * Helplastfactor, True, Helplastfactor
Else
    myform Form4, Form4.Left, Form4.top, vH_x * Helplastfactor, vH_y * Helplastfactor, True, Helplastfactor
End If
End If
Form4.moveMe
If Form1.Visible Then
If Form1.DIS.Visible Then
  ''  If Abs(Val(hueconvSpecial(mycolor(uintnew(&H80000018)))) - Val(hueconvSpecial(-Paper))) > Abs(Val(hueconvSpecial(mycolor(uintnew(&H80000003)))) - Val(hueconvSpecial(-Paper))) Then
  If Abs(hueconv(mycolor(uintnew(&H80000018))) - val(hueconv(players(0).Paper))) > 10 And Not Abs(lightconv(mycolor(uintnew(&H80000018))) - val(lightconv(players(0).Paper))) < 50 Then
    Form4.BackColor = &H80000018
    Form4.label1.BackColor = &H80000018
    
    Else
    
    Form4.BackColor = &H80000003
    Form4.label1.BackColor = &H80000003
    End If

Else
''If Abs(Val(hueconvSpecial(mycolor(&H80000018))) - Val(hueconvSpecial(Form1.BackColor))) > Abs(Val(hueconvSpecial(mycolor(&H80000003))) - Val(hueconvSpecial(Form1.BackColor))) Then
     If Abs(hueconv(mycolor(uintnew(&H80000018))) - val(hueconv(Form1.BackColor))) > 10 And Not Abs(lightconv(mycolor(uintnew(&H80000018))) - val(lightconv(Form1.BackColor))) < 50 Then

    Form4.BackColor = &H80000018
    Form4.label1.BackColor = &H80000018
    Else
    
    Form4.BackColor = &H80000003
    Form4.label1.BackColor = &H80000003
    End If
End If
End If
With Form4.label1
.Visible = True
.enabled = False
.Text = vH_doc$
If Not bypassshow Then .SetRowColumn 1, 0
.EditDoc = False
.NoMark = True
If abt Then
.glistN.WordCharLeft = "["
.glistN.WordCharRight = "]"
.glistN.WordCharRightButIncluded = vbNullString
.glistN.WordCharLeftButIncluded = vbNullString
Else
.glistN.WordCharRightButIncluded = ChrW(160) + "#("
.glistN.WordCharLeft = ConCat(":", "{", "}", "[", "]", ",", "(", ")", "!", ";", "=", ">", "<", "'", """", " ", "+", "-", "/", "*", "^", "@", Chr$(9), "#", "%", "&", "$")
.glistN.WordCharRight = ConCat(":", "{", "}", "[", "]", ",", ")", "!", ";", "=", ">", "<", "'", """", " ", "+", "-", "/", "*", "^", Chr$(9), "#")
.glistN.WordCharLeftButIncluded = "#$@~"

End If
.enabled = True
.NewTitle vH_title$, (4 + UAddPixelsTop) * Helplastfactor
If Not bypassshow Then .glistN.ShowMe
End With


'Form4.ZOrder
Form4.label1.glistN.DragEnabled = Not abt
If exWnd = 0 Then If Form1.Visible Then Form1.SetFocus
End Sub

Function FileNameType(extension As String) As String
Dim I As Long, fs, b
    I = FreeFile
    Open strTemp + "dummy." + extension For Output As I
    Print #I, "test"
    Close #I
    Sleep 10
    Set fs = CreateObject("Scripting.FileSystemObject")
  Set b = fs.GetFile(strTemp + "dummy." + extension)
    FileNameType = b.Type
    KillFile strTemp + "dummy." + extension
End Function
Function mylcasefILE(ByVal A$) As String
If A$ = vbNullString Then Exit Function
If casesensitive Then
' no case change
mylcasefILE = A$
Else
 mylcasefILE = LCase(A$)
 End If

End Function
Function myUcase(ByVal A$, Optional convert As Boolean = False) As String
Dim I As Long, W As Integer
If A$ = vbNullString Then Exit Function
 If AscW(A$) > 255 Or convert Then
 For I = 1 To Len(A$)
 W = AscW(Mid$(A$, I, 1))
 If W > 901 And W < 975 Then
 Select Case W
Case 902
Mid$(A$, I, 1) = ChrW(913)
Case 904
Mid$(A$, I, 1) = ChrW(917)
Case 906
Mid$(A$, I, 1) = ChrW(921)
Case 912
Mid$(A$, I, 1) = ChrW(921)
Case 905
Mid$(A$, I, 1) = ChrW(919)
Case 908
Mid$(A$, I, 1) = ChrW(927)
Case 911
Mid$(A$, I, 1) = ChrW(937)
Case 910
Mid$(A$, I, 1) = ChrW(933)
Case 940
Mid$(A$, I, 1) = ChrW(913)
Case 941
Mid$(A$, I, 1) = ChrW(917)
Case 943
Mid$(A$, I, 1) = ChrW(921)
Case 942
Mid$(A$, I, 1) = ChrW(919)
Case 972
Mid$(A$, I, 1) = ChrW(927)
Case 974
Mid$(A$, I, 1) = ChrW(937)
Case 973
Mid$(A$, I, 1) = ChrW(933)
Case 962
Mid$(A$, I, 1) = ChrW(931)
End Select
End If
Next I
End If
myUcase = UCase(A$)
End Function

Function myUcase1(ByVal A$, Optional convert As Boolean = False) As String
Dim I As Long, W As Integer
If A$ = vbNullString Then Exit Function
 
 For I = 1 To Len(A$)
 W = AscW(Mid$(A$, I, 1))
 If W >= 0 And (W < 65 Or W > 974) Then
 ElseIf W < 0 Then
 If W > -10241 And W < -9216 Then
 I = I + 1
 End If
 ElseIf W > 901 Or convert Then
 Select Case W
Case 902
Mid$(A$, I, 1) = ChrW(913)
Case 904
Mid$(A$, I, 1) = ChrW(917)
Case 906
Mid$(A$, I, 1) = ChrW(921)
Case 912
Mid$(A$, I, 1) = ChrW(921)
Case 905
Mid$(A$, I, 1) = ChrW(919)
Case 908
Mid$(A$, I, 1) = ChrW(927)
Case 911
Mid$(A$, I, 1) = ChrW(937)
Case 910
Mid$(A$, I, 1) = ChrW(933)
Case 940
Mid$(A$, I, 1) = ChrW(913)
Case 941
Mid$(A$, I, 1) = ChrW(917)
Case 943
Mid$(A$, I, 1) = ChrW(921)
Case 942
Mid$(A$, I, 1) = ChrW(919)
Case 972
Mid$(A$, I, 1) = ChrW(927)
Case 974
Mid$(A$, I, 1) = ChrW(937)
Case 973
Mid$(A$, I, 1) = ChrW(933)
Case 962
Mid$(A$, I, 1) = ChrW(931)
End Select
ElseIf Not convert Then
Exit For
End If
Next I

myUcase1 = UCase(A$)
End Function
Sub myUcase2(A$)
Dim I As Long, W As Integer
If A$ = vbNullString Then Exit Sub
 
 For I = 1 To Len(A$)
 W = AscW(Mid$(A$, I, 1))
  If W > 901 Or W < 975 Then
 Select Case W
Case 902
Mid$(A$, I, 1) = ChrW(913)
Case 904
Mid$(A$, I, 1) = ChrW(917)
Case 906
Mid$(A$, I, 1) = ChrW(921)
Case 912
Mid$(A$, I, 1) = ChrW(921)
Case 905
Mid$(A$, I, 1) = ChrW(919)
Case 908
Mid$(A$, I, 1) = ChrW(927)
Case 911
Mid$(A$, I, 1) = ChrW(937)
Case 910
Mid$(A$, I, 1) = ChrW(933)
Case 940
Mid$(A$, I, 1) = ChrW(913)
Case 941
Mid$(A$, I, 1) = ChrW(917)
Case 943
Mid$(A$, I, 1) = ChrW(921)
Case 942
Mid$(A$, I, 1) = ChrW(919)
Case 972
Mid$(A$, I, 1) = ChrW(927)
Case 974
Mid$(A$, I, 1) = ChrW(937)
Case 973
Mid$(A$, I, 1) = ChrW(933)
Case 962
Mid$(A$, I, 1) = ChrW(931)
End Select
 ElseIf W > -10241 And W < -9216 Then
 I = I + 1
End If
Next I
LSet A$ = UCase(A$)
End Sub
Function myLcase(ByVal A$) As String
If A$ = vbNullString Then Exit Function

A$ = LCase(A$)
Dim I As Long, ok As Boolean, W As Integer
For I = 1 To Len(A$)
W = AscW(Mid$(A$, I, 1))
If W > -10241 And W < -9216 Then
I = I + 1
ElseIf W = 963 Then
ok = True
Exit For
End If
Next I
 If ok Then
A$ = A$ + Chr(0)
' Here are greek letters for proper case conversion
A$ = Replace(A$, "ó" + Chr(0), "ò")
A$ = Replace(A$, Chr(0), "")
A$ = Replace(A$, "ó ", "ò ")
A$ = Replace(A$, "ó$", "ò$")
A$ = Replace(A$, "ó&", "ò&")
A$ = Replace(A$, "ó.", "ò.")
A$ = Replace(A$, "ó(", "ò(")
A$ = Replace(A$, "ó_", "ò_")
A$ = Replace(A$, "ó/", "ò/")
A$ = Replace(A$, "ó\", "ò\")
A$ = Replace(A$, "ó-", "ò-")
A$ = Replace(A$, "ó+", "ò+")
A$ = Replace(A$, "ó*", "ò*")
A$ = Replace(A$, "ó" + vbCr, "ò" + vbCr)
A$ = Replace(A$, "ó" + vbLf, "ò" + vbLf)
End If
myLcase = A$
End Function
Sub myLcase2(A$)
If A$ = vbNullString Then Exit Sub

A$ = LCase(A$)
Dim I As Long, ok As Boolean, W As Integer
For I = 1 To Len(A$)
W = AscW(Mid$(A$, I, 1))
If W > -10241 And W < -9216 Then
I = I + 1
ElseIf W = 963 Then
ok = True
Exit For
End If
Next I
 If ok Then
A$ = A$ + Chr(0)
' Here are greek letters for proper case conversion
A$ = Replace(A$, "ó" + Chr(0), "ò")
A$ = Replace(A$, Chr(0), "")
A$ = Replace(A$, "ó ", "ò ")
A$ = Replace(A$, "ó$", "ò$")
A$ = Replace(A$, "ó&", "ò&")
A$ = Replace(A$, "ó.", "ò.")
A$ = Replace(A$, "ó(", "ò(")
A$ = Replace(A$, "ó_", "ò_")
A$ = Replace(A$, "ó/", "ò/")
A$ = Replace(A$, "ó\", "ò\")
A$ = Replace(A$, "ó-", "ò-")
A$ = Replace(A$, "ó+", "ò+")
A$ = Replace(A$, "ó*", "ò*")
A$ = Replace(A$, "ó" + vbCr, "ò" + vbCr)
A$ = Replace(A$, "ó" + vbLf, "ò" + vbLf)
End If

End Sub
Function MesTitle$()
On Error Resume Next
If ttl Then
If Form1.Caption = vbNullString Then
If here$ = vbNullString Then
MesTitle$ = "M2000"
' IDE
Else
If LASTPROG$ <> "" Then
MesTitle$ = ExtractNameOnly(LASTPROG$, True)
Else
MesTitle$ = "M2000"
End If
End If
Else
MesTitle$ = Form1.Caption
End If
Else

If Typename$(Screen.ActiveForm) = "GuiM2000" Then
MesTitle$ = Screen.ActiveForm.Title
Else
If here$ = vbNullString Or LASTPROG$ = vbNullString Then
MesTitle$ = "M2000"
Else
If Not UseMe Is Nothing Then
If UseMe.AppTitle <> vbNullString Then
MesTitle$ = UseMe.AppTitle + " " + here$
Else
MesTitle$ = ExtractNameOnly(LASTPROG$, True) + " " + here$
End If
Else
MesTitle$ = ExtractNameOnly(LASTPROG$, True) + " " + here$
End If
End If
End If
End If
End Function
Public Function holdcontrol(wh As Object, mb As basket) As Long
Dim x1 As Long, y1 As Long
If TypeOf wh Is MetaDc Then holdcontrol = 100000: Exit Function
With mb
If .pageframe = 0 Then

If .mysplit > 0 Then .pageframe = (.mY - .mysplit) * 4 / 5 Else .pageframe = Fix(.mY * 4 / 5)
If .pageframe < 1 Then .pageframe = 1
.basicpageframe = .pageframe
holdcontrol = .pageframe
Else

holdcontrol = .basicpageframe
End If
End With
End Function
Public Sub HoldReset(Col As Long, mb As basket)
With mb
.basicpageframe = Col
If .basicpageframe <= 0 Then .basicpageframe = .pageframe
End With
End Sub
Public Sub gsb_file(Optional assoc As Boolean = True)
   Dim CD As String
     CD = App.path
        AddDirSep CD

        If assoc Then
          associate ".gsb", "M2000 Ver" + str$(VerMajor) + "." + CStr(VerMinor \ 100) + " User Module", CD + "M2000.EXE"
        Else
      deassociate ".gsb", "M2000 Ver" + str$(VerMajor) + "." + CStr(VerMinor \ 100) + " User Module", CD + "M2000.EXE"
   End If
End Sub
Public Sub Switches(s$, Optional fornow As Boolean = False)
Dim cc As cRegistry
Set cc = New cRegistry
cc.Temp = fornow
cc.ClassKey = HKEY_CURRENT_USER
cc.SectionKey = basickey
Dim D$, W$, p As Long, b As Long
If s$ <> "" Then
    Do While FastSymbol(s$, "-")
        If IsLabel(Basestack1, s$, D$) > 0 Then
            D$ = UCase(D$)
            If D$ = "TEST" Then
                STq = False
                STEXIT = False
                STbyST = True
                Form2.Show , Form1
                If Form2.Busy Then
                Do
                    Sleep 10
                Loop Until Not Form2.Busy
                End If
                Form2.Busy = True
                Form2.label1(0) = vbNullString
                Form2.label1(1) = vbNullString
                Form2.label1(2) = vbNullString
                TestShowSub = vbNullString
                TestShowStart = 0
                stackshow Basestack1
                Form2.Busy = False
                Form1.Show , Form5
                If Form3.Visible Then Form3.skiptimer = True: Form3.WindowState = 0
                trace = True
            ElseIf D$ = "NORUN" Then
                If ttl Then Form3.WindowState = vbNormal Else Form1.Show , Form5
                NORUN1 = True
            ElseIf D$ = "FONT" Then
            ' + LOAD NEW
                cc.ValueKey = "FONT"
                cc.ValueType = REG_SZ
                cc.Value = "Verdana"
            ElseIf D$ = "SEC" Then
                If Not fornow Then
                    cc.ValueKey = "NEWSECURENAMES"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0
                End If
                SecureNames = False
            ElseIf D$ = "DIV" Then
                If Not fornow Then
                    cc.ValueKey = "DIV"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0
                End If
                UseIntDiv = False
            ElseIf D$ = "LINESPACE" Then
                cc.ValueKey = "LINESPACE"
                cc.ValueType = REG_DWORD
                cc.Value = 0
            ElseIf D$ = "SIZE" Then
                cc.ValueKey = "SIZE"
                cc.ValueType = REG_DWORD
                cc.Value = 15
            ElseIf D$ = "PEN" Then
                cc.ValueKey = "PEN"
                cc.ValueType = REG_DWORD
                cc.Value = 0
                cc.ValueKey = "PAPER"
                cc.ValueType = REG_DWORD
                cc.Value = 7
            ElseIf D$ = "BOLD" Then
                cc.ValueKey = "BOLD"
                cc.ValueType = REG_DWORD
                cc.Value = 0
            ElseIf D$ = "PAPER" Then
                cc.ValueKey = "PAPER"
                cc.ValueType = REG_DWORD
                cc.Value = 7
                cc.ValueKey = "PEN"
                cc.ValueType = REG_DWORD
                cc.Value = 0
            ElseIf D$ = "GREEK" Then
                If Not fornow Then
                    cc.ValueKey = "COMMAND"
                    cc.ValueType = REG_SZ
                    cc.Value = "LATIN"
                End If
                pagio$ = "LATIN"
            ElseIf D$ = "DARK" Then
                If Not fornow Then
                     cc.ValueKey = "HTML"
                     cc.ValueType = REG_SZ
                     cc.Value = "BRIGHT"
                End If
                pagiohtml$ = "BRIGHT"
            ElseIf D$ = "CASESENSITIVE" Then
                If Not fornow Then
                    cc.ValueKey = "CASESENSITIVE"
                    cc.ValueType = REG_SZ
                    cc.Value = "NO"
                End If
                casesensitive = False
            ElseIf D$ = "INP" Then
                If Not fornow Then
                    cc.ValueKey = "INP-SWITCH"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                Use13 = False
            ElseIf D$ = "NBS" Then
                If Not fornow Then
                    cc.ValueKey = "NBS-SWITCH"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                Nonbsp = True
            ElseIf D$ = "RDB" Then
                If Not fornow Then
                    cc.ValueKey = "ROUND"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                RoundDouble = False
            ElseIf D$ = "TAB" Then
                If Not fornow Then
                    cc.ValueKey = "TAB"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                UseTabInForm1Text1 = False
            ElseIf D$ = "SBL" Then
                If Not fornow Then
                    cc.ValueKey = "SHOWBOOLEAN"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                ShowBooleanAsString = False
            ElseIf D$ = "DIM" Then
                If Not fornow Then
                    cc.ValueKey = "DIMLIKEBASIC"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                DimLikeBasic = False
            ElseIf D$ = "FOR" Then
                If Not fornow Then
                    cc.ValueKey = "FOR-LIKE-BASIC"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                ForLikeBasic = False
            ElseIf D$ = "PRI" Then
                If Not fornow Then
                cc.ValueKey = "PRIORITY-OR"
                cc.ValueType = REG_DWORD
                cc.Value = 0&  ' FALSE IS WRONG VALUE HERE
                End If
                priorityOr = False
            ElseIf D$ = "REG" Then
                gsb_file False
            ElseIf D$ = "DEC" Then
                If Not fornow Then
                    cc.ValueKey = "DEC"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                mNoUseDec = False
                CheckDec
            ElseIf D$ = "TXT" Then
                If Not fornow Then
                    cc.ValueKey = "TEXTCOMPARE"
                    cc.ValueType = REG_DWORD
                    cc.Value = 0&
                End If
                mTextCompare = False
            ElseIf D$ = "REC" Then
                cc.ValueKey = "FUNCDEEP"  ' RESET
                cc.ValueType = REG_DWORD
                cc.Value = 300
                If m_bInIDE Then funcdeep = 128
                 ' funcdeep not used - but functionality stay there for old dll's
                ClaimStack
                If findstack - 100000 > 0 Then
                    stacksize = findstack - 100000
                End If
            ElseIf D$ = "MDB" Then
                If Not fornow Then
                    cc.ValueKey = "MDBHELP"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(False)
                End If
                UseMDBHELP = False
            Else
                s$ = "-" + D$ + s$
                Exit Do
            End If
        Else
            Exit Do
        End If
        Sleep 2
    Loop
    Do While FastSymbol(s$, "+")
        If IsLabel(Basestack1, s$, D$) > 0 Then
            D$ = UCase(D$)
            If D$ = "TEST" Then
            
                STq = False
                STEXIT = False
                STbyST = True
                Form2.Show , Form1
                If Form2.Busy Then
                Do
                    Sleep 10
                Loop Until Not Form2.Busy
                End If
                Form2.label1(0) = vbNullString
                Form2.label1(1) = vbNullString
                Form2.label1(2) = vbNullString
                TestShowSub = vbNullString
                TestShowStart = 0
                stackshow Basestack1
                Form2.Busy = False
                Form1.Show , Form5
                If Form3.Visible Then Form3.skiptimer = True: Form3.WindowState = 0
                trace = True
                ElseIf D$ = "REG" Then
                gsb_file
            ElseIf D$ = "FONT" Then
                ' + LOAD NEW
                cc.ValueKey = "FONT"
                cc.ValueType = REG_SZ
                If ISSTRINGA(s$, W$) Then cc.Value = W$
            ElseIf D$ = "SEC" Then
                If Not fornow Then
                    cc.ValueKey = "NEWSECURENAMES"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(-1)
                End If
                SecureNames = True
            ElseIf D$ = "DIV" Then
                If Not fornow Then
                    cc.ValueKey = "DIV"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(-1)
                End If
                UseIntDiv = True
            ElseIf D$ = "LINESPACE" Then
                If Not fornow Then
                    cc.ValueKey = "LINESPACE"
                    cc.ValueType = REG_DWORD
                End If
                If IsNumberLabel(s$, W$) Then If val(W$) >= 0 And val(W$) <= 60 * dv15 Then cc.Value = CLng(val(W$) * 2)
            ElseIf D$ = "SIZE" Then
                cc.ValueKey = "SIZE"
                cc.ValueType = REG_DWORD
                If IsNumberLabel(s$, W$) Then If val(W$) >= 8 And val(W$) <= 48 Then cc.Value = CLng(val(W$))
            ElseIf D$ = "PEN" Then
                cc.ValueKey = "PAPER"
                cc.ValueType = REG_DWORD
                p = cc.Value
                cc.ValueKey = "PEN"
                cc.ValueType = REG_DWORD
                If IsNumberLabel(s$, W$) Then
                    If p = val(W$) Then p = 15 - p Else p = val(W$) Mod 16
                    cc.Value = CLng(val(p))
                End If
            ElseIf D$ = "BOLD" Then
                cc.ValueKey = "BOLD"
                cc.ValueType = REG_DWORD
                cc.Value = 1
                If IsNumberLabel(s$, W$) Then cc.Value = CLng(val(W$) Mod 16)
            ElseIf D$ = "PAPER" Then
                cc.ValueKey = "PEN"
                cc.ValueType = REG_DWORD
                p = cc.Value
                cc.ValueKey = "PAPER"
                cc.ValueType = REG_DWORD
                If IsNumberLabel(s$, W$) Then
                    If p = val(W$) Then p = 15 - p Else p = val(W$) Mod 16
                    cc.Value = CLng(val(p))
                End If
            ElseIf D$ = "GREEK" Then
                If Not fornow Then
                    cc.ValueKey = "COMMAND"
                    cc.ValueType = REG_SZ
                    cc.Value = "GREEK"
                End If
                pagio$ = "GREEK"
            ElseIf D$ = "DARK" Then
                If Not fornow Then
                    cc.ValueKey = "HTML"
                    cc.ValueType = REG_SZ
                    cc.Value = "DARK"
                End If
                pagiohtml$ = "DARK"
            ElseIf D$ = "CASESENSITIVE" Then
                If Not fornow Then
                    cc.ValueKey = "CASESENSITIVE"
                    cc.ValueType = REG_SZ
                    cc.Value = "YES"
                End If
                casesensitive = True
            ElseIf D$ = "INP" Then
                If Not fornow Then
                    cc.ValueKey = "INP-SWITCH"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                Use13 = True
            ElseIf D$ = "NBS" Then
                If Not fornow Then
                    cc.ValueKey = "NBS-SWITCH"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(False)
                End If
                Nonbsp = False
            ElseIf D$ = "RDB" Then
                If Not fornow Then
                    cc.ValueKey = "ROUND"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                RoundDouble = True
            ElseIf D$ = "TAB" Then
                If Not fornow Then
                    cc.ValueKey = "TAB"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                UseTabInForm1Text1 = True
            ElseIf D$ = "SBL" Then
                If Not fornow Then
                    cc.ValueKey = "SHOWBOOLEAN"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                ShowBooleanAsString = True
            ElseIf D$ = "DIM" Then
                If Not fornow Then
                    cc.ValueKey = "DIMLIKEBASIC"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                DimLikeBasic = True
            ElseIf D$ = "FOR" Then
                If Not fornow Then
                    cc.ValueKey = "FOR-LIKE-BASIC"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                ForLikeBasic = True
            ElseIf D$ = "PRI" Then
                If Not fornow Then
                    cc.ValueKey = "PRIORITY-OR"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                priorityOr = True
            ElseIf D$ = "TXT" Then
                If Not fornow Then
                    cc.ValueKey = "TEXTCOMPARE"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                mTextCompare = True
            ElseIf D$ = "DEC" Then
                If Not fornow Then
                    cc.ValueKey = "DEC"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                mNoUseDec = True
                CheckDec
            ElseIf D$ = "REC" Then
                cc.ValueKey = "FUNCDEEP"  ' RESET
                cc.ValueType = REG_DWORD
                funcdeep = 3260
                cc.Value = 3260 ' SET REVISION DEFAULT
                ClaimStack
                If findstack - 100000 > 0 Then
                    stacksize = findstack - 100000
                End If
            ElseIf D$ = "MDB" Then
                If Not fornow Then
                    cc.ValueKey = "MDBHELP"
                    cc.ValueType = REG_DWORD
                    cc.Value = CLng(True)
                End If
                UseMDBHELP = True
            Else
                s$ = "+" + D$ + s$
                Exit Do
            End If
        Else
            Exit Do
        End If
        Sleep 2
    Loop
End If
End Sub
    
    
Sub myesc(b$)
MyErMacro b$, "Escape", "ÄéáêïðÞ åêôÝëåóçò"
End Sub
Sub wrongsizeOrposition(A$)
    MyErMacro A$, "Wrong Size-Position for reading buffer", "ËÜèïò ÌÝãåèïò-èÝóç, ãéá äéÜâáóìá ÄéÜñèñùóçò"
End Sub
Sub wrongweakref(A$)
MyErMacro A$, "Wrong weak reference", "ëÜèïò éó÷íÞò áíáöïñÜò"
End Sub
Sub negsqrt(A$)
MyErMacro A$, "negative number for root", "áñíçôéêüò óå ñßæá"
End Sub
Sub expecteddecimal(A$)
MyErMacro A$, "Expected decimal separator char", "Ðåñßìåíá ÷áñáêôÞñá äéá÷ùñéóìïý äåêáäéêþí"
End Sub
Sub wrongexprinstring(A$)
MyErMacro A$, "Wrong expression in string", "ëÜèïò ìáèçìáôéêÞ Ýêöñáóç óôï áëöáñéèìçôéêü"
End Sub
Sub unknownoffset(A$, s$)
MyErMacro A$, "Unknown Offset " + s$, "¢ãíùóôç ÌåôÜèåóç " + s$
End Sub
Sub wronguseofenum(A$)
MyErMacro A$, "Wrong use of enumerator", "ëÜèïò ÷ñÞóç áðáñéèìçôÞ"
End Sub
Sub nosuchfile()
MyEr "No such file", "Äåí õðÜñ÷åé ôÝôïéï áñ÷åßï"
End Sub

Public Sub MyDoEvents()
On Error GoTo there
If TaskMaster Is Nothing Then
    DoEvents
    Exit Sub
ElseIf Not TaskMaster.Processing And TaskMaster.QueueCount = 0 Then
    DoEvents
    Exit Sub
Else
    If TaskMaster.PlayMusic Then
        TaskMaster.OnlyMusic = True
        TaskMaster.TimerTick
        TaskMaster.OnlyMusic = False
    End If
    TaskMaster.StopProcess
    TaskMaster.TimerTick
    DoEvents
    TaskMaster.StartProcess
End If
Exit Sub
there:
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd1
End Sub

Public Function ContainsUTF16(ByRef Source() As Byte, Optional maxsearch As Long = -1) As Long
  Dim I As Long, lUBound As Long, lUBound2 As Long, lUBound3 As Long
  Dim CurByte As Byte, CurByte1 As Byte
  Dim CurBytes As Long, CurBytes1 As Long
    lUBound = UBound(Source)
    If lUBound > 4 Then
    CurByte = Source(0)
    CurByte1 = Source(1)
    If maxsearch = -1 Then
    maxsearch = lUBound - 1
    ElseIf maxsearch < 8 Or maxsearch > lUBound - 1 Then
    maxsearch = lUBound - 1
    End If
    
    
    
    For I = 2 To maxsearch Step 2
        If CurByte1 = 0 And CurByte < 31 Then CurBytes1 = CurBytes1 + 1
        If CurByte = 0 And CurByte1 < 31 Then CurBytes = CurBytes + 1
        If Source(I) = CurByte Then
            CurBytes = CurBytes + 1
        Else
            CurByte = Source(I)
        End If
        If Source(I + 1) = CurByte1 Then
            CurBytes1 = CurBytes1 + 1
        Else
            CurByte1 = Source(I + 1)
        End If
        
    Next I
    End If
    If CurBytes1 = CurBytes And CurBytes1 * 3 >= lUBound Then
    ContainsUTF16 = 0
    Else
    If CurBytes1 * 3 >= lUBound Then
    ContainsUTF16 = 1
    ElseIf CurBytes * 3 >= lUBound Then
    ContainsUTF16 = 2
    Else
    ContainsUTF16 = 0
    End If
    End If
End Function
Public Function ContainsUTF8(ByRef Source() As Byte) As Boolean
  Dim I As Long, lUBound As Long, lUBound2 As Long, lUBound3 As Long
  Dim CurByte As Byte
    lUBound = UBound(Source)
    lUBound2 = lUBound - 2
    lUBound3 = lUBound - 3
    If lUBound > 2 Then
    
    For I = 0 To lUBound - 1
      CurByte = Source(I)
        If (CurByte And &HE0) = &HC0 Then
        If (Source(I + 1) And &HC0) = &H80 Then
            ContainsUTF8 = ContainsUTF8 Or True
             I = I + 1
             Else
                ContainsUTF8 = False
                Exit For
            End If
        

        ElseIf (CurByte And &HF0) = &HE0 Then
        ' 2 bytes
        If (Source(I + 1) And &HC0) = &H80 Then
            I = I + 1
            If I < lUBound2 Then
            If (Source(I + 1) And &HC0) = &H80 Then
                ContainsUTF8 = ContainsUTF8 Or True
                I = I + 1
            Else
                ContainsUTF8 = False
                Exit For
            End If
                Else
                ContainsUTF8 = False
                Exit For
            End If
        Else
            ContainsUTF8 = False
            Exit For
        End If
        ElseIf (CurByte And &HF8) = &HF0 Then
        ' 2 bytes
        If (Source(I + 1) And &HC0) = &H80 Then
            I = I + 1
            If I < lUBound2 Then
               If (Source(I + 1) And &HC0) = &H80 Then
                    ContainsUTF8 = ContainsUTF8 Or True
                    I = I + 1
                    If I < lUBound3 Then
                       If (Source(I + 1) And &HC0) = &H80 Then
                            ContainsUTF8 = ContainsUTF8 Or True
                            I = I + 1
                        Else
                            ContainsUTF8 = False
                            Exit For
                        End If
                        
                    Else
                        ContainsUTF8 = False
                        Exit For
                    End If
                Else
                    ContainsUTF8 = False
                    Exit For
                End If
                
            Else
                ContainsUTF8 = False
                Exit For
            End If
        Else
            ContainsUTF8 = False
            Exit For
        End If
        
        
        End If
        
    Next I
    End If
    

End Function
Function ReadUnicodeOrANSI(FileName As String, Optional ByVal EnsureWinLFs As Boolean, Optional feedback As Long) As String
Dim I&, FNr&, BLen&, WChars&, bom As Integer, BTmp As Byte, b() As Byte
Dim mLof As Long, nobom As Long
nobom = 1
' code from Schmidt, member of vbforums
If FileName = vbNullString Then Exit Function
On Error Resume Next
If GetDosPath(FileName) = vbNullString Then MissFile: Exit Function
 On Error GoTo ErrHandler
  BLen = FileLen(GetDosPath(FileName))
'  If Err.Number = 53 Then missfile: Exit Function
 
  If BLen = 0 Then Exit Function
  
  FNr = FreeFile
  Open GetDosPath(FileName) For Binary Access Read As FNr
      Get FNr, , bom
    Select Case bom
      Case &HFEFF, &HFFFE 'one of the two possible 16 Bit BOMs
        If BLen >= 3 Then
          ReDim b(0 To BLen - 3): Get FNr, 3, b 'read the Bytes
utf16conthere:
          feedback = 0
          If bom = &HFFFE Then 'big endian, so lets swap the byte-pairs
          feedback = 1
            For I = 0 To UBound(b) Step 2
              BTmp = b(I): b(I) = b(I + 1): b(I + 1) = BTmp
            Next
          End If
          ReadUnicodeOrANSI = b
        End If
      Case &HBBEF 'the start of a potential UTF8-BOM
        Get FNr, , BTmp
        If BTmp = &HBF Then 'it's indeed the UTF8-BOM
        feedback = 2
          If BLen >= 4 Then
            ReDim b(0 To BLen - 4): Get FNr, 4, b 'read the Bytes
            WChars = MultiByteToWideChar(65001, 0, b(0), BLen - 3, 0, 0)
            ReadUnicodeOrANSI = space$(WChars)
            MultiByteToWideChar 65001, 0, b(0), BLen - 3, StrPtr(ReadUnicodeOrANSI), WChars
          End If
        Else 'not an UTF8-BOM, so read the whole Text as ANSI
        feedback = 3
        
          ReadUnicodeOrANSI = StrConv(space$(BLen), vbFromUnicode)
          Get FNr, 1, ReadUnicodeOrANSI
        End If
        
      Case Else 'no BOM was detected, so read the whole Text as ANSI
        feedback = 3
       mLof = LOF(FNr)
       Dim buf() As Byte
       If mLof > 1000 Then
       ReDim buf(1000)
       Else
       ReDim buf(mLof)
       End If
       Get FNr, 1, buf()
       Seek FNr, 1
       Dim notok As Boolean
      If ContainsUTF8(buf()) Then 'maybe is utf-8
      feedback = 2
      nobom = -1
        ReDim b(0 To BLen - 1): Get FNr, 1, b
            WChars = MultiByteToWideChar(65001, 0, b(0), BLen, 0, 0)
            ReadUnicodeOrANSI = space$(WChars)
            MultiByteToWideChar 65001, 0, b(0), BLen, StrPtr(ReadUnicodeOrANSI), WChars
        Else
        notok = True
        
        
            Select Case ContainsUTF16(buf())
        Case 1
            nobom = -1
            bom = &HFEFF
            ReDim b(0 To BLen - 1): Get FNr, 1, b 'read the Bytes
            GoTo utf16conthere
        Case 2
            nobom = -1
            bom = &HFEFF
            ReDim b(0 To BLen - 1): Get FNr, 1, b 'read the Bytes
            GoTo utf16conthere
        End Select
        End If
        If notok Then
        ReDim b(0 To BLen - 1): Get FNr, 1, b
        If BLen Mod 2 = 1 Then
        ReadUnicodeOrANSI = StrConv(space$(BLen), vbFromUnicode)
        Else
        ReadUnicodeOrANSI = space$(BLen \ 2)
        End If
         CopyMemory ByVal StrPtr(ReadUnicodeOrANSI), b(0), BLen
         
         Clid = FoundLocaleId(Left$(ReadUnicodeOrANSI, 500))
         
         
         
        ReadUnicodeOrANSI = StrConv(ReadUnicodeOrANSI, vbUnicode, Clid)
        'End If
        End If
    End Select
    
    If InStr(ReadUnicodeOrANSI, vbCrLf) = 0 Then
      If InStr(ReadUnicodeOrANSI, vbLf) Then
      feedback = feedback + 10
   If EnsureWinLFs Then ReadUnicodeOrANSI = Replace(ReadUnicodeOrANSI, vbLf, vbCrLf)
      ElseIf InStr(ReadUnicodeOrANSI, vbCr) Then
      feedback = feedback + 20
      
    If EnsureWinLFs Then ReadUnicodeOrANSI = Replace(ReadUnicodeOrANSI, vbCr, vbCrLf)
      End If
    End If
    feedback = nobom * feedback
ErrHandler:
If FNr Then Close FNr
If Err Then
'MyEr Err.Description, Err.Description
Err.Raise Err.Number, Err.Source + ".ReadUnicodeOrANSI", Err.Description
End If
End Function

Public Function SaveUnicode(ByVal FileName As String, ByVal buf As String, mode2save As Long, Optional Append As Boolean = False) As Boolean
' using doc as extension you can read it from word...with automatic conversion to unicode
' OVERWRITE ALWAYS
Dim W As Long, A() As Byte, f$, I As Long, bb As Byte, yesswap As Boolean
On Error GoTo t12345
If Not Append Then
If Not NeoUnicodeFile(FileName) Then Exit Function
Else
If Not CanKillFile(FileName$) Then Exit Function
End If
f$ = GetDosPath(FileName)
If Err.Number > 0 Or f$ = vbNullString Then Exit Function
W = FreeFile
MyDoEvents
Open f$ For Binary As W
' mode2save
' 0 is utf-le
If Append Then Seek #W, LOF(W) + 1
mode2save = mode2save Mod 10
If mode2save = 0 Then
If Not Append Then
    A() = ChrW(&HFEFF)
    Put #W, , A()
End If
ElseIf mode2save = 1 Then
A() = ChrW(&HFFFE) ' big endian...need swap
If Not Append Then Put #W, , A()
yesswap = True
ElseIf Abs(mode2save) = 2 Then  'utf8
If mode2save > 0 And Not Append Then

        Put #W, , CByte(&HEF)
        Put #W, , CByte(&HBB)
        Put #W, , CByte(&HBF)
        End If
        Put #W, , Utf16toUtf8(buf)
        Close W
    SaveUnicode = True
        Exit Function
ElseIf mode2save = 3 Then ' ascii
Dim Buf1() As Byte
Buf1 = StrConv(buf, vbFromUnicode, Clid)
Put #W, , Buf1()
      Close W
    SaveUnicode = True
        Exit Function
End If

Dim maxmw As Long, iPos As Long
iPos = 1
maxmw = 32000 ' check it with maxmw 20 OR 1
If yesswap Then
For iPos = 1 To Len(buf) Step maxmw
A() = Mid$(buf, iPos, maxmw)
For I = 0 To UBound(A()) - 1 Step 2
bb = A(I): A(I) = A(I + 1): A(I + 1) = bb
Next I
Put #W, 3, A()
Next iPos
Else
For iPos = 1 To Len(buf) Step maxmw
A() = Mid$(buf, iPos, maxmw)
Put #W, , A()
Next iPos
End If
Close W
SaveUnicode = True
t12345:
End Function
Public Sub putUniString(f As Long, s As String)
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Sub
Module10.FileWriteString FH, s
End Sub
Public Sub putANSIString(f As Long, s As String)
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Sub
Module10.FileWriteString FH, StrConv(s, vbFromUnicode, Clid)
End Sub
Public Function getUniStringlINE(f As Long, s As String) As Boolean
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Function
Dim s1 As String, ss As Currency, lbreak As String
On Error GoTo a11
Do While Not FileEOFFH(FH)
    Module10.FileReadString FH, s1, 2
    If s1 <> vbCr And s1 <> vbLf Then
        s = s + s1
    Else
        If Not FileEOFFH(FH) Then
        ss = Module10.FileSeekFH(FH)
        lbreak = s1
        Module10.FileReadString FH, s1, 2
        If s1 <> vbCr And s1 <> vbLf Or lbreak = s1 Then
            Module10.FileSeekFH(FH) = ss
        End If
    End If
    
Exit Do
End If
    If Len(s) > 65535 Then
        MyEr "too big line for line input", "ðïëý ìåãÜëç åéóáãùãÞ ãñáììÞò"
        Exit Function
    End If
Loop
getUniStringlINE = True
a11:
End Function

Public Sub getAnsiStringlINE(f As Long, s As String)
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Sub
Dim A(0) As Byte, s1 As String, ss As Currency, lbreak As String
On Error GoTo a11
Do While Not FileEOFFH(FH)
    Module10.FileReadBytes FH, A(), 1
    s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
    If s1 <> vbCr And s1 <> vbLf Then
        s = s + s1
    Else
        If Not FileEOFFH(FH) Then
            ss = Module10.FileSeekFH(FH)
            Module10.FileReadBytes FH, A(), 1
            lbreak = s1
            s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
            If s1 <> vbCr And s1 <> vbLf Or lbreak = s1 Then
                Module10.FileSeekFH(FH) = ss
            End If
        End If
        Exit Do
    End If
    If LenB(s) > 65535 Then
        MyEr "too big line for line input", "ðïëý ìåãÜëç åéóáãùãÞ ãñáììÞò"
        Exit Sub
    End If
Loop
a11:
End Sub
Public Sub getUniStringComma(f As Long, s As String, Optional nochar34 As Boolean)
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Sub
Dim s1 As String, ss As Currency, inside As Boolean
s = vbNullString
On Error GoTo a1115
Do While Not FileEOFFH(FH) '(LOF(F) < Seek(F))
    Module10.FileReadString FH, s1, 2
    If nochar34 Then s = s1: Exit Do
    If s1 <> " " Then
    
    If s1 = """" Then inside = True: Exit Do
    End If
Loop

If Not nochar34 Then
    If s1 <> """" Then Exit Sub
Else
    If s1 = inpcsvsep$ Then
        s = vbNullString
        Exit Sub
    ElseIf s1 = vbCr Then
        s = vbNullString
        If Not FileEOFFH(FH) Then
            ss = Module10.FileSeekFH(FH)
            Module10.FileReadString FH, s1, 2
            If s1 <> vbLf Then
                Module10.FileSeekFH(FH) = ss
            End If
        End If
        Exit Sub
    ElseIf s1 = vbLf Then
        s = vbNullString
        Exit Sub
    End If
End If
Do While Not FileEOFFH(FH)
    Module10.FileReadString FH, s1, 2
    If s1 <> vbCr And s1 <> vbLf And nochar34 And Not s1 = inpcsvsep$ Then
        s = s + s1
    ElseIf s1 <> vbCr And s1 <> vbLf And s1 <> """" And Not nochar34 Then
        s = s + s1
    Else
        If nochar34 Then
        GoTo there
        ElseIf s1 = """" Then
            If s = vbNullString Then
                inside = False
            Else
                If Not FileEOFFH(FH) Then
                    ss = Module10.FileSeekFH(FH)
                    Module10.FileReadString FH, s1, 2
                    If s1 = """" Then
                        s = s + """"
                        GoTo nn1
                    Else
                        Module10.FileSeekFH(FH) = ss
                    End If
                End If
            End If
            inside = False
            Do While Not FileEOFFH(FH)
                Module10.FileReadString FH, s1, 2
                If s1 = vbCr Or s1 = vbLf Or s1 = inpcsvsep$ Then Exit Do
            Loop
there:
            If s1 = inpcsvsep$ Then Exit Do
        End If
        If s1 <> inpcsvsep$ And (Not FileEOFFH(FH)) And (Not inside) Then
            ss = Module10.FileSeekFH(FH)
            Module10.FileReadString FH, s1, 2
            If s1 <> vbCr And s1 <> vbLf Then
                Module10.FileSeekFH(FH) = ss
            End If
        End If
        If Not inside Then Exit Do Else s = s + s1
    End If
nn1:
    If Len(s) > 65535 Then
            MyEr "too big line for line input", "ðïëý ìåãÜëç åéóáãùãÞ ãñáììÞò"
            Exit Sub
        End If
    Loop
a1115:
End Sub
Public Sub getAnsiStringComma(f As Long, s As String, Optional nochar34 As Boolean)
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Sub
Dim A(0) As Byte, s1 As String, ss As Currency, inside As Boolean
s = vbNullString
On Error GoTo a1111
Do While Not FileEOFFH(FH)  'LOF(f) < Seek(f)
    Module10.FileReadBytes FH, A(), 1
    s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
    If nochar34 Then s = s1: Exit Do
    If s1 <> " " Then
        If s1 = """" Then inside = True: Exit Do
    End If
Loop
' we throw the first
If Not nochar34 Then
    If s1 <> """" Then Exit Sub
Else
    If s1 = inpcsvsep$ Then
        s = vbNullString
        Exit Sub
    ElseIf s1 = vbCr Then
        s = vbNullString
        If Not FileEOFFH(FH) Then
            ss = Module10.FileSeekFH(FH)
            Module10.FileReadBytes FH, A(), 1
            s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
            If s1 <> vbLf Then
                Module10.FileSeekFH(FH) = ss
            End If
        End If
        Exit Sub
    ElseIf s1 = vbLf Then
        s = vbNullString
        Exit Sub
    End If
End If
Do While Not FileEOFFH(FH)  'LOF(f) < Seek(f)
    Module10.FileReadBytes FH, A(), 1
    s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
    If s1 <> vbCr And s1 <> vbLf And nochar34 And Not s1 = inpcsvsep$ Then
        s = s + s1
    ElseIf s1 <> vbCr And s1 <> vbLf And s1 <> """" And Not nochar34 Then
        s = s + s1
    Else
        If nochar34 Then
            GoTo there
        ElseIf s1 = """" Then
            If s = vbNullString Then ' is the first we have empty string
                inside = False
            Else
                If Not FileEOFFH(FH) Then
                    ss = Module10.FileSeekFH(FH)
                    Module10.FileReadBytes FH, A(), 1
                    If A(0) = 34 Then
                        s = s + Chr(34)
                        GoTo nn1
                    Else
                        Module10.FileSeekFH(FH) = ss
                    End If
                End If
            End If
            inside = False
            Do While Not FileEOFFH(FH)
                Module10.FileReadBytes FH, A(), 1
                s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
                If s1 = vbCr Or s1 = vbLf Or s1 = inpcsvsep$ Then Exit Do
            Loop
there:
            If s1 = inpcsvsep$ Then Exit Do
        End If
        If s1 <> inpcsvsep$ And (Not FileEOFFH(FH)) And (Not inside) Then
            ss = Module10.FileSeekFH(FH)
            Module10.FileReadBytes FH, A(), 1
            s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
            If s1 <> vbCr And s1 <> vbLf Then
                Module10.FileSeekFH(FH) = ss
            End If
        End If
        If Not inside Then Exit Do Else s = s + s1
    End If
nn1:
        If LenB(s) > 65535 Then
            MyEr "too big line for line input", "ðïëý ìåãÜëç åéóáãùãÞ ãñáììÞò"
            Exit Sub
        End If
Loop
a1111:
End Sub
Public Sub getUniRealComma(f As Long, s$)
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Sub
Dim s1 As String, ss As Currency
s$ = vbNullString
On Error GoTo a111
Do While Not FileEOFFH(FH)
    Module10.FileReadString FH, s1, 2
    If s1 <> vbCr And s1 <> vbLf And s1 <> inpcsvsep$ Then
        s = s + s1
    Else
        If s1 <> inpcsvsep$ And Not (FileEOFFH(FH)) Then
            ss = Module10.FileSeekFH(FH)
            Module10.FileReadString FH, s1, 2
            If s1 <> vbCr And s1 <> vbLf Then
                Module10.FileSeekFH(FH) = ss
            End If
        End If
        Exit Do
    End If
    If Len(s) > 65535 Then
        MyEr "too big line for line input", "ðïëý ìåãÜëç åéóáãùãÞ ãñáììÞò"
        Exit Sub
    End If
Loop
s$ = MyTrim$(s$)
If LenB(s$) = 0 Then s$ = "0"
a111:
End Sub
Public Sub getAnsiRealComma(f As Long, s$)
Dim FH As Long
FH = Module10.ReadFileHandler(f)
If FH = 0 Then Exit Sub
Dim A(0) As Byte, s1 As String, ss As Currency
s$ = vbNullString
On Error GoTo a112
Do While Not FileEOFFH(FH)  'LOF(f) < Seek(f)
    Module10.FileReadBytes FH, A(), 1
    s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
    If s1 <> vbCr And s1 <> vbLf And s1 <> inpcsvsep$ Then
        s = s + s1
    Else
        If s1 <> inpcsvsep$ And Not FileEOFFH(FH) Then
            ss = Module10.FileSeekFH(FH)
            Module10.FileReadBytes FH, A(), 1
            s1 = ChrW(AscW(StrConv(ChrW(A(0)), vbUnicode, Clid)))
            If s1 <> vbCr And s1 <> vbLf Then
                Module10.FileSeekFH(FH) = ss
            End If
        End If
        Exit Do
    End If
        If LenB(s) > 65535 Then
            MyEr "too big line for line input", "ðïëý ìåãÜëç åéóáãùãÞ ãñáììÞò"
            Exit Sub
        End If
Loop
s$ = MyTrim$(s$)
If LenB(s$) = 0 Then s$ = "0"
a112:
End Sub

Public Function PopOne(s$) As String
Dim I&, LL As Long, n As Long
LL = Len(s): If LL = 0 Then Exit Function
Dim a1() As Integer, A2() As Integer
ReDim a1(LL + 6)
ReDim A2(LL + 6)
Dim skip As Boolean
skip = GetStringTypeExW(&HB, 4, StrPtr(s$), LL, a1(0)) = 0
skip = GetStringTypeExW(&HB, 2, StrPtr(s$), LL, A2(0)) = 0 Or skip
If skip Then
 PopOne = Left$(s$, 1)
 s$ = Mid$(s$, 2)
Else
  I& = LL - 1
  LL = 0
  For n = 0 To I&
  If a1(n) = 2048 And A2(n) = 1 Then
  If LL = 2 Then Exit For
    LL = LL + 1
  ElseIf a1(n) = 4096 And A2(n) = 0 Then
    If LL = 2 Then Exit For
     LL = LL + 1
     ElseIf a1(n) = 3 And A2(n) = 11 Then
        If LL < 2 Then
            PopOne = Left$(s, 1)
            s = Mid$(s, 2)
            Exit Function
        End If
     ElseIf (a1(n) = 0 And A2(n) = 0) Or a1(n) = 1 Then
        If LL < 2 Then
            PopOne = Left$(s, 1)
            s = Mid$(s, 2)
            Exit Function
        End If
    Else
    If LL = 2 Then Exit For
    LL = LL + 2
   End If
  Next n
  If LL < 2 Then LL = 1 Else LL = LL \ 2
 PopOne = Left$(s$, LL)
s$ = Mid$(s$, LL + 1)
End If


End Function
Public Sub ExcludeOne(s$)
Dim I&, LL As Long, n As Long
LL = Len(s): If LL = 0 Then Exit Sub
Dim a1() As Integer, A2() As Integer
ReDim a1(LL + 6)
ReDim A2(LL + 6)
Dim skip As Boolean
skip = GetStringTypeExW(&HB, 4, StrPtr(s$), LL, a1(0)) = 0
skip = GetStringTypeExW(&HB, 2, StrPtr(s$), LL, A2(0)) = 0 Or skip
If skip Then
 s$ = Left$(s$, Len(s$) - 1)
Else
  I& = LL - 1
  LL = 0
  For n = I& To 0 Step -1
  If a1(n) = 2048 And A2(n) = 1 Then
  If LL = 2 Then Exit For
    LL = LL + 1
  ElseIf a1(n) = 4096 And A2(n) = 0 Then
    If LL = 2 Then Exit For
     LL = LL + 1
     ElseIf a1(n) = 3 And A2(n) = 11 Then
    ElseIf a1(n) = 0 And A2(n) = 0 Then
    ElseIf a1(n) = 1 Then
    Else
    If LL = 2 Then Exit For
    LL = LL + 2
   End If
  Next n
     s$ = Left$(s$, n + 1)
End If
End Sub
Function RealRight(s$, ByVal many As Long) As String
Dim I&, LL As Long, n As Long
LL = Len(s): If LL = 0 Then Exit Function
If many >= LL Then RealRight = s$: Exit Function

Dim a1() As Integer, A2() As Integer
ReDim a1(LL + 6)
ReDim A2(LL + 6)
Dim skip As Boolean
skip = GetStringTypeExW(&HB, 4, StrPtr(s$), LL, a1(0)) = 0
skip = GetStringTypeExW(&HB, 2, StrPtr(s$), LL, A2(0)) = 0 Or skip
If skip Then
 RealRight = Right$(s$, many)
Else
  I& = LL - 1
  LL = -(many - 1) * 2 + 2
  For n = I& To 0 Step -1
  If a1(n) = 2048 And A2(n) = 1 Then
  If LL = 2 Then Exit For
    LL = LL + 1
  ElseIf a1(n) = 4096 And A2(n) = 0 Then
    If LL = 2 Then Exit For
     LL = LL + 1
     ElseIf a1(n) = 3 And A2(n) = 11 Then
     ElseIf a1(n) = 0 And A2(n) = 0 Then
     ElseIf a1(n) = 1 Then
    Else
    If LL = 2 Then Exit For
    LL = LL + 2
   End If
  Next n
     RealRight = Mid$(s$, n + 1)
End If
End Function
Function RealLeft(s$, ByVal many As Long) As String
Dim I&, LL As Long, n As Long
LL = Len(s): If LL = 0 Then Exit Function
If many >= LL Then RealLeft = s$: Exit Function

Dim a1() As Integer, A2() As Integer
ReDim a1(LL + 6)
ReDim A2(LL + 6)
Dim skip As Boolean
skip = GetStringTypeExW(&HB, 4, StrPtr(s$), LL, a1(0)) = 0
skip = GetStringTypeExW(&HB, 2, StrPtr(s$), LL, A2(0)) = 0 Or skip
If skip Then
 RealLeft = Left$(s$, many)
Else
  I& = LL - 1
  LL = -(many - 1) * 2 + 2
  For n = 0 To I&
  If a1(n) = 2048 And A2(n) = 1 Then
  If LL = 2 Then Exit For
    LL = LL + 1
  ElseIf a1(n) = 4096 And A2(n) = 0 Then
    If LL = 2 Then Exit For
     LL = LL + 1
     ElseIf a1(n) = 3 And A2(n) = 11 Then
     ElseIf a1(n) = 0 And A2(n) = 0 Then
     ElseIf a1(n) = 1 Then
    Else
    If LL = 2 Then Exit For
    LL = LL + 2
   End If
  Next n
     RealLeft = Mid$(s$, 1, n + 1)
End If
End Function

Function Tcase(s$) As String
Dim A() As String, I As Long
If s$ = vbNullString Then Exit Function
A() = Split(s$, " ")
For I = 0 To UBound(A())
A(I) = myUcase(Left$(A(I), 1), True) + Mid$(myLcase(A(I)), 2)
Next I
If UBound(A()) > 0 Then
Tcase = Join(A(), " ")
Else
Tcase = A(0)
End If
End Function
Public Sub choosenext()
Dim catchit As Boolean
On Error Resume Next
If Not Screen.ActiveForm Is Nothing Then
'Debug.Print "choose next"
    Dim X As Form
     For Each X In Forms
     If X.Name = "Form1" Or X.Name = "GuiM2000" Or X.Name = "Form2" Or X.Name = "Form4" Then
         If X.Visible And X.enabled Then
             If catchit Then X.SetFocus: Exit Sub
             If X.hWnd = GetForegroundWindow Then
             catchit = True
             End If
         End If
    End If
         
     Next X
     Set X = Nothing
     For Each X In Forms
     If X.Name = "Form1" Or X.Name = "GuiM2000" Or X.Name = "Form2" Or X.Name = "Form4" Then
         If X.Visible And X.enabled Then X.SetFocus: Exit Sub
             
             
         End If
     Next X
     Set X = Nothing
    End If

End Sub
Public Sub ChooseNextLeft(A As Object, b As GuiM2000, Optional ByVal useAny As Boolean = False)
    Dim X As gList, x1 As VB.PictureBox, backlist As Object, XX As Control, NoSkip As Boolean
    If b Is Nothing Then Exit Sub
    For Each XX In b.Controls
        If TypeOf XX Is gList Then
            If XX.Name <> "gList2" Then
                Set X = XX
                If useAny Then NoSkip = True Else NoSkip = X.Arrows2Tab Or X.TabStopSoft
                
                If X.Visible And X.enabled And NoSkip And Not X Is A Then
                    Set backlist = X
                End If
                If X Is A Then
                    If Not backlist Is Nothing Then
                        backlist.SetFocus
                    End If
                    Exit Sub
                End If
            End If
        ElseIf TypeOf XX Is VB.PictureBox Then
                Set x1 = XX
                NoSkip = x1.TabStop
                
                If x1.Visible And x1.enabled And NoSkip And Not x1 Is A Then
                    Set backlist = x1
                End If
                If x1 Is A Then
                    If Not backlist Is Nothing Then
                        backlist.SetFocus
                    End If
                    Exit Sub
                End If
        End If
    Next
End Sub
Public Sub ChooseNextRight(A As Object, b As GuiM2000, Optional ByVal useAny As Boolean = False)
    Dim X As gList, x1 As VB.PictureBox, GetNext As Boolean, XX As Control, NoSkip As Boolean
    If b Is Nothing Then Exit Sub
    For Each XX In b.Controls
        If TypeOf XX Is gList Then
            Set X = XX
            If useAny Then NoSkip = True Else NoSkip = X.Arrows2Tab Or X.TabStopSoft
            If X.Visible And X.enabled And NoSkip And GetNext Then
                X.SetFocus
                Exit Sub
            End If
            If X Is A Then GetNext = True
        ElseIf TypeOf XX Is VB.PictureBox Then
            Set x1 = XX
            NoSkip = x1.TabStop
            If x1.Visible And x1.enabled And NoSkip And GetNext Then
                x1.SetFocus
                Exit Sub
            End If
            If x1 Is A Then GetNext = True
        End If
    Next
End Sub
Public Function CheckLastHandler(obj As Object) As Boolean
Dim oldobj As Object, first As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set first = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = first: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set oldobj = obj
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                kk = kk + 1
                Set oldobj = obj
                Set obj = usehandler.objref
                GoTo again
        End If

    'End If
    
End If
If Not oldobj Is Nothing Then Set obj = oldobj: Set oldobj = Nothing: CheckLastHandler = True: Exit Function
Set obj = first
End Function
Public Function CheckLastHandlerVariant(obj) As Boolean
Dim oldobj As Object, first As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set first = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = first: Exit Function
If obj Is Nothing Then Exit Function
If TypeOf obj Is mHandler Then
    Set usehandler = obj
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set oldobj = obj
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                kk = kk + 1
                Set oldobj = obj
                Set obj = usehandler.objref
                GoTo again
        End If

    'End If
    
End If
If Not oldobj Is Nothing Then Set obj = oldobj: Set oldobj = Nothing: CheckLastHandlerVariant = True: Exit Function
Set obj = first
End Function
Public Function CheckLastHandlerOrIterator(obj As Object, lastindex As Long) As Boolean
Dim oldobj As Object, first As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set first = obj
lastindex = -1
Dim kk As Long
again:
If kk > 20 Then Set obj = first: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
        If usehandler.UseIterator Then lastindex = usehandler.index_cursor
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set oldobj = obj
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                kk = kk + 1
                Set oldobj = obj
                Set obj = usehandler.objref
                GoTo again
        End If

End If
    

If Not oldobj Is Nothing Then Set obj = oldobj: Set oldobj = Nothing: CheckLastHandlerOrIterator = True: Exit Function
Set obj = first
End Function
Public Function IfierVal()
If LastErNum <> 0 Then LastErNum = 0: IfierVal = True
End Function
Public Sub OutOfLimit()
  MyEr "Out of limit", "Åêôüò ïñßïõ"
End Sub
Public Sub stackproblem()
MyEr "Problem in return stack", "Ðñüâëçìá óôïí óùñü åðéóôñïöÞò"
End Sub
Public Sub PlaceAcommaBefore()
MyEr "Place a comma before", "ÂÜëå Ýíá êüììá ðñéí"
End Sub
Public Sub unknownid(b$, W$)
MyErMacro b$, "unknown identifier " + W$, "¢ãíùóôï áíáãíùñéóôéêü " + W$
End Sub
Public Sub VarNull()
MyEr "Variable is Null", "Ç ìåôáâëçôÞ Ý÷åé ôçí êáìßá ôéìÞ - Null"
End Sub

Public Sub NoRename()
    MyEr "Nothing renamed", "Äåí Ýãéíå ìåôïíïìáóßá"
End Sub
Public Sub MissCdib()
  MyEr "Missing IMAGE", "Ëåßðåé åéêüíá"
End Sub
Public Sub MissFile()
 MyEr "File not found", "Äåí âñÝèçêå ôï áñ÷åßï"
End Sub
Public Sub BadObjectDecl()
  MyEr "Bad object declaration - use Clear Command for Gui Elements", "ËÜèïò üñéóìá áíôéêåéìÝíïõ - ÷ñçóéìïðïßçóå Êáèáñü ãéá íá êáèáñßóåéò ôõ÷üí óôïé÷åßá ôïõ ãñáöéêïý ðåñéâÜëëïíôïò"
End Sub
Public Sub NoEnumerator()
  MyEr " - No enumerator found for this object", " - Äåí âñÞêá äñïìÝá óõëëïãÞò ãéá áõôü ôï áíôéêåßìåíï"
End Sub
Public Sub AssigntoNothing()
  MyEr "Bad object declaration - use Declare command", "ËÜèïò üñéóìá áíôéêåéìÝíïõ - ÷ñçóéìïðïßçóå ôçí ¼ñéóå"
End Sub
Public Sub Overflow()
 MyEr "Overflow", "õðåñ÷åßëéóç"
End Sub
Public Sub MissCdibStr()
  MyEr "Missing IMAGE in string", "Ëåßðåé åéêüíá óôï áëöáñéèìçôéêü"
End Sub
Public Sub MissStackStr()
  MyEr "Missing string value from stack", "Ëåßðåé áëöáñéèìçôéêü áðü ôï óùñü"
End Sub
Public Sub WrongFileHandler()
MyEr "Wrong File Handler", "ËÜèïò ×åéñéóôÞò Áñ÷åßïõ"
End Sub

Public Sub MissStackItem()
 MyEr "Missing item from stack", "Ëåßðåé êÜôé áðü ôï óùñü"
End Sub
Public Sub MissStackNumber()
 MyEr "Missing number value from stack", "Ëåßðåé áñéèìüò áðü ôï óùñü"
End Sub
Public Sub MissMic()
MyEr "No mic found", "Äåí âñÞêá åßóïäï ç÷ïãñÜöçóçò"
End Sub
Public Sub missNumber()
MyEr "Only number allowed", "Ìüíï áñéèìüò åðéôñÝðåôáé"
End Sub
Public Sub MissLogicalExpr()
MyEr "Missing logical expression", "Ëåßðåé ëïãéêÞ ðáñÜóôáóç"
End Sub
Public Sub MissNumExpr()
MyEr "Missing number expression", "Ëåßðåé áñéèìçôéêÞ ðáñÜóôáóç"
End Sub
Public Sub MissLicense()
MyEr "Missing License", "Ëåßðåé ¢äåéá"
End Sub
Public Sub MissStringExpr()
MyEr "Missing string expression", "Ëåßðåé áëöáñéèìçôéêÞ ðáñÜóôáóç"
End Sub
Public Sub MissString()
MyEr "Missing string", "Ëåßðåé áëöáñéèìçôéêü"
End Sub
Public Sub MissStringNumber()
MyEr "Missing string or number", "Ëåßðåé áëöáñéèìçôéêü Þ áñéèìüò"
End Sub

Public Sub NoCreateFile()
    MyEr "Can't create file", "Äåí ìðïñþ íá öôéÜîù áñ÷åßï"
End Sub
Public Sub BadFilename()
MyEr "Bad filename", "ËÜèïò óôï üíïìá áñ÷åßïõ"
End Sub
Public Sub ReadOnly()
MyEr "Read Only", "Ìüíï ãéá áíÜãíùóç"
End Sub
Public Sub MissDir()
MyEr "Missing directory name", "Ëåßðåé üíïìá öáêÝëïõ"
End Sub
Public Sub MissType()
MyEr "Wrong data type", "¢ëëïò ôýðïò ìåôáâëçôÞò"
End Sub
Public Sub UknownType(t$)
MyEr "Uknown data type " + t$, "¢ãíùóôïò ôýðïò ìåôáâëçôÞò" + t$
End Sub
Public Sub badsupport()
MyEr "object not supported", "Ôï áíôéêåßìåíï äåí õðïóôçñßæåôáé"
End Sub
Public Sub conflictname()
MyEr "Name conflict with Inventory object", "ÕðÜñ÷åé ôÝôïéï üíïìá óå ÷ñÞóç óå ÊáôÜóôáóç"
End Sub
Public Sub MissArrayName()
MyEr "Missing array name", "Ëåßðåé üíïìá ðßíáêá"
End Sub
Public Sub BadPath()
MyEr "Bad Path name", "ËÜèïò óôï üíïìá öáêÝëïõ (ôüðï)"
End Sub
Public Sub BadReBound()
MyEr "Can't commit a reference here", "Äåí ìðïñþ íá áíáèÝóù åäþ ìéá áíáöïñÜ"
End Sub
Public Sub oxiforPrinter()
MyEr "Not allowed this command for printer", "Äåí åðéôñÝðåôáé áõôÞ ç åíôïëÞ ãéá ôïí åêôõðùôÞ"
End Sub
Public Sub ResourceLimit()
MyEr "No more Graphic Resource - 1000 Max", "Äåí Ý÷ù Üëëï ÷þñï ãéá ãñáöéêÜ - 1000 Ìåãéóôï"
End Sub
Public Sub oxiforforms()
MyEr "Not allowed this command for forms", "Äåí åðéôñÝðåôáé áõôÞ ç åíôïëÞ ãéá öüñìåò"
End Sub
Public Sub oxiforImages()
MyEr "Not allowed this command for Images", "Äåí åðéôñÝðåôáé áõôÞ ç åíôïëÞ ãéá Åéêüíåò"
End Sub
Public Sub oxiforMetaFiles()
MyEr "Not allowed this command for drawings", "Äåí åðéôñÝðåôáé áõôÞ ç åíôïëÞ ãéá ó÷Ýäéá"
End Sub
Public Sub BadUDTName()
MyEr "Bad field name for UDT type", "ËÜèïò óôï üíïìá ðåäßï óýíèåôçò ìåôáâëçôÞò UDT"
End Sub
Public Sub SyntaxError()
If LastErName = vbNullString Then
MyEr "Syntax Error", "Óõíôáêôéêü ËÜèïò"
Else
If LastErNum = 0 Then LastErNum = -1 ' general
LastErNum1 = LastErNum
End If
End Sub
Public Sub MissingnumVar()
MyEr "missing numeric variable", "ëåßðåé áñéèìçôéêÞ ìåôáâëçôÞ"
End Sub
Public Sub BadGraphic()
MyEr "Can't operate graphic", "äåí ìðïñþ íá ÷åéñéóôþ ôï ãñáöéêü"
End Sub
Public Sub SelectorInUse()
MyEr "File/Folder Selector in Use", "Ç öüñìá åðéëïãÞò áñ÷åßùí/öáêÝëùí åßíáé óå ÷ñÞóç"
End Sub
Public Sub MissingDoc()  ' this is for identifier or execute part
MyEr "missing document type variable", "ëåßðåé ìåôáâëçôÞ ôýðïõ åããñÜöïõ"
End Sub
Public Sub MissingDocOrArrayOrInventory()  ' this is for identifier or execute part
MyEr "missing document or Array or Inventory type ", "ëåßðåé ôýðïò Ýããñáöï Þ ðßíáêá Þ êáôÜóôáóç"
End Sub
Public Sub UpperArrayLimit()
MyEr "Reach array upper limit", "¸öèáóá óôï Üíù üñéï ôïõ ðßíáêá"
End Sub

Public Sub MissingArrayOrInventory()  ' this is for identifier or execute part
MyEr "missing Array or Inventory type ", "ëåßðåé ôýðïò ðßíáêá Þ êáôÜóôáóç"
End Sub
Public Sub MissingLabel()
MyEr "Missing label/Number line", "Ëåßðåé ÅôéêÝôá/Áñéèìüò ãñáììÞò"
End Sub
Public Sub MissFuncParammeterdOCVar(Ar$)
MyEr "Not a Document variable " + Ar$, "Äåí åßíáé ìåôáâëçôÞ ôýðïõ åããñÜöïõ " + Ar$
End Sub
Public Sub MissingBlock()  ' this is for identifier or execute part
MyEr "missing block {} or string expression", "ëåßðåé êþäéêáò óå {} ç áëöáñéèìçôéêÞ Ýêöñáóç"
End Sub
Public Sub MissingBlockCode()
MyEr "missing block {}", "ëåßðåé êþäéêáò óå ìðëïê {}"
End Sub
Public Sub OnlyOneLineAllowed()
MyEr "Use block {} in starting line only", "×ñçóéìïðïßçóå ìðëïê {} óôçí áñ÷éêÞ ãñáììÞ"
End Sub
Public Function CheckBlock(once As Boolean) As Long
    If once Then
        OnlyOneLineAllowed
    Else
        MissingBlockCode
    End If
End Function

Public Sub MissingEnumBlock()
MyEr "missing block {} for enumeration constants", "ëåßðåé ìðëïê {} ãéá óôáèåñÝò áðáñßèìçóçò "
End Sub
Public Sub MissingCodeBlock()
MyEr "missing block {}", "ëåßðåé ìðëïê êþäéêá óå {}"
End Sub
Public Sub MissingArray(Optional W$)
If W$ = "" Then
MyEr "No array found", "Äåí âñÞêá ðßíáêá"
Else
MyEr "Can't find array " + W$ + ")", "Äåí âñßóêù ðßíáêá " + W$ + ")"
End If
End Sub
Public Sub ErrNum()
MyEr "Error in number", "ËÜèïò óôïí áñéèìü"
End Sub
Public Sub CantAssignValue()
MyEr "Can't assign value to constant", "Äåí ìðïñþ íá âÜëù ôéìÞ óå óôáèåñÜ"
End Sub
Public Sub ExpectedEnumType()
 MyEr "Expected Enumeration Type", "Ðåñßìåíá ôýðï áðáñßèìçóçò"
End Sub

Public Sub ExpectedVariable()
 MyEr "Expected variable", "Ðåñßìåíá ìåôáâëçôÞ"
End Sub
Public Sub Expected(w1$, w2$)
 MyEr "Expected object type " + w1$, "Ðåñßìåíá áíôéêåßìåíï ôýðïõ " + w2$
End Sub
Public Sub ExpectedCaseorElseorEnd2()
MyEr "Expected Case or Else or End Select", "Ðåñßìåíá Ìå Þ Áëëéþò Þ ÔÝëïò ÅðéëïãÞò"
End Sub
Public Sub ExpectedCaseorElseorEnd()
 MyEr "Expected Case or Else or End Select, for two or more commands use {}", "Ðåñßìåíá Ìå Þ Áëëéþò Þ ÔÝëïò ÅðéëïãÞò, ãéá äõï Þ ðåñéóóüôåñåò åíôïëÝò ÷ñçóéìïðïßçóå { }"
End Sub
Public Sub ExpectedCommentsOnly()
 MyEr "Expected comments (using ' or \) or new line", "Ðåñßìåíá óçìåéþóåéò (ìå ' Þ \) Þ áëëáãÞ ãñáìÞò"
End Sub

Public Sub ExpectedEndSelect()
 MyEr "Expected Ånd Select", "Ðåñßìåíá ÔÝëïò ÅðéëïãÞò"
End Sub
Public Sub ExpectedEndSelect2()
 MyEr "Expected Ånd Select, for two or more commands use {}", "Ðåñßìåíá ÔÝëïò ÅðéëïãÞò, ãéá äõï Þ ðåñéóóüôåñåò åíôïëÝò ÷ñçóéìïðïßçóå { }"
End Sub
Public Sub LocalAndGlobal()
MyEr "Global and local together;", "ÃåíéêÞ êáé ôïðéêÞ ìáæß!"
End Sub
Public Sub UnknownProperty(W$)
MyEr "Unknown Property " + W$, "¢ãíùóôç éäéüôçôá " + W$
End Sub
Public Sub UnknownVariable(v$)
Dim I As Long
I = rinstr(v$, "." + ChrW(8191))
If I > 0 Then
    I = rinstr(v$, ".")
    MyEr "Unknown Variable " + Mid$(v$, I), "¢ãíùóôç ìåôáâëçôÞ " + Mid$(v$, I)
Else
    I = rinstr(v$, "».")
    If I > 0 Then
        MyEr "Unknown Variable " + Mid$(v$, I + 2), "¢ãíùóôç ìåôáâëçôÞ " + Mid$(v$, I + 2)
    Else
        I = rinstr(v$, ChrW(8191))
    If I > 0 Then
        I = InStr(I + 1, v$, ".")
        If I > 0 Then
            MyEr "Unknown Variable " + Mid$(v$, I + 1), "¢ãíùóôç ìåôáâëçôÞ " + Mid$(v$, I + 1)
        Else
            MyEr "Unknown Variable", "¢ãíùóôç ìåôáâëçôÞ"
        End If
    Else
        MyEr "Unknown Variable " + v$, "¢ãíùóôç ìåôáâëçôÞ " + v$
    End If
    End If
End If
End Sub
Sub indexout(A$)
MyErMacro A$, "Index out of limits", "Äåßêôçò åêôüò ïñßùí"
End Sub

Sub wrongfilenumber(A$)
 MyErMacro A$, "not valid file number", "ëÜèïò áñéèìüò áñ÷åßïõ"
End Sub
Public Sub WrongArgument(A$)
MyErMacro A$, Err.Description, "ËÜèïò üñéóìá"
End Sub
Public Sub UnKnownWeak(W$)
 MyEr "Unknown Weak " + W$, "¢ãíùóôç éó÷íÞ " + W$
End Sub
Sub NegativeIndex(A$)
MyErMacro A$, "negative index", "áñíçôéêüò äåßêôçò"
End Sub
Sub NegativeIndex1()
MyEr "negative index", "áñíçôéêüò äåßêôçò"
End Sub
Sub joypader(A$, r)
MyErMacro A$, "Joypad number " + CStr(r) + " isn't ready", "Ôï íïýìåñï ËáâÞò " + CStr(r) + " äåí åßíáé Ýôïéìï"
End Sub
Sub noImage(A$)
MyErMacro A$, "Íï image in string", "Äåí õðÜñ÷åé åéêüíá óôï áëöáñéèìçôéêü"
End Sub
Sub noImageInBuffer(A$)
MyErMacro A$, "No Image in Buffer", "Äåí Ý÷åé åéêüíá ç ÄéÜñèñùóç"
End Sub

Sub WrongJoypadNumber(A$)
MyErMacro A$, "Joypad number 0 to 15", "Áñéèìüò ËáâÞò áðü 0 Ýùò 15"
End Sub
Sub CantFindArray(A$, s$)
MyErMacro A$, "Can't find array " + s$, "Äåí âñßóêù ðßíáêá " + s$
End Sub
Sub CantReadDimension(A$, s$)
 MyErMacro A$, "Can't read dimension index from array " + s$, "Äåí ìðïñþ íá äéáâÜóù ôïí äåßêôç äéÜóôáóçò ôïõ ðßíáêá " + s$

End Sub
Sub cantreadlib(A$)
MyErMacro A$, "Can't Read TypeLib", "Äåí ìðïñþ íá äéáâÜóù ôïõò ôýðïõò ôùí ðáñáìÝôñùí"
End Sub
Public Sub NotForArray()
MyEr "not for array items", "ü÷é ãéá óôïé÷åßá ðßíáêá"
End Sub
Public Sub NotForArrayBrackets()
MyEr "not for array using []", "ü÷é ãéá ðßíáêá ìå []"
End Sub

Public Sub NotArray()  ' this is for identifier or execute part
MyEr "Expected Array", "Ðåñßìåíá ðßíáêá"
End Sub
Public Sub NotExistArray()  ' this is for identifier or execute part
MyEr "Array not exist", "Äåí õðÜñ÷åé ôÝôïéïò ðßíáêáò"
End Sub
Public Sub MissingGroup()  ' this is for identifier or execute part
MyEr "missing group type variable", "ëåßðåé ìåôáâëçôÞ ôýðïõ ïìÜäáò"
End Sub
Public Sub MissingGroupExp()  ' this is for identifier or execute part
MyEr "missing group type expression", "ëåßðåé Ýêöñáóç ôýðïõ ïìÜäáò"
End Sub
Public Sub BadGroupHandle()  ' this is for identifier or execute part
MyEr "group isn't variable", "ç ïìÜäá äåí åßíáé ìåôáâëçôÞ"
End Sub
Public Sub FoundLogicalExpr()
    MyEr "Found logical expression", "ÂñÞêá ëïãéêÞ Ýêöñáóç"
End Sub

Public Sub BadEvents()
MyEr "Can't handle events here", "Äåí ìðïñþ íá ÷åéñéóôþ ãåãïíüôá"
End Sub
Public Sub BadDim()
MyEr "Array dimensions missing", "Ï ðßíáêáò äåí Ý÷åé äéáóôÜóåéò"
End Sub
Public Sub badread()
MyEr "can't read value", "äåí ìðïñþ íá äéáâÜóù ôéìÞ"
End Sub
Public Sub ArrayNameExist()
MyEr "Array exist", "ÕðÜñ÷åé Þäç áõôüò ï ðßíáêáò"
End Sub
Public Sub MissingDocRef()  ' this is for identifier or execute part
MyEr "invalid document pointer", "ìç Ýãêõñïò äåßêôçò åããñÜöïõ"
End Sub
Public Sub NoNewLambda()
    MyEr "No New statement for lambda", "¼÷é äÞëùóç íÝïõ ãéá ëáìäá"
End Sub
Public Sub ExpectedObj(nn$)
MyEr "Expected object type " + nn$, "Ðåñßìåíá áíôéêåßìåíï ôýðïõ " + nn$
End Sub
Public Sub MissOperator(ss$)
MyEr "Group not support operator " + ss$, "Ç ïìÜäá äåí õðïóôçñßæåé ôï ôåëåóôÞ " + ss$
End Sub
Sub MissObject(A$)
    MyErMacro A$, "No Object found", "Äåí âñÞêá áíôéêåßìåíï"
End Sub
Public Sub CantReadFileTimeStap(A$)
MyErMacro A$, "Can't Read File TimeStamp", "Äåí ìðïñþ íá äéáâÜóù ôçí ×ñïíïóÞìáíóç ôïõ áñ÷åßïõ"
End Sub

Public Sub ExpectedObjInline(nn$)
MyErMacro nn$, "Expected Object", "Ðåñßìåíá áíôéêåßìåíï"
End Sub
Public Sub MissingObj()
MyEr "missing object type variable", "ëåßðåé ìåôáâëçôÞ ôýðïõ áíôéêåéìÝíïõ"
End Sub
Public Sub BadGetProp()
MyEr "Can't Get Property", "Äåí ìðïñþ íá äéáâÜóù áõôÞ ôçí éäéüôçôá"
End Sub
Public Sub BadLetProp()
MyEr "Can't Let Property", "Äåí ìðïñþ íá ãñÜøù áõôÞ ôçí éäéüôçôá"
End Sub
Public Sub NoNumberAssign()
MyEr "Can't assign number to object", "Äåí ìðïñþ íá äþóù áñéèìü óôï áíôéêåßìåíï"
End Sub
Public Sub NoAssignThere()
MyEr "Use Return Object to change items", "×ñçóéìïðïßçóå ôçí ÅðéóôñïöÞ áíôéêåßìåíï ãéá íá åðéóôñÝøåéò ôéìÝò"
End Sub
Public Sub NoObjectpAssignTolong()
MyEr "Can't assign object to long", "Äåí ìðïñþ íá äþóù áíôéêåßìåíï óôïí ìáêñõ"
End Sub
Public Sub NoObjectpAssignToInteger()
MyEr "Can't assign object to Integer", "Äåí ìðïñþ íá äþóù áíôéêåßìåíï óôïí áêÝñáéï"
End Sub
Public Sub NoObjectAssign()
MyEr "Can't assign object", "Äåí ìðïñþ íá äþóù áíôéêåßìåíï"
End Sub
Public Sub NoNewStatFor(w1$, w2$)
MyEr "No New statement for " + w1$, "¼÷é äÞëùóç íÝïõ ãéá " + w2$
End Sub
Public Sub NoThatOperator(ss$)
    MyEr ss$ + " operator not allowed in group definition", " Ï ôåëåóôÞò " + ss$ + " äåí åðéôñåðåôáé óå ïñéóìü ïìÜäáò"
End Sub
Public Sub MissingObjRef()
MyEr "invalid object pointer", "ìç Ýãêõñïò äåßêôçò áíôéêåéìÝíïõ"
End Sub
Public Sub MissingStrVar()  ' this is for identifier or execute part
MyEr "missing string variable", "ëåßðåé áëöáñéèìçôéêÞ ìåôáâëçôÞ"
End Sub
Public Sub NoSwap(nameOfvar$)
MyEr "Can't swap ", "Äåí ìðïñþ íá áëëÜîù ôéìÝò "
End Sub
Public Sub Nosuchvariable(nameOfvar$)
MyEr "No such variable " + nameOfvar$, "äåí õðÜñ÷åé ôÝôïéá ìåôáâëçôÞ " + nameOfvar$
End Sub
Public Sub NoValueForVar(W$)
If LastErNum = 0 Then
MyEr "No value for variable " + W$, "×ùñßò ôéìÞ ç ìåôáâëçôÞ " + W$
End If
End Sub
Public Sub NoReference()
   MyEr "No reference exist", "Äåí õðÜñ÷åé áíáöïñÜ"
End Sub
Public Sub NoCommandOrBlock()
MyEr "Expected in Select Case a Block or a Command", "Ðåñßìåíá óôçí Åðßëåîå Ìå ìéá åíôïëÞ Þ Ýíá ìðëïê åíôïëþí)"
End Sub

Public Sub NoSecReF()
MyEr "No reference allowed - use new variable", "Äåí äÝ÷åôáé áíáöïñÜ - ÷ñçóéìïðïßçóå íÝá ìåôáâëçôÞ"
End Sub

Public Sub MissTHENELSE()
    MyEr "missing THEN or ELSE", "äåí âñÞêá ÔÏÔÅ Þ ÁËËÉÙÓ"
End Sub

Public Sub MissENDIF()
    MyEr "missing END IF", "äåí âñÞêá ÔÅËÏÓ ÁÍ"
End Sub
Public Sub MissIF()
    MyEr "No IF for END IF", "äåí âñÞêá ÁÍ ãéá ôçí ÔÅËÏÓ ÁÍ"
End Sub

Public Sub badSubNotFound()
MyEr "sub not found", "äåí âñÝèçêå ç ñïõôßíá"
End Sub
Public Sub BadSignHex()
    MyEr "no sign for hex values", "ü÷é ðñüóçìï ãéá äåêáåîáäéêïýò"
End Sub
Public Sub BadLitHex()
    MyEr "invalid hex values", "ëÜèïò üñéóìá ãéá äåêáåîáäéêü"
End Sub
Public Sub BadCommand()
    MyEr "Command for supervisor rights", "ÅíôïëÞ ìüíï ãéá åðüðôç"
End Sub

Public Sub NoClauseInThread()
    MyEr "can't find ERASE or HOLD or RESTART or INTERVAL clause", "Äåí ìðïñþ íá âñù üñï üðùò ôï ÓÂÇÓÅ Þ ôï ÊÑÁÔÁ Þ ôï ÎÅÊÉÍÁ Þ ôï ÊÁÈÅ"
End Sub
Public Sub NoThisInThread()
MyEr "Clause This can't used outside a thread", "Ï üñïò ÁÕÔÏ äåí ìðïñåß íá ÷ñçóéìïðïéçèåß Ýîù áðü Ýíá íÞìá"
End Sub
Public Sub NoObjectFound()
MyEr "No Object found", "Äåí âñÞêá áíôéêåßìåíï"
End Sub
Public Sub MisGosub()
MyEr "Expected clause Gosub or Goto", "Ðåñßìåíá üñéóìá ÄéáìÝóïõ Þ Ðñïò"
End Sub
Public Sub MissClause(A$, b$)
MyEr "Expected clause " + A$, "Ðåñßìåíá üñéóìá " + b$
End Sub
Public Sub MisInterval()
MyEr "Expected number for interval, miliseconds", "Ðåñßìåíá áñéèìü ãéá ïñéóìü ôáêôéêïý äéáóôÞìáôïò åêêßíçóçò íÞìáôïò (÷ñüíï óå ÷éëéïóôÜ äåõôåñïëÝðôïõ)"
End Sub
Public Sub MisEndFunc()
MyEr "Expected End Function", "Ðåñßìåíá ÔÝëïò ÓõíÜñôçóçò"
End Sub
Public Sub MisEndSub()
MyEr "Expected End Sub", "Ðåñßìåíá ÔÝëïò Ñïõôßíáò"
End Sub
Public Sub NoRef2()
MyEr "No with reference in left side of assignment", "¼÷é ìå áíáöïñÜ óôçí åê÷þñçóç ôéìÞò"
End Sub
Public Sub WrongObject()
MyEr "Wrong object type", "ëÜèïò ôýðïò áíôéêåéìÝíïõ"
End Sub
Public Sub NullObject()
MyEr "object type is Nothing", "O ôýðïò áíôéêåéìÝíïõ åßíáé Ôßðïôá"
End Sub
Public Sub WrongType()
MyEr "Wrong type", "ëÜèïò ôýðïò"
End Sub
Public Sub WrongItemType()
    MyEr "Wrong Array item type", "ëÜèïò ôýðïò óôïé÷åßïõ ðßíáêá"
End Sub
Public Sub GroupWrongUse()
MyEr "Something wrong with group", "ÊÜôé ðÜåé óôñáâÜ ìå ôçí ïìÜäá"
End Sub
Public Sub GroupCantSetValue()
    MyEr "Group can't set value", "Ç ïìÜäá äåí ìðïñåß íá èÝóåé ôéìÞ"
End Sub
Public Sub PropCantChange()
MyEr "Property can't change", "Ç éäéüôçôá äåí ìðïñåß íá áëëÜîåé"
End Sub
Public Sub noType(C$)
MyEr "missing type " + C$, "äåí âñçêá ôýðï " + C$
End Sub

Public Sub MissingSymbol(C$)
MissSymbol C$
End Sub
Public Sub NeedAGroupFromExpression()
MyEr "Need a group from expression", "×ñåéÜæïìáé ìéá ïìÜäá áðü ôçí Ýêöñáóç"
End Sub
Public Sub NeedAGroupInRightExpression()
MyEr "Need a group from right expression", "×ñåéÜæïìáé ìéá ïìÜäá áðü ôçí äåîéÜ Ýêöñáóç"
End Sub
Public Sub NotAfter(A$)
MyErMacro A$, "not an expression after not operator", "äåí õðÜñ÷åé ðáñÜóôáóç äåîéÜ ôïý ôåëåóôÞ ü÷é"
End Sub
Public Sub mEmptyArray()
MyEr "Empty Array", "¢äåéïò Ðßíáêáò"
End Sub
Public Sub EmptyStack(A$)
 MyErMacro A$, "Stack is empty", "O óùñüò åßíáé Üäåéïò"
End Sub
Public Sub StackTopNotArray(A$)
 MyErMacro A$, "Stack top isn't array", "Ç êïñõöÞ ôïõ óùñïý äåí åßíáé ðßíáêáò"
End Sub

Public Sub StackTopNotGroup(A$)
MyErMacro A$, "Stack top isn't group", "Ç êïñõöÞ ôïõ óùñïý äåí åßíáé ïìÜäá"
End Sub
Public Sub StackTopNotNumber(A$)
MyErMacro A$, "Stack top isn't number", "Ç êïñõöÞ ôïõ óùñïý äåí åßíáé áñéèìüò"
End Sub
Public Sub NeedAnArray1()
NeedAnArray1
End Sub
Public Sub NeedAnArray(A$)
MyErMacro A$, "Need an Array", "×ñåéÜæïìáé Ýíá ðßíáêá"
End Sub
Public Sub noref()
MyEr "No with reference (&)", "¼÷é ìå áíáöïñÜ (&)"
End Sub
Public Sub NoMoreDeep(deep As Variant)
MyEr "No more" + str(deep) + " levels gosub allowed", "Äåí åðéôñÝðïíôáé ðÜíù áðü" + str(deep) + " åðßðåäá ãéá åíôïëÞ ÄÉÁÌÅÓÏÕ"
End Sub
Public Sub CantFind(W$)
MyEr "Can't find " + W$ + " or type name", "Äåí ìðïñþ íá âñù ôï " + W$ + " Þ üíïìá ôýðïõ"
End Sub
Public Sub OverflowValue(Optional b As Integer = False)
If b = vbInteger Then
    MyEr "Overflow Integer", "Õðåñ÷åßëéóç áêåñáßïõ"
ElseIf b = vbLong Then
    MyEr "Overflow Long", "Õðåñ÷åßëéóç ìáêñý"
ElseIf b = vbCurrency Then
    MyEr "Overflow Currency", "Õðåñ÷åßëéóç ëïãéóôéêïý"
ElseIf b = vbSingle Then
    MyEr "Overflow Single", "Õðåñ÷åßëéóç áðëïý"
ElseIf b = vbDecimal Then
    MyEr "Overflow Decimal", "Õðåñ÷åßëéóç áñéèìïý"
ElseIf b = vbDouble Then
    MyEr "Overflow Double", "Õðåñ÷åßëéóç äéðëïý"
ElseIf b = 20 Then
    MyEr "Overflow Long Long", "Õðåñ÷åßëéóç ìáêñý ìáêñý"
ElseIf b = 100 Then
    MyEr "Overflow Exponet", "Õðåñ÷åßëéóç åêèÝôç"
ElseIf b = 101 Then
    MyEr "Negative Exponet", "Áñíçôéêüò åêèÝôçò"
ElseIf b = vbByte Then
    MyEr "Overflow Byte", "Õðåñ÷åßëéóç Øçöåßïõ"
Else  ' 20
    MyEr "Overflow", "Õðåñ÷åßëéóç"
End If
End Sub
Public Sub BadUseofReturn()
MyEr "Wrong Use of Return", "ÊáêÞ ÷ñÞóç ôçò åðéóôñïöÞò"
End Sub
Public Sub DevZero()
    MyEr "division by zero", "äéáßñåóç ìå ôï ìçäÝí"
End Sub
Public Sub DevZeroMacro(aa$)
    MyErMacro aa$, "division by zero", "äéáßñåóç ìå ôï ìçäÝí"
End Sub
Public Sub ErrInExponet(A$)
MyErMacro A$, "Error in exponet", "ËÜèïò óôïí åêèÝôç"
End Sub

Public Sub LambdaOnly(A$)
MyErMacro A$, "Only in lambda function", "Ìüíï óå ëÜìäá óõíÜñôçóç"
End Sub
Public Sub FilePathNotForUser()
MyEr "Filepath is not valid for user", "Ï ôüðïò ôïõ áñ÷åßïõ äåí åßíáé Ýãêõñïò ãéá ôïí ÷ñÞóôç"
End Sub

' used to isnumber
Public Sub MyErMacro(wher$, en$, gr$)
If stackshowonly Then
LastErNum = -2
wher$ = " : ERROR -2" + Sput(en$) + Sput(gr$) + wher$
Else
If Left$(en$, 1) = Chr$(0) Then en$ = Mid$(en$, 2)
If Left$(gr$, 1) = Chr$(0) Then gr$ = Mid$(gr$, 2)
MyEr en$, gr$
End If
End Sub
Public Sub MyErMacroStr(wher$, en$, gr$)
If stackshowonly Then
LastErNum = -2
wher$ = " : ERROR -2" + Sput(en$) + Sput(gr$) + wher$
Else
MyEr en$, gr$
End If
End Sub
Public Sub ZeroParam(Ar$)   ' we use MyErMacro in isNumber and isString
MyErMacro Ar$, "Empty parameter", "ÌçäåíéêÞ ðáñÜìåôñïò"
End Sub
Public Sub MissPar()
MyEr "missing parameter", "ëåßðåé ðáñÜìåôñïò"
End Sub
Public Sub MissModuleName()
MyEr "Missing module name", "Ëåßðåé üíïìá ôìÞìáôïò"
End Sub
Public Sub nonext()
MyEr "NEXT without FOR", "ÅÐÏÌÅÍÏ ÷ùñßò ÃÉÁ"
End Sub
Public Sub MissWhile()
MyEr "Missing the End While", "¸÷áóá ôï ÔÝëïò Åíþ"
End Sub

Public Sub MissUntil()
MyEr "Missing the Until or Always", "¸÷áóá ôï ÌÝ÷ñé Þ ôï ÐÜíôá"
End Sub

Public Sub MissNext()
MyEr "Missing the right NEXT", "¸÷áóá ôï óùóôü ÅÐÏÌÅÍÏ"
End Sub
Public Sub MissVarName()
MyEr "Missing variable name", "Ëåßðåé üíïìá ìåôáâëçôÞò"
End Sub
Public Sub MissParamref(Ar$)
MyErMacro Ar$, "missing by reference parameter", "ëåßðåé ìå áíáöïñÜ ðáñÜìåôñïò"
End Sub
Public Sub MissParam(Ar$)
MyErMacro Ar$, "missing parameter", "ëåßðåé ðáñÜìåôñïò"
End Sub
Public Sub MissFuncParameterStringVar()
MyEr "Not a string variable", "Äåí åßíáé áëöáñéèìçôéêÞ ìåôáâëçôÞ"
End Sub
Public Sub MissFuncParameterStringVarMacro(Ar$)
MyErMacro Ar$, "Not a string variable", "Äåí åßíáé áëöáñéèìçôéêÞ ìåôáâëçôÞ"
End Sub
Public Sub NoSuchFolder()
MyEr "No such folder", "Äåí õðÜñ÷åé ôÝôïéïò öÜêåëïò"
End Sub
Public Sub MissSymbol(wht$)
MyEr "missing " + wht$, "ëåßðåé " + wht$
End Sub
Public Sub ClearSpace(nm$)
Dim I As Long
Do
    I = 1
    If FastOperator(nm$, vbCrLf, I, 2, False) Then
        SetNextLine nm$
    ElseIf FastOperator(nm$, "/", I) Then
        SetNextLine nm$
    ElseIf FastOperator(nm$, "\", I) Then
        SetNextLine nm$
    ElseIf FastOperator(nm$, "'", I) Then
        SetNextLine nm$
    Else
    Exit Do
    End If
Loop
End Sub
Public Function StringToEscapeStr(RHS As String, Optional Json As Boolean = False) As String
Dim I As Long, cursor As Long, ch As String
cursor = 0
Dim del As String
Dim H9F As String
For I = 1 To Len(RHS)
                ch = Mid$(RHS, I, 1)
                cursor = cursor + 1
                Select Case AscW(ch)
                    Case 92:        ch = "\\"
                   ' Case """":       ch = "\"""
                    Case 34
                    If Json Then
                        ch = "\"""
                    Else
                        ch = "\u0022"
                    End If
                    Case 10:       ch = "\n"
                    Case 13:       ch = "\r"
                    Case 9:      ch = "\t"
                    Case 8:     ch = "\b"
                    Case 12: ch = "\f"
                    Case 0 To 31, 127 To &H9F
                        ch = "\u" + Right$("000" + Hex$(AscW(ch)), 4)
                    Case Is > 255
                       If Json Then ch = "\u" + Right$("000" + Hex$(AscW(ch)), 4)
                End Select
                If cursor + Len(ch) > Len(StringToEscapeStr) Then StringToEscapeStr = StringToEscapeStr + space$(500)
                Mid$(StringToEscapeStr, cursor, Len(ch)) = ch
                cursor = cursor + Len(ch) - 1
Next
If cursor > 0 Then StringToEscapeStr = Left$(StringToEscapeStr, cursor)

End Function
Public Function EscapeStrToString(RHS As String) As String
Dim I As Long, cursor As Long, ch As String
     For cursor = 1 To Len(RHS)
        ch = Mid$(RHS, cursor, 1)
        I = I + 1
        Select Case ch
            Case """": GoTo ok1
            Case "\":
                cursor = cursor + 1
                ch = Mid$(RHS, cursor, 1)
                Select Case LCase$(ch) 'We'll make this forgiving though lowercase is proper.
                    Case "\", "/": ch = ch
                    Case """":      ch = """"
                    Case "a":       ch = Chr$(7)
                    Case "n":      ch = vbLf
                    Case "r":      ch = vbCr
                    Case "t":      ch = vbTab
                    Case "b":      ch = vbBack
                    Case "f":      ch = vbFormFeed
                    Case "u":      ch = ParseHexChar(RHS, cursor, Len(RHS))
                End Select
        End Select
                If I + Len(ch) > Len(EscapeStrToString) Then EscapeStrToString = EscapeStrToString + space$(500)
                Mid$(EscapeStrToString, I, Len(ch)) = ch
                I = I + Len(ch) - 1
    Next
ok1:
    If I > 0 Then EscapeStrToString = Left$(EscapeStrToString, I)
End Function

Private Function ParseHexChar( _
    ByRef Text As String, _
    ByRef cursor As Long, _
    ByVal LenOfText As Long) As String
    
    Const ASCW_OF_ZERO As Long = &H30&
    Dim Length As Long
    Dim ch As String
    Dim DigitValue As Long
    Dim Value As Long

    For cursor = cursor + 1 To LenOfText
        ch = Mid$(Text, cursor, 1)
        Select Case ch
            Case "0" To "9", "A" To "F", "a" To "f"
                Length = Length + 1
                If Length > 4 Then Exit For
                If ch > "9" Then
                    DigitValue = (AscW(ch) And &HF&) + 9
                Else
                    DigitValue = AscW(ch) - ASCW_OF_ZERO
                End If
                Value = Value * &H10& + DigitValue
            Case Else
                Exit For
        End Select
    Next
    If Length = 0 Then Err.Raise 5 'No hex digits at all.
    cursor = cursor - 1
    ParseHexChar = ChrW$(Value)
End Function

Public Function ReplaceSpace(A$) As String
Dim I As Long, j As Long
I = 1
Do
I = InStr(I, A$, "[")
If I > 0 Then
    I = I + 1
    j = InStr(I, A$, "]")
    If j > 0 Then
    j = j - I
    Mid$(A$, I, j) = Replace(Mid$(A$, I, j), " ", ChrW(160))
    I = I + j
    End If
Else
    Exit Do
End If
Loop
ReplaceSpace = A$
End Function
Function GetReturnArray(bstack As basetask, x1 As Long, b$, p As Variant, ss$, pppp As mArray) As Boolean ' true is error

Do
        Set bstack.lastobj = Nothing
        If IsExp(bstack, b$, p) Then
        If x1 = 0 Then If lookOne(b$, ",") Then x1 = 1: Set pppp = New mArray: pppp.PushDim (1): pppp.PushEnd
        If x1 = 0 Then
                    If Not myVarType(p, vbString) Then
                        If Len(bstack.originalname$) > 3 Then
                            If Mid$(bstack.originalname$, Len(bstack.originalname$) - 2, 1) = "$" Then
                                MissStringExpr
                                Exit Do
                            End If
                        End If
                    End If
                 If Right$(bstack.originalname$, 3) = "%()" Then p = MyRound(p)
                 Set bstack.FuncObj = bstack.lastobj
                 Set bstack.lastobj = Nothing
                 bstack.FuncValue = p
        Else
                pppp.SerialItem 0, x1 + 1, 9
                If bstack.lastobj Is Nothing Then
                    pppp.item(x1 - 1) = p
                Else
                    Set pppp.item(x1 - 1) = bstack.lastobj
                    Set bstack.lastobj = Nothing
                End If
                bstack.FuncValue = p
                x1 = x1 + 1
                             
        End If
        ElseIf Not bstack.lastobj Is Nothing Then
cont1:
        If x1 = 0 Then If lookOne(b$, ",") Then x1 = 1: Set pppp = New mArray: pppp.PushDim (1): pppp.PushEnd
        If x1 = 0 Then
            Set bstack.FuncObj = bstack.lastobj
            Set bstack.lastobj = Nothing
            bstack.FuncValue = vbNullString
        Else
                pppp.SerialItem 0, x1 + 1, 9
                If bstack.lastobj Is Nothing Then
                    pppp.item(x1 - 1) = p
                Else
                    Set pppp.item(x1 - 1) = bstack.lastobj
                    Set bstack.lastobj = Nothing
                End If
                bstack.FuncValue = p
                x1 = x1 + 1
        End If
        ElseIf IsStrExp(bstack, b$, ss$, False) Then  ' Len(bstack.tmpstr) = 0
            If x1 = 0 Then If lookOne(b$, ",") Then x1 = 1: Set pppp = New mArray: pppp.PushDim (1): pppp.PushEnd
            If x1 = 0 Then
              '  If Len(bstack.originalname$) > 3 Then
                  '  If Mid$(bstack.originalname$, Len(bstack.originalname$) - 2, 1) <> "$" Then
                  '   If Right$(bstack.originalname$, 1) = "]" Then
                   '  If InStr(bstack.originalname, "$()") > 0 Then GoTo cont4567
                    ' End If
                    
misum: '                     MissNumExpr
      '                   GetReturnArray = True
     '                    Exit Function
        '            End If
   '             Else
 ''                   GoTo misum
    '            End If
'cont4567:
                Set bstack.FuncObj = bstack.lastobj
                Set bstack.lastobj = Nothing
                bstack.FuncValue = ss$
            Else
                pppp.SerialItem 0, x1 + 1, 9
                If bstack.lastobj Is Nothing Then
                    pppp.item(x1 - 1) = ss$
                Else
                    Set pppp.item(x1 - 1) = bstack.lastobj
                    Set bstack.lastobj = Nothing
                End If
                x1 = x1 + 1
                bstack.FuncValue = ss$
            End If
            ElseIf Not bstack.lastobj Is Nothing Then
           GoTo cont1
        End If
        Loop Until Not FastSymbol(b$, ",")
        If x1 > 0 Then
         pppp.SerialItem 0, x1, 9
         Set bstack.FuncObj = pppp
         Set pppp = New mArray
         Set bstack.lastobj = Nothing
         If myVarType(bstack.FuncValue, vbString) Then
         bstack.FuncValue = 0
         Else
         bstack.FuncValue = vbNullString
         End If
        End If
        x1 = 0
End Function


Function MergeOperators(ByVal A$, ByVal b$) As String
If A$ = vbNullString Then MergeOperators = b$: Exit Function
If b$ = vbNullString Then MergeOperators = A$: Exit Function
If A$ = b$ Then MergeOperators = A$: Exit Function
Dim br() As String, I As Long
If Len(A$) > Len(b$) Then
br() = Split("[]" + b$ + "[]", "][")
For I = 1 To UBound(br) - 1
If InStr(A$, "[" + br(I) + "]") = 0 Then A$ = A$ + "[" + br(I) + "]"
Next I
MergeOperators = A$
Else
br() = Split("[]" + A$ + "[]", "][")
For I = 1 To UBound(br) - 1
If InStr(b$, "[" + br(I) + "]") = 0 Then b$ = b$ + "[" + br(I) + "]"
Next I
MergeOperators = b$
End If
End Function
Public Sub GarbageFlush()
ReDim Trush(500) As VarItem
Dim I As Long
For I = 1 To 500
   Set Trush(I) = New VarItem
Next I
TrushCount = 500
End Sub
Public Sub GarbageFlush2()
ReDim Trush(500) As VarItem
Dim I As Long
For I = 1 To 500
   Set Trush(I) = New VarItem
Next I
TrushCount = 500
End Sub
Function PointPos(f$) As Long
Dim er As Long, er2 As Long
While FastSymbol(f$, Chr(34))
f$ = GetStrUntil(Chr(34), f$)
Wend
Dim I As Long, j As Long, oj As Long
If f$ = vbNullString Then
PointPos = 1
Else
er = 3
er2 = 3
For I = 1 To Len(f$)
er = er + 1
er2 = er2 + 1
Select Case Mid$(f$, I, 1)
Case "."
oj = j: j = I
Case "\", "/", ":", Is = Chr(34)
If er = 2 Then oj = 0: j = I - 2: Exit For
er2 = 1
oj = j: j = 0
If oj = 0 Then oj = I - 1: If oj < 0 Then oj = 0
Case " ", ChrW(160), vbTab
If j > 0 Then Exit For
If er2 = 2 Then oj = 0: j = I - 1: Exit For
er = 1
Case "|", "'"
j = I - 1
Exit For
Case Is > " "

If j > 0 Then oj = j Else oj = 0
Case Else
If oj <> 0 Then j = oj Else j = I
Exit For
End Select
Next I
If j = 0 Then
If oj = 0 Then
j = Len(f$) + 1
Else
j = oj
End If
End If
While Mid$(f$, j, I) = " "
j = j - 1
Wend
PointPos = j
End If
End Function
Public Function ExtractType(f$, Optional JJ As Long = 0, Optional simple As Boolean = True) As String
Dim I As Long, j As Long, D$
If FastSymbol(f$, Chr(34)) Then f$ = GetStrUntil(Chr(34), f$)
If f$ = vbNullString Then ExtractType = vbNullString: Exit Function
If simple Then
    j = SimplePointPos(f$)
ElseIf JJ > 0 Then
    j = JJ
Else
    j = PointPos(f$)
End If
D$ = f$ + " "
If j < Len(D$) Then
For I = j To Len(D$)
Select Case Mid$(D$, I, 1)
Case "/", "|", "'", " ", Is = Chr(34)
I = I + 1
Exit For
End Select
Next I
If (I - j - 2) < 1 Then
ExtractType = vbNullString
Else
ExtractType = mylcasefILE(Mid$(D$, j + 1, I - j - 2))
End If
Else
ExtractType = vbNullString
End If
End Function


Public Function CFname(A$, Optional Ts As Variant, Optional createtime As Variant) As String
If Len(A$) > 2000 Then Exit Function
Dim b$
Dim mDir As New recDir
If Not IsMissing(createtime) Then
mDir.UseUTC = createtime <= 0
End If
Sleep 1
If A$ <> "" Then
On Error GoTo 1
b$ = mDir.Dir1(A$, GetCurDir)
If b$ = vbNullString Then b$ = mDir.Dir1(A$, mDir.GetLongName(App.path))
If b$ <> "" Then
CFname = mylcasefILE(b$)
If Not IsMissing(Ts) Then
If Not IsMissing(createtime) Then
If Abs(createtime) = 1 Then
Ts = CDbl(mDir.lastTimeStamp2)
Else
Ts = CDbl(mDir.lastTimeStamp)
End If
Else
Ts = CDbl(mDir.lastTimeStamp)
End If
End If
End If
Exit Function
End If
1:
CFname = vbNullString
End Function

Public Function LONGNAME(sPath As String) As String
LONGNAME = ExtractPath(sPath, , True)
End Function
Public Function ExpEnvirStr(strInput) As String
Dim result As Long
Dim strOutput As String
'' Two calls required, one to get expansion buffer length first then do expansion
strOutput = space$(1000)
result = ExpandEnvironmentStrings(StrPtr(strInput), StrPtr(strOutput), result)
strOutput = space$(result)
result = ExpandEnvironmentStrings(StrPtr(strInput), StrPtr(strOutput), result)
ExpEnvirStr = StripTerminator(strOutput)
End Function

Public Function ExtractPath(ByVal f$, Optional Slash As Boolean = True, Optional existonly As Boolean = False) As String
If f$ = vbNullString Then Exit Function
Dim I As Long, j As Long, test$
test$ = f$ + " \/:": I = InStr(test$, " "): j = InStr(test$, "\")
If I < j Then j = InStr(test$, "/"): If I < j Then j = InStr(test$, ":"): If I < j Then Exit Function
If Right(f$, 1) = "\" Or Right(f$, 1) = "/" Then f$ = f$ + " a"
j = PointPos(f$)
If Mid$(f$, j, 1) = "." Then j = j - 1
If Len(f$) < j Then
If ExtractType(Mid$(f$, j) + "\.10", , False) = "10" Then j = j - 1 Else Exit Function
Else

End If

j = j - Len(ExtractNameOnly(f$))
If j <= 3 Then
If Mid$(f$, 2, 1) = ":" Then
If Slash Then
ExtractPath = mylcasefILE(Left$(f$, 2)) + "\"
Else
ExtractPath = mylcasefILE(Left$(f$, 2))
End If
Else
ExtractPath = vbNullString
End If
Else
If Slash Then
ExtractPath = mylcasefILE(Left$(f$, j))
Else
ExtractPath = mylcasefILE(Left$(f$, j - 1))
End If
End If

If existonly Then
ExtractPath = mylcasefILE(StripTerminator(GetLongName(ExpEnvirStr(ExtractPath))))
Else
ExtractPath = ExpEnvirStr(ExtractPath)
End If
Dim ccc() As String, C$
ccc() = Split(ExtractPath, "\..")
If UBound(ccc()) > LBound(ccc()) Then
C$ = vbNullString
For I = LBound(ccc()) To UBound(ccc()) - 1
If ccc(I) = vbNullString Then
C$ = ExtractPath(ExtractPath(C$, False))
Else
C$ = C$ + ExtractPath(ccc(I), True)
End If

Next I
If Left$(ccc(I), 1) = "\" Then
ExtractPath = C$ + Mid$(ccc(I), 2)
Else
ExtractPath = C$ + ccc(I)
End If
End If
End Function
Function SimplePointPos(s$)
Dim A As Long, b As Long, C As Long, D As Long
A = rinstr(s$, ".")
b = rinstr(s$, "\")
C = rinstr(s$, "/")
D = rinstr(s$, ":")
If b < A And C < A And D < A Then
    SimplePointPos = A
Else
    SimplePointPos = Len(s$)
End If

End Function
Public Function ExtractName(f$, Optional simple As Boolean = False) As String
Dim I As Long, j As Long, K$
If f$ = vbNullString Then Exit Function
If simple Then
j = SimplePointPos(f$)
Else
j = PointPos(f$)
If j > Len(f$) Then j = Len(f$)
End If
If Mid$(f$, j, 1) = "." Then
K$ = ExtractType(f$, j, simple)
Else
j = Len(f$)
End If
For I = j To 1 Step -1
Select Case Mid$(f$, I, 1)
Case Is < " ", "\", "/", ":"
Exit For
End Select
Next I
If K$ = vbNullString Then
If Mid$(f$, I + j - I, 1) = "." Then
ExtractName = mylcasefILE(Mid$(f$, I + 1, j - I - 1))
Else
ExtractName = mylcasefILE(Mid$(f$, I + 1, j - I))

End If
Else
ExtractName = mylcasefILE(Mid$(f$, I + 1, j - I)) + K$
End If

'ExtractName = mylcasefILE(Trim$(Mid$(f$, I + 1, j - I)))

End Function
Public Function ExtractNameOnly(ByVal f$, Optional simple As Boolean = False) As String
Dim I As Long, j As Long
If f$ = vbNullString Then Exit Function
If simple Then
j = SimplePointPos(f$)
Else
j = PointPos(f$)
If j > Len(f$) Then j = Len(f$)
End If
For I = j To 1 Step -1
Select Case Mid$(f$, I, 1)
Case Is < " ", "\", "/", ":"
Exit For
End Select
Next I
If Mid$(f$, I + j - I, 1) = "." Then
ExtractNameOnly = mylcasefILE(Mid$(f$, I + 1, j - I - 1))
Else
ExtractNameOnly = mylcasefILE(Mid$(f$, I + 1, j - I))
End If
End Function
Public Function GetCurDir(Optional AppPath As Boolean = False) As String
Dim A$, CD As String

If AppPath Then
CD = App.path
AddDirSep CD
A$ = mylcasefILE(CD)
Else
AddDirSep mcd
A$ = mylcasefILE(mcd)

End If
'If Right$(a$, 1) <> "\" Then a$ = a$ & "\"
GetCurDir = A$
End Function
Sub MakeGroupPointer(bstack As basetask, v, Optional usethisname As String = "", Optional Glob As Boolean)
Dim varv As New Group, vv As Group
Set vv = v
    With varv
        .IamGlobal = vv.IamGlobal
        .IamApointer = True
        .BeginFloat 2
       ' Debug.Print varv.soros.Total
       ' Set .Sorosref = vv.soros
        If vv.IamFloatGroup Then
        vv.ToDelete = False
        Else
            If Len(usethisname) > 0 Then
                If Glob Then
                    .IamGlobal = True
                Else
                    .lasthere = here$
                End If
                .GroupName = usethisname
            Else
                If Not .IamGlobal Then
                    .lasthere = here$
                End If
                If Len(vv.GroupName) > 1 Then
                    .GroupName = Mid$(vv.GroupName, 1, Len(vv.GroupName) - 1)
                End If
            End If
        End If
    End With
     Set varv.LinkRef = v
Set bstack.lastpointer = varv
Set bstack.lastobj = varv
End Sub
Function PreparePointer(bstack As basetask) As Boolean
Dim A As Group, pppp As mArray
    If bstack.lastpointer Is Nothing Then
    
    Else
        Set A = bstack.lastpointer
        
            Set pppp = New mArray
            pppp.PushDim 1
            pppp.PushEnd
            pppp.Arr = True
            Set pppp.item(0) = A
            Set bstack.lastpointer = pppp
            PreparePointer = True
  
    End If
    
End Function
Function BoxGroupVar(aGroup As Variant) As ppppLight
            Dim bGroup As Group
            Set bGroup = aGroup
            Set BoxGroupVar = New ppppLight
            BoxGroupVar.PushDim 1
            BoxGroupVar.PushEnd
            BoxGroupVar.Arr = True
            bGroup.ToDelete = True
            Set BoxGroupVar.item(0) = aGroup
End Function

Function BoxGroupObj(aGroup As Object) As ppppLight
            Dim bGroup As Group
            Set bGroup = aGroup
            Set BoxGroupObj = New ppppLight
            BoxGroupObj.PushDim 1
            BoxGroupObj.PushEnd
            BoxGroupObj.Arr = True
            bGroup.ToDelete = True
            Set BoxGroupObj.item(0) = aGroup
End Function

Sub monitor(bstack As basetask, prive As basket, Lang As Long)
    Dim ss$, di As Object
    Set di = bstack.Owner
    Dim primarymonitor As Long
    primarymonitor = FindPrimary
    If Lang = 0 Then
        wwPlain2 bstack, prive, "Åî ïñéóìïý êùäéêïóåëßäá: " & GetACP, bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "ÖÜêåëïò åöáñìïãÞò", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, PathFromApp("m2000"), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Êáôá÷þñçóç gsb", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, myRegister("gsb"), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "ÖÜêåëïò ðñïóùñéíþí áñ÷åßùí", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, LONGNAME(strTemp), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "ÔñÝ÷ïí öÜêåëïò", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, mcd, bstack.Owner.Width, 1000, True
        If m_bInIDE Then
        wwPlain2 bstack, prive, "¼ñéï ÁíáäñïìÞò ãéá ÓõíáñôÞóåéò " & (stacksize \ 3700), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "¼ñéï ÁíáäñïìÞò ÓõíáñôÞóåùí/ÔìçìÜôùí ìå ôçí ÊÜëåóå " & (stacksize \ 1900), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "¼ñéï êëÞóåùí ãéá ÔìÞìáôá " & (stacksize \ 1288), bstack.Owner.Width, 1000, True
        Else
        wwPlain2 bstack, prive, "¼ñéï ÁíáäñïìÞò ãéá ÓõíáñôÞóåéò " & (stacksize \ 9017), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "¼ñéï ÁíáäñïìÞò ÓõíáñôÞóåùí/ÔìçìÜôùí ìå ôçí ÊÜëåóå " & (stacksize \ 4524), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "¼ñéï êëÞóåùí ãéá ÔìÞìáôá  " & (stacksize \ 3759), bstack.Owner.Width, 1000, True
        End If
        If OverideDec Then wwPlain2 bstack, prive, "ÁëëáãÞ Ôïðéêïý " & (Clid), bstack.Owner.Width, 1000, True
        If UseIntDiv Then ss$ = "+DIV" Else ss$ = "-DIV"
        If priorityOr Then ss$ = ss$ + " +PRI" Else ss$ = ss$ + " -PRI"
        If Not mNoUseDec Then ss$ = ss$ + " -DEC" Else ss$ = ss$ + " +DEC"
        If mNoUseDec <> NoUseDec Then ss$ = ss$ + "(ðáñÜêáìøç)"
GoSub part2
        wwPlain2 bstack, prive, "Äéáêüðôåò " + ss$, bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Ðåñß äéáêïðôþí: ÷ñçóéìïðïßçóå ôçí åíôïëÞ ÂïÞèåéá Äéáêüðôåò", bstack.Owner.Width, 1000, True
        
        wwPlain2 bstack, prive, "Ïèüíåò:" + str$(DisplayMonitorCount()) + "  ç âáóéêÞ :" + str$(primarymonitor + 1) + " ÅíôïëÞ: ÐáñÜèõñï Ôýðïò," + str$(primarymonitor), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "ÁõôÞ ç öüñìá åßíáé óôçí ïèüíç:" + str$(FindFormSScreen(di) + 1), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Ç êïíóüëá åßíáé óôçí ïèüíç:" + str$(Console + 1), bstack.Owner.Width, 1000, True

    Else
        wwPlain2 bstack, prive, "Default Code Page:" & GetACP, bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "App Path", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, PathFromApp("m2000"), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Register gsb", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, myRegister("gsb"), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Temporary", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, LONGNAME(strTemp), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Current directory", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, mcd, bstack.Owner.Width, 1000, True
        If m_bInIDE Then
        wwPlain2 bstack, prive, "Max Limit for Function Recursion " & (stacksize \ 3700), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Max Limit for Function/Module Recursion using Call " & (stacksize \ 1900), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Max Limit for calling modules in depth " & (stacksize \ 1288), bstack.Owner.Width, 1000, True
        Else
        wwPlain2 bstack, prive, "Max Limit for Function Recursion " & (stacksize \ 9017), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Max Limit for Function/Module Recursion using Call " & (stacksize \ 4524), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Max Limit for calling modules in depth " & (stacksize \ 3759), bstack.Owner.Width, 1000, True
        End If
        If OverideDec Then wwPlain2 bstack, prive, "Locale Overide " & (Clid), bstack.Owner.Width, 1000, True
        If UseIntDiv Then ss$ = "+DIV" Else ss$ = "-DIV"
        If priorityOr Then ss$ = ss$ + " +PRI" Else ss$ = ss$ + " -PRI"
        If Not mNoUseDec Then ss$ = ss$ + " -DEC" Else ss$ = ss$ + " +DEC"
        If mNoUseDec <> NoUseDec Then ss$ = ss$ + "(bypass)"
        GoSub part2
        wwPlain2 bstack, prive, "Switches " + ss$, bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "About Switches: use command Help Switches", bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Screens:" + str$(DisplayMonitorCount()) + "  Primary is:" + str$(primarymonitor + 1) + " Command: Window Mode," + str$(primarymonitor), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "This form is in screen:" + str$(FindFormSScreen(di) + 1), bstack.Owner.Width, 1000, True
        wwPlain2 bstack, prive, "Console is in screen:" + str$(Console + 1), bstack.Owner.Width, 1000, True
    End If
Exit Sub
part2:
        If mTextCompare Then ss$ = ss$ + " +TXT" Else ss$ = ss$ + " -TXT"
        If ForLikeBasic Then ss$ = ss$ + " +FOR" Else ss$ = ss$ + " -FOR"
        If DimLikeBasic Then ss$ = ss$ + " +DIM" Else ss$ = ss$ + " -DIM"
        If ShowBooleanAsString Then ss$ = ss$ + " +SBL" Else ss$ = ss$ + " -SBL"
        If RoundDouble Then ss$ = ss$ + " +RDB" Else ss$ = ss$ + " -RDB"
        If SecureNames Then ss$ = ss$ + " +SEC" Else ss$ = ss$ + " -SEC"
        If UseTabInForm1Text1 Then ss$ = ss$ + " +TAB" Else ss$ = ss$ + " -TAB"
        If UseMDBHELP Then ss$ = ss$ + " +MDB" Else ss$ = ss$ + " -MDB"
        If Use13 Then ss$ = ss$ + " +INP" Else ss$ = ss$ + " -INP"
        If Nonbsp Then ss$ = ss$ + " -NBS" Else ss$ = ss$ + " +NBS"
        Return
End Sub
Sub NeoSwap(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MySwap(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoComm(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyRead(3, ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoRef(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyRead(2, ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoRead(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyRead(1, ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoReport(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyReport(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoDeclare(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyDeclare(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoMethod(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyMethod(ObjFromPtr(basestackLP), rest$, Lang, False, False)
If LastErNum = -1 Then resp = False
End Sub
Sub NeoWith(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyWith(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoSprite(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim s$, p, bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
If IsExp(bstack, rest$, p) Then
    If myVarType(p, vbString) Then
        SwapString2Variant s$, p
        sprite bstack, s$, rest$
    Else
        spriteGDI bstack, rest$
    End If
ElseIf IsStrExp(bstack, rest$, s$, False) Then
sprite bstack, s$, rest$
End If
resp = LastErNum1 = 0
End Sub

Sub NeoPlayer(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcPlayer(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoPrinter(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcPrinter(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoPage(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
ProcPage ObjFromPtr(basestackLP), rest$, Lang
resp = True
End Sub
Sub NeoCompact(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
BaseCompact ObjFromPtr(basestackLP), rest$
resp = True
End Sub
Sub NeoLayer(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcLayer(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoOrder(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyOrder(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoDelete(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = DELfields(ObjFromPtr(basestackLP), rest$)
'resp = True  '' maybe this can be change
End Sub
Sub NeoAppend(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim s$, p As Variant, bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
If IsExp(bstack, rest$, p) Then
    If myVarType(p, vbString) Then
        SwapString2Variant s$, p
        resp = append_table(bstack, s$, rest$, False)
    Else
    resp = AddInventory(bstack, rest$)
    End If
ElseIf IsStrExp(bstack, rest$, s$, False) Then
    resp = append_table(bstack, s$, rest$, False)
Else
SyntaxError
resp = False
End If
End Sub
Sub NeoSearch(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
getrow ObjFromPtr(basestackLP), rest$, , "", Lang
resp = True
End Sub
Sub NeoRetr(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
getrow ObjFromPtr(basestackLP), rest$, , , Lang
resp = True
End Sub
Sub NeoExecute(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
If IsLabelSymbolNew(rest$, "ÊÙÄÉÊÁ", "CODE", Lang) Then
 resp = ExecCode(ObjFromPtr(basestackLP), rest$)
 Else
CommExecAndTimeOut ObjFromPtr(basestackLP), rest$
resp = True
End If

End Sub

Sub NeoTable(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = NewTable(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoBase(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = NewBase(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoHold(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcHold(ObjFromPtr(basestackLP))
End Sub
Sub NeoRelease(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcRelease(ObjFromPtr(basestackLP))
End Sub
Sub NeoSuperClass(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcClass(ObjFromPtr(basestackLP), rest$, Lang, True)
End Sub
Sub NeoClass(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcClass(ObjFromPtr(basestackLP), rest$, Lang, False)
End Sub
Sub NeoDIM(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyDim(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoPathDraw(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcPath(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoCreateEmf(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcCreateEmf(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoDrawings(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyDrawings(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoFill(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcFill(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoFloodFill(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcFLOODFILL(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoTextCursor(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyCursor(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoMouseIcon(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
i3MouseIcon ObjFromPtr(basestackLP), rest$, Lang
resp = True
End Sub
Sub NeoLong(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbLong, True)
Set bstack = Nothing
End Sub
Sub NeoVariant(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbVariant, True)
Set bstack = Nothing
End Sub
Sub NeoByte(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbByte, True)
Set bstack = Nothing
End Sub
Sub NeoBigInteger(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbObject, True, CVar(New BigInteger))
Set bstack = Nothing
End Sub
Sub NeoDecimal(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbDecimal, True)
Set bstack = Nothing
End Sub
Sub NeoCurrency(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbCurrency, True)
Set bstack = Nothing
End Sub
Sub NeoObject(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbObject, True)
Set bstack = Nothing
End Sub
Sub NeoString(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbString, True)
Set bstack = Nothing
End Sub
Sub NeoSingle(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbSingle, True)
Set bstack = Nothing
End Sub
Sub NeoInteger(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbInteger, True)
Set bstack = Nothing
End Sub
Sub NeoComplex(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, 200, True)
Set bstack = Nothing
End Sub
Sub NeoBoolean(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbBoolean, True)
Set bstack = Nothing
End Sub
Sub NeoDate(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask, K As Long

Set bstack = ObjFromPtr(basestackLP)
K = MyTrimL(rest$): If K > 1 Then rest$ = Mid$(rest$, K)
If CheckFreeExecute(rest$) Then
    SetDouble bstack.Owner
    resp = True
Else
    resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbDate, True)
End If
Set bstack = Nothing

End Sub
Sub NeoDouble(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask, K As Long

Set bstack = ObjFromPtr(basestackLP)
K = MyTrimL(rest$): If K > 1 Then rest$ = Mid$(rest$, K)
If CheckFreeExecute(rest$) Then
    SetDouble bstack.Owner
    resp = True
Else
    resp = MyAnyType(bstack, rest$, Lang, Len(here$) > 0, vbDouble, True)
End If
Set bstack = Nothing

End Sub
Sub NeoNormal(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim bstack As basetask
Set bstack = ObjFromPtr(basestackLP)
Dim last As Boolean
With players(GetCode(bstack.Owner))
last = .currow + 1 >= .mY
End With
SetNormal bstack.Owner
With players(GetCode(bstack.Owner))
If last Then .currow = .mY - 1
End With

Set bstack = Nothing

resp = True
End Sub
Sub NeoSort(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcSort(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoImage(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcImage(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoBitmaps(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyBitmaps(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoDef(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcDef(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoMovies(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyMovies(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoSounds(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MySounds(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoPen(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcPen(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoCls(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcCls(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoDesktop(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcDesktop(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoStructure(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = myStructure(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoInput(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyInput(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoEvent(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = myEvent(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoProto(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcProto(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoEnum(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcEnum(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoPset(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyPset(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoAssert(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcAssert(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoMargin(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcMargins(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoModule(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyModule(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoModules(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyModules(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoGroup(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcGroup(0, ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoClipBoard(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyClipboard(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoBack(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
ProcBackGround ObjFromPtr(basestackLP), rest$, Lang, resp
End Sub
Sub NeoOver(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcOver(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoDrop(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcDrop(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoShift(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcShift(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoShiftBack(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcShiftBack(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoLoad(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcLoad(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoText(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcText(ObjFromPtr(basestackLP), False, rest$)
End Sub
Sub NeoHtml(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcText(ObjFromPtr(basestackLP), True, rest$)
End Sub

Sub NeoCurve(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcCurve(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoPoly(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcPoly(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoCircle(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcCircle(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoNew(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyNew(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoTitle(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcTitle(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoDraw(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcDraw(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoWidth(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcDrawWidth(ObjFromPtr(basestackLP), rest$)
End Sub

Sub NeoMove(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcMove(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoStep(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcStep(ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoPrint(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = RevisionPrint(ObjFromPtr(basestackLP), rest$, 0, Lang)
End Sub
Sub NeoCopy(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyCopy(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoPrinthEX(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = RevisionPrint(ObjFromPtr(basestackLP), rest$, 1, Lang)
End Sub
Sub NeoRem(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
    Dim I As Long
    If FastSymbol(rest$, "{") Then
    I = blockLen(rest$)
    If I > 0 Then rest$ = Mid$(rest$, I + 1) Else rest$ = vbNullString
    Else
    SetNextLineNL rest$
    End If
    resp = True
End Sub
Sub NeoPush(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyPush(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoData(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyData(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoClear(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyClear(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoLinespace(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = procLineSpace(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoSet(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim I As Long, s$
aheadstatusANY rest$, I
s$ = Left$(rest$, I - 1)
resp = interpret(ObjFromPtr(basestackLP), s$)
If resp Then
rest$ = Mid$(rest$, I)
Else
rest$ = s$ + Mid$(rest$, I)
End If
End Sub


Sub NeoBold(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
ProcBold ObjFromPtr(basestackLP), rest$
resp = True
End Sub
Sub NeoChooseObj(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
    resp = ProcChooseObj(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoChooseFont(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
    ProcChooseFont ObjFromPtr(basestackLP), Lang
    resp = True
End Sub
Sub NeoFont(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
    ProcChooseFont ObjFromPtr(basestackLP), Lang
    resp = True
End Sub
Sub NeoScore(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyScore(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoPlayScore(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyPlayScore(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoMode(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcMode(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoGradient(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcGradient(ObjFromPtr(basestackLP), rest$)
End Sub
Sub NeoFunction(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyFunction(0, ObjFromPtr(basestackLP), rest$, Lang)
End Sub

Sub NeoFiles(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcFiles(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub NeoCat(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = ProcCat(ObjFromPtr(basestackLP), rest$, Lang)
End Sub


Function CallAsk(bstack As basetask, A$, v$) As Boolean
Dim s$
    If UCase(v$) = "ASK(" Then
        DialogSetupLang 1
    Else
        DialogSetupLang 0
    End If
    If AskText$ = vbNullString Then ZeroParam A$: Exit Function
    If FastSymbol(A$, ",") Then IsStrExp bstack, A$, AskTitle$, False
    If FastSymbol(A$, ",") Then
        IsStrExp bstack, A$, s$, False 'AskOk$
        If s$ = "" Then
        AskOk$ = ""
        ElseIf s$ = "*" Then
            AskOk$ = "*" + AskOk$
        Else
            AskOk$ = s$
        End If
    End If
    If FastSymbol(A$, ",") Then
        IsStrExp bstack, A$, s$, False ' AskCancel$
        If s$ = "" Then
        AskCancel$ = ""
        ElseIf s$ = "*" Then
            AskCancel$ = "*" + AskCancel$
        Else
            AskCancel$ = s$
        End If
    End If
    If FastSymbol(A$, ",") Then IsStrExp bstack, A$, AskDIB$, False
    
    If FastSymbol(A$, ",") Then IsStrExp bstack, A$, AskStrInput$, False: AskInput = True
olamazi
CallAsk = True
End Function
Public Sub olamazi()
If Form4Loaded Then Exit Sub
If Form4.Visible Then
Form4.Visible = False
If Form1.Visible Then
   
   ' If Form2.Visible Then Form2.ZOrder
    If Form1.TEXT1.Visible Then
        Form1.TEXT1.SetFocus
    Else
        Form1.SetFocus
    End If
    End If
    End If
End Sub
Sub GetGuiM2000(r$)
Dim aaa As GuiM2000
If TypeOf Screen.ActiveForm Is GuiM2000 Then
Set aaa = Screen.ActiveForm
                  If aaa.Index > -1 Then
                  r$ = myUcase(aaa.myname$ + "(" & (aaa.Index) & ")", True)
                  Else
                  r$ = myUcase(aaa.myname$, True)
                  End If
Else
                r$ = vbNullString
End If

End Sub
Public Function IsSupervisor() As Boolean

Dim ss$
                 ss$ = UCase(userfiles)
                    DropLeft "\M2000_USER\", ss$
IsSupervisor = ss$ = vbNullString
End Function


Public Function UserPath() As String

Dim ss$
                 ss$ = UCase(userfiles)
                    DropLeft "\M2000_USER\", ss$
        If ss$ <> "" Then
        If CanKillFile(mcd) Then
        DropLeft "\", ss$
UserPath = Mid$(mcd, Len(userfiles) - Len(ss$) + 1)
If UserPath = vbNullString Then
UserPath = "."
End If
Else
UserPath = mcd
End If
Else
UserPath = mcd
End If
End Function
Public Function UserPath2() As String

Dim ss$
                 ss$ = UCase(userfiles)
                    DropLeft "\M2000_USER\", ss$
        If ss$ <> "" Then
        If CanKillFile(mcd) Then
        DropLeft "\", ss$
UserPath2 = Mid$(mcd, Len(userfiles) - Len(ss$) + 1)
If UserPath2 = vbNullString Then
UserPath2 = "."
End If
Else
UserPath2 = mcd
End If
Else
UserPath2 = mcd
End If
If Right$(UserPath2, 1) = "\" Then UserPath2 = Left$(UserPath2$, Len(UserPath2$) - 1)


End Function
Function Fast2Label(A$, C$, cl As Long, D$, dl As Long, ahead&) As Boolean
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
Pad$ = myUcase(Mid$(A$, I, ahead& + 1)) + " "
If j - I >= cl - 1 Then
If InStr(C$, Left$(Pad$, cl)) > 0 Then
If Mid$(Pad$, cl + 1, 1) Like "[0-9+.\( @-]" Then
A$ = Mid$(A$, MyTrimLi(A$, I + cl))
Fast2Label = True
End If
Exit Function
End If
End If
If j - I >= dl - 1 Then
If InStr(D$, Left$(Pad$, dl)) > 0 Then
If Mid$(Pad$, dl + 1, 1) Like "[0-9+.\( @-]" Then
A$ = Mid$(A$, MyTrimLi(A$, I + dl))
Fast2Label = True
End If
End If
End If
End Function
Function Fast2LabelNoNum(A$, C$, cl As Long, D$, dl As Long, ahead&) As Boolean
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
Pad$ = myUcase(Mid$(A$, I, ahead& + 1)) + " "
If j - I >= cl - 1 Then
    If InStr(C$, Left$(Pad$, cl)) > 0 Then
        If Len(Pad$) > cl Then
            Select Case AscW(Mid$(Pad$, cl + 1, 1))
            Case Is < 36, 39, 47, 59, 92, 123, 160
            Case Else
                Exit Function
            End Select
        End If
        A$ = Mid$(A$, MyTrimLi(A$, I + cl))
        Fast2LabelNoNum = True
        Exit Function
    End If
End If
If j - I >= dl - 1 Then
    If InStr(D$, Left$(Pad$, dl)) > 0 Then
        If Len(Pad$) > dl Then
            Select Case AscW(Mid$(Pad$, dl + 1, 1))
            Case Is < 36, 39, 47, 59, 92, 123, 160
            Case Else
                Exit Function
            End Select
        End If
        A$ = Mid$(A$, MyTrimLi(A$, I + dl))
        Fast2LabelNoNum = True
    End If
End If
End Function

Function Fast2Symbol(A$, C$, K As Long, D$, L As Long) As Boolean
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
If j - I >= K - 1 Then
    If InStr(C$, Mid$(A$, I, K)) > 0 Then
    A$ = Mid$(A$, MyTrimLi(A$, I + K))
    Fast2Symbol = True
    Exit Function
    End If
End If
'If j - i >= Len(d$) - 1 Then
If j - I >= L - 1 Then
    If InStr(D$, Mid$(A$, I, L)) > 0 Then
    A$ = Mid$(A$, MyTrimLi(A$, I + L))
    Fast2Symbol = True
    Exit Function
    End If

End If
End Function
Function FastOperator2(A$, C$, I As Long) As Boolean
    If Mid$(A$, I, 1) = C$ Then
        Mid$(A$, I, 1) = " "
        FastOperator2 = True
    End If
End Function
Function FastSymbol(A$, C$, Optional mis As Boolean = False, Optional cl As Long = 1) As Boolean
    Dim I As Long, j As Long
    j = Len(A$)
    If j = 0 Then Exit Function
    I = MyTrimL(A$)
    If I > j Then Exit Function  ' this is not good
    If j - I < cl - 1 Then
        If mis Then MissSymbol C$
        Exit Function
    End If
    If C$ = Mid$(A$, I, cl) Then
        A$ = Mid$(A$, MyTrimLi(A$, I + cl))
        FastSymbol = True
    ElseIf mis Then
        MissSymbol C$
    End If
End Function
Function FastSymbol1(s$, C$) As Boolean
    Dim I&, L As Long, where As Long
    Dim P2 As Long, P1 As Integer, p4 As Long
    L = Len(s$): If L = 0 Then Exit Function
    P2 = StrPtr(s$): L = L - 1
    p4 = P2 + L * 2
    For I = P2 To p4 Step 2
        GetMem2 I, P1
        Select Case P1
        Case 32, 160, 7, 9
        Case Else
            where = (I - P2) \ 2 + 1
            FastSymbol1 = P1 = AscW(C$)
            Exit For
        End Select
    Next I
    If FastSymbol1 Then
        s$ = Mid$(s$, where + 1)
    ElseIf where > 0 Then
        s$ = Mid$(s$, where)
    End If
End Function
Function FastSymbol23(s$, C$, st As Long, Optional Action As Integer) As Boolean
    Dim I&, L As Long, where As Long
    Dim P2 As Long, P1 As Integer, p4 As Long
    L = Len(s$): If L = 0 Then Exit Function
    P2 = StrPtr(s$): L = L - 1
    p4 = P2 + L * 2
    For I = P2 + (st * 2 - 2) To p4 Step 2
        GetMem2 I, P1
        Select Case P1
        Case 32, 160, 7, 9
        Case Else
            where = (I - P2) \ 2 + 1
            FastSymbol23 = P1 = AscW(C$)
            Exit For
        End Select
    Next I
    If Action = 1 Then
        If FastSymbol23 Then
            Mid$(s$, where, 1) = " "
        End If
    ElseIf Action = 0 Then
        If FastSymbol23 Then
            s$ = Mid$(s$, where + 1)
        ElseIf where > 0 Then
            s$ = Mid$(s$, where)
        End If
    End If
    
End Function

Function FastSymbol2(s$, C$) As Boolean
Dim I&, L As Long, where As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s$): If L = 0 Then Exit Function
  P2 = StrPtr(s$): L = L - 1
  p4 = P2 + L * 2
  For I = P2 To p4 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case Else
    
     where = (I - P2) \ 2 + 1
     FastSymbol2 = Mid$(s$, where, 2) = C$
     
   Exit For
  End Select
  Next I
  If FastSymbol2 Then
  s$ = Mid$(s$, where + 2)
  ElseIf where > 1 Then
  s$ = Mid$(s$, where)
  End If
  
End Function





Function lookA123(s) As Boolean
Dim I&, L As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s): If L = 0 Then Exit Function
  P2 = StrPtr(s): L = L - 1
  GetMem2 P2, P1
  If P1 <> 58 Then Exit Function
  For I = P2 + 2 To P2 + L * 2 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case 13, 39, 47, 92
    lookA123 = True
    Case Else
   Exit Function
  End Select
  Next I
End Function





Function MakeEmf(bstack As basetask, b$, Lang As Long, Data$, Optional ww = 0, Optional hh = 0) As Boolean
Dim W$, x1 As Long, label1$, usehandler As mHandler, par As Boolean, pppp As mArray, p As Variant, it&, x2&
x2 = Len(b$)
If IsLabelSymbolNew(b$, "ÙÓ", "AS", Lang) Then
            W$ = Funcweak(bstack, b$, x1, label1$)
            If LastErNum1 = -1 And x1 < 5 Then Exit Function
            If LenB(W$) = 0 Then
            If Len(bstack.UseGroupname) > 0 Then
                If Len(label1$) > Len(bstack.UseGroupname) Then
                    If bstack.UseGroupname = Left$(label1$, Len(bstack.UseGroupname)) Then
                        MyEr "No such member in this group", "Äåí õðÜñ÷åé ôÝôïéï ìÝëïò óå áõôÞ ôçí ïìÜäá"
                        Exit Function
                    End If
                End If
            ElseIf x1 = 1 Then
contvar1:
            x1 = globalvar(label1$, 0#)
            Set usehandler = New mHandler
                usehandler.T1 = 2

                Set usehandler.objref = ExecuteEmfBlock(bstack, Data$, it, ww, hh)


                    Set var(x1) = usehandler
                    MakeEmf = it <> 0
                    If it = 0 Then b$ = Data$ + space$(x2&)
                Exit Function
            ElseIf x1 = 5 Then
                If GetVar(bstack, label1$, x1) Then
                    If GetArrayReference(bstack, b$, label1$, var(x1), pppp, x1) Then
                        Set usehandler = New mHandler
                        usehandler.T1 = 2

                        Set usehandler.objref = ExecuteEmfBlock(bstack, Data$, it, ww, hh)
                        Set pppp.item(x1) = usehandler
                        MakeEmf = it <> 0
                        If it = 0 Then b$ = Data$ + space$(x2&) + b$
                    End If
                    Exit Function
            
                Else
                    MyEr "", ""
                    MyEr "Array not defined", "Ï ðßíáêáò äåí Ý÷åé ïñéóôåß"
                    Exit Function
                End If
            End If
            End If

            If x1 = 1 Then
            If GetVar(bstack, label1$, x1) Then
                Set usehandler = New mHandler
                usehandler.T1 = 2
        
                Set usehandler.objref = ExecuteEmfBlock(bstack, Data$, it, ww, hh)
          
                    Set var(x1) = usehandler
                    MakeEmf = it <> 0
                    If it = 0 Then b$ = Data$ + space$(x2&) + b$
            
                Exit Function
            Else
                GoTo contvar1
            End If
                ElseIf x1 = 5 Then
                If GetVar(bstack, label1$, x1) Then
                      DropLeft "(", W$
                    If GetArrayReference(bstack, W$, label1$, var(x1), pppp, x1) Then
                        Set usehandler = New mHandler
                        usehandler.T1 = 2
                        Set usehandler.objref = ExecuteEmfBlock(bstack, Data$, it, ww, hh)
                       
                        Set pppp.item(x1) = usehandler
                        MakeEmf = it <> 0
                        If it = 0 Then b$ = Data$ + space$(x2&) + b$
                    End If
                    Exit Function
            
                Else
                    MyEr "", ""
                    MyEr "Array not defined", "Ï ðßíáêáò äåí Ý÷åé ïñéóôåß"
                    Exit Function
                End If
            End If
        
        End If
End Function


Function GetRes(bstack As basetask, b$, Lang As Long, Data$) As Boolean
Dim W$, x1 As Long, label1$, usehandler As mHandler, par As Boolean, pppp As mArray, p As Variant
If IsLabelSymbolNew(b$, "ÙÓ", "AS", Lang) Then
            W$ = Funcweak(bstack, b$, x1, label1$)
            If LastErNum1 = -1 And x1 < 5 Then Exit Function
            If LenB(W$) = 0 Then
            If Len(bstack.UseGroupname) > 0 Then
                If Len(label1$) > Len(bstack.UseGroupname) Then
                    If bstack.UseGroupname = Left$(label1$, Len(bstack.UseGroupname)) Then
                        MyEr "No such member in this group", "Äåí õðÜñ÷åé ôÝôïéï ìÝëïò óå áõôÞ ôçí ïìÜäá"
                        Exit Function
                    End If
                End If
            ElseIf x1 = 1 Then
contvar1:
            x1 = globalvar(label1$, 0#)
            Set usehandler = New mHandler
            usehandler.T1 = 2
            If FastSymbol(b$, ",") Then
                If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                    Set usehandler.objref = Decode64toMemBloc(Data$, par, CBool(p))
                  Else
                    GetRes = True
                    MissParam Data$: Exit Function
                End If
            Else
                Set usehandler.objref = Decode64toMemBloc(Data$, par)
            End If
            If par Then
                Set var(x1) = usehandler
                GetRes = True
            Else
                GoTo Err1
            End If
            Exit Function
        ElseIf x1 = 3 Then
            x1 = globalvar(label1$, vbNullString)
            var(x1) = Decode64(Data$, par)
            If Not par Then GoTo Err1
            GetRes = True
            Exit Function
        ElseIf x1 = 5 Then
            If GetVar(bstack, label1$, x1) Then
                If GetArrayReference(bstack, b$, label1$, var(x1), pppp, x1) Then
                    Set usehandler = New mHandler
                        usehandler.T1 = 2
                        If Not par Then GoTo Err1
                        If FastSymbol(b$, ",") Then
                            If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                                Set usehandler.objref = Decode64toMemBloc(Data$, par, CBool(p))
                            Else
                                GetRes = True
                                MissParam Data$: Exit Function
                            End If
                        Else
                            Set usehandler.objref = Decode64toMemBloc(Data$, par)
                        End If
                        If par Then
                        Set pppp.item(x1) = usehandler
                            GetRes = True
                        Else
                            GoTo Err1
                        End If
                    End If
                    Exit Function
                Else
                    MyEr "", ""
                    MyEr "Array not defined", "Ï ðßíáêáò äåí Ý÷åé ïñéóôåß"
                    Exit Function
                End If
            ElseIf x1 = 6 Then
contStr1:
                If GetVar(bstack, label1$, x1) Then
                    If GetArrayReference(bstack, b$, label1$, var(x1), pppp, x1) Then
                        pppp.item(x1) = Decode64(Data$, par)
                        If Not par Then GoTo Err1
                        GetRes = True
                    End If
                    Exit Function
                Else
                    MyEr "", ""
                    MyEr "Array not defined", "Ï ðßíáêáò äåí Ý÷åé ïñéóôåß"
                    Exit Function
                End If
            End If
            End If

            If x1 = 1 Then
            If GetVar(bstack, label1$, x1) Then
            Set usehandler = New mHandler
                usehandler.T1 = 2
        
                Set usehandler.objref = Decode64toMemBloc(Data$, par)
                If par Then
                    Set var(x1) = usehandler
                    GetRes = True
                Else
Err1:
                    MyEr "Can't decode this resource", "Äåí ìðïñþí íá áðïêùäéêïðïéÞóù áõôü ôï ðüñï"
                End If
                Exit Function
            Else
                GoTo contvar1
            End If
                ElseIf x1 = 3 Then
                
                If GetVar(bstack, label1$, x1) Then
                var(x1) = Decode64(Data$, par)
                If Not par Then GoTo Err1
                GetRes = True
                Exit Function
                End If
                ElseIf x1 = 5 Then
                If GetVar(bstack, label1$, x1) Then
                      DropLeft "(", W$
                    If GetArrayReference(bstack, W$, label1$, var(x1), pppp, x1) Then
                        Set usehandler = New mHandler
                        usehandler.T1 = 2
                        Set usehandler.objref = Decode64toMemBloc(Data$, par)
                        If Not par Then GoTo Err1
                        Set pppp.item(x1) = usehandler
                        GetRes = True
                    End If
                    Exit Function
            
                Else
                    MyEr "", ""
                    MyEr "Array not defined", "Ï ðßíáêáò äåí Ý÷åé ïñéóôåß"
                    Exit Function
                End If
                            ElseIf x1 = 6 Then
                               If GetVar(bstack, label1$, x1) Then
                            DropLeft "(", W$
                    If GetArrayReference(bstack, W$, label1$, var(x1), pppp, x1) Then
                        pppp.item(x1) = Decode64(Data$, par)
                        If Not par Then GoTo Err1
                        GetRes = True
                    End If
                    Exit Function
                Else
                    MyEr "", ""
                    MyEr "Array not defined", "Ï ðßíáêáò äåí Ý÷åé ïñéóôåß"
                    Exit Function
                End If
            End If
        
        End If
End Function

Function IsHILOWWORD(bstack As basetask, A$, r As Variant) As Boolean
    Dim p As Variant
    If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
        If FastSymbol(A$, ",") Then
              If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                    r = (r * &H10000 + p)
                    
                     IsHILOWWORD = FastSymbol(A$, ")", True)
                  Else
                     
                    MissParam A$
                End If
        Else
             
             MissParam A$
        End If
     Else
             
             MissParam A$
      End If
     
End Function
Function IsBinaryNot(bstack As basetask, A$, r As Variant) As Boolean
  If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
            On Error Resume Next
            If r < 0 Then r = r And &H7FFFFFFF
             r = uintnew1(Not signlong2(r))
        If Err.Number > 0 Then
            
            WrongArgument A$
          
            Exit Function
            End If
    On Error GoTo 0
    
        IsBinaryNot = FastSymbol(A$, ")", True)
    Else
           MissParam A$
    
    End If
End Function
Function IsBinaryNeg(bstack As basetask, A$, r As Variant) As Boolean
  If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
            On Error Resume Next
       
             r = CDbl(Pow2minusOne(32) - uintnew(r))
        If Err.Number > 0 Then
        
            WrongArgument A$
        
            Exit Function
            End If
    On Error GoTo 0
    
        IsBinaryNeg = FastSymbol(A$, ")", True)
    Else
           MissParam A$
    
    End If
End Function
Function IsBinaryOr(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            r = uintnew1(signlong2(r) Or signlong2(p))
            IsBinaryOr = FastSymbol(A$, ")", True)
            Exit Function
        End If
    End If
End If
MissParam A$
End Function
Function IsBinaryAdd(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant
On Error Resume Next
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            r = add32(r, p)
            While FastSymbol(A$, ",")
                If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then MissNumExpr: Exit Function
                r = add32(r, p)
            Wend
            r = uintnew1(LowLong(cInt64(CDec(r))))
            IsBinaryAdd = FastSymbol(A$, ")", True)
            Exit Function
        End If
    End If
End If
MissParam A$
End Function
Function IsBinaryAnd(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
        If FastSymbol(A$, ",") Then
            If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                r = uintnew1(signlong2(r) And signlong2(p))
                IsBinaryAnd = FastSymbol(A$, ")", True)
                Exit Function
            End If
        End If
    End If
MissParam A$
End Function
Function IsBinaryXor(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            r = uintnew1(signlong2(r) Xor signlong2(p))
            IsBinaryXor = FastSymbol(A$, ")", True)
            Exit Function
        End If
    End If
End If
MissParam A$
End Function
Function IsBinaryShift(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
     If FastSymbol(A$, ",") Then
         If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            If p > 31 Or p < -31 Then
                MyErMacro A$, "Shift from -31 to 31", "Ïëßóèçóç áðü -31 ùò 31"
                IsBinaryShift = False: Exit Function
            Else
                If p > 0 Then
                    r = CCur((signlong(r) And signlong(Pow2minusOne(32 - p))) * Pow2(p))
                ElseIf p = 0 Then
                    r = CCur(r)
                Else
                    r = CCur(Int(CCur(r) / Pow2(-p)))
                End If
                IsBinaryShift = FastSymbol(A$, ")", True)
                Exit Function
            End If
        End If
    End If
End If
MissParam A$
End Function
Function IsBinaryRotate(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            If p > 31 Or p < -31 Then
                MyErMacro A$, "Rotation from -31 to 31", "ÐåñéóôïöÞ áðü -31 ùò 31"
                IsBinaryRotate = False: Exit Function
            Else
                If p > 0 Then
                    r = CCur((signlong(r) And signlong(Pow2minusOne(32 - p))) * Pow2(p) + Int(CCur(r) / Pow2(32 - p)))
                ElseIf p = 0 Then
                    r = CCur(r)
                Else
                    r = CCur((signlong(r) And signlong(Pow2minusOne(-p))) * Pow2(32 + p) + Int(CCur(r) / Pow2(-p)))
                End If
                IsBinaryRotate = FastSymbol(A$, ")", True)
                Exit Function
            End If
        End If
    End If
End If
MissParam A$
End Function
Function IsSinRad(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxSin(rr)
    Else
        r = Sin(r)
        'If Abs(r) < 0.00000000000001 Then r = 0#
    End If
    IsSinRad = FastSymbol(A$, ")", True)

Else
    MissParam A$
End If
End Function
Function IsSin(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxSin(rr)
    Else
        r = Sin(r * 1.74532925199433E-02)
        If Abs(r) < 0.00000000000001 Then r = 0#
    End If
    IsSin = FastSymbol(A$, ")", True)

Else
    MissParam A$
End If
End Function
Function IsAbs(bstack As basetask, A$, r As Variant) As Boolean
Dim BI As BigInteger
If IsExpBig(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If bstack.lastobj Is Nothing Then
        If TypeOf r Is cxComplex Then
            Dim rr As cxComplex
            rr = r
            r = nMath2.cxAbs(rr)
        Else
            r = Abs(r)
        End If
    Else
        Set BI = bstack.lastobj
        Set bstack.lastobj = BI.bAbs()
    End If
    IsAbs = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function

Function IsCosRad(bstack As basetask, A$, r As Variant) As Boolean

If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxCos(rr)
    Else
    r = Cos(r)
    'If Abs(r) < 0.00000000000001 Then r = 0#
    End If
    IsCosRad = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function IsCos(bstack As basetask, A$, r As Variant) As Boolean

If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxCos(rr)
    Else
    r = Cos(r * 1.74532925199433E-02)
    If Abs(r) < 0.00000000000001 Then r = 0#
    End If
    IsCos = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If

End Function
Function IsTanRad(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxTan(rr)
    Else
    r = Sgn(r) * Tan(r)
    If Abs(r) < 1E-16 Then r = 0
    If Abs(r) < 1 And Abs(r) + 0.0000000000001 >= 1 Then r = Sgn(r)
    End If
    IsTanRad = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function IsTan(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxTan(rr)
    Else
    r = Sgn(r) * Tan(r * 1.74532925199433E-02)
    If Abs(r) < 1E-16 Then r = 0
    If Abs(r) < 1 And Abs(r) + 0.0000000000001 >= 1 Then r = Sgn(r)
    End If
    IsTan = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function IsAtanRad(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxAtan(rr)
    Else
        r = Atn(r)
    End If
    IsAtanRad = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function IsAtan(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxAtan(rr)
    Else
        r = Atn(r) * 180# / Pi
    End If
    IsAtan = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function IsLn(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxlog(rr)
    Else
        If r <= 0 Then
            MyErMacro A$, "Only > zero parameter", "Ìüíï >0 ðáñÜìåôñïò"
            IsLn = False: Exit Function
        Else
            r = Log(r)
        End If
    End If
    IsLn = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function IsLog(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If TypeOf r Is cxComplex Then
        Dim rr As cxComplex
        rr = r
        r = nMath2.cxLogX(rr, 10#)
    Else
    If r <= 0 Then
        MyErMacro A$, "Only > zero parameter", "Ìüíï >0 ðáñÜìåôñïò"
        IsLog = False: Exit Function
    Else
        r = Log(r) / 2.30258509299405
    End If
    End If
    IsLog = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function IsFreq(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            r = GetFrequency(CInt(r), CInt(p))
            IsFreq = FastSymbol(A$, ")", True)
        Else
            MissParam A$
        End If
    Else
        MissParam A$
    End If
Else
    MissParam A$
End If
End Function
Function IsSqrt(bstack As basetask, A$, r As Variant) As Boolean
Dim BI As BigInteger
If IsExpBig(bstack, A$, r, flatobject:=True, nostring:=True) Then
        If bstack.lastobj Is Nothing Then
        If TypeOf r Is cxComplex Then
            Dim rr As cxComplex
            rr = r
            r = nMath2.cxSqr(rr)
        Else
            If r < 0 Then
                negsqrt A$
                Exit Function
            End If
            
            r = Sqr(r)
        End If
    Else
        Set BI = bstack.lastobj
        If BI.bSgn < 0 Then
            negsqrt A$
            Exit Function
        End If
        Set bstack.lastobj = BI.IntSqr
    End If
    IsSqrt = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
End Function
Function GiveForm() As Form
If Form1.Visible Then
    Set GiveForm = Form1
Else
    Set GiveForm = Form3
End If
End Function
Function IsNumberD(A$, D As Double) As Boolean
Dim a1 As Long, r
If A$ <> "" Then
For a1 = 1 To Len(A$) + 1
Select Case Mid$(A$, a1, 1)
Case " ", ",", ChrW(160)
If a1 > 1 Then Exit For
Case Is = Chr(2)
If a1 = 1 Then Exit Function
Exit For
End Select
Next a1
If a1 > Len(A$) Then a1 = Len(A$) + 1
If ValidNumberOnly(A$, r, False) Then
    D = CDbl(r)
End If
A$ = Mid$(A$, a1)
IsNumberD = True
Else
IsNumberD = False
End If
End Function
Function IsNumberLabel2(A$, Label$, a1 As Long, ByVal LI As Long) As Boolean
Dim A2 As Long
If LI > 0 Then
A2 = a1
If a1 > LI Then Exit Function
If LI > 5 + A2 Then LI = 4 + A2
If Mid$(A$, a1, 1) Like "[0-9]" Then
Do While a1 <= LI
a1 = a1 + 1
If Not Mid$(A$, a1, 1) Like "[0-9]" Then Exit Do

Loop
Label$ = Mid$(A$, A2, a1 - A2)
IsNumberLabel2 = True
End If
End If
End Function
Function IsNumberLabel(A$, Label$) As Boolean
Dim a1 As Long, LI As Long, A2 As Long
LI = Len(A$)

If LI > 0 Then

a1 = MyTrimL(A$)

A2 = a1
If a1 > LI Then A$ = vbNullString: Exit Function
If LI > 5 + A2 Then LI = 4 + A2
If Mid$(A$, a1, 1) Like "[0-9]" Then
Do While a1 <= LI
a1 = a1 + 1
If Not Mid$(A$, a1, 1) Like "[0-9]" Then Exit Do

Loop
Label$ = Mid$(A$, A2, a1 - A2): A$ = Mid$(A$, a1)
IsNumberLabel = True
End If

End If
End Function
Function IsNumberQuery(A$, fr As Long, r As Double, lr As Long) As Boolean
Dim sg As Long, sng As Long, n$, ig$, DE$, sg1 As Long, ex$, rr As Double
' ti kanei to e$
If A$ = vbNullString Then IsNumberQuery = False: Exit Function
sg = 1
sng = fr - 1
    Do While sng < Len(A$)
    sng = sng + 1
    Select Case Mid$(A$, sng, 1)
    Case " ", "+", ChrW(160)
    Case "-"
    sg = -sg
    Case Else
    Exit Do
    End Select
    Loop
n$ = Mid$(A$, sng)

If val("0" + Mid$(A$, sng, 1)) = 0 And Left(Mid$(A$, sng, 1), sng) <> "0" And Left(Mid$(A$, sng, 1), sng) <> "." Then
IsNumberQuery = False

Else
'compute ig$
    If Mid$(A$, sng, 1) = "." Then
    ' no long part
    ig$ = "0"
    DE$ = "."

    Else
    Do While sng <= Len(A$)
        
        Select Case Mid$(A$, sng, 1)
        Case "0" To "9"
        ig$ = ig$ + Mid$(A$, sng, 1)
        Case "."
        DE$ = "."
        Exit Do
        Case Else
        Exit Do
        End Select
       sng = sng + 1
    Loop
    End If
    ' compute decimal part
    If Len(DE$) = 0 Then
    If Len(A$) >= sng& Then
    If InStr("EeÅå", Mid$(A$, sng&, 1)) > 0 Then
        fr = fr + 1
        DE$ = "."
        GoTo CONT1234
    End If
    End If
    Else
      sng = sng + 1
CONT1234:
        Do While sng <= Len(A$)
       
        Select Case Mid$(A$, sng, 1)
        Case " ", ChrW(160), vbTab
        If Not (sg1 And Len(ex$) = 1) Then
        Exit Do
        End If
        Case "0" To "9"
        If sg1 Then
        ex$ = ex$ + Mid$(A$, sng, 1)
        Else
        DE$ = DE$ + Mid$(A$, sng, 1)
        End If
        Case "E", "e", "Å", "å" ' ************check it
             If ex$ = vbNullString Then
               sg1 = True
        ex$ = "E"
        Else
        Exit Do
        End If
        
        Case "+", "-"
        If sg1 And Len(ex$) = 1 Then
         ex$ = ex$ + Mid$(A$, sng, 1)
        Else
        Exit Do
        End If
        Case Else
        Exit Do
        End Select
         sng = sng + 1
        Loop
        If sg1 Then
            If Len(ex$) < 3 Then
                If ex$ = "E" Then
                    ex$ = " "
                ElseIf ex$ = "E-" Or ex$ = "E+" Then
                    ex$ = "  "
                End If
            End If
        End If
    End If
    If ig$ = vbNullString Then
    IsNumberQuery = False
    lr = 1
    Else
    If sg < 0 Then ig$ = "-" + ig$
    Err.Clear
    On Error Resume Next
    n$ = ig$ + DE$ + ex$
    sng = Len(ig$ + DE$ + ex$)
    rr = val(ig$ + DE$ + ex$)
    If Err.Number > 0 Then
         lr = 0
    Else
        r = rr
       lr = sng - fr + 2
       IsNumberQuery = True
    End If
    
       
    
    End If
End If
End Function


Function IsNumberOnly(A$, fr As Long, r As Variant, lr As Long, Optional useRtypeOnly As Boolean = False, Optional usespecial As Boolean = False) As Boolean
Dim sg As Long, sng As Long, ig$, DE$, sg1 As Long, ex$, foundsign As Boolean, unsigned As Boolean, extendsign As Boolean
' ti kanei to e$
If A$ = vbNullString Then IsNumberOnly = False: Exit Function
sg = 1
If fr = 0 Then fr = 1
sng = fr - 1
    Do While sng < Len(A$)
    sng = sng + 1
    Select Case Mid$(A$, sng, 1)
    Case " ", ChrW(160), vbTab
    Case "+"
    foundsign = True
    Case "-"
    sg = -sg
    foundsign = True
    Case Else
    Exit Do
    End Select
    Loop
   
If LCase(Mid$(A$, sng, 2)) Like "0[x÷]" Then
here1234:
    If foundsign Then
        BadSignHex
        IsNumberOnly = False
        GoTo er111
    End If
    ig$ = vbNullString
    DE$ = vbNullString
    sng = sng + 1
    Do While MaybeIsSymbolNoSpace(Mid$(A$, sng + 1, 1), "[0-9A-Fa-f_]")
        If Mid$(A$, sng + 1, 1) <> "_" Then
        DE$ = DE$ + Mid$(A$, sng + 1, 1)
        sng = sng + 1
        If Len(DE$) = 16 Then Exit Do
        Else
        sng = sng + 1
        End If
    Loop
    sng = sng + 1
    sg = 1 ' no sign
    If LenB(DE$) = 0 Then
    BadLitHex
    IsNumberOnly = False
    GoTo er111
    End If
    If MaybeIsSymbolNoSpace(Mid$(A$, sng, 1), "[&%]") Then
        'If Mid$(a$, sng, 2) = "&&" Then
        '    sng = sng + 2
        'Else
            sng = sng + 1
        'End If
        extendsign = True
        If Mid$(A$, sng - 1, 1) = "%" Then
            usespecial = False
            ig$ = "&H" + Right$("000" + DE$, 4)
            r = 0
        ElseIf Mid$(A$, sng - 1, 2) = "&&" Then
            sng = sng + 1
            usespecial = False
           ' ig$ = "&H" + Right$("000000000000000" + DE$, 16)
           ig$ = "&H" + DE$
            extendsign = False
            r = cInt64(0)
        ElseIf Mid$(A$, sng - 1, 1) = "&" Then
            usespecial = False
            extendsign = False
            ig$ = "&H" + Right$("0000000" + DE$, 8)
            r = 0&
        End If
        DE$ = vbNullString
        If Not usespecial Then
        GoTo jump123
        End If
        GoTo conthere1
    ElseIf useRtypeOnly Then
        unsigned = True
        If MyIsObject(r) Then
        If TypeOf r Is BigInteger Then
            Set r = Module13.CreateBigInteger(DE$)
            DE$ = vbNullString
            GoTo contfinal
        Else
        
            Exit Function
        End If
        Else
        Select Case VarType(r)
        Case 20, vbDecimal
        ig$ = "&H" + Right$(DE$, 16)
        DE$ = vbNullString
        GoTo conthere1
        Case vbLong, vbCurrency, vbDouble, vbSingle
        ig$ = "&H" + Right$("0000000" + DE$, 8)
        DE$ = vbNullString
        GoTo conthere1
        Case vbByte
        ig$ = "&H" + Right$(DE$, 2)
        DE$ = vbNullString
        GoTo conthere1
        Case vbInteger, vbBoolean
        ig$ = "&H" + Right$(DE$, 4)
        DE$ = vbNullString
        GoTo conthere1
        Case vbDecimal
        ig$ = "&H" + Right$(DE$, 8)
        DE$ = vbNullString
        GoTo conthere1
        
        End Select
        End If
    End If
        If Len(DE$) > 8 Then
        
        DE$ = Right$("00000000" + DE$, 16)
        Else
        DE$ = Right$("00000000" + DE$, 8)
        End If
        'R = CDbl(UNPACKLNG(Left$(DE$, 4)) * 65536#) + CDbl(UNPACKLNG(Right$(DE$, 4)))
        If Len(DE$) <= 8 Then
        r = CCur(cInt64(CVar("&H" + DE$)))
       ' If R < 0 Then R = R + 4294967296@
        Else
        r = CDec(cInt64(CVar("&H" + DE$)))
        If r < 0 Then
            r = r + maxlonglong
        End If
        End If
        
        GoTo contfinal
ElseIf Mid$(A$, sng, 2) Like "&[hH]" Then
GoTo here1234
ElseIf val("0" + Mid$(A$, sng, 1)) = 0 And Left(Mid$(A$, sng, 1), sng) <> "0" And Left(Mid$(A$, sng, 1), sng) <> "." Then

IsNumberOnly = False

Else
'compute ig$
    If Mid$(A$, sng, 1) = "." Then
    ' no long part
    ig$ = "0"
    DE$ = "."

    Else
    Do While sng <= Len(A$)
        
        Select Case Mid$(A$, sng, 1)
        Case "0" To "9"
        ig$ = ig$ + Mid$(A$, sng, 1)
        Case "."
        DE$ = "."
        Exit Do
        Case Else
        Exit Do
        End Select
       sng = sng + 1
    Loop
    End If
    ' compute decimal part
        If Len(DE$) = 0 Then
    If Len(A$) > sng& Then
    If InStr("EeÅå", Mid$(A$, sng&, 1)) > 0 Then
    If InStr("1234567890+-", Mid$(A$, sng& + 1, 1)) > 0 Then
       ' fr = fr + 1
        DE$ = "."
        
        GoTo cont123
    End If
    End If
    End If
    Else
      sng = sng + 1
cont123:
        Do While sng <= Len(A$)
       
        Select Case Mid$(A$, sng, 1)
        Case " ", ChrW(160), vbTab
        If Not (sg1 And Len(ex$) = 1) Then
        Exit Do
        End If
        Case "0" To "9"
        If sg1 Then
        ex$ = ex$ + Mid$(A$, sng, 1)
        Else
        DE$ = DE$ + Mid$(A$, sng, 1)
        End If
        Case "E", "e", "Å", "å"  ' ************check it
            If ex$ = vbNullString Then
               sg1 = True
                ex$ = "E"
            Else
                Exit Do
            End If
        Case "+", "-"
            If sg1 And Len(ex$) = 1 Then
             ex$ = ex$ + Mid$(A$, sng, 1)
            Else
                Exit Do
            End If
        Case Else
            Exit Do
        End Select
        sng = sng + 1
        Loop
        If Len(ex$) < 3 Then
                If ex$ = "E" Then
                ex$ = "0"
                sng = sng + 1
                ElseIf ex$ = "E-" Or ex$ = "E+" Then
                ex$ = "00"
                sng = sng + 2
                End If
                End If
    End If
    If ig$ = vbNullString Then
    IsNumberOnly = False
    lr = 1
    Else
    If sg < 0 Then ig$ = "-" + ig$
    On Error GoTo er111
     If useRtypeOnly Then GoTo conthere1
    If sng <= Len(A$) Then
    If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
    Select Case Mid$(A$, sng, 1)
    Case "@"
    r = CDec(ig$ + DE$)
    sng = sng + 1
    Case "&"
    If Mid$(A$, sng + 1, 1) = "&" Then
        r = cInt64(ig$)
        sng = sng + 2
    Else
        r = CLng(ig$)
        sng = sng + 1
    End If
    Case "%"
    r = CInt(ig$)
    sng = sng + 1
    Case "~"
    r = CSng(ig$ + DE$ + ex$)
    sng = sng + 1
    Case "#"
    r = CCur(ig$ + DE$)
    sng = sng + 1
    Case "u", "U"
    Select Case LCase(Mid$(A$, sng, 2))
    Case "ub"
        r = CByte(ig$)
        sng = sng + 2
    Case "ud"
        r = CDate(ig$ + DE$)
        sng = sng + 2
    Case Else

        sng = sng + 1
        GoTo jump123
    End Select
    Case Else
    GoTo jump123
GoTo conthere
    End Select
    Else
conthere:
        If useRtypeOnly Then
conthere1:
        If usespecial Then
       If sng <= Len(A$) Then
            Select Case Mid$(A$, sng, 1)
            Case "@"
                r = CDec(0)
                sng = sng + 1
            Case "&"
                If Mid$(A$, sng + 1, 1) = "&" Then
                    r = cInt64(0)
                    sng = sng + 2
                Else
                    r = 0&
                    sng = sng + 1
                End If
            Case "~"
                r = 0!
                sng = sng + 1
            Case "#"
                r = 0@
                sng = sng + 1
            Case "%"
                r = 0
                sng = sng + 1
            
            Case "u", "U"
                Select Case LCase(Mid$(A$, sng + 1, 2))
                Case "ub"
                    r = CByte(0)
                    sng = sng + 2
                Case "ud"
                    r = CDate(0)
                    sng = sng + 2
                Case Else
                    sng = sng + 1
                End Select
        End Select
        End If
        End If
jump123:
         If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
         
        Select Case VarType(r)
        Case vbDecimal
        If Len(DE$) = 0 Then r = CDec(ig$) Else r = CDec(ig$ + DE$)
        If unsigned Then
        If r < 0 Then
            r = r + maxlonglong
        End If
        End If
        Case vbLong
        r = CLng(ig$)
        If extendsign Then
        If r < 65536 And r >= 32768 Then
            r = r + &HFFFF0000
        End If
        End If
        Case vbByte
        r = CByte(ig$)
        Case vbInteger
        r = CInt(ig$)
        Case vbSingle
        r = CSng(ig$ + DE$ + ex$)
        Case vbCurrency
        If Len(DE$) = 0 Then r = CDec(ig$) Else r = CDec(ig$ + DE$)
        If unsigned Then
        If r < 0 Then
            r = r + 2147483647@
        End If
        End If
        r = CCur(r)
        Case vbBoolean
        r = CBool(ig$ + DE$)
        Case 20
        r = cInt64(CVar(ig$))
        Case vbDate
        r = CDate(ig$ + DE$)
        Case Else
        If MyIsObject(r) Then
        r = ig$
        Else
        r = CDbl(ig$ + DE$ + ex$)
        End If
        
        
        End Select
        Else
        
        
        If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
        r = val(ig$ + DE$ + ex$)
        End If
    End If
contfinal:
    lr = sng - fr + 1
    
    IsNumberOnly = True
    Exit Function
    End If
End If
er111:
    lr = sng - fr + 1
    Err.Clear
Exit Function

End Function
Function IsNumberD2fix(A$, D As Variant, Optional noendtypes As Boolean = False, Optional exceptspecial As Boolean) As Boolean
' for inline stacitems
If VarType(D) = vbEmpty Then D = 0#
Dim a1 As Long
If A$ <> "" Then
For a1 = 1 To Len(A$) + 1
Select Case Mid$(A$, a1, 1)
Case " ", ChrW(160), vbTab
If a1 > 1 Then Exit For
Case Is = Chr(2)
If a1 = 1 Then Exit Function
Exit For
End Select
Next a1
If a1 > Len(A$) Then a1 = Len(A$) + 1
    If IsNumberOnly(A$, 1, D, a1, noendtypes, exceptspecial) Then
        A$ = Mid$(A$, a1)
        IsNumberD2fix = True
    ElseIf MaybeIsSymbol(A$, "ÁáØøTtFf") Then
        If Fast3Varl(A$, "ÁËÇÈÅÓ", 6, "ÁËÇÈÇÓ", 6, "TRUE", 4, 6) Then
            D = True
            IsNumberD2fix = True
        ElseIf Fast3Varl(A$, "ØÅÕÄÅÓ", 6, "ØÅÕÄÇÓ", 6, "FALSE", 5, 6) Then
            D = False
            IsNumberD2fix = True
        Else
            IsNumberD2fix = False
        End If
    Else
    IsNumberD2fix = False
    End If
Else
    IsNumberD2fix = False
End If

End Function

Function IsNumberD2(A$, D As Variant, Optional noendtypes As Boolean = False, Optional exceptspecial As Boolean) As Boolean
' for inline stacitems
If VarType(D) = vbEmpty Then D = 0#
Dim a1 As Long
If A$ <> "" Then
For a1 = 1 To Len(A$) + 1
Select Case Mid$(A$, a1, 1)
Case " ", ChrW(160), vbTab
If a1 > 1 Then Exit For
Case Is = Chr(2)
If a1 = 1 Then Exit Function
Exit For
End Select
Next a1
If a1 > Len(A$) Then a1 = Len(A$) + 1
    If IsNumberOnly(A$, 1, D, a1, noendtypes, exceptspecial) Then
        A$ = Mid$(A$, a1)
        IsNumberD2 = True
    ElseIf MaybeIsSymbol(A$, "ÁáØøTtFf") Then
        If Fast3Varl(A$, "ÁËÇÈÅÓ", 6, "ÁËÇÈÇÓ", 6, "TRUE", 4, 6) Then
            If VarType(D) = vbBoolean Then
            D = True
            Else
            D = D - 1
            End If
            IsNumberD2 = True
        ElseIf Fast3Varl(A$, "ØÅÕÄÅÓ", 6, "ØÅÕÄÇÓ", 6, "FALSE", 5, 6) Then
            
            IsNumberD2 = True
        Else
            IsNumberD2 = False
        End If
    Else
    IsNumberD2 = False
    End If
Else
    IsNumberD2 = False
End If

End Function

Function IsNumberD3(A$, fr As Long, a1 As Long) As Boolean
' for inline stacitems
Dim D As Double
If A$ <> "" Then
For a1 = fr To Len(A$) + 1
Select Case Mid$(A$, a1, 1)
Case " ", ChrW(160), vbTab
If a1 > fr Then Exit For
Case Is = Chr(2)
If a1 = fr Then Exit Function
Exit For
End Select
Next a1
If a1 > Len(A$) Then a1 = Len(A$) + 1
If IsNumberOnly(A$, fr, D, a1) Then
IsNumberD3 = True
ElseIf Fast3NoSpaceCheck(fr, A$, "ÁËÇÈÅÓ", 6, "ÁËÇÈÇÓ", 6, "TRUE", 4, 6) Then
D = True
IsNumberD3 = True
ElseIf Fast3NoSpaceCheck(fr, A$, "ØÅÕÄÅÓ", 6, "ØÅÕÄÇÓ", 6, "FALSE", 5, 6) Then
D = False
IsNumberD3 = True
Else
a1 = fr
IsNumberD3 = False
End If
Else
a1 = fr
IsNumberD3 = False
End If

End Function

Function IsNumberCheck(A$, r As Variant, Optional mydec$ = " ") As Boolean
Dim sng&, sg As Variant, ig$, DE$, sg1 As Boolean, ex$, s$
If mydec$ = " " Then mydec$ = "."
sg = 1
Do While sng& < Len(A$)
sng& = sng& + 1
Select Case Mid$(A$, sng&, 1)
Case "#"
    If Len(A$) > sng& Then
    If MaybeIsSymbolNoSpace(Mid$(A$, sng& + 1, 1), "[0-9A-Fa-f]") Then
    s$ = "0x00" + Mid$(A$, sng& + 1, 6)
    If Len(s$) < 10 Then Exit Function
        If IsNumberCheck(s$, r) Then
        If s$ <> "" Then
          
             
        Else
            s$ = Right$("00000000" + Mid$(A$, sng& + 1, 6), 8)
            A$ = Mid$(A$, sng& + 7)
   r = -(CDbl(UNPACKLNG(Right$(s$, 2)) * 65536#) + CDbl(UNPACKLNG(Mid$(s$, 5, 2)) * 256#) + CDbl(UNPACKLNG(Mid$(s$, 3, 2))))
   IsNumberCheck = True
   Exit Function
        End If
        End If
        Else
        
    End If
    Else

    '' out
    End If
    Exit Function
Case " ", "+", ChrW(160)
Case "-"
sg = -sg
Case Else
Exit Do
End Select
Loop
A$ = Mid$(A$, sng&)
sng& = 1
If val("0" + Mid$(Replace(A$, mydec$, "."), sng&, 1)) = 0 And Left(Mid$(A$, sng&, 1), sng&) <> "0" And Left(Mid$(A$, sng&, 1), sng&) <> mydec$ Then
IsNumberCheck = False
Else

    If Mid$(A$, sng&, 1) = mydec$ Then

    ig$ = "0"
    DE$ = mydec$
    ElseIf LCase(Mid$(A$, sng&, 2)) Like "0[x÷]" Then
    ig$ = "0"
    DE$ = "0x"
  sng& = sng& + 1
Else
    Do While sng& <= Len(A$)
        
        Select Case Mid$(A$, sng&, 1)
        Case "0" To "9"
        ig$ = ig$ + Mid$(A$, sng&, 1)
        Case mydec$
        DE$ = mydec$
        Exit Do
        Case Else
        Exit Do
        End Select
       sng& = sng& + 1
    Loop
    End If
    ' compute decimal part
    If Len(DE$) = 0 Then
    If Len(A$) > sng& Then
    If InStr("EeÅå", Mid$(A$, sng&, 1)) > 0 Then
    If InStr("1234567890+-", Mid$(A$, sng& + 1, 1)) > 0 Then
        DE$ = mydec$
        GoTo cont123
    End If
    End If
    End If
    Else
      sng& = sng& + 1
cont123:
        Do While sng& <= Len(A$)
       
        Select Case Mid$(A$, sng&, 1)
        Case " ", ChrW(160), vbTab
        If Not (sg1 And Len(ex$) = 1) Then
        Exit Do
        End If
        Case "A" To "D", "a" To "d", "F", "f"
        If Left$(DE$, 2) = "0x" Then
        DE$ = DE$ + Mid$(A$, sng&, 1)
        End If
        Case "0" To "9"
        If sg1 Then
        ex$ = ex$ + Mid$(A$, sng&, 1)
        Else
        DE$ = DE$ + Mid$(A$, sng&, 1)
        End If
        Case "E", "e"
         If Left$(DE$, 2) = "0x" Then
         DE$ = DE$ + Mid$(A$, sng&, 1)
         Else
              If ex$ = vbNullString Then
               sg1 = True
        ex$ = "E"
        Else
        Exit Do
        End If
        End If
        Case "Å", "å"
 If ex$ = vbNullString Then
          sg1 = True
        ex$ = "E"
        Else
        Exit Do
        End If
        
        Case "+", "-"
        If sg1 And Len(ex$) = 1 Then
         ex$ = ex$ + Mid$(A$, sng&, 1)
        Else
        Exit Do
        End If
        Case Else
        Exit Do
        End Select
         sng& = sng& + 1
        Loop
        If Len(ex$) < 3 Then
                If ex$ = "E" Then
                ex$ = "0"
                sng = sng + 1
                ElseIf ex$ = "E-" Or ex$ = "E+" Then
                ex$ = "00"
                sng = sng + 2
                End If
                End If
    End If
    If ig$ = vbNullString Then
    IsNumberCheck = False
    Else

    If Left$(DE$, 2) = "0x" Then

            If Mid$(DE$, 3) = vbNullString Then
            r = 0
            Else
            DE$ = Right$("00000000" + Mid$(DE$, 3), 8)
            r = CDbl(UNPACKLNG(Left$(DE$, 4)) * 65536#) + CDbl(UNPACKLNG(Right$(DE$, 4)))
            End If
    Else
        If sg < 0 Then ig$ = "-" + ig$
                   On Error Resume Next
                        If ex$ <> "" Then
                        If Len(ex$) < 3 Then
                                If ex$ = "E" Then
                                ex$ = "0"
                                ElseIf ex$ = "E-" Or ex$ = "E+" Then
                                ex$ = "00"
                                End If
                                End If
                               If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                               If val(Mid$(ex$, 2)) > 308 Or val(Mid$(ex$, 2)) < -324 Then
                               
                                   r = val(ig$ + DE$)
                                   sng = sng - Len(ex$)
                                   ex$ = vbNullString
                                   
                               Else
                                   r = val(ig$ + DE$ + ex$)
                               End If
                           Else
                       If sng <= Len(A$) Then
            Select Case Asc(Mid$(A$, sng, 1))
            Case 64
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CDec(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                r = val(ig$ + DE$)
                End If
            Case 35
            Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CCur(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                r = val(ig$ + DE$)
                End If
           Case 37
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CInt(ig$)
                If Err.Number = 6 Then
                Err.Clear
                r = val(ig$)
                End If
           Case 38
               If Mid$(A$, sng + 1, 1) = "&" Then
                    r = cInt64(ig$)
                    sng = sng + 1
                    Mid$(A$, sng, 2) = "  "
                Else
                    r = CLng(ig$)
                    Mid$(A$, sng, 1) = " "
                End If
                If Err.Number = 6 Then
                    Err.Clear
                    r = val(ig$)
                End If
            Case 126
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CSng(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                r = val(ig$ + DE$)
                End If
            Case Else
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                r = val(ig$ + DE$)
            End Select
            Else
            If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
            r = val(ig$ + DE$)
            End If
                           End If
                     If Err.Number = 6 Then
                         If Len(ex$) > 2 Then
                             ex$ = Left$(ex$, Len(ex$) - 1)
                             sng = sng - 1
                             Err.Clear
                             If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                             r = val(ig$ + DE$ + ex$)
                             If Err.Number = 6 Then
                                 sng = sng - Len(ex$)
                                 If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                                  r = val(ig$ + DE$)
                             End If
                         End If
                       MyEr "Error in exponet", "ËÜèïò óôïí åêèÝôç"
                       IsNumberCheck = False
                       Exit Function
                     End If
           
         End If
           A$ = Mid$(A$, sng&)
           IsNumberCheck = True
End If
End If
End Function
Function utf8encode(A$) As String
Dim bOut() As Byte, lPos As Long
If LenB(A$) = 0 Then Exit Function
bOut() = Utf16toUtf8(A$)
lPos = UBound(bOut()) + 1
If lPos Mod 2 = 1 Then
    utf8encode = StrConv(String$(lPos, Chr(0)), vbFromUnicode)
Else
    utf8encode = String$((lPos + 1) \ 2, Chr(0))
    End If
    CopyMemory ByVal StrPtr(utf8encode), bOut(0), LenB(utf8encode)
End Function
Function utf8decode(A$) As String
Dim b() As Byte, BLen As Long, WChars As Long
BLen = LenB(A$)
If BLen = 0 Then Exit Function
            ReDim b(0 To BLen - 1)
            CopyMemory b(0), ByVal StrPtr(A$), BLen
            WChars = MultiByteToWideChar(65001, 0, b(0), (BLen), 0, 0)
            utf8decode = space$(WChars)
            MultiByteToWideChar 65001, 0, b(0), (BLen), StrPtr(utf8decode), WChars
End Function

Public Function ideographs(C$) As Boolean
Dim code As Long
If C$ = vbNullString Then Exit Function
code = AscW(C$)  '
ideographs = (code And &H7FFF) >= &H4E00 Or (-code > 24578) Or (code >= &H3400& And code <= &HEDBF&) Or (code >= -1792 And code <= -1281)
End Function
Public Function nounder32(C$) As Boolean
nounder32 = AscW(C$) > 31 Or AscW(C$) < 0
End Function

Function GetImageX(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray, usehandler As mHandler
GetImageX = False
If IsExp(bstack, A$, r) Then
      GetImageX = FastSymbol(A$, ")", True)
        If Not bstack.lastobj Is Nothing Then
           If TypeOf bstack.lastobj Is mHandler Then
              Set usehandler = bstack.lastobj
              Set bstack.lastobj = Nothing
              If usehandler.T1 = 2 Then
                  If usehandler.objref.ReadImageSizeX(r) Then
                  r = bstack.Owner.ScaleX(r, 3, 1)
                          Set usehandler = Nothing
                      Exit Function
                  End If
              End If
           End If
        End If
            noImageInBuffer A$
            GetImageX = False
            r = 0#
            Set bstack.lastobj = Nothing
Else
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) <> "String" Then MissString: Exit Function
                If Left$(var(w1), 4) = "cDIB" And Len(var(w1)) > 12 Then
                    r = cDIBwidth1(var(w1)) * DXP
                    
                    GetImageX = FastSymbol(A$, ")", True)
                Else
                    noImage A$
                    Exit Function
                End If
            Else
                MissFuncParameterStringVarMacro A$
            End If
        ElseIf w1 = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                If Not pppp.IsStringItem(w2) Then MissString: Exit Function
                Dim sV As Variant
                pppp.SwapItem w2, sV
          
                If Left$(sV, 4) = "cDIB" And Len(sV) > 12 Then
                    r = cDIBwidth1(sV) * DXP
                    
                    pppp.SwapItem w2, sV
                    GetImageX = FastSymbol(A$, ")", True)
                Else
                    pppp.SwapItem w2, sV
                    noImage A$
                End If
    
        Else
            MissParam A$
        End If
End If
End If
    
 
End Function
Function GetImageY(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray, usehandler As mHandler
GetImageY = False
If IsExp(bstack, A$, r) Then
      GetImageY = FastSymbol(A$, ")", True)
        If Not bstack.lastobj Is Nothing Then
           If TypeOf bstack.lastobj Is mHandler Then
              Set usehandler = bstack.lastobj
              Set bstack.lastobj = Nothing
              If usehandler.T1 = 2 Then
                  If usehandler.objref.ReadImageSizeY(r) Then
                  r = bstack.Owner.ScaleY(r, 3, 1)
                          Set usehandler = Nothing
                      Exit Function
                  End If
              End If
           End If
        End If
            noImageInBuffer A$
            GetImageY = False
            r = 0#
            Set bstack.lastobj = Nothing
Else
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) <> "String" Then MissString: Exit Function
                If Left$(var(w1), 4) = "cDIB" And Len(var(w1)) > 12 Then
                    r = cDIBheight1(var(w1)) * DXP
                    
                    GetImageY = FastSymbol(A$, ")", True)
                Else
                    noImage A$
                    Exit Function
                End If
            Else
                MissFuncParameterStringVarMacro A$
            End If
        ElseIf w1 = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                If Not pppp.IsStringItem(w2) Then MissString: Exit Function
                Dim sV As Variant
                pppp.SwapItem w2, sV
          
                If Left$(sV, 4) = "cDIB" And Len(sV) > 12 Then
                    r = cDIBheight1(sV) * DXP
                    
                    pppp.SwapItem w2, sV
                    GetImageY = FastSymbol(A$, ")", True)
                Else
                    pppp.SwapItem w2, sV
                    noImage A$
                End If
    
        Else
            MissParam A$
        End If
End If
End If
    
 
End Function
Function GetImageXpixels(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray, usehandler As mHandler
GetImageXpixels = False
If IsExp(bstack, A$, r) Then
      GetImageXpixels = FastSymbol(A$, ")", True)
        If Not bstack.lastobj Is Nothing Then
           If TypeOf bstack.lastobj Is mHandler Then
              Set usehandler = bstack.lastobj
              Set bstack.lastobj = Nothing
              If usehandler.T1 = 2 Then
                  If usehandler.objref.ReadImageSizeX(r) Then
                  
                          Set usehandler = Nothing
                      Exit Function
                  End If
              End If
           End If
        End If
            noImageInBuffer A$
            GetImageXpixels = False
            r = 0#
            Set bstack.lastobj = Nothing
Else
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) <> "String" Then MissString: Exit Function
                If Left$(var(w1), 4) = "cDIB" And Len(var(w1)) > 12 Then
                    r = cDIBwidth1(var(w1))
                    
                    GetImageXpixels = FastSymbol(A$, ")", True)
                Else
                    noImage A$
                    Exit Function
                End If
            Else
                MissFuncParameterStringVarMacro A$
            End If
        ElseIf w1 = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                If Not pppp.IsStringItem(w2) Then MissString: Exit Function
                Dim sV As Variant
                pppp.SwapItem w2, sV
          
                If Left$(sV, 4) = "cDIB" And Len(sV) > 12 Then
                    r = cDIBwidth1(sV)
                    
                    pppp.SwapItem w2, sV
                    GetImageXpixels = FastSymbol(A$, ")", True)
                Else
                    pppp.SwapItem w2, sV
                    noImage A$
                End If
    
        Else
            MissParam A$
        End If
End If
End If
    
 
End Function
Function GetImageYpixels(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray, usehandler As mHandler
GetImageYpixels = False
If IsExp(bstack, A$, r) Then
      GetImageYpixels = FastSymbol(A$, ")", True)
        If Not bstack.lastobj Is Nothing Then
           If TypeOf bstack.lastobj Is mHandler Then
              Set usehandler = bstack.lastobj
              Set bstack.lastobj = Nothing
              If usehandler.T1 = 2 Then
                  If usehandler.objref.ReadImageSizeY(r) Then
                  
                          Set usehandler = Nothing
                      Exit Function
                  End If
              End If
           End If
        End If
            noImageInBuffer A$
            GetImageYpixels = False
            r = 0#
            Set bstack.lastobj = Nothing
Else
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) <> "String" Then MissString: Exit Function
                If Left$(var(w1), 4) = "cDIB" And Len(var(w1)) > 12 Then
                    r = cDIBheight1(var(w1))
                    
                    GetImageYpixels = FastSymbol(A$, ")", True)
                Else
                    noImage A$
                    Exit Function
                End If
            Else
                MissFuncParameterStringVarMacro A$
            End If
        ElseIf w1 = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                If Not pppp.IsStringItem(w2) Then MissString: Exit Function
                Dim sV As Variant
                pppp.SwapItem w2, sV
          
                If Left$(sV, 4) = "cDIB" And Len(sV) > 12 Then
                    r = cDIBheight1(sV)
                    
                    pppp.SwapItem w2, sV
                    GetImageYpixels = FastSymbol(A$, ")", True)
                Else
                    pppp.SwapItem w2, sV
                    noImage A$
                End If
    
        Else
            MissParam A$
        End If
End If
End If
    
 
End Function

Function enthesi(bstack As basetask, rest$) As String
'first is the string "label {0} other {1}
Dim counter As Long, pat$, Final$, pat1$, pl1 As Long, pl2 As Long, pl3 As Long
Dim q$, p As Variant, P1 As Integer, pd$, insertdot As Boolean, threeparam As Boolean
Dim hasnumeric As Boolean
If IsExp(bstack, rest$, p, , True) Then
    If MemInt(VarPtr(p)) = vbString Then SwapString2Variant Final$, p: p = Empty: GoTo cont1
    MissStringExpr
    Exit Function
End If
If IsStrExp(bstack, rest$, Final$, False) Then
cont1:
  If FastSymbol(rest$, ",") Then
    insertdot = False
    threeparam = False
    Do
                hasnumeric = False
                pl2 = 1
                    pat$ = "{" & (counter)
                   pat1$ = pat$ + ":"
                    pat$ = pat$ + "}"
                    If IsExp(bstack, rest$, p) Then
                    q$ = ""
                    If Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is BigInteger Then
                            p = bstack.lastobj.ToString
                            insertdot = bstack.lastobj.OutputBase = 10
                        End If
                        Set bstack.lastobj = Nothing
                    End If
                    If myVarType(p, vbString) Then
                        SwapString2Variant q$, p
                    ElseIf MemInt(VarPtr(p)) = vbBoolean Then
                        q$ = Format$(p, DefBooleanString)
                    ElseIf MemInt(VarPtr(p)) = vbDate Then
                        q$ = FormatDateWithLocale(GetlocaleString2(&H1F, (Clid)), CDate(p), (Clid))
                        p = ""
                    Else
                    hasnumeric = True
                    End If

again1:
                    pl2 = InStr(pl2, Final$, pat1$)
                    If pl2 = 0 Then
                        If Len(q$) > 0 And MemInt(VarPtr(p)) = vbString Then
                        SwapString2Variant q$, p
                        End If
                    End If
again11:
                    If pl2 > 0 Then
                    pl1 = InStr(pl2, Final$, "}")
                    If Mid$(Final$, pl2 + Len(pat1$), 1) = ":" Then
                    P1 = 0
                    pl3 = val(Mid$(Final$, pl2 + Len(pat1$) + 1) + "}")
                    Else
                '    P1 = val("0" + Mid$(Final$, pl2 + Len(pat1$)))
                    If Mid$(Final$, pl2 + Len(pat1$), 1) = "-" Then
                        P1 = val("-0" + Mid$(Final$, pl2 + Len(pat1$) + 1))
                    Else
                        P1 = val("0" + Mid$(Final$, pl2 + Len(pat1$)))
                        
                    End If
                    pl3 = pl2 + Len(pat1$) + Len(LTrim(str$(P1)))
                    If Mid$(Final$, pl3, 1) = ":" Then
                        pl3 = val(Mid$(Final$, pl2 + Len(pat1$) + 1 + Len(LTrim(str$(P1)))) + "}")
                        threeparam = True
                    Else
                        pl3 = 0
                    End If
                    
                        If P1 < 0 Then
                        
                        If pl3 = 0 Then pl3 = P1
                            P1 = 0
                        ElseIf pl3 = 0 And Not insertdot Then
                        If pl3 = 0 Then
                            If Not hasnumeric Then pl3 = P1 Else p = Round(p, P1)
                        End If
                            P1 = 0
                        End If
                        
                        
                        
                    End If
                    If q$ = "" Then
                        Select Case MemInt(VarPtr(p))
                        Case vbLong, vbInteger, vbByte, 20
                            If P1 > 0 Then pd$ = Format$(p, String$(P1, "0")) Else pd$ = CStr(p)
                        Case vbString
                            pd$ = LTrim$(p)
                        Case vbDouble, vbSingle
                            pd$ = LTrim$(str(p))
                            If InStr(pd$, "E") > 0 Then
                                GoTo cont2234
                            ElseIf InStr(pd$, "e") > 0 Then '' we can change e to greek å
cont2234:
                                If threeparam Then
                                pd$ = Format$(p, "0." + String$(P1, "0") + "E+####")
                                Else
                                
                                pd$ = Format$(p, "0." + String$(Abs(pl3) \ 4, "0") + "E+####")

                                End If
                                If Not NoUseDec Then
                                   If Not OverideDec Then
                                        pd$ = Replace$(pd$, GetDeflocaleString(LOCALE_SDECIMAL), NowDec$)
                                    ElseIf GetDeflocaleString(LOCALE_SDECIMAL) <> NowDec$ Then
                                        pd$ = Replace$(pd$, GetDeflocaleString(LOCALE_SDECIMAL), NowDec$)
                                    End If
                                End If
                            Else
                                GoTo cont5534
                            End If
                        Case Else
cont5534:
                            
                            If threeparam Then
                                If P1 < 0 Then P1 = -P1
                                If P1 > 28 Then P1 = 28
                                p = MyRound(p, P1)
                                If P1 = 0 Then
                                    pd$ = Format$(p, "0")
                                Else
                                    pd$ = Format$(p, "0." + String$(P1, "0"))
                                End If
                                If Not NoUseDec Then
                                   If Not OverideDec Then
                                        pd$ = Replace$(pd$, GetDeflocaleString(LOCALE_SDECIMAL), NowDec$)
                                    ElseIf GetDeflocaleString(LOCALE_SDECIMAL) <> NowDec$ Then
                                        pd$ = Replace$(pd$, GetDeflocaleString(LOCALE_SDECIMAL), NowDec$)
                                    End If
                                End If
                                If InStr(pd$, ".") > 0 Then
                                    If NoUseDec Then
                                        pd$ = Replace$(pd$, ".", NowDec$)
                                    End If
                                End If
                            Else
                                pd$ = fixthis(p)
                            End If
                        End Select
                    Else
                        pd$ = ""
                        
                        If P1 > 0 And insertdot Then
                        If Len(q$) < P1 + 1 Then q$ = "0" + String$(P1 - Len(q$), "0") + q$
                        pd$ = Left$(q$, Len(q$) - P1) + NowDec + Right$(q$, P1)
                        Else
                        SwapStrings q$, pd$
                        End If
                    End If
                        If pl3 <> 0 Then
                            If pl3 > 0 Then
                                pd$ = Left$(pd$ + space$(pl3), pl3)
                            Else
                                pd$ = Right$(space$(Abs(pl3)) + pd$, Abs(pl3))
                            End If
                        End If

                    Final$ = Replace$(Final$, Mid$(Final$, pl2, pl1 - pl2 + 1), pd$)
                    pl2 = InStr(pl2, Final$, pat1$)
                    If pl2 > 0 Then GoTo again11
                    If InStr(Final$, pat$) > 0 Then GoTo cont7747
                Else
                    
cont7747:
                    Select Case MemInt(VarPtr(p))
                    Case vbLong, vbInteger, vbByte, 20
                        pd$ = CStr(p)
                    
                    Case vbString
                        pd$ = LTrim$(p)
                        Case vbBoolean
                            pd$ = Format$(p, DefBooleanString)
                        Case vbDate
                            pd$ = p
                        Case Else
                            pd$ = fixthis(p)
                        End Select
                    
                        Final$ = Replace$(Final$, pat$, pd$)
                        If pl2 = 0 Then
                        pl2 = InStr(Final$, pat1$)
                        Else
                        pl2 = InStr(pl2, Final$, pat1$)
                        End If
                        If pl2 > 0 Then GoTo again11
                    
                        End If
                        If Not FastSymbol(rest$, ",") Then Exit Do
                    
                    ElseIf IsStrExp(bstack, rest$, q$, True) Then
fromboolean:
                        Final$ = Replace$(Final$, pat$, q$)
AGAIN0:
                    pl2 = InStr(pl2, Final$, pat1$)
                      If pl2 > 0 Then
                       pl1 = InStr(pl2, Final$, "}")
                       pl3 = val(Mid$(Final$, pl2 + Len(pat1$)) + "}")
                       If pl3 <> 0 Then
                    If pl3 > 0 Then
                        pd$ = Left$(q$ + space$(pl3), pl3)
                        Else
                        pd$ = Right$(space$(Abs(pl3)) + q$, Abs(pl3))
                        End If
                  End If
                        Final$ = Replace$(Final$, Mid$(Final$, pl2, pl1 - pl2 + 1), pd$)
                        GoTo AGAIN0
                      End If
                        If Not FastSymbol(rest$, ",") Then Exit Do
                    Else
                        Exit Do
                    End If
                    counter = counter + 1
    Loop
    Else
    enthesi = EscapeStrToString(Final$)
    Exit Function
    End If
End If
enthesi = Final$
End Function

Public Function GetDeflocaleString(ByVal this As Long) As String
    On Error GoTo 1234
    Dim Buffer As String, ret&, r&
    Buffer = String$(514, 0)
    ret = GetLocaleInfoW(0, this, StrPtr(Buffer), Len(Buffer))
    GetDeflocaleString = Left$(Buffer, ret - 1)
1234:
End Function
Function RetM2000array(var As Variant) As Variant
Dim Ar As New mArray, v(), manydim As Long, probe As Long, probelow As Long
Dim j As Long
v() = var
On Error GoTo ma100
For j = 1 To 60
    probe = UBound(v, j)
    If Err Then Exit For
Next j
manydim = j - 1
On Error Resume Next
For j = manydim To 1 Step -1
    
    probe = UBound(v, j)
    If Err Then Exit For
    probelow = LBound(v, j)
    Ar.PushDim probe - probelow + 1
Next j
Ar.PushEnd
Ar.RevOrder = True
Ar.CopySerialize v()
ma100:
Set RetM2000array = Ar

End Function

Public Sub DisableTargets(j() As target, ByVal myl As Long)
Dim iu&, id&, I&
iu& = LBound(j())
id& = UBound(j())
For I& = iu& To id&
 If j(I&).layer = myl Then j(I&).Enable = False
Next I&
End Sub
Function BoxTarget(DSTACK As basetask, ByVal xl&, ByVal yl&, ByVal b As Long, ByVal f As Long, ByVal Tag$, ByVal id&, ByVal COM$, XXT&, YYT&, LineSpace&) As target
Dim X&, Y&, D As Object
Dim half As Long
Set D = DSTACK.Owner
Dim prive As basket
prive = players(GetCode(D))
With prive

X& = .curpos
Y& = .currow
xl& = xl& + X&


yl& = yl& + Y& - 1
half = 1 - (yl& - Y + 1) Mod 2
With BoxTarget
.SZ = prive.SZ
.Comm = COM$
.id = id&
.Tag = Tag$
.lX = X&
.lY = Y&
.tx = xl& - 1
.ty = yl&
.back = b
.fore = f
.barC = &H81000000
.Enable = True
.pen = prive.mypen
.Xt = XXT&
.Yt = YYT&
.sUAddTwipsTop = prive.uMineLineSpace
.Vertical = 0
.topval = 0
.botval = 0
.imagesize = 80
If D.Name = "DIS" Then
.layer = 0
ElseIf D.Name = "Form1" Then
.layer = -1
ElseIf D.Name = "dSprite" Then
.layer = D.Index
Else
.layer = GetCode(D)
End If
End With
If f <> &H81000000 Then BoxBigNew D, prive, xl& - 1, yl&, f
If b <> &H81000000 Then BoxColorNew D, prive, xl& - 1, yl&, b
If id& < 100 Then
    Tag$ = Left$(Tag$, xl& - X&)
    If Tag$ <> "" Then
    
    Select Case id& Mod 10
    Case 4, 5, 6
    Y& = (yl& + Y&) \ 2
    Case 7, 8, 9
    Y& = yl&
    Case Else
    End Select
    Select Case id& Mod 10
    Case 2, 5, 8
    X& = (xl& + X& - Len(Tag$)) \ 2
    Case 3, 6, 9
    X& = xl& - Len(Tag$)
    Case Else
    End Select
    If (id& Mod 10) > 0 Then
    LCTbasket D, prive, Y&, X&
    D.FontTransparent = True
        If half > 0 Then
    D.currentY = D.currentY + prive.Yt \ 2
    End If
    PlainBaSket D, prive, Tag$, True, True
    LCTbasket D, prive, BoxTarget.lY, BoxTarget.lX
    End If
    End If
Else
    If Tag$ <> "" Then
    id& = id& Mod 100
    Select Case id& Mod 10
    Case 4, 5, 6
    Y& = (yl& + Y&) \ 2
    Case 7, 8, 9
    Y& = yl&
    half = 0
    Case Else
    half = 0
    End Select
    f = 3
    Select Case id& Mod 10
    Case 2, 5, 8
    f = 2
    Case 3, 6, 9
    f = 1
    Case Else
    End Select
    
    If (id& Mod 10) > 0 Then
    LCTbasket D, prive, Y&, X&
    D.FontTransparent = True
    D.currentX = D.currentX - dv15 * 2
    If half > 0 Then
    D.currentY = D.currentY + prive.Yt \ 2
    End If
    wwPlain2 DSTACK, prive, Tag$, xl& - X&, 10000, , True, f, , , True
    LCTbasket D, prive, BoxTarget.lY, BoxTarget.lX
    End If
End If
    
End If
End With
End Function
Private Function MyMod(r1, po) As Variant
MyMod = r1 - Fix(r1 / po) * po
End Function
Sub SetTmpPath()
     strTemp = mylcasefILE(GetTempPathgg)
End Sub
Sub dset()
 If strTemp = vbNullString Then SetTmpPath
' for mcd
Dim CD As String, dummy As Long, q$

userfiles = GetSpecialfolder(CLng(26)) + "\M2000"
AddDirSep userfiles
If Not isdir(userfiles) Then
MkDir userfiles
End If

mcd = userfiles
If DefaultDec$ <> "" Then
again111:
    DefaultDec$ = GetDeflocaleString(LOCALE_SDECIMAL)
    If NowDec$ <> "" Then
    ElseIf OverideDec Then
    NowDec$ = GetlocaleString(LOCALE_SDECIMAL)
    NowThou$ = GetlocaleString(LOCALE_STHOUSAND)
    Else
    NowDec$ = DefaultDec$
    NowThou$ = GetDeflocaleString(LOCALE_STHOUSAND)
    End If
CheckDec
ElseIf DefaultDec$ <> GetDeflocaleString(LOCALE_SDECIMAL) Then
GoTo again111

End If

End Sub

Public Sub CheckDec()
If mNoUseDec Then
    OverideDec = False
    NowDec$ = GetDeflocaleString(LOCALE_SDECIMAL)
    If GetlocaleString(LOCALE_SDECIMAL) <> NowDec$ Then
        NoUseDec = False
        OverideDec = True
        NowDec$ = GetlocaleString(LOCALE_SDECIMAL)
        NowThou$ = GetlocaleString(LOCALE_STHOUSAND)
    Else
        NoUseDec = True
        NowDec$ = GetlocaleString(LOCALE_SDECIMAL)
        NowThou$ = GetlocaleString(LOCALE_STHOUSAND)
    End If
Else
    NowDec$ = GetlocaleString(LOCALE_SDECIMAL)
    NowThou$ = GetlocaleString(LOCALE_STHOUSAND)
    
    NoUseDec = GetDeflocaleString(LOCALE_SDECIMAL) = NowDec$
    OverideDec = NowDec$ = "."
End If
End Sub

Function ProcEnumGroup(bstack As basetask, rest$, Optional Glob As Boolean = False) As Boolean

Dim s$, w1$, v As Long, enumvalue As Long, myenum As Enumeration, mh As mHandler, V1 As Long, I As Long
Dim s1$, badd As Byte, lasttype, feed, w2$, usehandler As mHandler, myother As Enumeration
Dim gr As Boolean, fromvar As Long, j As Long
fromvar = varhash.count
enumvalue = 0#
lasttype = enumvalue
badd = CByte(1)
feed = enumvalue
If FastPureLabel(rest$, w1$, , , , , , gr) = 1 Then
    v = globalvar(bstack.GroupName + myUcase(w1$, gr), v, , Glob)
    Set myenum = New Enumeration
    myenum.EnumName = w1$
Else
    MyEr "No proper name for enumeration", "ìç êáíïíéêü üíïìá ãéá áðáñßèìçóç"
    Exit Function
End If
If FastSymbol(rest$, "{") Then
    s$ = block(rest$)
    Do
        If FastSymbol(s$, vbCrLf, , 2) Then
            While FastSymbol(s$, vbCrLf, , 2)
            Wend
        ElseIf FastPureLabel(s$, w1$, , , , , , gr) = 1 Then
            w2$ = myUcase(w1$, gr)
            If GetVar(bstack, bstack.GroupName + w2$, j) Then
                If j <= fromvar Then
                    If Typename(var(j)) = "mHandler" Then
                        Set usehandler = var(j)
                        If usehandler.T1 = 4 Then
                            Set myother = usehandler.objref
                            Set usehandler = Nothing
                            If myUcase(myother.EnumName, True) = w2$ Then
                                ' just copy the names from other enum here
                                For j = 0 To myother.count - 1
                                    myother.Index = j
                                    If AssignTypeNumeric(enumvalue + badd, VarType(lasttype)) Then
                                        enumvalue = enumvalue + badd
                                    End If
                                    feed = myother.Value
                                    If MyIsNumeric(feed) Then
                                        lasttype = feed
                                        enumvalue = feed
                                    End If
                                    myenum.addone myother.KeyToString, feed
                                Next j
                                ProcEnumGroup = True
                                GoTo conthere
                            End If
                        End If
                    End If
                    MyEr "name " + w1$ + " exist", "ôï üíïìá " + w1$ + " õðÜñ÷åé"
                    If fromvar < varhash.count Then
                        varhash.ReduceHash fromvar, var()
                    End If
                    ProcEnumGroup = False
                    Exit Function
                End If
            End If
            If FastSymbol(s$, "=") Then
                If IsExp(bstack, s$, enumvalue, , True) Then
                    feed = enumvalue
                    If MyIsNumeric(feed) Then lasttype = feed
                Else
                   'MyEr "No String allowed as enumeration value", "Äåí åðéôñÝðåôáé áëöáñéèìçôéêü ãéá ôéìÞ áðáñéèìçôÞ"
                   If IsStrExp(bstack, s$, s1$, False) Then
                       If AssignTypeNumeric(enumvalue + badd, VarType(lasttype)) Then
                           enumvalue = enumvalue + badd
                       Else
                           Exit Function
                       End If
                       feed = CVar(s1$)
                   Else
                       Exit Function
                   End If
                End If
            ElseIf AssignTypeNumeric(enumvalue + badd, VarType(lasttype)) Then
                enumvalue = enumvalue + badd
                feed = enumvalue
            Else
                Exit Function
            End If
            myenum.addone w1$, feed
            Set mh = New mHandler
            Set mh.objref = myenum
            mh.T1 = 4
            mh.ReadOnly = True
            mh.index_cursor = feed
            mh.index_start = myenum.count - 1
            V1 = globalvar(bstack.GroupName + myUcase(w1$, gr), V1, , Glob)
            Set var(V1) = mh
            ProcEnumGroup = True
        Else
            Exit Do
        End If
conthere:
        If FastSymbol(s$, ",") Then ProcEnumGroup = False
    Loop
    If V1 > v Then
        Set var(v) = var(V1)
    Else
        If myenum.count = 0 Then
            MyEr "Empty Enumeration", "¢äåéá Áðáñßèìçóç": Exit Function
        Else
            Set mh = New mHandler
            Set mh.objref = myenum
            myenum.Index = myenum.count - 1
            mh.index_cursor = myenum.Value
            mh.index_start = myenum.Index
            mh.T1 = 4
            mh.ReadOnly = True
            Set var(v) = mh
        End If
    End If
    ProcEnumGroup = FastSymbol(rest$, "}", True)
Else
    MissingEnumBlock
    Exit Function
End If
        
End Function
Function ProcEnum(bstack As basetask, rest$, Optional Glob As Boolean = False, Optional alocal As Boolean = False) As Boolean
Dim s$, w1$, v As Long, enumvalue As Variant, myenum As Enumeration, mh As mHandler, V1 As Long, I As Long
Dim s1$, badd As Byte, lasttype, feed, w2$, usehandler As mHandler, myother As Enumeration
Dim gr As Boolean, fromvar As Long, j As Long
fromvar = varhash.count
enumvalue = 0#
lasttype = enumvalue
badd = CByte(1)
feed = enumvalue
If FastPureLabel(rest$, w1$, , , , , , gr) = 1 Then
    If Not (alocal Or Glob) Then
        If GetVar(bstack, myUcase(w1$, gr), j, , , True) Then
        If MemInt(VarPtr(var(I))) = vbEmpty Or fromvar = j Then
        
        GoTo CONTHERE0
        Else
                          MyEr "name " + w1$ + " exist", "ôï üíïìá " + w1$ + " õðÜñ÷åé"
                          Exit Function
                          
                          End If
                          
        End If
    End If
    v = globalvar(myUcase(w1$, gr), v, , (here$ = "") Or Glob)
CONTHERE0:
    Set myenum = New Enumeration
    myenum.EnumName = w1$
Else

    MyEr "No proper name for enumeration", "ìç êáíïíéêü üíïìá ãéá áðáñßèìçóç"
    Exit Function
End If
If FastSymbol(rest$, "{") Then
    s$ = block(rest$)
    Do
        If FastSymbol(s$, vbCrLf, , 2) Then
            While FastSymbol(s$, vbCrLf, , 2)
            Wend
        ElseIf MaybeIsSymbol(s$, "/\'") Then
            SetNextLine s$
        ElseIf FastPureLabel(s$, w1$, , , , , , gr) = 1 Then
            w2$ = myUcase(w1$, gr)
            If alocal Or Glob Then
                If GetVar(bstack, w2$, j, Glob, , alocal) Then
                If j <= fromvar Then
                    If Typename(var(j)) = "mHandler" Then
                        Set usehandler = var(j)
                        If usehandler.T1 = 4 Then
                            Set myother = usehandler.objref
                            Set usehandler = Nothing
                            If myUcase(myother.EnumName, True) = w2$ Then
                                GoTo copyhere
                            End If
                        End If
                    End If
                End If
                End If
            ElseIf GetVar(bstack, w2$, j, , , True) Then
check111:
                If j <= fromvar Then
                    If Typename(var(j)) = "mHandler" Then
                        Set usehandler = var(j)
                        If usehandler.T1 = 4 Then
                            Set myother = usehandler.objref
                            Set usehandler = Nothing
                            If myUcase(myother.EnumName, True) = w2$ Then
                                ' just copy the names from other enum here
copyhere:
                                For j = 0 To myother.count - 1
                                    myother.Index = j
                                    If AssignTypeNumeric(enumvalue + badd, VarType(lasttype)) Then
                                        enumvalue = enumvalue + badd
                                    End If
                                    feed = myother.Value
                                    If MyIsNumeric(feed) Then
                                        lasttype = feed
                                        enumvalue = feed
                                    End If
                                    myenum.addone myother.KeyToString, feed
                                Next j
                                ProcEnum = True
                                GoTo conthere
                            Else
                            GoTo cont123344
                            End If
                        End If
                    End If
                    
                  MyEr "name " + w1$ + " exist", "ôï üíïìá " + w1$ + " õðÜñ÷åé"
                  If fromvar < varhash.count Then
                    varhash.ReduceHash fromvar, var()
                  End If
                  ProcEnum = False
                  Exit Function
                End If
            ElseIf GetVar(bstack, w2$, j, True) Then
                GoTo check111
            End If
cont123344:
            If FastSymbol(s$, "=") Then
                If IsExp(bstack, s$, enumvalue, , True) Then
                    feed = enumvalue
                    If MyIsNumeric(feed) Then lasttype = feed
                Else
                    'MyEr "No String allowed as enumeration value", "Äåí åðéôñÝðåôáé áëöáñéèìçôéêü ãéá ôéìÞ áðáñéèìçôÞ"
                    If IsStrExp(bstack, s$, s1$, False) Then
                        If AssignTypeNumeric(enumvalue + badd, VarType(lasttype)) Then
                            enumvalue = enumvalue + badd
                        Else
                            Exit Function
                        End If
                        feed = CVar(s1$)
                    Else
                        Exit Function
                    End If
                End If
            Else
                If AssignTypeNumeric(enumvalue + badd, VarType(lasttype)) Then
                    enumvalue = enumvalue + badd
                    feed = enumvalue
                Else
                    Exit Function
                End If
            End If
            myenum.addone w1$, feed
            w1$ = myUcase(w1$, gr)
            If numid.Find(w1$, I) Then If I > 0 Then numid.ItemCreator2 w1$, -1
            Set mh = New mHandler
            Set mh.objref = myenum
            mh.T1 = 4
            mh.ReadOnly = True
            mh.index_cursor = feed
            mh.index_start = myenum.count - 1
            V1 = globalvar(w1$, V1, , (here$ = "") Or Glob)
            Set var(V1) = mh
            ProcEnum = True
        Else
            Exit Do
        End If
conthere:
        If FastSymbol(s$, ",") Then ProcEnum = False
    Loop
        
    If V1 > v Then
        Set var(v) = var(V1)
    Else
        If myenum.count = 0 Then
            MyEr "Empty Enumeration", "¢äåéá Áðáñßèìçóç": Exit Function
        Else
            Set mh = New mHandler
            Set mh.objref = myenum
            myenum.Index = myenum.count - 1
            mh.index_cursor = myenum.Value
            mh.index_start = myenum.Index
            mh.T1 = 4
            mh.ReadOnly = True
            Set var(v) = mh
        End If
    End If
    ProcEnum = FastSymbol(rest$, "}", True)
Else
    MissingEnumBlock
    Exit Function
End If
End Function
Function CallLambdaASAP(bstack As basetask, A$, r, Optional forstring As Boolean = False) As Long
Dim w2 As Long, w1 As Long, nbstack As basetask
PushStage bstack, False
w2 = var2used
If forstring Then
w1 = globalvarGroup("A_" & (w2) & "$", 0#)
 Set var(w1) = bstack.lastobj
 Set bstack.lastobj = Nothing
  If here$ = vbNullString Then
            GlobalSub "A_" & (Abs(w2)) & "$()", "", , , w1
        Else
            GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "$()", "", , , w1
    End If
 Set nbstack = New basetask
    Set nbstack.Parent = bstack
    If bstack.IamThread Then Set nbstack.Process = bstack.Process
    Set nbstack.Owner = bstack.Owner
    nbstack.OriginalCode = 0
    nbstack.UseGroupname = vbNullString
 CallLambdaASAP = GoFunc(nbstack, "A_" & (Abs(w2)) & "$()", A$, r)

Else
w1 = globalvarGroup("A_" & (w2), 0#)
 Set var(w1) = bstack.lastobj
 Set bstack.lastobj = Nothing
  If here$ = vbNullString Then
            GlobalSub "A_" & (Abs(w2)) & "()", "", , , w1
        Else
            GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "()", "", , , w1
    End If
     Set nbstack = New basetask
    Set nbstack.Parent = bstack
    If bstack.IamThread Then Set nbstack.Process = bstack.Process
    Set nbstack.Owner = bstack.Owner
    nbstack.OriginalCode = 0
    nbstack.UseGroupname = vbNullString
 CallLambdaASAP = GoFunc(nbstack, "A_" & (Abs(w2)) & "()", A$, r)
End If


                 
PopStage bstack
End Function

Function ProcText(basestack As basetask, isHtml As Boolean, rest$) As Boolean
Dim x1 As Long, frm$, pa$, s$
ProcText = True
If IsSymbol(rest$, "UTF-8", 5) Then
x1 = 2
ElseIf IsSymbol(rest$, "UTF-16", 6) Then
x1 = 0 ' only little endian (but if something convert it to big we can read...)
Else
x1 = 3
End If

s$ = vbNullString
If Not IsStrExp(basestack, rest$, s$) Then
If Not FastPureLabel(rest$, s$) = 1 Then
    ProcText = False
    Exit Function
End If
End If
FastSymbol rest$, ","
If s$ <> "" Then

If FastSymbol(rest$, "+") Then pa$ = vbNullString Else pa$ = "new"
If FastSymbol(rest$, "{") Then frm$ = NLTrim2$(blockString(rest$, 125))
If frm$ <> "" Then
If isHtml Then
If ExtractType(s$) = vbNullString Then s$ = s$ + ".html"
End If
 textPUT basestack, mylcasefILE(s$), frm$, pa$, x1
Else
 textDel (mylcasefILE(s$))
 ProcText = True
 Exit Function
End If
ProcText = FastSymbol(rest$, "}")
End If
Exit Function

End Function
Private Function textPUT(bstack As basetask, ByVal ThisFile As String, THISBODY As String, C$, mode2save As Long) As Boolean
Dim chk As String, b$, j As Long, Prepare$, VR$, s$, v As Double, buf$, I As Long
ThisFile = strTemp + ThisFile
chk = GetDosPath(ThisFile)
If chk <> "" And C$ = "new" Then KillFile GetDosPath(chk)
On Error GoTo HM
textPUT = True
Do
j = InStr(THISBODY, "##")
If j = 0 Then Prepare$ = Prepare$ + THISBODY: Exit Do
If j > 1 Then Prepare$ = Prepare$ + Mid$(THISBODY, 1, InStr(THISBODY, "##") - 1)
THISBODY = Mid$(THISBODY, j + 2)
j = InStr(THISBODY, "##")
If j = 0 Then Prepare$ = Prepare$ + THISBODY: Exit Do
If j > 1 Then VR$ = Mid$(THISBODY, 1, InStr(THISBODY, "##") - 1)
THISBODY = Mid$(THISBODY, j + 2)
'
If IsExp(bstack, VR$, v, , True) Then
buf$ = Trim$(str$(v))
ElseIf IsStrExp(bstack, VR$, s$, Len(bstack.tmpstr) = 0) Then
buf$ = s$
Else
buf$ = VR$
End If
Prepare$ = Prepare$ + buf$
Loop
           If Not WeCanWrite(ThisFile) Then GoTo HM

textPUT = SaveUnicode(ThisFile, Prepare$, mode2save, Not (C$ = "new"))
Exit Function
HM:
textPUT = False
End Function
Private Function textDel(ByVal ThisFile As String) As Boolean
Dim chk As String
ThisFile = strTemp + ThisFile
chk = CFname(ThisFile)
textDel = (chk <> "")
If chk <> "" Then KillFile chk
End Function
Function MyPset(bstack As basetask, rest$) As Boolean
Dim prive As Long, X As Double, p As Variant, Y As Double, Col As Long
Dim Scr As Object, ss$
Set Scr = bstack.Owner
prive = GetCode(Scr)
With players(prive)
    Col = players(prive).mypen
    If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then Col = mycolor(p)
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, X, , True) Then
            If FastSymbol(rest$, ",") Then
                If IsExp(bstack, rest$, Y, , True) Then
                    If TypeOf Scr Is MetaDc Then
                     
                        Scr.Line2 X, Y, X, Y, Col, False, False
                    Else
                        Scr.PSet (X, Y), Col
                    End If
                     MyPset = True
                Else
                    MissPar
                End If
            End If
        Else
            MissPar
        End If
    Else
        If TypeOf Scr Is MetaDc Then
            Scr.Line2 X, Y, X, Y, Col, False, False
        Else
            Scr.PSet (.XGRAPH, .YGRAPH), Col
        End If
        MyPset = True
    End If
End With
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing
End Function
Function fMatrix(bstack As basetask, A$, Arr As Variant, res As Variant) As Boolean
Dim Pad$, cut As Long, pppp As mArray, pppp1 As mArray, st1 As mStiva, anything As Object, w3 As Long, usehandler As mHandler, r As Variant, p As Variant
Dim cur As Long, w2 As Long, w4 As Long, retresonly As Boolean, s$, ut$
Dim multi As Boolean, original As Long, bhas As Integer, BI As BigInteger
Set anything = Arr
If TypeOf anything Is mArray Then
Set usehandler = New mHandler
usehandler.T1 = 3
Set usehandler.objref = Arr
Set anything = usehandler
Else
If Not CheckLastHandlerOrIterator(anything, w3) Then Exit Function
End If
Pad$ = myUcase(Left$(A$, 20))  ' 20??
cut = InStr(Pad$, "(")

If cut <= 1 Then Exit Function
Mid$(A$, 1, cut) = space$(cut)
Set usehandler = anything
If TypeOf usehandler.objref Is mArray Then
Set pppp = usehandler.objref

If Left$(Pad$, 1) = Chr$(1) Then LSet Pad$ = Mid$(Pad$, 2): cut = cut - 1
Do
multi = False
Select Case Left$(Pad$, cut - 1)
Case "SUM", "ÁÈÑ"
res = 0
For w3 = 0 To pppp.count - 1
If pppp.MyIsNumeric(pppp.item(w3)) Then
p = pppp.item(w3)
If IsObject(res) Then
If TypeOf p Is cxComplex Then
    Set BI = res
    res = nMath2.cxAddComVar(nMath2.cxNew(CDbl(BI.ToString), 0), p)
Else
    Set res = res.Add(CreateBigInteger(CStr(Int(p))))
End If

ElseIf TypeOf p Is cxComplex Then
    If TypeOf res Is cxComplex Then
        res = nMath2.cxAddVar(res, p)
    Else
        res = nMath2.cxAddComVar(nMath2.cxNew(res, 0#), p)
    End If
ElseIf TypeOf res Is cxComplex Then
res = nMath2.cxAddRealVar(res, p)
Else
res = res + p
End If
ElseIf pppp.IsEnum2(w3, p) Then
If MyIsNumeric(p) Then
    res = res + p
End If
ElseIf pppp.ItemIsObject(w3) Then
Set p = pppp.itemObject(w3)
If TypeOf p Is BigInteger Then
If TypeOf res Is cxComplex Then
    Set BI = p
    res = nMath2.cxAddRealVar(res, CDbl(BI.ToString))
ElseIf IsObject(res) Then
    Set BI = p
    Set res = res.Add(BI)
Else
    Set BI = p
    Set res = CreateBigInteger(CStr(Int(res))) '.Add((p))
    Set res = res.Add(BI)
End If
End If
End If
Next w3
Case "MIN", "ÌÉÊ"
res = 0
w4 = -1
If pppp.count > 0 Then
For w3 = 0 To pppp.count - 1
If pppp.MyIsNumeric(w3) Then
res = pppp.itemnumeric(w3): w4 = w3: Exit For
ElseIf pppp.IsEnum2(w3, p) Then
If MyIsNumeric(p) Then
    res = p: w4 = w3: Exit For
End If
End If
Next w3

For w3 = w3 To pppp.count - 1
If pppp.MyIsNumeric(pppp.item(w3)) Then
If pppp.item(w3) < res Then res = pppp.item(w3): w4 = w3
ElseIf pppp.IsEnum2(w3, p) Then
If MyIsNumeric(p) Then
    If p < res Then res = p: w4 = w3
End If
End If
Next w3
End If
If Not FastSymbol(A$, ")") Then
    bstack.soros.PushVal w4
    If Not getone(bstack, A$) Then Exit Function
    Else
    fMatrix = True
    Exit Function
End If
Case "MIN$", "ÌÉÊ$"
res = vbNullString
w4 = -1
If pppp.count > 0 Then
For w3 = 0 To pppp.count - 1
    If pppp.IsStringItem(w3) Then
        If pppp.IsEnum2(w3, p) Then
            If VarType(p) = vbString Then
                res = p: w4 = w3: Exit For
            End If
        Else
            res = pppp.item(w3): w4 = w3: Exit For
        End If
    End If
Next w3

For w3 = w3 To pppp.count - 1
    If pppp.IsStringItem(w3) Then
        If pppp.IsEnum2(w3, p) Then
            If VarType(p) = vbString Then
                If p < res Then res = p: w4 = w3
            End If
        Else
            If pppp.item(w3) < res Then res = pppp.item(w3): w4 = w3
        End If
    End If
Next w3
End If
If Not FastSymbol(A$, ")") Then
    bstack.soros.PushVal w4
    If Not getone(bstack, A$) Then Exit Function
Else
    fMatrix = True
    Exit Function
End If

Case "MAX$", "ÌÅÃ$"
res = vbNullString
w4 = -1
If pppp.count > 0 Then
For w3 = 0 To pppp.count - 1
    If pppp.IsStringItem(w3) Then
        If pppp.IsEnum2(w3, p) Then
            If VarType(p) = vbString Then
                res = p: w4 = w3: Exit For
            End If
        Else
            res = pppp.item(w3): w4 = w3: Exit For
        End If
    End If
Next w3

For w3 = w3 To pppp.count - 1
    If pppp.IsStringItem(w3) Then
        If pppp.IsEnum2(w3, p) Then
            If VarType(p) = vbString Then
                If p > res Then res = p: w4 = w3
            End If
        Else
            If pppp.item(w3) > res Then res = pppp.item(w3): w4 = w3
        End If
    End If
Next w3
End If
If Not FastSymbol(A$, ")") Then
    bstack.soros.PushVal w4
    If Not getone(bstack, A$) Then Exit Function
Else
    fMatrix = True
    Exit Function
End If
Case "MAX", "ÌÅÃ"
res = 0
w4 = -1
If pppp.count > 0 Then
For w3 = 0 To pppp.count - 1
If pppp.MyIsNumeric(pppp.item(w3)) Then
res = pppp.itemnumeric(w3): w4 = w3: Exit For
ElseIf pppp.IsEnum2(w3, p) Then
If MyIsNumeric(p) Then
    res = p: w4 = w3: Exit For
End If
End If
Next w3

For w3 = w3 To pppp.count - 1
If pppp.MyIsNumeric(pppp.item(w3)) Then
    If pppp.item(w3) > res Then res = pppp.item(w3): w4 = w3
ElseIf pppp.IsEnum2(w3, p) Then
If MyIsNumeric(p) Then
    If p > res Then res = p: w4 = w3
End If
End If
Next w3
End If
If Not FastSymbol(A$, ")") Then
    bstack.soros.PushVal w4
    If Not getone(bstack, A$) Then Exit Function
Else
    fMatrix = True
    Exit Function
End If
Case "EVAL", "EVAL$", "ÅÊÖÑ", "ÅÊÖÑ$"
If lookOne(A$, ")") Then
    w2 = 0
ElseIf IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
    w2 = CLng(p)
Else
    GoTo missexp
End If
If w2 < 0 Or w2 >= pppp.count Then
MyEr "offset out of limits", "Äåßêôçò åêôüò ïñßùí"
fMatrix = False
Exit Function
Else
If pppp.MyIsObject(pppp.item(w2)) Then
Set bstack.lastobj = pppp.item(w2)
res = 0
lookagain:
    If Not bstack.lastobj Is Nothing Then

        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
            With usehandler
                If .T1 = 3 Then
                    If TypeOf .objref Is mArray Then
                        If FastSymbol(A$, ",") Then
                            If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                                w4 = CLng(p)
                                If w4 < 0 Or w4 >= .objref.count Then
                                    'indexout A$
                                    errOutOfLimit
                                    fMatrix = False
                                    Exit Function
                                End If
                                Set pppp = .objref
                                pppp.Index = w4
                                If pppp.IsObj Then
                                Set res = pppp.Value
                                If lookOne(A$, ",") Then w2 = w4: Set bstack.lastobj = res: GoTo lookagain
                                Set anything = res
                                If Not anything Is Nothing Then
                                    If TypeOf anything Is mHandler Then
                                        Set usehandler = anything
                                        If usehandler.T1 = 3 Then
                                            Set bstack.lastobj = usehandler
                                            Set pppp = usehandler.objref
                                            res = 0
                                            multi = True
                                            GoTo conthere11
                                        End If
                                    End If
                                End If
                                Else
                                If Mid$(Pad$, cut - 1, 1) = "$" Then
                                res = CStr(MyVal(pppp.Value))

                                Else
                                res = MyVal(pppp.Value)
                                If VarType(res) = vbString Then
                                        If Not ValidNumberOnlyMatrix(CStr(res), res, False) Then res = 0
                                End If
                                End If
                                End If
                            Set bstack.lastobj = Nothing
                            fMatrix = FastSymbol(A$, ")")
                            Exit Function
                            End If
                        Else
                            Set pppp = .objref
                            multi = True
                        End If
                        
                    ElseIf TypeOf .objref Is mStiva Then
  
                    If FastSymbol(A$, ",") Then
                            If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                                w4 = CLng(p)
                                If w4 < 0 Or w4 >= .objref.count Then
                                    errOutOfLimit
                                    fMatrix = False
                                    Exit Function
                                End If
                             
                                .objref.Index = w4
                                If .objref.IsObj Then
                                Set res = .objref.Value
                                If lookOne(A$, ",") Then w2 = w4: Set bstack.lastobj = res: GoTo lookagain
                                Set anything = res
                                If Not anything Is Nothing Then
                                    If TypeOf anything Is mHandler Then
                                        Set usehandler = anything
                                        If usehandler.T1 = 3 Then
                                            Set bstack.lastobj = usehandler
                                            Set pppp = usehandler.objref
                                            res = 0
                                            multi = True
                                            GoTo conthere11
                                        End If
                                    End If
                                End If
                                
                                
                                
                                
                                
                                Else
                                If Mid$(Pad$, cut - 1, 1) = "$" Then
                                res = CStr(MyVal(.objref.Value))
                                Else
                                res = MyVal(.objref.Value)
                                If VarType(res) = vbString Then
                                        If Not ValidNumberOnlyMatrix(CStr(res), res, False) Then res = 0
                                End If
                                End If
                                End If
                                
                            Set bstack.lastobj = Nothing
                            fMatrix = FastSymbol(A$, ")")
                            Exit Function
                            End If
                       End If
                    End If
                ElseIf usehandler.T1 = 1 And FastSymbol(A$, ",") Then
                    If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                            w4 = CLng(p)
                            If w4 < 0 Or w4 >= .objref.count Then
                                    errOutOfLimit
                                    fMatrix = False
                            Exit Function
                            End If
                        End If
                    

                        .objref.Index = w4
                        .objref.Done = True

                    If .objref.IsObj Then
                        res = usehandler.objref.ValueObj
                                If lookOne(A$, ",") Then w2 = w4: Set bstack.lastobj = res: GoTo lookagain
                                Set anything = res
                                If Not anything Is Nothing Then
                                    If TypeOf anything Is mHandler Then
                                        Set usehandler = anything
                                        If usehandler.T1 = 3 Then
                                            Set bstack.lastobj = usehandler
                                            Set pppp = usehandler.objref
                                            res = 0
                                            multi = True
                                            GoTo conthere11
                                        End If
                                    End If
                                End If
                        
                        
                        
                    Else
                                If Mid$(Pad$, cut - 1, 1) = "$" Then
                                res = CStr(MyVal(.objref.Value))
                                Else
                                res = MyVal(.objref.Value)
                                If VarType(res) = vbString Then
                                        If Not ValidNumberOnlyMatrix(CStr(res), res, False) Then res = 0
                                End If
                                End If
                        Set bstack.lastobj = Nothing
                    End If
                    .objref.Done = False
            End If
            End With
        ElseIf TypeOf bstack.lastobj Is lambda Then
                            PushStage bstack, False

                            If Mid$(Pad$, cut - 1, 1) = "$" Then
                                w3 = globalvarGroup("A_" & (Abs(w2)) & "$", 0#)
                                Set var(w3) = bstack.lastobj
                                If here$ = vbNullString Then
                                    GlobalSub "A_" & (Abs(w2)) & "$()", "", , , w3
                                Else
                                    GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "$()", "", , , w3
                                End If
                                If Not FastSymbol(A$, ")(", , 2) Then FastSymbol A$, ","
                                bstack.tmpstr = "A_" & (Abs(w2)) & "$(" + Left$(A$, 1)
                                BackPort A$
                               fMatrix = IsStr1(bstack, A$, s$)
                               res = s$
                            Else
                                w3 = globalvarGroup("A_" & (Abs(w2)), 0#)
                                Set var(w3) = bstack.lastobj
                                If here$ = vbNullString Then
                                    GlobalSub "A_" & (Abs(w2)) & "()", "", , , w3
                                Else
                                    GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "()", "", , , w3
                                End If
                                If Not FastSymbol(A$, ")(", , 2) Then FastSymbol A$, ","
                                bstack.tmpstr = "A_" & (Abs(w2)) & "(" + Left$(A$, 1)
                                BackPort A$
                                fMatrix = IsNumberNew(bstack, A$, res, False)
                            End If
                            PopStage bstack
                            If Not bstack.lastobj Is Nothing Then
                            If TypeOf bstack.lastobj Is mHandler Then
                                Set usehandler = bstack.lastobj
                                If usehandler.T1 = 3 Then
                                    If TypeOf usehandler.objref Is mArray Then
                                        Set pppp = usehandler.objref
                                        multi = True
                                        GoTo conthere11
                                    End If
                                End If
                            End If
                                                      
                            End If
                            Exit Function
conthere11:
        ElseIf TypeOf bstack.lastobj Is Group Then
            Dim ppppL As iBoxArray
            Set ppppL = BoxGroupVar(bstack.lastobj)
            Set bstack.lastpointer = Nothing
            Set bstack.lastobj = Nothing
            w2 = 0
            A$ = NLtrim(A$)
            If Left$(A$, 1) = "," Then
                If Mid$(Pad$, cut - 1, 1) = "$" Then
                    Mid$(A$, 1, 1) = " "
                    fMatrix = SpeedGroup(bstack, ppppL, "VAL$", pppp.CodeName + "$(", A$, w2) = 1
                Else
                    Mid$(A$, 1, 1) = "("
                    fMatrix = SpeedGroup(bstack, ppppL, "VAL", pppp.CodeName, A$, w2) = 1
                    res = bstack.LastValue
                End If
            Else
                If Mid$(Pad$, cut - 1, 1) = "$" Then
                    fMatrix = SpeedGroup(bstack, ppppL, "VAL$", pppp.CodeName + "$(", A$, w2) = 1
                Else
                    fMatrix = SpeedGroup(bstack, ppppL, "VAL", pppp.CodeName, A$, w2) = 1
                    res = bstack.LastValue
                End If
                FastSymbol A$, ")", True
            End If
            res = bstack.LastValue
            Exit Function
        Else
            Set bstack.lastobj = Nothing
            res = rValue(bstack, pppp.item(w2))
            If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is mHandler Then
                    Set usehandler = bstack.lastobj
                    If usehandler.T1 = 3 Then
                        If TypeOf usehandler.objref Is mArray Then
                        res = 0
                        Set pppp = CopyArray(usehandler.objref)
                        multi = True
                        End If
                    End If
                End If
            End If
        End If
    End If
Else
    If Mid$(Pad$, cut - 1, 1) = "$" Then
        If Not pppp.IsStringItem(w2) Then
            On Error Resume Next
            res = CStr(pppp.item(w2))
                If Err Then res = vbNullString
            Else
                res = pppp.item(w2)
               
            End If
        Else
            res = pppp.item(w2)
            If VarType(res) = vbString Then
                    If Not ValidNumberOnlyMatrix(CStr(res), res, False) Then res = 0
            End If
        End If
    End If

End If

Case "VAL", "ÔÉÌÇ", "VAL$", "ÔÉÌÇ$"
If lookOne(A$, ")") Then
    w2 = 0
ElseIf IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
    w2 = CLng(p)
Else
missexp:
    MissNumExpr
    fMatrix = False
    Exit Function
End If
If w2 < 0 Or w2 >= pppp.count Then
MyEr "offset out of limits", "Äåßêôçò åêôüò ïñßùí"
fMatrix = False
Exit Function
Else
If pppp.MyIsObject(pppp.item(w2)) Then
Set bstack.lastobj = pppp.item(w2)
res = 0
If Not bstack.lastobj Is Nothing Then
If TypeOf bstack.lastobj Is mHandler Then
Set usehandler = bstack.lastobj
With usehandler
If .T1 = 3 Then
    If TypeOf usehandler.objref Is mArray Then
    Set pppp = usehandler.objref
    multi = True
    End If
    ElseIf .T1 = 1 And FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                w4 = CLng(p)
                If w4 < 0 Or w4 >= .objref.count Then
                                    errOutOfLimit
                                    fMatrix = False
                Exit Function
                End If
            End If
        

            .objref.Index = w4
            .objref.Done = True

        If .objref.IsObj Then
            res = rValue(bstack, usehandler.objref.ValueObj)
        Else
                    If Mid$(Pad$, cut - 1, 1) = "$" Then
                    res = CStr(MyVal(.objref.Value))
                    Else
                    res = MyVal(.objref.Value)
                    If VarType(res) = vbString Then
                                If Not ValidNumberOnlyMatrix(CStr(res), res, False) Then res = 0
                        End If
                    End If
            Set bstack.lastobj = Nothing
        End If
        .objref.Done = False
End If
End With
ElseIf TypeOf bstack.lastobj Is Group Then
    If bstack.lastpointer Is Nothing Then
    If bstack.lastobj.IamApointer Then
        Set bstack.lastpointer = bstack.lastobj
    
    End If
    End If
ElseIf TypeOf bstack.lastobj Is mArray Then

Set pppp = bstack.lastobj
multi = True
End If
End If
Else
    If Mid$(Pad$, cut - 1, 1) = "$" Then
        If Not pppp.IsStringItem(w2) Then
            On Error Resume Next
            res = fixthis(pppp.item(w2))
                If Err Then res = vbNullString
            Else
                res = pppp.item(w2)
            End If
        Else
            res = pppp.item(w2)
            If VarType(res) = vbString Then
                If Not ValidNumberOnlyMatrix(CStr(res), res, False) Then res = 0
            End If
        End If
    End If
End If
Case "SLICE", "ÌÅÑÏÓ"
If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
If p < 0 Then
    MyEr "start offset out of limits", "Äåßêôçò áñ÷Þò åêôüò ïñßùí"
    fMatrix = False
    Exit Function
End If
Else
p = 0
End If
If FastSymbol(A$, ",") Then
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    If r < 0 Then
    Set pppp = pppp.EmptyArraySameType()
        GoTo JMPeMPTY
    ElseIf r >= pppp.count Or r < p Then
    MyEr "end offset out of limits", "Äåßêôçò ôÝëïõò åêôüò ïñßùí"
    fMatrix = False
    Exit Function
    End If
Else
r = pppp.count - 1
End If
Else
r = pppp.count - 1
End If
If CLng(p) >= pppp.count Then
    Set pppp = pppp.EmptyArraySameType()
        GoTo JMPeMPTY
End If
If original > 0 Then
pppp.CopyArraySliceFast pppp1, CLng(p), CLng(r)
Else
pppp.CopyArraySlice pppp1, CLng(p), CLng(r)
End If
Set pppp = pppp1
Set pppp1 = Nothing
JMPeMPTY:
original = original + 1
multi = True
fMatrix = True
Set usehandler = New mHandler
usehandler.T1 = 3
Set usehandler.objref = pppp
Set bstack.lastobj = usehandler
Case "END", "ÔÅË"
retresonly = True
GoTo cont1111
Case "START", "ÁÑ×Ç"
retresonly = False
cont1111:
If IsExp(bstack, A$, p) Then
    Set anything = bstack.lastobj
    Set bstack.lastobj = Nothing
    If Not CheckLastHandlerOrIterator(anything, w3) Then MissingArray: Exit Function
    Set usehandler = anything
    If Not TypeOf usehandler.objref Is mArray Then
        If usehandler.T1 = 4 Then Set usehandler = Nothing: Set anything = Nothing: GoTo again1
        Exit Function
    End If
    If pppp.count > 0 Then
        If retresonly Then
            If original > 0 Then
                Set anything = pppp
                Set pppp = usehandler.objref
                Set pppp1 = anything
            Else
                Set pppp1 = New mArray
                pppp.CopyArray pppp1
                Set pppp = usehandler.objref
            End If
            pppp.AppendArray pppp1
        Else
            Set anything = pppp
            Set pppp1 = usehandler.objref
            Set pppp = New mArray
            pppp1.CopyArray pppp
            Set pppp1 = anything
            pppp1.AppendArray pppp
            Set pppp1 = pppp
        End If
        
    Else
        Set pppp1 = usehandler.objref
    End If
    original = original + 1
    retresonly = False
    Set anything = Nothing
    Set usehandler = Nothing
    GoTo cont12321
Else
    MissingArray
End If
Exit Function
Case "SORT", "ÔÁÎÉÍÏÌÇÓÇ"
w2 = 0
w3 = -1
w4 = -1
If lookOne(A$, ")") Then
    w2 = 0
ElseIf IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
    w2 = CLng(p)
Else
    GoTo missexp
End If
If FastSymbol(A$, ",") Then
    If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
        w3 = CLng(p)
    Else
       GoTo missexp
    End If
End If
If FastSymbol(A$, ",") Then
    If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
        w4 = CLng(p)
    Else
        GoTo missexp
    End If
End If
If original > 0 Then
    Set pppp1 = pppp
Else
    Set pppp1 = New mArray
    pppp.CopyArray pppp1
End If
original = original + 1

If w2 Then
pppp1.SortDesTuple w3, w4
Else
pppp1.SortTuple w3, w4
End If
cont12321:
Set pppp = pppp1
Set pppp1 = Nothing
multi = True
fMatrix = True
Set usehandler = New mHandler
usehandler.T1 = 3
Set usehandler.objref = pppp
Set bstack.lastobj = usehandler
Case "STR$", "ÃÑÁÖÇ$"
If IsExp(bstack, A$, p, , True) Then
    If MemInt(VarPtr(p)) = vbString Then SwapString2Variant Pad$, p: p = Empty: GoTo contStr1
    MissStringExpr
    Exit Function
End If
If Not IsStrExp(bstack, A$, Pad$) Then Pad$ = " "
contStr1:
If FastSymbol(A$, ",") Then
    If IsExp(bstack, A$, p, , True) Then
        If MemInt(VarPtr(p)) = vbString Then SwapString2Variant s$, p: p = Empty: GoTo contStr2
    End If
    If Not IsStrExp(bstack, A$, s$) Then
        s$ = "": If Pad$ = " " Then Pad$ = ","
    End If
End If
contStr2:

res = ""
If pppp.count > 0 Then
For w3 = 0 To pppp.count - 2
If pppp.IsStringItem(w3) Then
    If pppp.ItemType(w3) = "mHandler" Then
    Set usehandler = pppp.item(w3)
    If Len(s$) > 0 Then
    res = res + """" + usehandler.index_cursor + """" + Pad$
    Else
    res = res + usehandler.index_cursor + Pad$
    End If
    Else
    If Len(s$) > 0 Then
        res = res + """" + StringToEscapeStr(pppp.item(w3)) + """" + Pad$
    Else
    res = res + pppp.item(w3) + Pad$
    End If
    End If
Else
    If Len(s$) > 0 Then
    res = res + Num2Str(pppp.itemnumeric(w3), s$) + Pad$
    Else
        If pppp.IsObjAt(w3, r) Then
            If TypeOf r Is BigInteger Then
                ut$ = r.ToString
                r = 0
            Else
                ut$ = fixthis(pppp.itemnumeric(w3))
            End If
        Else
            r = pppp.itemnumeric(w3)
            If TypeOf r Is cxComplex Then
                
                ut$ = fixthis(r)
            Else
                ut$ = fixthis(r)
            End If
            res = res + ut$ + Pad$
        End If
    End If
End If
Next
If pppp.IsStringItem(w3) Then
 If pppp.ItemType(w3) = "mHandler" Then
    Set usehandler = pppp.item(w3)
    If Len(s$) > 0 Then
    res = res + """" + usehandler.index_cursor + """"
    Else
    res = res + usehandler.index_cursor
    End If
    ElseIf Len(s$) > 0 Then
        res = res + """" + StringToEscapeStr(pppp.item(w3)) + """"
    Else
        res = res + pppp.item(w3)
    End If
Else
If Len(s$) > 0 Then
    res = res + Num2Str(pppp.itemnumeric(w3), s$)
    Else
        If pppp.IsObjAt(w3, r) Then
            If TypeOf r Is BigInteger Then
                ut$ = r.ToString
                r = 0
            Else
                ut$ = fixthis(pppp.itemnumeric(w3))
            End If
        Else
            r = pppp.itemnumeric(w3)
            If TypeOf r Is cxComplex Then
                ut$ = fixthis(r)
            Else
                ut$ = fixthis(r)
            End If
        End If
        res = res + ut$
    End If
End If
End If
Case "FOLD", "ÐÁÊ", "FOLD$", "ÐÁÊ$"
If IsExp(bstack, A$, p) Then
    If Not bstack.lastobj Is Nothing Then
        Set anything = bstack.lastobj
        If FastSymbol(A$, ",") Then
            If IsExp(bstack, A$, p) Then
                If Not bstack.lastobj Is Nothing Then
                Set res = bstack.lastobj
                Else
                 res = p
                 End If
            ElseIf IsStrExp(bstack, A$, Pad$, False) Then
                res = Pad$
            Else
               MissParam A$
                fMatrix = False
                Exit Function
            End If
            
        End If
        Set bstack.lastobj = Nothing
        Set r = Nothing
        CallLambdaArrayFold bstack, pppp, anything, res, r
        If Not r Is Nothing Then
        
            If TypeOf r Is mHandler Then
                Set usehandler = r
                If usehandler.T1 = 3 Then
                 If TypeOf usehandler.objref Is mArray Then
                    Set pppp = usehandler.objref
                    Set pppp1 = Nothing
                    multi = True
                    fMatrix = True
                    original = original + 1
                    Set bstack.lastobj = r
                    GoTo ABCDEF
                End If
                End If
            End If
            Set bstack.lastobj = r

        End If
    Else
        MyEr "missing a lambda function", "ëåßðåé ìéá ëÜìäá óõíÜñôçóç"
        fMatrix = False
        Exit Function
    End If
ABCDEF:
Else
    MyEr "missing a lambda function", "ëåßðåé ìéá ëÜìäá óõíÜñôçóç"
    fMatrix = False
    Exit Function
End If

Case "REV", "ÁÍÁÐ"
Set pppp1 = New mArray
If pppp1.MyTypeToBe <> vbVariant Then
    pppp.CopyArrayRevFast pppp1
Else
If original > 0 Then
    pppp.CopyArrayRevFast pppp1
Else
    pppp.CopyArrayRev pppp1
End If
End If
original = original + 1

Set pppp = pppp1
Set pppp1 = Nothing
res = 0
multi = True
fMatrix = True
Set usehandler = New mHandler
usehandler.T1 = 3
Set usehandler.objref = pppp
Set bstack.lastobj = usehandler

Case "MAP", "ÁÍÔ"
againmap:
If IsExp(bstack, A$, p) Then
    If Not bstack.lastobj Is Nothing Then
    CallLambdaArrayMap bstack, pppp, bstack.lastobj
    If FastSymbol(A$, ",") Then GoTo againmap
    Else
    MyEr "missing a lambda function", "ëåßðåé ìéá ëÜìäá óõíÜñôçóç"
    fMatrix = False
    Exit Function
End If
Else
Set pppp1 = New mArray
pppp.CopyArray pppp1
Set pppp = pppp1
original = original + 1
End If
res = 0
If FastSymbol(A$, ",") Then
    If pppp.count = 0 Then
        If IsExp(bstack, A$, p, , True) Then
             res = p: retresonly = True
        ElseIf IsStrExp(bstack, A$, Pad$, False) Then
            res = Pad$: retresonly = True
        Else
           MyEr "No value", "×ùñßò ôéìÞ"
            fMatrix = False
            Exit Function
        End If
    Else
        w2 = 1
        aheadstatus A$, , w2
        If w2 > 1 Then Mid$(A$, 1, w2 - 1) = space$(w2)
    End If
End If
fMatrix = True
If Not retresonly Then
Set usehandler = New mHandler
usehandler.T1 = 3
Set usehandler.objref = pppp
Set bstack.lastobj = usehandler
End If
multi = True

Case "FILTER", "ÖÉËÔÑÏ"
again:
If IsExp(bstack, A$, p) Then
    If Not bstack.lastobj Is Nothing Then
    CallLambdaArray bstack, pppp, bstack.lastobj
    Else
    MyEr "missing a lambda function", "ëåßðåé ìéá ëÜìäá óõíÜñôçóç"
    fMatrix = False
    Exit Function
End If
Else
Set pppp1 = New mArray
pppp.CopyArray pppp1
Set pppp = pppp1
original = original + 1
End If
res = 0
If FastSymbol(A$, ",") Then
    If pppp.count = 0 Then
        If IsExp(bstack, A$, p) Then
            If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
            If usehandler.T1 = 3 Then
            If TypeOf usehandler.objref Is mArray Then
                Set pppp = usehandler.objref
                GoTo again
           ' End If
            End If
            End If
            End If
            End If
             res = p: retresonly = True
        ElseIf IsStrExp(bstack, A$, Pad$, Len(bstack.tmpstr) = 0) Then
            res = Pad$: retresonly = True
        Else
           MyEr "No value", "×ùñßò ôéìÞ"
            fMatrix = False
            Exit Function
        End If
    Else
        w2 = 1
        aheadstatus A$, , w2
        If w2 > 1 Then Mid$(A$, 1, w2 - 1) = space$(w2)
    End If
End If
fMatrix = True
If Not retresonly Then
Set usehandler = New mHandler
usehandler.T1 = 3
Set usehandler.objref = pppp
Set bstack.lastobj = usehandler
End If
multi = True
Case "NOTHAVE", "ÄÅÍÅ×ÅÉ"
bhas = 2
GoTo jpos
Case "HAVE", "Å×ÅÉ"
bhas = 1
GoTo jpos
Case "POS", "ÈÅÓÇ"
jpos:
    res = -1
    cur = 0
    Dim st() As String, Sn() As Variant
    If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
        
        p = Int(r)
        If p < 0 Then p = 0
again1:
        If FastSymbol(A$, "->", , 2) Then
            If IsExp(bstack, A$, r) Then
                If bstack.lastobj Is Nothing Then
                    ReDim Sn(0 To 4) As Variant
                    Sn(0) = r
                Else
dothis:
                    Set anything = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    If Not CheckLastHandlerOrIterator(anything, w3) Then Exit Function
                    Set usehandler = anything
                    If Not TypeOf usehandler.objref Is mArray Then
                        If usehandler.T1 = 4 Then Set usehandler = Nothing: Set anything = Nothing: GoTo again1
                        Exit Function
                    End If
                    Set pppp1 = usehandler.objref
            
                    Sn() = pppp1.GetCopy()
                    If pppp1.count > 0 Then
                        ReDim Preserve Sn(0 To pppp1.count - 1)
                    End If
                    cur = pppp1.count - 1
                    w3 = p
                End If
            ElseIf IsStrExp(bstack, A$, Pad$, Len(bstack.tmpstr) = 0) Then
                GoTo there
            Else
                MissParam A$: Exit Function
            End If
        Else
            If bstack.lastobj Is Nothing Then
'                r = p
                p = 0
                ReDim Sn(0 To 4) As Variant
                Sn(0) = r
            Else
                GoTo dothis
            End If
        End If
        
        If pppp.count > 0 Then
            res = -1
            If Not pppp1 Is Nothing Then
                While res = -1 And cur >= 0 And w3 < pppp.count - cur - 1
                    For w3 = w3 To pppp.count - cur - 1
                        If pppp.MyIsObject(pppp.item(w3)) Then
                             If pppp.MyIsObject(Sn(0)) Then GoTo inside
                        Else
                            If pppp.MyIsObject(Sn(0)) Then GoTo inside
                            If pppp.item(w3) = Sn(0) Then
inside:
                                res = w3
                                w4 = w3 + 1
                                For w2 = 1 To cur
                                    If w4 < pppp.count Then
                                        If pppp.MyIsObject(pppp.item(w4)) Then
                                            If Not pppp.MyIsObject(Sn(w2)) Then
                                                res = -1
                                                Exit For
                                            End If
                                        Else
                                            If pppp.MyIsObject(Sn(w2)) Then
                                                res = -1
                                                Exit For
                                            Else
                                                If pppp.item(w4) <> Sn(w2) Then res = -1: Exit For
                                            End If
                                        End If
                                    End If
                                    w4 = w4 + 1
                                Next w2
                                If w2 > cur Then Exit For
                            End If
                        End If
                    Next w3
                Wend
            Else
                For w3 = p To pppp.count - 1
                    If pppp.MyIsNumeric(pppp.item(w3)) Then
                        If pppp.item(w3) = r Then
                        res = w3: Exit For
                        End If
                    Else
                        If pppp.ItemType(w3) = "mHandler" Then
                            Set usehandler = pppp.item(w3)
                            If usehandler.T1 = 4 Then
                            If myVarType(usehandler.index_cursor, vbString) Then
                                If myVarType(r, vbString) Then
                                    If usehandler.index_cursor = r Then res = w3: Exit For
                                End If
                            Else
                                If usehandler.index_cursor * usehandler.sign = r Then res = w3: Exit For
                            End If
                            End If
                        End If
                    End If
                Next w3
                w2 = 1
                Do While FastSymbol(A$, ",")
                    If cur = UBound(Sn()) Then ReDim Preserve Sn(0 To cur * 2 - 1) As Variant
                    cur = cur + 1
                    If IsExp(bstack, A$, Sn(cur), , True) Then
                        If res > -1 Then
                            w3 = w3 + 1
                            If w3 < pppp.count Then
                                If pppp.MyIsNumeric(pppp.item(w3)) Then
                                    If pppp.item(w3) <> Sn(cur) Then w2 = -1
                                ElseIf pppp.ItemType(w3) = "mHandler" Then
                                    Set usehandler = pppp.item(w3)
                                    If usehandler.T1 = 4 Then
                                        If myVarType(usehandler.index_cursor, vbString) Then
                                             If myVarType(Sn(cur), vbString) Then
                                                If usehandler.index_cursor <> Sn(cur) Then w2 = -1
                                             End If
                                        Else
                                            If usehandler.index_cursor * usehandler.sign <> Sn(cur) Then w2 = -1
                                        End If
                                    Else
                                        w2 = -1
                                    End If
                                Else
                                    w2 = -1
                                End If
                            Else
                                w2 = -1
                            End If
                        End If
                    End If
                Loop
                If w2 = -1 Then
                    w3 = res + 1
                    res = -1
                    While res = -1 And cur > 0 And w3 < pppp.count - cur - 1
                        For w3 = w3 To pppp.count - cur - 1
                            If pppp.MyIsNumeric(pppp.item(w3)) Then
                                If pppp.item(w3) = Sn(0) Then
                                    res = w3
                                    w4 = w3 + 1
                                    For w2 = 1 To cur
                                        If w4 < pppp.count Then
                                            If pppp.MyIsNumeric(pppp.itemnumeric(w4)) Then
                                                If pppp.item(w4) <> Sn(w2) Then res = -1: Exit For
                                            ElseIf pppp.ItemType(w4) = "mHandler" Then
                                                Set usehandler = pppp.item(w4)
                                                If usehandler.T1 = 4 Then
                                                    If myVarType(usehandler.index_cursor, vbString) Then
                                                        If myVarType(Sn(w2), vbString) Then
                                                            If usehandler.index_cursor <> Sn(w2) Then res = -1
                                                        End If
                                                    Else
                                                        If usehandler.index_cursor * usehandler.sign <> Sn(w2) Then res = -1
                                                    End If
                                                Else
                                                    res = -1
                                                End If
                                            Else
                                                res = -1
                                            End If
                                        End If
                                        w4 = w4 + 1
                                    Next w2
                                    If w2 > cur Then Exit For
                                End If
                            End If
                        Next w3
                    Wend
                End If
            End If
        End If
    ElseIf IsStrExp(bstack, A$, Pad$, Len(bstack.tmpstr) = 0) Then
        
there:
        ReDim st(0 To 4) As String
        st(0) = Pad$
        If pppp.count > 0 Then
            res = -1
            For w3 = p To pppp.count - 1
                If pppp.IsStringItem(w3) Then
                    If pppp.item(w3) = st(0) Then res = w3: Exit For
                End If
            Next w3
            w2 = 1
            Do While FastSymbol(A$, ",")
                If cur = UBound(st()) Then ReDim Preserve st(0 To cur * 2 - 1) As String
                cur = cur + 1
                If IsStrExp(bstack, A$, st(cur)) Then
                    If res > -1 Then
                        w3 = w3 + 1
                        If w3 < pppp.count Then
                            If pppp.IsStringItem(w3) Then
                                If pppp.item(w3) <> st(cur) Then w2 = -1
                            Else
                                w2 = -1
                            End If
                        Else
                            w2 = -1
                        End If
                    End If
                Else
                    w2 = -1
                End If
            Loop
            If w2 = -1 Then
                w3 = res + 1
                res = -1
                While res = -1 And cur > 0 And w3 < pppp.count - cur - 1
                    For w3 = w3 To pppp.count - cur - 1
                        If pppp.IsStringItem(w3) Then
                            If pppp.item(w3) = st(0) Then
                                res = w3
                                w4 = w3 + 1
                                For w2 = 1 To cur
                                    If w4 < pppp.count Then
                                        If pppp.IsStringItem(w4) Then
                                            If pppp.item(w4) <> st(w2) Then res = -1: Exit For
                                        Else
                                            res = -1
                                        End If
                                    End If
                                    w4 = w4 + 1
                                Next w2
                                If w2 > cur Then Exit For
                            End If
                        End If
                    Next w3
                Wend
            End If
        End If
    Else
        MissParam A$
        Exit Function
    End If
    If bhas > 0 Then
        If bhas = 1 Then
            res = res <> -1
        Else
            res = res = -1
        End If
    End If
End Select
fMatrix = FastSymbol(A$, ")")
If Not multi Then Exit Do
If fMatrix = False Then Exit Do
If Not IsOperator(A$, "#") Then Exit Do
If pppp.count = 0 Then
        Do
        w2 = 1
        aheadstatus A$, , w2
        If w2 > 1 Then Mid$(A$, 1, w2 - 1) = space$(w2)
        If Not FastSymbol(A$, ")") Then fMatrix = False: Exit Function
        Loop Until Not IsOperator(A$, "#")
Exit Function
End If
Pad$ = myUcase(Left$(A$, 20))
cut = InStr(Pad$, "(")
If cut <= 1 Then Exit Do
Mid$(A$, 1, cut) = space$(cut)
Set bstack.lastobj = Nothing

Loop
Else
WrongObject
End If
End Function
Function getone(bstack As basetask, rest$) As Boolean
Dim what$, ss$, x1 As Long
getone = True
FastSymbol rest$, "&"
   x1 = Abs(IsLabelBig(bstack, rest$, what$))
    
    If x1 <> 0 Then
            If x1 > 4 Then
                    ss$ = BlockParam(rest$)
                    what$ = what$ + ss$ + ")"
                    'rest$ = Mid$(rest$, Len(ss$) + 2)
                    Mid$(rest$, 1, Len(ss$) + 1) = space(Len(ss$) + 1)
                    Do While IsSymbol(rest$, ".")
                    x1 = IsLabel(bstack, rest$, ss$)
                    If x1 > 0 Then what$ = what$ + "." + ss$ Else Exit Do
                            If x1 > 4 Then
                            ss$ = BlockParam(rest$)
                            what$ = what$ + ss$ + ")"
                            'rest$ = Mid$(rest$, Len(ss$) + 2)
                            Mid$(rest$, 1, Len(ss$) + 1) = space(Len(ss$) + 1)
                            End If
                    Loop
            End If
              
              getone = MyRead(6, bstack, (what$), 1, what$, x1, True)

             Else
             MissParamref rest$
             Exit Function
             End If
  



End Function
Sub CallLambdaArray(bstack As basetask, ByRef pppp As mArray, mylambda As lambda)
Dim w2 As Long, w1 As Long, nbstack As basetask
PushStage bstack, False
w2 = var2used
w1 = globalvarGroup("A_" & (w2), 0#)
 Set var(w1) = mylambda
 Set bstack.lastobj = Nothing
  If here$ = vbNullString Then
            GlobalSub "A_" & (Abs(w2)) & "()", "", , w1
        Else
            GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "()", "", , , w1
    End If
     Set nbstack = New basetask
    Set nbstack.Parent = bstack
    If bstack.IamThread Then Set nbstack.Process = bstack.Process
    Set nbstack.Owner = bstack.Owner
    nbstack.OriginalCode = 0
    nbstack.UseGroupname = vbNullString
Dim aa As Object, oldsoros As mStiva, tempsoros As New mStiva, finalpppp As New mArray
finalpppp.StartResize: finalpppp.PushDim pppp.count: finalpppp.PushEnd
Set oldsoros = bstack.soros
Set bstack.Sorosref = tempsoros
Dim r, what As Long, where As Long
For w1 = 0 To pppp.count - 1
 
  If pppp.IsStringItem(w1) Then
   ' tempsoros.PushStrVariant pppp.item(w1)
    If pppp.IsEnum2(w1, r) Then
        tempsoros.PushStrVariant r
    Else
        tempsoros.PushStrVariant pppp.item(w1)
    End If
    what = 1
  ElseIf pppp.MyIsObject(pppp.item(w1)) Then
    tempsoros.PushObj pppp.item(w1)
    what = 2
  Else
      tempsoros.PushVal pppp.item(w1)
      what = 3
  End If
  If Not GoFunc(nbstack, "A_" & (Abs(w2)) & "()", vbNullString, r, w2, , , True) Then Exit For
  If CBool(r) Then
  If what <> 2 Then
  finalpppp.item(where) = pppp.item(w1)
 
  Else
   Set finalpppp.item(where) = pppp.item(w1)
  End If
  where = where + 1

  End If
  tempsoros.Flush
Next w1
Set bstack.Sorosref = oldsoros
PopStage bstack
finalpppp.StartResize: finalpppp.PushDim where: finalpppp.PushEnd
Set pppp = finalpppp

End Sub

Sub CallLambdaArrayMap(bstack As basetask, ByRef pppp As mArray, mylambda As lambda)
Dim w2 As Long, w1 As Long, nbstack As basetask
PushStage bstack, False
w2 = var2used
w1 = globalvarGroup("A_" & (w2), 0#)
 Set var(w1) = mylambda
 Set bstack.lastobj = Nothing
  If here$ = vbNullString Then
            GlobalSub "A_" & (Abs(w2)) & "()", "", , , w1
        Else
            GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "()", "", , , w1
    End If
     Set nbstack = New basetask
    Set nbstack.Parent = bstack
    If bstack.IamThread Then Set nbstack.Process = bstack.Process
    Set nbstack.Owner = bstack.Owner
    nbstack.OriginalCode = 0
    nbstack.UseGroupname = vbNullString
Dim aa As Object, oldsoros As mStiva, tempsoros As New mStiva, finalpppp As New mArray
finalpppp.StartResize: finalpppp.PushDim pppp.count: finalpppp.PushEnd
Set oldsoros = bstack.soros
Set bstack.Sorosref = tempsoros
Dim r, what As Long, where As Long
w1 = 0
Do While w1 < pppp.count
  If pppp.IsStringItem(w1) Then
    If pppp.IsEnum2(w1, r) Then
        tempsoros.PushStrVariant r
    Else
        tempsoros.PushStrVariant pppp.item(w1)
    End If
  ElseIf pppp.MyIsObject(pppp.item(w1)) Then
    tempsoros.PushObj pppp.item(w1)
  Else
      tempsoros.PushVal pppp.item(w1)
  End If
  If Not GoFunc(nbstack, "A_" & (Abs(w2)) & "()", vbNullString, r, w2, , , True) Then Exit Do
    If tempsoros.count > 0 Then
        If tempsoros.count > 1 Then
            what = tempsoros.count
            finalpppp.SerialItem 0, finalpppp.count + what - 1, 10
            While tempsoros.count > 0
                If tempsoros.StackItemTypeIsObject(1) Then
                    Set finalpppp.item(where) = tempsoros.PopObj
                Else
                    finalpppp.item(where) = tempsoros.PopAnyNoObject
                End If
                where = where + 1
            Wend
            
        Else
            If tempsoros.StackItemTypeIsObject(1) Then
                Set finalpppp.item(where) = tempsoros.PopObj
            Else
                finalpppp.item(where) = tempsoros.PopAnyNoObject
            End If
            where = where + 1
        End If
    Else
        finalpppp.SerialItem 0, where, 10
        Exit Do
    End If
 
  tempsoros.Flush
  w1 = w1 + 1
  
Loop
Set bstack.Sorosref = oldsoros
PopStage bstack
Set pppp = finalpppp

End Sub
Sub CallLambdaArrayFold(bstack As basetask, pppp As mArray, mylambda As lambda, res As Variant, ByRef retObj As Variant)
Dim w2 As Long, w1 As Long, nbstack As basetask
PushStage bstack, False
w2 = var2used
w1 = globalvarGroup("A_" & (w2), 0#)
 Set var(w1) = mylambda
 Set bstack.lastobj = Nothing
  If here$ = vbNullString Then
            GlobalSub "A_" & (Abs(w2)) & "()", "", , , w1
        Else
            GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "()", "", , , w1
    End If
     Set nbstack = New basetask
    Set nbstack.Parent = bstack
    If bstack.IamThread Then Set nbstack.Process = bstack.Process
    Set nbstack.Owner = bstack.Owner
    nbstack.OriginalCode = 0
    nbstack.UseGroupname = vbNullString
Dim aa As Object, oldsoros As mStiva, tempsoros As New mStiva
Set oldsoros = bstack.soros
Set bstack.Sorosref = tempsoros
Dim r, what As Long, where As Long
If pppp.MyIsNumeric(res) Then
tempsoros.PushVal res
ElseIf pppp.MyIsObject(res) Then
Set aa = res
tempsoros.PushObj aa
Else
tempsoros.PushStrVariant res
End If

For w1 = 0 To pppp.count - 1

  If pppp.IsStringItem(w1) Then
    If pppp.IsEnum2(w1, r) Then
        tempsoros.PushStrVariant r
    Else
        tempsoros.PushStrVariant pppp.item(w1)
    End If
  ElseIf pppp.MyIsObject(pppp.item(w1)) Then
    tempsoros.PushObj pppp.item(w1)
  Else
      tempsoros.PushVal pppp.item(w1)
  End If
  If Not GoFunc(nbstack, "A_" & (Abs(w2)) & "()", vbNullString, r, w2, , , True) Then Exit For
Next w1
  If tempsoros.count > 0 Then
  If tempsoros.StackItemTypeIsObject(1) Then
        Set retObj = tempsoros.PopObj
        res = 0
  Else
        res = tempsoros.PopAnyNoObject
  End If
    End If
Set bstack.Sorosref = oldsoros
PopStage bstack
End Sub

Function ChangeValues(bstack As basetask, rest$) As Boolean
Dim aa As mHandler, bb As FastCollection, ah As String, p As Variant, s$, lastindex As Long
Set aa = bstack.lastobj
Set bstack.lastobj = Nothing
Set bb = aa.objref
If bb.structLen > 0 Then
MyEr "Structure members are ReadOnly", "Ôá ìÝëç ôçò äïìÞò åßíáé ìüíï ãéá áíÜãíùóç"
Exit Function
End If
If bb.Done And FastSymbol(rest$, ":=", , 2) Then
        ' change one value
        ah = aheadstatus(rest$, False) & " "
        If Left$(ah, 1) = "N" Or InStr(ah, "l") > 0 Then
            If Not IsExp(bstack, rest$, p) Then
                ChangeValues = False
                GoTo there
            End If
            ChangeValues = True
            If Not bstack.lastobj Is Nothing Then
                Set bb.ValueObj = bstack.lastobj
                Set bstack.lastobj = Nothing
            Else
                bb.Value = p
            End If
            
        ElseIf Left$(ah, 1) = "S" Then
            If Not IsStrExp(bstack, rest$, s$) Then
                ChangeValues = False
                GoTo there
            End If
            ChangeValues = True
            If Not bstack.lastobj Is Nothing Then
                Set bb.ValueObj = bstack.lastobj
                Set bstack.lastobj = Nothing
            Else
                bb.Value = s$
            End If
        Else
                MyEr "No Data found", "Äåí âñÝèçêáí óôïé÷åßá"
                ChangeValues = False
        End If
        GoTo there

ElseIf lookOne(rest$, ",") Then
    Do While FastSymbol(rest$, ",")
        ChangeValues = True
        ah = aheadstatus(rest$, False) + " "
        If InStr(ah, "l") Then
                FoundLogicalExpr
                ChangeValues = False
        Else
                If Left$(ah, 1) = "N" Then
                    If Not IsExp(bstack, rest$, p, , True) Then
                        ChangeValues = False
                        GoTo there
                    End If
                        If VarType(p) = vbBoolean Then p = CLng(p)
                    If Not bstack.lastobj Is Nothing Then
                        MyEr "No Object Allowed for Key", "Äåí åðéôñÝðåôáé áíôéêåßìåíï ãéá êëåéäß"
                        ChangeValues = False
                        GoTo there
                    End If
                    If Not bb.Find(p) Then
                         MyEr "No Key found", "Äåí âñÝèçêå êëåéäß"
                        ChangeValues = False
                        GoTo there
                    End If
                    
                ElseIf Left$(ah, 1) = "S" Then
                    If Not IsStrExp(bstack, rest$, s$) Then
                        ChangeValues = False
                        GoTo there
                    End If
                    If Not bstack.lastobj Is Nothing Then
                        MyEr "No Object Allowed for Key", "Äåí åðéôñÝðåôáé áíôéêåßìåíï ãéá êëåéäß"
                        ChangeValues = False
                        GoTo there
                    End If
                    If Not bb.Find(s$) Then
                          MyEr "No Key found", "Äåí âñÝèçêå êëåéäß"
                        ChangeValues = False
                        GoTo there
                    End If
                Else
                        MyEr "No Key found", "Äåí âñÝèçêå êëåéäß"
                        ChangeValues = False
                        GoTo there
                
                End If
lastindex = bb.Index
                
                If FastSymbol(rest$, ":=", , 2) Then
                    ah = aheadstatus(rest$, False) + " "
                    If Left$(ah, 1) = "N" Or InStr(ah, "l") > 0 Then
                        If Not IsExp(bstack, rest$, p) Then
                            ChangeValues = False
                            GoTo there
                        End If
                        ChangeValues = True
                        bb.Index = lastindex
                        If Not bstack.lastobj Is Nothing Then
                            Set bb.ValueObj = bstack.lastobj
                            Set bstack.lastobj = Nothing
                        Else
                            bb.Value = p
                        End If
                ElseIf Left$(ah, 1) = "S" Then
                        If Not IsStrExp(bstack, rest$, s$) Then
                            ChangeValues = False
                            GoTo there
                        End If
                        ChangeValues = True
                        bb.Index = lastindex
                        If Not bstack.lastobj Is Nothing Then
                            Set bb.ValueObj = bstack.lastobj
                            Set bstack.lastobj = Nothing
                        Else
                            bb.Value = s$
                        End If
                Else
                        MyEr "No Data found", "Äåí âñÝèçêáí óôïé÷åßá"
                        ChangeValues = False
                End If
                End If
        End If
    Loop
ElseIf bb.Done Then
If Not bstack.soros.IsEmpty Then
With bstack.soros
If .StackItemTypeIsObject(1) Then
Set bb.ValueObj = .PopObj

Else
bb.Value = .StackItem(1)
.drop 1
End If
End With
ChangeValues = True
Else

End If
Set bstack.lastobj = Nothing
End If


there:
Set bb = Nothing
Set aa = Nothing
End Function
Function ChangeValuesArray(bstack As basetask, rest$) As Boolean
Dim aa As mHandler, p As Variant, pppp As mArray, W As Long, s$, ah As String, stiva As mStiva
Dim bs As Long
Set aa = bstack.lastobj
Dim anything As Object
Set anything = aa
If CheckIsmArray(anything) Then
    Set pppp = anything
    Set anything = Nothing
    If Not pppp.Arr Then
        NotArray
        Exit Function
    End If
    bs = pppp.myarrbase
    FastSymbol rest$, ","
    Do
    If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
    On Error Resume Next
    W = CLng(Fix(p)) + bs
    If Err Then
        Err.Clear
        OutOfLimit
        Exit Function
    End If
    On Error GoTo 0
    If W < 0 Then W = pppp.count - W + bs
    If W > (pppp.count + bs) Then GoTo outlimit
    If W < 0 Then
outlimit:
    errOutOfLimit
    Exit Function
    End If
    
    If FastSymbol(rest$, ":=", , 2) Then
            
            ah = aheadstatus(rest$, False) + " "
            If Left$(ah, 1) = "N" Or InStr(ah, "l") > 0 Then
                If Not IsExp(bstack, rest$, p) Then
                    ChangeValuesArray = False
                    GoTo there
                End If
                ChangeValuesArray = True
                If Not bstack.lastobj Is Nothing Then
                    Set pppp.item(W) = bstack.lastobj
                    Set bstack.lastobj = Nothing
                Else
                    pppp.item(W) = p
                End If
                
            ElseIf Left$(ah, 1) = "S" Then
                If Not IsStrExp(bstack, rest$, s$) Then
                    ChangeValuesArray = False
                    GoTo there
                End If
                ChangeValuesArray = True
                If Not bstack.lastobj Is Nothing Then
                    Set pppp.item(W) = bstack.lastobj
                    Set bstack.lastobj = Nothing
                Else
                    pppp.item(W) = s$
                End If
            Else
                    MyEr "No Data found", "Äåí âñÝèçêáí óôïé÷åßá"
                    ChangeValuesArray = False
            End If
    End If
    End If
    Loop Until Not FastSymbol(rest$, ",")
Else
Set bstack.lastobj = aa
If CheckStackObj(bstack, anything) Then
    Set stiva = anything
    Set anything = Nothing
    FastSymbol rest$, ","
    Do
    If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
    On Error Resume Next
    W = CLng(Fix(p))
    If Err Then
        Err.Clear
        OutOfLimit
        Exit Function
    End If
    On Error GoTo 0
    If W < 0 Then W = stiva.count - W + 1
    If W > stiva.count Then GoTo outlimit
    If W < 0 Then GoTo outlimit
   
    If FastSymbol(rest$, ":=", , 2) Then
            
            ah = aheadstatus(rest$, False) + " "
            If Left$(ah, 1) = "N" Or InStr(ah, "l") > 0 Then
                If Not IsExp(bstack, rest$, p) Then
                    ChangeValuesArray = False
                    GoTo there
                End If
                ChangeValuesArray = True
                If Not bstack.lastobj Is Nothing Then
                    stiva.MakeTopItem W
                    stiva.drop 1
                    stiva.PushObj bstack.lastobj
                    stiva.MakeTopItemBack W
                    Set bstack.lastobj = Nothing
                Else
                    stiva.MakeTopItem W
                    stiva.drop 1
                    stiva.PushVal p
                    stiva.MakeTopItemBack W
                End If
                
            ElseIf Left$(ah, 1) = "S" Then
                If Not IsStrExp(bstack, rest$, s$) Then
                    ChangeValuesArray = False
                    GoTo there
                End If
                ChangeValuesArray = True
                If Not bstack.lastobj Is Nothing Then
                    stiva.MakeTopItem W
                    stiva.drop 1
                    stiva.PushObj bstack.lastobj
                    stiva.MakeTopItemBack W
                    Set bstack.lastobj = Nothing
                Else
                    stiva.MakeTopItem W
                    stiva.drop 1
                    stiva.PushStr s$
                    stiva.MakeTopItemBack W
                End If
            Else
                    MyEr "No Data found", "Äåí âñÝèçêáí óôïé÷åßá"
                    ChangeValuesArray = False
            End If
    End If
    End If
    Loop Until Not FastSymbol(rest$, ",")
End If
End If
there:
Set anything = Nothing
Set aa = Nothing
End Function
Sub FeedCopyInOut(bstack As basetask, var$, where As Long, Arr$)
Dim A  As Variant
A = Array(var$, Arr$, where)
If bstack.CopyInOutCol Is Nothing Then Set bstack.CopyInOutCol = New Collection
bstack.CopyInOutCol.Add A
End Sub
Sub CopyBack(bstack As basetask)
Dim A As Variant, aa As Object, x1 As Long, what$, rest$, oldHere$, w2 As Long, ii As Long
Dim pppp As mArray, s As String
Dim actualvar As String, ArrArg As String, LocalVar As String
oldHere$ = here$
here$ = vbNullString
again:
For Each A In bstack.CopyInOutCol
actualvar = A(0)
ArrArg = A(1)
LocalVar = A(2)
If Len(ArrArg) > 0 Then
x1 = rinstr(actualvar, ArrArg) + Len(ArrArg) - 1
JUMPHERE:
    If neoGetArray(bstack, Left$(actualvar, x1), pppp) Then
        If Not pppp.Arr Then GoTo cont123
        If Not NeoGetArrayItem(pppp, bstack, Left$(actualvar, x1), w2, Mid$(actualvar, x1 + 1)) Then GoTo cont123
        If MyIsObject(var(LocalVar)) Then
        If TypeOf pppp.itemObject(w2) Is Group Then
        If pppp.item(w2).IamApointer Then
            Set pppp.item(w2) = var(LocalVar)
        Else
        Set pppp.item(w2) = CopyGroupObj(var(LocalVar), Not pppp.GroupRef Is Nothing)
        End If
        Else
            Set pppp.item(w2) = var(LocalVar)
            End If
        Else
            pppp.item(w2) = var(LocalVar)
        End If
    End If
Else
    If bstack.ExistVar2(actualvar) Then
        
        If MyIsObject(var(LocalVar)) Then
            bstack.SetVarobJ actualvar, var(LocalVar)
        Else
            bstack.SetVar actualvar, var(LocalVar)
        End If
    Else
    ii = 1
    If FastPureLabel(actualvar, what$, ii, , , , False) > 4 Then
    x1 = ii - 1 'rinstr(actualvar, what$) + Len(what$) - 1
    GoTo JUMPHERE
    
    End If
    
    End If
End If
cont123:
Next
here$ = oldHere$
Set bstack.CopyInOutCol = Nothing

End Sub
Function GetOneAsString(bstack As basetask, rest$, what$, x1 As Long) As Boolean
Dim ss$
            If x1 > 4 Then
                    ss$ = BlockParam(rest$)
                    If Mid$(rest$, Len(ss$) + 1, 1) <> ")" Then Exit Function
                    what$ = what$ + ss$ + ")"
                   rest$ = Mid$(rest$, Len(ss$) + 2)
                    GetOneAsString = True
            End If
    
End Function
Function NewVarItem() As VarItem
    If TrushCount = 0 Then
    Set NewVarItem = New VarItem
      Exit Function
    End If
    Set NewVarItem = Trush(TrushCount)
    Set Trush(TrushCount) = Nothing
    TrushCount = TrushCount - 1
End Function
Function ExpMatrix(bstack As basetask, A$, r) As Boolean
Dim usehandler As mHandler
 If Not bstack.lastobj Is Nothing Then
                                If Typename(bstack.lastobj) = "mHandler" Then
                                    Set usehandler = bstack.lastobj
                                    Set bstack.lastobj = Nothing
                                    ExpMatrix = fMatrix(bstack, A$, usehandler, r)
                                    If MyIsObject(r) Then
                                    If TypeOf r Is BigInteger Then
                                        Set bstack.lastobj = r
                                    End If
                                    r = CDbl(0)
                                    
                                    End If
                                    Exit Function
                                ElseIf Typename(bstack.lastobj) = "mArray" Then
                                Set usehandler = New mHandler
                                usehandler.T1 = 3
                                Set usehandler.objref = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                    ExpMatrix = fMatrix(bstack, A$, usehandler, r)
                                    If MyIsObject(r) Then r = CDbl(0)
                                    Exit Function
                                End If
                            End If
                                SyntaxError
                                ExpMatrix = False
                                Exit Function
End Function
Sub targetsMyExec(MyExec As Long, b$, bb$, v As Long, di As Object, W$, bstack As basetask, VarStat As Boolean, temphere$)
Dim x1 As Long, y1 As Long, x2 As Long, y2 As Long, SBB$, nd&, p As Variant
Dim notglobal As Boolean, GuiForm As GuiM2000, GuiImg As GuiImage
Dim V1 As Long
    If TypeOf di Is MetaDc Then
        MyExec = 0
        oxiforMetaFiles
        Exit Sub
    End If
    notglobal = val("0" + di.Tag) > 32 Or TypeOf di Is GuiM2000
     If Abs(IsLabel(bstack, b$, W$)) = 1 Then
         If Not GetVar(bstack, W$, v) Then
             v = globalvar(W$, 0#, , VarStat, temphere$)
         Else
             If var(v) >= 330000 And Not notglobal Then
                MyEr "wrong target handler", "ëÜèïò ÷åéñéóôÞò óôü÷ïõ"
                MyExec = 0
                Exit Sub
             End If
         End If
     Else
         MyExec = 0
         Exit Sub
     End If

     If Not FastSymbol(b$, ",") Then
         MyExec = 0
         Exit Sub
     ElseIf IsStrExp(bstack, b$, bb$) Then
     If NocharsInLine(bb$) Then MyExec = 0: Exit Sub
     With players(GetCode(di))
        x1 = 1
        y1 = 1
        x2 = &H81000000
        y2 = &H81000000
        nd& = 0
        SBB$ = vbNullString
        On Error GoTo err123
        If FastSymbol(b$, ",") Then If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then x1 = Abs(p) Mod (.mX + 1): p = Empty
        If FastSymbol(b$, ",") Then If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then y1 = Abs(p) Mod (.mY + 1): p = Empty
        If FastSymbol(b$, ",") Then If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then x2 = CLng(Fix(p)): p = Empty
        If FastSymbol(b$, ",") Then If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then y2 = CLng(Fix(p)): p = Empty
        If FastSymbol(b$, ",") Then If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then nd& = Abs(p): p = Empty
        If FastSymbol(b$, ",") Then If Not IsStrExp(bstack, b$, SBB$) Then MissStringExpr: MyExec = 0: Exit Sub
        
err123:
        If Err.Number = 6 Then
            Overflow
            MyExec = 0
            Exit Sub
        End If
    
        If Not notglobal Then
            Targets = False
            MyDoEvents1 Form1
            ReDim Preserve q(UBound(q()) + 1)
            q(UBound(q()) - 1) = BoxTarget(bstack, x1, y1, x2, y2, SBB$, nd&, bb$, .Xt, .Yt, .uMineLineSpace)
            var(v) = UBound(q()) - 1
            Targets = True
        Else
            If TypeOf di Is GuiM2000 Then
            Set GuiForm = di
            var(v) = GuiForm.AddTarget(BoxTarget(bstack, x1, y1, x2, y2, SBB$, nd&, bb$, .Xt, .Yt, .uMineLineSpace))
            Else
            If GetVar(bstack, .ControlName, V1) Then
            Set GuiImg = var(V1)
            var(v) = GuiImg.AddTarget(BoxTarget(bstack, x1, y1, x2, y2, SBB$, nd&, bb$, .Xt, .Yt, .uMineLineSpace))
            End If
            End If
        End If
    End With
ElseIf IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
    If Not notglobal Then
    If var(v) < 320000 Then
    
        q(var(v)).Enable = Not (p = 0)
        RTarget bstack, q(var(v))
        End If
    Else
    If TypeOf di Is GuiM2000 Then
    Set GuiForm = di
    GuiForm.EnableTarget bstack, var(v), p
    Else
    If GetVar(bstack, players(GetCode(di)).ControlName, V1) Then
    Set GuiImg = var(V1)
    GuiImg.EnableTarget bstack, var(v), p
    End If
    End If
    End If
Else
    MyExec = 0
    Exit Sub
End If
End Sub

Function ProcUSE(basestack As basetask, rest$, Lang As Long) As Boolean
Dim ss$, ML As Long, X As Double, pa$, s$, stac1$, p As Variant, frm$, I As Long, W$, pppp As mArray
Dim it As Long, what$
If IsStrExp(basestack, rest$, ss$) Then   'gsb
ElseIf Not Abs(IsLabel(basestack, rest$, ss$)) = 1 Then ' WITHOUT " .gsb"
SyntaxError
Exit Function
End If
ML = 0
If UCase(ss$) = "PIPE" Or UCase(ss$) = "ÁÕËÏÕ" Then
ML = 1
End If

stac1$ = vbNullString
If FastSymbol(rest$, "!") And ML <> 1 Then
If VALIDATEpart(rest$, s$) Then
Do While s$ <> ""
    If ISSTRINGA(s$, pa$) Then
        basestack.soros.DataStr pa$
    ElseIf IsNumberD2(s$, X) Then
        basestack.soros.DataVal X
        X = vbEmpty
    Else
        Exit Do
    End If
Loop
Else
SyntaxError
Exit Function
End If
Else
If ML <> 1 Then
    Do
        If IsExp(basestack, rest$, p, nostring:=False) Then
            stac1$ = stac1$ + str$(p)
        ElseIf IsStrExp(basestack, rest$, s$, False) Then
            stac1$ = stac1$ + Sput(s$)
        Else
        Exit Do
        End If
        If Not FastSymbol(rest$, ",") Then Exit Do
    Loop
    pa$ = ExtractPath(ss$)
    para$ = RTrim$(".gsb " + Mid$(ss$, Len(ExtractPath(ss$) + ExtractName(ss$)) + 1))
    If pa$ = vbNullString Then pa$ = mcd
    frm$ = ExtractNameOnly(ss$)
    End If
End If

If Not IsLabelSymbolNew(rest$, "ÓÔÏ", "TO", Lang) Then

W$ = "S" + CStr(Int(Rnd(12) * 100000))

Else

Select Case Abs(IsLabel(basestack, rest$, ss$))

Case 3
    If GetVar(basestack, ss$, I) Then
       W$ = "V" + CStr(I)
       s$ = frm$
       frm$ = var(I)
       var(I) = vbNullString
      Else
     I = globalvar(ss$, "")
             If I <> 0 Then
              W$ = "V" + CStr(I)
              
            var(I) = vbNullString
            End If
                        
     End If
Case 6
   
     If neoGetArray(basestack, ss$, pppp) Then
            If Not NeoGetArrayItem(pppp, basestack, ss$, it, rest$) Then
        MyEr "Not such index for array", "Ðåñßìåíá óùóôïýò äåßêôåò ãéá ðßíáêá"
        
        Exit Function
        End If
     Else
     MyEr "Not such array, need to DIM fisrt", "Ðåñßìåíá ðßíáêá, ðñÝðåé íá ïñßóåéò Ýíáí"
: Exit Function
     End If
    
    W$ = "A" + CopyArrayItems(basestack, ss$) + str(it)  ''''''''''åäù ãéá ôïí íåï ðßíáêá ðñÝðåé íá äþóù ôï mArray???
    s$ = frm$
    frm$ = pppp.item(it)
    If pppp.ItemType(it) = doc Then
    Set pppp.item(it) = New Document
    Else
     pppp.item(it) = vbNullString
    End If
   
    Case Else
    SyntaxError
: Exit Function
   End Select
   If Left$(W$, 1) <> "S" Then

p = GetTaskId + 10000 ' starts from 10000
If Not IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then
's$ = validpipename(ss$)

If frm$ <> "" Then

ss$ = frm$
Else

ss$ = "M" + CStr(p)
End If

Thing W$, validpipename(ss$)
sThread CLng(p), 0, ss$, W$
TaskMaster.Message CLng(p), 3, CLng(100)
Exit Function
Else
Select Case Abs(IsLabel(basestack, rest$, what$))
Case 0 ' TAKE A NUMBER
If IsNumberLabel(rest$, what$) Then
frm$ = "S" + Right$("0000" + what$, 5)
p = val(what$)
s$ = frm$
If Left$(W$, 1) = "V" Then var(val(Mid$(W$, 2))) = validpipename(frm$)
Else
MyEr "No number found (5 digits)", "Äåí âñÞêá áñéèìü (5 øçößá)"
Exit Function
End If
Case 1
    If GetVar(basestack, what, I) Then
    If var(I) < 10000 Then var(I) = p Else p = var(I)
      Else
      globalvar what, p
                             
     End If
Case 5, 7
   
     If neoGetArray(basestack, what, pppp) Then
        If Not NeoGetArrayItem(pppp, basestack, ss$, it, rest$) Then
        MyEr "Not such index for array", "Ðåñßìåíá óùóôïýò äåßêôåò ãéá ðßíáêá"
      
        Exit Function
        End If
     Else
     MyEr "Not such array, need to DIM fisrt", "Ðåñßìåíá ðßíáêá, ðñÝðåé íá ïñßóåéò Ýíáí"
     
      Exit Function
     End If
     If pppp.item(it) < 10000 Then pppp.item(it) = p Else p = pppp.item(it)
    Case Else
    MyEr "Wrong parameter", "ËÜèïò ðáñÜìåôñïò"
     Exit Function
   End Select
   End If
End If
'ss$ = validpipename("M" & CStr(p))
'stac1$ = Sput(ss$) + stac1$
If frm$ <> "" Then
ss$ = frm$
Else
ss$ = "M" + CStr(p)
End If
frm$ = s$
sThread CLng(p), 0, ss$, W$
TaskMaster.Message CLng(p), 3, CLng(100)
ss$ = validpipename(ss$)
stac1$ = Sput(ss$) + stac1$
ss$ = "M" + CStr(p)
End If
If ML <> 1 Then
If stac1$ = vbNullString And Left$(s$, 1) = "S" Then
s$ = App.path
AddDirSep s$
s$ = s$ + "M2000.EXE "
If Shell(s$ + Chr(34) + pa$ + frm$ + ".gsb" + para$ + Chr(34), vbNormalFocus) > 0 Then
End If
End If
If Left$(W$, 1) = "V" Then
ss$ = GetTag$ + ".gsb"
Else
ss$ = W$ + ".gsb"
End If
I = FreeFile
On Error Resume Next
 If Not NeoUnicodeFile(strTemp + ss$) Then
 MyEr "can't save " + strTemp + ss$, "äåí ìðïñþ íá óþóù " + strTemp + ss$
what$ = vbNullString
 Exit Function
End If

Open GetDosPath(strTemp + ss$) For Output As I
If Err.Number > 0 Then
InternalError
what$ = vbNullString
Exit Function
End If
If stac1$ <> "" Then

' look for unicode...
Print #I, "STACK !" + stac1$ + ": DIR " + Chr(34) + pa$ + Chr(34) + " : LOAD " + Chr(34) + frm$ + para$ + Chr(34)

Else
Print #I, "DIR " + Chr(34) + pa$ + Chr(34) + " : LOAD " + Chr(34) + frm$ + para$ + Chr(34)

End If
Close I
tempList2delete = Sput(strTemp + ss$) + tempList2delete
s$ = App.path
AddDirSep s$
s$ = s$ + "M2000.EXE "
LastUse = MyShell(s$ + Chr(34) + strTemp + ss$ + Chr(34), vbNormalFocus - 4 * (ML <> 0 Or IsSymbol(rest$, ";")))
Sleep 1
If LastUse <> 0 Then

If ML = 0 Then
If IsSymbol(rest$, ";") Then
Else
'AppActivate LastUse
End If
End If
'killfile strTemp + ss$
End If
End If
ProcUSE = True
End Function

Function AddInventory(bstack As basetask, rest$, Optional ret2logical As Boolean = False) As Boolean
Dim p As Variant, s$, pppp As mArray, ppppAny As iBoxArray, lastindex As Long, usehandler As mHandler
If Not bstack.lastobj Is Nothing Then
If Typename(bstack.lastobj) = "mHandler" Then
Dim aa As mHandler
Set aa = bstack.lastobj
Set bstack.lastobj = Nothing
If Not aa.objref Is Nothing Then
If TypeOf aa.objref Is FastCollection Then
Dim bb As FastCollection
Set bb = aa.objref
If bb.structLen > 0 Then
MyEr "Structure members are ReadOnly", "Ôá ìÝëç ôçò äïìÞò åßíáé ìüíï ãéá áíÜãíùóç"
Exit Function
End If

Dim ah As String
FastSymbol rest$, ","
again:
AddInventory = True
ah = aheadstatus(rest$, False) + " "
If InStr(ah, "l") Then
If ret2logical Then ret2logical = False: Exit Function
MyEr "No logical expression", "¼÷é ëïãéêÞ Ýêöñáóç"
AddInventory = False
Else
If Left$(ah, 1) = "N" Then
    If Not IsExp(bstack, rest$, p) Then
        AddInventory = False
        GoTo there
    End If
    If VarType(p) = vbBoolean Then p = CLng(p)
    If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mHandler Then
        Set usehandler = bstack.lastobj
        If usehandler.T1 = 4 Then
        Set bstack.lastobj = Nothing
        GoTo noenum
        End If
        End If
        MyEr "No Object Allowed for Key", "Äåí åðéôñÝðåôáé áíôéêåßìåíï ãéá êëåéäß"
        AddInventory = False
        GoTo there
    End If
noenum:
    If bb.ExistKey0(p) Then
        MyEr "Key exist, must be unique", "Ôï êëåéäß õðÜñ÷åé, ðñÝðåé íá åßíáé ìïíáäéêü"
        AddInventory = False
        GoTo there
    End If
    bb.AddKey p
ElseIf Left$(ah, 1) = "S" Then
    If Not IsStrExp(bstack, rest$, s$) Then
        AddInventory = False
        GoTo there
    End If
    If Not bstack.lastobj Is Nothing Then
        MyEr "No Object Allowed for Key", "Äåí åðéôñÝðåôáé áíôéêåßìåíï ãéá êëåéäß"
        AddInventory = False
        GoTo there
    End If
    If bb.ExistKey0(s$) Then
        MyEr "Key exist, must be unique", "Ôï êëåéäß õðÜñ÷åé, ðñÝðåé íá åßíáé ìïíáäéêü"
        AddInventory = False
        GoTo there
    End If
    bb.AddKey s$

Else
        MyEr "No Key found", "Äåí âñÝèçêå êëåéäß"
        AddInventory = False
        GoTo there

End If
lastindex = bb.Index
If FastSymbol(rest$, ":=", , 2) Then
ah = aheadstatus(rest$, False) + " "
If Left$(ah, 1) = "N" Or InStr(ah, "l") > 0 Then
    If Not IsExp(bstack, rest$, p) Then
        AddInventory = False
        GoTo there
    End If
    bb.Index = lastindex
    If Not bstack.lastobj Is Nothing Then
    If TypeOf bstack.lastobj Is mArray Then
        Set pppp = New mArray
        bstack.lastobj.CopyArray pppp
        Set bb.ValueObj = pppp
        Set pppp = Nothing
        
    Else
      Set bb.ValueObj = bstack.lastobj
    End If
        Set bstack.lastobj = Nothing
        If TypeOf bb.ValueObj Is Group Then
        bb.ValueObj.ToDelete = False
        End If
    Else
        bb.Value = p
    End If
    
ElseIf Left$(ah, 1) = "S" Then
    If Not IsStrExp(bstack, rest$, s$) Then
        AddInventory = False
        GoTo there
    End If
    bb.Index = lastindex
    If Not bstack.lastobj Is Nothing Then
    If TypeOf bstack.lastobj Is mArray Then
        Set pppp = New mArray
        bstack.lastobj.CopyArray pppp
        Set bb.ValueObj = pppp
        Set pppp = Nothing
    Else
    
        Set bb.ValueObj = bstack.lastobj
        
    End If
        Set bstack.lastobj = Nothing
             If TypeOf bb.ValueObj Is Group Then
        bb.ValueObj.ToDelete = False
        End If
    Else
        bb.Value = s$
    End If

Else
        MyEr "No Data found", "Äåí âñÝèçêáí óôïé÷åßá"
        AddInventory = False
        GoTo there

End If


End If


End If
If FastSymbol(rest$, ",") Then GoTo again
there:
Set bb = Nothing
Set aa = Nothing

Exit Function
ElseIf TypeOf aa.objref Is mArray Then
While IsSymbol(rest$, ",")
If Not IsExp(bstack, rest$, p) Then
    MyEr "Expected Array", "Ðåñßìåíá Ðßíáêá"
    Set aa = Nothing
    Set bstack.lastobj = Nothing
    Exit Function
End If
Dim myobject As Object
Set myobject = bstack.lastobj
Set bstack.lastobj = Nothing
If CheckIsmArray(myobject) Then
Set pppp = myobject
pppp.AppendArray aa.objref
Else
    MyEr "Expected Array", "Ðåñßìåíá Ðßíáêá"
    Set aa = Nothing
    Set bstack.lastobj = Nothing
    Exit Function
End If
Wend
Set aa = Nothing
AddInventory = True
Exit Function
End If
End If
End If
MyEr "Wrong type of object (not Inventory or pointer to Array)", "ËÜèïò ôýðïò áíôéêåéìÝíïõ (ü÷é ÊáôÜóôáóç Þ äåßêôçò óå Ðßíáêá)"
Set aa = Nothing
End If
Set bstack.lastobj = Nothing
End Function
Sub OnlyForInventory()
MyEr "Only for Inventory object", "Ìüíï ãéá áíôéêåßìåíï ÊáôÜóôáóç"
End Sub
Function NewInventory(bstack As basetask, rest$, r, queue As Boolean) As Boolean
            Dim serr As Boolean, usehandler As mHandler
            
                    MakeitObjectInventory r, queue
                    Set usehandler = r
                    If queue Then usehandler.objref.AllowAnyKey
                    Set bstack.lastobj = usehandler
                    If FastSymbol(rest$, ":=", , 2) Then
                    If AddInventory(bstack, rest$, serr) Then
                            Set bstack.lastobj = r
                        r = 0
                        NewInventory = True
                    End If
                    Else
                        Set bstack.lastobj = r
                        r = 0
                        NewInventory = True
                    End If
                    
End Function
Function IsCdate(bstack As basetask, A$, r As Variant) As Boolean
Dim pp As Variant, par As Boolean, R2 As Variant, R3 As Variant, R4 As Variant
   If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
    pp = Abs(r) - Fix(Abs(r))
    r = Abs(r Mod 2958466)
    par = True
    If FastSymbol(A$, ",") Then
    par = IsExp(bstack, A$, R2, , True)
    If FastSymbol(A$, ",") Then
    par = IsExp(bstack, A$, R3, , True) And par
    If FastSymbol(A$, ",") Then
    par = IsExp(bstack, A$, R4, , True) And par
    
    End If
    End If
    End If
    
    If Not par Then
     MissParam A$
     Exit Function
                End If
                On Error Resume Next
    R3 = R3 + (R2 - Int(R2)) * 365
    R2 = Int(R2)
    R4 = R4 + (R3 - Int(R3)) * 30
    R3 = Int(R3)
     r = DateSerial(Year(r) + R2, Month(r) + R3, Day(r) + R4) + CDate(pp)
              If Err.Number > 0 Then
    WrongArgument A$
    Err.Clear
    Exit Function
    End If
    On Error GoTo 0
 IsCdate = FastSymbol(A$, ")", True)
   Else
   
     MissParam A$
    
    End If
    
End Function
Function IsTimeVal(bstack As basetask, A$, r As Variant) As Boolean
Dim s$
    If IsStrExp(bstack, A$, s$, False) Then
    On Error Resume Next
    If UCase(s$) = "UTC" Then
    r = GetUTCTime
    r = r - Int(r)
    Else
    r = CDate(TimeValue(s$))
    End If
    
         If Err.Number > 0 Then
    
    WrongArgument A$
    Err.Clear
    Exit Function
    End If
        On Error GoTo 0
    
    
    Else
     Dim usehandler As mHandler
     Set usehandler = New mHandler
     usehandler.T1 = 1
     usehandler.ReadOnly = True
     Set usehandler.objref = zones
        Set bstack.lastobj = usehandler
     r = r - r
    End If
IsTimeVal = FastSymbol(A$, ")", True)
End Function
Function IsDataVal(bstack As basetask, A$, r As Variant) As Boolean
 Dim s$, p
    If IsStrExp(bstack, A$, s$, False) Then
    If FastSymbol(A$, ",") Then
    If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
        p = Clid
    End If
    On Error Resume Next
    r = DateFromString(s$, p)
    
     If Err.Number > 0 Then
    
    WrongArgument A$
    Err.Clear
    Exit Function
    End If
    Else
    On Error Resume Next
    If s$ = "UTC" Then
    r = CDate(Int(GetUTCDate))
    Else
    r = DateValue(s$)
    End If
    
     If Err.Number > 0 Then
    
    WrongArgument A$
    Err.Clear
    Exit Function
    End If
    End If
    On Error GoTo 0
    
    IsDataVal = FastSymbol(A$, ")", True)
      Else
     
                MissParam A$
    End If

End Function
Function IsSymbolNoSpace(A$, C$, Optional L As Long = 1) As Boolean
' not for greek identifiers. see isStr1()
    Dim j As Long
    j = Len(A$)
    If j = 0 Then Exit Function
    If UCase(Mid$(A$, 1, L)) = C$ Then
        A$ = NLtrim$(Mid$(A$, L + 1))
        
        IsSymbolNoSpace = True
    End If
End Function
Function FindItem(bstackstr As basetask, v As Variant, A$, r$, w2 As Long, Optional ByVal wasarr As Boolean = False) As Boolean
Dim usehandler As mHandler, fastcol As FastCollection, pppp As mArray, w1 As Long, p As Variant, s$
'Dim prev As Variant
'Set prev = v
FindItem = True
againtype:
        r$ = Typename(v)
        If r$ = "mHandler" Then
            Set usehandler = v
            Select Case usehandler.T1
            Case 1
                Set fastcol = usehandler.objref
                If FastSymbol(A$, ")(", , 2) Or True Then
                    If IsExp(bstackstr, A$, p) Then
                        If Not fastcol.Find(p) Then GoTo keynotexist
                        If fastcol.IsObj Then
                            w2 = fastcol.Index
                            Set v = fastcol.ValueObj
                            GoTo againtype
                        Else
                            wasarr = True
                            GoTo Checkit
                        End If
                    ElseIf IsStrExp(bstackstr, A$, s$, Len(bstackstr.tmpstr) = 0) Then
                        If fastcol.IsObj Then
                            w2 = fastcol.Index
                           ' Set prev = v
                            Set v = fastcol.ValueObj
                            GoTo againtype
                        Else
                        If fastcol.structLen > 0 Then GoTo Checkit
                            r$ = Typename(fastcol.Value)
                        End If
                    Else
                        FindItem = False
                        Exit Function
keynotexist:
                        errOutOfLimit
                        FindItem = False
                        Exit Function
                    End If
                Else
                    ' new
Checkit:
                    If fastcol.structLen > 0 Then
                    FindItem = False
                    Exit Function
                    ElseIf wasarr Then
                    'r$ = Typename(fastcol.Value)
                    FindItem = False
                    Exit Function
                    Else
                    FindItem = False
                    Exit Function
                    End If
                End If
            Case 2
                'r$ = "Buffer"
                    FindItem = False
                    Exit Function
                
            Case 3
                w1 = usehandler.indirect
                If w1 > -1 And w1 <= var2used Then
                                r$ = VarTypeName(var(w1))
                                If r$ = "mHandler" Then Set v = var(w1): GoTo againtype
                    Else
                            r$ = Typename(usehandler.objref)
                                       If FastSymbol(A$, ")(", , 2) Or True Then
                                        If r$ = "mArray" Then
                                            Set pppp = usehandler.objref
                                                If IsExp(bstackstr, A$, p) Then
                                                   pppp.Index = p
                                                    If MyIsObject(pppp.Value) Then
                                                    w2 = p
                                                   ' Set prev = v
                                                         Set v = pppp.Value
                                                         wasarr = False
                                                         GoTo againtype
                                                    Else
                                                       ' r$ = vartypename(pppp.Value)
                                                    End If
                                                Else

                                                FindItem = False
                                                Exit Function
                                            End If
                                        Else
                                                FindItem = False
                                                Exit Function
                                        End If
                                        
                                        End If
                                        
                                        End If
                                    
            Case 4
                    FindItem = False
                    Exit Function
            Case Else
                r$ = Typename(usehandler.objref)
                
            End Select
        ElseIf Typename(v) = "PropReference" Then
                    FindItem = False
                    Exit Function
        End If
        Set bstackstr.lastobj = Nothing
        Set bstackstr.lastpointer = Nothing
        FindItem = FastSymbol(A$, ")")
        If usehandler Is Nothing Then FindItem = False: Exit Function
        If TypeOf usehandler.objref Is mArray Then
            Set v = usehandler.objref
        Else
         Set pppp = New mArray
            Set pppp.GroupRef = usehandler
            pppp.Arr = False
            w2 = -101
            Set v = pppp
        End If
End Function


Function HaveMark(bstack As basetask, A As Long, b As Boolean) As Boolean
Dim s As mStiva2
Set s = bstack.RetStack
If s.Total >= 3 Then
HaveMark = s.LookTopVal = -3
A = s.StackItem(2)
b = s.StackItem(3)
End If
End Function
Function HaveMark2(bstack As basetask) As Boolean
Dim s As mStiva2
Set s = bstack.RetStack
If s.Total >= 3 Then
If s.LookTopVal = -3 Then s.drop 3: HaveMark2 = True
End If
End Function
Sub DropMark(bstack As basetask)
Dim s As mStiva2
Set s = bstack.RetStack
If s.Total >= 3 Then
If s.LookTopVal = -3 Then s.drop 3
End If
End Sub
Function interpret(bstack As basetask, b$, Optional ByPass As Boolean) As Boolean
Dim di As Object, myobject As Object, I As Long, x1 As Long, ok As Boolean, sp As Variant
Dim usehandler As mHandler, usehandler2 As mHandler
Set di = bstack.Owner
Dim prive As basket, cb As CodeBlock
'b$ = Trim$(b$)
Dim W$, ww#, LLL As Long, sss As Long, v As Long, p As Variant, ss$, sw$, ohere$
Dim pppp As mArray, i1 As Long, Lang As Long
Dim r1 As Long, R2 As Long
' uink$ = VbNullString
di.FontTransparent = True

SetBkMode di.Hdc, 1
ohere$ = here$
If Not ByPass Then here$ = vbNullString
bstack.LoadOnly = ByPass
sss = Len(b$)
Do While Len(b$) <> LLL
If LastErNum <> 0 Then Exit Do
LLL = Len(b$)

If FastSymbol(b$, ".") Then
' run in codeblock
            Set cb = New CodeBlock
            cb.Construct b$
            cb.ExportStr bstack
            cb.codeline (0)
            
ElseIf FastSymbol(b$, "{") Then
If Not interpret(bstack, block(b$)) Then interpret = False: here$ = ohere$: GoTo there1
If FastSymbol(b$, "}") Then
sss = Len(b$)
GoTo loopcontinue1
'LLL = Len(b$)


Else
interpret = False: here$ = ohere$: GoTo there1
End If
End If
jumpforCR1:
If FastSymbol(b$, vbCrLf, , 2) Then
        While FastSymbol(b$, vbCrLf, , 2)
        Wend
     ''   UINK$ = VbNullString
        sss = LLL
        End If

While MaybeIsSymbol(b$, "\'/")
 SetNextLine b$
    sss = Len(b$)
    LLL = sss
Wend
While FastSymbol(b$, ":")
sss = LLL

Wend
If NOEXECUTION Then interpret = False: here$ = ohere$: GoTo there1

If NocharsInLine(b$) Then interpret = True: here$ = ohere$: GoTo there1
If IsSymbol(b$, "@") Then
i1 = IsLabelAnew("", b$, W$, Lang)  '' NO FORM AA@BBB ALLOWED HERE
W$ = "@" + W$
GoTo PROCESSCOMMAND   'IS A COMMAND
Else
i1 = IsLabelAnew("", b$, W$, Lang) '' NO FORM AA@BBB ALLOWED HERE
End If
  If trace And (bstack.Process Is Nothing) And Not bypasstrace Then
  If bstack.IamLambda Then
  If pagio$ = "GREEK" Then
  Form2.label1(0) = "ËÁÌÄÁ()"
  Else
  Form2.label1(0) = "LAMBDA()"
  End If
  Else
    Form2.label1(0) = here$
    End If
    Form2.label1(1) = W$
    Form2.label1(2) = GetStrUntil(vbCrLf, b$ + vbCrLf, False)
 TestShowSub = vbNullString
 TestShowStart = 0
    Set Form2.Process = bstack
    stackshow bstack
    If Not Form1.Visible Then
    Form1.Show , Form5   'OK
    End If

    If STbyST And bstack.IamChild Then
        STbyST = False
        If Not STEXIT Then
        If Not STq Then
        Form2.gList4.ListIndex = 0
        End If
        End If
        Do
        If di.Visible Then di.Refresh
        ProcTask2 bstack
        Loop Until STbyST Or STq Or STEXIT Or NOEXECUTION Or myexit(bstack)
            If Not STEXIT Then
        If Not STq Then
        Form2.gList4.ListIndex = 0
        End If
        End If
        STq = False
        If STEXIT Then
        NOEXECUTION = True
        trace = False
        STEXIT = False
        GoTo there1
        End If
    End If
'Sleep 5
   '' SleepWaitNO 5
    If STEXIT Then
    
    trace = False
    STEXIT = False
    GoTo there1
    Else
    
    End If
End If
Select Case i1
Case 1234
GoTo jumpforCR1
Case 2
NoRef2
interpret = False
GoTo there1
Case 1

    If sss = LLL Then
  If comhash.Find2(W$, I, v) Then
  If v <> 0 Then GoTo PROCESSCOMMAND
  End If
    ss$ = vbNullString
    If MaybeIsSymbol(b$, "/*-+=~^|<>") Then
        If FastOperator(b$, "<=", I, 2, False) Then
        ' LOOK GLOBAL
        If GetVar(bstack, W$, v, True) Then
        W$ = varhash.lastkey
            Mid$(b$, I, 2) = "  "
            
            GoTo assignvalue
        ElseIf GetlocalVar(W$, v) Then
            W$ = varhash.lastkey
            Mid$(b$, I, 2) = "  "
            GoTo assignvalue
        Else
            ' NO SUCH VARIABLE
            interpret = False
            GoTo there1
        End If
        ' do something here
        ElseIf varhash.Find(myUcase(W$), v) Then
        ' CHECK VAR
            If FastOperator(b$, "=", I) Then
assignvalue:
                If MyIsNumeric(var(v)) Then
assignvalue2:
                    If IsExp(bstack, b$, p) Then
assignvalue3:
                        If bstack.lastobj Is Nothing Then
                        If VarType(var(v)) = vbLong Then
                        On Error Resume Next
                            var(v) = CLng(p)
                            If Err.Number > 0 Then OverflowValue vbLong: interpret = 0: GoTo there1
                            On Error GoTo 0
                        Else
                            var(v) = p
                        End If
                        Else
checkobject:
                        Set myobject = bstack.lastobj
                            If TypeOf bstack.lastobj Is Group Then ' oh is a group
                                Set bstack.lastobj = Nothing
                                UnFloatGroup bstack, W$, v, myobject, True ' global??
                                Set myobject = Nothing
                            ElseIf CheckIsmArray(myobject) Then
                                    Set usehandler = New mHandler
                                    usehandler.T1 = 3
                                    Set usehandler.objref = myobject
                                    Set var(v) = usehandler
                                    If TypeOf bstack.lastobj Is mHandler Then
                                        Set usehandler2 = bstack.lastobj
                                        With usehandler2
                                            If .UseIterator Then
                                                usehandler.UseIterator = True
                                                usehandler.index_start = .index_start
                                                usehandler.index_End = .index_End
                                                usehandler.index_cursor = .index_cursor
                                            End If
                                        End With
                                    End If
                                    Set usehandler2 = Nothing
                                    Set usehandler = Nothing
                            ElseIf TypeOf myobject Is mHandler Then
                                Set usehandler2 = myobject
                                If usehandler2.indirect > -1 Then
                                    Set var(v) = var(usehandler2.indirect)
                                Else
                                    Set var(v) = usehandler2
                                End If
                                Set usehandler2 = bstack.lastobj
                                Set usehandler = var(v)
                                With usehandler2
                                    If .UseIterator Then
                                        usehandler.UseIterator = True
                                        usehandler.index_start = .index_start
                                        usehandler.index_End = .index_End
                                        usehandler.index_cursor = .index_cursor
                                    End If
                                End With
                                Set usehandler2 = Nothing
                                Set usehandler = Nothing
                                Set bstack.lastobj = Nothing
                            ElseIf TypeOf myobject Is lambda Then
                                GlobalSub W$ + "()", "", , , v
                                Set var(v) = myobject
                                Set bstack.lastobj = Nothing
                            ElseIf TypeOf myobject Is mEvent Then
                             Set var(v) = myobject
                            CopyEvent var(v), bstack
                            Set var(v) = bstack.lastobj
                            ElseIf TypeOf myobject Is BigInteger Then
                            Set var(v) = CopyBigInteger(myobject)
                            
                            ElseIf TypeOf myobject Is VarItem Then
                                
                                var(v) = myobject.ItemVariant
                            Else
                                Set myobject = Nothing
                                Set bstack.lastobj = Nothing
                                If VarType(var(v)) = vbLong Then
                                    NoObjectpAssignTolong
                                    
                                Else
                                
                                    NoObjectAssign
                                End If
                                interpret = False: GoTo there1
                            End If
                            Set bstack.lastobj = Nothing
                            Set myobject = Nothing
                        End If

                    ElseIf IsStrExp(bstack, b$, ss$, Len(bstack.tmpstr) = 0) Then
                    If bstack.lastobj Is Nothing Then
                    'If VarType(var(v)) = vbEmpty Or VarType(var(v)) = vbString Then
                        var(v) = ss$
                   ' ElseIf ss$ = vbNullString Then
                   ' var(v) = 0#
                   ' Else
                    'If IsNumberCheck(ss$, p) Then
                    'var(v) = p
                    'End If
                    'End If
                    Else
                    GoTo checkobject
                    End If
                    Else
                    ' if is string then what???
                    If Typename(bstack.lastobj) = "mHandler" Then
                    GoTo checkobject
                    End If
                        NoValueForVar W$
                        interpret = False
                        GoTo there1
                    End If
                    GoTo loopcontinue1
                    
                Else
                    If Not MyIsObject(var(v)) Then
                        If IsStrExp(bstack, b$, ss$) Then
                        If VarType(var(v)) = vbString Then
                        var(v) = ss$
                        ElseIf ss$ = vbNullString Then
                            var(v) = 0#
                        Else
                            If IsNumberCheck(ss$, p) Then
                                var(v) = p
                            End If
                        End If
                        GoTo loopcontinue1
                    Else
                        If i1 = 1 Then
                        GoTo assignvalue2
                        End If
                        MyEr "Expected String expression", "Ðåñßìåíá Ýêöñáóç ÁëöáñéèìçôéêÞ"
                        Exit Function
                    End If
                ElseIf var(v) Is Nothing Then
                    AssigntoNothing  ' Use Declare
                    interpret = False
                    GoTo there1
                ElseIf TypeOf var(v) Is Group Then
                    If IsExp(bstack, b$, p) Then
                        If var(v).HasSet Then
                            If bstack.lastobj Is Nothing Then
                                bstack.soros.PushVal p
                            Else
                                bstack.soros.PushObj bstack.lastobj
                                Set bstack.lastobj = Nothing
                            End If
                            NeoCall2 bstack, W$ + "." + ChrW(&H1FFF) + ":=()", ok
                    ElseIf bstack.lastobj Is Nothing Then
                        NeedAGroupInRightExpression
                        interpret = False
                        GoTo there1
                    ElseIf TypeOf bstack.lastobj Is Group Then
                        Set myobject = bstack.lastobj
                        Set bstack.lastobj = Nothing
                        ss$ = bstack.GroupName
                        If var(v).HasValue Or var(v).HasSet Then
                            PropCantChange
                            interpret = 0
                            GoTo there1
                        Else
                            If Len(var(v).GroupName) > Len(W$) Then
                                UnFloatGroupReWriteVars bstack, W$, v, myobject
                            Else
                                bstack.GroupName = Left$(W$, Len(W$) - Len(var(v).GroupName) + 1)
                                If Len(var(v).GroupName) > 0 Then
                                    W$ = Left$(var(v).GroupName, Len(var(v).GroupName) - 1)
                                    UnFloatGroupReWriteVars bstack, W$, v, myobject
                                Else
                                    GroupWrongUse
                                    interpret = 0
                                    GoTo there1
                                End If
                            End If
                        End If
                        Set myobject = Nothing
                        bstack.GroupName = ss$
                    Else
                        WrongObject
                        interpret = False
                        GoTo there1
                    End If
                    GoTo loopcontinue1
                Else
noexpression:
                Set myobject = Nothing
                Set bstack.lastobj = Nothing
                MissNumExpr
                interpret = False
                GoTo there1
            End If
        ElseIf TypeOf var(v) Is PropReference Then
            If IsExp(bstack, b$, p) Then
                If FastSymbol(b$, "@") Then
                    If IsExp(bstack, b$, sp) Then
                        var(v).Index = p: sp = 0
                    ElseIf IsStrExp(bstack, b$, ss$) Then
                        var(v).Index = ss$: ss$ = vbNullString
                    End If
                    var(v).UseIndex = True
                End If
                var(v).Value = p
            Else
                GoTo noexpression
            End If
            GoTo loopcontinue1
        ElseIf TypeOf var(v) Is Constant Then
11212
            CantAssignValue
            interpret = False
            GoTo there1
        ElseIf TypeOf var(v) Is BigInteger Then
            If IsExpBig(bstack, b$, p) Then
           
            If bstack.lastobj Is Nothing Then
                var(v) = Module13.CreateBigInteger(CStr(Int(p)))
            ElseIf TypeOf bstack.lastobj Is BigInteger Then
                Set var(v) = CopyBigInteger(bstack.lastobj)
                Set bstack.lastobj = Nothing
            Else
                Set bstack.lastobj = Nothing
                ExpectedObj VarTypeName(var(v))
                           GoTo there1
            End If
            ElseIf IsStrExp(bstack, b$, ss$) Then
                var(v) = ss$
            Else
            ExpectedObj VarTypeName(var(v))
                           GoTo there1
            End If
        ElseIf TypeOf var(v) Is lambda Then
            ' exist and take something else
            If IsExp(bstack, b$, p) Then
                If bstack.lastobj Is Nothing Then
                    Expected "lambda", "ëÜìäá"
                ElseIf TypeOf bstack.lastobj Is lambda Then
                    Set var(v) = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    GoTo loopcontinue1
                Else
                    Expected "lambda", "ëÜìäá"
                End If
                interpret = False
                GoTo there1
            Else
                MissNumExpr
                interpret = False
                GoTo there1
            End If
        ElseIf TypeOf var(v) Is mHandler Then  ' CHECK IF IT IS A HANDLER
            Set usehandler = var(v)
            If IsExp(bstack, b$, p) Then
                If usehandler.ReadOnly Then
                    ReadOnly
                    interpret = False: GoTo there1
                End If
                If bstack.lastobj Is Nothing Then
                    NoObjectFound
                    interpret = False: GoTo there1
                ElseIf Typename(bstack.lastobj) = "mHandler" Then
                    Set usehandler = bstack.lastobj
                    Set myobject = New mHandler
                    usehandler.CopyTo myobject
                    Set var(v) = myobject
                ElseIf Typename(bstack.lastobj) = myArray Then
                    Set usehandler = New mHandler
                    usehandler.T1 = 3
                    Set usehandler.objref = bstack.lastobj
                    Set var(v) = usehandler
                    Set usehandler = Nothing
                Else
                    Set usehandler = var(v)
                    usehandler.T1 = 0
                    Set usehandler.objref = bstack.lastobj
                    Set usehandler = Nothing
                End If
                Set myobject = Nothing
            Else
                MissNumExpr
                interpret = False
                GoTo there1
            End If
            Set bstack.lastobj = Nothing
            Set myobject = Nothing
        ElseIf TypeOf var(v) Is mEvent Then
            If IsExp(bstack, b$, p) Then
                Set var(v) = bstack.lastobj
                CopyEvent var(v), bstack
                Set var(v) = bstack.lastobj
                Set bstack.lastobj = Nothing
            Else
                MissNumExpr
                interpret = 0
                GoTo there1
            End If
        Else
            I = 1
            GoTo somethingelse
        End If
    End If
Else
    ' or do something else
somethingelse:
    If InStr("/*-+=~^&|<>", Mid$(b$, I, 1)) > 0 Then
        If InStr("/*-+=~^&|<>!", Mid$(b$, I + 1, 1)) > 0 Then
            ss$ = Mid$(b$, I, 2)
            Mid$(b$, I, 2) = "  "
        Else
            ss$ = Mid$(b$, I, 1)
            Mid$(b$, I, 1) = " "
        End If
    Else
        GoTo PROCESSCOMMAND
    End If
    On Error GoTo forlong
    If MyIsNumeric(var(v)) Then
        If VarType(var(v)) = vbLong Then
            On Error GoTo forlong
                Select Case ss$
                    Case "="
                        v = globalvar(W$, CLng(p), , True)
                        GoTo assignvalue2
                    Case "+="
                        If IsExp(bstack, b$, p) Then
                            var(v) = CLng(Int(p) + var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "-="
                        If IsExp(bstack, b$, p) Then
                            var(v) = CLng(-Int(p) + var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "*="
                        If IsExp(bstack, b$, p) Then
                            var(v) = CLng(Int(p) * var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "/="
                        If IsExp(bstack, b$, p) Then
                            If Int(p) = 0 Then
                                DevZero
                                interpret = False
                                GoTo there1
                            End If
                            var(v) = CLng(var(v) / Int(p))
                        Else
                            GoTo noexpression
                        End If
                    Case "-!"
                        var(v) = CLng(-var(v))
                    Case "++"
                        var(v) = CLng(1 + var(v))
                    Case "--"
                        var(v) = CLng(var(v) - 1)
                    Case "~"
                        var(v) = CLng(-1 - (var(v) <> 0))
                    Case Else
                        GoTo PROCESSCOMMAND
                End Select
                On Error GoTo 0
            Else
                Select Case ss$
                    Case "="
                        v = globalvar(W$, p, , True)
                        GoTo assignvalue2
                    Case "+="
                        If IsExp(bstack, b$, p) Then
                            AssignTypeNumeric2 p, VarType(var(v))
                            var(v) = p + var(v)
                            If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "-="
                    
                        If IsExp(bstack, b$, p) Then
                        AssignTypeNumeric2 p, VarType(var(v))
                            var(v) = -p + var(v)
                            If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "*="
                        If IsExp(bstack, b$, p) Then
                            AssignTypeNumeric2 p, VarType(var(v))
                            
                            var(v) = p * var(v)
                             If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "/="
                        If IsExp(bstack, b$, p) Then
                            AssignTypeNumeric2 p, VarType(var(v))
                            If p = 0 Then
                                DevZero
                                interpret = False
                                GoTo there1
                            End If
                            
                            var(v) = var(v) / p
                            If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "-!"
                        var(v) = -var(v)
                    Case "++"
                        var(v) = 1 + var(v)
                    Case "--"
                        var(v) = var(v) - 1
                    Case "~"
                     
                         Select Case VarType(var(v))
                        Case vbBoolean
                            var(v) = Not CBool(var(v))
                        Case vbCurrency
                            var(v) = CCur(Not CBool(var(v)))
                        Case vbDecimal
                            var(v) = CDec(Not CBool(var(v)))
                        Case Else
                            var(v) = CDbl(Not CBool(var(v)))
                        End Select
                        
                        
                    Case Else
                        Mid$(b$, I, Len(ss$)) = ss$
                        GoTo PROCESSCOMMAND
                    End Select
                    On Error Resume Next
                End If
                
            ElseIf TypeOf var(v) Is Group Then
                If IsExp(bstack, b$, p) Then
                    If bstack.lastobj Is Nothing Then
                        bstack.soros.PushVal p
                    Else
                        bstack.soros.PushObj bstack.lastobj
                        Set bstack.lastobj = Nothing
                    End If
                End If
                NeoCall2 bstack, W$ + "." + ChrW(&H1FFF) + ss$ + "()", ok
                If Not ok Then
                    If LastErNum = 0 Then MissOperator ss$
                    interpret = False
                    GoTo there1
                End If
            Else
            If myVarType(var(v), vbString) Then
            If ss$ = "=" Then
                GoTo constr2
            ElseIf ss$ = "+=" Then
                GoTo constr3
            End If
            End If
                Set myobject = var(v)
                    If CheckIsmArray(myobject) Then
                        If IsExp(bstack, b$, p) Then
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is mArray Then
                                    Set usehandler = New mHandler
                                    Set var(v) = usehandler
                                    usehandler.T1 = 3
                                    Set usehandler.objref = bstack.lastobj
                                    Set usehandler = Nothing
                                Else
                                    Set myobject = bstack.lastobj
                                    If CheckIsmArray(myobject) Then
                                        Set usehandler = New mHandler
                                        Set var(v) = usehandler
                                        usehandler.T1 = 3
                                        Set usehandler.objref = myobject
                                        Set usehandler = Nothing
                                    Else
                                        NotArray
                                        interpret = False
                                        GoTo there1
                                    End If
                                End If
                            Else
                                myobject.Compute2 p, ss$
                            End If
                            Set myobject = Nothing
                            Set bstack.lastobj = Nothing
                        Else
                            myobject.Compute3 ss$
                            Set myobject = Nothing
                            Set bstack.lastobj = Nothing
                        End If
                    ElseIf TypeOf myobject Is mHandler Then
                    Set usehandler = myobject
                    If usehandler.T1 = 4 Then
                        If usehandler.ReadOnly Then
                                ReadOnly
                             interpret = False
                                GoTo there1
                        ElseIf ss$ = "++" Then
                        If usehandler.index_start < usehandler.objref.count - 1 Then
                            usehandler.index_start = usehandler.index_start + 1
                            usehandler.objref.Index = usehandler.index_start
                            usehandler.index_cursor = usehandler.objref.Value
                        End If
                        ElseIf ss$ = "--" Then
                    If usehandler.index_start > 0 Then
                            usehandler.index_start = usehandler.index_start - 1
                            usehandler.objref.Index = usehandler.index_start
                            usehandler.index_cursor = usehandler.objref.Value
                        End If
                        ElseIf ss$ = "-!" Then
                        usehandler.sign = -usehandler.sign
                        Else
                        NoOperatorForThatObject ss$
                         interpret = False
                            GoTo there1
                        End If
                        End If
                    Else
                    MyEr "Object not support operator " + ss$, "Ôï áíôéêåßìåíï äåí õðïóôçñßæåé ôï ôåëåóôÞ " + ss$
                    interpret = False
                    GoTo there1
                    End If
                End If
            End If
            Set usehandler = Nothing
            Set myobject = Nothing
            GoTo loopcontinue1
        ElseIf Not bstack.StaticCollection Is Nothing Then
            If bstack.ExistVar(W$) Then
                If FastOperator(b$, "=", I) Then
                    If IsExp(bstack, b$, p) Then
checkobject1:
                        Set myobject = bstack.lastobj
                        If CheckIsmArray(myobject) Then
                            Set usehandler = New mHandler
                            Set bstack.lastobj = usehandler
                            usehandler.T1 = 3
                            bstack.SetVarobJ W$, myobject
                            Set usehandler = Nothing
                        Else
                            bstack.SetVar W$, p
                        End If
                        Set myobject = Nothing
                        Set usehandler = Nothing
                        Set bstack.lastobj = Nothing
                        GoTo loopcontinue1
                    ElseIf IsStrExp(bstack, b$, ss$) Then
                        If bstack.lastobj Is Nothing Then
                            If ss$ = vbNullString Then
                                p = 0
                            Else
                                p = val(ss$)
                            End If
                        End If
                        GoTo checkobject1
                    Else
                        GoTo aproblem1
                    End If
                Else
                    If InStr("/*-+~", Mid$(b$, I, 1)) > 0 Then
                        If InStr("=+-!", Mid$(b$, I + 1, 1)) > 0 Then
                            ss$ = Mid$(b$, I, 2)
                            Mid$(b$, I, 2) = "  "
                        Else
                            ss$ = Mid$(b$, I, 1)
                            Mid$(b$, I, 1) = " "
                        End If
                    End If
                    If Not bstack.AlterVar(W$, p, ss$, False) Then interpret = False: GoTo there1
                    GoTo loopcontinue1
                End If
            End If
            If FastOperator(b$, "=", I) Then ' MAKE A NEW ONE IF FOUND =
                v = globalvar(W$, p, , True)
                GoTo assignvalue
            ElseIf GetVar(bstack, W$, v, True) Then
                GoTo somethingelse
            End If
        ElseIf FastOperator(b$, "=", I) Then ' MAKE A NEW ONE IF FOUND =
jumpiflocal:
            v = globalvar(W$, p, , True)
            GoTo assignvalue
        ElseIf GetVar(bstack, W$, v, True) Then
        ' CHECK FOR GLOBAL
            GoTo somethingelse
            Else
        GoTo PROCESSCOMMAND
        End If
    Else
          '**********************************************************
PROCESSCOMMAND:
        Dim y1 As Long
        Dim x2 As Long, y2 As Long, SBR$, nd&
        If Trim$(W$) <> "" Then
            Select Case W$
                Case "CALL", "ÊÁËÅÓÅ"
                    ' CHECK FOR NUMBER...
                    If bstack.NoRun Then
                        bstack.callx1 = 0
                        bstack.callohere = vbNullString
                        b$ = NLtrim(b$)
                        SetNextLineNL b$
                    Else
                        If lckfrm > 0 Then lckfrm = sb2used + 1
                        NeoCall ObjPtr(bstack), b$, Lang, ok
                        If Not ok Then
                            interpret = 0
                            GoTo there1
                        End If
                    End If
                Case " ", ChrW(160), vbTab
                Case "SLOW", "ÁÑÃÁ"
                    extreme = False
                    SLOW = True
                    interpret = True
                    here$ = ohere$
                    GoTo there1
                Case "FAST", "ÃÑÇÃÏÑÁ"
                    If FastSymbol(b$, "!") Then extreme = True Else extreme = False
                    SLOW = False
                    interpret = True
                    here$ = ohere$
                    GoTo there1
                Case "GLOBAL", "ÃÅÍÉÊÏ", "ÃÅÍÉÊÇ", "ÃÅÍÉÊÅÓ", "LOCAL", "ÔÏÐÉÊÁ", "ÔÏÐÉÊÇ", "ÔÏÐÉÊÅÓ"
                    b$ = W$ + " " + b$
                    interpret = Execute(bstack, b$, True) = 1
                    GoTo there1
                Case "USER", "×ÑÇÓÔÇÓ"
                    ss$ = PurifyPath(GetStrUntil("\", Trim$(GetNextLine(b$) + "\")))
                    If ss$ <> "" Then
                        dset
                        userfiles = GetSpecialfolder(CLng(26)) + "\M2000_USER\"
                        If Not isdir(userfiles) Then MkDir userfiles
                        ss$ = AddBackslash(userfiles + ss$)
                        If PathMakeDirs(ss$) Or isdir(ss$) Then
                            userfiles = ss$
                            mcd = userfiles
                            original bstack, "CLS"
                        Else
                            PlainBaSket di, players(GetCode(di)), "Bad User Name"
                        End If
                    Else
                        ss$ = UCase(userfiles)
                        DropLeft "\M2000_USER\", ss$
                        If Len(ss$) > 0 Then
                            PlainBaSket di, players(GetCode(di)), GetStrUntil("\", Tcase(ss$))
                        End If
                    End If
                    interpret = True
                    GoTo there1
                Case "TARGET", "ÓÔÏ×ÏÓ"
                    R2 = 0
                    ss$ = vbNullString
                    targetsMyExec R2, b$, ss$, v, di, W$, bstack, True, ""
                    If R2 = 0 Then
                        interpret = False
                        here$ = ohere$: GoTo there1
                    End If
                Case "ÄÉÁÊÏÐÔÅÓ", "SWITCHES"
                    If IsStrExp(bstack, b$, ss$) Then
                    Switches ss$, bstack.IamChild Or bstack.IamAnEvent  ' NON LOCAL FROM cli OR using SET SWITCHES
                End If
                Case "MONITOR", "ÅËÅÃ×ÏÓ"
                    If IsSupervisor Then
                    prive = players(GetCode(di))
                    
                    monitor bstack, prive, Lang
                    players(GetCode(di)) = prive
                    Else
                    BadCommand
                    End If
                Case "ÓÅÍÁÑÉÏ", "SCRIPT"
                If IsLabelOnly(b$, ss$) Then
                 If GetSub(myUcase(ss$, True), nd&) Then
                           b$ = vbCrLf + sbf(nd&).sb + b$
                   Else
                   b$ = ss$ + " " + b$
                   If IsStrExp(bstack, b$, W$) Then
                           b$ = vbCrLf + W$ + b$
                   Else
                   ' skip
                   End If
                   End If
                ElseIf IsStrExp(bstack, b$, W$) Then
                           b$ = vbCrLf + W$ + b$
                   End If
Case "RETURN", "ÅÐÉÓÔÑÏÖÇ"
    LastErNum = 0
       If IsExp(bstack, b$, p) Then
                If bstack.lastobj Is Nothing Then
                ElseIf Typename(bstack.lastobj) = "mHandler" Then
                        Select Case bstack.lastobj.T1
                           Case 1
                                  If ChangeValues(bstack, b$) Then GoTo loopcontinue1
                                  
                           Case 2
                                    If ChangeValuesMem(bstack, b$, Lang) Then GoTo loopcontinue1
                           Case 3
                                    If ChangeValuesArray(bstack, b$) Then GoTo loopcontinue1
                           End Select
                End If
            ElseIf IsStrExp(bstack, b$, ss$, Len(bstack.tmpstr) = 0) Then
                    append_table bstack, ss$, b$, True, Lang
                GoTo loopcontinue1
                 End If
  BadUseofReturn
       interpret = False
       GoTo there1
            Case "CONTINUE", "ÓÕÍÅ×ÉÓÅ"
            If HaltLevel > 0 Then
                     If NORUN1 Then NORUN1 = False: interpret = True: b$ = vbNullString: GoTo there1   ' send environment....to hell
                    If bstack.IamChild Or bstack.IamAnEvent Then NERR = True: NOEXECUTION = True
                    ExTarget = True: INK$ = Chr(27): UKEY$ = Chr$(27)  ': UINK$ = Chr(27)    ' send escape...for any good reason...
            Else
            GoTo contnoproper
            End If
            Case "CONST", "ÓÔÁÈÅÑÇ", "ÓÔÁÈÅÑÅÓ"
            ConstNew bstack, b$, W$, True, Lang
                    If LastErNum = -1 Then
                    interpret = False
                    GoTo there1
                    End If
                Case "ÔÅËÏÓ", "END"
                    
                    If NORUN1 Then NORUN1 = False: interpret = True: b$ = vbNullString: GoTo there1   ' send environment....to hell
                    If bstack.IamChild Or bstack.IamAnEvent Then
                    NERR = True: NOEXECUTION = True
                    ElseIf Not bstack.IamChild And Not bstack.IamAnEvent And Not HaltLevel > 0 Then
                    If Check2Save Then
                        GoTo loopcontinue1
                    Else
                        Check2SaveModules = False
                    End If
                    End If
                    ExTarget = True: INK$ = Chr(27): UKEY$ = Chr$(27)
                Case Else
                    LastErNum = 0 ' LastErNum1 = 0
                    LastErName = vbNullString   ' every command from Query call identifier
                    LastErNameGR = vbNullString  ' interpret is like execute without if for repeat while select structures
                    If comhash.Find2(W$, I, v) Then
                        If v <> 0 Then
                            If v = 32 Then
                                If Not Identifier(bstack, W$, b$, True, Lang) Then
                                    If NOEXECUTION Then
                                            MyEr "", ""
                                            interpret = False
                                    End If
                                    here$ = ohere$: GoTo there1
                              Else
                              If bstack.callx1 > 0 Then
                              If bstack.NoRun Then
                              bstack.callx1 = 0
                              bstack.callohere = vbNullString
                              b$ = NLtrim(b$)
                              SetNextLineNL b$
                              ElseIf Not ProcModuleEntry(bstack, "", 0, b$, Lang) Then
                                    If MOUT And b$ = vbNullString Then
                                    Else
                                        MyErMacro b$, "unknown identifier " + W$, "¢ãíùóôï áíáãíùñéóôéêü " + W$
                                    End If
                                End If
                                bstack.RemoveOptionals
                                End If
                              GoTo loopcontinue1
                              End If
                           
                         '' ElseIf v = 2000 Then
                          
                          Else
contnoproper:
                            MyEr "No proper command for command line interpreter", "Äåí åßíáé ç êáôÜëëçëç åíôïëÞ ãéá ôïí äéåñìçíåõôÞ ãñáììÞò"
                            interpret = False
                          
                            here$ = ohere$: GoTo there1
                          End If
                     End If
                    
                    If I <> 0 Then
                     If IsBadCodePtr(I) = 0 Then
                        If Not CallByPtr(I, bstack, b$, Lang) Then
                               If NOEXECUTION Then
                                    MyEr "", ""
                                    interpret = False
                                    End If
                                    here$ = ohere$: GoTo there1
                        End If
                        End If
                    Else
                            If Not Identifier(bstack, W$, b$, Not comhash.Find(W$, i1), Lang) Then
                            
                                    If NOEXECUTION Then
                                    MyEr "", ""
                                    interpret = False
                                    End If
                                    here$ = ohere$: GoTo there1
                            End If
                    End If
                    
                    ElseIf Not Identifier(bstack, W$, b$, Not comhash.Find(W$, i1), Lang) Then
                    
                        If NOEXECUTION Then
                            MyEr "", ""
                            interpret = False
                        End If
                        here$ = ohere$: GoTo there1
                    ElseIf bstack.callx1 > 0 Then
                        If lckfrm > 0 Then lckfrm = sb2used + 1
                            If bstack.NoRun Then
                                bstack.callx1 = 0
                                bstack.callohere = vbNullString
                                b$ = NLtrim(b$)
                                SetNextLineNL b$
                              ElseIf Not ProcModuleEntry(bstack, "", 0, b$, Lang) Then
                                If MOUT And b$ = vbNullString Then
                                Else
                                    MyErMacro b$, "unknown identifier " + W$, "¢ãíùóôï áíáãíùñéóôéêü " + W$
                                End If
                            
                            
                             End If
                            
                            If bstack.Parent Is Nothing Then
                                If NOEXECUTION Then
                                    NOEXECUTION = False
                                    MyEr "", ""
                                    Set Basestack1.Sorosref = New mStiva
                                    b$ = vbNullString
                                     ClearState
                                End If
                               
                            End If
                    End If
                    
                End Select
                End If
            End If
        Else
        If W$ <> "" Then
       '' b$ = w$ & " " & b$
        If Abs(IsLabel(bstack, (W$), W$)) Then
        
         If FindNameForGroup(bstack, W$) Then
 MyEr "Unknown Property " + W$, "¢ãíùóôç éäéüôçôá " + W$
 Else
MyEr "Unknown Variable " + W$, "¢ãíùóôç ìåôáâëçôÞ " + W$
End If
b$ = W$ + " " + b$
        
        Else

       SyntaxError
        End If
        b$ = vbNullString
        interpret = False
        GoTo there1
        End If
    End If
Case 3

ss$ = vbNullString
        I = 1
        If Len(b$) > 1 Then
        If InStr("/*-+=~^&|<>", Mid$(b$, I, 1)) > 0 Then
        
                    If InStr("/*-+=~^&|<>!", Mid$(b$, I + 1, 1)) > 0 Then
                        ss$ = Mid$(b$, I, 2)
                        Mid$(b$, I, 2) = "  "
                        If ss$ = "<=" Then ss$ = "g"
                    Else
                        ss$ = Mid$(b$, I, 1)
                        Mid$(b$, I, 1) = " "
                    End If
         End If
       End If

If ss$ <> "" Then
            If ss$ = "=" Then
                If GetVar(bstack, W$, v) Then
constr2:
                sw$ = ss$
                    If IsExp(bstack, b$, p, nostring:=False) Then
                        Select Case MemInt(VarPtr(p))
                        Case vbString
                            SwapString2Variant ss$, p
                        Case vbBoolean
                            ss$ = Format$(p, DefBooleanString)
                        Case 20
                            ss$ = CStr(p)
                        Case vbDate
                            ss$ = p
                        Case Else
                            ss$ = Fix(p)
                        End Select
                        GoTo constr1
                    ElseIf IsStrExp(bstack, b$, ss$, False) Then
constr1:
                    If Typename$(bstack.lastobj) = "lambda" Then
                                  GlobalSub W$ + "()", "", , , v
                                               Set var(v) = bstack.lastobj
                                                Set bstack.lastobj = Nothing
                    ElseIf Typename$(var(v)) = "Group" Then
                    
                    If sw$ = "g" Then
                           sw$ = ":="
                           If Not var(v).HasSet Then GroupCantSetValue: interpret = False: GoTo there1
                           End If
                           If bstack.lastobj Is Nothing Then
                                bstack.soros.PushStr ss$
                            Else
                                bstack.soros.PushObj bstack.lastobj
                                Set bstack.lastobj = Nothing
                            End If
                            NeoCall2 bstack, Left$(W$, Len(W$) - 1) + "." + ChrW(&H1FFF) + sw$ + "()", ok
                    If Not ok Then
                        If LastErNum = 0 Then
                            MissOperator ss$
                        End If
                        interpret = False
                        GoTo there1
                    End If
                    ElseIf VarTypeName(var(v)) = "PropReference" Then
                        If FastSymbol(b$, "@") Then
                            If IsExp(bstack, b$, sp) Then
                            var(v).Index = p: sp = 0
                            ElseIf IsStrExp(bstack, b$, sw$) Then
                            var(v).Index = sw$: sw$ = vbNullString
                            End If
                             var(v).UseIndex = True
                        End If
                        var(v).Value = ss$
                  ElseIf TypeOf var(v) Is Constant Then
                    CantAssignValue
                    interpret = False
                    GoTo there1
                    Else
                         
                         If CheckVarOnlyNo(var(v), ss$) Then
                           ExpectedObj VarTypeName(var(v))
                           GoTo there1
                         End If
                        End If
                    Else
aproblem1:
                       NoValueForVar W$
                    Exit Do  '???
                    End If
                ElseIf IsStrExp(bstack, b$, ss$, False) Then
                    
                                If bstack.lastobj Is Nothing Then
              globalvar W$, ss$, , True
            Else
            If Typename$(bstack.lastobj) = "lambda" Then
                       If Not GetVar(bstack, W$, x1, True) Then x1 = globalvar(W$, p, , True)
                             GlobalSub W$ + "()", "", , , x1
                                        Set myobject = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        If x1 <> 0 Then
                                        
                                          Set var(x1) = myobject
                                                Set myobject = Nothing
                                           
                                            
                                        End If
            End If
            End If
                ElseIf LastErNum = 0 Then
                                    
                    SyntaxError
                    interpret = False
                    GoTo there1
                    Else
                   Exit Do  '???
                End If
          
            ElseIf ss$ = "+=" Then
                            If GetVar(bstack, W$, v) Then
constr3:
                                If IsStrExp(bstack, b$, ss$) Then
                                    If MyIsObject(var(v)) Then

                                            NoOperatorForThatObject "+="
                                            
                                            interpret = False
                                            GoTo there1

                                    Else
                                var(v) = CStr(var(v)) + ss$
                                    End If
                                Else
                                    MissStringExpr
                                End If
                            Else
                                ExpectedVariable
                            End If
            Else
            ' one now option
                If GetVar(bstack, W$, v) Then
                        If IsStrExp(bstack, b$, ss$) Then
                             CheckVar var(v), ss$
                        Else
                            NoValueForVar W$
                        Exit Do
                        End If
                Else
                    Nosuchvariable W$
                End If
        End If
End If
          
Case 4
If FastSymbol(b$, "=") Then '................................
           
            If GetVar(bstack, W$, v) Then
                If IsExp(bstack, b$, p) Then
                
                
                If Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is lambda Then
                        If VarTypeName(var(v)) = "lambda" Then
                                                Set var(v) = bstack.lastobj

                                                Else
                                    GlobalSub W$ + "()", "", , , v
                                               Set var(v) = bstack.lastobj
                                                
                                        End If
                           Set bstack.lastobj = Nothing
                         Else
                       SyntaxError
                        End If
                        ElseIf MyIsObject(var(v)) Then
                        If TypeOf var(v) Is Constant Then
                            CantAssignValue
                            interpret = False
                            GoTo there1
                        Else
                           ExpectedObj VarTypeName(var(v))
                           GoTo there1
                           End If
                        Else
                        var(v) = MyRound(p)
                        End If
                Else
                  MissNumExpr
                Exit Do
                End If
            ElseIf IsExp(bstack, b$, p) Then
             If Not bstack.lastobj Is Nothing Then
                
                If Typename$(bstack.lastobj) = "lambda" Then
                    
                       If Not GetVar(bstack, W$, x1, True) Then x1 = globalvar(W$, p, , True)
                             GlobalSub W$ + "()", "", , , x1
                                        Set myobject = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        If x1 <> 0 Then
                                        
                                          Set var(x1) = myobject
                                                Set myobject = Nothing
                                           
                                            
                                        End If
                                        Else
                                SyntaxError
            End If
            Else
            globalvar W$, p, , True
            End If
                ElseIf LastErNum = 0 Then
                                
                SyntaxError
                interpret = False
                GoTo there1
                Else
               Exit Do
            End If
 Else
    If FastSymbol(b$, "+=", , 2) Then
    ss$ = "+"
    ElseIf FastSymbol(b$, "/=", , 2) Then
    ss$ = "/"
    ElseIf FastSymbol(b$, "-=", , 2) Then
    ss$ = "-"
    ElseIf FastSymbol(b$, "*=", , 2) Then
    ss$ = "*"
    ElseIf IsOperator0(b$, "++", 2) Then
    ss$ = "++"
    ElseIf IsOperator0(b$, "--", 2) Then
    ss$ = "--"
    ElseIf IsOperator0(b$, "-!", 2) Then
    ss$ = "-!"
         ElseIf IsOperator0(b$, "~") Then
        ss$ = "!!"
    ElseIf FastSymbol(b$, "<=", , 2) Then
    ss$ = "="
    End If
        If ss$ = vbNullString Then
                    NoValueForVar W$
                    interpret = False
                     GoTo there1
    End If
    If GetVar(bstack, W$, v) Then
        If Len(ss$) = 1 Then
                    If IsExp(bstack, b$, p) Then
                            On Error Resume Next
                            Select Case ss$
                            Case "="
                            var(v) = MyRound(p)
                                Case "+"
                                var(v) = MyRound(p) + MyRound(var(v))
                                Case "*"
                                 var(v) = MyRound(MyRound(p) * MyRound(var(v)))
                                Case "-"
                                var(v) = MyRound(var(v)) - MyRound(p)
                                Case "/"
                                If MyRound(p) = 0 Then
                                   interpret = False
                                 GoTo there1
                                End If
                                 var(v) = MyRound(MyRound(var(v) / MyRound(p)))
                                 Case "!"
                                 var(v) = -1 - (var(v) <> 0)
                            End Select
                            If Err.Number = 6 Then
                            interpret = False
                            GoTo there1
                            End If
                
                    Else
                                   interpret = False
                                 GoTo there1
                    End If
        Else
        If ss$ = "++" Then
        var(v) = 1 + var(v)
        ElseIf ss$ = "--" Then
        var(v) = var(v) - 1
        ElseIf ss$ = "-!" Then
        var(v) = -var(v)
        Else

                      var(v) = -1 - (var(v) <> 0)
        End If
        End If
    Else
                   interpret = False
        GoTo there1
    End If
End If
Case 5

If neoGetArray(bstack, W$, pppp) Then
againarray22:
    If FastSymbol(b$, ")") Then
    'need to found an expression
        If FastSymbol(b$, "=") Then
            If IsExp(bstack, b$, p) Then
                If Not bstack.lastobj Is Nothing Then
                    bstack.lastobj.CopyArray pppp
                    pppp.Final = False
                    Set bstack.lastobj = Nothing
                    GoTo loopcontinue1
                End If
            Else
                SyntaxError
            End If
            interpret = False
            GoTo there1
        End If
        End If
If Not NeoGetArrayItem(pppp, bstack, W$, v, b$) Then interpret = False: here$ = ohere$: GoTo there1
On Error Resume Next
If MaybeIsSymbol(b$, ":+-*/~") Then
With pppp
        If IsOperator0(b$, "++", 2) Then
            .item(v) = .itemnumeric(v) + 1
            GoTo loopcontinue1
        ElseIf IsOperator0(b$, "--", 2) Then
            .item(v) = .itemnumeric(v) - 1
            GoTo loopcontinue1
        ElseIf IsOperator(b$, "+=", 2) Then
            If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
            .item(v) = .itemnumeric(v) + p
        ElseIf IsOperator(b$, "-=", 2) Then
            If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
            .item(v) = .itemnumeric(v) - p
        ElseIf IsOperator(b$, "*=", 2) Then
            If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
            .item(v) = .itemnumeric(v) * p
        ElseIf IsOperator(b$, "/=", 2) Then
            If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
            If p = 0 Then
             DevZero
             Else
             .item(v) = pppp.itemnumeric(v) / p
            End If
        ElseIf IsOperator0(b$, "-!", 2) Then
            .item(v) = -.itemnumeric(v)
            GoTo loopcontinue1
        ElseIf IsOperator0(b$, "~") Then
            Select Case VarType(.itemnumeric(v))
            Case vbBoolean
                .item(v) = Not CBool(.itemnumeric(v))
            Case vbInteger
                .item(v) = CInt(Not CBool(.itemnumeric(v)))
            Case vbLong
                .item(v) = CLng(Not CBool(.itemnumeric(v)))
            Case vbCurrency
                .item(v) = CCur(Not CBool(.itemnumeric(v)))
            Case vbDecimal
                .item(v) = CDec(Not CBool(.itemnumeric(v)))
            Case Else
                .item(v) = CDbl(Not CBool(.itemnumeric(v)))
            End Select
            GoTo loopcontinue1
      ElseIf FastSymbol(b$, ":=", , 2) Then

    If IsExp(bstack, b$, p) Then
        .item(v) = p
    ElseIf IsStrExp(bstack, b$, ss$, Len(bstack.tmpstr) = 0) Then
      If Not MyIsObject(.item(v)) Then
          .item(v) = ss$
          Else
        CheckVar .item(v), ss$
        
        End If

    Else
        Exit Do
    End If
    If FastSymbol(b$, ",") Then v = v + 1: GoTo contarr1
    GoTo loopcontinue1
        End If
.item(v) = MyRound(.itemnumeric(v), 13)
GoTo loopcontinue1
End With
End If


If IsOperator0(b$, ".") Then

If pppp.ItemType(v) = "Group" Then
interpret = SpeedGroup(bstack, pppp, "", W$, b$, v)
Set pppp = Nothing
GoTo loopcontinue1
End If
ElseIf IsOperator(b$, "(") Then
If pppp.ItemType(v) = myArray Then
Set pppp = pppp.item(v)
GoTo againarray22
End If
ElseIf Not FastSymbol(b$, "=") Then
here$ = ohere$: GoTo there1
End If

If Not IsExp(bstack, b$, p, nostring:=False) Then
If IsStrExp(bstack, b$, ss$, False) Then
If bstack.lastobj Is Nothing Then
p = vbNullString
SwapString2Variant ss$, p
GoTo 11233
End If
End If
here$ = ohere$: GoTo there1
End If

 If Not bstack.lastobj Is Nothing Then
     Set myobject = pppp.GroupRef
     If pppp.IhaveClass Then

            Set pppp.item(v) = bstack.lastobj
            Set pppp.item(v).LinkRef = myobject
            With pppp.item(v)
                 .HasStrValue = myobject.HasStrValue
                .HasValue = myobject.HasValue
                .HasSet = myobject.HasSet
                .HasParameters = myobject.HasParameters
                .HasParametersSet = myobject.HasParametersSet
                
                Set .SuperClassList = myobject.SuperClassList
                Set .Events = myobject.Events
                .highpriorityoper = myobject.highpriorityoper
                .HasUnary = myobject.HasUnary
            End With
     Else
            If Typename(bstack.lastobj) = "mHandler" Then
                               Set pppp.item(v) = bstack.lastobj
     
            Else
                   If Not bstack.lastobj Is Nothing Then
                          If TypeOf bstack.lastobj Is mArray Then
                                 If bstack.lastobj.Arr Then
                                         Set pppp.item(v) = CopyArray(bstack.lastobj)

                                 Else
  
   
                                            Set pppp.item(v) = bstack.lastobj
                                            If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                                 End If
                          Else
                          
                                  Set pppp.item(v) = bstack.lastobj
                                  If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                          End If
                   Else
                  
                          Set pppp.item(v) = bstack.lastobj
                          If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                   End If
            End If
        End If
     
     Set bstack.lastobj = Nothing
     Else
11233:
     If pppp.Arr Then
     pppp.item(v) = p
     ElseIf Typename(pppp.GroupRef) = "PropReference" Then
    
     pppp.GroupRef.Value = p
     End If
    End If
Do While FastSymbol(b$, ",")
If pppp.UpperMonoLimit > v Then
v = v + 1
If Not IsExp(bstack, b$, p) Then here$ = ohere$: GoTo there1
If Not bstack.lastobj Is Nothing Then
     Set myobject = pppp.GroupRef
     If pppp.IhaveClass Then
         Set pppp.item(v) = bstack.lastobj
            
            With pppp.item(v)
                 .HasStrValue = myobject.HasStrValue
                .HasValue = myobject.HasValue
                .HasSet = myobject.HasSet
                .HasParameters = myobject.HasParameters
                .HasParametersSet = myobject.HasParametersSet
                 Set .SuperClassList = myobject.SuperClassList
                Set .Events = myobject.Events
                .highpriorityoper = myobject.highpriorityoper
                .HasUnary = myobject.HasUnary
            End With
        
        
     Else
        Set pppp.item(v) = bstack.lastobj
    End If
    Set pppp.item(v).LinkRef = myobject
    Set bstack.lastobj = Nothing
     Else
pppp.item(v) = p
End If
Else
Exit Do
End If
Loop
Else
interpret = False: here$ = ohere$: GoTo there1
End If
Case 6
If neoGetArray(bstack, W$, pppp) Then
    If FastSymbol(b$, ")") Then
    'need to found an expression
        If FastSymbol(b$, "=") Then
            If IsStrExp(bstack, b$, ss$) Then
                If Not bstack.lastobj Is Nothing Then
                    If TypeOf bstack.lastobj Is mHandler Then
                        Set usehandler = bstack.lastobj
                        If usehandler.T1 = 3 Then
                            If pppp.Arr Then
                                usehandler.objref.CopyArray pppp
                                pppp.Final = False
                            Else
                                NotArray
                            End If
                        Else
                            NotArray
                        End If
                        Set usehandler = Nothing
                    Else
                        bstack.lastobj.CopyArray pppp
                    End If
                    Set bstack.lastobj = Nothing
                    GoTo loopcontinue1
                End If
            Else
                SyntaxError
            End If
               interpret = False
            GoTo there1
        End If
    End If
     
againstrarr22:
If Not NeoGetArrayItem(pppp, bstack, W$, v, b$) Then interpret = False: here$ = ohere$: GoTo there1
On Error Resume Next
If pppp.ItemType(v) = myArray And pppp.Arr Then
If FastSymbol(b$, "(") Then
Set pppp = pppp.item(v)
GoTo againstrarr22
End If
End If
If Not FastSymbol(b$, "=") Then
    If FastSymbol(b$, ":=", , 2) Then
contarr1:
    ss$ = Left$(aheadstatus(b$), 1)
        If ss$ = "S" Then
        If Not IsStrExp(bstack, b$, ss$) Then interpret = False: here$ = ohere$: GoTo there1
        Else
        If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
        If CheckInt64(p) Then
            ss$ = CStr(p)
        ElseIf VarType(p) = vbString Then
            ss$ = LTrim$(p)
        Else
            ss$ = LTrim$(str(p))
        End If
        End If
             If Not MyIsObject(pppp.item(v)) Then
          pppp.item(v) = ss$
          Else
        CheckVar pppp.item(v), ss$
        
        End If
        Do While FastSymbol(b$, ",")
        If pppp.UpperMonoLimit > v Then
        v = v + 1
          ss$ = Left$(aheadstatus(b$), 1)
                        If ss$ = "S" Then
        If Not IsStrExp(bstack, b$, ss$) Then interpret = False: here$ = ohere$: GoTo there1
        Else
        If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
            If CheckInt64(p) Then
                ss$ = CStr(p)
            ElseIf VarType(p) = vbString Then
                ss$ = LTrim$(p)
            Else
                ss$ = LTrim$(str(p))
            End If
        End If
        
                If Not MyIsObject(pppp.item(v)) Then
                  pppp.item(v) = ss$
                  Else
                CheckVar pppp.item(v), ss$
                
                End If
        Else
        Exit Do
        End If
        Loop
   ElseIf IsOperator(b$, "+=", 2) Then
    If pppp.IsStringItem(v) Then
    If Not IsStrExp(bstack, b$, ss$) Then GoTo st1222
    If bstack.lastobj Is Nothing Then
        pppp.ItemStr(v) = pppp.item(v) + ss$
    Else
st1222:
        MyEr "Need a string", "×ñåéÜæïìáé Ýíá áëöáñéèìçôéêü"
        interpret = False: here$ = ohere$: GoTo there1
    End If
    Else
    GoTo st1222
    End If
        
    Else
    interpret = False: here$ = ohere$: GoTo there1
    End If
Else
        If Not IsStrExp(bstack, b$, ss$) Then interpret = False: here$ = ohere$: GoTo there1
        
        
    If Not MyIsObject(pppp.item(v)) Then
    If pppp.Arr Then
    If bstack.lastobj Is Nothing Then
        pppp.item(v) = ss$
    
    Else
    If Typename(bstack.lastobj) = myArray Then
    If bstack.lastobj.Arr Then
        Set pppp.item(v) = CopyArray(bstack.lastobj)
    Else
         Set pppp.item(v) = bstack.lastobj.GroupRef
    End If
    Else
        Set pppp.item(v) = bstack.lastobj
        End If
        Set bstack.lastobj = Nothing
        End If
        Else
        pppp.GroupRef.Value = ss$
        End If
    Else
        CheckVar pppp.item(v), ss$
    End If
        Do While FastSymbol(b$, ",")
        If pppp.UpperMonoLimit > v Then
        v = v + 1
                If Not IsStrExp(bstack, b$, ss$) Then here$ = ohere$: GoTo there1
        
                If Not MyIsObject(pppp.item(v)) Then
                  pppp.item(v) = ss$
                  Else
                CheckVar pppp.item(v), ss$
                
                End If
        Else
        Exit Do
        End If
        Loop
End If
Else
interpret = 0: here$ = ohere$: GoTo there1
End If
Case 7
If neoGetArray(bstack, W$, pppp) Then
    If FastSymbol(b$, ")") Then
    'need to found an expression
        If FastSymbol(b$, "=") Then
            If IsStrExp(bstack, b$, ss$) Then
                If Not bstack.lastobj Is Nothing Then
                    bstack.lastobj.CopyArray pppp
                    Set bstack.lastobj = Nothing
                    GoTo loopcontinue1
                End If
            Else
                SyntaxError
            End If
              interpret = False
            GoTo there1
        End If
        End If
againintarr7:
If Not NeoGetArrayItem(pppp, bstack, W$, v, b$) Then interpret = False: here$ = ohere$: GoTo there1
On Error Resume Next
If pppp.ItemType(v) = myArray And pppp.Arr Then
If FastSymbol(b$, "(") Then
Set pppp = pppp.item(v)
GoTo againintarr7
End If
End If
If MaybeIsSymbol(b$, "+-*/~") Then
If IsOperator0(b$, "++", 2) Then
pppp.item(v) = pppp.itemnumeric(v) + 1
ElseIf IsOperator0(b$, "--", 2) Then
pppp.item(v) = pppp.itemnumeric(v) - 1
ElseIf IsOperator(b$, "+=", 2) Then
If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
pppp.item(v) = pppp.itemnumeric(v) + MyRound(p)
ElseIf IsOperator(b$, "-=", 2) Then
If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
pppp.item(v) = pppp.itemnumeric(v) - MyRound(p)
ElseIf IsOperator(b$, "*=", 2) Then
If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
pppp.item(v) = MyRound(pppp.itemnumeric(v) * MyRound(p))
ElseIf IsOperator(b$, "/=", 2) Then
If Not IsExp(bstack, b$, p) Then interpret = False: here$ = ohere$: GoTo there1
If MyRound(p) = 0 Then
 DevZero
 Else
 pppp.item(v) = MyRound(pppp.itemnumeric(v) / MyRound(p))
End If
ElseIf IsOperator0(b$, "-!", 2) Then
pppp.item(v) = -pppp.itemnumeric(v)
ElseIf IsOperator0(b$, "~") Then
        With pppp
        Select Case VarType(.itemnumeric(v))
            Case vbBoolean
                .item(v) = Not CBool(.itemnumeric(v))
            Case vbInteger
                .item(v) = CInt(Not CBool(.itemnumeric(v)))
            Case vbLong
                .item(v) = CLng(Not CBool(.itemnumeric(v)))
            Case vbCurrency
                .item(v) = CCur(Not CBool(.itemnumeric(v)))
            Case vbDecimal
                .item(v) = CDec(Not CBool(.itemnumeric(v)))
            Case Else
                .item(v) = CDbl(Not CBool(.itemnumeric(v)))
        End Select
        End With
End If

GoTo loopcontinue1
End If
If Not FastSymbol(b$, "=") Then here$ = ohere$: GoTo there1
If Not IsExp(bstack, b$, p) Then here$ = ohere$: GoTo there1
If Not bstack.lastobj Is Nothing Then
    If TypeOf bstack.lastobj Is mArray Then
                                 If bstack.lastobj.Arr Then
                                         Set pppp.item(v) = CopyArray(bstack.lastobj)

                                 Else
  
   
                                            Set pppp.item(v) = bstack.lastobj
                                            If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                                 End If
                          Else
                          
                                  Set pppp.item(v) = bstack.lastobj
                                  If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                          End If
Else
p = MyRound(p)

If Err.Number > 0 Then interpret = False: here$ = ohere$: GoTo there1
pppp.item(v) = p
End If
Do While FastSymbol(b$, ",")

If pppp.UpperMonoLimit > v Then
v = v + 1
If Not IsExp(bstack, b$, p) Then here$ = ohere$: GoTo there1
pppp.item(v) = MyRound(p)
Else
Exit Do
End If
Loop
Else
interpret = False: here$ = ohere$: GoTo there1
End If
Case 8
'ExecuteVar(
x1 = -1
'x1 = 1
Mid$(b$, 1, 1) = " "
x1 = ExecuteVar(1, 8, bstack, W$, b$, x1, 0&, False, False, 91, "", 0, "", False)
If x1 <> 7 Then
interpret = False
b$ = ""
End If

Case Else
If FastSymbol(b$, "(") Then
            I = 1
            x1 = 0
            While Len(aheadstatus(b$, False, I)) > 0
                x1 = I - 1
                I = I + 1
            Wend
            ss$ = Left$(b$, x1)
            If x1 > 0 And MyTrim(ss$) <> vbNullString Then
                Mid$(b$, 1, x1) = space$(x1)
                If FastSymbol(b$, ")", True) Then
                    If FastSymbol(b$, "=") Then
                        If IsExp(bstack, b$, p) Then
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is mArray Then
                                Set pppp = bstack.lastobj
                                GoTo wehavearray
                                ElseIf TypeOf bstack.lastobj Is mHandler Then
                                    If CheckIsmArray(bstack.lastobj) Then
                                        Set usehandler = bstack.lastobj
                                        Set pppp = usehandler.objref
                                        Set usehandler = Nothing
wehavearray:
                                        Set bstack.lastobj = Nothing
                                        Set myobject = bstack.soros
                                        Set bstack.Sorosref = New mStiva
                                        bstack.soros.MergeBottomCopyArray pppp
                                        If Not MyRead(1, bstack, ss$, 1) Then
                                            Set bstack.lastobj = Nothing
                                            Set bstack.Sorosref = myobject
                                            interpret = False
                                            Exit Function
                                        End If
                                        Set bstack.lastobj = Nothing
                                        Set bstack.Sorosref = myobject
                                        Set myobject = Nothing
                                        GoTo loopcontinue1
                                    Else
a123321:                                    NotArray
                                            interpret = False
                                            Exit Function
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        GoTo a123321
        End If



If MaybeIsSymbol(b$, ",-+*/_!@()[];<>|~`'\") Then
SyntaxError
End If
End Select


loopcontinue1:
If MaybeIsSymbol(b$, "'\/") Then
ElseIf Not NocharsInLine(b$) Then
    If Not MaybeIsSymbol(b$, vbCr) Then
        If Not MaybeIsSymbol(b$, ":") Then Exit Do
    End If
End If
Loop
here$ = ohere$
If LastErNum = -2 Then
sss = CLng(Execute(bstack, b$, True))
b$ = vbNullString
interpret = False

GoTo there1
forlong:
OverflowValue vbLong
interpret = False
here$ = ohere$
GoTo there1


ElseIf LastErNum <> 0 Then
b$ = " "
End If
interpret = b$ = vbNullString
If Not interpret Then
If LastErNum = 0 Then SyntaxError
End If
there1:
bstack.LoadOnly = False
End Function
Function PrepareLambda(basestask As basetask, myl As lambda, ByVal v As Long, frm$, C As Constant) As Boolean
On Error GoTo 1234
If VarTypeName(var(v)) = "Constant" Then
    Set C = var(v)
    If Not C.flag Then
    InternalError
    PrepareLambda = False
    Exit Function
    End If
    Set myl = C.Value
Else
    Set myl = var(v)
End If
         myl.Name = here$
            
            myl.CopyToVar basestask, here$ = vbNullString, var()
            basestask.OriginalCode = -v
            basestask.FuncRec = subHash.LastKnown

            frm$ = myl.code$
PrepareLambda = True
Exit Function
1234
InternalError
PrepareLambda = False

End Function

Sub BackPort(A$)
If Len(A$) = 0 Then A$ = Chr(8) Else Mid$(A$, 1, 1) = Chr(8)
End Sub
Function ExistNum(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant, dd As Long, dn As Long, X As Variant, anything As Object, s$, usehandler As mHandler
ExistNum = False
If IsExp(bstack, A$, p) Then
    If myVarType(p, vbString) Then
        s$ = p
        GoTo j58885
    End If
    If Typename(bstack.lastobj) = "mHandler" Then
        Set anything = bstack.lastobj
        Set bstack.lastobj = Nothing
        If Not CheckLastHandler(anything) Then
            InternalError
            ExistNum = False
            Exit Function
        End If
        Set usehandler = anything
        With usehandler
            If TypeOf .objref Is FastCollection Then
                If FastSymbol(A$, ",") Then
                    If IsExp(bstack, A$, p, , True) Then
                        If myVarType(p, vbString) Then
                            s$ = p
                            GoTo j5884
                        End If
                        If FastSymbol(A$, ",") Then
                            If IsExp(bstack, A$, X, , True) Then
                                If myVarType(X, vbString) Then
                                    MissParam A$
                                    Exit Function
                                End If
                                X = Int(X)
                                If X = 0 Then
                                    r = .objref.FindOne(p, X)
                                    r = X
                                ElseIf X > 0 Then
                                    dn = X
                                    X = 0
                                    r = .objref.FindOne(p, X)
                                    X = -X + dn - 1
                                    r = .objref.FindOne(p, X)
                                Else
                                    r = .objref.FindOne(p, X)
                                End If
                            Else
                                MissParam A$
                                Set anything = Nothing
                                Exit Function
                            End If
                        Else
                            r = .objref.Find(p)
                        End If
                    ElseIf IsStrExp(bstack, A$, s$, False) Then
j5884:
                        Set bstack.lastobj = Nothing
                        If FastSymbol(A$, ",") Then
                            If IsExp(bstack, A$, X, , True) Then
                                If myVarType(X, vbString) Then
                                    MissParam A$
                                    Exit Function
                                End If

                                X = Int(X)
                                If X = 0 Then
                                    r = .objref.FindOne(s$, X)
                                    r = X
                                ElseIf X > 0 Then
                                    dn = X
                                    X = 0
                                    r = .objref.FindOne(s$, X)
                                    X = -X + dn - 1
                                    r = .objref.FindOne(s$, X)
                                Else
                                    r = .objref.FindOne(s$, X)
                                End If
                            Else
                                MissParam A$
                                Exit Function
                            End If
                        Else
                            r = .objref.Find(s$)
                        End If
                    End If
                    ExistNum = FastSymbol(A$, ")", True)
                    Exit Function
                End If
            End If
        End With
    End If
    MissParam A$
    Set bstack.lastobj = Nothing
ElseIf IsStrExp(bstack, A$, s$, False) Then
j58885:
    s$ = CFname(s$)
    If s$ <> "" Then
        r = (InStr(s$, "*") = 0 And InStr(s$, "?") = 0)
    Else
        r = False
    End If
    ExistNum = FastSymbol(A$, ")", True)
Else
    MissParam A$
End If
   
End Function
Function MySwap(bstack As basetask, rest$, Lang As Long) As Boolean
Dim s$, s0$, s1$, ss$, f As Long, of As Long, Col As Long, x1 As Long, I As Long, pppp As mArray, pppp1 As mArray, p
Dim swaparrays As Boolean, ar1 As Long, ar2 As Long
    f = Abs(IsLabel(bstack, rest$, s$))
    MySwap = True
    If f = 1 Or f = 4 Then Col = 1: of = f
    If f = 5 Or f = 7 Then Col = 2
    If f = 8 Then Col = 3
    
    If f = 0 Then MissingnumVar:  Exit Function
   ' If (f = 3 Or f = 6) And Col > 0 Then SyntaxError: MySwap = False:    Exit Function
    If Col = 1 Then
        If GetVar(bstack, s$, f) Then
                If Not FastSymbol(rest$, ",") Then MissingnumVar:  Exit Function
                I = Abs(IsLabel(bstack, rest$, ss$))
              If I = 1 Or I = 4 Then
                If GetVar(bstack, ss$, x1) Then
            If MyIsObject(var(f)) Then
            If var(f) Is Nothing Then
            ElseIf TypeOf var(f) Is Constant Then
            CantAssignValue
            MySwap = False: Exit Function
            End If
        End If
        If MyIsObject(var(x1)) Then
            If TypeOf var(x1) Is Constant Then
            CantAssignValue
            MySwap = False: Exit Function
            End If
        End If
                    If f <> x1 Then SwapVariant var(f), var(x1)
                    
                    
                Exit Function
                Else
s11111:
                    Nosuchvariable ss$
                    MySwap = False
                    Exit Function
                End If
            ElseIf I = 5 Or I = 6 Or I = 7 Then
                If neoGetArray(bstack, ss$, pppp) Then
                If Not pppp.Arr Then NotArray: Exit Function
                    If Not NeoGetArrayItem(pppp, bstack, ss$, x1, rest$, True) Then Exit Function
                        If MyIsObject(var(f)) Then
                            If TypeOf var(f) Is Constant Then
                            CantAssignValue
                            MySwap = False: Exit Function
                            End If
                        End If
                        If pppp.MyTypeToBe <> vbVariant Then
                            If pppp.MyTypeToBe <> vbObject Then
                                p = pppp.item(x1)
                                SwapVariant var(f), p
                                pppp.item(x1) = p
                            Else
                                Set p = pppp.item(x1)
                                SwapVariant var(f), p
                                If myVarType(p, vbObject) Then
                                    Set pppp.item(x1) = p
                                Else
                                    Set pppp.item(x1) = Nothing
                                End If
                            End If
                        Else
                            If myVarType(var(f), vbString) Then
                                If pppp.ItemTypeNum(x1) = vbString Then
                                p = pppp.item(x1)
                                SwapVariant var(f), p
                                pppp.item(x1) = p
                                Else
                                MySwap = False
                                NeedString
                                Exit Function
                                End If
                            Else
                            SwapVariant2 var(f), pppp, x1
                            End If
                        End If
                    
                Else
                    NoSwap ss$
                    MySwap = False
                    Exit Function
                End If
            ElseIf I = 3 Then
                    If of <> 1 Then GoTo s1234
                If MyIsObject(var(f)) Then GoTo s1234
                If Not myVarType(var(f), vbString) Then GoTo s1234
                
                If Not GetVar(bstack, ss$, x1) Then GoTo s11111
                If Not myVarType(var(x1), vbString) Then GoTo s1234
                If f <> x1 Then SwapVariant var(f), var(x1)
            
            Else
                MissingnumVar
                MySwap = False
                Exit Function
            End If
        Else
            Nosuchvariable s$
            
            Exit Function
        End If
    ElseIf Col = 2 Then
        If neoGetArray(bstack, s$, pppp) Then
            If Not pppp.Arr Then NotArray: Exit Function
            If FastSymbol(rest$, ")") Then
                swaparrays = True
                ar1 = varhash.lastNDX
                GoTo nextone
            End If
            If Not NeoGetArrayItem(pppp, bstack, s$, f, rest$) Then Exit Function
nextone:
            If Not FastSymbol(rest$, ",") Then MissingnumVar:  Exit Function
            I = Abs(IsLabel(bstack, rest$, ss$))
                  
            If I = 1 Or I = 4 Then
                    If swaparrays Then MySwap = False: NotArray: Exit Function
                    If GetVar(bstack, ss$, x1) Then
                    If pppp.IhaveClass Then
                            NoSwap ""
                    Else
                             If MyIsObject(var(x1)) Then
                                If TypeOf var(x1) Is Constant Then
                                CantAssignValue
                                MySwap = False: Exit Function
                                End If
                            End If
                            If pppp.MyTypeToBe <> vbVariant Then
                                If pppp.MyTypeToBe <> vbObject Then
                                    p = pppp.item(f)
                                    SwapVariant var(x1), p
                                    pppp.item(f) = p
                                Else
                                    Set p = pppp.item(f)
                                    SwapVariant var(x1), p
                                    If myVarType(p, vbObject) Then
                                        Set pppp.item(f) = p
                                    Else
                                        Set pppp.item(f) = Nothing
                                    End If
                                End If
                            Else
                                SwapVariant2 var(x1), pppp, f
                            End If
                     End If
                        
                    Else
                        MissingnumVar
                        MySwap = False
                        Exit Function
                    End If
            ElseIf I = 5 Or I = 7 Then
                    If neoGetArray(bstack, ss$, pppp1) Then
                    If Not pppp1.Arr Then NotArray: Exit Function
                    If swaparrays Then
                        If Not FastSymbol(rest$, ")") Then
                            MySwap = False
                            MyEr "can't swap arrays", "äåí ìðïñþ íá áëëÜîù ôïõò ðßíáêåò"
                            Exit Function
                        End If
                        ar2 = varhash.lastNDX
                        SwapVariant var(ar1), var(ar2)
                        Exit Function
                    End If
                    If Not NeoGetArrayItem(pppp1, bstack, ss$, x1, rest$) Then Exit Function
                    If pppp.IhaveClass Xor Not pppp1.IhaveClass Then
                        If pppp.MyTypeToBe <> vbVariant Or pppp1.MyTypeToBe <> vbVariant Then
                            If pppp.MyTypeToBe <> vbObject And pppp1.MyTypeToBe <> vbObject Then
                                If pppp.ItemIsObject(f) Then
                                    NoSwap ""
                                    Exit Function
                                ElseIf pppp1.ItemIsObject(x1) Then
                                    NoSwap ""
                                    Exit Function
                                Else
                                    p = pppp.item(f)
                                    pppp.item(f) = pppp1.item(x1)
                                    pppp1.item(x1) = p
                                End If
                            ElseIf pppp.MyTypeToBe = vbObject Or pppp1.MyTypeToBe = vbObject Then
                                If pppp.MyTypeToBe = vbObject And pppp1.MyTypeToBe = vbVariant Then
                                    Set p = pppp.item(f)
                                    SwapVariant2 p, pppp1, x1
                                    If myVarType(p, vbObject) Then
                                        Set pppp.item(f) = p
                                    Else
                                        Set pppp.item(f) = Nothing
                                    End If
                                ElseIf pppp.MyTypeToBe = vbVariant Or pppp1.MyTypeToBe = vbObject Then
                                    Set p = pppp1.item(x1)
                                    SwapVariant2 p, pppp, f
                                    If myVarType(p, vbObject) Then
                                        Set pppp1.item(x1) = p
                                    Else
                                        Set pppp1.item(x1) = Nothing
                                    End If
                                Else
                                    NoSwap ""
                                    Exit Function
                                End If
                            Else
                                Set p = pppp.item(f)
                                Set pppp.item(f) = pppp1.item(x1)
                                Set pppp1.item(x1) = p
                            End If
                        Else
                            SwapVariant3 pppp, f, pppp1, x1
                        End If
                        If pppp.IhaveClass Then
                            Set pppp.item(f).LinkRef = pppp1.GroupRef
                            Set pppp1.item(x1).LinkRef = pppp.GroupRef
                            End If
                        Else
                        NoSwap ""
                        MySwap = False
                        Exit Function
                        End If
                        
                    Else
                        MySwap = False
                        MissingnumVar
                        
                        Exit Function
                    End If
            Else
                MySwap = False
                MissingnumVar
                
                Exit Function
            End If
        Else
            MySwap = False
            MissingnumVar
            
            Exit Function
        End If
    ElseIf f = 3 Then
            If GetVar(bstack, s$, f) Then
            If Not FastSymbol(rest$, ",") Then MissingnumVar:  Exit Function
                I = Abs(IsLabel(bstack, rest$, ss$))
                 If I = 6 Or I = 5 Then
                    If Not neoGetArray(bstack, ss$, pppp) Then MissingStrVar:  Exit Function
                    If Not pppp.Arr Then NotArray: Exit Function
                    If Not NeoGetArrayItem(pppp, bstack, ss$, x1, rest$) Then Exit Function
                     If MyIsObject(var(f)) Then
                        If TypeOf var(f) Is Constant Then
                        CantAssignValue
                        MySwap = False: Exit Function
                        End If
                    End If
                    If pppp.MyTypeToBe <> vbVariant Then
                        If pppp.MyTypeToBe <> vbObject Then
                            p = pppp.item(x1)
                            SwapVariant var(f), p
                            pppp.item(x1) = p
                        Else
                            Set p = pppp.item(x1)
                            SwapVariant var(f), p
                            If myVarType(p, vbObject) Then
                                Set pppp.item(x1) = p
                            Else
                                Set pppp.item(x1) = Nothing
                            End If
                        End If
                    Else
                        SwapVariant2 var(f), pppp, x1
                    End If
                ElseIf I = 3 Then
                    If Not GetVar(bstack, ss$, x1) Then: Exit Function
                     If MyIsObject(var(f)) Then
                        If TypeOf var(f) Is Constant Then
                        CantAssignValue
                        MySwap = False: Exit Function
                        End If
                    End If
                   If f <> x1 Then SwapVariant var(f), var(x1)
                ElseIf I = 1 Then
                    If Not GetVar(bstack, ss$, x1) Then GoTo s11111
                    If MyIsObject(var(f)) Then GoTo s1234

                    If Not myVarType(var(x1), vbString) Then GoTo s1234
                    If f <> x1 Then SwapVariant var(f), var(x1)
                   
                Else
s1234:
                MissFuncParameterStringVar
                MySwap = False
                End If
                
                
            Else
                    
                    MissFuncParameterStringVar
                    MySwap = False
            End If
    ElseIf f = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
            If Not pppp.Arr Then NotArray: Exit Function
                If Not NeoGetArrayItem(pppp, bstack, s$, x1, rest$) Then Exit Function
                If Not FastSymbol(rest$, ",") Then MissingnumVar:  Exit Function
                I = Abs(IsLabel(bstack, rest$, ss$))
     
                If I = 6 Or I = 5 Then
                    If Not neoGetArray(bstack, ss$, pppp1) Then MissingStrVar:  Exit Function
                    If Not pppp.Arr Then NotArray: Exit Function
                    If Not NeoGetArrayItem(pppp1, bstack, ss$, I, rest$) Then Exit Function
                        If pppp.MyTypeToBe <> vbVariant Or pppp1.MyTypeToBe <> vbVariant Then
                            If pppp.MyTypeToBe <> vbObject And pppp1.MyTypeToBe <> vbObject Then
                                If pppp.ItemIsObject(x1) Then
                                    NoSwap ""
                                    Exit Function
                                ElseIf pppp1.ItemIsObject(I) Then
                                    NoSwap ""
                                    Exit Function
                                Else
                                    p = pppp.item(x1)
                                    pppp.item(x1) = pppp1.item(I)
                                    pppp1.item(I) = p
                                End If
                            ElseIf pppp.MyTypeToBe = vbObject Or pppp1.MyTypeToBe = vbObject Then
                                If pppp.MyTypeToBe = vbObject And pppp1.MyTypeToBe = vbVariant Then
                                    Set p = pppp.item(x1)
                                    SwapVariant2 p, pppp1, I
                                    If myVarType(p, vbObject) Then
                                        Set pppp.item(x1) = p
                                    Else
                                        Set pppp.item(x1) = Nothing
                                    End If
                                ElseIf pppp.MyTypeToBe = vbVariant Or pppp1.MyTypeToBe = vbObject Then
                                    Set p = pppp1.item(I)
                                    SwapVariant2 p, pppp, x1
                                    If myVarType(p, vbObject) Then
                                        Set pppp1.item(I) = p
                                    Else
                                        Set pppp1.item(I) = Nothing
                                    End If
                                Else
                                    NoSwap ""
                                    MySwap = False
                                    Exit Function
                                End If
                            Else
                                Set p = pppp.item(x1)
                                Set pppp.item(x1) = pppp1.item(I)
                                Set pppp1.item(I) = p
                            End If
                        Else
                            SwapVariant3 pppp, x1, pppp1, I
                        End If
                ElseIf I = 3 Then
                    If Not GetVar(bstack, ss$, I) Then: Exit Function
                    If MyIsObject(var(I)) Then
                        If TypeOf var(I) Is Constant Then
                        CantAssignValue
                        MySwap = False: Exit Function
                        End If
                    End If
                    If pppp.MyTypeToBe <> vbVariant Then
                        If pppp.MyTypeToBe <> vbObject Then
                            p = pppp.item(x1)
                            SwapVariant var(I), p
                            pppp.item(x1) = p
                        Else
                            Set p = pppp.item(x1)
                            SwapVariant var(I), p
                            If myVarType(p, vbObject) Then
                                Set pppp.item(x1) = p
                            Else
                                Set pppp.item(x1) = Nothing
                            End If
                        End If
                    Else
                        SwapVariant2 var(I), pppp, x1
                  End If
                    Else
                MissFuncParameterStringVar
                MySwap = False
                End If
                
                
            Else
                
                MissPar
                MySwap = False
                
            End If
    ElseIf Col = 3 Then
        If Not GetVar(bstack, s$, f) Then ss$ = s$: GoTo s11111
        If Not myVarType(var(f), vbObject) Then GoTo s33333
        If Not TypeOf var(f) Is refArray Then GoTo s44444
        ss$ = BlockParamSq(rest$)
        I = Len(ss$)
        If Not IsExp(bstack, ss$, p, , , , True) Then GoTo s22222
        ss$ = str$(p)
        If I = 0 Then GoTo s22222
        Mid$(rest$, 1, I) = space(I):
        I = I + 1
        If Mid$(rest$, I, 2) = "][" Then
        While Mid$(rest$, I, 2) = "]["
            Mid$(rest$, I, 2) = "  "
            
            s0$ = BlockParamSq(rest$)
            If Not IsExp(bstack, (s0$), p, , , , True) Then GoTo s22222
            If Len(s0$) - I < 2 Then GoTo s22222
            
            Mid$(rest$, 1, Len(s0$)) = space(Len(s0$))
            ss$ = ss$ + "][" + str$(p)
            I = 1 + Len(s0$)
        Wend
           End If
        If Mid$(rest$, I, 1) <> "]" Then GoTo s22222
        Mid$(rest$, I, 1) = " "
        
        s1$ = s$ + "[" + ss$ + "]"
        If FastSymbol(rest$, ",", True) Then
        f = Abs(IsLabel(bstack, rest$, s$))
        If f <> 8 Then CantAssignValue: MySwap = False: Exit Function
        If Not GetVar(bstack, s$, f) Then ss$ = s$: GoTo s11111
        If Not myVarType(var(f), vbObject) Then GoTo s33333
        If Not TypeOf var(f) Is refArray Then GoTo s44444
        ss$ = BlockParamSq(rest$)
        I = Len(ss$)
        If I = 0 Then GoTo s22222
        If Not IsExp(bstack, ss$, p, , , , True) Then GoTo s22222
        ss$ = str$(p)
        Mid$(rest$, 1, I) = space(I):
        I = I + 1
        If Mid$(rest$, I, 2) = "][" Then
        While Mid$(rest$, I, 2) = "]["
            Mid$(rest$, I, 2) = "  "
            
            s0$ = BlockParamSq(rest$)
            If Not IsExp(bstack, (s0$), p, , , , True) Then GoTo s22222
            If Len(s0$) - I < 2 Then GoTo s22222
            
            Mid$(rest$, 1, Len(s0$)) = space(Len(s0$))
            ss$ = ss$ + "][" + str$(p)
            I = 1 + Len(s0$)
        Wend
           End If
        If Mid$(rest$, I, 1) <> "]" Then GoTo s22222
        Mid$(rest$, I, 1) = " "
        
        s$ = s$ + "[" + ss$ + "]"
        End If
        MySwap = Execute(bstack, "push " + s$ + "," + s1$ + ":read " + s$ + "," + s1$, False) <> 0
        
       
    Else
                MissPar
                MySwap = False
    End If
    Exit Function
s44444:
    badsupport
    MySwap = False
    Exit Function
s33333:
    MissingObj
    MySwap = False
    Exit Function
s22222:
    SyntaxError
    MySwap = False
End Function
Public Function TraceThis(bstack As basetask, di As Object, b$, W$, SBB$) As Boolean
    
    TraceThis = True
    If Form2.Busy Then Exit Function
    Form2.Busy = True
    PrepareLabel bstack
    Form2.label1(1) = W$
    Form2.label1(2) = GetStrUntil(vbCrLf, b$ + vbCrLf, False)
    If Len(b$) = 0 Then
    WaitShow = 0
    bypassST = False
    Set Form2.Process = bstack
    Form2.Busy = False
    Exit Function
    Else
    If TestShowBypass Then
 
        ElseIf WaitShow = 0 Or Len(b$) < WaitShow Then
            WaitShow = 0
            If bstack.OriginalCode < 0 Then
            lasttracecode = -bstack.OriginalCode
                SBB$ = GetNextLine((var(-bstack.OriginalCode).code$))
            Else
            lasttracecode = bstack.OriginalCode
                SBB$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))
            End If
            If Left$(SBB$, 10) = "'11001EDIT" Then
                TestShowSub = Mid$(sbf(Abs(bstack.OriginalCode)).sb, Len(SBB$) + 3)
                If TestShowSub = vbNullString Then
                    TestShowSub = Mid$(sbf(FindPrevOriginal(bstack)).sb, Len(SBB$) + 3)
                End If
                If InStr(TestShowSub, b$) = 0 Then
                    WaitShow = Len(b$)
                End If
            Else
                If bstack.OriginalCode <> 0 Then
                    If bstack.OriginalCode < 0 Then
                        TestShowSub = var(-bstack.OriginalCode).code$
                    Else
                        TestShowSub = sbf(Abs(bstack.OriginalCode)).sb
                    End If
                Else
                    If bstack.IamThread Then
                        If bstack.Process Is Nothing Then
                        Else
                            TestShowSub = bstack.Process.CodeData
                        End If
                    Else
                        TestShowSub = b$
                    End If
                End If
  
            End If
   
        End If
        If bstack.addlen Then
            If Len(TestShowSub) - bstack.addlen - Len(b$) > 0 Then
                TestShowStart = Len(TestShowSub) - bstack.addlen - Len(b$) + 1
            Else
                TestShowStart = 1
            End If
        Else
            TestShowStart = Len(TestShowSub) - Len(b$) + 1 ' rinstr(TestShowSub, b$)
        End If
        If TestShowStart <= 0 Then
            TestShowStart = rinstr(TestShowSub, Mid$(b$, 2)) - 1
        End If
     bypassST = False
          
    Set Form2.Process = bstack
    stackshow bstack
        
    End If
    
    If Not Form1.Visible Then
        Form1.Show , Form5   'OK
    End If

    If STbyST Then
        STbyST = False
        If Not STEXIT Then
            If Not STq Then
            
                Form2.gList4.ListIndex = 0
            End If
        End If
        If Not TaskMaster Is Nothing Then
            If TaskMaster.QueueCount > 0 And TaskMaster.Processing Then TaskMaster.StopProcess
        End If
        Form2.Busy = False
        Do
            BLOCKkey = False
            If Not IsWine Then If di.Visible Then di.Refresh
            ProcTask2 bstack
        Loop Until STbyST Or STq Or STEXIT Or bypassST Or NOEXECUTION Or myexit(bstack) Or Not Form2.Visible

     
        If Not TaskMaster Is Nothing Then
           If TaskMaster.QueueCount > 0 And Not TaskMaster.Processing Then TaskMaster.StartProcess
        End If
        If Not STEXIT Then
            If Not STq Then
                Form2.gList4.ListIndex = 0
            End If
        End If
        STq = False
        If STEXIT Then
            NOEXECUTION = True
            trace = False
            STEXIT = False
            TraceThis = False
            Form2.Busy = False
            Exit Function
        End If
    Else
    Form2.Busy = False
    If tracecounter > 0 Then
    If Not IsWine Then MyDoEvents1 Form2, True
    If stoponerror Then tracecounter = -100
    ElseIf stoponerror Or STq Then
        tracecounter = tracecounter + 1
    End If
    If Form2.Busy Then Exit Function
    End If
    If STEXIT Then
        trace = False
        STEXIT = False
        TraceThis = False
        Exit Function
    End If
   
End Function
Function DriveSerial1(bstack As basetask, A$, r As Variant) As Boolean
    Dim s$
    If IsStrExp(bstack, A$, s$, False) Then
        r = DriveSerial(Left$(s$, 3))
        DriveSerial1 = FastSymbol(A$, ")", True)
    Else
        MissParam A$
    End If
End Function
Function MakeForm(basestack As basetask, rest$) As Boolean
On Error Resume Next
MakeForm = True
Dim Scr As Object, XX As Single, p As Variant, x1 As Long, y1 As Long, X As Double, Y As Double
Dim w3 As Long, w4 As Long, sX As Double, adjustlinespace As Boolean, SZ As Single, reduce As Single
reduce = 1
Set Scr = basestack.Owner

Dim basketcode As Long, mAddTwipsTop As Long


If Left$(Typename(Scr), 3) = "Gui" Then
If Typename(Scr) = "GuiM2000" Then Scr.SkipAutoPos = True: FastSymbol rest$, "!": GoTo there1
ElseIf Scr.Name = "Form1" Then

Else
If FastSymbol(rest$, "!") Then
If Not TypeOf Scr Is MetaDc Then reduce = 0.9
End If
there1:

basketcode = GetCode(Scr)
With players(basketcode)
.UseDouble = 0
SetNormal Scr
mAddTwipsTop = .uMineLineSpace  ' the basic
Dim wishX As Long, wishY As Long
If IsExp(basestack, rest$, p) Then
    If p < 10 Then p = 10
    X = 4
    XX = 4
    If Scr.Name = "DIS" Then
    Do
    Y = CDbl(XX)
    XX = CSng(X)
    nForm basestack, XX, w3, w4, mAddTwipsTop   'using line spacing
    If XX > CSng(X) Then X = CDbl(XX)
    
    If Form1.Width * reduce < w3 * p Then Exit Do
    X = X + 0.25
    Loop
 
    
    Else
    Do
    
    Y = CDbl(XX)
    XX = CSng(X)

    nForm basestack, XX, w3, w4, mAddTwipsTop  'using line spacing
    If XX > CSng(X) Then X = CDbl(XX)
    
    If Scr.Width * reduce < w3 * p Then Exit Do
    
    X = X + 0.4
    Loop
    End If
    X = Y
    sX = 0
    wishX = p
    If FastSymbol(rest$, ",") Then
    sX = Empty
    
        If IsExp(basestack, rest$, sX) Then
        wishY = sX
       mAddTwipsTop = 0  ' find a new one
       players(basketcode).MineLineSpace = 0
       players(basketcode).uMineLineSpace = 0
        adjustlinespace = True
    ''    mmx = scr.Width
''mmy = scr.Height
        Else
        MakeForm = False
        MissNumExpr
        Set Scr = Nothing
        Exit Function
        End If
   
End If
If FastSymbol(rest$, ";") And Scr.Name = "DIS" Then
adjustlinespace = False
If IsWine Then
    Form1.move ScrInfo(Console).Left, ScrInfo(Console).top, ScrInfo(Console).Width - 1, ScrInfo(Console).Height - 1
Else
    Form1.move ScrInfo(Console).Left, ScrInfo(Console).top, ScrInfo(Console).Width, ScrInfo(Console).Height
End If
    Form1.BackColor = players(-1).Paper
    
Sleep 1
End If
nForm basestack, CSng(X), w3, w4, 0
Dim mmx As Long, mmy As Long
If sX = 0 Then
SZ = CSng(X)
mmx = Scr.Width * reduce
 If Scr.Name = "DIS" Then
 mmy = CLng(mmx * Form1.Height / Form1.Width) ' WHY 3/4 ??
 Else
 mmy = Scr.Width * reduce
 End If
 players(basketcode).MineLineSpace = mAddTwipsTop
 players(basketcode).uMineLineSpace = mAddTwipsTop
FrameText Scr, SZ, CLng(w3 * p), mmy, players(basketcode).Paper
Else
If Scr.Name = "DIS" Then
If (sX * w4) > Form1.Height * reduce Then
Y = Form1.Height * reduce
Dim safety As Long

While sX * w4 > Form1.Height * reduce And Not safety = sX * w4
safety = sX * w4

XX = Y / (dv20 * sX)

nForm basestack, XX, w3, w4, 0  'using no spacing so we put a lot of lines
X = CDbl(XX)
Y = Y * 0.9
Wend


End If
Else
If sX * w4 > Scr.Height * reduce Then
Y = Scr.Height * reduce
Do While sX * w4 > Scr.Height * reduce

XX = Y / (dv20 * sX)
nForm basestack, XX, w3, w4, 0  'using no spacing so we put a lot of lines
If X = CDbl(XX) Then Exit Do
X = CDbl(XX)
Y = Y * 0.9
Loop


End If

End If

If Scr.Name = "DIS" Then
If Not adjustlinespace Then If Scr.Height * reduce >= Form1.Height * reduce - dv15 Then mAddTwipsTop = dv15 * (((Scr.Height * reduce - sX * w4) / sX / 2) \ dv15)
End If
nForm basestack, (X), w3, w4, mAddTwipsTop
SZ = CSng(X)
'If mmx < scr.Width Then
mmx = Scr.Width * reduce


'If mmx < scr.Width Then
mmy = Scr.Height * reduce
If adjustlinespace Then
If Scr.Name = "DIS" Then
mAddTwipsTop = dv15 * (((Form1.Height * reduce - sX * w4) / sX / 2) \ dv15)

Else
mAddTwipsTop = dv15 * (((Scr.Height * reduce - sX * w4) / sX / 2) \ dv15)
End If
sX = CLng(sX * (w4 + mAddTwipsTop * 2))
Else
sX = CLng(sX * w4)
End If
players(basketcode).MineLineSpace = mAddTwipsTop
players(basketcode).uMineLineSpace = mAddTwipsTop
FrameText Scr, SZ, CLng(w3 * p), CLng(sX), players(basketcode).Paper, Not (Scr.Name = "DIS")

End If


ElseIf FastSymbol(rest$, ";") And Scr.Name = "DIS" Then



If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top
If IsWine Then
         Form1.Width = ScrInfo(Console).Width - 1
         Form1.Height = ScrInfo(Console).Height
         Form1.move ScrInfo(Console).Left, ScrInfo(Console).top
Else
        Form1.move ScrInfo(Console).Left, ScrInfo(Console).top, ScrInfo(Console).Width, ScrInfo(Console).Height
    
End If
Form1.BackColor = players(-1).Paper
Form1.Cls
With players(-1)
        .mysplit = 0
        .MAXXGRAPH = Form1.Width
        .MAXYGRAPH = Form2.Height
        SetText Form1
        End With
MyMode Scr
ElseIf Scr.Name = "DIS" Then

w3 = Form1.Left + Scr.Left
w4 = Form1.top + Scr.top
If IsWine And Form1.Width = ScrInfo(Console).Width Then Form1.Width = ScrInfo(Console).Width - dv15
If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top: w4 = Form1.top + Scr.top
scrMove00 Scr
If IsWine Then
    If Scr.Width = ScrInfo(Console).Width Then
       Form1.Width = Scr.Width - 1
    Else
        Form1.Width = Scr.Width
    End If
    Form1.Height = Scr.Height
    Form1.move w3, w4
Else
    Form1.move w3, w4, Scr.Width, Scr.Height
End If
Form1.Cls
        With players(-1)
        .mysplit = 0
        .MAXXGRAPH = Form1.Width
        .MAXYGRAPH = Form2.Height
        SetText Form1
        End With
SetText Scr

Set Scr = Nothing
Exit Function
Else
'' CROP LAYER
If basketcode > 0 Then
With players(basketcode)
.MAXXGRAPH = .mX * .Xt
.MAXYGRAPH = .mY * .Yt
End With
With Form1.dSprite(basestack.tolayer)
.move .Left, .top, players(basketcode).MAXXGRAPH, players(basketcode).MAXYGRAPH
End With

End If
End If

players(basketcode).MineLineSpace = mAddTwipsTop
players(basketcode).uMineLineSpace = mAddTwipsTop
MakeForm = True
.curpos = 0
.currow = 0

End With
End If
SetText Scr

If TypeOf Scr Is MetaDc Then
x1 = (players(basketcode).mX \ 20) * 20
players(basketcode).mX = (players(basketcode).mX \ (players(basketcode).Column + 1)) * (players(basketcode).Column + 1)
If x1 >= wishX Then
    x1 = (wishX \ 20) * 20
    If x1 < wishX Then
        x1 = (wishX \ 8) * 8
        If x1 < wishX Then x1 = x1 + 16
        players(basketcode).mX = x1: players(basketcode).Column = 7
    Else
        players(basketcode).mX = x1: players(basketcode).Column = 9
    End If
End If
If players(basketcode).mX = 0 Then SetText Scr
players(basketcode).MAXXGRAPH = players(basketcode).Xt * players(basketcode).mX
Scr.Width = players(basketcode).MAXXGRAPH
If wishY > 0 Then
players(basketcode).MAXYGRAPH = wishY * players(basketcode).Yt
If players(basketcode).MAXYGRAPH > Scr.Height Then
SetText Scr, 0, True
players(basketcode).MAXYGRAPH = wishY * (players(basketcode).Yt) + dv15
players(basketcode).MineLineSpace = 0
players(basketcode).uMineLineSpace = 0
mAddTwipsTop = 0
End If
players(basketcode).mY = wishY
Scr.Height = players(basketcode).MAXYGRAPH


End If
SetText Scr, mAddTwipsTop, True
End If
End Function

Sub ClearLoadedForms()
Dim I As Long, j As Long, start As Long
j = Forms.count
Debug.Print ""
While j > 0
For I = start To Forms.count - 1
If TypeOf Forms(I) Is GuiM2000 Then Unload Forms(I): start = I: Exit For
Next I
j = j - 1
Wend
End Sub
Function getSafeFormList() As LongHash
Dim I As Long, myCol As safeforms
If Not varhash.Find(ChrW(&HFFBF) + here$, I) Then
I = AllocVar()
varhash.ItemCreator ChrW(&HFFBF) + here$, I
Set myCol = New safeforms
Set var(I) = myCol
Else
Set myCol = var(I)
End If
Set getSafeFormList = myCol.mylist
End Function
Function ProcBrowser(bstack As basetask, rest$, Lang As Long) As Boolean
Dim s$, W$, X As Double, x1 As Long
ProcBrowser = True

x1 = IsLabelFileName(bstack, rest$, W$)
If x1 = 1 Then
    SwapStrings s$, W$
Else
    x1 = IsStrExp(bstack, rest$, s$, False)
End If

If x1 = 0 Then
If NOEDIT Then
                If Form1.view1.Visible Then
                    Form1.KeyPreview = True
                    ProcTask2 bstack
                    Form1.view1.SetFocus: Form1.KeyPreview = False
                Else
                    Form1.KeyPreview = True
                End If
        End If
        Exit Function
End If
            If FastSymbol(rest$, ",") Then
                    If IsExp(bstack, rest$, X) Then IEX = CLng(X): IESizeX = Form1.ScaleWidth - IEX Else MissNumExpr: ProcBrowser = False: Exit Function
                If FastSymbol(rest$, ",") Then
                    If IsExp(bstack, rest$, X) Then IEY = CLng(X): IESizeY = Form1.ScaleHeight - IEY Else MissNumExpr: ProcBrowser = False: Exit Function
                                If FastSymbol(rest$, ",") Then
                    If IsExp(bstack, rest$, X) Then IESizeX = CLng(X) Else MissNumExpr: ProcBrowser = False: Exit Function
                                    If FastSymbol(rest$, ",") Then
                    If IsExp(bstack, rest$, X) Then IESizeY = CLng(X) Else MissNumExpr: ProcBrowser = False: Exit Function
                 End If
                End If
             End If
           End If
           If IESizeX = 0 Or IESizeY = 0 Then
           IEX = Form1.ScaleWidth / 8
           IEY = Form1.ScaleHeight / 8
           IESizeX = Form1.ScaleWidth * 6 / 8
           IESizeY = Form1.ScaleHeight * 6 / 8
           End If

If myLcase(Left$(s$, 8)) = "https://" Or myLcase(Left$(s$, 7)) = "http://" Or myLcase(Left$(s$, 4)) = "www." Or myLcase(Left$(s$, 6)) = "about:" Then
Form1.IEUP s$
ElseIf s$ <> "" Then
Form1.IEUP "file://" + strTemp + s$
Else
Form1.IEUP ""
Form1.KeyPreview = True
End If
ProcTask2 bstack

End Function

Function MyScore(bstack As basetask, rest$) As Boolean
Dim s$, sX As Double, p As Variant
MyScore = False
If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
If p >= 1 And p <= 16 Then
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, sX, flatobject:=True, nostring:=True) Then
If FastSymbol(rest$, ",") Then
If IsStrExp(bstack, rest$, s$, False) Then
voices(p - 1) = s$
BEATS(p - 1) = CDbl(sX)
MyScore = True
End If
End If
End If
End If
End If
End If
End Function

Function MyPlayScore(bstack As basetask, rest$) As Boolean
Dim task As TaskInterface, sX As Double, p As Variant

MyPlayScore = True
If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
    If p = 0 Then
    TaskMaster.MusicTaskNum = 0
    TaskMaster.OnlyMusic = True
    Do
    TaskMaster.TimerTickNow
    Loop Until TaskMaster.PlayMusic = False
    TaskMaster.OnlyMusic = False   '' forget it in revision 130
   mute = True
    Else
    mute = False
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, sX) Then
          If sX < 1 Then
          sX = 0
          Do While TaskMaster.ThrowOne(CLng(p))
          sX = sX - 1
          If sX < -100 Then Exit Do
          Loop
          Else
          Set task = New MusicBox
          Set task.Owner = Form1.DIS
         
          task.Parameters CLng(p), CLng(sX)
          TaskMaster.MusicTaskNum = TaskMaster.MusicTaskNum + 1
          TaskMaster.AddTask task
          End If
          Do While FastSymbol(rest$, ",")
           MyPlayScore = False
        If IsExp(bstack, rest$, p) Then
             If FastSymbol(rest$, ",") Then
                If IsExp(bstack, rest$, sX) Then
                If sX < 1 Then
                        sX = 0
                        Do While TaskMaster.ThrowOne(CLng(p))
                        sX = sX - 1
                        If sX < -100 Then Exit Do
                        Loop
                  Else
                    Set task = New MusicBox
                    Set task.Owner = Form1.DIS
                    task.Parameters CLng(p), CLng(sX)
                    TaskMaster.MusicTaskNum = TaskMaster.MusicTaskNum + 1
                     TaskMaster.AddTask task
              End If
                MyPlayScore = True
                 End If
            End If
        End If
        If MyPlayScore = False Then
          mute = True
        Exit Do
        End If
          Loop
        End If
    End If
    End If
Else

MyPlayScore = False
End If
End Function

Function IdPara(basestack As basetask, rest$, Lang As Long) As Boolean
Dim x1 As Long, y1 As Long, I As Long, it As Long, vvl As Variant
Dim X As Double, Y As Double, s$, what$, w3 As Long, w4 As Long, z As Double
Dim xa As Long, ya As Long
Dim pppp As mArray


IdPara = True
If IsLabelSymbolNew(rest$, "ÓÔÏ", "TO", Lang) Then
    If Not IsExp(basestack, rest$, Y, flatobject:=True, nostring:=True) Then
        MissNumExpr
        IdPara = False
        Exit Function
    Else
        Y = Y - 1
        If Y < 0 Then Y = -1
        If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, X) Then
                X = Int(X)
                If X < 1 Then
                    MyErMacro rest$, "the index base must be >=1", "ç âÜóç äåßêôç ðñÝðåé íá åßíáé >=1"
                    Exit Function
                End If
            End If
            If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, z, flatobject:=True, nostring:=True) Then
                    z = Int(z)
                    If z < 1 Then
                        MyErMacro rest$, "the lenght base must be >=1", "ôï ìÞêïò ðñÝðåé íá åßíáé >=1"
                        Exit Function
                    End If
                End If
            Else
                z = 0
            End If
        Else
            X = 0
        End If
        If Left$(rest$, 1) = "&" Then Mid$(rest$, 1, 1) = " "
        x1 = Abs(IsLabel(basestack, rest$, what$))
        If x1 = 3 Then
            If GetVar(basestack, what$, I) Then
                If VarTypeName(var(I)) = doc Then
                    If Not FastSymbol(rest$, "=") Then
                        MissSymbol "="
                        IdPara = False
                        Exit Function
                    Else
                        If Not IsStrExp(basestack, rest$, s$, False) Then
                            MissStringExpr
                            IdPara = False
                            Exit Function
                        Else
                            If Y = -1 Then
                            Y = var(I).DocParagraphs
                        End If
                        If var(I).ParagraphFromOrder(Y + 1) = -1 Then
                            CheckVar var(I), s$
                        ElseIf Y < 1 Then
                            w3 = var(I).ParagraphFromOrder(1)
                            w4 = X
                            If z > 0 Then
                                var(I).BackSpaceNchars w3, w4 + CLng(z), CLng(z)
                            End If
                            If w3 < 1 Then w3 = 1
                            If Len(s$) > 0 Then var(I).InsertDoc w3, w4, s$
                        Else
                            w3 = var(I).ParagraphFromOrder(Y + 1)
                            w4 = X
                            If z > 0 Then
                                var(I).BackSpaceNchars w3, w4 + CLng(z), CLng(z)
                            End If
                            If w3 < 1 Then w3 = 1
                            If Len(s$) > 0 Then var(I).InsertDoc w3, w4, s$
                        End If
                    End If
                End If
            Else
                
                MissingDoc   ' only doc not string var
                IdPara = False
                Exit Function
            End If
        Else
            Nosuchvariable what$
            IdPara = False
            Exit Function
        End If
    ElseIf x1 = 6 Then
        If neoGetArray(basestack, what$, pppp) Then
            If Not NeoGetArrayItem(pppp, basestack, what$, it, rest$) Then IdPara = False: Exit Function
                If pppp.ItemType(it) = doc Then
                    If Not FastSymbol(rest$, "=") Then
                        MissSymbol "="
                        IdPara = False
                        Exit Function
                    Else
                        If IsStrExp(basestack, rest$, s$, False) Then
                            If pppp.item(it).ParagraphFromOrder(Y + 1) = -1 Then
                                CheckVar pppp.item(it), s$
                            ElseIf Y < 1 Then
                                w3 = pppp.item(it).ParagraphFromOrder(1)
                                w4 = X
                                If z > 0 Then
                                    pppp.item(it).BackSpaceNchars w3, w4 + CLng(z), CLng(z)
                                End If
                                If w3 < 1 Then w3 = 1
                                If Len(s$) > 0 Then pppp.item(it).InsertDoc w3, w4, s$
                            Else
                                w3 = pppp.item(it).ParagraphFromOrder(Y + 1)
                                w4 = X
                                If z > 0 Then
                                    pppp.item(it).BackSpaceNchars w3, w4 + CLng(z), CLng(z)
                                End If
                                If w3 < 1 Then w3 = 1
                                If Len(s$) > 0 Then pppp.item(it).InsertDoc w3, w4, s$
                            End If
                        Else
                            MissStringExpr
                            IdPara = False
                            Exit Function
                        
                        End If
                    End If
                Else
                    MissingDoc   ' only doc not string var
                    IdPara = False
                    Exit Function
                End If
            End If
        Else
            MissingDoc   ' only doc not string var
            IdPara = False
            Exit Function
        End If
    End If
ElseIf IsExp(basestack, rest$, X) Then
    X = Int(X)
    If X < 1 Then
        MyErMacro rest$, "the index base must be >=1", "ç âÜóç äåßêôç ðñÝðåé íá åßíáé >=1"
        ' not needed to change idpara must be true because macro embed an ERROR command
        Exit Function
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, Y) Then
            MissNumExpr
            IdPara = False
            Exit Function
        End If
        Y = Int(Y)
        If Y < 0 Then
            MyErMacro rest$, "number to delete chars must positive or zero", "ï áñéèìüò ãéá íá äéáãñÜøù ðñÝðåé íá åßíáé èåôéêüò Þ ìçäÝí"
            Exit Function
        End If
    Else
        Y = 0  ' only insert
    End If
    If Left$(rest$, 1) = "&" Then Mid$(rest$, 1, 1) = " "
     x1 = Abs(IsLabel(basestack, rest$, what$))
        
        If x1 = 3 Or x1 = 1 Then
            If GetVar(basestack, what$, I) Then
                If VarTypeName(var(I)) = doc Then
                    If Not FastSymbol(rest$, "=") Then
                        MissSymbol "="
                        IdPara = False
                        Exit Function
                    Else
                        If Not IsStrExp(basestack, rest$, s$, False) Then
                            MissStringExpr
                            IdPara = False
                            Exit Function
                        Else
                            If Y = 0 Then
                                var(I).FindPos 1, 0, CLng(X), x1, y1, w3, w4
                                If w4 = 0 Then
                                 ' ' merge to previous
                                End If
                            Else
                                var(I).FindPos 1, 0, X + Y, x1, y1, w3, w4
                                ' so now we now the paragraph w3 and the position w4
                                var(I).BackSpaceNchars w3, w4, Y
                            End If
                            If s$ <> "" Then var(I).InsertDoc w3, w4, s$
                        End If
                     End If
                ElseIf VarTypeName(var(I)) = "Constant" Then
                    CantAssignValue
                    IdPara = False
                    Exit Function
                Else
                    If x1 = 1 Then
                    If Not myVarType(var(I), vbString) Then
                        MissingStrVar
                        IdPara = False
                    End If
                    End If
                    If Not FastSymbol(rest$, "=") Then
                        MissSymbol "="
                        IdPara = False
                        Exit Function
                    Else
                        If Not IsStrExp(basestack, rest$, s$, False) Then
                            MissStringExpr
                            IdPara = False
                            Exit Function
                        Else
                            If Y = 0 Then
                                var(I) = Left$(var(I), X - 1) + s$ + Mid$(var(I), X)
                            Else
                                If s$ = vbNullString Then
                                    var(I) = Left$(var(I), X - 1) + Mid$(var(I), X + Y)
                                Else
                                    If Len(s$) = Y Then
                                        Mid$(var(I), X, Y) = s$
                                    ElseIf Len(s$) < Y Then
                                        Mid$(var(I), X, Y) = s$ + space$(Y - Len(s$))
                                    Else
                                        var(I) = Left$(var(I), X - 1) + s$ + Mid$(var(I), X + Y)
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            Else
                Nosuchvariable what$
                IdPara = False
                Exit Function
            End If
        ElseIf x1 = 6 Or x1 = 5 Then
            If neoGetArray(basestack, what$, pppp) Then
                If Not NeoGetArrayItem(pppp, basestack, what$, it, rest$) Then IdPara = False: Exit Function
                If pppp.ItemType(it) = doc Then
                    If FastSymbol(rest$, "=") Then
                        If IsStrExp(basestack, rest$, s$, False) Then
                            If Y = 0 Then
                                pppp.item(it).FindPos 1, 0, CLng(X), xa, ya, w3, w4
                                 If w4 = 0 Then
                                ' ' merge to previous
                                 End If
                            Else
                                pppp.item(it).FindPos 1, 0, X + Y, xa, ya, w3, w4
                                ' so now we now the paragraph w3 and the position w4
                                pppp.item(it).BackSpaceNchars w3, w4, Y
                            End If
                            If s$ <> "" Then pppp.item(it).InsertDoc w3, w4, s$
                        Else
                            MissStringExpr
                            IdPara = False
                        End If
                    End If
                Else
                If Not pppp.ItemType(it) = "String" Then
                            WrongItemType
                            IdPara = False
                            Exit Function
                End If
                If FastSymbol(rest$, "=") Then
                    If IsStrExp(basestack, rest$, s$, False) Then
                        If Y = 0 Then
                            pppp.item(it) = Left$(pppp.item(it), X - 1) + s$ + Mid$(var(I), X)
                        Else
                            If s$ = vbNullString Then
                                pppp.item(it) = Left$(pppp.item(it), X - 1) + Mid$(pppp.item(it), X + Y)
                            Else
                                vvl = pppp.item(it)
                                If Len(vvl) = Y Then
                                    Mid$(vvl, X, Y) = s$
                                ElseIf Len(s$) < Y Then
                                    Mid$(vvl, X, Y) = s$ + space$(Y - Len(s$))
                                Else
                                    vvl = Left$(vvl, X - 1) + s$ + Mid$(vvl, X + Y)
                                End If
                                pppp.item(it) = vvl
                            End If
                        End If
                    Else
                        MissStringExpr
                        IdPara = False
                    End If
                End If
            End If
        Else
            IdPara = True
        End If
    Else
        If x1 = 8 Then
        NotForArrayBrackets
        Else
        MissingStrVar
        End If
        IdPara = False
        ' wrong parameter
    End If
End If

End Function
Sub stackshow(b As basetask)
Static OldPagio$
Dim p As Variant, r$, al$, s$, dl$, dl2$, isnew As Boolean
Static once As Boolean, ok As Boolean
If once Then Exit Sub
once = True
Form2.GetPanelPos
TestShowSubLast = TestShowSub
If TestShowCode Then
    If Not Form2.switchview = 1 Then
        Form2.switchview = 1
        Form2.gList3(2).BackColor = &H606060
        Form2.gList3(2) = Form2.gList3(2)
    End If
    With Form2.testpad
        .enabled = True
        .SelectionColor = rgb(255, 64, 128)
        .nowrap = True
        .NoColor = False
        isnew = oldpanel1 <> TestShowSubLast
        If isnew Then
            oldpanel1 = TestShowSubLast
        End If
        .Text = TestShowSubLast
        If Len(Form2.label1(1)) > 0 Then
            If AscW(Form2.label1(1)) = 8191 Then
                .SelStartSilent = TestShowStart - 1
                .SelLength = Len(Mid$(Form2.label1(1), 7))
            Else
                .SelStartSilent = TestShowStart - Len(Form2.label1(1)) - 1
                .SelLength = Len(Form2.label1(1))
            End If
            Form2.GetPanelPos 1&
        End If
        Form2.paneltitle 1&
        'Form2.gList1.ShowMe
       ' If isnew Then
       '     Form2.GetPanelPos 1&
       ' Else
       '     Form2.SetPanelPos 1&
       ' End If
        
    End With
    once = False
    Exit Sub
ElseIf Form2.switchview = 2 Then
        With Form2.testpad
        .enabled = True
        .SelectionColor = rgb(255, 64, 128)
        .nowrap = True
        .NoColor = True
        .ForeColor = rgb(255, 255, 0)
        If Errorlog.DocLines = 0 Then
            If pagio$ = "GREEK" Then
                .Text = "Äåí Ý÷ïõí êáôáãñáöåß ëÜèç" & vbCrLf & "F1 - êáèáñéóìüò" & vbCrLf & "F4 - áíôéãñáöÞ óôç öüñìá âïÞèåéáò"
            Else
                .Text = "No Errors logged" & vbCrLf & "F1 - clear" & vbCrLf & "F4 - copy window to help form"
            End If
            .SetRowColumn 1, 1
            Form2.GetPanelPos 2&
        Else
            isnew = oldpanel2 <> Errorlog.textDoc
            If isnew Then oldpanel2 = Errorlog.textDoc
            .Text = Errorlog.textDoc
            If isnew Or Not STbyST Then
                If .glistN.listcount - 1 > 0 Then
                    .SetRowColumn .glistN.listcount - 1, 1
                Else
                    .SetRowColumn 1, 1
                End If
                Form2.GetPanelPos 2&
            Else
                Form2.SetPanelPos 2&
            End If
        End If
        '.glistN.ShowMe2
        Form2.paneltitle 2&
        End With
        once = False
        Exit Sub
Else
    Form2.switchview = 0
    Form2.testpad.nowrap = False
    Form2.testpad.NoColor = False
    Form2.paneltitle 0&
End If

If pagio$ <> OldPagio$ Then
Form2.FillAgainLabels
OldPagio$ = pagio$
End If


Dim Stack As mStiva
Set Stack = b.soros

If Form2.Compute <> "" Then
If Form2.Compute.Prompt = "? " Then dl$ = Form2.Compute
With Form2.testpad
.enabled = True
.ResetSelColors
''
.nowrap = False
''
End With
Do
dl2 = dl$
ok = False
stackshowonly = True
If FastSymbol(dl$, ")") Then
ok = True
ElseIf IsExp(b, dl$, p) Then
    If al$ = vbNullString Then
        If pagio$ = "GREEK" Then
        al$ = "? " + Left$(dl2$, Len(dl2$) - Len(dl$)) + "=" + MyCStr(p)
        Else
        al$ = "? " + Left$(dl2$, Len(dl2$) - Len(dl$)) + "=" + MyCStr(p)
        End If
            
    Else
        al$ = al$ + "," + Left$(dl2$, Len(dl2$) - Len(dl$)) + "=" + MyCStr(p)
    End If
    ok = True
    ElseIf IsStrExp(b, dl$, s$) Then
    If Len(dl2$) - Len(dl$) >= 0 Then
    
    
    If al$ = vbNullString Then
        al$ = Left$(dl2$, Len(dl2$) - Len(dl$)) + "=" + Chr(34) + s$ + Chr(34)
    Else
        al$ = al$ + "," + Left$(dl2$, Len(dl2$) - Len(dl$)) + "=" + Chr(34) + s$ + Chr(34)
    End If
    ok = True
    End If
    ElseIf InStr(dl$, ",") > 0 Then
       If InStr(dl$, Chr(2)) > 0 Then
     r$ = GetStrUntil(Chr(2), dl$, False)
     s$ = "<"
If ISSTRINGA(dl$, r$) Then If pagio$ <> "GREEK" Then s$ = s$ + r$
If ISSTRINGA(dl$, r$) Then If pagio$ = "GREEK" Then s$ = s$ + r$
al$ = s$ + ">" + al$
ok = True
Else
al$ = al$ + " " + GetStrUntil(",", dl$)
    
     dl$ = vbNullString
  
End If
    
    ok = True
    ElseIf dl$ <> "" Then
      If InStr(dl$, Chr(2)) > 0 Then
     r$ = GetStrUntil(Chr(2), dl$, False)
     s$ = "<"
If ISSTRINGA(dl$, r$) Then If pagio$ <> "GREEK" Then s$ = s$ + r$
If ISSTRINGA(dl$, r$) Then If pagio$ = "GREEK" Then s$ = s$ + r$
al$ = s$ + ">" + al$
ok = True
Else
     al$ = al$ + " " + dl$
     dl$ = vbNullString
  
End If

    End If
    
DropLeft ",", dl$

Loop Until Not ok
End If
stackshowonly = False
If al$ <> "" Then al$ = al$ + vbCrLf
    If pagio$ = "GREEK" Then
    al$ = al$ + "Óùñüò "
    Else
    al$ = al$ + "Stack "
    End If
If Stack.Total = 0 Then
    If pagio$ = "GREEK" Then
    al$ = al$ + "Áäåéïò"
    Else
    al$ = al$ + "Empty"
    End If
Else
    If pagio$ = "GREEK" Then
    al$ = al$ + "ÊïñõöÞ "
    Else
    al$ = al$ + "Top "
    End If

End If
Dim I As Long

Do
I = I + 1
If Stack.Total < I Or Len(al$) > 400 Then Exit Do

If Stack.StackItemType(I) = "N" Or Stack.StackItemType(I) = "L" Then
al$ = al$ + MyCStr(Stack.StackItem(I)) + " "
ElseIf Stack.StackItemType(I) = "S" Then
r$ = Stack.StackItem(I)
    If Len(r$) > 78 Then
    al$ = al$ + Chr(34) + Left$(r$, 75) + "..." + Chr(34)
    Else
    al$ = al$ + Chr(34) + r$ + Chr(34)
    End If
 ElseIf Stack.StackItemType(I) = ">" Then
   If pagio$ = "LATIN" Then
    al$ = al$ + "[Optional] "
    Else
    al$ = al$ + "[Ðñïáéñåôéêü] "
    End If
ElseIf Stack.StackItemType(I) = "*" Then

al$ = al$ + Stack.StackItemTypeObjectType(I) + " "
Else  '??
al$ = al$ + Stack.StackItemTypeObjectType(I) + " "
End If

Loop
With Form2
    .gList1.BackColor = &H3B3B3B
        .label1(2) = .label1(2)
    
        .testpad.enabled = True
        .testpad.Text = al$
         .testpad.SetRowColumn 1, 1
         Form2.GetPanelPos 0&
       ' .testpad.enabled = False
       
End With
once = False
End Sub

Function MyCStr(p) As String
    Select Case VarType(p)
    Case vbBoolean
        MyCStr = Format$(p, ";\T\r\u\e;\F\a\l\s\e")
    Case vbLong
        MyCStr = LTrim$(str$(p)) + "&"
    Case vbInteger
        MyCStr = LTrim$(str$(p)) + "%"
    Case vbDecimal
        MyCStr = LTrim$(str$(p)) + "@"
    Case vbSingle
        MyCStr = LTrim$(str$(p)) + "~"
    Case vbCurrency
        MyCStr = LTrim$(str$(p)) + "#"
    Case 20
        MyCStr = CStr(p) + "&&"
    Case Else
        MyCStr = LTrim$(str$(p))
    End Select
End Function
Private Function VarTypeNameList(v) As String
Dim n As Integer
    n = MemInt(VarPtr(v))
    Select Case n And &H7FF
        Case 0
            VarTypeNameList = "Empty"
        Case 1
            VarTypeNameList = "Null"
        Case 2
            VarTypeNameList = "Integer"
        Case 3
            VarTypeNameList = "Long"
        Case 4
            VarTypeNameList = "Single"
        Case 5
            VarTypeNameList = "Double"
        Case 6
            VarTypeNameList = "Currency"
        Case 7
            VarTypeNameList = "Date"
        Case 8
            VarTypeNameList = "String"
        Case 10
            VarTypeNameList = "Error"
        Case 9, 13
            VarTypeNameList = Typename(v)
        Case 11
            VarTypeNameList = "Boolean"
        Case 12, 1
            VarTypeNameList = "Variant"
        Case 14
            VarTypeNameList = "Decimal"
        Case 17
            VarTypeNameList = "Byte"
        Case 20
            VarTypeNameList = "Long Long"
        Case 36
            VarTypeNameList = Typename(v)
        Case Is > 8192
            VarTypeNameList = ArrayDesc(v)
        Case Else
            VarTypeNameList = "type" & VarType(v)
    End Select
End Function

Sub mylist(bstack As basetask, Optional tofile As Long = -1, Optional Lang As Long)
Dim Scr As Object, prive As Long
Set Scr = bstack.Owner
prive = GetCode(Scr)
Dim p As Variant, I As Long, s$, pn&, X As Double, Y As Double, it As Long, f As Long, pa$
Dim x1 As Long, y1 As Long, frm$, par As Boolean, ohere$, ss$, W$, sX As Double, sY As Double, modname$
Dim pppp As mArray, hlp$, h&, all$, myobject As Object, usehandler As mHandler, usegroup As Group
Dim w1 As Long, w2 As Long, w3 As Long, dum As Boolean, virtualtop As Long
pn& = 0
virtualtop = varhash.count - 1
'GoTo ByPass  '********************************
For pn& = virtualtop To 0 Step -1
    varhash.ReadVar pn&, s$, h&
    If InStr(s$, ChrW(&H1FFF)) = 0 And InStr(s$, ChrW(&HFFBF)) = 0 Then Exit For
    virtualtop = virtualtop - 1
Next pn&
ByPass:
pn& = 0
Dim A() As String, aa() As String
With players(prive)
    Do While pn& < varhash.count
        varhash.ReadVar pn&, s$, h&
        If SecureNames Then
            A() = Split(s$, "».")
            If UBound(A()) = 1 Then
                A(0) = GetName(A(0))
                s$ = Join(A(), ".")
            End If
            aa() = Split(s$, ".")
            If UBound(aa()) = 1 Then
            aa(0) = sbf(val(Mid$(aa(0), 2))).goodname
            s$ = Join(aa(), ".")
            End If
            
        End If
        If h& <> -1 Then
            If InStr(s$, ChrW(&HFFBF)) > 0 Then
                GoTo LOOPNEXT
            ElseIf InStr(s$, ChrW(&H1FFF)) > 0 Then
                GoTo LOOPNEXT
            ElseIf Right$(s$, 1) = "(" Then
                If MyIsObject(var(h&)) Then
                    Set myobject = var(h&)
                    If Not CheckIsmArray(myobject) Then
                        If Not myobject Is Nothing Then
                            If TypeOf myobject Is ppppLight Then
                                If Typename(myobject.GroupRef) = "PropReference" Then
                                    Dim pr As PropReference
                                    Set pr = myobject.GroupRef
                                    s$ = s$ + ")." + pr.ObjectType
                                    Set pr = Nothing
                                    GoTo conthere
                                End If
                            End If
                        End If
                        GoTo LOOPNEXT
                    End If
                    Set pppp = myobject
                    Set myobject = Nothing
                    f = pppp.bDnum
                    w1 = 0
                    pppp.GetDnum w1, w2, w3
                    w1 = w1 + 1
                    If f > 1 Then
                        If tofile < 0 Then
                            If tofile = -1 Then
                                If .mX - .curpos < Len(s$ + Trim$(str$(w2)) + ",") Then crNew bstack, players(prive)
                                PlainBaSket Scr, players(prive), s$ + Trim$(str$(w2)) + ","
                            Else
                                all = all + " " + s$ + Trim$(str$(w2)) + ","
                                s$ = vbNullString
                            End If
                        Else
                            If uni(tofile) Then
                                putUniString tofile, s$ + Trim$(str$(w2)) + ","
                            Else
                                putANSIString tofile, s$ + Trim$(str$(w2)) + ","
                            End If
                        End If
                    Else
                        If pn& < virtualtop Then
                            If tofile < 0 Then
                                If tofile = -1 Then
                                    If .mX - .curpos < Len(s$ + Trim$(str$(w2)) + "), ") Then crNew bstack, players(prive)
                                    PlainBaSket Scr, players(prive), s$ + Trim$(str$(w2)) + "), "
                                Else
                                    all = all + " " + s$ + Trim$(str$(w2)) + "),"
                                End If
                            Else
                                If uni(tofile) Then
                                    putUniString tofile, s$ + Trim$(str$(w2)) + "), "
                                Else
                                    putANSIString tofile, s$ + Trim$(str$(w2)) + "), "
                                End If
                            End If
                        Else
                            If tofile < 0 Then
                                If tofile = -1 Then
                                    If .mX - .curpos < Len(s$ + Trim$(str$(w2)) + ")") Then crNew bstack, players(prive)
                                        PlainBaSket Scr, players(prive), s$ + Trim$(str$(w2)) + ")"
                                    Else
                                        all = all + " " + s$ + Trim$(str$(w2)) + ")"
                                    End If
                                 Else
                                    If uni(tofile) Then
                                        putUniString tofile, s$ + Trim$(str$(w2)) + ")"
                                    Else
                                        putANSIString tofile, s$ + Trim$(str$(w2)) + ")"
                                    End If
                                End If
                            End If
                    End If
                    X = f - 1
                    While X > 0
                        X = X - 1
                        pppp.GetDnum w1, w2, w3
                        w1 = w1 + 1
                        If X > 0 Then
                            If tofile < 0 Then
                                If tofile = -1 Then
                                    If .mX - .curpos < Len(Trim$(str$(w2)) + ",") Then crNew bstack, players(prive)
                                    PlainBaSket Scr, players(prive), Trim$(str$(w2)) + ","
                                Else
                                    all = all + " " + s$ + Trim$(str$(w2)) + ","
                                End If
                            Else
                                If uni(tofile) Then
                                    putUniString tofile, Trim$(str$(w2)) + ","
                                Else
                                    putANSIString tofile, Trim$(str$(w2)) + ","
                                End If
                            End If
                        Else
                            If pn& < virtualtop Then
                                If tofile < 0 Then
                                    If tofile = -1 Then
                                        If .mX - .curpos < Len(Trim$(str$(w2)) + "), ") Then crNew bstack, players(prive)
                                        PlainBaSket Scr, players(prive), Trim$(str$(w2)) + "), "
                                    Else
                                        all = all + " " + s$ + Trim$(str$(w2)) + "),"
                                    End If
                                Else
                                    If uni(tofile) Then
                                        putUniString tofile, Trim$(str$(w2)) + "), "
                                    Else
                                        putANSIString tofile, Trim$(str$(w2)) + "), "
                                    End If
                                End If
                            Else
                                If tofile < 0 Then
                                    If tofile = -1 Then
                                        If .mX - .curpos < Len(Trim$(str$(w2)) + ")") Then crNew bstack, players(prive)
                                        PlainBaSket Scr, players(prive), Trim$(str$(w2)) + ")"
                                    Else
                                        all = all + " " + s$ + Trim$(str$(w2)) + ")"
                                    End If
                                Else
                                    If uni(tofile) Then
                                        putUniString tofile, Trim$(str$(w2)) + ")"
                                    Else
                                        putANSIString tofile, Trim$(str$(w2)) + ")"
                                    End If
                                End If
                            End If
                        End If
                    Wend
                End If
                GoTo LOOPNEXT
            ElseIf Right$(s$, 1) = "$" Or Right$(s$, 3) = "$()" Then  ' WHY "$()"
                If VarTypeName(var(h&)) = doc Then
                    If var(h&).IsEmpty Then
                        hlp$ = " [Empty Document]"
                    Else
                        hlp$ = " [Document " & (var(h&).SizeCRLF) & " chars]"
                    End If
                ElseIf VarTypeName(var(h&)) = "PropReference" Then
                    hlp$ = " [Object Property]"
                Else
                    If MyIsObject(var(h&)) Then
                        If TypeOf var(h&) Is lambda Then
                            hlp$ = "[lambda$]"
                        Else
                            If TypeOf var(h&) Is Constant Then
                                If var(h&).flag Then
                                    hlp$ = "[" + VarTypeNameList(var(h&).Value) + "$]"
                                Else
                                    If Len(CStr(var(h&))) > 3 * .mX Then
                                        hlp$ = " = [" + Left$(CStr(var(h&)), 4) + "...]"
                                    Else
                                        hlp$ = " = [" & (var(h&)) & "]"
                                    End If
                                End If
                            Else
                                hlp$ = "[" + VarTypeNameList(var(h&)) + "]"
                            End If
                        End If
                    Else
                        If Len(var(h&)) > 3 * .mX Then
                            hlp$ = " = " + Chr(34) + Left$(CStr(var(h&)), 4) + "..." + Chr(34)
                        Else
                            hlp$ = " = " & Chr(34) & (var(h&)) & Chr(34)
                        End If
                    End If
                End If
                s$ = s$ + hlp$
            Else
                If MyIsObject(var(h&)) Then
                    If var(h&) Is Nothing Then
                        s$ = s$ + "*[Nothing]"
                    ElseIf TypeOf var(h&) Is mHandler Then
                        Set usehandler = var(h&)
                        Select Case usehandler.T1
                        Case 1
                            If usehandler.ReadOnly Then
                                If usehandler.objref.structLen > 0 Then

                                    s$ = s$ + "*[Structure]"
                                    
                                Else
                                    s$ = s$ + "*[Inventory/ReadOnly]"
                                End If
                            Else
                                s$ = s$ + "*[Inventory]"
                            End If
                        Case 2
                                If usehandler.objref.structref Is Nothing Then
                                    s$ = s$ + "*[Buffer]"
                                ElseIf usehandler.objref.structref.Tag <> "" Then
                                    If usehandler.objref.items = 1 Then
                                    s$ = s$ + "*[" + usehandler.objref.structref.Tag + "]"
                                    Else
                                    s$ = s$ + "*[" + usehandler.objref.structref.Tag + ":" & usehandler.objref.items & "]"
                                    End If
                                Else
                                    s$ = s$ + "*[Buffer]"
                                End If
                        Case 4
                            If myVarType(usehandler.index_cursor, vbString) Then
                            If Len(usehandler.index_cursor) > 3 * .mX Then
                                hlp$ = Chr(34) + Left$(usehandler.index_cursor, 4) + "..." + Chr(34)
                            Else
                                hlp$ = Chr(34) + usehandler.index_cursor + Chr(34)
                            End If
                            ElseIf myVarType(usehandler.index_cursor, 20) Then
                                hlp$ = CStr(usehandler.index_cursor)
                            Else
                                hlp$ = LTrim$(str(usehandler.index_cursor))
                            End If
                            If usehandler.ReadOnly Then
                                s$ = s$ + " = [" + usehandler.objref.EnumName + ":" + hlp$ + "]"
                            Else
                                s$ = s$ + "[" + usehandler.objref.EnumName + "] = " + hlp$
                            End If
                            
                        Case Else
                            If Not usehandler.objref Is Nothing Then
                                If TypeOf usehandler.objref Is mHandler Then
                                    If usehandler.objref.T1 = 4 Then
                                        Set usehandler = usehandler.objref
                                        s$ = s$ + "*[" + usehandler.objref.EnumName + "]"
                                    Else
                                        s$ = s$ + "*[" + Typename(usehandler.objref) + "]"
                                    End If
                                Else
                                    s$ = s$ + "*[" + Typename(usehandler.objref) + "]"
                                End If
                            ElseIf usehandler.indirect > 0 Then
                                s$ = s$ + "*[" + VarTypeNameList(var(usehandler.indirect)) + "]"
                            End If
                        End Select
                        Set usehandler = Nothing
                    ElseIf TypeOf var(h&) Is refArray Then
                    Dim rA As refArray
                    Set rA = var(h&)
                    
                    If rA.MarkTwoDimension Then
                        s$ = s$ & "*" & rA.vtTypeString()
                    Else
                        If rA.emtype = 200 Then
                        s$ = s$ & "*" & "Complex" & Mid(rA.vtTypeString(0), 8)
                        Else
                        s$ = s$ & "*" & rA.vtTypeString(0)
                        End If
                    End If
                    Else
                        If TypeOf var(h&) Is Constant Then
                            On Error Resume Next
                            If VarType(var(h&)) = 20 Then
                            s$ = s$ + " = [" + CStr(var(h&)) + "]"
                            ElseIf VarType(var(h&)) = vbString Then
                            s$ = s$ + " = [" + LTrim$(var(h&).Value) + "]"
                            Else
                            s$ = s$ + " = [" + LTrim$(str(var(h&))) + "]"
                            End If
                            If Err Then
                                s$ = s$ & " = [" & var(h&) & "]"
                                Err.Clear
                            End If
                        Else
                            If TypeOf var(h&) Is Group Then
                                Set usegroup = var(h&)
                                If usegroup.IamApointer Then
                                    s$ = s$ + "*[Group]"
                                Else
                                    s$ = s$ + "[Group]"
                                End If
                                Set usegroup = Nothing
                            ElseIf TypeOf var(h&) Is PropReference Then
                                s$ = s$ + "." + var(h&).ObjectType
                            ElseIf TypeOf var(h&) Is BigInteger Then
                                s$ = s$ + var(h&).Pack
                            Else
                                s$ = s$ + "*" + VarTypeNameList(var(h&))
                            End If
                        End If
                    End If
                Else
                    On Error Resume Next
                    Select Case VarType(var(h&))
                    Case 20
                        s$ = s$ + " = " + CStr(var(h&)) + "&&"
                    Case vbByte
                        s$ = s$ + " = " + CStr(var(h&)) + "|0x" + Hex(var(h&))
                    Case vbString
                        If Len(var(h&)) > 3 * .mX Then
                            s$ = s$ + " = " + Chr(34) + Left$(LTrim$(var(h&)), 4) + "..." + Chr(34)
                        Else
                            s$ = s$ + " = " + Chr(34) + LTrim$(var(h&)) + Chr(34)
                        End If
                    Case 13
                        s$ = s$ + "*[" + Typename(var(h&)) + "]"
                    Case 36
                  If Left$(Typename(var(h&)), 2) = "cx" Then
                      s$ = s$ + "[" + Mid$(Typename(var(h&)), 3) + "]"
                       Else
                        s$ = s$ + "[" + Typename(var(h&)) + "]"
                        End If
                    Case Else
                        s$ = s$ + " = " + LTrim$(str(var(h&)))
                    End Select
                    If Err Then
                        hlp$ = "" & var(h&)
                        If Len(hlp$) > 3 * .mX Then
                            s$ = s$ + " = " + Chr(34) + Left$(hlp$, 4) + "..." + Chr(34)
                        Else
                            s$ = s$ + " = " + Chr(34) + hlp$ + Chr(34)
                        End If

                        Err.Clear
                    End If
                    Select Case VarType(var(h&))
                    Case vbLong
                        s$ = s$ + "&"
                    Case vbDecimal
                        s$ = s$ + "@"
                    Case vbSingle
                        s$ = s$ + "~"
                    Case vbCurrency
                        s$ = s$ + "#"
                    Case vbInteger
                        s$ = s$ + "%"
                    End Select
                End If
                
            End If
conthere:
            If pn& < virtualtop Then s$ = s$ + ", "
            If tofile < 0 Then
                If tofile = -1 Then
                    If .mX - .curpos < Len(s$) Then crNew bstack, players(prive)
                    PlainBaSket Scr, players(prive), s$
                End If
                all = all + " " + s$
            Else
                If uni(tofile) Then
                    putUniString tofile, s$
                Else
                    putANSIString tofile, s$
                End If
            End If
        End If
LOOPNEXT:
        pn& = pn& + 1
    Loop
s$ = vbNullString
If Not bstack.StaticCollection Is Nothing Then
Dim st1 As Long, mList As FastCollection, sk As Boolean
Set mList = bstack.StaticCollection
If mList.count > 0 Then
    If Lang = 1 Then
        s$ = " Static Variables: "
    Else
        s$ = " ÓôáôéêÝò ÌåôáâëçôÝò: "
    End If
    If tofile < 0 Then
        If tofile = -1 Then
            crNew bstack, players(prive)
            PlainBaSket Scr, players(prive), s$
            crNew bstack, players(prive)
        End If
        all = all + vbCrLf + s$ + vbCrLf
    Else
        If uni(tofile) Then
            putUniString tofile, s$
        Else
            putANSIString tofile, s$
        End If
    End If
    s$ = ""
End If
For st1 = 1 To mList.count
mList.Index = st1 - 1
If Left$(mList.KeyToString, 2) <> "%_" Then

    If mList.IsObj Then
        If TypeOf mList.ValueObj Is mHandler Then
            Set usehandler = mList.ValueObj
            Select Case usehandler.T1
            Case 1
                If usehandler.ReadOnly Then
                    If usehandler.objref.structLen > 0 Then
                    s$ = s$ + mList.KeyToString + "*[Structure]"
                    Else
                    s$ = s$ + mList.KeyToString + "*[Inventory/ReadOnly]"
                    End If
                Else
                    s$ = s$ + mList.KeyToString + "*[Inventory]"
                End If
            Case 2
                s$ = s$ + mList.KeyToString + "*[Buffer]"
            Case 3
                s$ = s$ + mList.KeyToString + "*[" + Typename(usehandler.objref) + "]"
            Case 4
                        If myVarType(usehandler.index_cursor, vbString) Then
                            If Len(usehandler.index_cursor) > 3 * .mX Then
                                hlp$ = Chr(34) + Left$(usehandler.index_cursor, 4) + "..." + Chr(34)
                            Else
                                hlp$ = Chr(34) + usehandler.index_cursor + Chr(34)
                            End If
                            ElseIf myVarType(usehandler.index_cursor, 20) Then
                                hlp$ = CStr(usehandler.index_cursor)
                            Else
                                hlp$ = LTrim$(str(usehandler.index_cursor))
                            End If
                            If usehandler.ReadOnly Then
                                s$ = s$ + " = [" + usehandler.objref.EnumName + ":" + hlp$ + "]"
                            Else
                                s$ = s$ + "[" + usehandler.objref.EnumName + "] = " + hlp$
                            End If
            End Select
        ElseIf TypeOf mList.ValueObj Is BigInteger Then
      
        s$ = s$ + mList.KeyToString + mList.ValueObj.Pack
        Else
            s$ = s$ + mList.KeyToString + " [" + Typename(mList.ValueObj) + "]"
        End If
    Else
If IsNumeric(mList.Value) Then
    If VarType(mList.Value) = vbByte Then
    s$ = s$ + mList.KeyToString + " = " + CStr(mList.Value) + "|0x" + Hex(mList.Value)
    ElseIf VarType(mList.Value) = vbLong Then
        s$ = s$ + mList.KeyToString + " = " + CStr(mList.Value) + "&"
                ElseIf VarType(mList.Value) = vbInteger Then
                    s$ = s$ + mList.KeyToString + " = " + CStr(mList.Value) + "%"
                Else
                s$ = s$ + mList.KeyToString + " = " + LTrim$(str$(mList.Value))
                End If
            ElseIf VarType(mList.Value) = vbDate Then
                    s$ = s$ & mList.KeyToString & " = " & mList.Value
            ElseIf VarType(mList.Value) = 20 Then
                s$ = s$ & mList.KeyToString & " = " & CStr(mList.Value) & "&&"
            Else
                If Len(var(h&)) > 3 * .mX Then
                    s$ = s$ + mList.KeyToString + " = " + Chr(34) + Left$(mList.Value, 4) + "..." + Chr(34)
                Else
                    s$ = s$ & mList.KeyToString & " = " & Chr(34) & mList.Value & Chr(34)
                End If
            End If
        End If
    End If
 
    If s$ <> "" Then

        If tofile >= 0 Then
            putUniString tofile, vbCrLf
            If uni(tofile) Then
                putUniString tofile, s$
            Else
                putANSIString tofile, s$
            End If
        End If
    End If
   If mList.count > st1 Then s$ = s$ + ", "
    
    If tofile < 0 Then
        If tofile = -1 Then
            If .mX - .curpos < Len(s$) Then crNew bstack, players(prive)
            PlainBaSket Scr, players(prive), s$
        End If
        all = all + " " + s$
    Else
        If uni(tofile) Then
            putUniString tofile, s$
        Else
            putANSIString tofile, s$
        End If
    End If
    
    s$ = ""
    
       Next st1
    
    
    
End If
    If tofile < -1 Then
        If Scr.currentX <> 0 Then crNew bstack, players(prive)
        If s$ <> "" Then s$ = vbCrLf + s$
        wwPlain2 bstack, players(prive), all$ + s$, Scr.Width, 1000, True, , 3
    ElseIf tofile = -1 Then
        If s$ <> "" Then
         crNew bstack, players(prive)
        
        PlainBaSket Scr, players(prive), s$
        End If
    End If
    
    If tofile < 0 Then crNew bstack, players(prive)
        
      End With
End Sub
Function PathFromApp(ByVal nap$) As String
Dim ap$
nap$ = nap$ + " "
ap$ = GetStrUntil(" ", nap$)
If ExtractType(ap$) = vbNullString Then ap$ = ap$ + ".exe"
Dim cc As New cRegistry
cc.ClassKey = HKEY_CURRENT_USER
cc.SectionKey = "SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\" + ap$
cc.ValueKey = vbNullString
cc.ValueType = REG_SZ
On Error GoTo 1111
If IsEmpty(cc.Value) Then
    cc.ClassKey = HKEY_LOCAL_MACHINE
    If IsEmpty(cc.Value) Then
        PathFromApp = vbNullString
    Else
        PathFromApp = Trim$(mylcasefILE(cc.Value & " " & nap$))
    End If
Else
    PathFromApp = Trim$(mylcasefILE(cc.Value & " " & nap$))
End If
Exit Function
1111:
PathFromApp = vbNullString
End Function


Public Function PCall(ByVal sFile As String, Optional param As String) As String
Dim S2 As String, I As Long, bsfile As String, rfile As String, MYNULL$
bsfile = mylcasefILE(sFile)
   S2 = String(MAX_FILENAME_LEN, 32)
   'Retrieve the name and handle of the executable, associated with this file
   I = FindExecutable(StrPtr(sFile), StrPtr(MYNULL$), StrPtr(S2))
   If I > 32 Then
   rfile = mylcasefILE(Left$(S2, InStr(S2, Chr$(0)) - 1))
   If ExtractName(bsfile, True) = ExtractName(rfile, True) Then
   ' it is an executable
   PCall = mylcasefILE(bsfile)
   Else
   If param <> "" Then
   PCall = rfile & " " & param & " " & Chr(34) + bsfile + Chr(34)
   Else
      PCall = rfile & " " & Chr(34) + bsfile + Chr(34)
      End If
      End If
      Else
      PCall = vbNullString
End If
End Function

Sub makegroup(bstack As basetask, what$, I As Long)
Dim it As Long
it = globalvar(what$, it)
    MakeitObject2 var(it)
    If var(I).IamApointer Then
        If var(I).link.IamFloatGroup Then
           Set var(it).LinkRef = var(I).link
            var(it).IamApointer = True
            var(it).isRef = True
        Else
            With var(I).link
            
                var(it).edittag = .edittag
                var(it).FuncList = .FuncList
                var(it).GroupName = myUcase(what$) & "."
               ' Set var(it).Sorosref = .soros.Copy
                If UBound(.Fields) > 1 Then var(it).Fields = .Fields
                var(it).HasValue = .HasValue
                var(it).HasSet = .HasSet
                var(it).HasStrValue = .HasStrValue
                var(it).HasParameters = .HasParameters
                var(it).HasParametersSet = .HasParametersSet
            
                        Set var(it).Events = .Events
            
                var(it).highpriorityoper = .highpriorityoper
                var(it).HasUnary = .HasUnary
            End With
        End If
    
    Else
        With var(I)
            var(it).edittag = .edittag
            var(it).FuncList = .FuncList
            var(it).GroupName = myUcase(what$) & "."
            'Set var(it).Sorosref = .soros.Copy
            If UBound(.Fields) > 1 Then var(it).Fields = .Fields
            var(it).HasValue = .HasValue
            var(it).HasSet = .HasSet
            var(it).HasStrValue = .HasStrValue
            var(it).HasParameters = .HasParameters
            var(it).HasParametersSet = .HasParametersSet
            Set var(it).Events = .Events
            var(it).highpriorityoper = .highpriorityoper
            var(it).HasUnary = .HasUnary
        End With
        var(it).IamRef = Len(bstack.UseGroupname) > 0
    End If
    If var(I).HasStrValue Then
        globalvar what$ + "$", it, True
    End If
            
        
End Sub
Function ExecCode(basestack As basetask, rest$) As Boolean ' experimental
' ver .001
Dim p As Variant, mm As MemBlock, w2 As Long, usehandler As mHandler
    If IsExp(basestack, rest$, p) Then
        If Not basestack.lastobj Is Nothing Then
          If Not TypeOf basestack.lastobj Is mHandler Then
            Set basestack.lastobj = Nothing
            Exit Function
            End If
            Set usehandler = basestack.lastobj
            With usehandler
                  If Not TypeOf .objref Is MemBlock Then
                      Set basestack.lastobj = Nothing
                      Exit Function
                  ElseIf .objref.NoRun Then
                       Set basestack.lastobj = Nothing
                       Exit Function
                  End If
            End With
            Set mm = usehandler.objref
            Set usehandler = Nothing
            If mm.status = 0 Then
            w2 = mm.GetPtr(0)
            If FastSymbol(rest$, ",") Then
            If Not IsExp(basestack, rest$, p) Then
                Set basestack.lastobj = Nothing
                Set mm = Nothing
                MissPar
                Exit Function
            End If
            If p < 0 Or p >= mm.SizeByte Then
                Set basestack.lastobj = Nothing
                Set mm = Nothing
                MyEr "Offset out of buffer", "Äéåýèõíóç åêôüò äéÜñèñùóçò"
                Exit Function
            End If
            SetUpForExecution w2, mm.SizeByte
            w2 = cUlng(uintnew(w2) + p)
            End If
            Set basestack.lastobj = Nothing
            Dim what As Long
            Set ExecBaseStack = basestack
            ExecHere$ = here$
            what = CallWindowProc(w2, 0&, 0&, 0&, 0&)
            here$ = ExecHere$
            Set ExecBaseStack = Nothing
            If what <> 0 Then MyEr "Error " & what, "ËÜèïò " & what
                ReleaseExecution w2, mm.SizeByte
                ExecCode = what = 0
                Set mm = Nothing
            End If
        End If
    End If
    Set basestack.lastobj = Nothing
End Function
Sub MyMode(Scr As Object)
Dim x1 As Long, y1 As Long
On Error Resume Next
With players(GetCode(Scr))
    x1 = Scr.Width
    y1 = Scr.Height
    If Left$(Typename(Scr), 3) = "Gui" Then
    Else
    If Scr.Name = "Form1" Then
    DisableTargets q(), -1
    
    ElseIf Scr.Name = "DIS" Then
    DisableTargets q(), 0
    
    ElseIf Scr.Name = "dSprite" Then
        DisableTargets q(), val(Scr.Index)
    ElseIf val("0" + Scr.Tag) > 32 Then
        Scr.ClearTargets
    End If
    End If
    If .SZ < 4 Then .SZ = 4
        Err.Clear
        Scr.Font.Size = .SZ
        If Err.Number > 0 Then
                MyFont = "ARIAL"
                Scr.Font.Name = MyFont
                Scr.Font.charset = .charset
                Scr.Font.Name = MyFont
                Scr.Font.charset = .charset
        End If
        .uMineLineSpace = .MineLineSpace
        FrameText Scr, .SZ, x1, y1, .Paper
    .currow = 0
    .curpos = 0
    .XGRAPH = 0
    .YGRAPH = 0
End With
End Sub
Function ProcSave(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pa$, W$, s$, Col As Long, prg$, x1 As Long, par As Boolean, I As Long, noUse As Long, lcl As Boolean
Dim askme As Boolean, K As Long, M As Long
If lckfrm <> 0 Then MyEr "Save is locked", "Ç áðïèÞêåõóç åßíáé êëåéäùìÝíç": rest$ = vbNullString: Exit Function
lcl = IsLabelSymbolNew(rest$, "ÔÏÐÉÊÁ", "LOCAL", Lang) Or basestack.IamChild Or basestack.IamAnEvent

x1 = IsLabelFileName(basestack, rest$, W$)
If x1 = 1 Then
    SwapStrings pa$, W$
Else
    x1 = IsStrExp(basestack, rest$, pa$, False)
End If

If x1 <> 0 Then
        If subHash.count = 0 Or pa$ = vbNullString Then MyEr "Nothing to save", "Äåí õðÜñ÷åé êÜôé íá óþóù":              Exit Function
        If ExtractType(pa$) = "gsb1" Then
            MyEr "Recovery Mode (file is a gsb1 type): use another name or set type to gsb", "ÊáôÜóôáóç ÁíÜêôçóçò (o ôýðïò áñ÷åßïõ åßíáé gsb1): ÷ñçóéìïðïßçóå Üëëï üíïìá ÷ùñßò ôýðï, Þ ôýðï gsb"
            Exit Function
        End If

        If ExtractType(pa$) = "gsb" Then pa$ = ExtractPath(pa$) + ExtractNameOnly(pa$, True)
        If ExtractPath(pa$, True) <> "" Then
                If InStr(ExtractPath(pa$, True), mcd) <> 1 Then pa$ = pa$ + ".gsb" Else pa$ = pa$ + ".gsb"
        Else
                pa$ = mcd + pa$ + ".gsb"
        End If
        If Not WeCanWrite(pa$) Then Exit Function
        
      
           For I = subHash.count - 1 To 0 Step -1
       subHash.ReadVar I, s$, Col
       If Not Len(sbf(Col).sbgroup) > 0 Then
       
                If Right$(s$, 2) = "()" Then
                If Not InStr(s$, ChrW(&H1FFF)) > 0 Then
                s$ = Left$(s$, Len(s$) - 2)
                
                If Right$(sbf(Col).sb, 2) <> vbCrLf Then sbf(Col).sb = sbf(Col).sb + vbCrLf
                If Lang Then
                
                                If Not blockCheck(sbf(Col).sb, DialogLang, noUse, "Function " + s$ + "()" + vbCrLf) Then Exit Function
                                If sbf(Col).IamAClass Then

                                K = InStr(sbf(Col).sb, vbCrLf)
                                M = rinstr(sbf(Col).sb, vbCrLf + vbCrLf)
                                K = InStr(K + 1, sbf(Col).sb, "{")
                                prg$ = "CLASS " + Left$(sbf(Col).goodname, Len(sbf(Col).goodname) - 2) + " {" + Mid$(sbf(Col).sb, K + 3, M - K - 3) + vbCrLf + prg$
                               
                               
                                Else
                                prg$ = s$ + " {" + sbf(Col).sb + "}" + vbCrLf + prg$
                                If lcl Then
                                    prg$ = "FUNCTION " + prg$
                                Else
                                    prg$ = "FUNCTION GLOBAL " + prg$
                                End If
                                End If
                        Else
                                If Not blockCheck(sbf(Col).sb, DialogLang, noUse, "ÓõíÜñôçóç " + s$ + "()" + vbCrLf) Then Exit Function
                                If sbf(Col).IamAClass Then
                                K = InStr(sbf(Col).sb, vbCrLf)
                                M = rinstr(sbf(Col).sb, vbCrLf + vbCrLf)
                                K = InStr(K + 1, sbf(Col).sb, "{")
                                prg$ = "ÊËÁÓÇ " + Left$(sbf(Col).goodname, Len(sbf(Col).goodname) - 2) + " {" + Mid$(sbf(Col).sb, K + 3, M - K - 3) + vbCrLf + prg$
                                Else
                                prg$ = s$ + " {" + sbf(Col).sb + "}" + vbCrLf + prg$
                                If lcl Then
                                    prg$ = "ÓÕÍÁÑÔÇÓÇ " + prg$
                                Else
                                    prg$ = "ÓÕÍÁÑÔÇÓÇ ÃÅÍÉÊÇ " + prg$
                                End If
                                End If
                        End If
                End If
                Else
                        If Right$(sbf(Col).sb, 2) <> vbCrLf Then sbf(Col).sb = sbf(Col).sb + vbCrLf
                        If Lang Then
                                If Not blockCheck(sbf(Col).sb, DialogLang, noUse, "Module " + s$ + vbCrLf) Then Exit Function
                                prg$ = s$ + " {" + sbf(Col).sb + "}" + vbCrLf + prg$
                                If lcl Then
                                    prg$ = "MODULE " + prg$
                                Else
                                    prg$ = "MODULE GLOBAL " + prg$
                                End If
                        Else
                                If Not blockCheck(sbf(Col).sb, DialogLang, noUse, "ÔìÞìá " + s$ + vbCrLf) Then Exit Function
                                prg$ = s$ + " {" + sbf(Col).sb + "}" + vbCrLf + prg$
                                If lcl Then
                                    prg$ = "ÔÌÇÌÁ " + prg$
                                Else
                                    prg$ = "ÔÌÇÌÁ ÃÅÍÉÊÏ " + prg$
                                End If
                        End If
                End If
        End If
        Next I
        W$ = vbNullString
        If FastSymbol(rest$, "@@", , 2) Then
            ' default password  - one space only - coder use default internal password
                If Not IsStrExp(basestack, rest$, W$) Then W$ = " "
        ElseIf FastSymbol(rest$, "@") Then
                ' One space only
                W$ = " "
        End If
        par = False
        If FastSymbol(rest$, ",") Then
                If Abs(IsLabel(basestack, rest$, s$)) = 1 Then
                        prg$ = prg$ + s$
                ElseIf FastSymbol(rest$, "{") Then
                        prg$ = prg$ + block(rest$)
                        If Not FastSymbol(rest$, "}") Then Exit Function
                End If
        End If
        ' reuse s$, col$
        If Len(W$) > 1 Then  'scrable col by George
                s$ = vbNullString: For Col = 1 To Int((33 * Rnd) + 1): s$ = s$ + Chr(65 + Int((23 * Rnd) + 1)): Next Col
                ' insert a variable length label......to make a variable length file
                prg$ = s$ + ":" + vbCrLf + prg$
                prg$ = mycoder.encryptline(prg$, W$, Len(prg$) Mod 33)
                par = True
        ElseIf Len(W$) = 1 Then   ' I have to check that...
                s$ = vbNullString:   For Col = 1 To Int((33 * Rnd) + 1): s$ = s$ + Chr(65 + Int((23 * Rnd) + 1)): Next Col
                prg$ = s$ + ":" + vbCrLf + prg$
                prg$ = mycoder.must1(prg$)
                par = True
        End If
        s$ = vbNullString

        If Not WeCanWrite(pa$) Then Exit Function
       ' If CFname(pa$) <> "" Then
        If par Then
        If Not SaveUnicode(pa$ + "1", prg$, 0) Then BadFilename: Exit Function
        Else
        If Not SaveUnicode(pa$ + "1", prg$, 2) Then BadFilename: Exit Function
        End If
        ProcTask2 Basestack1
        If CFname(ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".gsb") <> "" Then
            If CFname(ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1") <> "" Then
                KillFile ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1"
            End If
            RenameFile2 pa$, ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1"
            askme = True
        End If
     ProcTask2 Basestack1
     
        If askme Then
                
                If Lang = 1 Then
                        If MsgBoxN("Replace " + ExtractNameOnly(pa$, True), vbOKCancel, MesTitle$) <> vbOK Then
nogood:
                        If CFname(pa$ + "1") <> "" Then
                            KillFile pa$ + "1"
                        End If
                        RenameFile2 ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1", ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".gsb"
                        MyEr "File not saved -1005", "Äåí óþèçêå ôï áñ÷åßï -1005"
                        ProcSave = True
                        Exit Function
                        Else
                        Check2SaveModules = False
                        End If
                Else
                        If MsgBoxN("ÁëëáãÞ " + ExtractNameOnly(pa$, True), vbOKCancel, MesTitle$) <> vbOK Then
                        GoTo nogood
                        Else
                        Check2SaveModules = False
                        End If
                End If
                s$ = "*"
        End If
        If par Then
                If s$ = "*" Then
                        MakeACopy ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1", ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck"
                        KillFile ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1"
                End If
                RenameFile2 pa$ + "1", pa$
                Check2SaveModules = False
        Else
                If s$ <> "" Then
                        MakeACopy ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1", ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck"
                        KillFile ExtractPath(pa$) + ExtractNameOnly(pa$, True) + ".bck1"
                End If
                RenameFile2 pa$ + "1", pa$
                If here$ = vbNullString Then LASTPROG$ = pa$
                Check2SaveModules = False
        End If
 ProcSave = True
Else
MyEr "A name please or use Ctrl+A to perform SAVE COMMAND$  (the last loading)", "¸íá üíïìá ðáñáêáëþ, Þ ðÜôá ôï ctrl+Á ãéá íá áðïèçêåýóåéò ìå ôï üíïìá ôïõ ðñïãñÜììáôïò ðïõ öïñôþèçêå ôåëåõôáßá"
End If

End Function
Sub ProcChooseFont(bstack As basetask, Lang As Long)
If Form4Loaded Then
If Form4.Visible Then
Form4.Visible = False
    If Form1.TEXT1.Visible Then
        Form1.TEXT1.SetFocus
    Else
        Form1.SetFocus
    End If
End If
End If
DialogSetupLang Lang
With bstack.Owner
    ReturnFontName = .Font.Name
    ReturnBold = .Font.bold
    ReturnItalic = .Font.Italic
    ReturnSize = CSng(.Font.Size)
    ReturnCharset = .Font.charset
End With
FeedFont2Stack bstack, OpenFont(bstack)

End Sub


Function ProcMode(bstack As basetask, rest$) As Boolean
Dim Scr As Object, p As Variant, x1 As Long, y1 As Long
Dim prive As Long, gui As GuiM2000
ProcMode = True
'' Kform is global
Kform = True
On Error Resume Next
Set Scr = bstack.Owner
With players(GetCode(Scr))
If .double Then SetNormal Scr
.UseDouble = 0
x1 = Scr.Width
y1 = Scr.Height
If Scr.Name = "GuiM2000" Then
    Set gui = Scr
    gui.SkipAutoPos = True
    gui.DisAllTargets
    Else
If Scr.Name = "Form1" Then
DisableTargets q(), -1

ElseIf Scr.Name = "DIS" Then
DisableTargets q(), 0

ElseIf Scr.Name = "dSprite" Then
DisableTargets q(), val(Scr.Index)
End If
End If
If IsExp(bstack, rest$, p) Then
If bstack.toprinter Then
If prFactor = 0 Then
prFactor = 1
End If
.SZ = CSng(p) * szFactor
Else
.SZ = CSng(p)
End If
If .SZ < 4 Then .SZ = 4
If Not bstack.toprinter Then
If FastSymbol(rest$, ",") Then
    If IsExp(bstack, rest$, p) Then x1 = CLng(p): y1 = CLng(x1 * ScrInfo(Console).Height / ScrInfo(Console).Width)
    If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, p) Then y1 = CLng(p)
        
    End If
ElseIf FastSymbol(rest$, ";") Then
prive = GetCode(bstack.Owner)
.mysplit = 0
Scr.Font.Size = .SZ
       SetText Scr
        GetXYb Scr, players(prive), .curpos, .currow

Set Scr = Nothing
Exit Function
End If
Else
'.SZ = .SZ * 3
End If
Err.Clear
Scr.Font.Size = .SZ
If Err.Number > 0 Then

MyFont = "ARIAL"
Scr.Font.Name = MyFont
Scr.Font.charset = bstack.myCharSet
Scr.Font.Name = MyFont
Scr.Font.charset = bstack.myCharSet
End If
.SZ = Scr.Font.Size
     .uMineLineSpace = .MineLineSpace
    
 FrameText Scr, .SZ, x1, y1, .Paper
 
    Else
    ProcMode = False
    Exit Function
    End If
    .currow = 0
    .curpos = 0
    .XGRAPH = 0
    .YGRAPH = 0
End With
Set Scr = Nothing

End Function



Function Infinity() As Double
PutMem1 VarPtr(Infinity) + 7, &H7F
PutMem1 VarPtr(Infinity) + 6, &HF0
End Function
Function ProcAssert(basestack As basetask, rest$) As Boolean
Dim p, Final, Pos&, opos&, pos1&, skip As Boolean, Mes$, fin$, haveerrors As Boolean
Pos = 1
skip = Not escok
opos = Pos
aheadstatusANY rest$, Pos
ProcAssert = True
If Pos = opos Then Exit Function
If Not skip Then
Mes$ = Mid$(rest$, opos, Pos - opos)
MyEr "", ""
Do
    opos = Pos - Len(Mes$)
    pos1 = 1
    aheadstatus Mes$, False, pos1
    pos1 = Pos - pos1
    If Not IsExp(basestack, Mes$, p, flatobject:=True, nostring:=True) Then
        p = 0
    End If
    If p = 0 Then
        If Len(fin$) = 0 Then
        fin$ = MyTrim(Mid$(rest$, opos, Pos - pos1 - 1))
        Else
        fin$ = fin$ + ", " + MyTrim(Mid$(rest$, opos, Pos - pos1 - 1))
        End If
    End If
    If LastErNum <> 0 Then
        Mes$ = Right$(Mes$, pos1 - opos + 1)
        haveerrors = True
        LastErNum = 0
    End If
Loop While FastSymbol(Mes$, ",")
If Len(fin$) > 0 Then MyEr "Assert :" + fin$, "Áîßùóç:" + fin$
ProcAssert = Not (haveerrors Or LastErNum)
End If
rest$ = Mid$(rest$, Pos)
End Function
Function ProcAbout(basestack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, s$, ss$, X As Double, Y As Double, I As Long
Dim kk As New Document
Dim UAddPixelsTop As Long  ' just not used
If IsLabelSymbolNewExp(rest$, "ÄÅÉÎÅ", "SHOW", Lang, ss$) Then
    If lastAboutHTitle <> "" Then abt = True: vH_title$ = vbNullString
        If IsStrExp(basestack, rest$, ss$, False) Then
            feedback$ = ss$
            feednow$ = FeedbackExec$
            CallGlobal feednow$
        Else
            vHelp
        End If
        ProcAbout = True
        Exit Function
ElseIf FastSymbol(rest$, "!") Then
    vH_title$ = vbNullString
    par = IsStrExp(basestack, rest$, s$, False)
    If par Then
            If s$ = vbNullString Then
                mHelp = False
                abt = False
                lastAboutHTitle = vbNullString
                sHelp "", "", 0, 0
                GoTo conthere
            Else
                par = par And FastSymbol(rest$, ",")
                par = par And IsExp(basestack, rest$, X)
                par = par And FastSymbol(rest$, ",")
                par = par And IsExp(basestack, rest$, Y)
                par = par And FastSymbol(rest$, ",")
                par = par And IsStrExp(basestack, rest$, ss$)
                If par Then
                    abt = True
                    kk.EmptyDoc
                    kk.textDoc = ReplaceSpace(s$)
                    s$ = kk.textFormat(vbCrLf)
                    kk.EmptyDoc
                    kk.textDoc = ReplaceSpace(s$)
                    s$ = kk.TextParagraph(1)
                    kk.EmptyDoc
                    kk.textDoc = ReplaceSpace(ss$)
                    ' save to
                    lastAboutHTitle = s$
                    LastAboutText = kk.textFormat(vbCrLf)
                    sHelp lastAboutHTitle, LastAboutText, CLng(X), CLng(Y)
                End If
            End If
        End If
    ElseIf IsLabelSymbolNew(rest$, "ÊÁËÅÓÅ", "CALL", Lang) Then
        mHelp = True
        abt = True
        If IsStrExp(basestack, rest$, ss$, False) Then
            kk.textDoc = ReplaceSpace(ss$)
            FeedbackExec$ = kk.textFormat(vbCrLf)
        End If
    Else
        If IsStrExp(basestack, rest$, s$, False) Then
            mHelp = True
            If s$ = vbNullString Then
                If Lang = 0 Then
                    lastAboutHTitle = "ÂïÞèåéá ÅöáñìïãÞò"
                    LastAboutText = vbNullString
                Else
                    lastAboutHTitle = "Application Help"
                    LastAboutText = vbNullString
                End If
                GoTo conthere
            End If
            kk.EmptyDoc
            kk.textDoc = ReplaceSpace(s$)
            s$ = kk.textFormat(vbCrLf)
            kk.EmptyDoc
            kk.textDoc = ReplaceSpace(s$)
            s$ = kk.TextParagraph(1)
            I = 0
            X = (ScrInfo(Console).Width - 1) * 2 / 5
            Y = (ScrInfo(Console).Height - 1) / 7
            vH_title$ = s$
            If FastSymbol(rest$, ",") Then
                par = True
                If Not IsExp(basestack, rest$, X) Then
                    X = (ScrInfo(Console).Width - 1) * 2 / 5: par = False
                Else
                    I = 1
                End If
                If FastSymbol(rest$, ",") Then
                    par = True
                    If Not IsExp(basestack, rest$, Y) Then
                        Y = (ScrInfo(Console).Height - 1) / 7: par = False
                    Else
                        I = 2
                    End If
                End If
            End If
            If Not Form4.Visible Then
                Helplastfactor = 1
                helpSizeDialog = 1
                vH_x = CLng(X * Helplastfactor)
                vH_y = CLng(Y * Helplastfactor)
                If Screen.ActiveForm Is Nothing Then
                    Form4.Show
                Else
                    If Screen.ActiveForm.Name = "MyPopUp" Then
                        Form4.Show , Form1
                    Else
                    Form4.Show , Screen.ActiveForm
                End If
            End If
            myform Form4, ScrInfo(Console).Width - CLng(X * Helplastfactor), ScrInfo(Console).Height - CLng(Y * Helplastfactor), CLng(X * Helplastfactor), CLng(Y * Helplastfactor), True, 1  'Helplastfactor
            MoveFormToOtherMonitorOnly Form4, True
            HelpLastWidth = X
            GoTo there
        ElseIf I <> 0 Then
            If Screen.ActiveForm Is Nothing Then
                Form4.Show
            ElseIf Form4 Is Screen.ActiveForm Then
                Form4.Show
            Else
                Form4.Show , Screen.ActiveForm
            End If
            myform Form4, Form4.Left, Form4.top, CLng(X * Helplastfactor), CLng(Y * Helplastfactor), True, Helplastfactor
            MoveFormToOtherMonitorOnly Form4
            GoTo there
        End If
        Form4.Hide
        If Screen.ActiveForm Is Nothing Then
            Form4.Show
        ElseIf Form4 Is Screen.ActiveForm Then
            Form4.Show
        Else
            Form4.Show , Screen.ActiveForm
        End If
there:
        Form4.Line (0, 0)-(Form4.ScaleWidth - dv15, Form4.ScaleHeight - dv15), Form4.BackColor, BF
        Form4.moveMe
        If FastSymbol(rest$, ",") Or Not par Then
            If IsStrExp(basestack, rest$, ss$) Then
                kk.EmptyDoc
                kk.textDoc = ReplaceSpace(ss$)
                Form4.label1.Text = kk.textFormat(vbCrLf)
            End If
        End If
        With Form4.label1
            .EditDoc = False
            .NoMark = True
            .enabled = True
            .NewTitle s$, 4 + UAddPixelsTop
            .glistN.DragEnabled = False
            .glistN.WordCharLeft = "["
            .glistN.WordCharRight = "]"
            .glistN.WordCharRightButIncluded = vbNullString
        End With
    Else
conthere:
        If Not (basestack.IamChild Or basestack.IamAnEvent) Then
            abt = False
        End If
        If Form4Loaded Then
            If Form4.Visible Then
                Form4.Visible = False
                If Form1.Visible Then
                    If Form1.TEXT1.Visible Then
                        Form1.TEXT1.SetFocus
                    Else
                        Form1.SetFocus
                    End If
                End If
            End If
            Helplastfactor = 1
            helpSizeDialog = 1
            Unload Form4
        End If
    End If
End If
Exit Function
End Function
Function ProcRemove(basestack As basetask, rest$, Lang As Long) As Boolean
Dim ss$
ProcRemove = True
If IsLabelSymbolNew(rest$, "ÁÄÅÉÁÓ", "LICENSE", Lang) Then
If IsStrExp(basestack, rest$, ss$) Then
Licenses.Remove ss$
Else
MissStringExpr
End If
Else
If IsStrExp(basestack, rest$, ss$) Then
RemoveDll ss$
ElseIf sb2used <= basestack.OriginalCode And basestack.OriginalCode <> 0 Then
MyEr "Can't Remove Last Module/Function", "Äåí ìðïñþ íá äéáãñÜøù ôï ôåëåõôáßï ôìÞìá/óõíÜñôçóç"
ProcRemove = False
Else
If basestack.IamChild Or basestack.IamAnEvent Or basestack.IamThread Or HaltLevel > 0 Then Exit Function
If sb2used > 0 Then
If MsgBoxN(IIf(pagio$ <> "GREEK", "Remove last module/function", "Íá äéáãñÜøù ôï ôåëåõôáßï ôìÞìá") + vbCrLf + sbf(subHash.count).goodname, 1) = 1 Then


If subHash.count > 0 Then subHash.ReduceHash subHash.count - 1, sbf()
    If UBound(sbf()) / 2 > sb2used And UBound(sbf()) > 19 Then
       ReDim Preserve sbf(UBound(sbf()) / 2 + 1) As modfun
         
    End If
    sb2used = sb2used - 1

If lckfrm <> 0 Then
If lckfrm > sb2used Then lckfrm = 0

End If
End If
End If

End If
End If
End Function
Function BreakMes() As String
If Check2SaveModules Then
If pagio$ = "GREEK" Then
BreakMes = "ÄéáêïðÞ êáé Åðáíåêêßíçóç" + vbCrLf + "Ðñïóï÷Þ õðÜñ÷ïõí ìç áðïèçêåõìÝíåò áëëáãÝò ðïõ èá ÷áèïýí"
Else
BreakMes = "Break Key - Hard Reset" + vbCrLf + "Warning, changes lost"
End If
Else
If pagio$ = "GREEK" Then
BreakMes = "ÄéáêïðÞ êáé Åðáíåêêßíçóç"
Else
BreakMes = "Break Key - Hard Reset"
End If
End If
End Function
Function Check2Save() As Boolean
If Check2SaveModules Then
Check2Save = MsgBoxN(IIf(pagio$ = "GREEK", "Ðñïóï÷Þ õðÜñ÷ïõí ìç áðïèçêåõìÝíåò áëëáãÝò ðïõ èá ÷áèïýí", "Warning, changes lost"), 1, IIf(pagio$ = "GREEK", "Ôåñìáôéóìüò ÄéåñìçíåõôÞ", "Quit Interpreter")) <> 1
Else
Check2Save = False
End If

End Function
Function IsCtime(bstack As basetask, A$, r As Variant) As Boolean
Dim par As Boolean, R2 As Variant, R3 As Variant, R4 As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
  
    r = Abs(r)
    par = True
    If FastSymbol(A$, ",") Then
    par = IsExp(bstack, A$, R2, , True)
    If FastSymbol(A$, ",") Then
    par = IsExp(bstack, A$, R3, , True) And par
    If FastSymbol(A$, ",") Then
    par = IsExp(bstack, A$, R4, , True) And par
    End If
    End If
    End If
    
       If Not par Then
     MissParam A$
     Exit Function
                End If
                On Error Resume Next
    R3 = R3 + (R2 - Int(R2)) * 60
    R2 = Int(R2)
    R4 = R4 + (R3 - Int(R3)) * 60
    R3 = Int(R3)
    r = TimeSerial(Hour(CDate(r)) + R2, Minute(CDate(r)) + R3, Second(CDate(r)) + R4) + CDate(Int(Abs(r)))
    
                If Err.Number > 0 Then
    WrongArgument A$
    Err.Clear
    Exit Function
    End If
    On Error GoTo 0
     IsCtime = FastSymbol(A$, ")", True)
      Else
   
     MissParam A$
    End If
End Function
Function IsRecords(bstack As basetask, A$, r As Variant) As Boolean
Dim VR As Long
    IsSymbol3 A$, "#"
    If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
        VR = CLng(r)
        If Fstep(VR) = 0 Then
            wrongfilenumber A$
        Else
            r = myLof2(VR) / CCur(Fstep(VR))
            
            IsRecords = FastSymbol(A$, ")", True)
        End If
    Else
        MissParam A$
    End If
End Function
Function RemoveGuiArray(bstack As basetask, where As Long, what$) As Boolean
    Dim ppppL As iBoxArray, pppp As mArray
    'what$ = Left$(what$, Len(what$) - 1)
    If neoGetArray(bstack, what$, ppppL, here$ <> "") Then
        If TypeOf ppppL Is mArray Then
            Set pppp = ppppL
            Set ppppL = Nothing
        Else
            GoTo err010
        End If
        If Not pppp.IHaveGui Then
err010:
            MyEr "Not a Gui Control Array " + what$ + "()", "Äåí åßíáé ðßíáêáò óôïé÷åßùí " + what$ + "()"
            Exit Function
        End If
        Dim Max As Long, CTR As IControlIndex, I As Long, dummy As Long
        Max = pppp.count - 1
        If where >= 0 And where <= Max Then
            If pppp.ItemIsObject(where) Then
                Set CTR = pppp.item(where)
                CTR.UnloadMe
                For I = where + 1 To Max
                    If pppp.ItemIsObject(I) Then
                        Set CTR = pppp.item(I)
                        CTR.Index = CTR.Index - 1
                        Set pppp.item(I - 1) = pppp.item(I)
                    Else
                            InternalError
                            Exit Function
                    End If
                Next I
                If Max < 1 Then
                    Set pppp.item(where) = Nothing
                    pppp.SerialItem dummy, -1, 8
                Else
                    If pppp.ItemIsObject(Max) Then
                        Set pppp.item(Max) = Nothing
                    End If
                    pppp.SerialItem dummy, Max + 1, 9
                End If
                RemoveGuiArray = True
            Else
                InternalError
                Exit Function
            End If
        ElseIf where = -1 And Max > 0 Then
            For I = 0 To Max - 1
                Set CTR = pppp.item(I)
                CTR.UnloadMe
                Set pppp.item(I) = Nothing
            Next I
            pppp.SerialItem dummy, -1, 8
            RemoveGuiArray = True
        Else
            errOutOfLimit
        End If
    Else
    ' error
        MyEr "Array not exist " + what$ + "()", "Äåí õðÜñ÷åé áõôüò ï ðßíáêáò" + what$ + "()"
    End If
    
End Function
Function ExpandGui(bstack As basetask, what$, rest$, ifier As Boolean, Lang As Long, oName As String)
Dim pppp As mArray, aVar As Variant, h$
 Dim I As Long
'' add new GuiItems but not visible
what$ = Left$(what$, Len(what$) - 1)
 If neoGetArray(bstack, oName$, pppp, here$ <> "") Then
 
 If Not (pppp.IHaveGui Or pppp.comevents) Then
 MyEr "Only for Gui controls or Com objects with events", "Ìüíï ãéá óôïé÷åßá äéåðáöÞò Þ ãéá áíôéêåßìåíá COM ìå ãåãïíüôá"
 ifier = False: Exit Function
  End If
 I = pppp.UpperMonoLimit + 1
 pppp.SerialItem 0, I + 2, 9
  

  On Error Resume Next
  Select Case pppp.ItemType(0)
    Case "GuiM2000"
        CreateFormObject aVar, 1
        Set pppp.item(I) = aVar
        Dim aaa As GuiM2000, aa0 As GuiM2000
        Set aaa = aVar
        Set aa0 = pppp.item(0)
        With aa0
        Set aaa.EventObj = .EventObj
        h$ = .modulename
        End With
        
        With aaa
        .myname = what$
        .modulename = h$
        .TempTitle = what$ & "(" & (I) & ")"
        .Index = I
        End With
        Set aaa = Nothing
        Set aa0 = Nothing
    Case "GuiButton"
        CreateFormObject aVar, 2
        
        Set pppp.item(I) = aVar
        Dim aaa1 As GuiButton, aaa11 As GuiButton
        Set aaa1 = pppp.item(0)
        Set aaa11 = aVar
        Set aaa = aaa1.GetCallBack
        With aaa11
        .ConstructArray aaa, what$, I
        .move 0, 2000, 6000, 600
        .Caption = what$ & "(" & (I) & ")"
        .SetUp
         Set aaa.Controls(.ctrlName).Container = aaa.Controls(aaa1.ctrlName).Container
        End With
    Case "GuiTextBox"
        CreateFormObject aVar, 3
        Set pppp.item(I) = aVar
        Dim aaa2 As GuiTextBox, aaa22 As GuiTextBox
        Set aaa2 = pppp.item(0)
        Set aaa22 = aVar
        Set aaa = aaa2.GetCallBack
        With aaa22
        .ConstructArray aaa, what$, I
        .move 0, 2000, 6000, 600
        .SetUp
        .Text = what$ & "(" & (I) & ")"
        Set aaa.Controls(.ctrlName).Container = aaa.Controls(aaa2.ctrlName).Container
        End With
        
    Case "GuiCheckBox"
        CreateFormObject aVar, 4
        Set pppp.item(I) = aVar
        Dim aaa3 As GuiCheckBox, aaa33 As GuiCheckBox
        Set aaa3 = pppp.item(0)
        Set aaa33 = aVar
        Set aaa = aaa3.GetCallBack
        With aVar
        .ConstructArray aaa3, what$, I
        .move 0, 2000, 6000, 600
        .Caption = what$ & "(" & (I) & ")"
        .SetUp
        Set aaa.Controls(.ctrlName).Container = aaa.Controls(aaa3.ctrlName).Container
        End With
    
    Case "GuiEditBox"
        CreateFormObject aVar, 5
        Set pppp.item(I) = aVar
        Dim aaa4 As GuiEditBox, aaa44 As GuiEditBox
        Set aaa4 = pppp.item(0)
        Set aaa = aaa4.GetCallBack
        Set aaa44 = aVar
        With aaa44
        .ConstructArray aaa, what$, I
        .move 0, 2000, 6000, 1200
        
        If aaa.prive <> 0 Then
        .LineSpace = players(aaa.prive).uMineLineSpace
        Else
        .LineSpace = players(0).uMineLineSpace
        End If
        .SetUp
        .Text = what$ & "(" & (I) & ")"
        Set aaa.Controls(.ctrlName).Container = aaa.Controls(aaa4.ctrlName).Container
        End With
        Set aaa = Nothing
Case "GuiImage"
        CreateFormObject aVar, 8
        Set pppp.item(I) = aVar
        Dim aaai4 As GuiImage, aaai44 As GuiImage
        Set aaai4 = pppp.item(0)
        Set aaa = aaa4.GetCallBack
        Set aaai44 = aVar
                With aaai44
        .ConstructArray aaa, what$, I
        .move 0, 2000, 6000, 1200
        .SetUp
        .Text = what$ & "(" & (I) & ")"
        Set aaa.Controls(.ctrlName).Container = aaa.Controls(aaai4.ctrlName).Container
        End With
        Set aaa = Nothing
    Case "GuiListBox"
        CreateFormObject aVar, 6
        Set pppp.item(I) = aVar
        Dim aaa5 As GuiListBox, aaa55 As GuiListBox
        Set aaa5 = pppp.item(0)
        Set aaa = aaa5.GetCallBack
        Set aaa55 = aVar
        With aaa55
        .ConstructArray aaa, what$, I
        .move 0, 2000, 6000, 600
        If aaa.prive <> 0 Then
        .LineSpace = players(aaa.prive).uMineLineSpace
        Else
        .LineSpace = players(0).uMineLineSpace
        End If
        .ListText = what$ & "(" & (I) & ")"
        .SetUp
        Set aaa.Controls(.ctrlName).Container = aaa.Controls(aaa5.ctrlName).Container
        End With
    Case "GuiDropDown"
        CreateFormObject aVar, 7
        Set pppp.item(I) = aVar
        Dim aaa6 As GuiDropDown, aaa66 As GuiDropDown
        Set aaa6 = pppp.item(0)
        Set aaa = aaa6.GetCallBack
        Set aaa66 = aVar
        With aaa66
        .ConstructArray aaa5.GetCallBack, what$, I
        .move 0, 2000, 6000, 600
        .SetUp
        Set aaa.Controls(.ctrlName).Container = aaa.Controls(aaa6.ctrlName).Container
        End With
    Case "Socket"
    Set aVar = New cTlsSocket
    Set pppp.item(pppp.count - 1) = aVar
    Case "SerialPort"
    Set aVar = New SerialPort
    Set pppp.item(pppp.count - 1) = aVar
    Case "ShellPipe"
    Set aVar = New ShellPipe
    Set pppp.item(pppp.count - 1) = aVar
    Case "cHttpDownload"
    Set aVar = New cHttpDownload
    Set pppp.item(pppp.count - 1) = aVar
    Case "CallBack2"
        Dim Aaaa As CallBack2
        Set Aaaa = pppp.item(pppp.count - 1)
        Set aVar = Aaaa.CopyOfMe
        Set pppp.item(pppp.count - 1) = aVar
    Case "ExtControl"
        Dim Aeee As ExtControl, Aeee1 As ExtControl
        Set Aeee = pppp.item(pppp.count - 1)
        CreateFormObject aVar, 9
        Set Aeee1 = aVar
        Set aaa = Aeee.GetCallBack
        I = Aeee.Index + 1
        Aeee1.Attach aaa.Controls.Add(Aeee.TypeDef, Aeee.ControlName & I), Aeee.ControlName, Aeee.TypeDef, aaa, I
        aaa.AddGuiControl Aeee1
        aaa.Controls(Aeee.ControlName & I).move 0, 2000, 6000, 600
                               
        Set aVar = Aeee1
        Set pppp.item(pppp.count - 1) = aVar
        Set aaa.Controls(Aeee.ControlName & I).Container = aaa.Controls(Aeee.ControlName & (I - 1)).Container
    Case Else
    ' any other com object
    
    End Select
    If pppp.comevents Then
    Dim pppp1 As mArray
    If neoGetArray(bstack, ChrW(&HFFBF) + "_" + what$ + "(", pppp1, True) Then
     I = pppp1.UpperMonoLimit + 1
    pppp1.SerialItem 0, I + 2, 9
    GetShinkArr2 pppp, pppp1, what$, (pppp1.count - 1), (pppp1.count)
    End If
    End If
ifier = True
End If
End Function

Function MyDeclare(bstack As basetask, rest$, Lang As Long, Optional groupok As Boolean, Optional prive As Boolean) As Boolean
Dim p As Variant, I As Long, s$, pa$
Dim x1 As Long, y1 As Long, par As Boolean, ss$, W$, what$, Y3 As Boolean, Y4 As Boolean
Dim declobj As Object, ML As Long
Dim dum As Boolean
Dim pppp As mArray, removecontrol As IControlIndex
Dim ii As Long, ev As ComShinkEvent
MyDeclare = True
ML = -1
If Not groupok Then y1 = IsLabelSymbolNewExp(rest$, "ÃÅÍÉÊÏ", "GLOBAL", Lang, ss$)
If Not y1 Then
    If Not groupok Then y1 = IsLabelSymbolNewExp(rest$, "ÔÏÐÉÊÏ", "LOCAL", Lang, ss$)
    If y1 Then y1 = y1 * -100: ss$ = vbNullString
End If
If Not groupok Then Y3 = IsLabelSymbolNewExp(rest$, "ÌÅÃÅÃÏÍÏÔÁ", "WITHEVENTS", Lang, ss$)
ss$ = vbNullString
x1 = Abs(innerIsLabel(bstack, rest$, what$, , True, True))
If Not groupok Then
    W$ = myUcase(what$, True)
ElseIf prive Then
    W$ = bstack.GroupName + ChrW(&HFFBF) + myUcase(what$, True)
Else
    W$ = bstack.GroupName + myUcase(what$, True)
End If
gohere:
If x1 = 1 Or x1 = 3 Then
    If x1 = 1 Then
    
        If GetVar(bstack, W$, I) And y1 = 0 Then
            If Y3 Then
                If TypeOf var(I) Is GuiM2000 Then
                    BadEvents
                    MyDeclare = False
                    Exit Function
                End If
                If GetShink(ev, I, W$) Then
                    If Not GetVar(bstack, ChrW(&HFFBF) + "_" + W$, ii) Then
                        ii = globalvarGroup(ChrW(&HFFBF) + "_" + W$, s$, , y1 = True)
                    End If
                    Set var(ii) = ev
                Else
                    BadEvents
                    MyDeclare = False
                End If
                Exit Function
            End If
            ss$ = vbNullString
            If IsLabelSymbolNewExp(rest$, "ÔÉÐÏÔÁ", "NOTHING", Lang, ss$) Then
                If ML >= 0 Then
goNothing:
                    If neoGetArray(bstack, W$, pppp) Then
                        ' no check for real array Why ?
                        For I = 0 To pppp.UpperMonoLimit
                            If MyIsObject(pppp.item(I)) Then
                                If pppp.ItemType(I) = "GuiM2000" Then
                                    Set declobj = pppp.item(I)
                                    Unload declobj
                                End If
                                Set pppp.item(I) = Nothing  ' special use
                            Else
                                pppp.item(I) = Empty
                            End If
                        Next I
                    Else
                        MyDeclare = False
                        Exit Function
                    End If
                ElseIf Not MyIsObject(var(I)) Then
                    If groupok Then
                        Set var(I) = Nothing
                    Else
                        BadObjectDecl
                        MyDeclare = False
                    End If
                Else
                    If var(I) Is Nothing Then Exit Function
                    If TypeOf var(I) Is GuiM2000 Then
                        var(I).CloseNow
                        Unload var(I)
                    Else
                        If GetVar(bstack, ChrW(&HFFBF) + "_" + W$, ii) Then
                            Set var(ii) = Nothing
                        End If
                    End If
                    Set var(I) = Nothing
                End If
                Exit Function
            ElseIf IsLabelSymbolNewExp(rest$, "ÍÅÏ", "NEW", Lang, ss$) Then
fornew:
               Set var(I) = Nothing
               GoTo THEREnew
            ElseIf IsLabelSymbolNewExp(rest$, "ÍÅÁ", "NEW", Lang, ss$) Then
               GoTo fornew
            ElseIf IsLabelSymbolNew(rest$, "ÄÉÁÃÑÁÖÇ", "REMOVE", Lang) Then
                If MyIsObject(var(I)) Then
                    If TypeOf var(I) Is IControlIndex Then
                         Set removecontrol = var(I)
                         removecontrol.UnloadMe
                         Set removecontrol = Nothing
                    End If
               End If
               Set var(I) = Nothing
                MyDeclare = True
               Exit Function
            Else
                If MyIsObject(var(I)) Then
                    If var(I) Is Nothing Then
                        GoTo THEREnew
                    End If
                End If
                
                BadObjectDecl
                MyDeclare = False
                Exit Function
            End If
        End If
    End If
    ss$ = vbNullString
    If IsLabelSymbolNewExp(rest$, "ÂÁÓÇ", "BASE", Lang, ss$) Then
        If Not IsStrExp(bstack, rest$, pa$) Then
            BadObjectDecl
            MyDeclare = False
            Exit Function
        End If
        If GetVar(bstack, W$, I) Then
            BadObjectDecl
            MyDeclare = False
            Exit Function
        End If
        If Not getone2(pa$, p) Then
            Set p = New Mk2Base
            PushOne pa$, p
        End If
        globalvar bstack.GroupName + W$, p, y1 = True
        MyDeclare = True
        Exit Function
    ElseIf IsLabelSymbolNewExp(rest$, "ÁÐÏ", "LIB", Lang, ss$) Then
        If y1 = 100 Then y1 = 0
        par = Fast2LabelNoNum(rest$, "C", 1, "", 0, 1)
        If IsStrExp(bstack, rest$, pa$) Then
            If Not IsStrExp(bstack, rest$, ss$) Then ss$ = vbNullString
            Do
                If FastSymbol(ss$, vbCrLf, , 2) Then
                    s$ = vbNullString
                Else
                    s$ = GetNextLine(ss$)
                    If Not MaybeIsSymbol(s$, "'\/") Then Exit Do
                End If
            Loop
            ss$ = s$ + CleanStr(ss$, vbCrLf)
            s$ = vbNullString
            I = AllocVar()
            Dim stdFunc As stdCallFunction
            Set stdFunc = New stdCallFunction
                    If IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then
                If Not IsExp(bstack, rest$, p) Then
                    BadObjectDecl
                    MyDeclare = False
                    Set stdFunc = Nothing
                    Exit Function
                Else
                    stdFunc.RetType = CLng(p)
                End If
            End If
            stdFunc.CallThis pa$, ss$, Lang
            If par Then stdFunc.CallType = 1
            Set var(I) = stdFunc
            s$ = W$
            If x1 = 3 Then
                If here$ = vbNullString Or y1 Then
                    y1 = GlobalSub(s$ + "()", "CALL EXTERN " & (I) & " : = LETTER$'" & ChrW(&H1FFD))
                Else
                    y1 = GlobalSub(here$ + "." + bstack.GroupName + s$ + "()", "CALL EXTERN " & (I) & " : = LETTER$'" & ChrW(&H1FFD))
                End If
            Else
                If here$ = vbNullString Or y1 Then
                    If stdFunc.RetType = 9 Or stdFunc.RetType = 13 Then
                    y1 = GlobalSub(s$ + "()", "CALL EXTERN " & (I) & " : = STACKITEM():DROP'" & ChrW(&H1FFD))
                    Else
                    y1 = GlobalSub(s$ + "()", "CALL EXTERN " & (I) & " : = NUMBER'" & ChrW(&H1FFD))
                    End If
                Else
                    If stdFunc.RetType = 9 Or stdFunc.RetType = 13 Then
                        y1 = GlobalSub(here$ + "." + bstack.GroupName + s$ + "()", "CALL EXTERN " & (I) & " : = STACKITEM() : DROP'" & ChrW(&H1FFD))
                    Else
                        y1 = GlobalSub(here$ + "." + bstack.GroupName + s$ + "()", "CALL EXTERN " & (I) & " : = NUMBER'" & ChrW(&H1FFD))
                    End If
                End If
            End If
            sbf(y1).sbc = I
            
            sbf(y1).locked = True
            Set stdFunc = Nothing
            Exit Function
        Else
            BadObjectDecl
            MyDeclare = False
            Set stdFunc = Nothing
            Exit Function
        End If
    ElseIf IsLabelSymbolNewExp(rest$, "ÌÅ", "USE", Lang, ss$) Then
        If Y3 <> 0 Then
            SyntaxError
            Exit Function
        End If
        x1 = Abs(IsLabel(bstack, rest$, pa$))
        IsSymbol3 rest$, ","
        If x1 = 1 Then
            If GetVar(bstack, pa$, x1) Then
                If MyIsObject(var(x1)) Then
                    I = globalvar(W$, s$, , y1 = True)
                    If IsStrExp(bstack, rest$, ss$) Then
                        Set var(I) = MakeObjectFromString(var(x1), ss$)
                    End If
                End If
            End If
        Else
            MissPar
            MyDeclare = False
        End If
        Exit Function
    End If
    If ML >= 0 Then
         If neoGetArray(bstack, W$, pppp, True) Then
            ArrayNameExist
            MyDeclare = False
            Exit Function
         Else
            x1 = -1
            GlobalArr bstack, W$ + "(", (ML) & ")", I, x1, , , CBool(y1)
            If DeclareGUI(bstack, what$, rest$, MyDeclare, Lang, (I), ML, W$, y1, Y3, x1) Then
                If Y3 And y1 = 0 Then
                    ii = -1
                    GlobalArr bstack, ChrW(&HFFBF) + "_" + W$ + "(", (ML) & ")", I, ii, , , CBool(y1)
                    If Not GetShinkArr(x1, ii, W$, 0, I) Then
                        BadEvents
                        MyDeclare = False
                    Else
                        var(x1).comevents = True
                    End If
                End If
                Exit Function
            End If
        End If
    Else
        I = globalvar(W$, s$, , y1 = True)
    End If
THEREnew:
MyDeclare = False
    Y4 = IsLabelSymbolNew(rest$, "ÐÁÑÅ", "GET", Lang)
    If Y4 And MaybeIsSymbol(rest$, ",") Then
        FastSymbol rest$, ","
        If IsStrExp(bstack, rest$, pa$) Then
            GetitObject var(I), , CVar(pa$)
        End If
        GoTo jump1
    ElseIf IsStrExp(bstack, rest$, s$) Then
        If FastSymbol(rest$, ",") Then
            If IsStrExp(bstack, rest$, pa$) Then
                If Y4 Then
                    On Error Resume Next
                    GetitObject var(I), CVar(s$), CVar(pa$)
                    If Err.Number > 0 Then Exit Function
                ElseIf FastSymbol(rest$, ",") Then
                    If IsStrExp(bstack, rest$, W$) Then
                        Err.Clear
                        On Error Resume Next
                        If W$ = vbNullString Then
                            Licenses.Add s$
                        Else
                            Licenses.Add s$, W$
                        End If
                        If Err.Number > 0 And Err.Number <> 732 Then
                            MissLicense
                            Err.Clear
                        Else
                            Err.Clear
                            CreateitObject var(I), s$, CVar(pa$)
                            If Err.Number > 0 Then
                                Err.Clear
                                MissLicense
                            End If
                        End If
                        Licenses.Remove s$
                    Else
                        MissStringExpr
                    End If
                Else
                    Err.Clear
                    On Error Resume Next
                    CreateitObject var(I), s$, CVar(pa$)
                    If Err.Number > 0 Then
                        Err.Clear
                        MissLicense
                    End If
                End If
            Else
                If FastSymbol(rest$, ",") Then
                    If IsStrExp(bstack, rest$, pa$) Then
                        Err.Clear
                        On Error Resume Next
                        If pa$ = vbNullString Then
                            Licenses.Add s$
                        Else
                            Licenses.Add s$, pa$
                        End If
                        If Err.Number > 0 And Err.Number <> 732 Then
                            MissLicense
                            Err.Clear
                        Else
                            Err.Clear
                            CreateitObject var(I), s$
                            If Err.Number > 0 Then
                                Err.Clear
                                MissLicense
                            End If
                        End If
                        Licenses.Remove s$
                    Else
                        MissStringExpr
                    End If
                Else
                    MissStringExpr
                    End If
                End If
            Else
                Err.Clear
                On Error Resume Next
                If Y4 Then
                    GetitObject var(I), CVar(s$)
                Else
                    CreateitObject var(I), s$
                End If
jump1:
                If Err.Number > 0 Then
                    Err.Clear
                    MissLicense
                ElseIf Y3 <> 0 Then
                    If GetShink(ev, I, W$) Then
                       ' private
                       ' no need for a name, we do not address it in any way.
                       ' ev knows how to call handler
                       If Not GetVar(bstack, ChrW(&HFFBF) + "_" + W$, ii) Then
                           ii = globalvarGroup(ChrW(&HFFBF) + "_" + W$, s$, , y1 = True)
                       End If
                       Set var(ii) = ev
                    Else
                       BadEvents
                       MyDeclare = False
                    End If
                End If
            End If
        ElseIf DeclareGUI(bstack, what$, rest$, MyDeclare, Lang, I, , , , Y3) Then
            If Y3 Then
                If Not MyIsObject(var(I)) Then
                    If Not GetVar(bstack, ChrW(&HFFBF) + "_" + W$, ii) Then
                        ii = globalvarGroup(ChrW(&HFFBF) + "_" + W$, s$, , y1 = True)
                    End If
                     var(ii) = Empty
                        GoTo exitHere
                ElseIf GetShink(ev, I, W$) Then
                    If Not GetVar(bstack, ChrW(&HFFBF) + "_" + W$, ii) Then
                        ii = globalvarGroup(ChrW(&HFFBF) + "_" + W$, s$, , y1 = True)
                    End If
                    Set var(ii) = ev
                End If
        End If
    End If
    Err.Clear
    On Error Resume Next
    If Not MyIsObject(var(I)) Then
        If groupok Then
            Set var(I) = Nothing
        Else
            BadObjectDecl
        End If
    End If
ElseIf x1 = 5 Then
    If FastSymbol(rest$, ")") Then
        If IsLabelSymbolNewExp(rest$, "ÔÉÐÏÔÁ", "NOTHING", Lang, ss$) Then GoTo goNothing
        If IsLabelSymbolNewExp(rest$, "ÐÁÍÙ", "OVER", Lang, ss$) Then
            ExpandGui bstack, what$, rest$, MyDeclare, Lang, W$
        ElseIf IsLabelSymbolNew(rest$, "ÄÉÁÃÑÁÖÇ", "REMOVE", Lang) Then
            If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
                ML = CLng(p)
                
                
            Else ' all
                ML = -1
            End If
            MyDeclare = RemoveGuiArray(bstack, ML, what$)
            Exit Function
        Else
            BadObjectDecl
        End If
    ElseIf IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
        ML = CLng(p)
        If FastSymbol(rest$, ")") Then
            x1 = 1
            W$ = Left$(W$, Len(W$) - 1)
            GoTo gohere
        Else
            BadObjectDecl
        End If
    Else
        BadObjectDecl
    End If
Else
    BadObjectDecl
End If
exitHere:
MyDeclare = True
Set declobj = Nothing
End Function

Private Function GetShinkArr(v As Long, where As Long, objname$, from As Long, count As Long) As Boolean
Dim aa As Object, ok As Boolean, I As Long, pppp As mArray, pppp1 As mArray, ev As ComShinkEvent
Set pppp = var(v)
Set pppp1 = var(where)
ok = True
For I = from To count + from - 1
    Set ev = New ComShinkEvent
    
    Set aa = pppp.item(I)
    
                         ev.VarIndex = v
                         ev.ItemIndex = I
                         If here$ <> "" Then
                         ev.modulename = here$ + "." + objname$
                         ev.modulenameonly = here$
                         Else
                         ev.modulename = objname$
                         ev.modulenameonly = vbNullString
                         End If
                         ev.Attach aa
   Set aa = Nothing
   If Not ev.Attached() Then ok = False: Exit For
   Set pppp1.item(I) = ev
   Next I
   GetShinkArr = ok
End Function
Private Function GetShinkArr2(pppp As mArray, pppp1 As mArray, objname$, from As Long, count As Long) As Boolean
Dim aa As Object, ok As Boolean, I As Long, ev As ComShinkEvent
ok = True
Set ev = pppp1.item(0)
Dim v As Long
v = ev.VarIndex
For I = from To count - 1
    Set ev = New ComShinkEvent
    
    Set aa = pppp.item(I)
    
                         ev.VarIndex = v
                         ev.ItemIndex = I
                         If here$ <> "" Then
                         ev.modulename = here$ + "." + objname$
                         ev.modulenameonly = here$
                         Else
                         ev.modulename = objname$
                         ev.modulenameonly = vbNullString
                         End If
                         ev.Attach aa
   Set aa = Nothing
   If Not ev.Attached() Then ok = False: Exit For
   Set pppp1.item(I) = ev
   Next I
   GetShinkArr2 = ok
End Function
Public Function GetShink(ev As ComShinkEvent, v As Long, objname$) As Boolean
Dim aa As Object
    Set ev = New ComShinkEvent

    Set aa = var(v)
    If TypeOf aa Is ExtControl Then Set aa = aa.Value
    
            ev.VarIndex = v
            ev.ItemIndex = -1
            If here$ <> "" Then
            ev.modulename = here$ + "." + objname$
            ev.modulenameonly = here$
            Else
            ev.modulename = objname$
            ev.modulenameonly = vbNullString
            End If
            ev.Attach aa
   Set aa = Nothing
   GetShink = ev.Attached()
End Function
Private Function GetContainer(bstack As basetask, rest$, ByVal Lang As Long) As GuiImage
    Dim p
    Set bstack.lastobj = Nothing
    If IsLabelSymbolNew(rest$, "ÅÉÊÏÍÁ", "IMAGE", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            On Error Resume Next
            Set GetContainer = bstack.lastobjIndirect(var())
            If Err Then
                BadObjectDecl
            End If
        End If
    End If
End Function
Function DeclareGUI(bstack As basetask, what$, rest$, ifier As Boolean, Lang As Long, I As Long, Optional Ar As Long = 0, Optional oName As String = vbNullString, Optional Glob As Long = 0, Optional Y3 As Boolean, Optional ArrPos As Long = 0)
DeclareGUI = True
On Error GoTo wrong
Dim W$, x1 As Long, y1 As Long, s$, USEOLD As Boolean, bp As Long
Dim alfa As GuiM2000, mm As CallBack2, alfa0 As GuiImage
Dim aVar As Variant, p As Variant
Dim pppp As mArray, mmmm As mEvent
' for these events no use of noHere property because no copyevent/upgrade happens
'         see .upgrade in UnFloatGroupReWriteVars and UnFloatGroup

 If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
    Y3 = False ' no withevents in declare
    If IsLabelSymbolNew(rest$, "ÃÅÃÏÍÏÓ", "EVENT", Lang) Then
        x1 = Abs(IsLabel(bstack, rest$, W$))
        If x1 <> 1 Then
                BadObjectDecl
        Else
           If GetlocalVar(bstack.GroupName + W$, y1) Then
               USEOLD = True
           ElseIf GetVar(bstack, bstack.GroupName + W$, y1) Then
               USEOLD = True
           Else
            y1 = globalvar(bstack.GroupName + W$, s$)
            MakeitObjectEvent var(y1)
           End If
           If VarTypeName(var(y1)) <> "mEvent" Then
               ifier = False
               DeclareGUI = False: Exit Function
           End If
        End If
        If Ar = 0 Then
            If Not USEOLD Then ProcEvent bstack, "{Read msg$, &obj}", 1, y1
            CreateFormObject var(I), 1
            Set alfa = var(I)
            Set alfa.safe = getSafeFormList()
            Set alfa.EventObj = var(y1)
            alfa.Index = -1
            alfa.myname = what$
            alfa.modulename = here$
            alfa.TempTitle = what$
            Set alfa = Nothing
        Else
            ProcEvent bstack, "{Read index, msg$, &obj}", 1, y1
            Set mmmm = var(y1)
            GoTo contEvArray
        End If
    Else
            bp = True
            If Ar = 0 Then
                CreateFormObject var(I), 1
                Set alfa = var(I)
                Set mmmm = New mEvent
                Set alfa.safe = getSafeFormList()
                Set alfa.EventObj = mmmm
                With mmmm
                    .BypassInit 10
                    .VarIndex = I * 1000 + varhash.count
                    .enabled = True
                    .ParamBlock "Read msg$, &obj", 2
                    .GenItemCreator LTrim$(str(I * 456)), "{ Module " + here$ + vbCrLf + "try { Call local " + here$ + "." + bstack.GroupName + what$ + "() } }" + here$ + "." + bstack.GroupName
                End With
                alfa.myname = what$
                alfa.Index = -1
                alfa.modulename = here$
                alfa.ByPass = bp
                alfa.TempTitle = what$
                Set mmmm = Nothing
                Set alfa = Nothing
            Else
                Set mmmm = New mEvent
contEvArray:
                'If neoGetArray(bstack, oName$ + "(", pppp, , CBool(glob)) Then
                    Set pppp = var(ArrPos)
                    what$ = Left$(what$, Len(oName$))
                    If y1 = 0 Then
                        With mmmm
                            .BypassInit 10
                            .VarIndex = I * 1000 + varhash.count
                            .enabled = True
                            .ParamBlock "Read Index, msg$, &obj", 3
                            .GenItemCreator LTrim$(str(I * 3456)), "{ Module " + here$ + vbCrLf + "try { call local " + here$ + "." + bstack.GroupName + what$ + "() } }" + here$ + "." + bstack.GroupName
                        End With
                    End If
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 1
                        Set pppp.item(I) = aVar
                        Dim aaa As GuiM2000, safe As LongHash
                        Set safe = getSafeFormList()
                        Set aaa = aVar
                        With aaa
                            Set .safe = safe
                            Set .EventObj = mmmm
                            .myname = what$
                            .modulename = here$
                            .ByPass = bp
                            .TempTitle = what$ & "(" & (I) & ")"
                            .Index = I
                        End With
                    Next I
                    Set aaa = Nothing
                'End If
                pppp.IHaveGui = True
                Set mmmm = Nothing
            End If
        End If
 ElseIf IsLabelSymbolNew(rest$, "ÐËÇÊÔÑÏ", "BUTTON", Lang) Then
     Y3 = False ' no withevents in declare
    If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            If bstack.lastobj Is Nothing Then
                BadObjectDecl
                Exit Function
            End If
            Dim aa2 As GuiButton
            If Ar = 0 Then
                CreateFormObject var(I), 2
                Set alfa = bstack.lastobjIndirect(var())
                Set alfa0 = GetContainer(bstack, rest$, Lang)
                Set bstack.lastobj = Nothing
                If Err Then GoTo wrong
                Set aa2 = var(I)
                With aa2
                    .Construct alfa, what$
                    If Not alfa0 Is Nothing Then
                        .move 0, 0, 6000, 600
                        Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                    Else
                        .move 0, 2000, 6000, 600
                    End If
                    .Caption = what$
                    .SetUp
                End With
                Set alfa = Nothing
            Else
                If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                    what$ = Left$(what$, Len(oName$))
                    Set alfa = bstack.lastobjIndirect(var())
                    Set alfa0 = GetContainer(bstack, rest$, Lang)
                    Set bstack.lastobj = Nothing
                    If Err Then GoTo wrong
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 2
                        Set pppp.item(I) = aVar
                        Set aa2 = aVar
                        With aa2
                            .ConstructArray alfa, what$, I
                            If Not alfa0 Is Nothing Then
                                .move 0, 0, 6000, 600
                                Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                            Else
                                .move 0, 2000, 6000, 600
                            End If
                            .Caption = what$ & "(" & (I) & ")"
                            .SetUp
                        End With
                    Next I
                    pppp.IHaveGui = True
                    Set alfa = Nothing
                End If
            End If
        End If
    End If
ElseIf IsLabelSymbolNew(rest$, "ÅÉÓÁÃÙÃÇ", "TEXTBOX", Lang) Then
    Y3 = False ' no withevents in declare
    If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            If bstack.lastobj Is Nothing Then
                BadObjectDecl
                Exit Function
            End If
            Dim aa3 As GuiTextBox
            If Ar = 0 Then
                CreateFormObject var(I), 3
                Set alfa = bstack.lastobjIndirect(var())
                Set alfa0 = GetContainer(bstack, rest$, Lang)
                Set bstack.lastobj = Nothing
                If Err Then GoTo wrong
                Set aa3 = var(I)
                With aa3
                    .Construct alfa, what$
                    If Not alfa0 Is Nothing Then
                        .move 0, 0, 6000, 600
                        Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                    Else
                        .move 0, 2000, 6000, 600
                    End If
                    .SetUp
                    .Text = what$
                End With
                Set alfa = Nothing
            Else
                If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                    what$ = Left$(what$, Len(oName$))
                    Set alfa = bstack.lastobjIndirect(var())
                    Set alfa0 = GetContainer(bstack, rest$, Lang)
                    Set bstack.lastobj = Nothing
                    If Err Then GoTo wrong
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 3
                        Set pppp.item(I) = aVar
                        Set aa3 = aVar
                        With aa3
                            .ConstructArray alfa, what$, I
                            If Not alfa0 Is Nothing Then
                                .move 0, 0, 6000, 600
                                Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                            Else
                                .move 0, 2000, 6000, 600
                            End If
                            .SetUp
                            .Text = what$ & "(" & (I) & ")"
                        End With
                    Next I
                    pppp.IHaveGui = True
                    Set alfa = Nothing
                End If
            End If
        End If
    End If
ElseIf IsLabelSymbolNew(rest$, "ÅÐÉËÏÃÇ", "CHECKBOX", Lang) Then
    Y3 = False ' no withevents in declare
     If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            If bstack.lastobj Is Nothing Then
                BadObjectDecl
                Exit Function
            End If
            Dim aa4 As GuiCheckBox
            If Ar = 0 Then
                CreateFormObject var(I), 4
                Set alfa = bstack.lastobjIndirect(var())
                Set alfa0 = GetContainer(bstack, rest$, Lang)
                Set bstack.lastobj = Nothing
                If Err Then GoTo wrong
                Set aa4 = var(I)
                With aa4
                    .Construct alfa, what$
                    If Not alfa0 Is Nothing Then
                        .move 0, 0, 6000, 600
                        Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                    Else
                        .move 0, 2000, 6000, 600
                    End If
                    .Caption = what$
                    .SetUp
                End With
                Set alfa = Nothing
            Else
                If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                    what$ = Left$(what$, Len(oName$))
                    Set alfa = bstack.lastobjIndirect(var())
                    Set alfa0 = GetContainer(bstack, rest$, Lang)
                    Set bstack.lastobj = Nothing
                    If Err Then GoTo wrong
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 4
                        Set pppp.item(I) = aVar
                        Set aa4 = aVar
                        With aa4
                            .ConstructArray alfa, what$, I
                            If Not alfa0 Is Nothing Then
                                .move 0, 0, 6000, 600
                                Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                            Else
                                .move 0, 2000, 6000, 600
                            End If
                            .Caption = what$ & "(" & (I) & ")"
                            .SetUp
                        End With
                    Next I
                    pppp.IHaveGui = True
                    Set alfa = Nothing
                End If
            End If
        End If
    End If
ElseIf IsLabelSymbolNew(rest$, "ÊÅÉÌÅÍÏ", "EDITBOX", Lang) Then
    Y3 = False ' no withevents in declare
    If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            If bstack.lastobj Is Nothing Then
                BadObjectDecl
                Exit Function
            End If
            Dim aa5 As GuiEditBox
            If Ar = 0 Then
                CreateFormObject var(I), 5
                Set alfa = bstack.lastobjIndirect(var())
                Set alfa0 = GetContainer(bstack, rest$, Lang)
                Set bstack.lastobj = Nothing
                If Err Then GoTo wrong
                Set aa5 = var(I)
                With aa5
                    .Construct alfa, what$
                    If Not alfa0 Is Nothing Then
                        .move 0, 0, 6000, 1200
                        Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                    Else
                        .move 0, 2000, 6000, 1200
                    End If
                    If alfa.prive <> 0 Then
                        .LineSpace = players(alfa.prive).uMineLineSpace
                    Else
                        .LineSpace = players(0).uMineLineSpace
                    End If
                    .SetUp
                    .Text = what$
                End With
                Set alfa = Nothing
            Else
                If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                    what$ = Left$(what$, Len(oName$))
                    Set alfa = bstack.lastobjIndirect(var())
                    Set alfa0 = GetContainer(bstack, rest$, Lang)
                    Set bstack.lastobj = Nothing
                    If Err Then GoTo wrong
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 5
                        Set pppp.item(I) = aVar
                        Set aa5 = aVar
                        With aa5
                            .ConstructArray alfa, what$, I
                            If Not alfa0 Is Nothing Then
                                .move 0, 0, 6000, 1200
                                Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                            Else
                                .move 0, 2000, 6000, 1200
                            End If
                            If alfa.prive <> 0 Then
                                .LineSpace = players(alfa.prive).uMineLineSpace
                            Else
                                .LineSpace = players(0).uMineLineSpace
                            End If
                            .SetUp
                            .Text = what$ & "(" & (I) & ")"
                        End With
                    Next I
                    pppp.IHaveGui = True
                    Set alfa = Nothing
                End If
            End If
        End If
    End If
ElseIf IsLabelSymbolNew(rest$, "ËÉÓÔÁ", "LISTBOX", Lang) Then
    Y3 = False ' no withevents in declare
    If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            If bstack.lastobj Is Nothing Then
                BadObjectDecl
                Exit Function
            End If
            Dim aa6 As GuiListBox
            If Ar = 0 Then
                CreateFormObject var(I), 6
                Set alfa = bstack.lastobjIndirect(var())
                Set alfa0 = GetContainer(bstack, rest$, Lang)
                Set bstack.lastobj = Nothing
                If Err Then GoTo wrong
                Set aa6 = var(I)
                With aa6
                    .Construct alfa, what$
                    .move 0, 2000, 6000, 600
                    If Not alfa0 Is Nothing Then
                        .move 0, 0, 6000, 600
                        Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                    Else
                        .move 0, 2000, 6000, 600
                    End If
                    .ListText = what$
                    .SetUp
                End With
                Set alfa = Nothing
            Else
                If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                    what$ = Left$(what$, Len(oName$))
                    Set alfa = bstack.lastobjIndirect(var())
                    Set alfa0 = GetContainer(bstack, rest$, Lang)
                    Set bstack.lastobj = Nothing
                    If Err Then GoTo wrong
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 6
                        Set pppp.item(I) = aVar
                        Set aa6 = aVar
                        With aa6
                            .ConstructArray alfa, what$, I
                            If Not alfa0 Is Nothing Then
                                .move 0, 0, 6000, 600
                                Set alfa.Controls(.ctrlName).Container = alfa0.pbox
                            Else
                                .move 0, 2000, 6000, 600
                            End If
                            If alfa.prive <> 0 Then
                                .LineSpace = players(alfa.prive).uMineLineSpace
                            Else
                                .LineSpace = players(0).uMineLineSpace
                            End If
                            .ListText = what$ & "(" & (I) & ")"
                            .SetUp
                        End With
                    Next I
                    pppp.IHaveGui = True
                    Set alfa = Nothing
                End If
            End If
        End If
    End If
ElseIf IsLabelSymbolNew(rest$, "ÅÉÊÏÍÁ", "IMAGE", Lang) Then
    Y3 = False ' no withevents in declare
    If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            If bstack.lastobj Is Nothing Then
                BadObjectDecl
                Exit Function
            End If
            Dim aa8 As GuiImage
            If Ar = 0 Then
                CreateFormObject var(I), 8
                Set alfa = bstack.lastobjIndirect(var())
                Set bstack.lastobj = Nothing
                Set aa8 = var(I)
                With aa8
                    .Construct alfa, what$
                    .move 0, 2000, 6000, 600
                    .SetUp
                    .Text = what$
                End With
                Set alfa = Nothing
            Else
                If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                    what$ = Left$(what$, Len(oName$))
                    Set alfa = bstack.lastobjIndirect(var())
                    Set bstack.lastobj = Nothing
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 7
                        Set pppp.item(I) = aVar
                        Set aa8 = aVar
                        With aa8
                            .ConstructArray alfa, what$, I
                            .move 0, 2000, 6000, 600
                            .SetUp
                            .Text = what$ & "(" & (I) & ")"
                        End With
                    Next I
                    pppp.IHaveGui = True
                    Set alfa = Nothing
                End If
            End If
        End If
    End If

ElseIf IsLabelSymbolNew(rest$, "ËÉÓÔÁ.ÅÉÓÁÃÙÃÇÓ", "COMBOBOX", Lang) Then
    Y3 = False ' no withevents in declare
    If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        If Not IsExp(bstack, rest$, p) Then
            BadObjectDecl
        Else
            If bstack.lastobj Is Nothing Then
                BadObjectDecl
                Exit Function
            End If
            Dim aa7 As GuiDropDown
            If Ar = 0 Then
                CreateFormObject var(I), 7
                Set alfa = bstack.lastobjIndirect(var())
                Set bstack.lastobj = Nothing
                Set aa7 = var(I)
                With aa7
                    .Construct alfa, what$
                    .move 0, 2000, 6000, 600
                    .SetUp
                End With
                Set alfa = Nothing
            Else
                If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                    what$ = Left$(what$, Len(oName$))
                    Set alfa = bstack.lastobjIndirect(var())
                    Set bstack.lastobj = Nothing
                    For I = 0 To Ar - 1
                        CreateFormObject aVar, 7
                        Set pppp.item(I) = aVar
                        Set aa7 = aVar
                        With aa7
                            .ConstructArray alfa, what$, I
                            .move 0, 2000, 6000, 600
                            .SetUp
                        End With
                    Next I
                    pppp.IHaveGui = True
                    Set alfa = Nothing
                End If
            End If
        End If
    End If
ElseIf IsLabelSymbolNew(rest$, "ÔÕÐÏÓ", "TYPE", Lang) Then
     Y3 = False ' no withevents in declare
    'Y3 = True
    If IsStrExp(bstack, rest$, s$) Then
        If FastSymbol(rest$, ",") Then IsStrExp bstack, rest$, W$ Else W$ = ""
        Dim ec1 As ExtControl
        If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
            If Not IsExp(bstack, rest$, p) Then
                BadObjectDecl
            Else
                If bstack.lastobj Is Nothing Then
                    BadObjectDecl
                    Exit Function
                End If
                
                If Ar = 0 Then
                    On Error Resume Next
                    
                    If W$ <> "" Then
                        Licenses.Add s$, W$
                    End If
                    If Err Then Err.Clear: GoTo wrong
                    
                    CreateFormObject var(I), 9
                    Set alfa = bstack.lastobjIndirect(var())
                    Set alfa0 = GetContainer(bstack, rest$, Lang)
                    Set bstack.lastobj = Nothing
                    If Err Then GoTo wrong
                    
                    Set ec1 = var(I)
                    With ec1
                    
                         .Attach alfa.Controls.Add(s$, what$), what$, s$, alfa
                         If Err.Number Then Err.Clear: GoTo wrong
                         alfa.AddGuiControl ec1
                        If Not alfa0 Is Nothing Then
                            alfa.Controls(what$).move 0, 2000, 6000, 600
                            Set alfa.Controls(what$).Container = alfa0.pbox
                        Else
                            
                            alfa.Controls(what$).move 0, 2000, 6000, 600
                        End If
                        If .FixEvent Then Y3 = True
                    End With
                    Set alfa = Nothing
                Else
                    If neoGetArray(bstack, oName$ + "(", pppp, , CBool(Glob)) Then
                        what$ = Left$(what$, Len(oName$))
                        Set alfa = bstack.lastobjIndirect(var())
                        Set alfa0 = GetContainer(bstack, rest$, Lang)
                        Set bstack.lastobj = Nothing
                        If Err Then GoTo wrong
                         If W$ <> "" Then
                            Licenses.Add s$, W$
                        End If
                        If Err Then GoTo wrong
                        For I = 0 To Ar - 1
                            CreateFormObject aVar, 9
                            Set pppp.item(I) = aVar
                            Set ec1 = aVar
                            With ec1
                                .Attach alfa.Controls.Add(s$, what$ & I), what$, s$, alfa, I
                                alfa.AddGuiControl ec1
                                If Err.Number Then Err.Clear: GoTo wrong
                                If Not alfa0 Is Nothing Then
                                    alfa.Controls(what$ & I).move 0, 2000, 6000, 600
                                    Set alfa.Controls(what$ & I).Container = alfa0.pbox
                                Else
                                    
                                    alfa.Controls(what$ & I).move 0, 2000, 6000, 600
                                End If
                                If .FixEvent Then Y3 = True
                            End With
                        Next I
                        pppp.IHaveGui = True
                        Set alfa = Nothing
                    End If
                End If
            End If
        End If
    Else
        BadObjectDecl
    End If
ElseIf IsLabelSymbolNew(rest$, "ÐËÇÑÏÖÏÑÉÅÓ", "INFORMATION", Lang) Then
    
    Y3 = False ' no withevents in declare
    If Ar > 0 Then
    MyEr "not for array", "ü÷é ãéá ðßíáêá"
    DeclareGUI = False
    End If
    Set var(I) = OsInfo
ElseIf IsLabelSymbolNew(rest$, "ÌÇÔÑÙÏ.ÓÕÓÔÇÌÁÔÏÓ", "WINDOWS.REGISTRY", Lang) Then
    
    Y3 = False ' no withevents in declare
    If Ar > 0 Then
    MyEr "not for array", "ü÷é ãéá ðßíáêá"
    DeclareGUI = False
    End If
    Set var(I) = New cRegistry
ElseIf IsLabelSymbolNew(rest$, "ÐÇÃÇ.ÃÅÃÏÍÏÔÏÓ", "SINK.EVENT", Lang) Then
    
    Y3 = True
    If Ar > 0 Then
    MyEr "not for array", "ü÷é ãéá ðßíáêá"
    DeclareGUI = False
    End If
    Set var(I) = New SinkEvent

ElseIf IsLabelSymbolNew(rest$, "ÓÕÌÐÉÅÓÔÇÓ", "COMPRESSOR", Lang) Then
    If Ar = 0 Then
        Set var(I) = New ZipTool
    Else
        what$ = Left$(what$, Len(oName$))
        Set pppp = var(ArrPos)
        For I = 0 To Ar - 1
            Set pppp.item(I) = New ZipTool
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÌÁÈÇÌÁÔÉÊÁ", "MATH", Lang) Then
    Y3 = False ' no withevents in declare
    Set var(I) = nMath
ElseIf IsLabelSymbolNew(rest$, "ÌÁÈÇÌÁÔÉÊÁ2", "MATH2", Lang) Then
    Y3 = False ' no withevents in declare
    Set var(I) = nMath2
    
ElseIf IsLabelSymbolNew(rest$, "ÓÔÁÈÌÏÓ", "SOCKET", Lang) Then
    If Ar = 0 Then
        Set var(I) = New cTlsSocket
    Else
        what$ = Left$(what$, Len(oName$))
        Set pppp = var(ArrPos)
        For I = 0 To Ar - 1
            Set pppp.item(I) = New cTlsSocket
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÁÕËÏÓ", "SHELLPIPE", Lang) Then
    If Ar = 0 Then
        Set var(I) = New ShellPipe
    Else
        what$ = Left$(what$, Len(oName$))
        Set pppp = var(ArrPos)
        For I = 0 To Ar - 1
            Set pppp.item(I) = New ShellPipe
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÓÅÉÑÉÁÊÇ", "SERIALPORT", Lang) Then
    If Ar = 0 Then
        Set var(I) = New SerialPort
    Else
        what$ = Left$(what$, Len(oName$))
        Set pppp = var(ArrPos)
        For I = 0 To Ar - 1
            Set pppp.item(I) = New SerialPort
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÊÁÔÅÂÁÓÌÁ", "DOWNLOAD", Lang) Then
    If Ar = 0 Then
        Set var(I) = New cHttpDownload
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = New cHttpDownload
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÁÉÔÇÌÁ.ÓÕÍÄÅÓÇÓ", "HTTPS.REQUEST", Lang) Then
    If Ar = 0 Then
        Set var(I) = New clsHttpsRequest
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = New clsHttpsRequest
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÐÅËÁÔÇÓ", "CLIENT", Lang) Then
    Y3 = False ' no withevents in declare
    If Ar = 0 Then
        Set var(I) = New cTlsClient
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = New cTlsClient
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÓÕËËÏÃÇ", "COLLECTION", Lang) Then
    Y3 = False ' no withevents in declare
    If Ar = 0 Then
        Set var(I) = New Collection
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = New Collection
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÓÔÏÉ×ÅÉÁXML", "XMLDATA", Lang) Then
    Y3 = False ' no withevents in declare
    If Ar = 0 Then
        Set var(I) = xmlMonoNew
        
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = xmlMonoNew
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÐÉÍÁÊÁÓJSON", "JSONARRAY", Lang) Then
    Y3 = False
    If Ar = 0 Then
        Set var(I) = New JsonArray
        
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = New JsonArray
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ËÉÓÔÁJSON", "JSONOBJECT", Lang) Then
    Y3 = False
    If Ar = 0 Then
        Set var(I) = New JsonObject
        
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = New JsonObject
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÌÏÍÁÄÉÊÏ", "MUTEX", Lang) Then
    Y3 = False ' no withevents in declare
    If Ar = 0 Then
        Set var(I) = New Mutex
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set pppp.item(I) = New Mutex
        Next I
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÅÖÁÑÌÏÃÇ", "APPLICATION", Lang) Then
    If IsLabelSymbolNew(rest$, "ÖÏÑÌÁ", "FORM", Lang) Then
        Set var(I) = Form1
    Else
        If Ar = 0 Then
            Set mm = New CallBack2
            mm.NoPublic bstack, ""
            Set var(I) = mm
            Set mm = Nothing
        Else
            Set pppp = var(ArrPos)
            what$ = Left$(what$, Len(oName$))
            For I = 0 To Ar - 1
                Set mm = New CallBack2
                mm.NoPublic bstack, ""
                Set pppp.item(I) = mm
                Set mm = Nothing
            Next I
        End If
    End If
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÔÌÇÌÁ", "MODULE", Lang) Then
    If Ar = 0 Then
            Set mm = New CallBack2
            mm.NoPublic bstack, here$
            Set var(I) = mm
            Set mm = Nothing
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set mm = New CallBack2
            mm.NoPublic bstack, here$
            Set pppp.item(I) = mm
            Set mm = Nothing
        Next I
    End If
ElseIf IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then
    If IsStrExp(bstack, rest$, s$) Then GoTo ccc
ElseIf IsStrExp(bstack, rest$, s$) Then
ccc:
    Y3 = False ' no withevents in declare
    If Ar = 0 Then
        CreateitObject var(I), s$
    Else
        Set pppp = var(ArrPos)
        what$ = Left$(what$, Len(oName$))
        For I = 0 To Ar - 1
            Set p = Nothing
            CreateitObject p, s$
            Set pppp.item(I) = p
        Next I
    End If
    Exit Function
wrong:
BadObjectDecl
DeclareGUI = False
Err.Clear
End If
End Function

Function ReArrangePara(what$) As String
ReArrangePara = what$
Exit Function
Dim a1() As Integer, A2() As Integer, WHAT1$, r As Long, mark1 As Long, ii As Long, mark2 As Long
Dim wr$
If Len(what$) = 0 Then Exit Function
    ReDim a1(Len(what$) + 10)
    ReDim A2(Len(what$) + 10)
    Dim skip As Boolean
    skip = GetStringTypeExW(&HB, 4, StrPtr(what$), Len(what$), a1(0)) = 0
    skip = GetStringTypeExW(&HB, 2, StrPtr(what$), Len(what$), A2(0)) = 0 Or skip
    
    If Not skip Then
    For r = 0 To Len(what$) - 1
    If (A2(r) And 254) = 2 And (a1(r) And &H8000) <> 0 Then
    If mark1 = 0 Then WHAT1$ = WHAT1$ + Left$(what$, r)
    mark1 = r + 1
    mark2 = 0
    For ii = mark1 + 1 To Len(what$) - 1
    If (A2(ii) And 254) > 2 And (a1(ii) And 7) = 0 Then mark2 = ii: Exit For
    Next ii
    If mark2 = 0 Then
    wr$ = Mid$(what$, mark1) + wr$
    r = ii
    Else
    wr$ = Mid$(what$, mark1, mark2 - mark1 + 1) + wr$

    r = ii - 1
    End If
    ElseIf (a1(r) And &HFFF8) <> 0 And (a1(ii) And 7) = 0 Then
    mark1 = 0
    For ii = r To Len(what$) - 1
  
    If mark2 > 0 Then
    If (a1(r) And &H8000) <> 0 Then
    If (A2(ii) And 2) = 2 Then mark1 = ii: Exit For
    Else
    If A2(ii) > 3 And mark1 > 0 Then
    
   ' If (A2(ii + 1) And 15) <> 3 Then
   If A2(ii) > 9 Then ii = ii - 1: Exit For
    ElseIf (A2(ii) And 3) = 2 Then
        If A2(ii) > 3 And A2(ii + 1) = 1 Then
                WHAT1$ = WHAT1$ + wr$
                wr$ = ""
                mark2 = 0
         Else
            mark1 = ii: Exit For
        End If
    ElseIf A2(ii) > 3 Then

        If (A2(ii + 1) And 3) > 1 Then mark1 = ii
        Exit For

    End If
        mark1 = ii
    
    End If
    Else
    If Len(wr$) > 0 Then
    If A2(ii) > 3 Then
            If A2(ii) > 9 And A2(ii + 1) > 9 Then
        mark1 = 0
        
        Else
    If (A2(ii + 1) And 1) = 1 And A2(ii + 1) <> 3 Then
          WHAT1$ = WHAT1$ + wr$
    wr$ = ""
    mark1 = ii
    Else
    
    mark2 = ii
    mark1 = ii
    
    If A2(ii + 1) < 4 Then Exit For
    End If
    End If
    ElseIf A2(ii + 1) > 3 Then

    If A2(r) = 3 Then
    mark2 = ii
    mark1 = ii
    
    Exit For
    End If
    End If
    End If
    If (A2(ii) And 254) = 2 And (a1(ii) And &H8000) <> 0 Then mark1 = ii: Exit For
    End If
    
    Next ii

    If mark2 = 0 Then
    WHAT1$ = WHAT1$ + Mid$(what$, r + 1, ii - r)
    r = ii - 1
    ElseIf mark1 = 0 Then
    If Len(wr$) > 0 Then wr$ = wr$ + Mid$(what$, r + 1, ii - r + 1)
    r = ii
    Else
   
    If Len(wr$) > 0 Then wr$ = Mid$(what$, r + 1, ii - r + 1) + wr$
    r = ii
    End If
    If mark2 > 0 Then
    If (A2(ii) And 3) = 3 Then

        mark2 = 0
    ElseIf (A2(ii) And 3) = 0 Then
      WHAT1$ = WHAT1$ + wr$
    wr$ = ""
    mark2 = 0
    End If
    
    End If
    
    
    Else
    
    End If
    Next r
    
    
    
    End If
    If Len(wr$) = 0 And Len(WHAT1$) = 0 Then
    ReArrangePara = what$
    Else
    ReArrangePara = WHAT1$ + wr$
    End If
End Function
Function mydata2(bstack As basetask, rest$, RetStack As mStiva) As Boolean
Dim s$, p As Variant, usehandler As mHandler ', vvl As Variant, photo As Object
mydata2 = True
Do
    If FastSymbol(rest$, "!") Then
                If IsExp(bstack, rest$, p) Then
                    If bstack.lastobj Is Nothing Then
                        RetStack.DataValLong p
                    ElseIf TypeOf bstack.lastobj Is mHandler Then
                        Set usehandler = bstack.lastobj
                        If TypeOf usehandler.objref Is mStiva Then
                            RetStack.MergeBottom usehandler.objref
                        ElseIf TypeOf usehandler.objref Is mArray Then
                            RetStack.MergeBottomCopyArray usehandler.objref
                        Else
                            mydata2 = False
                            MyEr "Expected Stack Object or Array after !", "Ðåñßìåíá áíôéêåßìåíï Óùñü Þ ðßíáêá ìåôÜ ôï !"
                            Set bstack.lastobj = Nothing
                            Exit Function
                        End If
                        Set usehandler = Nothing
                        Set bstack.lastobj = Nothing
                    ElseIf TypeOf bstack.lastobj Is mArray Then
                        RetStack.MergeBottomCopyArray bstack.lastobj
                        Set bstack.lastobj = Nothing
                    End If
                        
                     End If
                ElseIf IsExp(bstack, rest$, p) Then
                  If bstack.lastobj Is Nothing Then
                      RetStack.DataVal p
                 Else
                   If TypeOf bstack.lastobj Is mStiva Then
                   Set bstack.Sorosref = bstack.lastobj
                   ElseIf TypeOf bstack.lastobj Is VarItem Then
                    RetStack.DataObjVaritem bstack.lastobj
                      Else
                      RetStack.DataObj bstack.lastobj
                    Set bstack.lastpointer = Nothing
                    End If
                      Set bstack.lastobj = Nothing
                End If
        ElseIf IsStrExp(bstack, rest$, s$) Then
                If bstack.lastobj Is Nothing Then
                        RetStack.DataStr s$
                Else
                        RetStack.DataObj bstack.lastobj
                        Set bstack.lastobj = Nothing
                          Set bstack.lastpointer = Nothing
                End If
        Else
                mydata2 = LastErNum1 = 0
                Exit Do
        End If
        If Not FastSymbol(rest$, ",") Then Exit Do
        
Loop
End Function
Function IsLabelDot2(bstack As basetask, A$, r$) As Long    'ok
' for left side...no &

Dim rr&, one As Boolean, C$, firstdot$, gr As Boolean
r$ = vbNullString
If A$ = vbNullString Then IsLabelDot2 = 0: Exit Function

A$ = NLtrim$(A$)
    Do While Len(A$) > 0
    C$ = Left$(A$, 1)
    If AscW(C$) < 256 Then
        Select Case AscW(C$)
        Case 64  '"@"
           
              IsLabelDot2 = 0: A$ = firstdot$ + A$: Exit Function

        Case 63 '"?"
        If r$ = vbNullString And firstdot$ = vbNullString Then
        r$ = "?"
        A$ = Mid$(A$, 2)
        IsLabelDot2 = 1
        Exit Function
    
        ElseIf firstdot$ = vbNullString Then
        IsLabelDot2 = 1
        Exit Function
        Else
        IsLabelDot2 = 0
        Exit Function
        End If
        Case 46 '"."
            If one Then
            Exit Do
            Exit Do
            ElseIf r$ <> "" And Len(A$) > 1 Then
            If Mid$(A$, 2, 2) = ". " Or Mid$(A$, 2, 1) = " " Then Exit Do
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1
            Else
            firstdot$ = firstdot$ + "."
            A$ = Mid$(A$, 2)
            End If
       Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
        Exit Do

        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            If firstdot$ <> "" Then A$ = firstdot$ + A$
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                            If Mid$(A$, 2, 2) = ")@" Then
                                    r$ = r$ + "()."
                                  
                                 A$ = Mid$(A$, 4)
                               Else
                                       Select Case rr&
                                       Case 1
                                       rr& = 5 ' float array or function
                                       Case 3
                                       rr& = 6 'string array or function
                                       Case 4
                                       rr& = 7 ' long array
                                       Case Else
                                       Exit Do
                                       End Select
                                       r$ = r$ + Left$(A$, 1)
                                       A$ = Mid$(A$, 2)
                                   Exit Do
                            
                          End If
               Else
                        Exit Do
            
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If

    Loop
    If Len(firstdot$) > 0 Then
     r$ = myUcase(r$, gr)
    rr& = bstack.GetDotNew(r$, Len(firstdot$)) * rr&
    Else
       r$ = myUcase(r$, gr)
       End If
    IsLabelDot2 = rr&
   

End Function
Function ProcDrawWidth(bstack As basetask, rest$) As Boolean
Dim X As Double, p As Variant, it As Long, ss$, I As Long, x1 As Long, nd&, once As Boolean
ProcDrawWidth = True
Dim Scr As Object
Set Scr = bstack.Owner
If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
    I = Scr.DrawWidth
    x1 = Scr.DrawStyle
    If Int(p) < 1 Then p = 1
    Scr.DrawWidth = p
   
        If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, X, , True) Then
                On Error Resume Next
                X = Int(X)
                If X >= 0 Or X <= 6 Then
                    Scr.DrawStyle = X
                    If Err Then X = 0: Scr.DrawStyle = Int(X)
                    Scr.DrawWidth = p
                End If
            End If
        End If
   
    If FastSymbol(rest$, "{") Then
        ss$ = block(rest$)
         TraceStore bstack, nd&, rest$, 0
        If FastSymbol(rest$, "}") Then
            Call executeblock(it, bstack, ss$, False, once, , True)
        End If
        bstack.addlen = nd&
    Else
        MissingBlockCode
    End If
Else
MissNumExpr
End If

If it = 2 Then
If ss$ = "" Then
If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
Else
rest$ = ": Goto " + ss$
If trace Then WaitShow = 2: TestShowSub = rest$
End If

it = 1
End If
If it <> 1 Then ProcDrawWidth = False: rest$ = ss$ + rest$
If I <= 0 Then I = 1
Scr.DrawWidth = I
Scr.DrawStyle = x1
Scr.DrawWidth = I
Scr.DrawStyle = x1
Set Scr = Nothing
End Function
Function ProcCurve(bstack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, sX As Double, sY As Double, X As Double, Y As Double, x1 As Integer, p As Variant, f As Long
Dim Scr As Object

Set Scr = bstack.Owner
ProcCurve = True
With players(GetCode(Scr))
If IsLabelSymbolNew(rest$, "ÃÙÍÉÁ", "ANGLE", Lang) Then par = True
f = 32
ReDim PLG(f)
x1 = 1
PLG(0).X = Scr.ScaleX(.XGRAPH, 1, 3)
PLG(0).Y = Scr.ScaleY(.YGRAPH, 1, 3)
Do
If x1 >= f Then f = f * 2: ReDim Preserve PLG(f)
If IsExp(bstack, rest$, p) Then
X = p

If Not FastSymbol(rest$, ",") Then ProcCurve = False: MissNumExpr: Exit Function
If IsExp(bstack, rest$, p) Then
If par Then
sX = X / PI2
sX = (sX - Fix(sX)) * PI2
.XGRAPH = .XGRAPH + Cos(sX) * p
.YGRAPH = .YGRAPH - Sin(sX) * p
Else
.XGRAPH = .XGRAPH + CLng(X)
.YGRAPH = .YGRAPH + CLng(p)
End If
PLG(x1).X = Scr.ScaleX(.XGRAPH, 1, 3)
PLG(x1).Y = Scr.ScaleY(.YGRAPH, 1, 3)

Else
 ProcCurve = False: MissNumExpr: Exit Function
End If
Else
 ProcCurve = False: MissNumExpr: Exit Function
End If

x1 = x1 + 1
Loop Until Not FastSymbol(rest$, ",")
x1 = x1 - 1
Dim mGDILines As Boolean
'If GDILines Then
'    mGDILines = Not (TypeOf scr Is MetaDc And scr.DrawWidth = 1) And Not .NoGDI
'ElseIf scr.DrawWidth > 1 And Not .NoGDI Then
'    mGDILines = Not TypeOf scr Is MetaDc
'End If
Dim trans As Long
trans = .mypentrans
If .IamEmf Then

   mGDILines = Not .NoGDI And Not ((Scr.DrawStyle > 0 And Scr.DrawWidth = 1) And Not Scr.DrawStyle)
ElseIf GDILines Or (trans < 255) Then
    mGDILines = Not .NoGDI
Else
    mGDILines = Scr.DrawWidth > 1

End If
Dim pencol As Long, bstyle As Long, Col As Long
If .pathfillstyle = 1 And .IamEmf Then mGDILines = False
If mGDILines Then
    pencol = .mypen
    If .pathgdi > 0 Then
        Col = .pathcolor: bstyle = .pathfillstyle
        M2000Pen trans, Col
      
         If trans < 255 And bstyle = 5 Then M2000Pen trans, pencol Else M2000Pen 255, pencol
        If x1 + 4 >= f Then f = f + 4: ReDim Preserve PLG(f)
        PLG(x1 + 1) = PLG(0)
        PLG(x1 + 2) = PLG(0)
        PLG(x1 + 3) = PLG(0)
        PLG(x1 + 4) = PLG(0)
        DrawBezierGdi Scr.Hdc, pencol, Col, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, PLG(), CLng(x1 + 4)
    Else
        DrawBezierGdi Scr.Hdc, pencol, 0, 1, Scr.DrawWidth, Scr.DrawStyle, PLG(), CLng(x1 + 1)
    End If
Else
If PolyBezier(Scr.Hdc, PLG(0), x1 + 1) = 0 Then
BadGraphic
 Exit Function
End If
End If
Scr.FillStyle = vbFSTransparent
End With
MyRefresh bstack
'MyDoEvents1 Scr


End Function
Function ProcSort(basestack As basetask, rest$, Lang As Long) As Boolean
Dim I As Long, s$, sX As Double, sY As Double, pppp As mArray
Dim x1 As Long, y1 As Long, p As Variant, ML As Long, desc As Boolean, numb As Boolean, useclid As Boolean
ProcSort = False
Dim mm As mArray, uHandler As mHandler
desc = IsLabelSymbolNew(rest$, "ÖÈÉÍÏÕÓÁ", "DESCENDING", Lang)
If Not desc Then
    useclid = IsLabelSymbolNew(rest$, "ÁÕÎÏÕÓÁ", "ASCENDING", Lang)
Else
    useclid = True
End If
    y1 = Abs(IsLabel(basestack, rest$, s$))
    If y1 = 1 Then
         If GetVar(basestack, s$, I) Then
                If VarTypeName(var(I)) = "mHandler" Then
                Set uHandler = var(I)
usehandler:
                        If uHandler.ReadOnly Then
                        ReadOnly
                        Exit Function
                        End If
                            If uHandler.T1 = 1 Then
                                If IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then
                                    numb = IsLabelSymbolNew(rest$, "ÁÑÉÈÌÏÓ", "NUMBER", Lang)
                                    If Not numb Then
                                    If Not IsLabelSymbolNew(rest$, "ÊÅÉÌÅÍÏ", "TEXT", Lang) Then
                                    MyEr "Expected Text or Number", "Ðåñßìåíá Êåßìåíï Þ Áñéèìüò"
                                    ProcSort = False
                                    Exit Function
                                    End If
                                    End If
                                    uHandler.objref.NumericSort = numb
                                End If
                                If FastSymbol(rest$, ",") Then
                                    If IsExp(basestack, rest$, p) Then
                                        If FastSymbol(rest$, ",") Then
                                            Set mm = New mArray
                                            mm.PushDim 20, (0)
                                            mm.PushEnd
                                            If Not useclid Then
                                            mm.item(0) = p
                                            y1 = 1
                                            Else
                                            x1 = p
                                            y1 = 0
                                            End If
                                            Do
                                            If IsExp(basestack, rest$, p) Then
                                                mm.item(y1) = p
                                            Else
                                                mm.item(y1) = 0
                                            End If
                                            y1 = y1 + 1
                                            Loop While FastSymbol(rest$, ",")
                                            mm.StartResize
                                            mm.PushDim y1, (0)
                                            mm.PushEnd
                                            mm.ExportArrayNow
                                            With uHandler.objref
                                                .FeedSCol2 mm.refArray
                                                If useclid Then
                                                    .SetBinaryCompare
                                                    .useclid = x1
                                                    If desc Then
                                                        .SortDes
                                                    Else
                                                        .Sort
                                                    End If
                                                    .SetTextCompare
                                                Else
                                                    .useclid = 0
                                                    .Sort
                                                End If
                                                .DisposeCol
                                            End With
                                        Else
                                            With uHandler.objref
                                                If useclid Then
                                                    .SetBinaryCompare
                                                    .useclid = CLng(p)
                                                
                                                        If desc Then
                                                            .SortDes
                                                        Else
                                                            .Sort
                                                        End If
                                                    .SetTextCompare
                                                ElseIf p <> 0 Then
                                                    
                                                    .useclid = 0
                                                    .Sort
                                                Else
                                                
                                                    .useclid = 0
                                                    .SortDes
                                                End If
                                             End With
                                        End If
                                    Else
                                        MissPar
                                        Exit Function
                                    End If

                            Else
                                With uHandler.objref
                                    If desc Then
                                     .useclid = 0
                                     .SortDes
                                    Else
                                    .useclid = 0
                                        .Sort
                                    End If
                                End With
                            End If
                            
                            ProcSort = True
                            ElseIf uHandler.T1 = 3 Then
                            Set pppp = uHandler.objref
useArray:
                            If FastSymbol(rest$, ",") Then
                                  If pppp.bDnum = 2 Then
                                            pppp.GetDnum 0, ML, I
                                            pppp.SerialItem x1, 1, 6
                                            
                                            Set mm = New mArray
                                            
                                            mm.PushDim x1 * 2 + 2, (0)
                                            mm.PushEnd
                                            y1 = 0
                                            Do
                                            If IsExp(basestack, rest$, p) Then
                                            If y1 > 1 And (y1 And 1) = 1 And desc Then
                                                mm.item(y1) = (CLng(p) And 2) + 1 - (CLng(p) And 1) = 1
                                            Else
                                                mm.item(y1) = p
                                                End If
                                            Else
                                                mm.item(y1) = 0
                                            End If
                                            y1 = y1 + 1
                                            Loop While FastSymbol(rest$, ",")
                                            If y1 Mod 2 = 1 Then
                                            y1 = y1 + 1
                                            End If
                                            mm.item(0) = mm.item(0) + I
                                            mm.item(1) = mm.item(1) + I
                                            If y1 = 2 Then
                                            If desc Then
                                            mm.item(2) = 0
                                            mm.item(3) = 1
                                            y1 = 4
                                            End If
                                            
                                            End If
                                            mm.StartResize
                                            mm.PushDim y1, (0)
                                            mm.PushEnd
                                            
                                            'mm.ExportArrayNow
                                            pppp.SortColumns mm.ExportArrayCopy
                                  Else
                                            If IsExp(basestack, rest$, p) Then
                                                x1 = p
                                            Else
                                                x1 = -1
                                            End If
                                            y1 = -1
                                            If FastSymbol(rest$, ",") Then
                                            If IsExp(basestack, rest$, p) Then
                                                y1 = p
                                            End If
                                        If desc Then
                                           pppp.SortDesTuple x1, y1
                                        Else
                                           pppp.SortTuple x1, y1
                                        End If
                                  End If
                                  End If
                                Else
                                        If desc Then
                                           pppp.SortDesTuple
                                        Else
                                           pppp.SortTuple
                                        End If
                                End If
                            ProcSort = True
                            Else
                            MyEr "Expected Inventory", "Ðåñßìåíá ÊáôÜóôáóç"
                            End If
                Else
                   MyEr "Expected Inventory", "Ðåñßìåíá ÊáôÜóôáóç"
                End If
            Else
                   MissFuncParameterStringVar
            End If
    Exit Function
    ElseIf y1 = 5 Then
            If neoGetArray(basestack, s$, pppp) Then
                If pppp.Arr Then
                If FastSymbol(rest$, ")") Then
                GoTo useArray
                End If
                End If
                 If Not NeoGetArrayItem(pppp, basestack, s$, I, rest$) Then Exit Function
                 If pppp.IsStringItem(I) Or pppp.itemnumeric(I) Then
                 MissingArrayOrInventory
                 Exit Function
                 End If
                 If pppp.item(I) Is Nothing Then
                 MissingArrayOrInventory
                 Exit Function
                 End If
                 If TypeOf pppp.itemObject(I) Is mHandler Then
                    Set uHandler = pppp.item(I)
                    GoTo usehandler
                 ElseIf TypeOf pppp.itemObject(I) Is mArray Then
                    Set pppp = pppp.item(I)
                    GoTo useArray
                 End If
                End If
                MissingArrayOrInventory
                Exit Function
                
    ElseIf y1 = 6 Then
                If neoGetArray(basestack, s$, pppp) Then
                If pppp.Arr Then
                If FastSymbol(rest$, ")") Then
                GoTo useArray
                End If
                End If
                
                 If Not NeoGetArrayItem(pppp, basestack, s$, I, rest$) Then Exit Function
                 If pppp.IsStringItem(I) Or pppp.itemnumeric(I) Then
                 MissingDocOrArrayOrInventory
                 Exit Function
                 End If
                 If pppp.item(I) Is Nothing Then
                 MissingDocOrArrayOrInventory
                 Exit Function
                 End If
                 If TypeOf pppp.itemObject(I) Is mHandler Then
                    Set uHandler = pppp.item(I)
                    GoTo usehandler
                 ElseIf TypeOf pppp.itemObject(I) Is mArray Then
                    Set pppp = pppp.item(I)
                    GoTo useArray
                 End If
                Else
                MissingDoc
                Exit Function
                End If
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, sX) Then    ' FROM
            If FastSymbol(rest$, ",") Then
            sX = 1
                GoTo sort2
            Else
                MissNumExpr
                Exit Function
            End If
        End If
    Else
 sX = 1
    End If
    
     If FastSymbol(rest$, ",") Then
sort2:
        If Not IsExp(basestack, rest$, p) Then   ' TO
            If FastSymbol(rest$, ",") Then
            x1 = 0
                GoTo sort3
            Else
                MissNumExpr
                Exit Function
            End If
        End If
        x1 = CLng(p)
     Else
        x1 = 0    ' TO THE LAST
    End If
         If FastSymbol(rest$, ",") Then
sort3:
        If Not IsExp(basestack, rest$, sY) Then   ' TO
                        MissNumExpr
                        Exit Function
        End If
        ML = CLng(sY)
     Else
        ML = 1   ' KEYSTART
    End If
        If y1 = 3 Then
            If GetVar(basestack, s$, I) Then
                If VarTypeName(var(I)) = doc Then
                            If desc Then
                            var(I).SortDocDes ML, CLng(sX), x1
                            Else
                            var(I).SortDoc ML, CLng(sX), x1
                            End If
                            ProcSort = True '*******************************************
                Else
                   MissingDoc
                End If
            Else
                   MissFuncParameterStringVar
            End If
        ElseIf y1 = 6 Then
                    If pppp.ItemType(I) = doc Then
                                If desc Then
                                pppp.item(I).SortDocDes ML, CLng(sX), x1
                                Else
                                pppp.item(I).SortDoc ML, CLng(sX), x1
                                End If
                                ProcSort = True  '*****************************************
                      Else
                                MissingDoc
                      End If
        Else
                    MissPar
        End If

End Function

Function GetData(bstack As basetask, rest$, obj As Object) As Boolean
Dim s$, p As Variant, usehandler As mHandler ', vvl As Variant, photo As Object
Set obj = New mStiva
Dim soros As mStiva
Set soros = obj
GetData = True
Do
    If FastSymbol(rest$, "!") Then
                If IsExp(bstack, rest$, p) Then
                    If bstack.lastobj Is Nothing Then
                        soros.DataValLong p
                    ElseIf TypeOf bstack.lastobj Is mHandler Then
                        Set usehandler = bstack.lastobj
                        If TypeOf usehandler.objref Is mStiva Then
                            soros.MergeBottom usehandler.objref
                        ElseIf TypeOf usehandler.objref Is mArray Then
                            soros.MergeBottomCopyArray usehandler.objref
                        Else
                            GetData = False
                            MyEr "Expected Stack Object or Array after !", "Ðåñßìåíá áíôéêåßìåíï Óùñü Þ ðßíáêá ìåôÜ ôï !"
                            Set bstack.lastobj = Nothing
                            Exit Function
                        End If
                        Set usehandler = Nothing
                        Set bstack.lastobj = Nothing
                    ElseIf TypeOf bstack.lastobj Is mArray Then
                        soros.MergeBottomCopyArray bstack.lastobj
                        Set bstack.lastobj = Nothing
                    End If
                        
                     End If
                ElseIf IsExp(bstack, rest$, p) Then
                  If bstack.lastobj Is Nothing Then
                      soros.DataVal p
                 Else
                   If TypeOf bstack.lastobj Is mStiva Then
                   Set bstack.Sorosref = bstack.lastobj
                   ElseIf TypeOf bstack.lastobj Is VarItem Then
                    soros.DataObjVaritem bstack.lastobj
                      Else
                      If TypeOf bstack.lastobj Is Group Then
                      bstack.lastobj.ToDelete = False
                      End If
                      soros.DataObj bstack.lastobj
                      Set bstack.lastpointer = Nothing
                      
                    End If
                      Set bstack.lastobj = Nothing
                End If
        ElseIf IsStrExp(bstack, rest$, s$, Len(bstack.tmpstr) = 0) Then
                If bstack.lastobj Is Nothing Then
                        soros.DataStr s$
                Else
                        soros.DataObj bstack.lastobj
                        Set bstack.lastobj = Nothing
                          Set bstack.lastpointer = Nothing
                End If
        Else
                GetData = LastErNum1 = 0
                Exit Do
        End If
        If Not FastSymbol(rest$, ",") Then Exit Do
        
Loop
End Function
Function MyWith(bstack As basetask, rest$, Lang As Long) As Boolean
Dim I As Long, ss$, s$, pppp As mArray, pa$, x1 As Long, id, p
MyWith = True
x1 = Abs(IsLabel(bstack, rest$, s$))
If x1 = 1 Or x1 = 3 Then
    If GetVar(bstack, s$, I) Then
            If Not MyIsObject(var(I)) Then BadObjectDecl:  Exit Function
            If Not var(I) Is Nothing Then  ''???
                   Do While FastSymbol(rest$, ",")
                    If Not ss$ = vbNullString Then ss$ = vbNullString
                    If IsExp(bstack, rest$, id) Then
                                        
                    ProcProperty bstack, var(), I, ss$, rest$, Lang, , CLng(id)
                    If LastErNum <> 0 Then MyWith = False: Exit Do
                    ElseIf IsStrExp(bstack, rest$, ss$, Len(bstack.tmpstr) = 0) Then
                    On Error Resume Next

                      ProcProperty bstack, var(), I, ss$, rest$, Lang
                      If Err.Number > 0 Then
                      MyEr "Property " + ss$ + " problem", "Ðñüâëçìá ìå éäéüôçôá " + ss$
                      Err.Clear
                      MyWith = False
                    Exit Do
                      End If
                      MyWith = Err = 0
                      Err.Clear
                    Else
                    MissStringNumber
                    MyWith = False
                    Exit Do
                    End If
                    Loop
                    Exit Function
            Else
                    BadObjectDecl
                    Exit Function
            End If
    Else
    
     Nosuchvariable s$
    End If
ElseIf x1 = 5 Or x1 = 6 Then
  If neoGetArray(bstack, s$, pppp) Then
    If NeoGetArrayItem(pppp, bstack, s$, I, rest$) Then
      Do While FastSymbol(rest$, ",")
                    If Not ss$ = vbNullString Then ss$ = vbNullString
                    If IsExp(bstack, rest$, id) Then
                    ProcPropertyArray bstack, pppp, I, ss$, rest$, Lang, MyWith
                    If LastErNum <> 0 Then MyWith = False: Exit Do
                    
                    ElseIf IsStrExp(bstack, rest$, ss$, Len(bstack.tmpstr) = 0) Then
                    If TypeOf pppp.itemObject(I) Is GuiM2000 Then
                      If UCase(ss$) = "VISIBLE" Then ss$ = "TrueVisible"
                      End If
                  ProcPropertyArray bstack, pppp, I, ss$, rest$, Lang, MyWith
                  If LastErNum1 = -1 Then
                  Exit Do
                  End If
                  If Err.Number > 0 Then
                      MyEr "Property " + ss$ + " problem", "Ðñüâëçìá ìå éäéüôçôá " + ss$
                      Err.Clear
                      MyWith = False
                    Exit Do
                      End If
                      MyWith = Err = 0
                      Err.Clear
                    Else
                    MissStringNumber
                    MyWith = False
                    Exit Do
                    End If
                    Loop
                    Exit Function
           
            
     End If
  Else
      MissingObj
  End If
Else
MissingObj
End If
End Function


Function MyWrite(basestack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, s$, it As Long, par As Boolean, I As Long, skip As Boolean
If IsLabelSymbolNew(rest$, "ÌÅ", "WITH", Lang) Then
    If IsStrExp(basestack, rest$, s$) Then
        csvsep$ = Left$(s$, 1)
        If FastSymbol(rest$, ",") Then If IsStrExp(basestack, rest$, s$) Then csvDec$ = Left$(s$, 1): MyWrite = True
        csvuseescape = False
        If FastSymbol(rest$, ",") Then If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then csvuseescape = CBool(p): MyWrite = True
        If FastSymbol(rest$, ",") Then MyWrite = False: If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then cleanstrings = CBool(p): MyWrite = True
    End If
    Exit Function
End If
MyWrite = True
If csvsep$ = vbNullString Then csvsep$ = ","
If IsLabelSymbolNew(rest$, "ÄÅÊÁÅÎ", "HEX", Lang) Then it = 1
If FastSymbol(rest$, "#") Then

    MyWrite = False
    If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
    skip = p < 0
        On Error Resume Next
    If skip Then
    Dim Scr As Object, prive As basket, basketcode As Long
    Set Scr = basestack.Owner
    basketcode = GetCode(Scr)
    prive = players(GetCode(Scr))
    Else
    I = CLng(p)
    If Fkind(I) = FnoUse Or Fkind(I) = Finput Or Fkind(I) = Frandom Then MyEr "Wrong File Handler", "ËÜèïò ×åéñéóôÞò Áñ÷åßïõ": MyWrite = False: Exit Function
    End If
        
        par = False
        Do While FastSymbol(rest$, ",")

            If IsExp(basestack, rest$, p, , True) Then
                If myVarType(p, 20) Then
                    s$ = CStr(p)
                ElseIf myVarType(p, vbString) Then
                    s$ = LTrim$(p)
                Else
                    s$ = LTrim$(str(p))
                End If
                If it Then
                Else
                If Left$(s$, 1) = "." Then
                    s$ = "0" + s$
                    ElseIf Left$(s$, 2) = "-." Then s$ = "-0" + Mid$(s$, 2)
                End If
            End If
                If par Then
                    If skip Then
                        PlainBaSket Scr, prive, csvsep$
                    ElseIf uni(I) Then
                            putUniString I, csvsep$
                    Else
                            putANSIString I, csvsep$
                           ' Print #i, ",";
                    End If
                End If
                If skip Then
                        If it Then
                            PlainBaSket Scr, prive, PACKLNGUnsign$(p)
                        Else
                            If Len(csvDec$) = 0 Then
                                PlainBaSket Scr, prive, s$
                            Else
                                PlainBaSket Scr, prive, Replace(str$(p), ".", csvDec$)
                            End If
                        End If
                ElseIf uni(I) Then
                        If it Then
                            putUniString I, PACKLNGUnsign$(p)
                        ElseIf Len(csvDec$) = 0 Then
                            putUniString I, s$
                        Else
                            putUniString I, Replace(s$, ".", csvDec$)
                        End If
                Else
                        If Len(csvDec$) = 0 Then
                            putANSIString I, s$
                        Else
                            putANSIString I, Replace(s$, ".", csvDec$)
                        End If
                        
                        If Err.Number > 0 Then Exit Function
                End If
            ElseIf IsStrExp(basestack, rest$, s$, False) Then
            If csvuseescape Then s$ = StringToEscapeStr(s$, False)
                If par Then
                    If skip Then
                        PlainBaSket Scr, prive, csvsep$
                    ElseIf uni(I) Then
                        putUniString I, csvsep$
                    Else
                        putANSIString I, csvsep$

                    End If
                End If
                If Not cleanstrings Then s$ = Replace$(s$, Chr(34), Chr(34) + Chr(34))
                If skip Then
                    PlainBaSket Scr, prive, Chr(34) + s$ + Chr(34)
                ElseIf uni(I) Then
                    If cleanstrings Then
                        putUniString I, s$
                    Else
                        putUniString I, Chr(34) + s$ + Chr(34)
                    End If
                Else
                    If cleanstrings Then
                        putANSIString I, s$
                    Else
                        putANSIString I, Chr(34) + s$ + Chr(34)
                    End If
                    End If
                    If Err.Number > 0 Then Exit Function
            Else
                
                    Exit Function
            End If
            par = True
            If skip Then players(basketcode) = prive
        Loop
        If skip Then
            crNew basestack, prive
        ElseIf uni(I) Then
            putUniString I, vbCrLf
        Else
            putANSIString I, vbCrLf
        End If
        MyWrite = True

    End If
End If
If skip Then players(basketcode) = prive

End Function
Function IsPureLabel(A$, r$) As Long 'ok
Dim rr&, one As Boolean, C$
r$ = vbNullString
If A$ = vbNullString Then IsPureLabel = 0: Exit Function

A$ = NLtrim$(A$)
    Do While Len(A$) > 0
    C$ = myUcase(Left$(A$, 1))
    If AscW(C$) < 256 Then
        Select Case AscW(C$)
        Case 46 '"."
            If one Then
            Exit Do
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1
            Else
            IsPureLabel = 0
            Exit Function
            End If
        Case 65 To 90, 913 To 937, 902, 904, 906, 908, 905, 911, 910, 962 '"A" To "Z", "Á" To "Ù", "¢", "¸", "º", "¼", "¹", "¿", "¾", "ò"
            If one Then
            Exit Do
            Else
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
            
        Case 36 ' "$"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                            If Mid$(A$, 2, 2) = ")@" Then
                                    r$ = r$ + "()."
                                  
                                 A$ = Mid$(A$, 4)
                               Else
                                       Select Case rr&
                                       Case 1
                                       rr& = 5 ' float array or function
                                       Case 3
                                       rr& = 6 'string array or function
                                       Case 4
                                       rr& = 7 ' long array
                                       Case Else
                                       Exit Do
                                       End Select
                                       r$ = r$ + Left$(A$, 1)
                                       A$ = Mid$(A$, 2)
                                   Exit Do
                            
                          End If
               Else
                        Exit Do
            
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If

    Loop
    IsPureLabel = rr&
   A$ = NLtrim$(A$)

End Function
Function GetRealRow(dq As Object) As Long
Dim mybasket As basket
mybasket = players(GetCode(dq))
If mybasket.lastprint Then
GetXYb dq, mybasket, mybasket.curpos, mybasket.currow
End If

 GetRealRow = mybasket.currow
End Function

Function GetRealPos(dq As Object) As Long
Dim mybasket As basket, oldx
mybasket = players(GetCode(dq))
If mybasket.lastprint Then
oldx = dq.currentX
dq.currentX = dq.currentX + mybasket.Xt - dv15
GetXYb dq, mybasket, mybasket.curpos, mybasket.currow
dq.currentX = oldx
End If

 GetRealPos = mybasket.curpos
End Function

Sub ProcWindow(bstack As basetask, rest$, Scr As Object, ifier As Boolean)
Dim x1 As Long, y1 As Long, p As Variant, useScreen As Long
Dim scr1 As GuiImage
If Scr.Name = "GuiM2000" Then
    Scr.ClearTargets
ElseIf Scr.Name = "Form1" Then
    DisableTargets q(), -1
ElseIf Scr.Name = "DIS" Then
    DisableTargets q(), 0
ElseIf Scr.Name = "dSprite" Then
    DisableTargets q(), val(Scr.Index)
Else
    If TypeOf Scr Is GuiImage Then
        Scr.ClearTargets
        Set Scr = Scr.pbox
    ElseIf TypeOf Scr Is VB.PictureBox Then
    On Error Resume Next
        Set scr1 = FindGuiImage(bstack, Scr)
        If Err Or scr1 Is Nothing Then Err.Clear: Exit Sub
        scr1.ClearTargets
    End If
End If
With players(GetCode(Scr))
        If .double Then SetNormal Scr
        .UseDouble = 0
        If IsExp(bstack, rest$, p) Then
            .SZ = p
            If .SZ < 4 Then .SZ = 4
            If FastSymbol(rest$, ",") Then
                If IsExp(bstack, rest$, p) Then
                    x1 = CLng(p)
again:
                    If x1 >= 0 And x1 <= DisplayMonitorCount - 1 And Scr.Name = "DIS" Then
                    Console = x1
                    
                    If Not Form1.WindowState = 0 Then Form1.WindowState = 0: Form1.Refresh
                    
                    If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top
                    If IsWine Then
                        Form1.move ScrInfo(Console).Left, ScrInfo(Console).top
                        If Form1.Width = ScrInfo(Console).Width Then
                        Form1.Width = ScrInfo(Console).Width - 1
                        Else
                        Form1.Width = ScrInfo(Console).Width
                        End If
                        Form1.Height = ScrInfo(Console).Height
                        Form1.move ScrInfo(Console).Left, ScrInfo(Console).top
                    
                    Else
                        Form1.move ScrInfo(Console).Left, ScrInfo(Console).top, ScrInfo(Console).Width, ScrInfo(Console).Height
                    End If
                    FrameText Scr, .SZ, CLng(Form1.Width), CLng(Form1.Height), .Paper
                    players(-1).MAXXGRAPH = Form1.Width ' .MAXXGRAPH
                    players(-1).MAXYGRAPH = Form1.Height '.MAXYGRAPH
                    'If Scr.Name = "Form1" Then SetText Scr
                    Exit Sub
                    
                ElseIf x1 > 3000 Then
                    y1 = CLng(x1 * ScrInfo(Console).Height / ScrInfo(Console).Width)
                ElseIf Scr.Name <> "DIS" Then
                    
                Else
                    x1 = 0
                    GoTo again
                End If
        End If
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = CLng(p)
    End If
    If Scr.Name = "GuiM2000" Then
       Dim aaa As GuiM2000
       Set aaa = Scr
        useScreen = FindMonitorFromMouse
        Set aaa.Picture = LoadPicture("")
               If FastSymbol(rest$, ";") Then 'CENTER
                    aaa.SkipAutoPos = True
                    If x1 >= 0 And x1 < DisplayMonitorCount Then
                        useScreen = x1
                        x1 = aaa.ScaleWidth
                        y1 = aaa.ScaleHeight
                        FrameText Scr, .SZ, x1, y1, .Paper, True
                        aaa.move (ScrInfo(useScreen).Width - .MAXXGRAPH) / 2 + ScrInfo(useScreen).Left, (ScrInfo(useScreen).Height - .MAXYGRAPH) / 2 + ScrInfo(useScreen).top
                    Else
                        FrameText Scr, .SZ, x1, y1, .Paper, True
                        aaa.move (ScrInfo(useScreen).Width - .MAXXGRAPH) / 2 + ScrInfo(useScreen).Left, (ScrInfo(useScreen).Height - .MAXYGRAPH) / 2 + ScrInfo(useScreen).top
                    End If
                    
                Else
                If x1 >= 0 And x1 < DisplayMonitorCount Then
                        useScreen = x1
                        x1 = aaa.ScaleWidth
                        y1 = aaa.ScaleHeight
                        aaa.SkipAutoPos = True
again100:
                        If aaa.Left < ScrInfo(useScreen).Left Then
                            aaa.Left = ScrInfo(useScreen).Left + ScrInfo(useScreen).Width
                        End If
                        If aaa.Left >= ScrInfo(useScreen).Left + ScrInfo(useScreen).Width Then
                            aaa.Left = aaa.Left - ScrInfo(useScreen).Width
                            GoTo again100
                        End If
again101:
                        If aaa.top < ScrInfo(useScreen).top Then
                            aaa.top = ScrInfo(useScreen).top + ScrInfo(useScreen).Height
                        End If
                        If aaa.top >= ScrInfo(useScreen).top + ScrInfo(useScreen).Height Then
                            aaa.top = aaa.top - ScrInfo(useScreen).Height
                            GoTo again101
                        End If
                        
                        aaa.move aaa.Left, aaa.top, x1, y1
                Else
                    If x1 = 0 Then x1 = 14000
                    If y1 = 0 Then y1 = 6000
                    aaa.move aaa.Left, aaa.top, x1, y1
                End If
                    
                    FrameText Scr, .SZ, 0, 0, .Paper, True
                            
            End If
            SetTextSZ Scr, .SZ
    
    ElseIf Scr.Name = "dSprite" Then
            RsetRegion Scr
            Set Scr.Picture = LoadPicture("")
            If FastSymbol(rest$, ";") Then 'CENTER
                        FrameText Scr, .SZ, x1, y1, .Paper, True
                        Scr.move (ScrInfo(Console).Width - .MAXXGRAPH) / 2, (ScrInfo(Console).Height - .MAXYGRAPH) / 2
            Else
                        Scr.move Scr.Left, Scr.top, x1, y1

                        FrameText Scr, .SZ, 0, 0, .Paper, True
                        
            End If
            SetTextSZ Scr, .SZ
    ElseIf TypeOf Scr Is VB.PictureBox And CLng("0" & Scr.Tag) > 33 Then
            Set Scr.Picture = LoadPicture("")
            If FastSymbol(rest$, ";") Then 'CENTER
                        FrameText Scr, .SZ, x1, y1, .Paper, True
                        Scr.move (Scr.Parent.Width - .MAXXGRAPH) / 2, (Scr.Parent.Height - .MAXYGRAPH) / 2
            Else
                        Scr.move Scr.Left, Scr.top, x1, y1

                        FrameText Scr, .SZ, 0, 0, .Paper, True
                        
            End If
            SetTextSZ Scr, .SZ
        
    ElseIf Scr.Name = "Emf" Then
        FastSymbol rest$, ";"
        If x1 <= 0 Then x1 = Scr.Width
        If y1 <= 0 Then y1 = Scr.Height
        Scr.move Scr.Left, Scr.top, x1, y1
        FrameText Scr, .SZ, 0, 0, .Paper, True
        
        Exit Sub
    Else
        If FastSymbol(rest$, ";") Then 'CENTER
            Form1.WindowState = 0
            If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top
            If Scr.Name = "Form1" Then
            If x1 = 0 Then x1 = ScrInfo(Console).Width
            If y1 = 0 Then y1 = ScrInfo(Console).Height
            
            .MAXXGRAPH = x1
            .MAXYGRAPH = y1
            If Scr.Visible Then
                ClearScr Scr, .Paper
            Else
                Scr.BackColor = .Paper
            End If
            Else
            FrameText Scr, .SZ, x1, y1, .Paper
            End If
                    If IsWine Then
                        If .MAXXGRAPH = ScrInfo(Console).Width Then
                        Form1.Width = .MAXXGRAPH - 1
                        Else
                        Form1.Width = .MAXXGRAPH
                        End If
                        Form1.Height = .MAXYGRAPH
                        Form1.move ((ScrInfo(Console).Width - 1) - Form1.Width) / 2 + ScrInfo(Console).Left, ((ScrInfo(Console).Height - 1) - Form1.Height) / 2 + ScrInfo(Console).top
                    Else

            
            Form1.move ScrInfo(Console).Left + (ScrInfo(Console).Width - .MAXXGRAPH) / 2, ScrInfo(Console).top + (ScrInfo(Console).Height - .MAXYGRAPH) / 2, .MAXXGRAPH, .MAXYGRAPH
 
            End If
            Form1.Up
            If Scr.Name <> "Form1" Then
            scrMove00 Scr
            Else
            Scr.currentX = 0
            Scr.currentY = 0
            .curpos = 0
            .currow = 0
            SetText Scr

            End If
            players(-1).MAXXGRAPH = Form1.Width ' .MAXXGRAPH
            players(-1).MAXYGRAPH = Form1.Height '.MAXYGRAPH
            If Form1.Visible Then
                 If form5iamloaded Then
                     Form1.Show , Form5
                 Else
                     Form1.Show
                 End If
             End If
        Else
            Form1.WindowState = 0
            If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top
            If Scr.Name = "Form1" Then
            If x1 = 0 Then x1 = ScrInfo(Console).Width
            If y1 = 0 Then y1 = ScrInfo(Console).Height
            .MAXXGRAPH = x1
            .MAXYGRAPH = y1
            If Scr.Visible Then
                ClearScr Scr, .Paper
            Else
                Scr.BackColor = .Paper
            End If
            Else
            FrameText Scr, .SZ, x1, y1, .Paper
            End If
            If IsWine Then
                If .MAXXGRAPH = ScrInfo(Console).Width Then
                Form1.Width = .MAXXGRAPH - 1
                Else
                Form1.Width = .MAXXGRAPH
                End If
                Form1.Height = .MAXYGRAPH
                Form1.move ScrInfo(Console).Left, ScrInfo(Console).top
            Else
                Form1.move ScrInfo(Console).Left, ScrInfo(Console).top, .MAXXGRAPH, .MAXYGRAPH
            End If
            players(-1).MAXXGRAPH = Form1.Width ' .MAXXGRAPH
            players(-1).MAXYGRAPH = Form1.Height '.MAXYGRAPH
            Form1.Up
            If Scr.Name = "Form1" Then
            Scr.currentX = 0
            Scr.currentY = 0
            .curpos = 0
            .currow = 0
            SetText Scr
            End If
            scrMove00 Scr
            If Form1.Visible Then
                If form5iamloaded Then
                    Form1.Show , Form5
                Else
                    Form1.Show
                End If
            End If
    End If
End If
Else
ifier = False
Exit Sub
End If
''SleepWait 4
End With
End Sub



Sub scrMove00(Scr As Object, Optional ByVal W As Variant, Optional ByVal h As Variant)
If TypeOf Scr Is Form Then
If IsMissing(W) And IsMissing(h) Then
Scr.move ScrInfo(Console).Left, ScrInfo(Console).top
Else
Scr.move ScrInfo(Console).Left, ScrInfo(Console).top, W, h
End If
Else
 If IsMissing(W) And IsMissing(h) Then
Scr.move 0, 0
Else
Scr.move 0, 0, W, h
End If
End If
End Sub
Function MySounds(bstack As basetask, rest$, Lang As Long) As Boolean
MySounds = True
Dim mDir As recDir, s$, ss$, frm$
Set mDir = New recDir
mDir.IncludedFolders = False
mDir.Nofiles = False
mDir.TopFolder = mcd
mDir.SortType = Abs(FastSymbol(rest$, "!"))
frm$ = ExtractNameOnly(mDir.Dir2$(mcd, "WAV", False), True)
s$ = vbNullString
ss$ = vbNullString
Do While frm$ <> ""
s$ = frm$
If ss$ <> "" Then ss$ = ss$ + ", " + s$ Else ss$ = s$
s$ = mDir.Dir2
If s$ <> "" Then frm$ = ExtractNameOnly(s$, True) Else frm$ = vbNullString
Loop
If Lang Then
ss$ = "Sounds: " + ss$
Else
ss$ = "¹÷ïé: " + ss$
End If
Set mDir = Nothing
RepPlain bstack, bstack.Owner, ss$
End Function
Function ProcCat(bstack As basetask, rest$, Lang As Long) As Boolean
Dim aDir As New recDir, ss$, s$, pa$, frm$, par As Boolean, I As Long, Col As Long
aDir.IncludedFolders = True
aDir.Nofiles = True
aDir.TopFolder = mcd
aDir.LevelStop = 1
aDir.SortType = Abs(FastSymbol(rest$, "!")) + Abs(FastSymbol(rest$, "!"))
ProcCat = True
s$ = vbNullString
pa$ = vbNullString

par = Lang = 1
I = FastSymbol(rest$, "+")
If FastSymbol(rest$, "*") Then
ss$ = "*"
ElseIf Not IsStrExp(bstack, rest$, ss$) Then
ss$ = vbNullString
Else
ss$ = myUcase(ss$)
End If
''stac1 = VbNullString

If InStr(ss$, "?") > 0 Or InStr(ss$, "*") > 0 Then
aDir.Pattern = ss$
frm$ = mylcasefILE$(aDir.Dir2$(mcd, "", False))

Else
frm$ = mylcasefILE$(aDir.Dir2$(mcd, ss$, False))

End If

If I = False Then
    If frm$ <> "" Then
        If par Then
            pa$ = "Folders " + ss$ + ": "
        Else
            pa$ = "ÊáôÜëïãïé " + ss$ + ": "
        End If
    End If
End If
ss$ = vbNullString
Col = Len(mcd)
Do While frm$ <> ""
MyDoEvents
s$ = Mid$(frm$, Col + 2)
If s$ <> "" Then
If I Then
Form1.List1.AddItem s$
Else
If InStr(s$, " ") > 0 Then s$ = Chr(34) + s$ + Chr(34)
If ss$ <> "" Then ss$ = ss$ + ", " + s$ Else ss$ = s$
End If
End If
s$ = aDir.Dir2
If s$ <> "" Then frm$ = s$ Else frm$ = vbNullString
Loop
If I = False Then RepPlain bstack, bstack.Owner, pa$ + ss$

End Function
Function ProcFiles(bstack As basetask, rest$, Lang As Long) As Boolean
Dim aDir As New recDir, ss$, pa$, s$, par As Boolean, stac1 As String, frm$, I As Long
Dim addext As Boolean, addpath As Boolean, p As Variant
ProcFiles = True
aDir.IncludedFolders = False
aDir.Nofiles = False
aDir.TopFolder = mcd
aDir.SortType = Abs(FastSymbol(rest$, "!")) + Abs(FastSymbol(rest$, "!"))

s$ = vbNullString
pa$ = vbNullString

par = Lang = 1
I = FastSymbol(rest$, "+")
If FastSymbol(rest$, "*") Then
ss$ = "*"
ElseIf Not IsStrExp(bstack, rest$, ss$) Then
ss$ = "TXT"
Else
ss$ = myUcase(ss$)
End If
stac1 = vbNullString
If FastSymbol(rest$, ",") Then
' SEARCH INSIDE FILE
If Not IsStrExp(bstack, rest$, stac1$) Then
If Not IsExp(bstack, rest$, p) Then
SyntaxError: Exit Function
Else
Select Case p
Case 1
addext = True
Case 2
addext = True
addpath = True
Case Else
MyEr "Not defined yet", "äåí Ý÷åé ïñéóôåß áêüìá"
ProcFiles = False
Exit Function
End Select
End If
End If
End If
If I <> 0 Then addpath = False
If InStr(ss$, "?") > 0 Or InStr(ss$, "*") > 0 Then
    aDir.Pattern = ss$
    frm$ = mylcasefILE$(aDir.Dir2$(mcd, "", False))
Else
    frm$ = mylcasefILE$(aDir.Dir2$(mcd, ss$, False))
End If

If I = False Then
    If frm$ <> "" Then
        If par Then
            If stac1 <> "" Then
            pa$ = "Files " + Replace(ss$, "|", ", ") + " with text " + Chr(34) + stac1 + Chr(34) + " :  "
            Else
            pa$ = "Files " + Replace(ss$, "|", ", ") + ": "
            End If
        Else
            If stac1 <> "" Then
            pa$ = "Áñ÷åßá " + Replace(ss$, "|", ", ") + " ìå êåßìåíï " + Chr(34) + stac1 + Chr(34) + " :  "
            
            Else
            pa$ = "Áñ÷åßá " + Replace(ss$, "|", ", ") + ": "
            End If
        End If
    End If
Else
   ' Form1.List2.clear
End If
If InStr(ss$, "|") > 0 Then addext = True
ss$ = vbNullString
Do While frm$ <> ""
MyDoEvents
If NOEXECUTION Then Exit Do
If Right$(" " + aDir.Pattern, 1) <> "*" And InStr(" " + aDir.Pattern, "|") = 0 Then
    If addext Then
        If addpath Then
            s$ = Included(mcd + frm$, stac1)
            If LastErNum1 <> 0 Then Exit Function
            If s$ <> "" Then s$ = mcd + s$
        Else
            s$ = ExtractName(Included(mcd + frm$, stac1), True)
            If LastErNum1 <> 0 Then Exit Function
        End If
    Else
        s$ = ExtractNameOnly(Included(mcd + frm$, stac1), True)
    If LastErNum1 <> 0 Then Exit Function
    End If
Else
If addpath Then
            s$ = Included(mcd + frm$, stac1)
            If LastErNum1 <> 0 Then Exit Function
            If s$ <> "" Then s$ = mcd + s$
Else
   s$ = Included(mcd + frm$, stac1)
   If LastErNum1 <> 0 Then Exit Function
   End If
End If
If s$ <> "" Then
If I Then
If Right$(" " + aDir.Pattern, 1) <> "*" Then
Form1.List1.AddItem s$
Else
Form1.List1.AddItem s$
End If
Else

If ss$ <> "" Then ss$ = ss$ + ", " + s$ Else ss$ = s$
End If
End If
s$ = aDir.Dir2
If s$ <> "" Then frm$ = s$ Else frm$ = vbNullString
Loop
If I = False Then
RepPlain bstack, bstack.Owner, pa$ + ss$
End If
End Function
Sub RepPlain(bstack As basetask, Scr As Object, txt$)
Dim prive As Long
prive = GetCode(Scr)
If players(prive).curpos > 0 Then crNew bstack, players(prive)
wwPlain2 bstack, players(prive), txt$, Scr.Width, 100000, True
If players(prive).curpos > 0 Then crNew bstack, players(prive)
End Sub

Function MyModules(bstack As basetask, rest$, Lang As Long) As Boolean
Dim frm$, s$, pa$, ss$, mDir As recDir, showlocal As Boolean, I As Long, Filter$, filter2$
Dim A() As String, aa() As String
showlocal = FastSymbol(rest$, "?")
LastErNum = 0
 If IsStrExp(bstack, rest$, Filter$, False) Then
Filter$ = myUcase(Filter$, True)
If Left$(Filter$, 1) <> "*" Then Filter$ = Filter$ + "*"
If FastSymbol(rest$, ",") Then
If IsStrExp(bstack, rest$, filter2$, False) Then
If filter2$ <> vbNullString Then filter2$ = myUcase(filter2$, True)
ElseIf LastErNum Then
    Exit Function
End If
End If
ElseIf LastErNum Then
    Exit Function
End If
MyModules = True
frm$ = subHash.ShowRev    ' Mid$(SubName$, 2)
s$ = vbNullString
pa$ = vbNullString

Do While ISSTRINGA(frm$, s$)

If pa$ <> "" Then
    If InStrRev(s$, ") ") > 0 Then
    ss$ = FixName(Left$(s$, InStrRev(s$, ")")))
        If SecureNames Then
            A() = Split(ss$, "».")
            If UBound(A()) = 1 Then
                A(0) = GetName(A(0))
                s$ = Join(A(), ".")
            End If
            aa() = Split(ss$, ".")
            If UBound(aa()) = 1 Then
            aa(0) = sbf(val(Mid$(aa(0), 2))).goodname
            ss$ = Join(aa(), ".")
            End If
            
        End If
    If Len(Filter$) > 0 Then
    If ss$ Like Filter$ Then
        If Len(filter2$) > 0 Then
            If InStr(myUcase(sbf(val(Mid$(s$, InStrRev(s$, ")") + 1))).sb, True), filter2$) > 0 Then
                pa$ = pa$ + ", " + ss$
            End If
        Else
            pa$ = pa$ + ", " + ss$
        End If
    End If
    Else
    pa$ = pa$ + ", " + ss$
    End If
    ElseIf InStrRev(s$, " ") > 0 Then
    ss$ = FixName(Left$(s$, InStrRev(s$, " ") - 1))
    If SecureNames Then
            A() = Split(ss$, "».")
            If UBound(A()) = 1 Then
                A(0) = GetName(A(0))
                s$ = Join(A(), ".")
            End If
            aa() = Split(ss$, ".")
            If UBound(aa()) = 1 Then
            aa(0) = sbf(val(Mid$(aa(0), 2))).goodname
            ss$ = Join(aa(), ".")
            End If
            
        End If
    
    
    If Len(Filter$) > 0 Then
        If ss$ Like Filter$ Then
            If Len(filter2$) > 0 Then
            If InStr(myUcase(sbf(val(Mid$(s$, InStrRev(s$, " ") + 1))).sb, True), filter2$) > 0 Then
                pa$ = pa$ + ", " + ss$
            End If
            Else
                pa$ = pa$ + ", " + ss$
            End If
        End If
    Else
    pa$ = pa$ + ", " + ss$
    End If
    End If
Else
    If InStrRev(s$, ") ") > 0 Then
    pa$ = FixName(Left$(s$, InStrRev(s$, ")")))
    If Len(Filter$) > 0 Then
        If Not pa$ Like Filter$ Then
        pa$ = vbNullString
        ElseIf Len(filter2$) > 0 Then
            If Not InStr(myUcase(sbf(val(Mid$(s$, InStrRev(s$, ")") + 1))).sb, True), filter2$) > 0 Then
                pa$ = vbNullString
            End If
        End If
    End If
    ElseIf InStrRev(s$, " ") > 0 Then
    pa$ = FixName(Left$(s$, InStrRev(s$, " ") - 1))
    If Len(Filter$) > 0 Then
        If Not pa$ Like Filter$ Then
            pa$ = vbNullString
        ElseIf Len(filter2$) > 0 Then
            If Not InStr(myUcase(sbf(val(Mid$(s$, InStrRev(s$, " ") + 1))).sb, True), filter2$) > 0 Then
                pa$ = vbNullString
            End If
        End If
    End If
    End If
End If
Loop
ss$ = vbNullString
If pa$ <> "" Or Len(Filter$) > 0 Or Len(filter2$) > 0 Then
If here$ <> vbNullString Then If showlocal Then GoTo ponly
If pa$ <> "" Then
If Lang Then

pa$ = "In Memory: " + pa$ + vbCrLf + "        Use REMOVE to remove the right most, EDIT module_name to edit"
Else
pa$ = "Óôç ÌíÞìç: " + pa$ + vbCrLf + "        Ìå ôç ÄÉÁÃÑÁÖÇ èá óâÞóåéò ôï ôåëåõôáßï, ìå ÓÕÃÃÑÁÖÇ Þ Ó üíïìá_ôìÞìáôïò èá ãñÜøåéò"
End If
End If
If here$ = vbNullString Then If showlocal Then GoTo ponly
End If


Set mDir = New recDir
mDir.IncludedFolders = False
mDir.Nofiles = False
mDir.TopFolder = mcd
mDir.SortType = Abs(FastSymbol(rest$, "!"))
frm$ = ExtractNameOnly(mDir.Dir2$(mcd, "GSB|GSB1", False), True)

If frm$ <> "" Then
If pa$ <> "" Then pa$ = pa$ + vbCrLf
If Lang Then
pa$ = pa$ + "On Disk: "
Else
pa$ = pa$ + "Óôïí Äßóêï: "
End If
End If
ss$ = vbNullString
Do While frm$ <> ""
s$ = frm$
If ss$ <> "" Then ss$ = ss$ + ", " + s$ Else ss$ = s$
s$ = mDir.Dir2
If s$ <> "" Then frm$ = ExtractNameOnly(s$, True) Else frm$ = vbNullString

Loop
Set mDir = Nothing
pa$ = pa$ + ss$
If ss$ <> "" Then
If here$ = vbNullString Then
If Lang Then
pa$ = pa$ + vbCrLf + Replace$("        Use LOAD 'module_name' to load, EDIT 'module_name.gsb' to edit on disk", "'", Chr(34))
If IsSupervisor Then pa$ = pa$ + ", WIN DIR$ for folders tasks"
Else
pa$ = pa$ + vbCrLf + Replace$("        Ìå ÖÏÑÔÙÓÅ ïíïìá_ôìçìáôïò öïñôþíåéò óôç ìíÞìç, ìå Ó Þ ÓÕÃÃÑÁÖÇ 'ïíïìá_ôìçìáôïò.gsb' äéïñèþíåéò óôï äßóêï", "'", Chr(34))
If IsSupervisor Then pa$ = pa$ + ", ìå ÓÕÓÔÇÌÁ ÊÁÔ$ áíïßãåéò ôïí êáôÜëïãï ìå ôá áñ÷åßá ãéá åñãáóßåò"
End If
End If
End If
' PRINT ONLY
ponly:
RepPlain bstack, bstack.Owner, pa$

End Function
Function FixName(s$) As String
Dim A() As String
If SecureNames Then
A() = Split(s$, "».")
If UBound(A()) = 1 Then
A(0) = GetName(A(0))
FixName = Join(A(), ".")
Else
FixName = s$
End If
Else
FixName = s$
End If

End Function

Function MyIcon(basestack As basetask, rest$) As Boolean
Dim s$, aPic As StdPicture, p, anyObj As Object, ok As Boolean
On Error Resume Next
    Dim aa As New cDIBSection
    If IsStrExp(basestack, rest$, s$) Then
        If CFname$(s$) <> "" Then
            s$ = CFname$(s$)
            Set aPic = LoadPicture(GetDosPath(s$))
            If aPic Is Nothing Then Exit Function
            ok = True
            If FileLen(GetDosPath(s$)) > 4000 Then
                aa.CreateFromPicture LoadMyPicture(GetDosPath(s$), True, &H3B3B3B)
                AskDIBicon$ = DIBtoSTR(aa)
            Else
                AskDIBicon$ = ""
            End If
        End If
    ElseIf IsExp(basestack, rest$, p) Then
    If basestack.lastobj Is Nothing Then
    If p = 0 Then
        AskDIBicon$ = ""
        If Not UseMe Is Nothing Then
        Err.Clear
        Set aPic = UseMe.GetAppIcon
        If Not Err Then
        aa.BackColor = &H3B3B3B
        aa.CreateFromPicture aPic
        AskDIBicon$ = DIBtoSTR(aa)
        
        Else
        Set aPic = Form3.icon
        End If
        Else
        Set aPic = Form3.icon
        End If
        
    Else
        Set aPic = Form3.icon
    End If
    
    ok = True
    ElseIf TypeOf basestack.lastobj Is mHandler Then
            Set anyObj = GetObjFromHandler(basestack.lastobj, ok)
            If ok Then
                Dim mm As MemBlock
                If Typename(anyObj) = "MemBlock" Then
                    Set mm = anyObj
                    mm.SubType = 30
                    aa.CreateFromPicture mm.GetStdPicture(, , &H3B3B3B)
                        ' aa.CreateFromPicture mm.GetStdPicture1(, , &H3B3B3B)  ' smooth
                    AskDIBicon$ = DIBtoSTR(aa)
                    mm.SubType = 300
                    Set aPic = mm.GetStdPicture()
                Else
                    AskDIBicon$ = ""
                    Set aPic = anyObj
                End If
                MyIcon = True
            Else
                MyEr "No icon found", "Äåí âñÞêá åéêüíá"
                Exit Function
            End If
        Else
            If Not Form3AppIcon Is Nothing Then
                Set aPic = Form3AppIcon
            Else
                Set aPic = Form2.icon
            End If
        End If
    Else
        If Not Form3AppIcon Is Nothing Then
            Set aPic = Form3AppIcon
        Else
            Set aPic = Form2.icon
        End If
    End If
    If Not UseMe Is Nothing Then
        PlaceIcon aPic
        Set Form3AppIcon = aPic
    Else
        Set Form3AppIcon = aPic
    End If
    Set Form1.icon = aPic
    Set basestack.lastobj = Nothing
    Set basestack.lastpointer = Nothing
    MyIcon = ok
End Function
Private Function GetObjFromHandler(vv As Object, ok As Boolean) As Object
Dim mh As mHandler, vIndex As Long
If TypeOf vv Is mHandler Then
    Set mh = vv
    If mh.indirect >= 0 Then
    vIndex = mh.indirect
    If var2used < mh.indirect Then
    MyEr "weak reference out of scope", "ç áíáöïñÜ åßíáé åêôüò óêïðïý"
    ok = False
    Exit Function
    End If
    
    Set GetObjFromHandler = var(mh.indirect)
    ok = True
    Else
    Set GetObjFromHandler = mh.objref
    ok = True
    End If
End If
End Function

Function ProcTitle(basestack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, s$
If Form1.Visible Then Form1.TrueVisible = True
If IsStrExp(basestack, rest$, s$) Then
    
If FastSymbol(rest$, ",") Then
    If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
        
        If p = 0 Then
            If LenB(s$) = 0 Then
                If Not UseMe Is Nothing Then
                    If Not UseMe.IhaveExtForm Then
                        UseMe.Hide
                    Else
                        Form1.CaptionW = vbNullString
                        Form3.CaptionWsilent = vbNullString
                        Form3.WindowState = 1
                        Unload Form3
                        PlaceCaption ""
                    End If
                Else
                    Form1.CaptionW = vbNullString
                    Form3.CaptionWsilent = vbNullString
                    Form3.WindowState = 1
                    Unload Form3
                End If
            ElseIf Not UseMe Is Nothing Then
                If UseMe.IhaveExtForm Then
                    PlaceCaption s$
                Else
                    Form3.CaptionWsilent = s$
                    Form3.CaptionW = s$
                    Form1.CaptionW = vbNullString
                    Form3.WindowState = 1
                End If
            Else
                Form3.CaptionWsilent = s$
                Form3.CaptionW = s$
                Form1.CaptionW = vbNullString
                Form3.WindowState = 1
            End If
            
            If Not ttl Or Not UseMe Is Nothing Then
                
                Form1.Visible = False
                If s$ <> "" Then
                    Form1.CaptionW = s$
                Else
                    Form1.CaptionW = "M2000"
                End If
            Else
                If Not Form3.WindowState = 1 Then
                        If Not Form3.Visible Then
                        Form1.TrueVisible = Form1.Visible
                        Form1.Visible = False
                        If LenB(s$) = 0 Then
                        'Unload Form3: ttl = False
                        End If
                        ProcTitle = True
                        Exit Function
                        End If
                        
                        Form3.move VirtualScreenWidth() + 2000, VirtualScreenHeight() + 2000
                        Form3.skiptimer = True
                        Form3.WindowState = 1
                        Form1.TrueVisible = Form1.TrueVisible Or Form1.Visible
                        Form1.Visible = False
                        ProcTitle = True
                        Exit Function
                        
                   End If
            End If
      
                   
        Else
NormalState:
        
        
         
        If UseMe Is Nothing Then
         If LenB(s$) = 0 Or Not Form1.Visible Then ProcTitle = True: Exit Function
            If Not ttl Then
            Load Form3
            If Form3.WindowState = 1 Then Form3.skiptimer = False: Form3.WindowState = 0
            Form3.move VirtualScreenWidth() + 2000, VirtualScreenHeight() + 2000: ttl = True
            
            End If
            Form3.Timer1.Interval = 30
            Form3.Timer1.enabled = False
            Form3.CaptionW = s$
            Form1.CaptionW = vbNullString
                Form1.TrueVisible = True
                If Not Form3.WindowState = 0 Then
                    Form3.Visible = True
                    
                    Form3.WindowState = 0
    
                        End If
        ElseIf UseMe.IhaveExtForm Then
        
           
            PlaceCaption s$
'            UseMe.Show
        If s$ <> vbNullString Then
        'Form3.Timer1.Interval = 30
        '    Form3.Timer1.enabled = True
         '   Form3.CaptionWsilent = s$
        '    Form3.CaptionW = s$
         '   Form1.CaptionW = vbNullString
            Form3.WindowState = 0
        End If
        Else
        If s$ <> vbNullString Then
        Form3.Timer1.Interval = 30
            Form3.Timer1.enabled = True
           Form3.CaptionWsilent = s$
            Form3.CaptionW = s$
            Form1.CaptionW = vbNullString
            Form3.WindowState = 0
        Else
         Form1.CaptionW = vbNullString
           Form3.CaptionWsilent = s$
           Form3.WindowState = 1
        End If
        
        
        
        End If
          
                mywait basestack, 100
             
             
             
             End If
        ProcTitle = True
        Exit Function
    Else
        ProcTitle = False
    End If
Else
    If Not UseMe Is Nothing Then UseMe.Show
    GoTo NormalState
End If
Else
    If UseMe Is Nothing Then
            If ttl Then
                Unload Form3
                ttl = False
            End If
    Else
    If Not UseMe.IhaveExtForm Then
            If ttl Then
                Unload Form3
                ttl = False
            End If
    End If
            UseMe.SetExtCaption ""
            'Form1.CaptionW = "M2000"
    End If
End If
ProcTitle = True
End Function
Public Function myRegister(tp$) As String
If strTemp = vbNullString Then SetTmpPath
    
Dim I As Long
I = FreeFile
Open strTemp + "tmp." + tp$ For Output As I
Print #I, "test"
Close I
' found me
Dim rl$
rl$ = PCall(strTemp + "tmp." + tp$)
If rl$ <> "" Then
rl$ = GetStrUntil(Chr(34), rl$)
End If
Sleep 10
KillFile strTemp + "tmp." + tp$
myRegister = Trim$(rl$)
End Function
Public Function MyShell(ww$, Optional way As VbAppWinStyle = vbNormalFocus, Optional param As String = vbNullString) As Long
Dim frm$, exst As Boolean, pexist As Boolean, pp$, EXE$, ret As Long
' logic

On Error GoTo 11111
If Is64bit Then Wow64EnableWow64FsRedirection False
again:
If ExtractType(ww$) <> "" Then

frm$ = ExtractPath(ww$) + ExtractName(ww$)
param = RTrim$(Mid$(ww$, Len(frm$) + 1) + " " + param)
ww$ = frm$
ElseIf ExtractPath(ww$) = vbNullString Then
Dim I As Long, j As Long
I = InStr(ww$, Chr(34))
j = InStrRev(ww$, Chr(34))
If j > I Then
param = Mid$(ww$, I, j - I + 1)
ww$ = Left$(ww$, I - 1)
End If

End If
If ww$ = vbNullString Then
If param <> "" Then
ret = Shell(Trim$(param), way)
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
End If
End If
If ExtractPath(ww$) = mylcasefILE(ww$) Then
' it is a path
ww$ = "a.@@@ " + ww$
Else
frm$ = CFname(ww$)
If ExtractName(frm$) <> ExtractName(ww$) Then
On Error Resume Next

EXE$ = Trim$(ww$)
ret = ShellExecute(0, 0, StrPtr(EXE$), StrPtr(param), 0, way)

If Err.Number > 0 Then

Err.Clear
ww$ = PathFromApp(ww$)
If ww$ <> "" Then
EXE$ = Trim$(ww$)
ret = ShellExecute(0, 0, StrPtr(EXE$), StrPtr(param), 0, way)
End If
End If
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
End If
If CFname(ww$) <> "" Then ww$ = frm$: exst = True

pp$ = ExtractPath(ww$)
End If
If pp$ <> "" Then
pexist = True
ww$ = Mid$(ww$, Len(pp$) + 1)
End If
ww$ = ww$ + " "
EXE$ = vbNullString
If InStr(ww$, ".") > InStr(ww$, " ") Then
EXE$ = Left$(ww$, InStr(ww$, "."))
ww$ = Mid$(ww$, Len(EXE$) + 1)
End If
ww$ = ww$ + " "
EXE$ = EXE$ + Trim$(GetStrUntil(" ", ww$))
' until now we have all things splitted
EXE$ = mylcasefILE(EXE$)
' until now we have all things splitted
Select Case ExtractType(EXE$)
Case ""
If pexist Then
' this is not normal
' ***************ERROR*************
Else
' so we put exe by default
EXE$ = EXE$ + ".exe"
frm$ = PathFromApp(Trim$(EXE$ + " " + ww$))
If frm$ <> "" Then
ret = Shell(frm$, way)
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
Else
ret = Shell(Trim$(EXE$ + " " + ww$ + " " + param), way)
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
End If
End If
Case "exe", "bat", "com" ' can be run immediatly
If pexist Then
EXE$ = pp$ + EXE$
If param <> "" Then

If Form1.Visible And way = vbNormalFocus Then
ret = ShellExecute(Form1.hWnd, 0, StrPtr(EXE$), StrPtr(param), StrPtr(pp$), way)
Else
ret = ShellExecute(0, 0, StrPtr(EXE$), StrPtr(param), StrPtr(pp$), way)
End If
Else
If Form1.Visible And way = vbNormalFocus Then
ret = ShellExecute(Form1.hWnd, 0, StrPtr(EXE$), 0, StrPtr(pp$), way)
Else
ret = ShellExecute(0, 0, StrPtr(EXE$), 0, StrPtr(pp$), way)
End If

End If
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
Else
frm$ = PathFromApp(Trim$(EXE$ + " " + ww$))
If frm$ <> "" Then
ret = Shell(frm$, vbNormalFocus)
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
Else
ret = Shell(Trim$(EXE$ + " " + ww$), way)
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
End If
End If
Case "@@@"
'ret =Shell(RTrim$("explorer " & ww$), way)
EXE$ = "explorer"
If Form1.Visible Then
ret = ShellExecute(Form1.hWnd, 0, StrPtr(EXE$), StrPtr(ww$), 0, way)
Else
ret = ShellExecute(0, 0, StrPtr(EXE$), StrPtr(ww$), 0, way)
End If
If Is64bit Then Wow64EnableWow64FsRedirection True
Case Else ' its a document
If InStr(pp$, "file://") > 0 Then
pp$ = Replace$(pp$, "file://", "")
Else
pp$ = Replace$(pp$, "file:", "")
End If
frm$ = PCall(pp$ + EXE$)
If frm$ <> "" Then
If AscW(frm$) = 34 Then
frm$ = frm$ + "@"
frm$ = Replace$(frm$, Chr(34) + "@", " " + param + Chr(34))
frm$ = Replace$(frm$, "@", "")
ret = Shell(Trim$(frm$), way)
Else
frm$ = PCall(pp$ + EXE$, param)

ww$ = frm$ + " " + ww$
GoTo again
End If
If Is64bit Then Wow64EnableWow64FsRedirection True
Exit Function
Else
End If
If Is64bit Then Wow64EnableWow64FsRedirection True
End Select
On Error Resume Next
11111:
ret = 0
' its a document
End Function
Function newStart(basestack As basetask, rest$) As Boolean
Dim Scr As Object, s$, pa As Long, r, mycoder As New coder
If HaltLevel > 0 Then rest$ = vbNullString: Exit Function
    If Not basestack.IamChild And Not basestack.IamAnEvent Then
        If IsNumber(basestack, rest$, r, True) Then
            If r = 0 Then
                If UseMe Is Nothing Then Beep: newStart = True: Exit Function
                If UseMe.IhaveExtForm Then
                    rest$ = UseMe.code + vbCrLf + "END"  ' mycoder.must()
                End If
                newStart = True
                Exit Function
            End If
        End If
        If Check2Save Then
        newStart = True
            Exit Function
        End If
End If
Check2SaveModules = False
MyEr "", ""
NOEXECUTION = False
MOUT = False
byPassCallback = False
EditTabWidth = 4
tParam.cbSize = LenB(tParam)
tParam.iTabLength = 4
ReportTabWidth = 8
HaltLevel = -HaltLevel
newStart = True
Set Scr = basestack.Owner
SetNormal Scr
Targets = False
ReDim q(0) As target
Dim zero As basket, I As Long, zerocounter As Counters
For I = -2 To 1000
    players(I) = zero
    Prefresh(I) = zerocounter
Next I
Scr.ForeColor = mycolor(11)
basestack.myBold = False
basestack.myitalic = False
pa = 0

            Err.Clear
            On Error Resume Next
If IsStrExp(basestack, rest$, s$) Then
            If s$ <> "" And s$ <> "*" Then MyFont = s$ Else MyFont = Scr.Font.Name
      
                Scr.Font.charset = 0
                Scr.Font.Name = MyFont
               If Not myLcase(MyFont) = myLcase(Scr.Font.Name) Then
               Scr.Font.charset = 1
               Scr.Font.Name = MyFont
               End If
               Sleep 1

                Scr.Font.charset = basestack.myCharSet
                    Form1.TEXT1.Font.charset = basestack.myCharSet

    Form1.List1.Font.charset = basestack.myCharSet

                Scr.FontBold = False
                Scr.FontItalic = False
            If Err.Number > 0 Then
                Err.Clear
                Scr.Font.Name = FFONT
                Scr.Font.charset = basestack.myCharSet
            End If
        StoreFont Scr.Font.Name, Scr.FontSize, Scr.Font.charset
        
        SetText Scr, -2, True
            s$ = vbNullString
            If FastSymbol(rest$, ",") Then
             
            If IsStrExp(basestack, rest$, s$) Then
            'rest$ = s$ & "}" & rest$
            If s$ <> "" Then s$ = ": " + s$ + "}"
            ElseIf FastSymbol(rest$, "{") Then
            s$ = ": " + block(rest$)
            If Not FastSymbol(rest$, "}") Then Set Scr = Nothing: newStart = False: Exit Function
                End If
                End If
            original Basestack1, s$  ' set...
            
Else
    MyEr "", ""
    closeAll ' we closed all files
    If AVIRUN Then MediaPlayer1.stopMovie
    PlaySoundNew ""
    
    If basestack.toprinter Then
    getnextpage
    End If
    Set Scr = Form1.DIS
  
    Form1.myBreak basestack
    basestack.toprinter = False
    players(DisForm).mypen = mycolor(PenOne)
    players(DisForm).mypentrans = 255
    players(DisForm).Paper = mycolor(PaperOne)
    players(DisForm).ReportTab = ReportTabWidth
    Form1.Cls
    original Basestack1, ""
    MyNew Basestack1, "", 1
    MyClear Basestack1, ""

    basestack.soros.Flush

End If

End Function
Sub newHide(basestack As basetask)
Dim Scr As Object
Set Scr = basestack.Owner
If Scr.Name = "DIS" Or Scr.Name = "dSprite" Then
Scr.Visible = False
End If
MyRefresh basestack
'MyDoEvents1 Scr
Set Scr = Nothing
End Sub



Sub newshow(bstack As basetask)
On Error Resume Next
Dim Scr As Object
Set Scr = bstack.Owner
If Scr.Name = "DIS" Or Scr.Name = "dSprite" Then
If Not Form1.Visible And Form1.TrueVisible Then
If UseMe Is Nothing Then
Form3.skiptimer = True
Form3.Visible = True: If Form3.WindowState = 0 Then Form3.move VirtualScreenWidth() + 2000, VirtualScreenHeight() + 2000
mywait Basestack1, 100
Form3.CaptionWsilent = ExtractNameOnly(cLine)
Else
If UseMe.AppTitle = vbNullString Then
PlaceCaption ExtractNameOnly(cLine)
Else
PlaceCaption UseMe.AppTitle
End If
If Err.Number > 0 Then
Err.Clear: Set UseMe = Nothing
Form3.skiptimer = True
Form3.Visible = True: If Form3.WindowState = 0 Then Form3.move VirtualScreenWidth() + 2000, VirtualScreenHeight() + 2000
mywait Basestack1, 100
Form3.CaptionWsilent = ExtractNameOnly(cLine)
End If
Exit Sub
End If
End If
If Form1.Visible = False Then
conthere:
    If ttl Then
        If Form3.WindowState = 1 Then
           Form1.Visible = True
            Form3.skiptimer = True
            Form3.Visible = True
            Form3.skiptimer = True
            Form3.WindowState = 0
              
            Do While Not Form1.Visible Or NOEXECUTION
                mywait bstack, 1
                Sleep 10
            Loop
            If Form3.WindowState = 0 Then Form3.move VirtualScreenWidth() + 2000, VirtualScreenHeight() + 2000
            Form3.Timer1.Interval = 20
            Form3.Show
            Sleep 50
            Form3.CaptionW = vbNullString
            PlaceCaption ""
            If Form3.Visible Then Form3.Refresh
            MyDoEvents1 Form3, True
            mywait bstack, 50
        Else
         
        End If
    Else
        Form1.Show , Form5
        mywait bstack, 5
    End If
Else
    If ttl Then
    ' we have title
        If Form3.WindowState = 1 Then
        Form3.Visible = True: Form3.WindowState = 0: If Form3.WindowState = 0 Then Form3.move VirtualScreenWidth() + 2000, VirtualScreenHeight() + 2000
            Do While Not Form1.Visible Or NOEXECUTION
           mywait bstack, 5
                Loop
        End If
    Else
     Form1.Show , Form5
     mywait bstack, 5
    End If
End If
If Typename(Scr) = "PictureBox" Then
If Scr.Parent.Visible = False Then
Scr.Parent.Visible = True
mywait bstack, 5
End If
End If
    Scr.Visible = True
        Do While Not Scr.Visible And Not NOEXECUTION
mywait bstack, 5
Scr.Visible = True
        Loop
If Scr.Visible Then
Scr.SetFocus

End If
End If
Set Scr = Nothing
End Sub

Sub getfirstpage()
Dim try1 As Long
If UBound(MyDM) = 1 Then
PrinterDim pw, ph, psw, psh, pwox, phoy
End If

'If pwox > phoy Then mydpi = phoy Else mydpi = pwox
''mydpi = pwox / 4
If pwox <= phoy Then
mydpi = pwox
Else
mydpi = phoy
End If
''prFactor = 1
prFactor = mydpi / 600#
mydpi = 600


again:
On Error Resume Next
' DC FROM PRINTER
'oprinter.EndPrint
oprinter.ClearUp
If oprinter.create(Int(psw / pwox * mydpi + 0.5), Int(psh / phoy * mydpi + 0.5)) Then
Form1.PrinterDocument1.BackColor = QBColor(15)
oprinter.WhiteBits
oprinter.GetDpi mydpi, mydpi
Form1.PrinterDocument1.Cls
oprinter.needHDC
Set Form1.PrinterDocument1 = hDCToPicture(oprinter.HDC1, 0, 0, oprinter.Width, oprinter.Height)
oprinter.FreeHDC
If Err > 0 And try1 < 2 Then
try1 = try1 + 1
prFactor = prFactor * 2
mydpi = mydpi / 2
GoTo again
End If
szFactor = mydpi * dv15 / 1440#
On Error Resume Next
Form1.PrinterDocument1.Refresh
Form1.PrinterDocument1.Scale (0, 0)-(Form1.ScaleX(Int(psw / pwox * mydpi + 0.5), 3, 1), Form1.ScaleY(Int(psh / phoy * mydpi + 0.5), 3, 1))
pnum = 0
End If
End Sub
Sub getnextpage()
Dim pagetitle As String
On Error Resume Next
If oprinter.Height = 0 Then
getfirstpage

Else
pnum = pnum + 1
With players(-2)
.curpos = 0
.currow = 0
.lastprint = False
.XGRAPH = 0
.YGRAPH = 0
End With
With Form1.PrinterDocument1
.currentX = 0
.currentY = 0
End With
oprinter.CopyPicturePrinter Form1.PrinterDocument1
oprinter.GetDpi mydpi, mydpi
If Not ttl Or Not UseMe Is Nothing Then
pagetitle = Form1.CaptionW + str$(pnum)
ElseIf Form3.CaptionW <> "" Then
pagetitle = Form3.CaptionW + str$(pnum)
End If
If pagetitle = "" Then
pagetitle = "M2000 printing" + str$(pnum)
End If
If PRM - PLM > 0 Then
oprinter.square oprinter.Width - (PRM - PLM) / szFactor * mydpi / 1440, 0, oprinter.Width, oprinter.Height, "FFFFFF"
End If
If PBM - PTM > 0 Then
oprinter.square 0, oprinter.Height - (PBM - PTM) / szFactor * mydpi / 1440, oprinter.Width, oprinter.Height, "FFFFFF"
End If
oprinter.ThumbnailPaintPrinter 1, 100 * prFactor, False, True, True, , CLng(PLM / szFactor * mydpi / 1440), CLng(PTM / szFactor * mydpi / 1440), , , pagetitle
'oprinter.ClearBits Form1.PrinterDocument1.BackColor
'oprinter.needHDC
'Set Form1.PrinterDocument1 = hDCToPicture(oprinter.HDC1, 0, 0, oprinter.Width, oprinter.Height)
Form1.PrinterDocument1.Line (0, 0)-(Form1.PrinterDocument1.ScaleWidth, Form1.PrinterDocument1.ScaleHeight), &HFFFFFF, BF
'oprinter.FreeHDC

Form1.PrinterDocument1.Refresh
Form1.PrinterDocument1.Scale (0, 0)-(Form1.ScaleX(Int(psw / pwox * mydpi + 0.5), 3, 1), Form1.ScaleY(Int(psh / phoy * mydpi + 0.5), 3, 1))


End If
End Sub
Sub getenddoc()
On Error Resume Next
Dim pagetitle As String
pnum = pnum + 1
If prFactor = 0 Then prFactor = 1
Form1.Refresh
oprinter.CopyPicturePrinter Form1.PrinterDocument1
Form1.PrinterDocument1.Picture = LoadPicture("")
If Not ttl Or Not UseMe Is Nothing Then
pagetitle = Form1.CaptionW + str$(pnum)
ElseIf Form3.CaptionW <> "" Then
pagetitle = Form3.CaptionW + str$(pnum)
End If
If pagetitle = "" Then
pagetitle = "M2000 printing" + str$(pnum)
End If
If PRM - PLM > 0 Then
oprinter.square oprinter.Width - (PRM - PLM) / szFactor * mydpi / 1440, 0, oprinter.Width, oprinter.Height, "FFFFFF"
End If
If PBM - PTM > 0 Then
oprinter.square 0, oprinter.Height - (PBM - PTM) / szFactor * mydpi / 1440, oprinter.Width, oprinter.Height, "FFFFFF"
End If
'oprinter.ThumbnailPaintPrinter 1, 100 * prFactor, False, True, True, , , , , , pagetitle
oprinter.ThumbnailPaintPrinter 1, 100 * prFactor, False, True, True, , CLng(PLM / szFactor * mydpi / 1440), CLng(PTM / szFactor * mydpi / 1440), , , pagetitle
oprinter.ClearUp
oprinter.EndPrint



'Set oprinter = New cDIBSection
End Sub
Function MyDrawings(bstack As basetask, rest$, Lang As Long) As Boolean
MyDrawings = True
Dim mDir As recDir, s$, ss$, frm$
Set mDir = New recDir
mDir.IncludedFolders = False
mDir.Nofiles = False
mDir.TopFolder = mcd
mDir.SortType = Abs(FastSymbol(rest$, "!"))
frm$ = ExtractName(mDir.Dir2$(mcd, "WMF|EMF", False), True)
s$ = vbNullString
ss$ = vbNullString
Do While frm$ <> ""
s$ = frm$
If ss$ <> "" Then ss$ = ss$ + ", " + s$ Else ss$ = s$
s$ = mDir.Dir2
If s$ <> "" Then frm$ = ExtractName(s$, True) Else frm$ = vbNullString
Loop

If Lang Then
ss$ = "Drawings: " + ss$
Else
ss$ = "Ó÷Ýäéá: " + ss$
End If
Set mDir = Nothing
RepPlain bstack, bstack.Owner, ss$
End Function
Function MyMovies(bstack As basetask, rest$, Lang As Long) As Boolean
MyMovies = True
Dim mDir As recDir, s$, ss$, frm$
Set mDir = New recDir
mDir.IncludedFolders = False
mDir.Nofiles = False
mDir.TopFolder = mcd
mDir.SortType = Abs(FastSymbol(rest$, "!"))
frm$ = ExtractNameOnly(mDir.Dir2$(mcd, "AVI", False), True)
s$ = vbNullString
ss$ = vbNullString
Do While frm$ <> ""
s$ = frm$
If ss$ <> "" Then ss$ = ss$ + ", " + s$ Else ss$ = s$
s$ = mDir.Dir2
If s$ <> "" Then frm$ = ExtractNameOnly(s$, True) Else frm$ = vbNullString
Loop
Set mDir = Nothing
If Lang Then
ss$ = "Movies: " + ss$
Else
ss$ = "Ôáéíßåò: " + ss$
End If
RepPlain bstack, bstack.Owner, ss$
End Function
Function MyBitmaps(bstack As basetask, rest$, Lang As Long) As Boolean
MyBitmaps = True
Dim mDir As recDir, s$, ss$, frm$
Set mDir = New recDir
mDir.IncludedFolders = False
mDir.Nofiles = False
mDir.TopFolder = mcd
mDir.SortType = Abs(FastSymbol(rest$, "!"))
frm$ = ExtractName(mDir.Dir2$(mcd, "BMP|JPG|GIF|DIB|ICO|CUR|PNG|TIF", False), True)
s$ = vbNullString
ss$ = vbNullString
Do While frm$ <> ""
s$ = frm$
If ss$ <> "" Then ss$ = ss$ + ", " + s$ Else ss$ = s$
s$ = mDir.Dir2
If s$ <> "" Then frm$ = ExtractName(s$, True) Else frm$ = vbNullString
Loop
If Lang Then
ss$ = "Bitmaps: " + ss$
Else
ss$ = "Åéêüíåò: " + ss$
End If
Set mDir = Nothing
RepPlain bstack, bstack.Owner, ss$
End Function
Function ProcFKey(bstack As basetask, rest$, Lang As Long) As Boolean
Dim I As Long, p As Variant, s$, prive
If IsLabelSymbolNew(rest$, "ÊÁÈÁÑÏ", "CLEAR", Lang) Then
    For I = 1 To 24: FK$(I) = vbNullString: Next I
ElseIf IsExp(bstack, rest$, p) Then

    I = ((CLng(p) + 23) Mod 24) + 1
    If lookOne(rest$, "{") Then
         If IsStrExp(bstack, rest$, s$) Then
            FK$(I) = s$
        Else
            MissPar
            Exit Function
        End If
    ElseIf FastSymbol(rest$, ",") Then
        If IsStrExp(bstack, rest$, s$) Then
            FK$(I) = s$
        Else
            MissPar
            Exit Function
        End If
    Else
        prive = GetCode(bstack.Owner)
        PlainBaSket bstack.Owner, players(prive), FK$(I)
        crNew bstack, players(prive)
    End If
Else
    s$ = vbNullString: prive = GetCode(bstack.Owner)
    For I = 1 To 24
        If FK$(I) <> "" Then
            s$ = s$ + placeme$("ÊËÅÉÄÉ", "FKEY", Lang) + Right$(" " & (I), 3) + " [" + FK$(I) + "]" ' FKEY
            If I > 12 Then s$ = s$ & " SHIFT + F" & (I - 12) Else s$ = s$ & " F" & (I)
            s$ = s$ + vbCrLf
        End If
    Next I
    RepPlain bstack, bstack.Owner, s$
End If
ProcFKey = True
End Function
Function placeme$(gre$, Eng$, code As Long)
If code = 1 Then placeme$ = Eng$ Else placeme$ = gre$
End Function
Function MyScan(basestack As basetask, rest$) As Boolean
Dim p As Variant, Y As Double, s$
ClearJoyAll
PollJoypadk
If GetForegroundWindow <> Form1.hWnd Or Not Targets Then
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then

End If
MyScan = True
MyDoEvents0 basestack.Owner
If Fkey > 0 Then
If FK$(Fkey) <> "" Then
    s$ = FK$(Fkey)
    MyScan = interpret(Basestack1, s$)
Fkey = 0
End If
End If


 Exit Function
End If
If basestack.Owner.Visible = False Then basestack.Owner.Visible = True
basestack.Owner.SetFocus
NoAction = False

nomore = True
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
Y = Timer + p

Do ' TOO
MyDoEvents
Loop Until NoAction Or Timer > Y Or NOEXECUTION
    'End If
Else
Do ' TOO
 MyDoEvents
If Fkey > 0 Then
If FK$(Fkey) <> "" Then
rest$ = FK$(Fkey) + rest$
Fkey = 0
Exit Do
End If
End If
Loop Until NoAction Or NOEXECUTION
End If
nomore = False ' TOO

End Function

Function MyHelp(basestack As basetask, rest$, Lang As Long) As Boolean
Dim s$, s1$, aa As Boolean
If Not basestack.IamChild Or Not mHelp Or Not basestack.IamAnEvent Then
mHelp = False
abt = False
lastAboutHTitle = vbNullString
Dim I As Long
I = 1
If MaybeIsSymbol3lot(rest$, "?", I) Then
Mid$(rest$, 1, I) = space(I)
    fHelp basestack, "PRINT", Abs(pagio$ = "GREEK") + 1
    GoTo fhExit
ElseIf MaybeIsSymbol3lot(rest$, "@~$#", I) Then
s1$ = Mid$(rest$, I, 1)
Mid$(rest$, 1, I) = space(I)
I = I + 1
If MaybeIsSymbol3lot(rest$, "(", I) Then
s$ = s1$ + s$


FastSymbol rest$, ")"
    fHelp basestack, s$, Abs(pagio$ = "GREEK") + 1
    GoTo fhExit
End If

End If
If Abs(IsLabel(basestack, rest$, s$)) > 0 Then
    vH_title$ = vbNullString
    aa = AscW(s$ + Mid$(" Ó", Abs(pagio$ = "GREEK") + 1)) < 128
    If Len(s1$) > 0 Then s$ = s1$ + s$
    fHelp basestack, s$, aa
ElseIf Not ISSTRINGA(rest$, s$) Then
    nhelp basestack, Lang <> 1
Else
    fHelp basestack, s$, Lang = 1
End If
End If
fhExit:
MyHelp = True
End Function
Function ProcCls(basestack As basetask, rest$) As Boolean
'If basestack.toprinter Then Exit Function
Dim Scr As Object, p As Variant
 ProcCls = True
Set Scr = basestack.Owner

With players(GetCode(Scr))
If Not IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
p = -.Paper
Else
.Paper = mycolor(p)
End If



If FastSymbol(rest$, ",") Then
    If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
    If Not basestack.toprinter Then
    If p < 0 Then p = .mY + p
        .mysplit = MyRound(p)
        If .mysplit >= .mY Then .mysplit = 0: .pageframe = 0
        .pageframe = Int((.mY - .mysplit) * 2 / 3)

    End If
        Else
        ProcCls = False
        Set Scr = Nothing
        Exit Function
    End If
End If
If basestack.toprinter Then
If oprinter.Height > 0 Then
oprinter.Cls CLng(mycolor(.Paper))
oprinter.PaintPicture Form1.PrinterDocument1.Hdc
.curpos = 0
.currow = .mysplit
.lastprint = False
Scr.currentX = 0
Scr.currentY = 0
End If
Else
ClearScrNew Scr, players(GetCode(Scr)), CLng(mycolor(.Paper))
End If
If Form4Loaded Then
If Form4.Visible Then
If Not mHelp And Not abt Then vHelp
End If
End If
End With
Set Scr = Nothing
End Function

Public Sub DelTemp()
Dim tmp$
On Error Resume Next
While tempList2delete <> ""
If Not ISSTRINGA(tempList2delete, tmp$) Then Exit Sub
KillFile tmp$
Wend

End Sub
Public Function GetTempFileName() As String

   Dim sTmp    As String
   Dim sTmp2   As String
   Dim EXENAME As String
   EXENAME = App.EXENAME

   sTmp2 = GetTempPathgg
   sTmp = space(Len(sTmp2) + 256)
   Call GetTempFileNameW(StrPtr(sTmp2), StrPtr(EXENAME), UNIQUE_NAME, StrPtr(sTmp))
   GetTempFileName = Left$(sTmp, InStr(sTmp, Chr$(0)) - 1)
    tempList2delete = Sput(GetTempFileName) + tempList2delete
End Function
Public Function GetTempPathgg() As String
  
   Dim sTmp       As String
   Dim I          As Long
   Dim em$
    
   I = GetTempPath(0, StrPtr(em$))
   sTmp = space(I)

   Call GetTempPath(I, StrPtr(sTmp))
   GetTempPathgg = AddBackslash(Left$(sTmp, I - 1))

End Function
Public Function AddBackslash(s As String) As String

   If Len(s) > 0 Then
      If Right$(s, 1) <> "\" Then
         AddBackslash = s + "\"
      Else
         AddBackslash = s
      End If
   Else
      AddBackslash = "\"
   End If

End Function
Function ProcCreateEmf(bstack As basetask, rest$, Lang As Long) As Boolean
Dim W, h  ' these are twips - need to convert to .01 mm
Dim f As Boolean, p As Variant, Col As Long, it As Long, ss$, X As Double, par As Boolean, prive As Long
Dim nd&, once As Boolean
ProcCreateEmf = True
prive = GetCode(bstack.Owner)
' skip for now
If IsExp(bstack, rest$, W, , True) Then
    If FastSymbol(rest$, ",") Then
           If Not IsExp(bstack, rest$, h, , True) Then MissNumExpr
    Else
    
    End If
End If
If FastSymbol(rest$, "{") Then
            ss$ = block(rest$)
            TraceStore bstack, nd&, rest$, 0
            If FastSymbol(rest$, "}") Then
                Call executeblock(it, bstack, ss$, False, once, , True)
                If it = 2 Then
                    If ss$ = "" Then
                        If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                    Else
                        rest$ = ": Goto " + ss$
                        If trace Then WaitShow = 2: TestShowSub = rest$
                    End If
                    
                    it = 1
                End If
                If it <> 1 Then ProcCreateEmf = False: rest$ = ss$ + rest$
            Else
                MissPar
                ProcCreateEmf = False
                Exit Function
            End If
            bstack.addlen = nd&
        Else
            MissPar
            ProcCreateEmf = False
            Exit Function
        End If
        If Not IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then Exit Function

End Function
Function ProcPath(bstack As basetask, rest$, Lang As Long) As Boolean
Dim f As Boolean, p As Variant, Col As Long, it As Long, ss$, X As Double, par As Boolean, prive As Long
Dim OldGDILines As Boolean, Region As Boolean, oldpathcolor As Long, oldpathfillstyle As Integer, nd&, once As Boolean
ProcPath = True
prive = GetCode(bstack.Owner)
f = IsLabelSymbolNew(rest$, "ÐÁÍÙ", "OVER", Lang)
If FastSymbol(rest$, "!") Then par = True

If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
        Col = CLng(p)  ' using a fill color
        If FastSymbol(rest$, ",") Then
           If Not IsExp(bstack, rest$, X, , True) Then MissNumExpr
           Else
           X = vbSolid
           End If
        If FastSymbol(rest$, "{") Then

            ss$ = block(rest$)
            
            TraceStore bstack, nd&, rest$, 0
            If FastSymbol(rest$, "}") Then
            If MaybeIsSymbol(rest$, ";") Then
                    If MyTrim(ss$) = vbNullString Then GoTo contthere Else GoTo contthere2
            End If
                players(prive).pathgdi = players(prive).pathgdi + 1
                oldpathfillstyle = players(prive).pathfillstyle
                oldpathcolor = players(prive).pathcolor
                
                players(prive).pathcolor = mycolor(Col)
                players(prive).pathfillstyle = Int(X) Mod 8
                
                BeginPath bstack.Owner.Hdc
              '  If (par Or F) And GDILines Then OldGDILines = True: players(prive).NoGDI = True
                If (par Or Region) Then players(prive).NoGDI = True: If GDILines Then OldGDILines = True
                Call executeblock(it, bstack, ss$, False, once, , True)

                
                players(prive).pathgdi = players(prive).pathgdi - 1
                If players(prive).pathgdi > 0 Then
                    players(prive).pathcolor = oldpathcolor
                    players(prive).pathfillstyle = oldpathfillstyle
                Else
                    If (par Or Region) Then players(prive).NoGDI = False: GDILines = OldGDILines
                End If
                        
                ' what for 2 and 3 values
                EndPath bstack.Owner.Hdc
        
                bstack.Owner.FillStyle = Int(X) Mod 8
                bstack.Owner.FillColor = mycolor(Col)
                Col = p ' from  6.3 change
                If par Then bstack.Owner.DrawMode = 7
                If f Then  ' from 8 rev 83
                      If bstack.Owner.FillStyle = 1 Then
                           StrokeAndFillPath bstack.Owner.Hdc
                        Else
                            FillPath bstack.Owner.Hdc
                          End If
                Else
                     StrokeAndFillPath bstack.Owner.Hdc         ' stroke and fill path
                End If
                If par Then bstack.Owner.DrawMode = 13
                bstack.Owner.FillStyle = vbFSTransparent
                If players(prive).pathgdi = 0 Then
                    players(prive).pathcolor = oldpathcolor
                    players(prive).pathfillstyle = oldpathfillstyle
                End If
                If it = 2 Then
                    If ss$ = "" Then
                        If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                    Else
                        rest$ = ": Goto " + ss$
                        If trace Then WaitShow = 2: TestShowSub = rest$
                    End If
                    
                    it = 1
                End If
                If it <> 1 Then ProcPath = False: rest$ = ss$ + rest$
            Else
                MissPar
                ProcPath = False
            End If
            bstack.addlen = nd&

        Else
            MissPar
            ProcPath = False
        End If
    Exit Function
    Else
        If FastSymbol(rest$, "{") Then
            ss$ = block(rest$)
            TraceStore bstack, nd&, rest$, 0
            If MyTrim(ss$) = vbNullString Then
            ProcPath = FastSymbol(rest$, "}")
contthere:
              If FastSymbol(rest$, ";") Then
 
                  SelectClipRgn bstack.Owner.Hdc, 0&
              End If
              bstack.addlen = nd&
              Exit Function
            End If
        
            If FastSymbol(rest$, "}") Then
contthere2:
                If FastSymbol(rest$, ";") Then Region = True
                
                oldpathfillstyle = players(prive).pathfillstyle
                oldpathcolor = players(prive).pathcolor
                
                players(prive).pathcolor = mycolor(Col)
                players(prive).pathfillstyle = Int(X) Mod 8
                BeginPath bstack.Owner.Hdc
                'If (par Or region) And GDILines Then OldGDILines = True: players(prive).NoGDI = True
                If (par Or Region) Then players(prive).NoGDI = True: If GDILines Then OldGDILines = True
                Call executeblock(it, bstack, ss$, False, once, , , True)
                
                EndPath bstack.Owner.Hdc
                players(prive).pathgdi = players(prive).pathgdi - 1
                If players(prive).pathgdi > 0 Then
                    players(prive).pathcolor = oldpathcolor
                    players(prive).pathfillstyle = oldpathfillstyle
                Else
                    If (par Or Region) Then players(prive).NoGDI = False: GDILines = OldGDILines
                End If
                bstack.Owner.FillStyle = vbFSSolid
                If Region Then            ' path { block of commands };
                    
                    If f Then
                        SelectClipPath bstack.Owner.Hdc, 2
                    Else
                        SelectClipPath bstack.Owner.Hdc, RGN_COPY  ' make a clip path
                    End If
                
                    
                Else
                    If par Then bstack.Owner.DrawMode = 7
                    StrokePath bstack.Owner.Hdc               ' stroke path
                    If par Then bstack.Owner.DrawMode = 13
                End If
                bstack.Owner.FillStyle = vbFSTransparent
                If it = 2 Then
                    If ss$ = "" Then
                    If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                    Else
                    rest$ = ": Goto " + ss$
                    If trace Then WaitShow = 2: TestShowSub = rest$
                    End If
                    
                    it = 1
                End If
                If it <> 1 Then ProcPath = False: rest$ = ss$ + rest$
            Else
                MissPar
                ProcPath = False
            End If
            bstack.addlen = nd&
    Else
        MissPar
        ProcPath = False
    End If

End If

End Function
Function StripTerminator(ByVal strString As String) As String
    Dim intZeroPos As Long

    intZeroPos = InStr(strString, Chr$(0))
    If intZeroPos > 0 Then
        StripTerminator = Left$(strString, intZeroPos - 1)
    Else
        StripTerminator = strString
    End If
End Function
Sub AddDirSep(strPathName As String)
    If Right(Trim(strPathName), Len(gstrSEP_URLDIR)) <> gstrSEP_URLDIR And _
       Right(Trim(strPathName), Len(gstrSEP_DIR)) <> gstrSEP_DIR Then
        strPathName = RTrim$(strPathName) + gstrSEP_DIR
    End If
End Sub
Function GetWindowsDir() As String
    Dim strBuf As String
    Const gintMAX_SIZE& = 255                        'Maximum buffer size
    strBuf = space$(gintMAX_SIZE)

    '
    'Get the windows directory and then trim the buffer to the exact length
    'returned and add a dir sep (backslash) if the API didn't return one
    '
    If GetWindowsDirectory(strBuf, gintMAX_SIZE) > 0 Then
        strBuf = StripTerminator$(strBuf)
        AddDirSep strBuf

        GetWindowsDir = strBuf
    Else
        GetWindowsDir = vbNullString
    End If
End Function
Function ProcMargins(bstack As basetask, rest$)
Dim p
If Not IsExp(bstack, rest$, p) Then
PLM = 0
PTM = 0
PRM = 0
PBM = 0
ProcMargins = True
Exit Function
End If
PLM = p
If Not FastSymbol(rest$, ",") Then ProcMargins = True: Exit Function
If IsExp(bstack, rest$, p) Then
PTM = p
End If

If Not FastSymbol(rest$, ",") Then ProcMargins = True: Exit Function
If IsExp(bstack, rest$, p) Then
PRM = p
End If
If Not FastSymbol(rest$, ",") Then ProcMargins = True: Exit Function
If Not IsExp(bstack, rest$, p) Then
SyntaxError
Exit Function
End If
PBM = p
ProcMargins = True
End Function
Sub Portrait(bstack As basetask)
Dim dummy As Object, try1 As Long, cursize As Single
If UBound(MyDM) = 1 Then
PrinterDim pw, ph, psw, psh, pwox, phoy
End If
If pwox <= phoy Then
mydpi = pwox
Else
mydpi = phoy
End If
prFactor = mydpi / 600#
mydpi = 600
If szFactor > 0 Then
    cursize = players(-2).SZ / szFactor
Else
    cursize = Form1.DIS.FontSize
End If
szFactor = mydpi * dv15 / 1440#

If Int(psw / pwox * mydpi + 0.5) / Int(psh / phoy * mydpi + 0.5) > 1 Then
    If oprinter.PrinterOn Then
        ChangeNowOrientationPortrait
        oprinter.ResetPageDM
        SwapPrinterDim pw, ph, psw, psh, pwox, phoy
        GoTo contnow
    Else
        ChangeOrientation dummy, Printer.DeviceName, MyDM()
        SwapPrinterDim pw, ph, psw, psh, pwox, phoy
        Exit Sub
    End If
    
Else
    Form1.PrinterDocument1.Cls
    Form1.Refresh
    Exit Sub
End If
contnow:
Dim thisprinter As New cDIBSection

If thisprinter.create(Int(psw / pwox * mydpi + 0.5), Int(psh / phoy * mydpi + 0.5)) Then
    thisprinter.ClearBits Form1.PrinterDocument1.BackColor
    
    thisprinter.GetDpi mydpi, mydpi
    Form1.PrinterDocument1.Cls
    thisprinter.needHDC
    Set Form1.PrinterDocument1 = hDCToPicture(thisprinter.HDC1, 0, 0, thisprinter.Width, thisprinter.Height)
    thisprinter.FreeHDC
    If Err > 0 And try1 < 2 Then
        try1 = try1 + 1
        prFactor = prFactor * 2
        mydpi = mydpi / 2
        GoTo contnow
    End If
    szFactor = mydpi * dv15 / 1440#
    On Error Resume Next
    Form1.Refresh
    Form1.PrinterDocument1.Scale (0, 0)-(Form1.ScaleX(Int(psw / pwox * mydpi + 0.5), 3, 1), Form1.ScaleY(Int(psh / phoy * mydpi + 0.5), 3, 1))
    thisprinter.CopyPrinter oprinter.PrinterHdc
    Set oprinter = thisprinter
ElseIf try1 < 2 Then
        try1 = try1 + 1
        prFactor = prFactor * 2
        mydpi = mydpi / 2
        GoTo contnow
End If

If bstack.toprinter Then
    'SetText Form1.PrinterDocument1
    SetTextSZ Form1.PrinterDocument1, CSng(cursize * szFactor)
    Else
    PlaceBasket Form1.PrinterDocument1, players(-2)
    SetTextSZ Form1.PrinterDocument1, CSng(cursize * szFactor)
'    SetText Form1.PrinterDocument1
End If
End Sub
Sub Landscape(bstack As basetask)
Dim dummy As Object, try1 As Long, cursize As Single
If UBound(MyDM) = 1 Then
PrinterDim pw, ph, psw, psh, pwox, phoy
End If
If pwox <= phoy Then
mydpi = pwox
Else
mydpi = phoy
End If
prFactor = mydpi / 600#
mydpi = 600
If szFactor > 0 Then
    cursize = players(-2).SZ / szFactor
Else
    cursize = Form1.DIS.FontSize
End If
szFactor = mydpi * dv15 / 1440#

If Int(psw / pwox * mydpi + 0.5) / Int(psh / phoy * mydpi + 0.5) < 1 Then
    If oprinter.PrinterOn Then
        ChangeNowOrientationLandscape
        oprinter.ResetPageDM
        SwapPrinterDim pw, ph, psw, psh, pwox, phoy
        GoTo contnow
    Else
        ChangeOrientation dummy, Printer.DeviceName, MyDM()
        SwapPrinterDim pw, ph, psw, psh, pwox, phoy
        Exit Sub
    End If
Else
    Form1.PrinterDocument1.Cls
    Form1.Refresh
    Exit Sub
End If

contnow:
Dim thisprinter As New cDIBSection

If thisprinter.create(Int(psw / pwox * mydpi + 0.5), Int(psh / phoy * mydpi + 0.5)) Then
    thisprinter.ClearBits Form1.PrinterDocument1.BackColor
    thisprinter.GetDpi mydpi, mydpi
    thisprinter.needHDC
    On Error Resume Next
    Set Form1.PrinterDocument1 = hDCToPicture(thisprinter.HDC1, 0, 0, thisprinter.Width, thisprinter.Height)
    thisprinter.FreeHDC
    If Err > 0 And try1 < 2 Then
        thisprinter.ClearUp
        try1 = try1 + 1
        prFactor = prFactor * 2
        mydpi = mydpi / 2
        GoTo contnow
    End If
    szFactor = mydpi * dv15 / 1440#
    On Error Resume Next
    Form1.Refresh
    Form1.PrinterDocument1.Scale (0, 0)-(Form1.ScaleX(Int(psw / pwox * (mydpi) + 0.5), 3, 1), Form1.ScaleY(Int(psh / phoy * mydpi + 0.5), 3, 1))
    thisprinter.CopyPrinter oprinter.PrinterHdc
    Set oprinter = thisprinter
ElseIf try1 < 2 Then
        try1 = try1 + 1
        prFactor = prFactor * 2
        mydpi = mydpi / 2
        GoTo contnow
End If

If bstack.toprinter Then
    'SetText Form1.PrinterDocument1
    SetTextSZ Form1.PrinterDocument1, CSng(cursize * szFactor)
    Else
    PlaceBasket Form1.PrinterDocument1, players(-2)
    'SetText Form1.PrinterDocument1
       SetTextSZ Form1.PrinterDocument1, CSng(cursize * szFactor)
End If

End Sub
Sub nhelp(bstack As basetask, Optional GREEK As Boolean = False)
Dim di As Object
Set di = bstack.Owner
If GREEK Then
Dim bb$
bb$ = "   ÅËËÇÍÉÊÁ Þ ËÁÔÉÍÉÊÁ ãéá åðéëïãÞ êùäéêïóåëßäáò ãéá ôï ôýðï åìöÜíéóçò âïÞèåéáò " + vbCrLf
bb$ = bb$ + "   Ìå Esc ôåñìáôßæåé ç åêôÝëåóç ôìçìÜôùí  " + vbCrLf
bb$ = bb$ + "   ctrl + f1 áíïßãåé ôçí âïÞèåéá, ãñÜöïíôáò êáé åðéëÝãïíôáò âñßóêåé" + vbCrLf
bb$ = bb$ + "   ctrl + c Ôåñìáôßæåé ôçí åêôÝëåóç êáé êáèáñßæåé" + vbCrLf
bb$ = bb$ + "   ctrl + ïðïéïäÞðïôå ðëÞêôñï áíïßãåé ôç âçìáôéêÞ åêôÝëåóç" + vbCrLf
bb$ = bb$ + "   pause/break êÜíåé øõ÷ñÞ åêêßíçóç / äåò ÂÏÇÈÅÉÁ ÁÑ×Ç" + vbCrLf
bb$ = bb$ + "   Ó ïíïìáÔìçìáôïò áíïßãåé ôïí äéïñèùôÞ ãéá íá ãñÜøïõìå ðñüãñáììá" + vbCrLf
bb$ = bb$ + "   Ó ïíïìáÓõíÜñôçóçò( áíïßãåé ôïí äéïñèùôÞ ãéá íá ãñÜøïõìå óõíÜñôçóç" + vbCrLf
bb$ = bb$ + "   Ó ïíïìáÓõíÜñôçóçò$( áíïßãåé ôïí äéïñèùôÞ ãéá íá ãñÜøïõìå óõíÜñôçóç$" + vbCrLf
bb$ = bb$ + "   Ôìçìáôá  [ìáò äåß÷íåé ôá ôìÞìáôá óôç ìíÞìç êáé ôï äßóêï]" + vbCrLf
bb$ = bb$ + "   ÂÏÇÈÅÉÁ êáôé (ìáò äßíåé âïÞèåéá óå îå÷ùñéóôü ðáñÜèõñï)" + vbCrLf
bb$ = bb$ + "   ? Þ ÔÕÐÙÓÅ ôõðþíåé" + vbCrLf
bb$ = bb$ + "   äþóå ôçí åíôïëÞ ÑÕÈÌÉÓÅÉÓ ç ctrl+U ãéá íá áëëÜîåé ôçí åî ïñéóìïý ãñáììáôïóåéñÜ êáé ôá ÷ñþìáôá" + vbCrLf
bb$ = bb$ + "   äþóå ôçí åíôïëÞ ÅËÅÃ×ÏÓ ãéá íá äåéò óôïé÷åßá ôïõ äéåñìçíåõôÞ" + vbCrLf
bb$ = bb$ + "   äþóå ôçí åíôïëÞ ÔÅËÏÓ ãéá íá ôåñìáôßóåéò ôïí äéåñìçíåõôÞ" + vbCrLf
Else
bb$ = "   GREEK or LATIN for choose the codepage for errors display" + vbCrLf
bb$ = bb$ + "   with LATIN all error messages are in ENGLISH language  " + vbCrLf
bb$ = bb$ + "   Esc escape execution" + vbCrLf
bb$ = bb$ + "   ctrl + f1 open help form, you can write and click for find" + vbCrLf
bb$ = bb$ + "   ctrl + c terminate execution, clear all" + vbCrLf
bb$ = bb$ + "   ctrl + anykey open for test" + vbCrLf
bb$ = bb$ + "   pause/break for break cold reset / look HELP START" + vbCrLf
bb$ = bb$ + "   EDIT modulename     [open editor for writing program]" + vbCrLf
bb$ = bb$ + "   EDIT functionname( [open editor for writing function()]" + vbCrLf
bb$ = bb$ + "   EDIT functionname$( [open editor for writing function$()]" + vbCrLf
bb$ = bb$ + "   MODULES for a list of modules in memory and on dik" + vbCrLf
bb$ = bb$ + "   use HELP writesomething [to find some help, open the help form]" + vbCrLf
bb$ = bb$ + "   ? or PRINT for printing" + vbCrLf
bb$ = bb$ + "   type SETTINGS or ctrl+U to change the default font and colors" + vbCrLf
bb$ = bb$ + "   type MONITOR for info about current state of Interpreter" + vbCrLf
bb$ = bb$ + "   type END and press enter to close this program" + vbCrLf
End If
wwPlain2 bstack, players(GetCode(bstack.Owner)), bb$, di.Width, 1000, True
crNew bstack, players(GetCode(bstack.Owner))
End Sub



 

Function GetWindowsfontDir() As String
    Dim strBuf As String
    Const gintMAX_SIZE& = 255                        'Maximum buffer size
    strBuf = space$(gintMAX_SIZE)

    '
    'Get the windows directory and then trim the buffer to the exact length
    'returned and add a dir sep (backslash) if the API didn't return one
    '
    If GetWindowsDirectory(strBuf, gintMAX_SIZE) > 0 Then
        strBuf = StripTerminator$(strBuf)
        AddDirSep strBuf
        strBuf = strBuf + "FONT"
        AddDirSep strBuf
    
        GetWindowsfontDir = strBuf
    Else
        GetWindowsfontDir = vbNullString
    End If
End Function
Sub GREEK(bstack As basetask)
On Error Resume Next
LoadKeyboardLayout "00000408", KLF_ACTIVATE
Clid = 1032
UserCodePage = 1253
DefBooleanString = ";ÁëçèÝò;ØåõäÝò"
If Not mNoUseDec Then
NoUseDec = Mid$(CStr(1.2), 2, 1) = "."
OverideDec = Not NoUseDec
NowDec$ = "."
NowThou$ = ","
Else
NoUseDec = Mid$(CStr(1.2), 2, 1) = ","
OverideDec = Not NoUseDec
NowDec$ = ","
NowThou$ = "."
End If
With Form1
   bstack.myCharSet = 161
If bstack.tolayer > 0 Then
    .dSprite(bstack.tolayer).Font.charset = 161
    ElseIf bstack.toback Then
    .Font.charset = 161
    Else
    .DIS.Font.charset = bstack.myCharSet
    .TEXT1.Font.charset = bstack.myCharSet
    .List1.Font.charset = bstack.myCharSet
   ' .List2.Font.CharSet = bstack.myCharSet
    End If
End With
pagio$ = "GREEK"
Clid = 1032
DefBooleanString = ";ÁëçèÝò;ØåõäÝò"
DialogSetupLang 0
With players(GetCode(bstack.Owner))
.charset = 161
End With
End Sub
Sub LATIN(bstack As basetask)
On Error Resume Next
LoadKeyboardLayout "00000409", KLF_ACTIVATE
Clid = 1033
UserCodePage = 1252

NoUseDec = Mid$(CStr(1.2), 2, 1) = "."
OverideDec = Not NoUseDec
NowDec$ = "."
NowThou$ = ","


With Form1
bstack.myCharSet = 0
If bstack.tolayer > 0 Then
    .dSprite(bstack.tolayer).Font.charset = 0
    ElseIf bstack.toback Then
    .Font.charset = 0
    Else
    
    .DIS.Font.charset = bstack.myCharSet
    .TEXT1.Font.charset = bstack.myCharSet
    .List1.Font.charset = bstack.myCharSet
   ' .List2.Font.CharSet = bstack.myCharSet
    End If
End With
pagio$ = "LATIN"
Clid = 1033
DefBooleanString = ";\T\r\u\e;\F\a\l\s\e"
DialogSetupLang 1
With players(GetCode(bstack.Owner))
.charset = 0
End With
End Sub


Private Function GetLCIDFromKeyboard() As Long
    Dim Buffer As String, ret&, r&
    Buffer = String$(514, 0)
      r = GetKeyboardLayout(DWL_ANYTHREAD) And &HFFFF&
      r = val("&H" + Right(Hex(r), 4))
        ret = GetLocaleInfoW(r, LOCALE_ILANGUAGE, StrPtr(Buffer), Len(Buffer))
    GetLCIDFromKeyboard = CLng(val("&h" + Left$(Buffer, ret - 1)))
End Function
Public Function GetLCIDFromKeyboardLanguage() As String
    Dim Buffer As String, ret&, r&
    Buffer = String$(514, 0)
    r = GetKeyboardLayout(DWL_ANYTHREAD) And &HFFFF&
    r = val("&H" + Right(Hex(r), 4))
    'LOCALE_SENGLANGUAGE&
    If LCID_DEF <> 1033 And Not Clid = 1033 Then
        ret = GetLocaleInfoW(r, LOCALE_SLANGUAGE&, StrPtr(Buffer), Len(Buffer))
    Else
        ret = GetLocaleInfoW(r, LOCALE_SENGLANGUAGE&, StrPtr(Buffer), Len(Buffer))
    End If
    If shortlang Then If ret > 3 Then ret = 4
    On Error Resume Next
    GetLCIDFromKeyboardLanguage = Left$(Buffer, ret - 1)

End Function

Public Function GetlocaleString(ByVal this As Long) As String
On Error GoTo 1234
    Dim Buffer As String, ret&, r&
    Buffer = String$(514, 0)
    ret = GetLocaleInfoW(Clid, this, StrPtr(Buffer), Len(Buffer))
        
    GetlocaleString = Left$(Buffer, ret - 1)
    
1234:
    
End Function
Public Function GetlocaleString2(ByVal this As Long, ByVal McLid As Long) As String
On Error GoTo 1234
    Dim Buffer As String, ret&, r&
    Buffer = String$(514, 0)
      
        ret = GetLocaleInfoW(McLid, this, StrPtr(Buffer), Len(Buffer))
    GetlocaleString2 = Left$(Buffer, ret - 1)
    
1234:
    
End Function

Public Function QueryDecString() As String
QueryDecString = GetDeflocaleString(14)
End Function

Function IsLabelOnly(A$, r$) As Long
Dim n$
If Len(A$) < 129 Then
    IsLabelOnly = IsLabelOnlyInner(A$, r$)
Else
    n$ = Left$(A$, 128)
    IsLabelOnly = IsLabelOnlyInner(n$, r$)
    If Len(n$) = 0 Then
        IsLabelOnly = IsLabelOnlyInner(A$, r$)
    Else
        A$ = Mid$(A$, 129 - Len(n$))
    End If
End If
End Function

Function IsLabelOnlyInner(A$, r$) As Long  ' ok
Dim rr&, one As Boolean, C$, dot&
r$ = vbNullString
If A$ = vbNullString Then IsLabelOnlyInner = 0: Exit Function
A$ = NLtrim$(A$)
Do While Len(A$) > 0
    C$ = Left$(A$, 1) 'ANYCHAR HERE
    If AscW(C$) < 256 Then
        Select Case AscW(C$)
        Case 64  '"@"
            If r$ = vbNullString Then
                A$ = Mid$(A$, 2)
            ElseIf Mid$(A$, 2, 1) <> "(" And r$ <> "" Then
                r$ = r$ + "."
                A$ = Mid$(A$, 2)
            Else
                 IsLabelOnlyInner = 0: Exit Function
            End If
        Case 46 '"."
            If one Then
                Exit Do
            ElseIf r$ <> "" Then
                r$ = r$ + C$
                A$ = Mid$(A$, 2)
            ElseIf Not Mid$(A$, 2, 1) Like "[0-9]" Then
                If r$ <> "" Then
                    r$ = r$ + C$
                    rr& = 1
                Else
                    dot& = dot& + 1
                End If
                A$ = Mid$(A$, 2)
            Else
                If r$ = vbNullString And dot& > 0 Then
                    r$ = String$(dot& + 1, ".")
                    A$ = Mid$(A$, 2)
                    IsLabelOnlyInner = 1
                Else
                    IsLabelOnlyInner = 0
                End If
                Exit Function
            End If
        Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
            Exit Do
        Case 48 To 57, 95 '"0" To "9", "_"
            If one Then
                Exit Do
            ElseIf r$ <> "" Then
                r$ = r$ + C$
                A$ = Mid$(A$, 2)
                rr& = 1 'is an identifier or floating point variable
            Else
                If dot& > 0 Then A$ = "." + A$: dot& = 0
                Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
                Exit Do
            Else
                r$ = r$ + C$
                A$ = Mid$(A$, 2)
                rr& = 1 'is an identifier or floating point variable
            End If
        Case 38 ' "&"
            If r$ = vbNullString Then rr& = 2:    A$ = Mid$(A$, 2)
            Exit Do
        Case 36 ' "$"
            If one Then Exit Do
            If r$ <> "" Then
                one = True
                rr& = 3 ' is string variable
                r$ = r$ + C$
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
                one = True
                rr& = 4 ' is long variable
                r$ = r$ + C$
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                If Mid$(A$, 2, 2) = ")@" Then
                    r$ = r$ + "()."
                    A$ = Mid$(A$, 4)
                Else
                    Select Case rr&
                    Case 1
                        rr& = 5 ' float array or function
                    Case 3
                        rr& = 6 'string array or function
                    Case 4
                        rr& = 7 ' long array
                    Case Else
                        Exit Do
                    End Select
                    r$ = r$ + C$
                    A$ = Mid$(A$, 2)
                    Exit Do
                End If
            Else
                Exit Do
            End If
        Case Else
            Exit Do
        End Select
    Else
        If one Then
            Exit Do
        Else
            r$ = r$ + C$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
        End If
    End If
Loop
IsLabelOnlyInner = rr&
End Function
Function ProcFind(basestack As basetask, rest$) As Boolean
Dim I As Long, s$, pppp As mArray, x1 As Long, y1 As Long
Dim p As Variant, Col As Long, frm$, ss$
ProcFind = True
    y1 = Abs(IsLabel(basestack, rest$, s$))
     
        If y1 = 6 Then
                If neoGetArray(basestack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, basestack, s$, I, rest$) Then Exit Function
                Else
                    MissingDoc
                    Exit Function
                End If
    End If
    If FastSymbol(rest$, ",") Then
    If Not IsStrExp(basestack, rest$, frm$) Then
        MissStringExpr
        Exit Function
    End If
        ss$ = GetNextLine(frm$)
        SetNextLine frm$
    If frm$ <> "" Then
        MyEr "Search string with line breaks", "Áëöáñéèìçôéêü áíáæÞôçóçò ìå áëëáãÝò ãñáììþí"
        Exit Function
    End If
    Else
        MissPar
        Exit Function
    End If
    
     If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, p) Then
            MissNumExpr
            Exit Function
        End If
        x1 = CLng(p)
     Else
        x1 = 0
    End If
    
        If y1 = 3 Then
            If GetVar(basestack, s$, I) Then
                If VarTypeName(var(I)) = doc Then
                
                     x1 = var(I).FindStr(ss$, x1, y1, Col)
                     If x1 > 0 Then
                        basestack.soros.PushVal CDbl(Col)  ' CHAR IN PARAGRAPH
                        basestack.soros.PushVal CDbl(y1)   'PARAGRAPH ORDER ..NUMBER START FROM 1
                     End If
                        basestack.soros.PushVal CDbl(x1)   ' POSITION IN ALL DOCUMENT
                    
                Else
                    MissingDoc
                    Exit Function
                End If
            Else
                   MissFuncParameterStringVar
                    Exit Function
            End If
        ElseIf y1 = 6 Then
                    If pppp.ItemType(I) = doc Then
          
                        x1 = pppp.item(I).FindStr(ss$, x1, y1, Col)
                            If x1 > 0 Then
                               basestack.soros.PushVal CDbl(Col)  ' CHAR IN PARAGRAPH
                               basestack.soros.PushVal CDbl(y1)   'PARAGRAPH ORDER ..NUMBER START FROM 1
                            End If
                        basestack.soros.PushVal CDbl(x1)   ' POSITION IN ALL DOCUMENT
                    
              
                        Else
                         MissingDoc
                         Exit Function
                        End If
                    
    Else
                    
                MissPar
                Exit Function
    End If

End Function
Function ProcSaveDoc(entrypoint As Long, basestack As basetask, rest$) As Boolean
Dim dum As Boolean, W$, I As Long, s$, pppp As mArray, ss$, p As Variant
Dim x1 As Long, y1 As Long, doc1 As Document
If entrypoint = 1 Then dum = True  ' means documend append to file
    y1 = Abs(IsLabel(basestack, rest$, s$))
         If y1 = 6 Then
                If neoGetArray(basestack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, basestack, s$, I, rest$) Then Exit Function
                Else
                MissingDoc
                Exit Function
                End If
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsStrExp(basestack, rest$, W$) Then
            If Not dum Then
                If Not IsExp(basestack, rest$, p, , True) Then GoTo sdmess
                If MemInt(VarPtr(p)) = vbString Then
                    SwapString2Variant W$, p
                    GoTo cont154
                End If
            
pass2:
                 If FastPureLabel(rest$, W$, , True) = 1 Then

                    If Not check2(W$, "ÙÓ", "AS") Then SyntaxError: Exit Function
                    
                    If Not Abs(IsLabel(basestack, rest$, W$)) = 3 Then MissingStrVar: Exit Function
                     If y1 = 3 Then
                    If Not GetVar(basestack, s$, I) Then Nosuchvariable s$: Exit Function
                    
                    
                    
                    If Not VarTypeName(var(I)) = doc Then MissingDoc: Exit Function
                        Set doc1 = var(I)
                    ElseIf y1 = 6 Then
                    If Not pppp.ItemType(I) = doc Then MissingDoc: Exit Function
                        Set doc1 = pppp.item(I)
                    
                    End If       '
                    If Not GetVar(basestack, W$, I) Then I = globalvar(W$, "")
                    
                    If dum Then
                    var(I) = doc1.textDocFormated()
                    Else
                    var(I) = doc1.textDocFormated(p)
                    End If
                    ProcSaveDoc = True
                    Exit Function
                Else
                    MissPar
                    Exit Function
                End If
            End If
sdmess:
            MissStringExpr
            Exit Function
        End If
cont154:
        ss$ = GetNextLine(W$)
        SetNextLine W$
        If W$ <> "" Then
            MyEr "filename with line breaks", "üíïìá áñ÷åßïõ ìå áëëáãÝò ãñáììþí"
            Exit Function
        End If
        ' check valid name
        If ExtractNameOnly(ss$, True) = vbNullString Then BadFilename: Exit Function
        If ExtractPath(ss$) = vbNullString Then
            ss$ = mylcasefILE(mcd + ss$)
        End If
        If ExtractType(ss$) = vbNullString Then ss$ = ss$ + ".txt"
    ElseIf entrypoint = 1 Then
        GoTo sdmess
    Else
        dum = True
        GoTo pass2
    End If
    
     If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, p) Then    'type...for saving
        MissNumExpr
        Exit Function
        End If
        x1 = CLng(p)
        If x1 > 500 Then
        
        x1 = 0
        End If
     Else
        x1 = -5 ' ' 2 = utf-8 standard save mode
    End If
    
        If y1 = 3 Then
            If GetVar(basestack, s$, I) Then
                If VarTypeName(var(I)) = doc Then
                         If x1 = -5 Then
                    If var(I).ListLoadedType <> 0 Then
                    x1 = var(I).ListLoadedType
                    Else
                    x1 = 2
                    End If
                    End If
                    If CanKillFile(ss$) Then
                    If x1 = 0 And p <> 0 Then
                    var(I).LCID = CLng(p)
                    x1 = 3
                    End If
                     If Not var(I).SaveUnicodeOrAnsi(ss$, x1, dum) Then
                       MyEr "can't save " + ss$, "äåí ìðïñþ íá óþóù " + ss$
                      End If
                      Else
                      FilePathNotForUser
                      Exit Function
                      End If
                Else
                    MissingDoc
                    Exit Function
                End If
            Else
                   MissFuncParameterStringVar
                    Exit Function
            End If
        ElseIf y1 = 6 Then
                    If pppp.ItemType(I) = doc Then
                    If x1 = -5 Then
                    If pppp.item(I).ListLoadedType <> 0 Then
                    x1 = pppp.item(I).ListLoadedType
                    Else
                    x1 = 2
                    End If
                    End If
                    If CanKillFile(ss$) Then
                    If x1 = 0 And p <> 0 Then
                    pppp.item(I).LCID = CLng(p)
                    x1 = 3
                    End If
                     If Not pppp.item(I).SaveUnicodeOrAnsi(ss$, x1, dum) Then
                       MyEr "can't save " + ss$, "äåí ìðïñþ íá óþóù " + ss$
                       Exit Function
                      End If
                      Else
                      FilePathNotForUser
                      Exit Function
                      End If
                        Else
                         MissingDoc
                         Exit Function
                        End If
                    
    Else
                    
                MissPar
                Exit Function
    End If
ProcSaveDoc = True
End Function
Function ProcWin(basestack As basetask, rest$) As Boolean
Dim s$, W$, x1 As Long, qu As Boolean
If IsSupervisor Then

x1 = IsLabelFileName(basestack, rest$, W$)
If x1 = 1 Then
    SwapStrings s$, W$
Else
    x1 = IsStrExp(basestack, rest$, s$, False)
End If

If x1 Then
On Error Resume Next

If s$ = ExtractPath$(s$) Then
MyShell "explorer " + Chr(34) + s$ + Chr(34)
Else
If IsSymbol(rest$, ",") Then
x1 = IsLabelFileName(basestack, rest$, W$)
If x1 = 1 Then
Else
    x1 = IsStrExp(basestack, rest$, W$, False)
End If


If x1 Then
    qu = Left$(W$, 1) = """"
    If qu Then
        If ExtractType(W$) = vbNullString Then W$ = W$ + ".gsb"
        If ExtractPath(W$) = vbNullString Then W$ = mcd + W$
        W$ = """" + W$ + """"""
    End If
    MyShell s$, 1 - 5 * (IsSymbol(rest$, ";")), W$
Else
    MissStringExpr
Exit Function
End If
Else
MyShell s$, 1 - 5 * (IsSymbol(rest$, ";"))
End If
End If
'***********************************************
End If
Else
BadCommand
Exit Function
End If
ProcWin = True
End Function

Function ProcDos(basestack As basetask, rest$) As Boolean
Dim s$, W$, x1 As Long, p
If IsSupervisor Then
On Error Resume Next

x1 = IsLabelFileName(basestack, rest$, W$)
If x1 = 1 Then
    SwapStrings s$, W$
Else
    x1 = IsStrExp(basestack, rest$, s$, False)
End If
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, p) Then MissNumExpr: Exit Function
Else
p = 300
End If
        If x1 Then
        
                    If FastSymbol(rest$, ";") Then
                                doslast = Shell("CMD /C " + s$, vbMinimizedNoFocus)
                    Else
                                doslast = Shell("CMD /K " + s$, vbNormalFocus)
                    End If
        Else
                    doslast = Shell("CMD", vbNormalFocus)
        End If

           MyDoEvents
        Sleep CLng(Abs(p))

Else
BadCommand
Exit Function
End If
ProcDos = True
End Function

Function ProcSpeech(basestack As basetask, rest$) As Boolean
Dim s$, p As Variant, dum As Boolean
If IsStrExp(basestack, rest$, s$, False) Then

If FastSymbol(rest$, "#") Then s$ = "<spell>" + s$ + "</spell>"
dum = FastSymbol(rest$, "!")
If FastSymbol(rest$, ",") Then ' get voice number
If Not IsExp(basestack, rest$, p) Then MissNumExpr:  Exit Function
SPEeCH s$, dum, CLng(p)
Else
SPEeCH s$, dum
End If
End If
ProcSpeech = True
End Function
Function ProcField(bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, pppp As mArray, s$, it As Long, X As Double, Y As Double, p As Variant
Dim I As Long, x1 As Long, y1 As Long, what$, par As Boolean
prive = GetCode(bstack.Owner)
If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
End If
ProcField = True
  With players(prive)
        If IsLabelSymbolNew(rest$, "ÍÅÏ", "NEW", Lang) Then
            If IsExp(bstack, rest$, p) Then result = p Else result = 0
            Exit Function
        End If
        If IsLabelSymbolNew(rest$, "ÓÕÍÈÇÌÁ", "PASSWORD", Lang) Then I = True
    
        If Not IsExp(bstack, rest$, X) Then X = .curpos
        If Not FastSymbol(rest$, ",") Then Exit Function
        If Not IsExp(bstack, rest$, Y) Then Y = .currow
        If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, p) Then Exit Function
        p = MyRound(p)
        End If
        If Not IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then Exit Function
        Select Case Abs(IsLabel(bstack, rest$, what$))
        Case 3
            par = False
            If Not GetVar(bstack, what$, it) Then it = globalvar(what$, String$(CLng(p), 32))
            s$ = var(it)
        Case 6
                 par = True
                If neoGetArray(bstack, what$, pppp) Then If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Exit Function
                s$ = pppp.item(it)
        Case Else
        Exit Function
        End Select
        If p = 0 And s$ = vbNullString Then Exit Function
        If p = 0 Then p = Len(s$)
        s$ = Left$(s$, p)
        s$ = s$ + String$(p - Len(s$), " ")
        x1 = 1
        
        s$ = gf(bstack, Y, X, s$, x1, y1, CBool(I))
        
        
        If y1 <> 99 Then
        LCTbasket bstack.Owner, players(prive), Y + 1, 0
        End If
        result = y1
        If par Then
                If pppp.ItemType(it) = doc Then
            Set pppp.item(it) = New Document
            If s$ <> "" Then pppp.item(it).textDoc = s$
            Else
            pppp.item(it) = s$
            End If
        Else
        CheckVar var(it), s$
        End If
        Exit Function
End With
End Function

Function ProcList(basestack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, again$, Clsid() As GUID, LNames() As String, clsNumber As Long, I As Long, probe$, what$
Dim usemodule As Boolean, where As Long, page$
If IsLabelSymbolNew(rest$, "×ÑÇÓÔÙÍ", "USERS", Lang) Then
ProcUsers basestack
ProcList = True
Exit Function
End If

If FastSymbol(rest$, "!") Then
mylist basestack, -2, Lang   ' proportional
ElseIf IsLabelSymbolNew(rest$, "COM", "COM", Lang) Then
If IsLabelSymbolNew(rest$, "ÓÔÏ", "TO", Lang) Then
If here$ <> "" Then
    MyEr "Only in command line interpreter", "Ìüíï óôïí ìåôáöñáóôÞ ãñáììÞò"
    Exit Function
End If

If FastPureLabel(rest$, what$, , True) = 0 Then
    MyEr "Expect a module name", "Ðåñßìåíá Ýíá üíïìá ôìÞìáôïò"
    Exit Function
End If
If Not subHash.Find(what$, where) Then
If Lang = 1 Then
where = ModuleSubAsap(what$, "\\ End for Automatic list" + vbCrLf)
Else
where = ModuleSubAsap(what$, "\\ ÔÝëïò Áõôüìáôçò ëßóôáq" + vbCrLf)
End If
If where < 0 Then ProcList = False: Exit Function
End If
usemodule = True

End If

'' list com
'' List com to abcModule
If ObjectCatalog.count <> 0 Then again$ = "!"
' use Choose.object + to make it again
If ProcChooseObj(basestack, again$, Lang) Then
' list1 is a glist control
If Form1.List1.ListIndex = -1 Then ProcList = True: Exit Function
    If Form1.List1.listcount > 0 Then
                ObjectCatalog.Index = Form1.List1.ListIndex
        If Not usemodule Then
                basestack.soros.PushStr ObjectCatalog.Value
                ProcList = MyReport(basestack, "letter$", Lang)
        End If
        On Error GoTo there
        If GetAllCoclasses(ObjectCatalog.Value, Clsid(), LNames(), clsNumber) Then
        If Not usemodule Then If clsNumber > 0 Then ProcList = MyReport(basestack, "{CoClasses - Objects}", Lang)
        For I = 0 To clsNumber - 1
        If usemodule Then
            If Lang = 1 Then
                page$ = page$ + "Declare "
            Else
                page$ = page$ + "¼ñéóå "
            End If
            page$ = page$ + LNames(I) + " " + Chr$(34) + GetGUIDstr(Clsid(I)) + Chr$(34) + vbCrLf
        Else
        probe$ = strProgID(Clsid(I))
        basestack.soros.PushStr GetGUIDstr(Clsid(I))
        If probe$ = vbNullString Then
        basestack.soros.PushStr LNames(I)
        Else
        basestack.soros.PushStr probe$
        End If
        
        ProcList = MyReport(basestack, "quote$(letter$)+{, }+quote$(letter$)", Lang)
        End If
        Next I
         If usemodule Then
         sbf(where).sb = page$ + sbf(where).sb
         End If
        End If
      ProcList = True
    End If
Else
ProcList = True
End If
Exit Function
ElseIf IsExp(basestack, rest$, p) Then
mylist basestack, CLng(p), Lang

Else
mylist basestack, , Lang

  


End If
MyDoEvents1 basestack.Owner
ProcList = True
Exit Function
there:
MyEr Err.Description, Err.Description
Err.Clear
End Function
Function ProcLoad(basestack As basetask, rest$, Lang As Long) As Boolean
Dim x1 As Long, s$, W$, ss$, par As Boolean, vvl As Variant, Key$, par1 As Boolean, NoRun As Boolean
par1 = Not IsLabelSymbolNew(rest$, "ÍÅÏ", "NEW", Lang)
If par1 Then par1 = Not IsLabelSymbolNew(rest$, "ÍÅÁ", "NEW", Lang)  ' PLURAL FOR GREEK
NoRun = IsLabelSymbolNew(rest$, "ÔÌÇÌÁÔÁ", "MODULES", Lang)
ProcLoad = True
With basestack
If Not .IamChild And Not .IamAnEvent And Not .IamThread And Not .IamLambda Then
If Check2Save Then
    rest$ = vbNullString
    Exit Function
End If

If sb2used > 0 And Not NoRun Then
If MsgBoxN(IIf(pagio$ <> "GREEK", "There are modules/functions loaded, load anyway", "ÕðÜñ÷ïõí öïñôùìÝíá ôìÞìáôá/óõíáñôÞóåéò, íá öïñôþóù üðùò êáé íá Ý÷åé"), 1) <> 1 Then

rest$ = vbNullString
Exit Function
End If
End If
End If
End With
Do
x1 = IsLabelFileName(basestack, rest$, W$)
If x1 = 1 Then
    SwapStrings s$, W$
Else
    x1 = IsStrExp(basestack, rest$, s$, False)
End If

If x1 <> 0 Then
   
    If par1 Then
        If loadcatalog.ExistKey(mcd + ExtractNameOnly(s$, True) + ".gsb") Then
            W$ = mcd + ExtractNameOnly(s$, True) + ".gsb"
            ss$ = loadcatalog.Value
            If loadcatalog.ExistKey(W$ + Chr(1)) Then Switches loadcatalog.Value
            par1 = False
            GoTo JUMPHERE
        ElseIf loadcatalog.ExistKey(mcd + ExtractNameOnly(W$, True) + ".gsb") Then
            W$ = mcd + ExtractNameOnly(W$, True) + ".gsb"
            ss$ = loadcatalog.Value
            If loadcatalog.ExistKey(W$ + Chr(1)) Then Switches loadcatalog.Value
            par1 = False
            GoTo JUMPHERE
        End If
    Else
        'If loadcatalog.ExistKey(mcd + ExtractNameOnly(s$, True) + ".gsb") Then
        '    loadcatalog.RemoveWithNoFind
        'ElseIf loadcatalog.ExistKey(mcd + ExtractNameOnly(W$, True) + ".gsb") Then
        '    loadcatalog.RemoveWithNoFind
        'End If
    End If
    par1 = True
    If ExtractType(s$) <> "gsb" Then
        Key$ = mcd + ExtractNameOnly(s$, True) + ".gsb"
        s$ = CFname(mcd + ExtractNameOnly(s$, True) + ".gsb")
        If s$ = vbNullString Then
        Key$ = mcd + ExtractNameOnly(W$, True) + ".gsb"
        s$ = CFname(mcd + ExtractNameOnly(W$, True) + ".gsb")
        End If
        If s$ = vbNullString Then
        Key$ = mcd + ExtractNameOnly(W$, True) + ".gsb1"
        s$ = CFname(mcd + ExtractNameOnly(W$, True) + ".gsb1")
        If RenameFile2(s$, mcd + ExtractNameOnly(s$, True) + ".gsb") Then
         s$ = CFname(mcd + ExtractNameOnly(W$, True) + ".gsb")
        End If
        End If
     Else
        ss$ = s$
        If ExtractPath$(s$) = vbNullString Then
            s$ = ExtractName(s$, True)
            ss$ = Trim$(Mid$(ss$, Len(s$) + 1))
            s$ = mcd + s$
        Else
            s$ = ExtractPath(s$) + ExtractName(s$, True)
            ss$ = Trim$(Mid$(ss$, Len(s$) + 1))
        
        End If
        If CFname(s$) = vbNullString Then
        s$ = W$
        ss$ = s$
        If ExtractPath$(s$) = vbNullString Then
            s$ = ExtractName(s$, True)
            ss$ = Trim$(Mid$(ss$, Len(s$) + 1))
            s$ = mcd + s$
        Else
            s$ = ExtractPath(s$) + ExtractName(s$, True)
            ss$ = Trim$(Mid$(ss$, Len(s$) + 1))
        
        End If
        If CFname(s$) = vbNullString Then
            nosuchfile
            ProcLoad = False
            Exit Function
        End If
        End If
        If par1 Then
        If loadcatalog.ExistKey(Key$ + Chr$(1)) Then
            loadcatalog.Value = ss$
        Else
            loadcatalog.AddKey Key$ + Chr$(1), ss$
        End If
        End If
        Switches ss$
    End If
    If ExtractNameOnly(s$, True) = vbNullString Or LenB(CFname(s$)) = 0 Then
        nosuchfile
        ProcLoad = False
        Exit Function
    End If
    Dim oldclid As Long
    oldclid = Clid
    Clid = 1032
    ss$ = ReadUnicodeOrANSI(s$, True)
    ss$ = Join(Split(ss$, vbCrLf), vbLf)
    ss$ = Replace(ss$, vbCr, vbLf)
    ss$ = Join(Split(ss$, vbLf), vbCrLf)
    Clid = oldclid
    If ss$ <> "" Then
   If par1 Then
        If loadcatalog.ExistKey(Key$) Then
            loadcatalog.Value = ss$
        Else
               loadcatalog.AddKey Key$, ss$
        End If
    End If
    End If
JUMPHERE:
    If ss$ <> "" Then
    If Err.Number = 0 And Not (basestack.IamChild Or basestack.IamAnEvent) Then
       If Not NoRun Then LASTPROG$ = s$
        loadcatalog.Remove Key$: loadcatalog.Remove Key$ + Chr(1)
    End If
    If FastSymbol(rest$, ",") Then
        If IsStrExp(basestack, rest$, W$) Then
                ss$ = mycoder.decryptline(ss$, W$, (Len(ss$) / 2) Mod 33)
                If Abs(IsLabel(basestack, ss$, W$)) Then
                        If Not (Left$(ss$, 3) = ":" + vbCrLf) Then ProcLoad = False: Exit Function
                        If Not NORUN1 Then lckfrm = sb2used + 1
                        GoTo skipme2
                End If
        End If
End If
par = False

Do While MaybeIsSymbol(ss$, "\'[*")
SetNextLine ss$
par = True
Loop
' no more exclude tab
'ss$ = Replace(ss$, Chr$(9), "      ")

If ss$ <> "" Then
If par Then GoTo skipme
If (AscW(ss$) > 127 And myUcase(Left$(ss$, 5)) <> "ÊËÁÓÇ" And myUcase(Left$(ss$, 5)) <> "ÔÌÇÌÁ" And myUcase(Left$(ss$, 9)) <> "ÓÕÍÁÑÔÇÓÇ") Or (((AscW(ss$) And &H4000) = &H4000)) Then
    ss$ = mycoder.must(ss$)
    If NORUN1 Then
        SetTextData CF_UNICODETEXT, ss$
        basestack.LoadOnly = True
    End If

    If IsLabelA1("", ss$, W$) Then
        If Not (Left$(ss$, 3) = ":" + vbCrLf) Then ProcLoad = False: Exit Function
        'lock that module
        If Not NORUN1 Then lckfrm = sb2used + 1
    Else
        MOUT = True
    End If
Else
skipme:
    While FastSymbol(ss$, vbCrLf, , 2)
    
      ''  SleepWait 20
    Wend
    If Abs(IsLabel(basestack, ss$, W$)) Then
        If Not (Left$(ss$, 3) = ":" + vbCrLf) Then
        ss$ = W$ + " " + ss$
        End If
    End If
End If
skipme2:
vvl = CStr(vvl) + vbCrLf + ss$ + vbCrLf

End If
End If
End If
Loop Until MOUT Or Not IsSymbol(rest$, "&&", 2)
If lckfrm > 0 Then Resettimestamp
basestack.NoRun = NoRun
ProcLoad = interpret(basestack, CStr(vvl), Len(here$) > 0)
basestack.NoRun = False


End Function

Function MyNew(basestack As basetask, rest$, Lang As Long) As Boolean
MyNew = True
If HaltLevel > 0 Then Exit Function
If Not basestack.IamChild And Not basestack.IamAnEvent Then
        If Check2Save Then
            Exit Function
        End If
End If
Check2SaveModules = False
Resettimestamp
If (basestack.Process Is Nothing) And (basestack.Parent Is Nothing) Then
Set basestack.StaticCollection = Nothing 'New FastCollection
basestack.IamAnEvent = False
abt = False
Set loadcatalog = New FastCollection
Set BookMarks = New FastCollection
LASTPROG$ = vbNullString
Randomize Timer
Set comhash = New sbHash
allcommands comhash
Set numid = New idHash
Set funid = New idHash
Set strid = New idHash
Set strfunid = New idHash
NumberId numid, funid
StringId strid, strfunid
NoOptimum = False
If Lang = 0 Then
sHelp "Ì2000 [ÂÏÇÈÅÉÁ]", "ÃñÜøå ÔÅËÏÓ ãéá íá âãåéò áðü ôï ðñüãñáììá" + vbCrLf + "Äåò ôá ÏËÁ (êÜíå êëéê óôï ÏËÁ)" + vbCrLf + "George Karras 2022", (ScrInfo(Console).Width - 1) * 3 / 5, (ScrInfo(Console).Height - 1) * 1 / 7
Else
sHelp "Ì2000 [HELP]", "Write END for exit from this program" + vbCrLf + "See ALL commands  (click on ALL)" + vbCrLf + "George Karras 2022", (ScrInfo(Console).Width - 1) * 3 / 5, (ScrInfo(Console).Height - 1) * 1 / 7
End If
NERR = False
lckfrm = 0
subHash.ReduceHash 0, sbf()
sb2used = 0
ReDim sbf(50) As modfun
TaskMaster.Dispose
Dim I As Long
For I = 1 To 24: FK$(I) = vbNullString: Next I
CloseAllConnections
CleanupLibHandles
ProcPen basestack, ", 255"
Form1.ResetMarks
' This is the INPUT END
If Not NOEDIT Then
NOEDIT = True
Else
If QRY Then QRY = False
End If
' restore DB.Provider for User
JetPrefixUser = JetPrefixHelp
JetPostfixUser = JetPostfixHelp
' SET ARRAY BASE TO ZERO
ArrBase = 0
End If
If Form1.Visible Then
If Not UseMe Is Nothing Then
UseMe.SetExtCaption "M2000"
End If
End If
Errorlog.EmptyDoc
End Function
Sub ClearCatalog()
Set ObjectCatalog = New FastCollection
End Sub
Function ProcChooseObj(bstack As basetask, rest$, Lang As Long) As Boolean
Dim f As Long, I As Long, s$, p As Variant
    Dim iSectCount As Long, iSect As Long, sSections() As String
    Dim iVerCount As Long, iVer As Long, sVersions() As String
      Dim iExeSectCount As Long, iExeSect As Long, sExeSect() As String
If Form4Loaded Then
If Form4.Visible Then
Form4.Visible = False
    If Form1.TEXT1.Visible Then
        Form1.TEXT1.SetFocus
    Else
        Form1.SetFocus
    End If
End If
End If
 Form1.List1.Clear
    If lookOne(rest$, "!") Then
            ObjectCatalog.Done = True
            For I = 0 To ObjectCatalog.count - 1
                ObjectCatalog.Index = I
                Form1.List1.additemFast ObjectCatalog.KeyToString
                
            Next I
        ProcChooseObj = MyMenu(2, bstack, rest$, Lang)
    Else
      
       Set ObjectCatalog = New FastCollection
       Dim cr As New cRegistry, first$, K As Long
       Dim bFoundExeSect As Boolean, ss$, mmdir As New recDir
       '' some code here are copies from VbScriptEditor
       '' http://www.codeproject.com/Articles/19986/VbScript-Editor-With-Intellisense
       cr.ClassKey = HKEY_CLASSES_ROOT
       cr.ValueType = REG_SZ
       cr.SectionKey = "TypeLib"
        If cr.EnumerateSections(sSections(), iSectCount) Then
            For iSect = 1 To iSectCount
                cr.SectionKey = "TypeLib\" + sSections(iSect)
                If cr.EnumerateSections(sVersions(), iVerCount) Then
                    For iVer = 1 To iVerCount
                        cr.SectionKey = "TypeLib\" + sSections(iSect) + "\" + sVersions(iVer)
                        first$ = cr.Value
                        cr.EnumerateSections sExeSect(), iExeSectCount
                        If iExeSectCount > 0 Then
                            bFoundExeSect = False
                            For iExeSect = 1 To iExeSectCount
                                If IsNumeric(sExeSect(iExeSect)) Then
                                    cr.SectionKey = cr.SectionKey + "\" + sExeSect(iExeSect) + "\win32"
                                    bFoundExeSect = True
                                    Exit For
                                End If
                            Next iExeSect
                            If bFoundExeSect Then
                                ss$ = cr.Value
                                ss$ = ExtractPath(ss$, , True) + ExtractName(ss$, True)
                                If mmdir.ExistFile(ss$) Then
                                    ObjectCatalog.AddKey first$ + " (" + sVersions(iVer) + ")", ss$
                                End If
                            End If
                        End If
                    Next iVer
                End If
            Next iSect
            ObjectCatalog.Sort
            ObjectCatalog.Done = True
            For I = 0 To ObjectCatalog.count - 1
                ObjectCatalog.Index = I
                Form1.List1.additemFast ObjectCatalog.KeyToString
            Next I
            ProcChooseObj = MyMenu(2, bstack, rest$, Lang)
        Else
            OutOfLimit
            ProcChooseObj = False
        End If
    End If
End Function
Function ProcChooseColor(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, I As Long, it As Long, Scr As Object
olamazi
With players(GetCode(bstack.Owner))
If IsExp(bstack, rest$, p) Then
On Error Resume Next
I = CLng(-p)
Else
I = -.mypen
End If
it = I
If I < 0 Then it = -it: I = it
If I > 0 And I < 16 Then I = QBColor(I)


DialogSetupLang Lang
If OpenColor(bstack, I) Then
bstack.soros.PushVal CCur(-I)
Else
bstack.soros.PushVal CCur(-it)

End If
End With
ProcChooseColor = True
End Function

Function ProcDesktop(bstack As basetask, rest$, Lang As Long) As Boolean
Dim work1 As Boolean, oldleft As Long, oldtop As Long
Dim photo As cDIBSection, s$, p As Variant, X As Double, aPic As StdPicture
olamazi
If IsLabelSymbolNew(rest$, "ÅÉÊÏÍÁ", "IMAGE", Lang) Then
If IsStrExp(bstack, rest$, s$) Then
' FILL WIDTH  IMAGE
 If Left$(s$, 4) = "cDIB" And Len(s$) > 12 Then
 Set photo = New cDIBSection
 If Not cDib(s$, photo) Then MissCdibStr:  Exit Function
  photo.GetDpi 96, 96
  If form5iamloaded Then
  Form5.RestoreSizePos
  Form5.Cls
  photo.ThumbnailPaint Form5
  Else
  photo.ThumbnailPaint Form1
  End If
 Else
 If ExtractType(s$) = vbNullString Then s$ = s$ + ".jpg"
                    If CFname(s$) = vbNullString Then
                        s$ = mcd + s$
                        If CFname(s$) = vbNullString Then
                        BadFilename
                        Exit Function
                        End If
                    Else
                        s$ = CFname(s$)
                    End If
        If Len(s$) < 254 Then
        ' look for image to load
            Set photo = New cDIBSection
            If CFname(s$) <> "" Then
             s$ = CFname(s$)
                                       Set aPic = LoadMyPicture(GetDosPath(s$))
                If Not aPic Is Nothing Then
                
                    photo.CreateFromPicture aPic
                                           
                    If photo.bitsPerPixel <> 24 Then
                        Conv24 photo
                        Else
                        CheckOrientation photo, s$
                        End If
                       photo.GetDpi 96, 96
                       If form5iamloaded Then
                       Form5.RestoreSizePos
                       Form5.Cls
                       photo.ThumbnailPaint Form5
                       Else
                       photo.ThumbnailPaint Form1
                       End If
                    End If
                    End If
        Else
        BadFilename
        End If
        End If
 Set photo = Nothing
End If
ElseIf IsLabelSymbolNew(rest$, "ÊÑÕØÅ", "HIDE", Lang) Then
If Not form5iamloaded Then
'
End If
Form5.BackColor = &H0 ' ALWAYS BLACK
Form5.Cls
SetTrans Form5, CByte(255), mycolor(0), True
ElseIf IsLabelSymbolNew(rest$, "ÊÁÈÁÑÇ", "CLEAR", Lang) Then
If form5iamloaded Then
Form5.RestoreSizePos
Form5.BackColor = &H0 ' ALWAYS BLACK
Form5.Cls

Set Form5.Picture = LoadPicture("")
Form5.Cls
SetTrans Form5, CByte(255), mycolor(-2)

Else
Form1.Cls
End If
Else
If Not Form1.Visible Then
work1 = True
oldleft = Form1.Left
oldtop = Form1.Left
Form1.move -Form1.Width - dv15, -Form1.Height - dv15
Form1.Visible = True
End If
If IsExp(bstack, rest$, p) Then
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, X) Then
        
        Form5.Visible = True
        Form5.ZOrder 1
        SetTrans Form1, CByte(p And &HFF), mycolor(X), True
        
        End If
    Else

    Form5.Visible = True
    'Form5.ZOrder 1
    SetTrans Form1, CByte(p And &HFF)
    End If
    Else
    CdESK
    End If
End If
If work1 Then
    Form1.Visible = False
    Form1.move oldleft, oldtop
End If

ProcDesktop = True
End Function
Function ProcFont(bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, x1 As Long, s$
If IsLabelSymbolNew(rest$, "ÖÏÑÔÙÓÅ", "LOAD", Lang) Then
Do
If IsStrExp(bstack, rest$, s$) Then
    s$ = CFname$(s$)
    If s$ <> "" Then
        ProcFont = LoadFont(s$)
    End If
Else
    MissStringExpr
    ProcFont = False
    Exit Function
End If
Loop Until Not FastSymbol(rest$, ",")
ElseIf IsLabelSymbolNew(rest$, "ÄÉÁÃÑÁÖÇ", "REMOVE", Lang) Then
Do
If IsStrExp(bstack, rest$, s$) Then
    s$ = CFname$(s$)
    If s$ <> "" Then
        ProcFont = RemoveFont(s$)
    End If
Else
    MissStringExpr
    ProcFont = False
    Exit Function
End If
Loop Until Not FastSymbol(rest$, ",")
Else

    prive = GetCode(bstack.Owner)
    If IsStrExp(bstack, rest$, s$) Then
        On Error Resume Next
        x1 = bstack.Owner.Font.charset
        bstack.Owner.Font.Name = s$
        If Not (x1 = bstack.Owner.Font.charset) Then
            bstack.Owner.Font.charset = x1
        End If
    
        If LCase(bstack.Owner.Font.Name) <> LCase(s$) Then
        
            bstack.Owner.Font.Name = MyFont
            bstack.Owner.Font.charset = bstack.myCharSet
        End If
    End If
        StoreFont bstack.Owner.Font.Name, players(prive).SZ, bstack.Owner.Font.charset
        players(prive).FontName = bstack.Owner.Font.Name
        SetText bstack.Owner
        GetXYb bstack.Owner, players(prive), players(prive).curpos, players(prive).currow
End If
 ProcFont = True
End Function

Function ProcSubDir(basestack As basetask, rest$, Lang As Long) As Boolean
Dim x1 As Long, ss$, W$

x1 = IsLabelFileName(basestack, rest$, W$)
If x1 = 1 Then
    SwapStrings ss$, W$
Else
    x1 = IsStrExp(basestack, rest$, ss$, False)
End If
If x1 <> 0 Then
    ss$ = mcd + ss$
    AddDirSep ss$
    If PathMakeDirs(ss$) Then
        mcd = ss$
        ProcSubDir = True
    Else
        BadPath
    End If
Else
MissDir
End If

End Function
Function ProcOpenFile(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pa$, ss$, frm$, s$, W$, Scr As Object, x1 As Long, p As Variant, par As Boolean, f As Boolean
Dim aaa() As String, dum As Boolean
If IsSelectorInUse Then
SelectorInUse
Exit Function
End If
olamazi
frm$ = mcd
DialogSetupLang Lang

IsStrExp basestack, rest$, s$
If FastSymbol(rest$, ",") Then If IsStrExp(basestack, rest$, pa$) Then frm$ = pa$
If frm$ <> "" Then If Not isdir(frm$) Then NoSuchFolder: Exit Function
If FastSymbol(rest$, ",") Then If IsStrExp(basestack, rest$, pa$) Then ss$ = pa$
par = False
If FastSymbol(rest$, ",") Then If Not IsStrExp(basestack, rest$, W$) Then Exit Function
If FastSymbol(rest$, ",") Then If IsExp(basestack, rest$, p) Then par = p <> 0
If FastSymbol(rest$, ",") Then f = IsExp(basestack, rest$, p) Else p = 0  '' if f is false what???
 dum = p <> 0
If TypeOf basestack.Owner Is GuiM2000 Then
Set Scr = basestack.Owner
Else
 If Form1.Visible Then
Set Scr = Form1
Else
Set Scr = Nothing
End If
End If
If InStr(W$, "|") > 0 Then
    If InStr(W$, "(*.") > 0 Then
        aaa() = Split(W$, "(*.")
        W$ = vbNullString
        If UBound(aaa()) > LBound(aaa()) Then
            W$ = "|"
            For x1 = LBound(aaa()) + 1 To UBound(aaa())
                W$ = W$ + UCase(Left$(aaa(x1), InStr(aaa(x1), ")") - 1) + "|")
            Next x1
        End If
    Else
        aaa() = Split(W$, "|")
        W$ = vbNullString
        If UBound(aaa()) > LBound(aaa()) Then
            W$ = "|"
            For x1 = LBound(aaa()) To UBound(aaa())
                W$ = W$ + UCase(aaa(x1)) + "|"
            Next x1
        End If
    End If
End If

    If OpenDialog(basestack, frm$, s$, ss$, W$, Not par, dum) Then
     If multifileselection Then
        If ReturnListOfFiles <> "" Then
                aaa() = Split(ReturnListOfFiles, "#")
                If UBound(aaa()) > LBound(aaa()) Then
            
                        For x1 = UBound(aaa()) To LBound(aaa()) + 1 Step -1
                            basestack.soros.PushStr aaa(x1)
                        Next x1
                        basestack.soros.PushVal UBound(aaa()) - LBound(aaa())
                        basestack.soros.PushStr aaa(x1)
                 End If
            Else
            
     If isdir(ReturnFile) Then
     basestack.soros.PushStr ""
    Else
    basestack.soros.PushStr ReturnFile
    End If
        End If
    Else
    If isdir(ReturnFile) Then
     basestack.soros.PushStr ""
    Else
    basestack.soros.PushStr ReturnFile
    End If
    End If
    Else
    basestack.soros.PushStr ""
    End If

Set Scr = Nothing
ProcOpenFile = True
End Function

Function ProcTone(bstack As basetask, rest$) As Boolean
Dim p As Variant, sX As Double
If IsExp(bstack, rest$, p) Then
    If Not FastSymbol(rest$, ",") Then
       Beeper 1000, p
    ElseIf IsExp(bstack, rest$, sX) Then
    Beeper sX, p
    Else
    MyEr "wrong parameter", "ëÜèïò ðáñÜìåôñïò"
    Exit Function
    End If
Else
Beeper 1000, 100
End If
ProcTone = True
End Function
Function ProcGradient(bstack As basetask, rest$) As Boolean
Dim X As Long, Y As Long, p As Variant, trans As Long, USEOLD As Boolean
Dim whois As Long
whois = GetCode(bstack.Owner)
ProcGradient = True
With players(whois)
trans = .mypentrans
USEOLD = .NoGDI
If Not IsExp(bstack, rest$, p) Then X = rgb(255, 255, 255) Else X = mycolor(p)
If Not FastSymbol(rest$, ",") Then
Y = 0
Else
If Not IsExp(bstack, rest$, p) Then Y = 0 Else Y = mycolor(p)
End If
If Not FastSymbol(rest$, ",") Then
If USEOLD Then
TwoColorsGradient bstack, GRADIENT_FILL_RECT_V, GDIP_ARGB1(trans, X), GDIP_ARGB1(trans, Y)
Else
If .hRgn Then
GdiPlusGradientRegion whois, 0, 0, bstack.Owner.ScaleWidth / dv15 + 1, bstack.Owner.ScaleHeight / dv15 + 1, GDIP_ARGB1(trans, X), GDIP_ARGB1(trans, Y), 1
Else
GdiPlusGradient bstack.Owner.Hdc, 0, 0, bstack.Owner.ScaleWidth / dv15 + 1, bstack.Owner.ScaleHeight / dv15 + 1, GDIP_ARGB1(trans, X), GDIP_ARGB1(trans, Y), 1
End If
End If



Else
If Not IsExp(bstack, rest$, p) Then
ProcGradient = IfierVal: Exit Function
Else
If USEOLD Then
TwoColorsGradient bstack.Owner, -CLng(p <> 0), GDIP_ARGB1(trans, X), GDIP_ARGB1(trans, Y)
Else
If p = 0 Then
GdiPlusGradient bstack.Owner.Hdc, 0, 0, bstack.Owner.ScaleWidth / dv15 + 1, bstack.Owner.ScaleHeight / dv15 + 1, GDIP_ARGB1(trans, Y), GDIP_ARGB1(trans, X), 0&
Else
GdiPlusGradient bstack.Owner.Hdc, 0, 0, bstack.Owner.ScaleWidth / dv15 + 1, bstack.Owner.ScaleHeight / dv15 + 1, GDIP_ARGB1(trans, X), GDIP_ARGB1(trans, Y), 1&
End If
End If




End If
End If
End With
End Function
Public Function GetSpecialfolder(CSIDL As Long) As String
    Dim r As Long
    Dim IDL As Long, NoError As Long, path$
    'Get the special folder
    r = SHGetSpecialFolderLocation(100, CSIDL, IDL)
    If r = NoError Then
        'Create a buffer
        If IDL Then
        path$ = space$(1024)
        
        'Get the path from the IDList
        r = SHGetPathFromIDList(IDL, StrPtr(path$))
        'Remove the unnecessary chr$(0)'s
        GetSpecialfolder = mylcasefILE(Left$(path, InStr(path, vbNullChar) - 1))
        Call CoTaskMemFree(IDL)
        Exit Function
        End If
    End If
    GetSpecialfolder = vbNullString
End Function
Sub ProcUsers(bstack As basetask)
Dim aDir As New recDir, ss$, A$, b$, n As Integer
aDir.IncludedFolders = True
aDir.Nofiles = True
aDir.TopFolder = GetSpecialfolder(CLng(26)) + "\M2000_USER\"
aDir.LevelStop = 1
aDir.SortType = 1

b$ = GetSpecialfolder(CLng(26)) + "\M2000_USER\"
n = Len(b$) + 2
A$ = Tcase(Mid$(mylcasefILE$(aDir.Dir2$(b$, "", False)), n))
b$ = vbNullString
While A$ <> ""
If InStr(A$, " ") > 0 Then A$ = "[" + Replace(A$, " ", ChrW(160)) + "]"
b$ = A$

A$ = Tcase(Mid$(aDir.Dir2, n))
If A$ <> "" Then ss$ = ss$ + b$ + ", "
Wend
If b$ <> "" Then ss$ = ss$ + b$
Dim Scr As Object, prive As Long
Set Scr = Form1.DIS 'bstack.Owner
prive = GetCode(Scr)
wwPlain2 bstack, players(prive), ss$, Scr.Width, 1000, True, , 3
End Sub

Function MyFrame(bstack As basetask, rest$) As Boolean
Dim prive As Long, x1 As Long, y1 As Long, Col As Long, p As Variant
Dim X As Double, Y As Double, ss$
MyFrame = True
prive = GetCode(bstack.Owner)
With players(prive)
x1 = 1
y1 = 1
Col = .mypen
If FastSymbol(rest$, "@") Then
If FastSymbol(rest$, "(") Then
    If IsExp(bstack, rest$, p) Then x1 = Abs(p + .curpos) Mod (.mX + 1)
    If Not FastSymbol(rest$, ")") Then MissSymbol ")": Exit Function
Else
    If IsExp(bstack, rest$, p) Then x1 = Abs(p) Mod (.mX + 1)
End If
If FastSymbol(rest$, ",") Then
    If FastSymbol(rest$, "(") Then
        If IsExp(bstack, rest$, p) Then y1 = Abs(p + .currow - 1) Mod (.mY + 1)
        If Not FastSymbol(rest$, ")") Then MissSymbol ")": Exit Function
    
    Else
        If IsExp(bstack, rest$, p) Then y1 = Abs(p) Mod (.mY + 1)
    End If
    '
    
End If
Y = 5
If FastSymbol(rest$, ",") Then If Not IsExp(bstack, rest$, Y) Then Y = 5
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, X) Then
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, p) Then
MyRect bstack.Owner, players(prive), (x1), (y1), (Y), (X), (p)
Else
 MyFrame = False: MissNumExpr: Exit Function
End If
Else
MyRect bstack.Owner, players(prive), (x1), (y1), (Y), (X)
End If
ElseIf IsStrExp(bstack, rest$, ss$) Then
MyRect bstack.Owner, players(prive), (x1), (y1), (Y), ss$
Else
MyRect bstack.Owner, players(prive), (x1), (y1), 5, "?"
End If
Else
MyRect bstack.Owner, players(prive), (x1), (y1), 6, 0
End If
Else
If IsExp(bstack, rest$, p) Then x1 = Abs(p) Mod .mX
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = Abs(p) Mod .mY

x1 = x1 + .curpos - 1
y1 = y1 + .currow - 1
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then BoxColorNew bstack.Owner, players(prive), x1, y1, (p)


If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then Col = p Else MyFrame = False: MissNumExpr: Exit Function


BoxBigNew bstack.Owner, players(prive), x1, y1, Col
End If
End With
MyDoEvents1 bstack.Owner


End Function
Function MyMark(bstack As basetask, rest$) As Boolean
Dim prive As Long, p As Variant, par As Boolean, x1 As Long, y1 As Long, Col As Long
MyMark = True
prive = GetCode(bstack.Owner)
With players(prive)
x1 = 1
y1 = 1
Col = .mypen
If IsExp(bstack, rest$, p) Then x1 = Abs(p) Mod .mX
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = Abs(p) Mod .mY
x1 = x1 + .curpos - 1
y1 = y1 + .currow - 1
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then Col = p

If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then par = Not (p = 0)

CircleBig bstack.Owner, players(prive), x1, y1, Col, par
End With
MyDoEvents1 bstack.Owner


End Function
Function MyLineInput(bstack As basetask, rest$, Lang As Long) As Boolean
Dim f As Long, p As Variant, what$, it As Long, s$, I As Long, prive As Long, frm$
Dim pppp As mArray
If IsLabelSymbolNew(rest$, "ÅÉÓÁÃÙÃÇÓ", "INPUT", Lang) Then
If FastSymbol(rest$, "#") Then

    If Not IsExp(bstack, rest$, p) Then Exit Function
    If Not FastSymbol(rest$, ",") Then Exit Function
    f = CLng(p)
    Select Case Abs(IsLabel(bstack, rest$, what$))
    Case 1
        If GetVar(bstack, what$, I) Then
            If MemInt(VarPtr(var(I))) = vbString Then GoTo haveit
            MyEr "Missing Strung Type", "Äåí âñÞêá ôýðï ÃÑÁÌÌÁ": Exit Function
        Else
            GoTo haveit
        End If
    Case 3
haveit:
    MyLineInput = True
    If uni(f) Then
    If Not getUniStringlINE(f, s$) Then MyLineInput = False: MyEr "Can't input, not UTF16LE", "Äåí ìðïñþ íá åéóÜãù, ü÷é UTF16LE": Exit Function
    Else
    getAnsiStringlINE f, s$
    End If
    If GetVar(bstack, what$, I) Then
    CheckVar var(I), s$
    Else
    globalvar what$, s$
    End If
    Case 6, 5
    If neoGetArray(bstack, what$, pppp) Then

    If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Exit Function
    Else
    Exit Function
    End If
    MyLineInput = True
    If uni(f) Then
    If Not getUniStringlINE(f, s$) Then MyLineInput = False: MyEr "Can't input, not UTF16LE", "Äåí ìðïñþ íá åéóÜãù, ü÷é UTF16LE": Exit Function
    Else
    getAnsiStringlINE f, s$
    End If
    If pppp.ItemType(it) = doc Then
    Set pppp.item(it) = New Document
    If s$ <> "" Then pppp.item(it).textDoc = s$
    Else
    pppp.item(it) = s$
    End If
    End Select
Else
If Not releasemouse Then If Not Form1.Visible Then newshow Basestack1

If bstack.toprinter = True Then oxiforPrinter:   Exit Function
prive = GetCode(bstack.Owner)
If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
End If
Select Case Abs(IsLabel(bstack, rest$, what$))
Case 3
           
                If players(prive).lastprint Then
                LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                players(prive).lastprint = False
                End If
QUERY bstack, frm$, s$, 1000, False

                If GetVar(bstack, what$, I) Then
                        CheckVar var(I), s$
                Else
                        globalvar what$, s$
                End If
                 MyLineInput = True
Case 6
            If neoGetArray(bstack, what$, pppp) Then
                       If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Exit Function
                Else
                 MyEr "No such array", "Äåí õðÜñ÷åé ôÝôïéïò ðßíáêáò"
                       Exit Function
                End If
            
                If players(prive).lastprint Then
                LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                players(prive).lastprint = False
                End If
QUERY bstack, frm$, s$, 1000, False

 If pppp.ItemType(it) = doc Then
                Set pppp.item(it) = New Document
                        If s$ <> "" Then pppp.item(it).textDoc = s$
                Else
                        pppp.item(it) = s$
                End If
                 MyLineInput = True
End Select

End If


End If
End Function
Function MyAnyType(basestack As basetask, rest$, Lang As Long, Optional alocal As Boolean, Optional thattype As Integer = vbLong, Optional SameIfExist As Boolean = False, Optional zeroitem) As Boolean
    Dim s$, what$, I As Long, p As Variant, P1 As Variant, j As Long, getmore As Boolean, skipcheck As Boolean
    MyAnyType = True
    If thattype = vbLong Then If IsLabelSymbolNew(rest$, "ÌÁÊÑÕÓ", "LONG", Lang) Then thattype = 20
    skipcheck = lookOne(rest$, ".") Or Len(here$) = 0
    j = Abs(IsLabel(basestack, rest$, what$))
    
    
    Do While j <> 0
        If Not (j = 1 Or j = 4 Or j = 8) Then MyEr "wrong variable type name " + what$, "ëÜèïò ôýðïò ïíüìáôïò ìåôáâëçôÞò " + what$: MyAnyType = False: Exit Function
        If thattype = vbVariant And (j <> 1 And j <> 8) Then MyEr "variants can't be used with % or $ at the end", "Ïé Üôõðïé äåí ìðïñïýí íá Ý÷ïõí % Þ $ óôï üíïìÜ ôïõò": MyAnyType = False: Exit Function
        
        If basestack.priveflag Then what$ = ChrW(&HFFBF) + what$
        If Not FastSymbol(rest$, "<") Then  ' get local var first

            If SameIfExist Then
                If GetlocalVar(basestack.GroupName + what$, I) Then
                    If j = 8 Then GoTo makeitnow1
                    If MyIsObject(var(I)) Then
                        Set p = var(I)
                        If Not p Is Nothing Then
                            If TypeOf p Is Group Then
                                If Not p.IamApointer Then
                                     MyAnyType = False
                                    WrongType
                                    Exit Function
                                End If
                            End If
                        End If
                    Else
                    p = var(I)
                    End If
                    GoTo there01
                ElseIf GetVar(basestack, basestack.GroupName + what$, I) Then
                
                    If skipcheck Then GoTo there123
                    If I <= basestack.Vars Then
                        I = globalvar(basestack.GroupName + what$, Empty, useType:=thattype <> vbVariant)     ' MAKE ONE  '
                        GoTo makeitnow1
                    Else
there123:
                    If j = 8 Then GoTo makeitnow1
                    If MyIsObject(var(I)) Then
                        Set p = var(I)
                        If Not p Is Nothing Then
                            If TypeOf p Is Group Then
                                If Not p.IamApointer Then
                                     MyAnyType = False
                                    WrongType
                                    Exit Function
                                End If
                            End If
                        End If
 
                    Else
                    p = var(I)
                    End If
                    
                    GoTo there01
                    End If
                Else
newvar:
                    I = globalvar(basestack.GroupName + what$, Empty, useType:=(thattype <> vbVariant Or j = 8))     ' MAKE ONE  '
                    GoTo makeitnow1
                End If
            Else
                    I = globalvar(basestack.GroupName + what$, Empty, makeitglobal:=Not alocal, useType:=thattype <> vbVariant)       ' MAKE ONE  '
                    GoTo makeitnow1
            End If
        ElseIf GetVar(basestack, basestack.GroupName + what$, I) Then
            
there01:
            If MyIsObject(var(I)) Then
                Set var(I) = Nothing
                p = 0
            End If
            var(I) = Empty
            On Error Resume Next
            Err.Clear
            Select Case thattype
            Case vbObject
                '
            Case vbInteger
                var(I) = CInt(p)
            Case 20
                var(I) = cInt64(p)
            Case vbLong
                var(I) = CLng(p)
            Case vbDecimal
                var(I) = CDec(p)
            Case vbCurrency
                var(I) = CCur(p)
            Case vbSingle
                var(I) = CSng(p)
            Case vbDouble
                var(I) = CDbl(p)
            Case vbBoolean
                var(I) = CBool(p)
            Case vbString
                var(I) = p
            Case vbByte
                var(I) = CByte(p)
            Case vbDate
                var(I) = CDate(p)
            Case vbVariant
                varhash.vType(varhash.Index) = False
                If MyIsObject(p) Then
                    Set var(I) = p
                Else
                    var(I) = p
                End If
            Case 200
                var(I) = nMath2.cxZero
            End Select
            If Err > 0 Then
                If Err.Number = 6 Then OverflowValue thattype
                Err.Clear
                MyAnyType = False
                Exit Function
            End If
            GoTo there12
        Else
            I = globalvar(basestack.GroupName + what$, Empty, useType:=thattype <> vbVariant) ' MAKE ONE
            If I <> 0 Then
makeitnow1:
                If j = 8 Then
                Dim rA As refArray
                Set rA = New refArray
                Dim skipitems As Boolean
                skipitems = False
                If Not IsExp(basestack, rest$, p, flatobject:=True, nostring:=thattype <> vbString) Then
                   ' MyAnyType = False: MissNumExpr: Exit Function
                    p = 0&
                    skipitems = True
                End If
                p = Abs(Int(p))
                If Not FastSymbol1(rest$, "]") Then
                        MyAnyType = False: SyntaxError: Exit Function
                End If
                Set var(I) = rA
                P1 = 0
                If skipitems Then
                    rA.emtype = thattype
                    'rA.DefArrayAt 0, thattype, CLng(p)
                    rA.MarkTwoDimension = False
                ElseIf FastSymbol1(rest$, "[") Then
                    If Not IsExp(basestack, rest$, P1, flatobject:=True, nostring:=thattype <> vbString) Then
                        MyAnyType = False: MissNumExpr: Exit Function
                    End If
                    If Not FastSymbol1(rest$, "]") Then
                        MyAnyType = False: SyntaxError: Exit Function
                    End If
                    I = Abs(Int(P1))
                    j = CLng(p)
                    For j = j To 0 Step -1
                        rA.DefArrayAt CVar(j), thattype, I
                    Next j
                    rA.MarkTwoDimension = True
                    If FastSymbol(rest$, "=") Then
                        j = CLng(p)
                        If IsExp(basestack, rest$, p) Then
                        If myVarType(p, vbString) Then
                        SwapString2Variant s$, p
                        GoTo contGetStr
                        End If
                        For I = I To 0 Step -1
                        For P1 = j To 0 Step -1
                            rA(P1, I) = p
                            Select Case rA.AssignError
                            Case 0
                            Case 6
                                Err.Clear
                                OverflowValue VarType(rA(P1, I))
                                MyAnyType = False
                                Exit Function
                            Case Else
                                MyEr Err.Description, Err.Description
                                Err.Clear
                                MyAnyType = False
                                Exit Function
                            End Select
                        Next P1
                        Next I
                        ElseIf IsStrExp(basestack, rest$, s$, False) Then
contGetStr:
                            For I = I To 0 Step -1
                            For P1 = j To 0 Step -1
                            rA(P1, I) = s$
                            p = rA.AssignError
                            If p <> 0 Then
                             MyEr Err.Description, Err.Description
                             Err.Clear
                             MyAnyType = False
                             Exit Function
            
                            End If
                            Next P1
                            Next I
                        Else
                                MyAnyType = False
                                 Exit Function
                        End If
                        
                    
                    End If
                    
 
                    
                Else
                    rA.DefArrayAt 0, thattype, CLng(p)
                    rA.MarkTwoDimension = False
                    P1 = p
                    If FastSymbol(rest$, "=") Then
                        If IsExp(basestack, rest$, p) Then
                        If myVarType(p, vbString) Then
                        SwapString2Variant s$, p
                        GoTo contGetStr0
                        End If
                        If Not IsMissing(zeroitem) Then
                        If basestack.lastobj Is Nothing Then
                        If TypeOf zeroitem Is BigInteger Then
                            Set basestack.lastobj = Module13.CreateBigInteger(CStr(Int(p)))
                        Else
                            SyntaxError
                            Exit Function
                        End If
                        ElseIf Typename(basestack.lastobj) = Typename(zeroitem) Then
                        ' do nothing
                        Else
                            WrongType
                            Exit Function
                        End If
                      '  SwapVariant p, P1
                        End If
                            If basestack.lastobj Is Nothing Then
                             For I = CLng(P1) To 0 Step -1
                                    rA(0, I) = p
                                    P1 = rA.AssignError
                                    If P1 <> 0 Then
                                        If P1 = 6 Then
                                            Err.Clear
                                            OverflowValue VarType(rA(0, I))
                                            MyAnyType = False
                                            Exit Function
                                        Else
                                            MyEr Err.Description, Err.Description
                                            Err.Clear
                                            MyAnyType = False
                                            Exit Function
                                        End If
                                    End If
                             Next I
                            Else
contGetStr0:
                             For I = CLng(P1) To 0 Step -1
                                   rA(0, I) = CVar(basestack.lastobj)
                                   P1 = rA.AssignError
                                    If P1 <> 0 Then
                                        MyEr Err.Description, Err.Description
                                        Err.Clear
                                        MyAnyType = False
                                        Exit Function
                                    End If
                             Next I
                            End If
                        ElseIf IsStrExp(basestack, rest$, s$, False) Then
                        If Not IsMissing(zeroitem) Then
                            Set basestack.lastobj = Module13.CreateBigInteger(s$)
                            SwapVariant p, P1
                        End If
                             If basestack.lastobj Is Nothing Then
                             For I = CLng(P1) To 0 Step -1
                                    
                                    rA(0, I) = s$
                                    P1 = rA.AssignError
                                    If P1 <> 0 Then
                                        If P1 = 6 Then
                                            Err.Clear
                                            OverflowValue VarType(rA(0, I))
                                            MyAnyType = False
                                            Exit Function
                                        Else
                                            MyEr Err.Description, Err.Description
                                            Err.Clear
                                            MyAnyType = False
                                            Exit Function
                                        End If
                                    End If
                             Next I
                            Else
                             For I = CLng(p) To 0 Step -1
                                    rA(0, I) = CVar(basestack.lastobj)
                                   P1 = rA.AssignError
                                    If P1 <> 0 Then
                                        MyEr Err.Description, Err.Description
                                        Err.Clear
                                        MyAnyType = False
                                        Exit Function
                                    End If
                             Next I
                            End If
                        Else
                        
                        End If
                    End If
                End If
                    
                    GoTo contNext
                Else
                Select Case thattype
                Case vbObject
                    If Not IsMissing(zeroitem) Then
                        If TypeOf zeroitem Is BigInteger Then
                            Set var(I) = New BigInteger
                        Else
                            Set var(I) = zeroitem
                        End If
                    Else
                         Set var(I) = Nothing
                    End If
                Case vbInteger
                    var(I) = 0
                Case 20
                    var(I) = cInt64(0)
                Case vbLong
                    var(I) = 0&
                Case vbDecimal
                    var(I) = CDec(0)
                Case vbCurrency
                    var(I) = 0@
                Case vbSingle
                    var(I) = 0!
                Case vbDouble
                    var(I) = CDbl(0)
                Case vbBoolean
                    var(I) = False
                Case vbString
                    var(I) = vbNullString
                Case vbVariant
                    var(I) = Empty
                Case vbByte
                    var(I) = CByte(0)
                Case vbDate
                    var(I) = CDate(0)
                Case 200
                    var(I) = nMath2.cxZero
                End Select
                If Err > 0 Then
                    If Err.Number = 6 Then OverflowValue thattype
                    Err.Clear
                    MyAnyType = False
                    Exit Function
                End If
                End If
there12:
                If FastSymbol(rest$, "=") Then
                    If IsExp(basestack, rest$, p) Then
                    On Error Resume Next
                    Err.Clear
                    If thattype = 12 Then
                        If Not basestack.lastobj Is Nothing Then
                            GoTo jumphereObject
                        Else
                            var(I) = p
                        End If
                    ElseIf thattype = 200 Then
                        If TypeOf p Is cxComplex Then
                            var(I) = p
                        Else
                            var(I) = nMath2.cxNew(CDbl(p), 0)
                        End If
                     
                    ElseIf Not myVarType(p, thattype) Then
                        Select Case thattype
                        Case vbObject
                            If Not basestack.lastobj Is Nothing Then
jumphereObject:
                                Set p = basestack.lastobj
                                If TypeOf p Is Group Then
                                If Not p.IamApointer Then
                                    MakeGroupPointer basestack, p
                                    Set p = basestack.lastobj
                                End If
                                End If
                                If var(I) Is Nothing Then
                                Set var(I) = p
                                ElseIf TypeOf var(I) Is BigInteger Then
                                    If TypeOf p Is BigInteger Then
                                    Set var(I) = p
                                    Else
                                    WrongType
                                    GoTo ex1
                                    End If
                                ElseIf Not IsMissing(zeroitem) Then
                                    If Typename(zeroitem) = Typename(var(I)) Then
                                        Set var(I) = p
                                    Else
                                        WrongType
                                        GoTo ex1
                                    End If
                                Else
                                Set var(I) = p
                                End If
                                Set basestack.lastobj = Nothing
                                Set basestack.lastpointer = Nothing
                            Else
                            If Not IsMissing(zeroitem) Then
                                If TypeOf zeroitem Is BigInteger Then
                                Dim zerobigint As BigInteger
                                Set zerobigint = var(I)
                                If MemInt(VarPtr(p)) <> vbString Then
                                    p = CStr(Int(p))
                                End If
                                SwapString2Variant s$, p
                                zerobigint.AnyBaseInput s$
                                End If
                            Else
                                Set var(I) = Nothing
                                End If
                            End If
                            
                        Case vbInteger
                            var(I) = CInt(p)
                        Case 20
                            var(I) = cInt64(p)
                        Case vbLong
                            var(I) = CLng(p)
                        Case vbDecimal
                            If j = 4 Then p = Round(p)
                            var(I) = CDec(p)
                        Case vbCurrency
                            If j = 4 Then p = Round(p)
                            var(I) = CCur(p)
                        Case vbSingle
                            If j = 4 Then p = Round(p)
                            var(I) = CSng(p)
                        Case vbDouble
                            If j = 4 Then p = Round(p)
                            var(I) = CDbl(p)
                        Case vbBoolean
                            var(I) = CBool(p)
                        Case vbString
                            Select Case MemInt(VarPtr(p))
                              Case vbString, vbDate
                                  var(I) = p
                              Case 20
                                 var(I) = CStr(p)
                        
                              Case vbBoolean
                                  var(I) = Format(p, DefBooleanString)
                              Case Else
                                var(I) = fixthis(p)
                            End Select
                            
                        Case vbByte
                            var(I) = CByte(p)
                        Case vbDate
                            var(I) = CDate(p)
                        End Select
                    Else
                        If j = 4 Then p = Round(p)
                        
                        var(I) = p
                    End If
                    
                Set basestack.lastobj = Nothing
                Set basestack.lastpointer = Nothing
                    If Err > 0 Then
                        If Err.Number = 6 Then OverflowValue thattype
                        Err.Clear
                    MyAnyType = False
                    Exit Function
                End If
                    Else
                        If thattype = vbVariant Then
                            If IsStrExp(basestack, rest$, s$, False) Then
                                var(I) = vbNullString
                                var(I) = CVar(s$)
                            Else
                                MissNumExpr
                                MyAnyType = False
                                Exit Function
                            End If
                        ElseIf thattype = vbString Then
                            If IsStrExp(basestack, rest$, s$, False) Then
                                var(I) = vbNullString
                                var(I) = CVar(s$)
                            Else
                                MissNumExpr
                                MyAnyType = False
                                 Exit Function
                            End If
                        ElseIf thattype = vbDate Then
                            If IsExp(basestack, rest$, p, , True) Then
                                var(I) = CDate(p)
                            ElseIf IsStrExp(basestack, rest$, s$, False) Then
                                var(I) = CDate(s$)
                            Else
                                MissNumExpr
ex1:
                                MyAnyType = False
                                 Exit Function
                            End If
                        ElseIf thattype = vbObject Then
                            If TypeOf var(I) Is BigInteger Then
                            If IsExp(basestack, rest$, p, , True) Then
                             SwapString2Variant s$, CStr(Int(p))
                            ElseIf Not IsStrExp(basestack, rest$, s$, False) Then
                               SyntaxError
                               GoTo ex1
                            End If
                            Set var(I) = Module13.CreateBigInteger(s$)
                            End If
                        Else
                            MissNumExpr
                            MyAnyType = False
                             Exit Function
                        End If
                    End If
                Else
                    If Not MaybeIsTwoSymbol(rest$, "//") Then
                        If MaybeIsSymbol(rest$, "><~+-*/|!@#$%^&") Then SyntaxError: MyAnyType = False: Exit Do
                    End If
                End If
            End If
        End If
contNext:
        If Not FastSymbol(rest$, ",") Then Exit Do
        DropCommentOrLine rest$
        skipcheck = lookOne(rest$, ".") Or Len(here$) = 0
        j = Abs(IsLabel(basestack, rest$, what$))
    Loop
End Function

Function ProcSoundRec(basestack As basetask, rest$, Lang As Long) As Boolean
' not tested yet...
Dim s$, p As Variant, ss$, X As Double, Y As Double
Dim LRec As RecordMci
    
    
    If IsLabelSymbolNew(rest$, "ÍÅÁ", "NEW", Lang) Then
        Set sRec = New RecordMci
        Set LRec = sRec
        If Not LRec.HaveMic Then GoTo noMic
        LRec.Rec_Initialize
        If IsStrExp(basestack, rest$, s$) Then LRec.FileName = s$
        If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                If IsLabelSymbolLatin(rest$, "STEREO") Then
                    LRec.Stereo
                Else
                    LRec.Mono
                End If
                If IsLabelSymbolLatin(rest$, "HIFI") Then
                    LRec.Bit16
                Else
                    LRec.Bit8
                End If
                LRec.QualityAny CDbl(p)
        End If
    Else
        If sRec Is Nothing Then
         Set sRec = New RecordMci
         If Not LRec.HaveMic Then GoTo noMic
        End If
        Set LRec = sRec
        LRec.RecFast
    End If
    ElseIf Not (sRec Is Nothing) Then
        Set LRec = sRec
    ss$ = vbNullString
    
    If IsLabelSymbolNewExp(rest$, "ÅÉÓÁÃÙÃÇ", "INSERT", Lang, ss$) Then
        LRec.Capture True
    ElseIf IsLabelSymbolNewExp(rest$, "ÁËËÁÃÇ", "OVERWRITE", Lang, ss$) Then
        LRec.ReCapture
    ElseIf IsLabelSymbolNewExp(rest$, "ÁÐÏÊÏÐÇ", "DELETE", Lang, ss$) Then
            If IsExp(basestack, rest$, X, , True) Then
            Else
                X = 0
            End If
            If IsLabelSymbolNew(rest$, "ÅÙÓ", "TO", Lang) Then
                If Not IsExp(basestack, rest$, Y, , True) Then
                    Y = LRec.getLengthInMS
                End If
            Else
                Y = LRec.getLengthInMS
            End If
            LRec.CutRecordMs CDbl(X), CDbl(Y)
    ElseIf IsLabelSymbolNewExp(rest$, "ÅÍÔÁÓÇ", "VOLUME", Lang, ss$) Then
                If IsExp(basestack, rest$, X, , True) Then
                    If X < 0 Then X = 0
                    If X > 100 Then X = 100
                    LRec.setVolume CLng(X)
                Else
                    LRec.setVolume 50&
                End If
    ElseIf IsLabelSymbolNewExp(rest$, "ÄÉÁÊÏÐÇ", "STOP", Lang, ss$) Then
        LRec.recStop
    ElseIf IsLabelSymbolNewExp(rest$, "ÄÏÊÉÌÇ", "TEST", Lang, ss$) Then
        LRec.recPlay
    ElseIf IsLabelSymbolNewExp(rest$, "ÈÅÓÇ", "POS", Lang, ss$) Then
        If LRec.isRecPlaying Then
            If IsExp(basestack, rest$, X, , True) Then
            LRec.recPlayFromMs X
            Else
            LRec.recPlay
            End If
        Else
        ' SEEK
            If IsExp(basestack, rest$, X, , True) Then
            LRec.oneMCI "seek capture to " + CStr(CLng(X))
            Else
            LRec.oneMCI "seek capture to 0"
            End If
        End If
    ElseIf IsLabelSymbolNewExp(rest$, "ÓÙÓÅ", "SAVE", Lang, ss$) Then
        If IsStrExp(basestack, rest$, s$) Then
            LRec.SaveAs s$
        Else
            LRec.Save
        End If
    ElseIf IsLabelSymbolNewExp(rest$, "ÊËÅÉÓÅ", "END", Lang, ss$) Then
        Set sRec = Nothing
        Set LRec = Nothing
    End If
    Else
        
        MyEr "You don't have new recording", "Äåí Ý÷åéò åôïéìÜóåé íÝá ç÷ïãñÜöçóç"
    End If
  ProcSoundRec = True
  Exit Function
noMic:
MissMic
  
End Function

Public Function ScanTarget(j() As target, ByVal X As Long, ByVal Y As Long, ByVal myl As Long) As Long
Dim iu&, id&, I&, XX&, YY&

iu& = LBound(j())
id& = UBound(j())
ScanTarget = -1
For I& = iu& To id&
With j(I&)
If .Enable And .layer = myl Then
XX& = X \ .Xt
YY& = Y \ .Yt
If .lX <= XX& And .tx >= XX& And .lY <= YY& And .ty >= YY& Then
ScanTarget = I&
Exit For
End If
End If
End With
Next I&
End Function
Function ProcMedia(basestack As basetask, rest$, Lang As Long) As Boolean
Dim Scr As Object
Dim s$, ss$, X As Double, Y As Double
Set Scr = basestack.Owner
On Error Resume Next
ProcMedia = True
If IsLabelSymbolNew(rest$, "ÖÏÑÔÙÓÅ", "LOAD", Lang) Then
            If AVIUP Then
                  AVI.GETLOST
                  MyDoEvents
            End If
            If IsStrExp(basestack, rest$, s$) Then
                If s$ <> "" Then
                    If ExtractType(s$) = vbNullString Then s$ = s$ + ".avi"
                    If CFname(s$) = vbNullString Then
                        s$ = mcd + s$: If CFname(s$) = vbNullString Then Exit Function
                    Else
                        s$ = CFname(s$)
                    End If
                Else
                    Set Scr = Nothing
                    ProcMedia = True  ' ??????????
                    Exit Function
                End If
                avifile = s$
                Load AVI
                If Not OsInfo.IsWindows8Point1OrGreater Then
                MediaPlayer1.playMovie
                MediaPlayer1.pauseMovie
                MediaPlayer1.setPositionTo 0
                End If
                
                Sleep 2
                MyDoEvents
                AVIRUN = False
                    If Form1.Visible Then Form1.SetFocus
                    'MediaPlayer1.setLeftVolume vol * 10
                    'MediaPlayer1.setRightVolume vol * 10
                    
                MediaPlayer1.sizeLocateMovie AVI.Left \ dv15, AVI.top \ dv15, AVI.Width \ dv15, AVI.Height \ dv15
                
            End If
            Set Scr = Nothing
            ProcMedia = True
            Exit Function
            
    ElseIf AVIUP Then
    ss$ = vbNullString
        If IsLabelSymbolNewExp(rest$, "ÄÅÉÎÅ", "SHOW", Lang, ss$) Then
            'If Not AVIRUN Then MediaPlayer1.playMovie: MediaPlayer1.pauseMovie
            
            
            If Scr.Name = "GuiM2000" Then
            If Scr.Visible Then
                
                AVI.Show , Scr
                
                MediaPlayer1.sizeLocateMovie 0, 0, AVI.Width \ dv15, AVI.Height \ dv15 + 1
                MediaPlayer1.showMovie
                AVI.ZOrder 0
             AVI.SetFocus
                MyDoEvents

      End If
                Set Scr = Nothing
                ProcMedia = True
                Exit Function
           
                
            Else
                If Form1.Visible Then
                AVI.Show , Form1
                Else
                AVI.Show , Form5
                End If
               'MediaPlayer1.sizeLocateMovie 0, 0, AVI.Width \ dv15, AVI.Height \ dv15 + 1
               MediaPlayer1.showMovie
                AVI.ZOrder 0
             AVI.SetFocus
                MyDoEvents
                Set Scr = Nothing
                ProcMedia = True
                Exit Function
       End If
        ElseIf IsLabelSymbolNewExp(rest$, "ÊÑÕØÅ", "HIDE", Lang, ss$) Then
                AVI.Hide
                Set Scr = Nothing
                ProcMedia = True
                Exit Function
        ElseIf IsLabelSymbolNewExp(rest$, "ÊÑÁÔÇÓÅ", "PAUSE", Lang, ss$) Then
                If MediaPlayer1.isMoviePlaying Then MediaPlayer1.pauseMovie
                Set Scr = Nothing
                ProcMedia = True
                Exit Function
        ElseIf IsLabelSymbolNewExp(rest$, "ÐÁÉÎÅ", "PLAY", Lang, ss$) Then
        
                If Not AVIRUN Then
                AVI.Interval = MediaPlayer1.getLengthInMS - MediaPlayer1.getPositionInMS
                AVI.Avi2Up
                End If
        
                MyDoEvents
                Set Scr = Nothing
                ProcMedia = True
                Exit Function
        ElseIf IsLabelSymbolNewExp(rest$, "ÎÅÊÉÍÁ", "RESTART", Lang, ss$) Then
                    If Not MediaPlayer1.isMoviePlaying Then
                    
                         MediaPlayer1.playMovie
                         
                    Else
                         MediaPlayer1.resumeMovie
                    End If
                    MyDoEvents
                    AVIRUN = False
                    Set Scr = Nothing
                    ProcMedia = True
                    Exit Function
        ElseIf IsLabelSymbolNewExp(rest$, "ÓÔÏ", "TO", Lang, ss$) Then
                    If IsExp(basestack, rest$, X) Then
                        If MediaPlayer1.getLengthInMS > 0 Then MediaPlayer1.setPositionTo X
                        
                    End If
                    Set Scr = Nothing
                    ProcMedia = True
                    Exit Function

        End If
    ElseIf IsLabelSymbolNewExp(rest$, "ÊÑÕØÅ", "HIDE", Lang, ss$) Then
    
    End If
    ss$ = vbNullString
' do nothing until here
If IsExp(basestack, rest$, X) Then
   
            If FastSymbol(rest$, ",") Then
    
             UseAviSize = False
    AviSizeX = 0
    AviSizeY = 0
    aviX = 0
    aviY = 0
    UseAviSize = False
    UseAviXY = True: aviX = CLng(X): aviY = 0
            If IsExp(basestack, rest$, Y) Then aviY = CLng(Y) Else ProcMedia = False: UseAviXY = False: aviX = 0
            Else ' SPECIAL
            If MediaPlayer1.getLengthInMS > 0 Then
                If X < 0 Then
                MediaPlayer1.pauseMovie
                AVIRUN = MediaPlayer1.isMoviePlaying
                If Scr.Name <> "Printer" Then
                If Scr.Visible Then Scr.SetFocus
                End If
                ElseIf X = 0 Then
                          
                MediaPlayer1.playMovie
                MyDoEvents
                Else
                MediaPlayer1.setPositionTo X
                End If
                ProcMedia = True
        Else
        ProcMedia = False
        End If
        Set Scr = Nothing
        Exit Function
            End If
            If aviX = 0 Then UseAviXY = False
            If FastSymbol(rest$, ",") Then
                    If IsExp(basestack, rest$, X) Then AviSizeX = CLng(X) Else rest$ = "," + rest$
                If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, X) Then AviSizeY = CLng(X) Else rest$ = "," + rest$
                End If
                UseAviSize = (Abs(AviSizeY) + Abs(AviSizeX)) <> 0 Or (aviX = 0 And aviY = 0)
                
            End If
            If Not FastSymbol(rest$, ",") Then
                   If AVIUP Then
                   If UseAviXY And UseAviSize Then
                   AVI.move aviX, aviY, AviSizeX, AviSizeY
                   MediaPlayer1.sizeLocateMovie 0, 0, AviSizeX \ dv15, AviSizeY \ dv15 + 1
                   ElseIf UseAviXY Then
                   AVI.move aviX, aviY
                    MediaPlayer1.sizeLocateMovie 0, 0, AVI.Width \ dv15, AVI.Height \ dv15 + 1
                    ElseIf UseAviSize Then
                     AVI.move AVI.Left, AVI.top, AviSizeX, AviSizeY
                   MediaPlayer1.sizeLocateMovie 0, 0, AviSizeX \ dv15, AviSizeY \ dv15 + 1
                    End If
                    If AVI.Visible Then AVI.Refresh
           Else
                   If AVIRUN Or AVIUP Then
                AVI.GETLOST
            End If
           
            End If
            Set Scr = Nothing
            Exit Function
            
            End If
      
ElseIf FastSymbol(rest$, ";") Then
'MediaPlayer1.closeMovie
    UseAviXY = False
    UseAviSize = False
    AviSizeX = 0
    AviSizeY = 0
    aviX = 0
    aviY = 0
    AVI.GETLOST
Else
 
'MediaPlayer1.closeMovie
If AVIRUN Or AVIUP Then
                AVI.GETLOST
              
            End If
  
End If

Do
ProcTask2 basestack

 If Not MediaPlayer1.isMoviePlaying Then AVIRUN = False
Loop Until Not AVIRUN Or NOEXECUTION

Do While IsStrExp(basestack, rest$, s$)
If s$ <> "" Then
If ExtractType(s$) = vbNullString Then s$ = s$ + ".avi"
    If CFname(s$) = vbNullString Then
        s$ = mcd + s$: If CFname(s$) = vbNullString Then Set Scr = Nothing: Exit Function

    Else
        s$ = CFname(s$)
    End If
    Else
    AVI.GETLOST
    Exit Do
End If
avifile = s$
Load AVI
If UseAviXY Then
AVI.Left = aviX
AVI.top = aviY
End If
AVI.Avi2Up

If Form1.Visible Then
                AVI.Show , Form1
                Else
                AVI.Show
                End If

 'AVI.Show
Sleep 5

If AVIRUN Then
If AVI.Height > 0 Then If Form1.Visible Then Form1.SetFocus
MediaPlayer1.setLeftVolume vol * 10
MediaPlayer1.setRightVolume vol * 10

End If
If FastSymbol(rest$, ",") Then
If AVIRUN Then
Do
 AVIRUN = MediaPlayer1.isMoviePlaying
 ProcTask2 basestack
' sleep 5

Loop Until AVIRUN = False Or NOEXECUTION
End If
Else
If FastSymbol(rest$, ";") Then
If AVIRUN Then
Do
 AVIRUN = MediaPlayer1.isMoviePlaying
ProcTask2 basestack
 ' sleep 5

Loop Until AVIRUN = False Or NOEXECUTION
End If
End If
Exit Do
End If
Loop
Set Scr = Nothing
Exit Function


End Function

Function Num2Str(p, FTXT As String) As String
        Dim s$
        If TypeOf p Is cxComplex Then
            If p.I >= 0 Then s$ = "+"
            If p.I = 1 Then
                Num2Str = "(" + Num2Str(p.r, FTXT) + "+i)"
            Else
                Num2Str = "(" + Num2Str(p.r, FTXT) + s$ + Num2Str(p.I, FTXT) + "i)"
            End If
        ElseIf Not NoUseDec Then
                If OverideDec Then
                    s$ = Replace$(Format$(p, FTXT), GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                    s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                    s$ = Replace$(s$, Chr(2), NowDec$)
                    Num2Str = Replace$(s$, Chr(3), NowThou$)
                ElseIf InStr(s$, NowDec$) > 0 And InStr(FTXT, ".") > 0 Then
                    Num2Str = Format$(p, FTXT)
                ElseIf InStr(s$, NowDec$) > 0 Then
                    s$ = Replace$(Format$(p, FTXT), NowDec$, Chr(2))
                    s$ = Replace$(s$, NowThou$, Chr(3))
                    s$ = Replace$(s$, Chr(2), ".")
                    Num2Str = Replace$(s$, Chr(3), ",")
                End If
        Else
            Num2Str = Format$(p, FTXT)
        End If
End Function


Function ProcImage(bstack As basetask, rest$, Lang As Long) As Boolean
Dim photo As cDIBSection, pppp As mArray, s$, x1 As Long, y1 As Long, W$, it As Long, p As Variant, part As Boolean, Border As Long, titl$
Dim aPic As StdPicture, s1$, usecolorback As Boolean, ihavepic As Boolean, mem As MemBlock, cback As Long, usehandler As mHandler
ProcImage = True
part = IsLabelSymbolNew(rest$, "ÐËÁÉÓÉÏ", "FRAME", Lang)
If IsStrExp(bstack, rest$, s$) Then
    ihavepic = Left$(s$, 4) = "cDIB" And Len(s$) > 12
    GoTo cont1
ElseIf IsExp(bstack, rest$, p) Then
    If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mHandler Then
        Set usehandler = bstack.lastobj
            If usehandler.T1 = 2 Then
                Set mem = usehandler.objref
                Set usehandler = Nothing
                Set bstack.lastobj = Nothing
                If FastSymbol(rest$, "(") Then
                    If Not IsExp(bstack, rest$, p) Then MissNumExpr: Exit Function
               
                    usecolorback = True
                    cback = mycolor(p)
                    If Not FastSymbol(rest$, ")", True) Then Exit Function
                End If
                If mem Is Nothing Then
                GoTo errNoImage
                ElseIf usecolorback Then
                    Set aPic = mem.GetStdPicture(, , cback)
                Else
                    Set aPic = mem.GetStdPicture()
                End If
                Set bstack.lastobj = Nothing
                GoTo cont1
            End If
        End If
    End If
    Set usehandler = Nothing
    Set bstack.lastobj = Nothing
errNoImage:
    MyEr "No Image found", "Äåí âñÞêá åéêüíá"
    Exit Function
cont1:
    x1 = 0
    y1 = 0
    If aPic Is Nothing Then If Not ihavepic Then If ExtractType(s$) = vbNullString Then s$ = s$ + ".bmp"
    If part Then
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then x1 = p
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p Else ProcImage = False: MissNumExpr: Exit Function
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then Border = p Else ProcImage = False: MissNumExpr: Exit Function
        If FastSymbol(rest$, ",") Then If Not IsStrExp(bstack, rest$, titl$) Then ProcImage = False: MissStringExpr: Exit Function
        If Not aPic Is Nothing Then
            Set photo = New cDIBSection
            photo.CreateFromPicture aPic
            photo.GetDpi 96, 96
            If photo.Width = 0 Then
                Set photo = Nothing
                MissCdib
                ProcImage = False: Exit Function
            End If
            If photo.bitsPerPixel <> 24 Then Conv24 photo
            ThumbImageDib bstack.Owner, x1, y1, photo, Border, dv15, titl$
            Set photo = Nothing
        ElseIf Not ihavepic Then
            Set photo = New cDIBSection
            If CFname(s$) <> "" Then
                s$ = CFname(s$)
                Set aPic = LoadMyPicture(GetDosPath(s$))
                If aPic Is Nothing Then Exit Function
                photo.CreateFromPicture aPic
                photo.GetDpi 96, 96
                If photo.Width = 0 Then
                    Set photo = Nothing
                    MissCdib
                    ProcImage = False: Exit Function
                End If
                CheckOrientation photo, s$
                If photo.bitsPerPixel <> 24 Then Conv24 photo
                ThumbImageDib bstack.Owner, x1, y1, photo, Border, dv15, titl$
                Set photo = Nothing
            End If
        Else
           ThumbImage bstack.Owner, x1, y1, s$, Border, dv15, titl$
        End If
    ElseIf IsLabelSymbolNew(rest$, "ÓÔÏ", "TO", Lang) Then
        If CFname(s$) <> "" Or ihavepic Or Not aPic Is Nothing Then
            Select Case Abs(IsLabel(bstack, rest$, W$))
            Case 3
                If GetVar(bstack, W$, it) Then
                    If FastSymbol(rest$, "(") Then
                        If IsExp(bstack, rest$, p) Then usecolorback = True: cback = mycolor(p)
                        If Not FastSymbol(rest$, ")", True) Then ProcImage = False: Exit Function
                    End If
                    Set photo = New cDIBSection
                    If Not (ihavepic Or Not aPic Is Nothing) Then
                        s$ = CFname(s$)
                        Set aPic = LoadMyPicture(s$, usecolorback, cback)
                    End If
                    If Not aPic Is Nothing Then
                        If aPic.Type = vbPicTypeIcon Then photo.BackColor = bstack.Owner.BackColor
                        If aPic.Type = 4 Then
                            If Not mem Is Nothing Then
                            If Not mem.SubType = 2 Then GoTo 1000
                            Set aPic = mem.GetStdPicture1(-1, -1, cback, True, True, True)
                            photo.CreateFromPicture aPic
                            GoTo 1010
                            Else
1000
                            With players(GetCode(bstack.Owner))
                                photo.emfSizeFactor = 1
                            End With
                            End If
                        End If
                        photo.ClearUp
                        photo.CreateFromPicture aPic, cback
1010
                        photo.GetDpi 96, 96
                        If photo.Width = 0 Then
                            Set photo = Nothing
                            MissCdib
                            ProcImage = False: Exit Function
                        End If
                        If Len(s$) > 0 Then CheckOrientation photo, s$
                        If photo.bitsPerPixel <> 24 Then Conv24 photo
                    ElseIf Not cDib(s$, photo) Then
                        Set photo = Nothing
                        ProcImage = False
                        MyEr "No Image Found", "Äåí âñÞêå åéêüíá"
                        Exit Function
                    End If
                    x1 = photo.Width
                    y1 = photo.Height
                    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then x1 = x1 * p / 100#: y1 = y1 * p / 100#
                    If FastSymbol(rest$, ",") Then
                        If IsExp(bstack, rest$, p) Then
                            y1 = photo.Height * p / 100#
                        Else
                            Set photo = Nothing
                            ProcImage = False: MissNumExpr: Exit Function
                        End If
                    End If
                    If photo.Width > 0 Then
                    If Not (Abs(y1) = photo.Width And Abs(x1) = photo.Height) Then
                        If photo.BitmapType = 4 Then
                            Set aPic = photo.Picture()
                            p = Sqr(y1 * x1 / (photo.Width * photo.Height))
                            photo.ClearUp
                            photo.emfSizeFactor = p
                            photo.CreateFromPicture aPic, cback
                            photo.GetDpi 96, 96
                        End If
                        Set photo = photo.Resample(Abs(y1), Abs(x1))
                        
                        End If
                        var(it) = DIBtoSTR(photo)
                    Else
                        var(it) = vbNullString
                    End If
                    Set photo = Nothing
                Else
                    ProcImage = False
                    If W$ <> "" Then
                        Nosuchvariable W$
                    Else
                        MissingStrVar
                    End If
                End If
                Exit Function
            Case 6
    ' ÁÐÏ ÐÉÍÁÊÁ
                Dim W5 As Long
                If neoGetArray(bstack, W$, pppp) Then
                    If Not NeoGetArrayItem(pppp, bstack, W$, W5, rest$) Then ProcImage = False: MissNumExpr: Exit Function
                    If MyIsObject(pppp.item(W5)) Then
                        MyEr "can't copy image to " + pppp.ItemType(W5), "äåí ìðïñþ íá áíôéãñÜøù åéêüíá óå " + pppp.ItemType(W5)
                        ProcImage = False
                        Exit Function
                    End If
                    If FastSymbol(rest$, "(") Then
                        If IsExp(bstack, rest$, p) Then usecolorback = True
                        If Not FastSymbol(rest$, ")", True) Then ProcImage = False: Exit Function
                    End If
                    Set photo = New cDIBSection
                    If Not (ihavepic Or Not aPic Is Nothing) Then
                        s$ = CFname(s$)
                        Set aPic = LoadMyPicture(s$, usecolorback, mycolor(p))
                    End If
                    If Not aPic Is Nothing Then
                        If aPic.Type = vbPicTypeIcon Then photo.BackColor = bstack.Owner.BackColor
                        photo.CreateFromPicture aPic
                        photo.GetDpi 96, 96
                        If photo.Width = 0 Then
                            Set photo = Nothing
                            MissCdib
                            ProcImage = False: Exit Function
                        End If
                        CheckOrientation photo, s$
                        If photo.bitsPerPixel <> 24 Then Conv24 photo
                    ElseIf Not cDib(s$, photo) Then
                            Set photo = Nothing
                            MissCdibStr
                            Exit Function
                    End If
                    x1 = photo.Width
                    y1 = photo.Height
                    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then x1 = x1 * p / 100#: y1 = y1 * p / 100#
                    If FastSymbol(rest$, ",") Then
                        If IsExp(bstack, rest$, p) Then
                            y1 = photo.Height * p / 100#
                        Else
                            Set photo = Nothing
                         ProcImage = False: MissNumExpr: Exit Function
                        End If
                    End If
                    If photo.Width > 0 Then
                        Set photo = photo.Resample(y1, x1)
                        If MyIsObject(pppp.item(W5)) Then
                            MyEr "can't copy image to " + pppp.ItemType(W5), "äåí ìðïñþ íá áíôéãñÜøù åéêüíá óå " + pppp.ItemType(W5)
                            ProcImage = False
                        Else
                            pppp.item(W5) = DIBtoSTR(photo)
                        End If
                    End If
                    Set photo = Nothing
                    Exit Function
                Else
                     ProcImage = False: MissingArray W$: Exit Function
                End If
            End Select
        Else
            MyEr "missing file, or image in string or in buffer", "ëåßðåé áñ÷åßï Þ åéêüíá óå áëöáñéèìçôéêü Þ óå äéÜñèñùóç ìíÞìçò"
            ProcImage = False
            Exit Function
        End If
    ElseIf IsLabelSymbolNew(rest$, "ÅÎÁÃÙÃÇ", "EXPORT", Lang) Then
        If IsStrExp(bstack, rest$, W$) Then
            If Not CanKillFile(W$) Then FilePathNotForUser:  Exit Function
            Set photo = New cDIBSection
            If Not (ihavepic Or Not aPic Is Nothing) Then
                 MyEr "No found Image in String or Buffer", "Äåí âñÞêá åéêüíá óå áëöáñéèìçôéêü Þ óå äéÜñèñùóç ìíÞìçò"
                 ProcImage = False
                 Exit Function
            ElseIf aPic Is Nothing Then
                If cDib(s$, photo) Then
cont4:
                    If FastSymbol(rest$, ",") Then
                        If IsExp(bstack, rest$, p) Then
                            x1 = (Abs(p) - 1) Mod 100 + 1
                            s$ = vbNullString
                            If FastSymbol(rest$, ",") Then If Not IsStrExp(bstack, rest$, s$) Then MissStringExpr: ProcImage = False: Exit Function
                            SaveJPG photo, ExtractPath(W$) + ExtractNameOnly(W$, True) + ".jpg", x1, s$
                        Else
                            Set photo = Nothing
                            ProcImage = False: MissNumExpr: Exit Function
                        End If
                    Else
                        photo.SaveDib ExtractPath(W$) + ExtractNameOnly(W$, True) + ".bmp"
                    End If
                Else
                 MyEr "No Proper Image in String", "Äåí âñÞêá êáôÜëëçëç åéêüíá óå áëöáñéèìçôéêü"
                 ProcImage = False
                 Exit Function
                End If
            Else
                photo.BackColor = &HFFFFFF
                photo.CreateFromPicture aPic
                photo.GetDpi 96, 96
                If photo.Width = 0 Then
                    Set photo = Nothing
                    MissCdib
                    ProcImage = False: Exit Function
                End If
                If photo.bitsPerPixel <> 24 Then Conv24 photo
                GoTo cont4
            End If
            Set photo = Nothing
            Exit Function
        Else
             ProcImage = False: MyEr "Missing Filename", "Äåí âñÞêá üíïìá áñ÷åßïõ": Exit Function
        End If
ElseIf mem Is Nothing Then
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then x1 = p
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p Else ProcImage = False: MissNumExpr: Exit Function
    SImage bstack.Owner, x1, y1, s$
Else
    Dim d1 As Object, maybeerror As Boolean
    Set d1 = bstack.Owner
    Dim mm As MetaDc, rr As Single, xSpot As Long, ySpot As Long
    x1 = -1
    y1 = -1
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then x1 = Abs(p)
    
    If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, p) Then
                y1 = Abs(p)
            Else
              maybeerror = True
            End If
    End If
    If TypeOf d1 Is MetaDc Then
        If mem.SubType = 2 Then
            If aPic Is Nothing Then Set aPic = mem.GetStdPicture
            Set mm = d1
            With players(GetCode(d1))
                If FastSymbol(rest$, ",") Then
                If IsExp(bstack, rest$, p) Then rr = p 'MyMod(p, 360)
                If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then xSpot = CSng(p)
                If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then ySpot = CSng(p) Else ProcImage = False: MissNumExpr: Exit Function
                If mem.IsWmf Then
                mm.PlayWmfInside aPic, .XGRAPH / dv15, .YGRAPH / dv15, x1, y1, rr, xSpot / dv15, ySpot / dv15
                Else
                mm.PlayEmfInside aPic, .XGRAPH / dv15, .YGRAPH / dv15, x1, y1, rr, xSpot / dv15, ySpot / dv15
                End If
                Else
                    mm.PaintPicture aPic, .XGRAPH, .YGRAPH, x1, y1
                End If
                
                Exit Function
            End With
        End If
        GoTo renderbitmap
    Else
        'If mem.SubType = 2 Then
        If FastSymbol(rest$, ",") Then
renderthere:
            If IsExp(bstack, rest$, p) Then rr = p 'MyMod(p, 360)
            If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then xSpot = CSng(p)
            If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then ySpot = CSng(p) Else ProcImage = False: MissNumExpr: Exit Function
            Set d1 = bstack.Owner
             mem.DrawEmfToHdc d1, xSpot, ySpot, rr, x1, y1
             
            
            Exit Function
        Else
            If maybeerror Then MissParam rest$: Exit Function
        End If
renderbitmap:
If MaybeIsSymbol(rest$, ",") Then GoTo renderthere
        If x1 > -1 Then x1 = d1.ScaleX(x1, 1, 3)
        If y1 > -1 Then y1 = d1.ScaleY(y1, 1, 3)
        With players(GetCode(d1))
            'If FastSymbol(rest$, ",") Then MyEr "Not for bitmap", "ü÷é ãéá åéêüíá óçìåßùí": ProcImage = False: Exit Function
            
            mem.DrawImageToHdc d1, .XGRAPH \ dv15, .YGRAPH \ dv15, x1, y1
        End With
    End If
End If
End If
End Function
 
Function ProcPlayer(bstack As basetask, rest$, Lang As Long)
Dim par As Boolean, sX As Double, sY As Double, X As Double, Y As Double, x1 As Integer, p As Variant, it As Long
Dim Col As Long, Scr As Object, what$, I As Long, s$, pppp As mArray, frm$, sxy As Double, orig As Long, zX As Variant, zY As Variant
If IsExp(bstack, rest$, p) Then
    If p = 0 Then   ' ZERO CLEAR ALL HARDWARE SPRITES
        ClrSprites
        ProcPlayer = True
        Exit Function
    End If
    If p < 1 Or p > 32 Then SyntaxError: ProcPlayer = False: Exit Function
    orig = CLng(p)
    it = FindSpriteByTag(orig)
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, X) Then  ' get new left or leave it empty
            If it = 0 Then
                X = 0
            Else
                X = Form1.dSprite(it).Left + players(it).X
            End If
            If FastSymbol(rest$, ",") Then
                If Not IsExp(bstack, rest$, Y) Then MissNumExpr: ProcPlayer = False: Exit Function
            Else
                MissNumExpr
                ProcPlayer = False: Exit Function
            End If
        Else
            If FastSymbol(rest$, ",") Then   ' so ,, is "stay X where you are
                If Not IsExp(bstack, rest$, Y) Then MissNumExpr: ProcPlayer = False: Exit Function
            Else
                If it = 0 Then
                    Y = 0
                Else
                    Y = Form1.dSprite(it).top + players(it).Y
                End If
            End If
        End If
        If IsLabelSymbolNew(rest$, "ÌÅ", "USE", Lang) Then ' no need for coma
            Select Case Abs(IsLabel(bstack, rest$, what$))
            Case 3
                If GetVar(bstack, what$, I) Then s$ = var(I)
            Case 6
                If neoGetArray(bstack, what$, pppp) Then
                    
                    If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then
                        MissNumExpr
                        ProcPlayer = True: Exit Function
                    End If
                Else
                    MissNumExpr
                    ProcPlayer = False: Exit Function
                End If
                s$ = pppp.item(it)  ' get the sprite image
            Case Else
                MissNumExpr
                ProcPlayer = False: Exit Function
            End Select
            Col = 0
            sX = 0

            If FastSymbol(rest$, ",") Then  ' get image manipulators..
                    If IsExp(bstack, rest$, sY) Then
                     Col = mycolor(sY)
                    ' If col > 0 Then col = QBColor(col Mod 16) Else col = -col
                     ElseIf IsStrExp(bstack, rest$, frm$) Then
                     '' maybe is a mask
                     
                     Col = 0
                     Else
                     ProcPlayer = False: MissNumExpr: Exit Function
                    End If
                     
                        If FastSymbol(rest$, ",") Then
                            If IsExp(bstack, rest$, sX) Then
                          
                               Else
                            MissNumExpr
                            ProcPlayer = False: Exit Function
                            End If
                        Else
                
                        End If
                    
              End If
                    
                    If FastSymbol(rest$, ",") Then
                                If IsExp(bstack, rest$, sxy) Then
                                    If FastSymbol(rest$, ",") Then GoTo HOTSPOT
                                ElseIf FastSymbol(rest$, ",") Then
HOTSPOT:
                                IsExp bstack, rest$, zX
                                If FastSymbol(rest$, ",") Then
                                    If Not IsExp(bstack, rest$, zY) Then GoTo mis
                                End If
                                Else
mis:
                                    MissNumExpr
                                    ProcPlayer = False: Exit Function
                                End If
                    
                    
                    End If
                    
                   If IsLabelSymbolNew(rest$, "ÌÅÃÅÈÏÓ", "SIZE", Lang) Then
              If Not IsExp(bstack, rest$, sY) Then ProcPlayer = False: MissNumExpr: Exit Function
              Else
              sY = 1
              End If
                    
              ' so col, sx and sy are image manipulators
            it = GetNewSpriteObj(orig, s$, Col, CLng(sX), CSng(sY), CSng(sxy), frm$)
 On Error Resume Next
                players(it).HotSpotX = -zX * sY
                    players(it).HotSpotY = -zY * sY
 
            PosSprite orig, X - players(it).X + players(it).HotSpotX, Y - players(it).Y + players(it).HotSpotY
        Else ' without USE
      
    On Error Resume Next
         PosSprite orig, X - players(it).X + players(it).HotSpotX, Y - players(it).Y + players(it).HotSpotY
        
        End If
        Else ' without x, y
            If IsLabelSymbolNew(rest$, "ÌÅ", "USE", Lang) Then
        Select Case Abs(IsLabel(bstack, rest$, what$))
        Case 3
            If GetVar(bstack, what$, I) Then s$ = var(I)
        Case 6
             If neoGetArray(bstack, what$, pppp) Then
   
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then
                     ProcPlayer = False: MissNumExpr: Exit Function
                End If
            Else
                 ProcPlayer = False: MissNumExpr: Exit Function
            End If
            s$ = pppp.item(it)
        Case Else
             ProcPlayer = False: MissNumExpr: Exit Function
        End Select
        Col = 0 'rgb(255, 255, 255)
        sX = 0
    If FastSymbol(rest$, ",") Then
    
        If IsExp(bstack, rest$, sY) Then
            'col = CLNG(sY)
            Col = mycolor(sY)
            'If col > 0 Then col = QBColor(col) Else col = -col
        ElseIf IsStrExp(bstack, rest$, frm$) Then
            '' maybe is a mask
            Col = 0
        Else
            ProcPlayer = False: MissNumExpr: Exit Function
        End If
        If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, sX) Then
            Else
                MissNumExpr
                ProcPlayer = False: Exit Function
            End If
        Else
        End If
    End If
            If FastSymbol(rest$, ",") Then
                If IsExp(bstack, rest$, sxy) Then
                Else
                    MissNumExpr
                    ProcPlayer = False: Exit Function
                End If
            Else
    
            End If
            If IsLabelSymbolNew(rest$, "ÌÅÃÅÈÏÓ", "SIZE", Lang) Then          ' SIZE WITHOUT COMMA
                If Not IsExp(bstack, rest$, sY) Then ProcPlayer = False: MissNumExpr: Exit Function
            Else
                sY = 1
            End If
    
            it = GetNewSpriteObj(orig, s$, Col, CLng(sX), CSng(sY), CSng(sxy), frm$)
            ' no USE no X, Y or X,Y USE ..
            ' only command
        ElseIf IsLabelSymbolNew(rest$, "ÄÅÉÎÅ", "SHOW", Lang) Then     ' SHOW
            SrpiteHideShow orig, (True)
        ElseIf IsLabelSymbolNew(rest$, "ÊÑÕØÅ", "HIDE", Lang) Then        ' HIDE
            SrpiteHideShow orig, (False)
        ElseIf IsLabelSymbolNew(rest$, "ÐÁÍÙ", "OVER", Lang) Then      ' ÐÁÍÙ
            If IsExp(bstack, rest$, X) Then
                If orig <> X Then SpriteControlOver orig, CLng(X)
                
            Else
                ProcPlayer = False
            End If
        ElseIf IsLabelSymbolNew(rest$, "ÕÐÏ", "UNDER", Lang) Then
            If IsExp(bstack, rest$, X) Then
                If orig <> X Then SpriteControlUnder orig, CLng(X)
                
            Else
                ProcPlayer = False
            End If
        ElseIf IsLabelSymbolNew(rest$, "ÁËËÁÎÅ", "SWAP", Lang) Then       ' SWAP
            If IsExp(bstack, rest$, X) Then
                If orig <> X Then SpriteControl orig, CLng(X)
                
            Else
                ProcPlayer = False
            End If
        End If
    End If
End If
ProcPlayer = True
Exit Function
End Function


Sub ClearState()
Basestack1.IamAnEvent = False
abt = False
'Set comhash = New sbHash
'allcommands comhash
'Set numid = New idHash
'Set funid = New idHash
'Set strid = New idHash
'Set strfunid = New idHash
'NumberId numid, funid
'StringId strid, strfunid
NoOptimum = False
NERR = False
TaskMaster.Dispose
CloseAllConnections
CleanupLibHandles
If Not NOEDIT Then
NOEDIT = True
Else
If QRY Then QRY = False
End If
' restore DB.Provider for User
JetPrefixUser = JetPrefixHelp
JetPostfixUser = JetPostfixHelp
' SET ARRAY BASE TO ZERO
ArrBase = 0
End Sub

Function ProcPrinter(basestack As basetask, rest$) As Boolean
Dim xp As Printer, I As Long, p As Variant, x1 As Long, y1 As Long, X As Double, Y As Double
Dim s$, ss$, f As Long, pa$, sX As Double, it As Long, ya As Long, AddTwipsTopL As Long, nd&
Dim Scr As Object
ProcPrinter = True
Set Scr = basestack.Owner
If basestack.toprinter Then Exit Function
 If ThereIsAPrinter = False Then Exit Function
If FastSymbol(rest$, "!") Then
olamazi
If ThereIsAPrinter Then
For Each xp In Printers
If xp.DeviceName = pname Then
Set Printer = xp
Exit For
End If
Next xp

If ShowProperties(Form1, Printer.DeviceName, MyDM()) Then
MyDoEvents
PrinterDim pw, ph, psw, psh, pwox, phoy
End If
End If
Exit Function
End If
If FastSymbol(rest$, "+") Then
Form1.List1.Clear
For Each xp In Printers
Form1.List1.additemFast xp.DeviceName & " (" & xp.Port & ")"
Next xp
For I = 0 To Form1.List1.listcount - 1
If pname & " (" & Port & ")" = Form1.List1.list(I) Then Form1.List1.ListIndex = I
Next I
Exit Function
ElseIf FastSymbol(rest$, "?") Then
Form1.List1.Clear
For Each xp In Printers
Form1.List1.additemFast xp.DeviceName & " (" & xp.Port & ")"
Next xp
For I = 0 To Form1.List1.listcount - 1
If pname & " (" & Port & ")" = Form1.List1.list(I) Then Form1.List1.ListIndex = I
Next I
Execute basestack, "menu !", True
If CDbl(Form1.List1.ListIndex + 1) > 0 Then
I = InStr(Form1.List1.ListValue, " (")
pname = Left$(Form1.List1.ListValue, I - 1)
Port = Mid$(Form1.List1.ListValue, I + 2, InStr(I + 2, Form1.List1.ListValue, ")") - I - 2)
End If
For Each xp In Printers
If xp.DeviceName = pname And xp.Port = Port Then Set Printer = xp
Next xp
ReDim MyDM(1 To 1) As Byte
Exit Function
End If
getfirstpage
If szFactor = 0 Then szFactor = mydpi * dv15 / 1440#
If Not IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
p = players(-2).SZ / szFactor
If p = 0 Then p = Form1.DIS.FontSize
End If

If FastSymbol(rest$, ",") Then
If IsStrExp(basestack, rest$, s$) Then
For Each xp In Printers
If xp.DeviceName & " (" & xp.Port & ")" = s$ Then
pname = xp.DeviceName
Port = xp.Port
Set Printer = xp
ReDim MyDM(1 To 1) As Byte
If FastSymbol(rest$, ",") Then
If IsStrExp(basestack, rest$, ss$) Then
If ss$ <> "" Then
LoadArray MyDM(), ss$
End If
End If
Exit For
End If
End If
Next xp

Exit Function
End If
End If
If lookOne(rest$, "{") Then


 If ThereIsAPrinter = False Then Exit Function
If pname = vbNullString Then Exit Function
For Each xp In Printers
If xp.DeviceName = pname And xp.Port = Port Then Set Printer = xp
Next xp
getfirstpage

If players(-2).Xt = 0 Then

players(-2) = players(0)  'COPY dis
With players(-2)
players(-2).curpos = 0
players(-2).currow = 0
If p = 0 Then p = .SZ
szFactor = mydpi * dv15 / 1440#
.SZ = CSng(p * szFactor)
End With

PlaceBasket Form1.PrinterDocument1, players(-2)
SetText Form1.PrinterDocument1

End If
If p = 0 Then p = players(-2).SZ Else p = CSng(p)
SetTextSZ Form1.PrinterDocument1, CSng(p * szFactor) ' CSng(p * mydpi * dv15 / 1440)

LCTbasket Form1.PrinterDocument1, players(-2), 0, 0
'realfactor = CSng(players(-2).SZ) / prFactor / p


With Printer   ' for no specific reason..I have to think it again
.currentX = 0
.currentY = 0
End With
basestack.toprinter = True
nd& = basestack.addlen
it = Execute(basestack, rest$, False, True, , True)
basestack.addlen = nd&
            If it = 2 Then
                        If rest$ = "" Then
                            rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                        Else
                        rest$ = ": Goto " + rest$
                         If trace Then WaitShow = 2: TestShowSub = rest$
                        End If
                        it = 1
                        End If

If Not basestack.toprinter Then
pnum = 0
oprinter.ClearUp
Form1.PrinterDocument1.Picture = LoadPicture("")
Else
getenddoc
End If
basestack.toprinter = False
Set basestack.Owner = Scr
If it = 0 Then
ProcPrinter = False
End If

Else
PlainBaSket Scr, players(GetCode(Scr)), pname & " (" & Port & ")"
crNew basestack, players(GetCode(Scr))
End If
Exit Function
End Function

Private Property Get xmlMonoNew() As XmlMono
    Dim M As New XmlMonoInternal, z As New XmlMono
    z.createTree M
    Set xmlMonoNew = z
End Property
Function IsCollide(bstack As basetask, A$, r As Variant) As Boolean
Dim R2 As Variant
If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
r = Fix(r)
If FastSymbol(A$, ",") Then
    If Not IsExp(bstack, A$, R2) Then: MissParam A$: IsCollide = False: Exit Function
    R2 = Fix(R2)
    If FastSymbol(A$, ",") Then
    r = CollideArea(CLng(r), CLng(R2), bstack, A$)
    Else
    r = CollidePlayers(CLng(r), CLng(R2))
    End If
Else
r = CollidePlayers(CLng(r), CLng(100))
End If
   
    IsCollide = FastSymbol(A$, ")", True)
End If
End Function

Function IsParagr(bstack As basetask, A$, r As Variant) As Boolean
Dim s$, pp As Variant, dn As Long, w1 As Long, w2 As Long, pppp As mArray
    w1 = Abs(IsLabel(bstack, A$, s$))
                  
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                        If Not FastSymbol(A$, ",") Then: MissParam A$: Exit Function
        
                       If IsExp(bstack, A$, pp, flatobject:=True, nostring:=True) Then
                                dn = CLng(Fix(pp))
                              r = var(w1).ParagraphFromOrder(dn)           ''
                                 
                            
                                 Else
                                       MissNumExpr
                                        
                                        IsParagr = False
                                        Exit Function
                                 End If
         
               Else
                    MissingDoc
                                        
                                        IsParagr = False
                                        Exit Function
                End If
                
                IsParagr = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                                If Not FastSymbol(A$, ",") Then: MissParam A$: Exit Function
                            If IsExp(bstack, A$, pp, flatobject:=True, nostring:=True) Then
                                dn = CLng(Fix(pp))
                                 r = pppp.item(w2).ParagraphFromOrder(dn)
                                 Else
                                        MissNumExpr
                                        
                                        IsParagr = False
                                        Exit Function
                                 End If
                  Else
                    MissingDoc
                                        
                                        IsParagr = False
                                        Exit Function
                End If
                    
                IsParagr = FastSymbol(A$, ")", True)
    Else
                    
                MissFuncParameterStringVarMacro A$
    End If
End Function

Public Function MyTitle$(basestack As basetask)
Static PREVT$

' On Error GoTo t1
If exWnd = 0 Then
PREVT$ = vbNullString
MyTitle$ = vbNullString
Exit Function
End If
If PREVT$ <> nnn$ Then
PREVT$ = nnn$

Form1.view1_StatusTextChange11 basestack, Trim$(nnn$)

End If
MyTitle$ = Trim$(PREVT$)

Exit Function
T1:
MyTitle$ = "???"
End Function
Public Function Originalusername()

Dim ss$
                 ss$ = UCase(userfiles)
                    DropLeft "\M2000_USER\", ss$
                    
If ss$ = vbNullString Then
Originalusername = UserName
Else
ss$ = Right$(userfiles, Len(ss$))
Originalusername = GetStrUntil("\", ss$)
End If
End Function
Public Function UserName()
Dim A$, b$, C$
A$ = GetSpecialfolder(0)
While A$ <> ""
C$ = b$
b$ = GetStrUntil("\", A$)
Wend
UserName = C$
End Function
Function IsDimension(bstack As basetask, A$, r As Variant) As Boolean
Dim s$, pppp As mArray, ppppAny As iBoxArray, w1 As Long, p As Variant, anything As Object, pp As Variant, usehandler As mHandler
Dim K As Long
K = Abs(IsLabel(bstack, A$, s$))
Set bstack.lastobj = Nothing
If K > 4 And K < 8 Then
If neoGetArray(bstack, s$, ppppAny) Then
If ppppAny.Arr Then
If FastSymbol(A$, ")") Then
    If K = 6 Then
        IsStrExp bstack, s$ + ")", s$
    Else
        IsNumber bstack, s$ + ")", p
    End If
Else
bstack.tmpstr = s$ + Left$(A$, 1)
  BackPort A$
    If K = 6 Then
        IsStrExp bstack, A$, s$
    Else
        IsNumber bstack, A$, p
    End If
End If
getback:
If Not bstack.lastobj Is Nothing Then
If TypeOf bstack.lastobj Is mHandler Then
Set anything = bstack.lastobj
If CheckIsmArray(anything) Then Set bstack.lastobj = anything
Set anything = Nothing
End If
If Not (TypeOf bstack.lastobj Is mArray) Then NeedAnArray A$: Exit Function
Set ppppAny = bstack.lastobj
Set bstack.lastobj = Nothing
Else

IsDimension = False
End If
Else
   If NeoGetArrayItem(ppppAny, bstack, s$, w1, A$) Then
    If TypeOf ppppAny.GroupRef Is mHandler Then
        Set usehandler = ppppAny.GroupRef
        If usehandler.T1 = 1 Then
        Set bstack.lastobj = ppppAny.item(w1)
        If TypeOf bstack.lastobj Is mHandler Then
        
        Set usehandler = bstack.lastobj
        If usehandler.T1 = 3 Then
            Set ppppAny = usehandler.objref
        End If
        ElseIf TypeOf bstack.lastobj Is mArray Then
            Set ppppAny = bstack.lastobj
        End If
        Set bstack.lastobj = Nothing
        Else
        Set pppp = usehandler.objref.ValueObj
        End If
        Set usehandler = Nothing
    End If
  End If
End If
Else
      NeedAnArray A$: Exit Function
End If

 If ppppAny.Arr Then  '
    Set pppp = ppppAny
    If FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            If p < 1 Then
                If Not FastSymbol(A$, ",") Then
                    pppp.GetDnum (0), pp, r
                    r = -r
                ElseIf IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
                    r = CLng(r) - 1
                    pppp.SerialItem pp, (r), 5
                    If r >= 0 And r < pp Then
                        pppp.GetDnum (r), pp, r
                        r = -r
                    Else
                        CantReadDimension A$, s$
                        Exit Function
                   End If
                Else
                    missNumber
                    Exit Function
                End If
            Else
                'pppp.SerialItem PP, CLNG(Fix(p) - 1), 6
                pppp.SerialItem pp, (r), 5
                p = p - 1
                If p >= 0 And p < pp Then
                    If FastSymbol(A$, ",") Then
                        If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
                            If r = 0 Then
                                pppp.GetDnum CLng(Fix(p)), pp, r
                                r = -r
                            Else
                                pppp.GetDnum CLng(Fix(p)), pp, r
                                r = pp - r - 1
                            End If
                        End If
                    Else
                        pppp.GetDnum CLng(Fix(p)), pp, r
                        r = pp
                    End If
                Else
                    CantReadDimension A$, s$
                    Exit Function
                End If
            
            End If
                IsDimension = FastSymbol(A$, ")", True)
        Else
            CantReadDimension A$, s$
        End If
        
      Else ' dimensions
      p = 0
      pppp.SerialItem pp, CLng(Fix(p)), 5
         r = pp
              
              IsDimension = FastSymbol(A$, ")", True)
      End If
      Exit Function
      Else
       
       End If
ElseIf GetVar(bstack, s$, w1) Then
If IsExp(bstack, (s$), p) Then
    Set anything = bstack.lastobj
    If CheckIsmArray(anything) Then
        Set bstack.lastobj = anything
        Set anything = Nothing
    Else
    Set anything = Nothing

    End If
GoTo getback

End If
 Else
 
 End If
If IsStrExp(bstack, A$, s$, False) Then
    s$ = s$ + "("
    If neoGetArray(bstack, s$, ppppAny) Then
    
      If Not ppppAny.Arr Then
    
  If NeoGetArrayItem(ppppAny, bstack, s$, w1, A$, , False) Then
      If TypeOf ppppAny.GroupRef Is mHandler Then
        Set usehandler = ppppAny.GroupRef
        Set ppppAny = usehandler.objref.ValueObj
        Set usehandler = Nothing
    End If
  End If
  
   
  End If
  If Not ppppAny.Arr Then NeedAnArray A$: Exit Function
        Set pppp = ppppAny
        If FastSymbol(A$, ",") Then
          If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            If p < 1 Then
                r = -pppp.myarrbase
            Else
                p = Fix(p)
                pppp.SerialItem pp, CLng(p - 1), 6
                r = pp
            End If
            
            IsDimension = FastSymbol(A$, ")", True)
          Else
            CantReadDimension A$, s$
            End If
        Else ' dimensions
            p = 0
            pppp.SerialItem pp, CLng(p), 5
            r = pp
            
            IsDimension = FastSymbol(A$, ")", True)
        End If
        Else
        CantFindArray A$, s$
    End If
Else
        CantFindArray A$, s$
End If
End Function

Function ProcLoadDoc(entrypoint As Long, basestack As basetask, rest$) As Boolean
Dim dum As Boolean, pppp As mArray, s$, I As Long, x1 As Long, y1 As Long, frm$, ss$
Dim p As Variant
ProcLoadDoc = True
If entrypoint = 1 Then dum = True
      y1 = Abs(IsLabel(basestack, rest$, s$))

        If y1 = 6 Then
                If neoGetArray(basestack, s$, pppp) Then
                    If Not NeoGetArrayItem(pppp, basestack, s$, I, rest$) Then Exit Function
                Else
                    MissingDoc
                    Exit Function
                End If
    End If
    If FastSymbol(rest$, ",") Then
        If IsExp(basestack, rest$, p, , True) Then
            If MemInt(VarPtr(p)) <> vbString Then
                MissStringExpr
                Exit Function
            End If
            SwapString2Variant frm$, p
        ElseIf Not IsStrExp(basestack, rest$, frm$) Then
            MissStringExpr
            Exit Function
        End If
    
    ss$ = GetNextLine(frm$)
    SetNextLine frm$
    If frm$ <> "" Then
    MyEr "filename with line breaks", "üíïìá áñ÷åßïõ ìå áëëáãÝò ãñáììþí"
    
    End If
    ' check valid name
    If ExtractNameOnly(ss$, True) = vbNullString Then BadFilename:  Exit Function
    If ExtractPath(ss$) = vbNullString Then
    ss$ = mylcasefILE(mcd + ss$)
    End If
    If ExtractType(ss$) = vbNullString Then ss$ = ss$ + ".txt"
    Else
    
    MissPar
    Exit Function
    End If
    
   
        If y1 = 3 Then
            If GetVar(basestack, s$, I) Then
                If VarTypeName(var(I)) = doc Then

                x1 = 2
                On Error Resume Next
                If FastSymbol(rest$, ",") Then
                
                If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                var(I).LCID = CLng(p)
                End If
                End If
            If basestack.Owner.Name = "GuiM2000" Then
                Set basestack.Owner.mDoc = var(I)
                var(I).ReadUnicodeOrANSI ss$, dum, x1
                Set basestack.Owner.mDoc = Nothing
            Else
                var(I).ReadUnicodeOrANSI ss$, dum, x1
                End If
                If Err.Number > 0 Then Err.Clear: Exit Function
                 var(I).ListLoadedType = x1
                 Exit Function
                Else
                    MissingDoc
                    
                End If
            Else
                   MissFuncParameterStringVar
                    
            End If
        ElseIf y1 = 6 Then
                    If pppp.ItemType(I) = doc Then
                                    x1 = 2
                pppp.item(I).ReadUnicodeOrANSI ss$, dum, x1
                 pppp.item(I).ListLoadedType = x1
                    
                        Else
                         MissingDoc
                         
                        End If
    Else
                MissPar
    End If
End Function


Function ProcRecursionLimit(basestack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, prive As Long
ProcRecursionLimit = True
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
deep = Abs(MyRound(p))
If IsSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then funcdeep = Abs(MyRound(p)) ' obsolate
End If
ElseIf IsSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then funcdeep = Abs(MyRound(p)) ' obsolate
Else
prive = GetCode(basestack.Owner)
    If deep = 0 Then
            If Lang = 1 Then
            PlainBaSket basestack.Owner, players(prive), "NO RECURSION LIMIT FOR SUBRUTINES"
            Else
            PlainBaSket basestack.Owner, players(prive), "×ÙÑÉÓ ÏÑÉÏ ÁÍÁÄÑÏÌÇÓ ÓÔÉÓ ÑÏÕÔÉÍÅÓ"
            End If
            
    Else
    If Lang = 1 Then
        PlainBaSket basestack.Owner, players(prive), "RECURSION LIMIT FOR SUBRUTINES " & (deep)
         crNew basestack, players(prive)
         If m_bInIDE Then
         PlainBaSket basestack.Owner, players(prive), "RECURSION LIMIT FOR FUNCTIONS " & (stacksize \ 2948 - 1)
         Else
        PlainBaSket basestack.Owner, players(prive), "RECURSION LIMIT FOR FUNCTIONS " & (stacksize \ 9832 - 1)
        End If
    Else
        PlainBaSket basestack.Owner, players(prive), "ÏÑÉÏ ÁÍÁÄÑÏÌÇÓ ÓÔÉÓ ÑÏÕÔÉÍÅÓ " & (deep)
         crNew basestack, players(prive)
          If m_bInIDE Then
          PlainBaSket basestack.Owner, players(prive), "ÏÑÉÏ ÁÍÁÄÑÏÌÇÓ ÓÔÉÓ ÓÕÍÁÑÔÇÓÅÉÓ " & (stacksize \ 2948 - 1)
          Else
        PlainBaSket basestack.Owner, players(prive), "ÏÑÉÏ ÁÍÁÄÑÏÌÇÓ ÓÔÉÓ ÓÕÍÁÑÔÇÓÅÉÓ " & (stacksize \ 9832 - 1)
        End If
    End If
    End If
      '  PlainBaSket basestack.Owner, players(prive), CStr(deep)
    crNew basestack, players(prive)
End If
If funcdeep < 128 Then funcdeep = 128
If funcdeep > 3260 Then funcdeep = 3260
End Function


Function ProcSalata(entrypoint As Long, basestack As basetask, rest$) As Boolean
Dim p As Variant, Scr As Object, prive As Long, s$
ProcSalata = True
On entrypoint GoTo charset, CodePage, Locale
Exit Function
charset:
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
On Error Resume Next
chr11:
    Set Scr = basestack.Owner
    prive = GetCode(Scr)
    Scr.Font.charset = CInt(p)
    Form1.TEXT1.Font.charset = Scr.Font.charset
    Form1.List1.Font.charset = Scr.Font.charset
      StoreFont Scr.Font.Name, players(prive).SZ, Scr.Font.charset
      players(prive).charset = Scr.Font.charset
          Set Scr = Nothing
End If
Exit Function
CodePage:
        If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
        ' usercodepage for use compare.
        ' also change to form.
        On Error Resume Next
        If IsValidCodePage(CLng(p)) = 0 Then
            NoValidCodePage
            ProcSalata = True
        Exit Function
        End If
CHR222:
        UserCodePage = CLng(p)
        p = GetCharSet(CLng(p))
        
        GoTo chr11
        End If
Exit Function
Locale:
    On Error Resume Next
    If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
        If CLng(p) <> 0 Then
        If GetCodePage(CLng(p)) = 0 Then
        ProcSalata = False
                        NoValidLocale
                        Exit Function
                    End If
    Clid = CLng(p)
    
            Else
            Clid = OsInfo.LangNonUnicodeCode
                    End If
    
    If Clid = 1032 Then
    DefBooleanString = ";ÁëçèÝò;ØåõäÝò"
    Else
    DefBooleanString = ";\T\r\u\e;\F\a\l\s\e"
    End If
    OverideDec = False
    NowDec$ = GetlocaleString(LOCALE_SDECIMAL)
    NowThou$ = GetlocaleString(LOCALE_STHOUSAND)
    mNoUseDec = True
    NoUseDec = GetDeflocaleString(LOCALE_SDECIMAL) = NowDec$
    
    OverideDec = NowDec$ <> "."
    p = GetCodePage(CLng(p))
    GoTo CHR222
    ElseIf IsStrExp(basestack, rest$, s$) Then
    ' format$ for true/false values
    If LenB(s$) = 0 Then DefBooleanString = ";\T\r\u\e;\F\a\l\s\e" Else DefBooleanString = s$
    End If
End Function

Function ProcScreenRes(basestack As basetask, rest$) As Boolean
Dim X As Double, Y As Double
If IsExp(basestack, rest$, X) Then
    If FastSymbol(rest$, ",") Then
        If IsExp(basestack, rest$, Y) Then
            ChangeScreenRes CLng(X), CLng(Y)
        Else
            
            MissNumExpr
        End If
    Else
        
        SyntaxError
    End If
ElseIf FastSymbol(rest$, "!") Then
    ScreenRestore
Else
    
    MissNumExpr
End If
ProcScreenRes = True
End Function
Function ProcSaveAs(bstack As basetask, rest$, Lang As Long) As Boolean
Dim Scr As Object, frm$, pa$, s$, ss$, W$
If IsSelectorInUse Then
SelectorInUse
Exit Function
End If
olamazi

frm$ = mcd
DialogSetupLang Lang

IsStrExp bstack, rest$, s$
If FastSymbol(rest$, ",") Then If IsStrExp(bstack, rest$, pa$) Then frm$ = pa$
If frm$ <> "" Then If Not isdir(frm$) Then NoSuchFolder: Exit Function
If FastSymbol(rest$, ",") Then If IsStrExp(bstack, rest$, pa$) Then ss$ = pa$
If FastSymbol(rest$, ",") Then If Not IsStrExp(bstack, rest$, W$) Then Exit Function
olamazi
If TypeOf bstack.Owner Is GuiM2000 Then
Set Scr = bstack.Owner
ElseIf val("0" + bstack.Owner.Tag) > 32 Then
Set Scr = bstack.Owner.Parent
If Scr Is Nothing Then Exit Function
While Not TypeOf Scr Is GuiM2000
Set Scr = Scr.Parent
If Scr Is Nothing Then Exit Function
Wend
Else
If Form1.Visible Then
Set Scr = Form1
Else
Set Scr = Nothing
End If
End If
' change for file type
If InStr(W$, "|") > 0 Then W$ = vbNullString  ' NOT COMBATIBLE..CHANGE TO ALL FILES
If SaveAsDialog(bstack, s$, frm$, ss$, W$) Then
bstack.soros.PushStr ReturnFile
Else
bstack.soros.PushStr ""
End If
Set Scr = Nothing
ProcSaveAs = True
End Function

Function ProcJoypad(basestack As basetask, rest$) As Boolean
Dim p As Variant
        If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
        If Not StartJoypadk(MyRound(p)) Then
        ' ERROR
        MyEr "Joypad " & (p) & " not exist", "ç ëáâÞ " & (p) & " äåí õðÜñ÷åé"
        
        Exit Function
        End If
        While FastSymbol(rest$, ",")
        
         If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
        If Not StartJoypadk(MyRound(p)) Then
        MyEr "Joypad " & (p) & " not exist", "ç ëáâÞ " & (p) & " äåí õðÜñ÷åé"
        
        Exit Function

        End If
        Else
        MyEr "Joypad Number?", "Áñéèìüò ËáâÞò?"
        
        Exit Function

        End If
        Wend
        
        Else
        FlushJoyAll
        End If
ProcJoypad = True
End Function
Function MyDelay(basestack As basetask, rest$) As Boolean
Dim p As Variant
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
mywait basestack, p
Else
mywait basestack, 0
End If
MyDelay = True

End Function
Function ProcTune(bstack As basetask, rest$) As Boolean
'' break async
Dim p As Variant, s$
If IsExp(bstack, rest$, p) Then
    If Not FastSymbol(rest$, ",") Then
        beeperBEAT = CLng(p)
    ElseIf IsStrExp(bstack, rest$, s$) Then
        beeperBEAT = CLng(p)
        PlayTune (s$)
    Else
        MyEr "wrong parameter", "ëÜèïò ðáñÜìåôñïò"
        Exit Function
    End If
ElseIf IsStrExp(bstack, rest$, s$) Then
' B C D E F G
PlayTune (s$)
End If
ProcTune = True
End Function
Function ProcName(bstack As basetask, rest$, Lang As Long) As Boolean
Dim s$, W$, x1 As Long, y1 As Long, ss$
ProcName = True
x1 = IsLabelFileName(bstack, rest$, W$)
If x1 = 1 Then
   SwapStrings s$, W$
Else
    x1 = IsStrExp(bstack, rest$, s$, False)
End If

If Not IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then ProcName = False: Exit Function

y1 = IsLabelFileName(bstack, rest$, W$)
If y1 = 1 Then
    SwapStrings ss$, W$
Else
    y1 = IsStrExp(bstack, rest$, ss$)
End If
If x1 = 0 Or y1 = 0 Then SyntaxError: ProcName = False: Exit Function
If Not CanKillFile(CFname(s$)) Then FilePathNotForUser: ProcName = False: Exit Function
If Not RenameFile(s$, ss$) Then NoRename


End Function
Sub GetitObject(var, Optional cc, Optional serverclass1)
Dim aa As Object, b As GUID, serverclass As String
If IsMissing(cc) Then
    If Left$(serverclass1, 1) = "{" Then
        serverclass = serverclass1
        serverclass = strProgIDfromSrting(serverclass)
    Else
        serverclass = serverclass1
    End If
    On Error Resume Next
    Set aa = GetObject(, serverclass)
    If Err Then
        MyEr Err.Description, Err.Description
        Err.Clear
    End If
ElseIf IsMissing(serverclass1) Then
    On Error Resume Next
    cc = GetDosPath((cc))
    If cc <> "" Then
        Set aa = GetObject(cc)
    Else
        MissFile
    End If
    If Err Then
        MyEr Err.Description, Err.Description
    End If
Else
    On Error Resume Next
    cc = GetDosPath((cc))
    Set aa = GetObject(cc, serverclass1)
    If Err Then
        MyEr Err.Description, Err.Description
    End If
End If
Set var = aa
End Sub
Function getVarPtr(bstack As basetask, A$, r) As Boolean
Dim VR As Long, v$, V1&, w1 As Long, w2 As Long, s1$
Dim anything As Object, n$, gr As Boolean
Dim sg1 As Boolean, s$, par As Boolean
Dim ppppAny As iBoxArray, pppp As mArray
r = 0&
w2 = Len(A$)
If Len(A$) < 129 Then
    V1& = IsLabelBig(bstack, A$, v$, par, s1$, True, , , , gr)
Else
    n$ = Left$(A$, 128)
    s$ = bstack.tmpstr
    V1& = IsLabelBig(bstack, n$, v$, par, s1$, True, , , sg1, gr)
    If Len(n$) = 0 Then
        If sg1 Then bstack.tmpstr = s$
        sg1 = False
        V1& = IsLabelBig(bstack, A$, v$, par, s1$, True, , , , gr)
    Else
        If sg1 Then
        sg1 = False
        Select Case Len(n$)
        Case Is < 128
            Mid$(A$, 129 - Len(n$), Len(n$)) = n$
            A$ = Mid$(A$, 129 - Len(n$))
        Case Is > 128
            A$ = n$ + Mid$(A$, 129)
        Case Else
            Mid$(A$, 1, 128) = n$
        End Select
        Else
            A$ = Mid$(A$, 129 - Len(n$))
        End If
    End If
End If
V1& = Abs(V1&)
If V1& > 0 And V1& < 5 Then
    par = False
    If GetVar(bstack, v$, w1, , , , , par) Then
        If par Then
            w2 = MemInt(VarPtr(var(w1)))
            Select Case w2
                Case vbBoolean, vbByte, vbInteger, vbLong, vbString, vbDouble, vbSingle, vbCurrency, 20, vbObject, 13
                    r = VarPtr(var(w1)) + 8
                Case vbDecimal, vbUserDefinedType
                    r = VarPtr(var(w1))
                Case Else
                    r = 0
            End Select
        Else
            r = VarPtr(var(w1))
        End If
        If FastSymbol(A$, ")") Then getVarPtr = True
    End If
ElseIf neoGetArray(bstack, v$, ppppAny) Then
    If ppppAny Is Nothing Then
        WrongObject
        Exit Function
    ElseIf FastSymbol(A$, ")") Then
        If Not ppppAny.Arr Then WrongObject: Exit Function
    Else
    If Not ppppAny.Arr Then WrongObject: Exit Function
    If Not NeoGetArrayItem(ppppAny, bstack, v$, w1, A$) Then Exit Function
        Set pppp = ppppAny
        Select Case pppp.MyTypeToBe
            Case vbByte
                r = pppp.ArrPtr + w1
            Case vbBoolean, vbInteger
                r = pppp.ArrPtr + w1 * 2&
            Case vbLong, vbString, vbSingle, vbObject, 13
                r = pppp.ArrPtr + w1 * 4&
            Case vbDouble, vbCurrency, 20
                r = pppp.ArrPtr + w1 * 8&
            Case Else
                r = pppp.ArrPtr + w1 * 16&
        End Select
        
    End If
    If FastSymbol(A$, ")") Then getVarPtr = True
Else
    SyntaxError
End If
End Function
Function createAnobject(bstack As basetask, b$) As Boolean
Dim s$, s1$, K As Integer, ob
Set ob = Nothing
If IsStrExp(bstack, b$, s$) Then
K = 1
End If
If FastSymbol(b$, ",") Then
    If IsStrExp(bstack, b$, s1$) Then
    K = K + 10
    End If
End If
If FastSymbol(b$, ")") Then
    Select Case K
    Case 1
        GetitObject ob, s$
    Case 10
        GetitObject ob, , s1$
    Case 11
        GetitObject ob, s$, s1$
    End Select
    If Not ob Is Nothing Then
        Set bstack.lastobj = ob
        createAnobject = True
    End If
End If
End Function
Function GetThisModuleName(r$) As Boolean
GetThisModuleName = True
r$ = GetName(here$)
If Len(r$) = 0 Then Exit Function
    If AscW(r$) = 8191 Then
        If InStr(here$, r$) > 0 Then
            r$ = GetName(Left$(here$, Len(here$) - Len(r$)))
            If Len(r$) > 1 Then
                r$ = Left$(r$, Len(r$) - 1)
            Else
                r$ = GetName(here$)
            End If
        Else
            r$ = sbf(val(Mid$(here$, rinstr(here$, "«") + 1))).sbgroup
            If Len(r$) > 0 Then
                r$ = Mid$(r$, rinstr(r$, ".", 2) + 1)
                If Len(r$) > 1 Then
                    r$ = Left$(r$, Len(r$) - 1)
                Else
                    r$ = GetName(here$)
                End If
            End If
        End If
    End If
    If InStr(r$, "«") > 0 Then r$ = GetName(r$)
    If InStr(r$, ").") Then r$ = Mid$(r$, InStr(r$, ").") + 2)
End Function
Public Function IsPoint(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
Dim R2 As Variant, R3 As Variant, R4 As Variant
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) <> "String" Then MissString: Exit Function
                    If Left$(var(w1), 4) = "cDIB" And Len(var(w1)) > 12 Then
                    If FastSymbol(A$, ",") Then
                        If Not IsExp(bstack, A$, R2, , True) Then: MissParam A$: Exit Function
                        If FastSymbol(A$, ",") Then
                            If Not IsExp(bstack, A$, R3, , True) Then: MissParam A$: Exit Function
                            If FastSymbol(A$, ",") Then
                                If Not IsExp(bstack, A$, R4, , True) Then: MissParam A$: Exit Function
                                    r = SetDIBPixel(var(w1), R2, R3, mycolor(R4))
                                Else
                                    r = GetDIBPixel(var(w1), R2, R3)
                                End If
                                
                                IsPoint = FastSymbol(A$, ")", True)
                            Else
                                MissParam A$: Exit Function
                            End If
                        Else
                            MissParam A$: Exit Function
                        End If
                    Else
                    noImage A$
                    Exit Function
        End If
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                If Not pppp.IsStringItem(w2) Then MissString: Exit Function
                Dim sV As Variant
                pppp.SwapItem w2, sV
          
                If Left$(sV, 4) = "cDIB" And Len(sV) > 12 Then
                    If FastSymbol(A$, ",") Then
                        If Not IsExp(bstack, A$, R2, , True) Then: MissParam A$: pppp.SwapItem w2, sV: Exit Function
                        If FastSymbol(A$, ",") Then
                            If Not IsExp(bstack, A$, R3, , True) Then: MissParam A$: pppp.SwapItem w2, sV: Exit Function
                            If FastSymbol(A$, ",") Then
                                If Not IsExp(bstack, A$, R4, , True) Then: MissParam A$: pppp.SwapItem w2, sV: Exit Function
                                r = SetDIBPixel(sV, R2, R3, mycolor(R4))
                            Else
                                r = GetDIBPixel(sV, R2, R3)
                            End If
                            
                            pppp.SwapItem w2, sV
                            IsPoint = FastSymbol(A$, ")", True)
                        Else
                            pppp.SwapItem w2, sV
                            MissParam A$: Exit Function
                        End If
                    Else
                        pppp.SwapItem w2, sV
                        MissParam A$: Exit Function
                    End If
                Else
                    pppp.SwapItem w2, sV
                    noImage A$
                End If
    
        Else
            MissParam A$
        End If
End If
End Function

Function StaticNew(bstack As basetask, b$, W$, Lang As Long) As Boolean
Dim p As Variant, ii As Long, ss$, usehandler As mHandler, h As Variant, ok As Boolean

If bstack.StaticCollection Is Nothing Then

Set bstack.StaticCollection = New FastCollection
If Not bstack.IamThread Then
    bstack.SetBacket "%_" + bstack.StaticInUse
End If
End If
Do
    Select Case IsLabel(bstack, b$, W$)
    Case 1
        If GetlocalVar(W$, ii) Then
            MyEr "Variable exist as local", "Ç ìåôáâëçôÞ õðÜñ÷åé ùò ôïðéêÞ"
            StaticNew = False
            Exit Function
        End If
        If Not bstack.ExistVar(W$) Then
            If FastSymbol(b$, "=") Then
                    If IsStrExp(bstack, b$, ss$) Then
                    bstack.SetVar W$, ss$
                    GoTo aaa1
                    ElseIf Not IsExp(bstack, b$, p) Then
                        SyntaxError
                        Exit Function
                    End If
                    Dim anything As Object
                    Set anything = bstack.lastobj
                    If CheckIsmArray(anything) Then
                            Set usehandler = New mHandler
                            With usehandler
                            .T1 = 3
                            Set .objref = anything
                            End With
                            Set p = usehandler
                            Set h = usehandler
                      bstack.SetVarobJvalue W$, h
                      Set usehandler = Nothing
                      Set h = Nothing
                    ElseIf CheckLastHandler(anything) Then
                        Set usehandler = anything
                        If usehandler.T1 = 2 Then
                            bstack.SetVarobJvalue W$, anything
                        ElseIf usehandler.T1 = 1 Then
                            bstack.SetVarobJvalue W$, anything
                        ElseIf usehandler.T1 = 3 Then
                            bstack.SetVarobJ W$, anything
                        ElseIf usehandler.T1 = 4 Then
                            Set p = usehandler
                            bstack.SetVarobJvalue W$, p
                        Else
                            GoTo conthere
                        End If
                    ElseIf Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is Group Then
                            If bstack.lastobj.IamApointer Then
                                If bstack.lastobj.link.IamFloatGroup Then
                                    bstack.SetVarobJvalue W$, bstack.lastobj
                                Else
                                    GoTo aaaa1
                                End If
                            Else
aaaa1:
                            Set bstack.lastobj = Nothing
                            MyEr "only for pointers for float groups", "ìüíï ãéá äåßêôåò óå ìç óôáôéêÜ áíôéêåßìåíá"
                            Exit Function

                        End If
                    ElseIf TypeOf bstack.lastobj Is BigInteger Then
                    Set p = bstack.lastobj
                        bstack.SetVarobJvalue W$, p
                    End If
                Else
                    bstack.SetVar W$, p
                End If
                Set bstack.lastobj = Nothing
            ElseIf IsLabelSymbolNew(b$, "ÙÓ", "AS", Lang) Then
               If IsLabelSymbolNew(b$, "ÁÑÉÈÌÏÓ", "DECIMAL", Lang) Then
                    p = CDec(0)
                ElseIf IsLabelSymbolNew(b$, "ÄÉÐËÏÓ", "DOUBLE", Lang) Then
                    p = 0#
                ElseIf IsLabelSymbolNew(b$, "ÁÐËÏÓ", "SINGLE", Lang) Then
                    p = 0!
                ElseIf IsLabelSymbolNew(b$, "ËÏÃÉÊÏÓ", "BOOLEAN", Lang) Then
                    p = False
                ElseIf IsLabelSymbolNew(b$, "ÌÁÊÑÕÓ", "LONG", Lang) Then
                    If IsLabelSymbolNew(b$, "ÌÁÊÑÕÓ", "LONG", Lang) Then
                        p = cInt64(0)
                    Else
                        p = 0&
                    End If
                ElseIf IsLabelSymbolNew(b$, "ÁÊÅÑÁÉÏÓ", "INTEGER", Lang) Then
                    p = 0
                ElseIf IsLabelSymbolNew(b$, "ËÏÃÉÓÔÉÊÏÓ", "CURRENCY", Lang) Then
                    p = 0@
                ElseIf IsLabelSymbolNew(b$, "ØÇÖÉÏ", "BYTE", Lang) Then
                    p = CByte(0)
                ElseIf IsLabelSymbolNew(b$, "ÇÌÅÑÏÌÇÍÉÁ", "DATE", Lang) Then
                    If FastSymbol(b$, "=") Then
                        If IsNumberD2(b$, p) Then
                            p = CDate(p)
                        ElseIf ISSTRINGA(b$, ss$) Then
                            p = CDate(ss$)
                        Else
                            missNumber
                            Exit Function
                        End If
                    Else
                        p = CDate(0#)
                    End If
                    bstack.SetVar W$, p
                    GoTo aaa1
                ElseIf IsLabelSymbolNew(b$, "ÌÉÃÁÄÉÊÏÓ", "COMPLEX", Lang) Then
                    
                    If FastSymbol(b$, "=") Then
                    If FastSymbol(b$, "(") Then
                        If IsNumberD2(b$, p, True) Then
                        b$ = NLtrim(b$)
                        If UCase(Left$(b$, 2)) = "I)" Then
                            p = nMath2.cxNew(0, CDbl(p))
                            Mid(b$, 1, 2) = "  "
                        ElseIf Left$(b$, 1) = "," Then
                            Mid(b$, 1, 1) = " "
                            p = nMath2.cxNew(CDbl(p), 0)
                            If IsNumberD2(b$, h, True) Then
                            p.I = CDbl(h)
                            b$ = NLtrim(b$)
                            If Not UCase(Left$(b$, 2)) = "I)" Then
                                SyntaxError
                                StaticNew = False
                                Exit Function
                            End If
                            Mid(b$, 1, 2) = "  "
                        End If
                        bstack.SetVar W$, p
                        GoTo aaa1
                        End If
                        End If
                    ElseIf IsNumberD2(b$, p, True) Then
                        p = nMath2.cxNew(CDbl(p), 0)
                        bstack.SetVar W$, p
                        GoTo aaa1
                    End If
                    
                    End If
                    SyntaxError
                    Exit Function
                ElseIf IsLabelSymbolNew(b$, "ÌÅÃÁËÏÓÁÊÅÑÁÉÏÓ", "BIGINTEGER", Lang) Then
                    Set p = New BigInteger
                    If FastSymbol(b$, "=") Then
                        If Not IsNumberD2(b$, p, True, True) Then
                           missNumber
                                Exit Function
                            
                        End If
                         Set p = Module13.CreateBigInteger(CStr(p))
                    End If
                    bstack.SetVarobJ W$, p
                    GoTo aaa1
                ElseIf IsEnumAs(bstack, b$, p, ok) Then
                    If ok Then
                        bstack.SetVarobJ W$, p
                        GoTo aaa1
                    Else
                        Exit Function
                    End If
                Else
                    MyEr "No type found", "äåí âñÞêá ôýðï"
                    Exit Function
                End If
                If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then
                        If VarType(p) = vbDate Then
                           If ISSTRINGA(b$, ss$) Then
                                p = vbNullString
                                SwapString2Variant ss$, p
                            Else
                                missNumber
                                Exit Function
                            End If
                        Else
                            missNumber
                            Exit Function
                        End If
                    End If
                     If Len(b$) > 0 Then
                        If InStr("!@#%~&", Left$(b$, 1)) > 0 Then
                            Mid$(b$, 1, 1) = " "
                        Else
                           Select Case LCase(Left$(b$, 2))
                           Case "ub", "ud"
                           Mid$(b$, 1, 2) = "  "
                           End Select
                        End If
                        
                        End If
                End If
                bstack.SetVar W$, p
            ElseIf FastSymbol(b$, "->", , 2) Then
                If GetPointer(bstack, b$) Then
                    If bstack.lastpointer.IamFloatGroup Then
                        bstack.SetVarobJvalue W$, bstack.lastpointer
                    Else
                        Set bstack.lastpointer = Nothing
                        GoTo aaaa1
                    End If
                Else
                    GoTo aaaa1
                End If
            Else
               bstack.SetVar W$, p
            End If
            Set bstack.lastobj = Nothing
        ElseIf FastSymbol(b$, "=") Then
            ii = 1
            ss$ = aheadstatus(b$, False, ii)
            b$ = Mid$(b$, ii)
        ElseIf Fast2VarNoTrim(b$, "ÙÓ", 2, "AS", 2, 3, ii) Then
            ii = 1
            ss$ = aheadstatus(b$, False, ii)
            b$ = Mid$(b$, ii)
        ElseIf FastSymbol(b$, "->", , 2) Then
            ii = 1
            ss$ = aheadstatus(b$, False, ii)
            b$ = Mid$(b$, ii)
        End If
        StaticNew = True
    Case 3
        If Not bstack.ExistVar(W$) Then
            If FastSymbol(b$, "=") Then If Not IsStrExp(bstack, b$, ss$) Then SyntaxError: Exit Function
            bstack.SetVar W$, ss$
        ElseIf FastSymbol(b$, "=") Then
            ii = 1
            ss$ = aheadstatus(b$, False, ii)
            b$ = Mid$(b$, ii)
        End If
        StaticNew = True
    Case 4
        If Not bstack.ExistVar(W$) Then
            If FastSymbol(b$, "=") Then
            If Not IsExp(bstack, b$, p) Then SyntaxError: Exit Function
            ElseIf IsLabelSymbolNew(b$, "ÙÓ", "AS", Lang) Then
    
               If IsLabelSymbolNew(b$, "ÁÑÉÈÌÏÓ", "DECIMAL", Lang) Then
                    p = CDec(p)
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    End If
                    p = Int(p)
            ElseIf IsLabelSymbolNew(b$, "ÄÉÐËÏÓ", "DOUBLE", Lang) Then
                    p = 0#
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    End If
                    p = Int(p)
            ElseIf IsLabelSymbolNew(b$, "ÁÐËÏÓ", "SINGLE", Lang) Then
                    p = 0!
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    End If
                    p = Int(p)
            ElseIf IsLabelSymbolNew(b$, "ËÏÃÉÊÏÓ", "BOOLEAN", Lang) Then
                    p = False
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    End If
            ElseIf IsLabelSymbolNew(b$, "ÌÁÊÑÕÓ", "LONG", Lang) Then
                    If IsLabelSymbolNew(b$, "ÌÁÊÑÕÓ", "LONG", Lang) Then
                        p = cInt64(0)
                    Else
                        p = 0&
                    End If
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    
                    End If
            ElseIf IsLabelSymbolNew(b$, "ÁÊÅÑÁÉÏÓ", "INTEGER", Lang) Then
                    p = 0
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    End If
            ElseIf IsLabelSymbolNew(b$, "ËÏÃÉÓÔÉÊÏÓ", "CURRENCY", Lang) Then
                    p = 0@
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    End If
                    p = Int(p)
            ElseIf IsLabelSymbolNew(b$, "ØÇÖÉÏ", "BYTE", Lang) Then
                    p = CByte(0)
                    If FastSymbol(b$, "=") Then
                    If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                    End If
                    p = CByte(p)
            Else
            MyEr "No type found", "äåí âñÞêá ôýðï"
            Exit Function
            End If
            
         
            End If
            If Len(b$) > 0 Then
            If InStr("!@#%~&", Left$(b$, 1)) > 0 Then
                Mid$(b$, 1, 1) = " "
            End If
            End If
            bstack.SetVar W$, p
        ElseIf FastSymbol(b$, "=") Then
         ii = 1
            ss$ = aheadstatus(b$, False, ii)
        b$ = Mid$(b$, ii)
        'ElseIf Fast2VarNoTrim(b$, "ÙÓ", 2, "AS", 2, 3, ii) Then
        ElseIf IsLabelSymbolNew(b$, "ÙÓ", "AS", Lang) Then
         ii = 1
            ss$ = aheadstatus(b$, False, ii)
        b$ = Mid$(b$, ii)
    End If
        StaticNew = True
        
    Case Else
conthere:
        MyErMacro b$, "No static for that type " + W$, "¼÷é óôáôéêÞ ãéá áõôü ôï ôýðï " + W$
        Exit Function
    End Select
aaa1:
 Loop Until Not FastSymbol(b$, ",")
End Function
Function MyDocument(basestack As basetask, rest$, Lang As Long, Optional alocal As Boolean) As Boolean
Dim ss$, s$, what$, x1 As Long, I As Long, it As Long, pppp As mArray
MyDocument = True
ss$ = vbNullString
Do
    x1 = Abs(IsLabel(basestack, rest$, what$))
    If basestack.priveflag Then what$ = ChrW(&HFFBF) + what$
    If x1 = 3 Or x1 = 6 Then
        If x1 = 3 Then
            If Not FastSymbol(rest$, "<") Then  ' get local var first
                If alocal Then
                    I = globalvar(basestack.GroupName + what$, s$)  ' MAKE ONE  '
                    GoTo makeitnow
                ElseIf GetlocalVar(basestack.GroupName + what$, I) Then
                    GoTo there0
                ElseIf GetVar(basestack, basestack.GroupName + what$, I) Then
                    GoTo there0
                Else
                    I = globalvar(basestack.GroupName + what$, s$)  ' MAKE ONE  '
                    GoTo makeitnow
                End If
            ElseIf GetVar(basestack, basestack.GroupName + what$, I) Then
there0:
                s$ = var(I)
                MakeitObject var(I)
                CheckVar var(I), s$
                GoTo there1
            Else
                I = globalvar(basestack.GroupName + what$, s$) ' MAKE ONE
                If I <> 0 Then
makeitnow:
                    MakeitObject var(I)
there1:
                    If FastSymbol(rest$, "=") Then
                        If IsStrExp(basestack, rest$, s$, False) Then
                            CheckVar var(I), s$
                        Else
                            MissStringExpr
                            MyDocument = False
                        End If
                    End If
                End If
            End If
        Else
            If neoGetArray(basestack, what$, pppp, here$ <> "") Then   ' basestack.GroupName &
                If Not NeoGetArrayItem(pppp, basestack, what$, it, rest$) Then MyDocument = False: Exit Function
                x1 = 0
                If Not MyIsObject(pppp.item(it)) Then
                    s$ = pppp.item(it)
                    Set pppp.item(it) = New Document
                    If s$ <> "" Then pppp.item(it).textDoc = s$
                    If FastSymbol(rest$, "=") Then
                        If IsStrExp(basestack, rest$, s$, False) Then
                            CheckVar pppp.item(it), s$
                        Else
                            MissStringExpr
                            MyDocument = False
                        End If
                    End If
                Else
                    If FastSymbol(rest$, "=") Then
                        If IsStrExp(basestack, rest$, s$, False) Then
                            CheckVar pppp.item(it), s$
                        Else
                            MissStringExpr
                            MyDocument = False
                        End If
                    Else
                        Exit Do
                    End If
                End If
                MyDocument = True
            Else
                MyErMacro rest$, "array has no dimension", "ï ðßíáêáò äåí Ý÷åé ïñéóôåß"
                MyDocument = False
                Exit Function
            End If
        End If
    Else
        SyntaxError
        MyDocument = False
    End If
Loop Until Not FastSymbol(rest$, ",")
End Function

Function GrabFrame() As String
Dim p As New cDIBSection

p.CreateFromPicture hDCToPicture(GetDC(0), AVI.Left / DXP, AVI.top / DYP, AVI.Width / DXP, AVI.Height / DYP - 1)
If p.Height > 0 Then

GrabFrame = DIBtoSTR(p)
End If
End Function
Function ProcChooseOrgan(bstack As basetask, rest$, Lang As Long) As Boolean
Dim f As Long, I As Long, s$
If Form4Loaded Then
If Form4.Visible Then
Form4.Visible = False
    If Form1.TEXT1.Visible Then
        Form1.TEXT1.SetFocus
    Else
        Form1.SetFocus
    End If
End If
End If
Form1.List1.Clear
f = 0
For I = 1 To 127
s$ = ORGAN(I)
Form1.List1.additemFast s$
'If TextWidth(bstack.Owner, s$) > f Then f = TextWidth(bstack.Owner, s$)
Next I
ProcChooseOrgan = MyMenu(1, bstack, rest$, Lang)
End Function
Public Function CallEventFromCOM(evCom As ComShinkEvent, aString$, what$, NumVar As Long, vrs(), exclude As Boolean, ItemIndex As Long) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
Dim f$, F1$, klm As Long, ohelp As Object
'olescok = escok
'escok = False
CallEventFromCOM = True
F1$ = evCom.modulename$
f$ = UCase(F1$ + "_" + aString$ + "()") ' No greek
If Not subHash.Find(f$, klm) Then exclude = True: Exit Function
extr = extreme
extreme = True
tr = trace
trace = False
Dim n$, bb As mStiva, oldbstack As mStiva, nowtotal As Long
Dim bstack As basetask
Set bstack = New basetask
Set bstack.Owner = Form1.DIS
Set bstack.StaticCollection = EventStaticCollection
bstack.IamAnEvent = True
Dim I As Long
I = evCom.VarIndex
F1$ = evCom.modulename
Set oldbstack = bstack.soros
Dim j As Long, K As Long, s1$, S2$
Dim ohere$
ohere$ = here$
here$ = vbNullString

If evCom.Attached Then
Set bb = New mStiva
Set bstack.Sorosref = bb
            PushStage bstack, False
            If ItemIndex > -1 Then
                bb.DataVal CVar(ItemIndex)
            End If
            For K = 1 To NumVar
            If VariantIsRef(VarPtr(vrs(K))) Then
            Select Case VarType(vrs(K))
            Case vbString
            globalvarGroup "EV" & (I + K) & "$", vrs(K)
            bb.DataStr "EV" & (I + K) & "$"
            Case Is >= vbArray
            ' make it normal
            globalvarGroup "EV" & (I + K) & "(", RetM2000array(vrs(K))
            bb.DataStr "EV" & (I + K)
            Case Else
            globalvarGroup "EV" & (I + K), vrs(K)
            bb.DataStr "EV" & (I + K)
            End Select
            Else
            Select Case VarType(vrs(K))
            Case vbString
            bb.DataStr CStr(vrs(K))
            Case Is >= vbArray
            ' make it normal
                Set ohelp = RetM2000array(vrs(K))
                bb.DataObj ohelp
                Set ohelp = Nothing
            Case Else
                If MyIsObject(vrs(K)) Then
                    Set ohelp = vrs(K)
                    bb.DataObj ohelp
                    Set ohelp = Nothing
                Else
                    bb.DataVal vrs(K)
                End If
            End Select
            End If
            Next K
            '''bb.DataObj evCom
            '' last is the second name, the class name??
            bb.DataStr what$
     
            bb.DataObj MakeitObjectGeneric(evCom.VarIndex)
  
            'f$ = aString$
            
           '' WE ARE GOING TO OUR MODULE
           
            here$ = evCom.modulenameonly

            If FastCallModule(bstack, klm) <> 1 Then
            
            
            
                PopStage bstack
                bb.Flush
                GoTo conthere
            End If
                  here$ = vbNullString
                  If NumVar > 0 Then
       For K = LBound(vrs()) To UBound(vrs()) - 1
       Select Case VarType(vrs(K))
       Case vbString
            GetlocalVar "EV" & (I + K) & "$", j
            vrs(K) = var(j)
       Case Is >= vbArray
            GetlocalVar "EV" & (I + K) & "(", j
            RetComArray var(j), vrs(K)
       
        Case Else
            GetlocalVar "EV" & (I + K), j
             vrs(K) = var(j)
            End Select
           
            Next K
            End If
            PopStage bstack

            bb.Flush

End If

conthere:
Set bstack.Sorosref = oldbstack
here$ = ohere$
Set oldbstack = Nothing
Set bb = Nothing
extreme = extr
trace = tr

'escok = olescok
End Function
Function makestruct(basestack As basetask, rest$, Lang As Long, Glob As Boolean, alocal As Boolean) As Boolean
Dim what$, Offset As Long, offset1 As Long, offsetlist As FastCollection, I As Long, s$, b$, p As Variant, w2 As Long
' struct is an inventory of offsets
Dim usehandler As mHandler
If Abs(IsLabel(basestack, rest$, what$)) = 1 Then  ' WE HAVE A NAME
If basestack.priveflag Then what$ = ChrW(&HFFBF) + what$
          If alocal Or Glob Then
          GoTo makeitnow
          ElseIf GetlocalVar(basestack.GroupName + what$, I) Then
                        If Not MyIsObject(var(I)) Then MakeitObjectInventory var(I)
                    ElseIf GetVar(basestack, basestack.GroupName + what$, I) Then
                        If Not MyIsObject(var(I)) Then MakeitObjectInventory var(I)
                    Else
makeitnow:
                        I = globalvar(basestack.GroupName + what$, Empty, , Glob)
                        MakeitObjectInventory var(I)
                        Set usehandler = var(I)
                        usehandler.objref.UcaseKeys = True
                        usehandler.objref.Tag = what$
                        comhash.ItemCreator2 what$, 0, 44
                    End If
                     Set usehandler = var(I)
Set offsetlist = usehandler.objref
' so now we have the inventory
Dim mm As Long
If Fast2LabelNoNum(rest$, "APPEND", 6, "ÐÑÏÓÈÇÊÇ", 8, 8) Then
    mm = offsetlist.structLen
End If
If FastSymbol(rest$, "{") Then

    
    If StructPage(basestack, rest$, Lang, mm, Offset, offsetlist, "") Then
    If offsetlist Is Nothing Then Exit Function
    offsetlist.structLen = Offset
    usehandler.ReadOnly = True
    makestruct = True
    End If
End If
Set offsetlist = Nothing
End If
End Function
Function ProcKeyboard(basestack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, s$, p As Variant, w3 As Long, G As gList
Dim alt, shift, ctrl, again As Boolean
On Error Resume Next
If IsLabelSymbolNew(rest$, "ÖÏÑÔÙÓÅ", "LOAD", Lang) Then
If IsStrExp(basestack, rest$, s$) Then
    Set basestack.lastobj = Nothing
    If LoadKeyboardLayout(s$, KLF_ACTIVATE) <> 0 Then
    
    End If
Else
    If Lang = 0 Then
    LoadKeyboardLayout "00000408", KLF_ACTIVATE
    Else
    LoadKeyboardLayout "00000409", KLF_ACTIVATE
    End If
End If
ElseIf IsLabelSymbolNew(rest$, "ÐÅÔÁ", "REMOVE", Lang) Then
If IsStrExp(basestack, rest$, s$) Then
    Set basestack.lastobj = Nothing
    If s$ = "00000408" Or s$ = "00000409" Then
    Else
    If UnloadKeyboardLayout(LoadKeyboardLayout(s$, HKL_NEXT)) <> 0 Then
    
    End If
    End If
End If
ElseIf IsLabelSymbolNew(rest$, "ÄÙÓÅ", "PUT", Lang) Then
    If IsStrExp(basestack, rest$, s$) Then
        If LenB(s$) > 1 Then
        
            s$ = myUcase(s$, True)
            p = AscW(s$)
            again = Len(s$) > 1
            If p > 128 Or p < 0 Then
                GoTo err123
            End If
            p = p + 500
        Else
err123:
            MyEr "Code out of range", "Êùäéêüò åêôüò åìâÝëåéáò"
            Exit Function
        End If
    ElseIf IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
        On Error GoTo err123
        p = CInt(p)
        If p > 128 Or p < 0 Then
                GoTo err123
        End If
        p = p + 500
        alt = 0
        shift = 0
        ctrl = 0
    End If
    If FastSymbol(rest$, ",") Then
        If FastSymbol(rest$, ",") Then GoTo j1
        IsExp basestack, rest$, shift, , True
        If FastSymbol(rest$, ",") Then
j1:
            If FastSymbol(rest$, ",") Then GoTo j2
            IsExp basestack, rest$, ctrl, , True
            If FastSymbol(rest$, ",") Then
j2:
            If Not IsExp(basestack, rest$, alt, , True) Then
                MissPar
                Exit Function
            End If
            End If
        End If
    End If
a1234:
    SendAKey p, shift, ctrl, alt
    If again Then
            s$ = Mid$(s$, 2)
            If LenB(s$) < 2 Then GoTo err123
            p = AscW(s$)
            again = Len(s$) > 1
            If p > 128 Or p < 0 Then
                GoTo err123
            End If
            GoTo a1234
    End If
ElseIf FastSymbol(rest$, "!") Then
    MyShell "osk.exe"
Else
    par = True
    Do
        If par = False Then Exit Do
        If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
            w3 = UINT(p)
    If w3 >= &H10000 And w3 <= &H10FFFF Then
        w3 = w3 - &H10000
        s$ = ChrW(UINT(w3 \ &H400& + &HD800&)) + ChrW(UINT((w3 And &H3FF&) + &HDC00&))
        Else
    s$ = ChrW$(UINT(p))
    End If
  
 If Form1.gList1.Visible Then

    With Form1.TEXT1
    If .UsedAsTextBox Then
    .RemoveUndo s$
    s$ = GetNextLine((s$))
     .InsertTextNoRender = s$
     .SelLength = Len(s$)
    Else
    .RemoveUndo s$
    .InsertTextNoRender = s$
    .Render
    End If
    End With
    Else
    MKEY$ = MKEY$ + s$
    End If

            par = False
        ElseIf IsStrExp(basestack, rest$, s$) Then
       
        
         If Form1.gList1.Visible Then
    With Form1.TEXT1
    If .UsedAsTextBox Then
    .RemoveUndo s$
    s$ = GetNextLine((s$))
     .InsertTextNoRender = s$
     .SelLength = Len(s$)
    Else
    .RemoveUndo s$
    .InsertTextNoRender = s$
    .Render
    End If
    End With
    Else
            MKEY$ = MKEY$ + s$
            End If
        
        par = False
        Else
        Exit Do
        End If
        If Not FastSymbol(rest$, ",") Then Exit Do
        par = True
    Loop
End If
ProcKeyboard = True
End Function

Function ProcCHANGE(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, X As Double, W$, GuiForm As GuiM2000, GuiImg As GuiImage
Dim V1 As Long
If IsExp(bstack, rest$, p) Then
    p = CLng(p)
    If TypeOf bstack.Owner Is MetaDc Then
            oxiforMetaFiles
            GoTo skipcommand
    ElseIf TypeOf bstack.Owner Is GuiM2000 Then
        Set GuiForm = bstack.Owner
        GuiForm.RenderTarget bstack, rest$, Lang, p
    ElseIf val("0" + bstack.Owner.Tag) > 32 Then
        If GetVar(bstack, players(GetCode(bstack.Owner)).ControlName, V1) Then
            Set GuiImg = var(V1)
            GuiImg.RenderTarget bstack, rest$, Lang, p
        End If
    Else
        If p >= 0 And p < UBound(q()) Then
            Dim ss$
            While FastSymbol(rest$, ",")
                ss$ = vbNullString
                X = Empty
                If IsLabelSymbolNewExp(rest$, "ÖÑÁÓÇ", "TEXT", Lang, ss$) Then
                    If IsStrExp(bstack, rest$, W$) Then
                        q(p).Tag = W$
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÐÅÍÁ", "PEN", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        q(p).pen = X
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÖÏÍÔÏ", "BACK", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        q(p).back = X
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÐËÁÉÓÉÏ", "BORDER", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        q(p).fore = X
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÏÄÇÃÉÁ", "COMMAND", Lang, ss$) Then
                    If IsStrExp(bstack, rest$, W$) Then
                        q(p).Comm = W$
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÔÉÌÇ", "VALUE", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        q(p).topval = Int(X * 100)
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÂÁÓÇ", "BASE", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        q(p).botval = Int(X * 100)
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "×ÑÙÌÁ", "COLOR", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        q(p).barC = X
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÌÅÃÅÈÏÓ", "SIZE", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        If X > 100 Then X = 100
                        If X < -100 Then X = -100
                        q(p).imagesize = Int(X)
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÊÁÈÅÔÇ", "PORTRAIT", Lang, ss$) Then
                    If IsExp(bstack, rest$, X, , True) Then
                        q(p).Vertical = Int(X) <> 0
                    Else
                        GoTo skipcommand
                    End If
                ElseIf IsLabelSymbolNewExp(rest$, "ÅÉÊÏÍÁ", "IMAGE", Lang, ss$) Then
                    If IsExp(bstack, rest$, X) Then
                        If bstack.lastobj Is Nothing Then
                            Set q(p).drawimage = Nothing
                        ElseIf TypeOf bstack.lastobj Is mHandler Then
                            Dim usehandler As mHandler
                            Set usehandler = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            If usehandler.T1 = 2 Then
                                Set q(p).drawimage = usehandler.objref
                            Else
                                GoTo err123
                            End If
                        Else
err123:
                            WrongObject
                            Exit Function
                        End If
                    Else
                        GoTo skipcommand
                    End If
                Else
                    GoTo skipcommand
                End If
            Wend
            RTarget bstack, q(p)
        Else
        GoTo skipcommand
        End If
    End If
    ProcCHANGE = True
    Exit Function
End If
skipcommand:
ProcCHANGE = True
V1 = 1
FastSymbol rest$, ","
Do
aheadstatusSkipParam rest$, V1
If V1 > 1 And V1 <= Len(rest$) Then
    rest$ = Mid$(rest$, V1)
    FastSymbol rest$, ","
    V1 = 1
Else
    Exit Do
End If
Loop Until V1 = 1
End Function


Private Function lookB123(s) As Boolean
Dim I&, L As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s): If L = 0 Then Exit Function
  P2 = StrPtr(s): L = L - 1

  For I = P2 To P2 + L * 2 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case 13, 47, 39, 92
    lookB123 = True
    Case Else
   Exit Function
  End Select
  Next I
End Function
Function MyError(basestack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, x1 As Long, s$, ss$, what$
Dim myMsgBox As New stdCallFunction, I As Long
x1 = LastErNum
If IsExp(basestack, rest$, p, , True) Then
If myVarType(p, vbString) Then s$ = p: GoTo g13123
If p = 0 Then
myMsgBox.CallThis "user32.MessageBoxW", "long alfa, lptext$, lpcaption$, long type", 1
basestack.soros.PushVal 16
basestack.soros.PushStr MesTitle$
basestack.soros.PushStr "Fatal Error"
basestack.soros.PushVal Form1.hWnd
Module1.CallByObject basestack, False, myMsgBox
NERR = True
MyError = False
Exit Function
ElseIf p = -1 Then
NERR = False
MyError = False
Exit Function
Else
If p = -2 Then
 ISSTRINGA rest$, s$
 ISSTRINGA rest$, ss$
MyEr s, ss$
If basestack.IamThread Then
On Error Resume Next
basestack.Parent.ThrowThreads
NERR = False
MyError = False
Exit Function
End If
MyError = False
Exit Function

Else
MyEr "ERROR " & p, "ËÁÈÏÓ " & p
LastErNum = p
End If
End If
ElseIf IsStrExp(basestack, rest$, s$, False) Then
g13123:
MyEr what$ + " " + s$, what$ + " " + s$
Else
LastErNum = 0 ': LastErNum1 = 0
LastErNameGR = vbNullString
LastErName = vbNullString

MyError = True
Exit Function
End If

MyError = False

End Function

Function IsSymbol3(A$, C$) As Boolean
' SAME AS FASTSYMB WITHOUT trim after
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
If j - I > -1 Then
If C$ = Mid$(A$, I, 1) Then
A$ = Mid$(A$, I + 1)
IsSymbol3 = True
End If
End If
End Function
Public Function MyTrimLi(s$, L As Long) As Long
Dim I&
Dim P2 As Long, P1 As Integer, p4 As Long
 If L > Len(s) Then MyTrimLi = Len(s) + 1: Exit Function
 If L <= 0 Then MyTrimLi = 1: Exit Function
  L = L - 1
  I = Len(s)
  P2 = StrPtr(s) + L * 2:  p4 = P2 + I * 2
  For I = P2 To p4 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 9
    Case Else
     MyTrimLi = (I - P2) \ 2 + 1 + L
   Exit Function
  End Select
  Next I
 MyTrimLi = Len(s) + 1
End Function

Public Function MyTrimL(s$) As Long
Dim I&, L As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s): If L = 0 Then MyTrimL = 1: Exit Function
  P2 = StrPtr(s): L = L - 1
  p4 = P2 + L * 2
  For I = P2 To p4 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case Else
     MyTrimL = (I - P2) \ 2 + 1
   Exit Function
  End Select
  Next I
 MyTrimL = L + 2
End Function
Function myLof2(I As Long) As Currency
    Dim FH As Long
    FH = Module10.ReadFileHandler(I)
    If FH = 0 Then Exit Function
    Module10.API_FileSize FH, myLof2
End Function
Function myLof2FH(FH As Long) As Currency
    If FH = 0 Then Exit Function
    Module10.API_FileSize FH, myLof2FH
End Function
Sub Str1nControls(ByRef r$)
On Error Resume Next
    If Screen.ActiveForm Is Nothing Then
    r$ = vbNullString
    Else
    Select Case Screen.ActiveForm.Name
    Case "View1"
      r$ = "BROWSER"
    Case "TweakForm"
      r$ = "SETTINGS"
    Case "AVI"
    r$ = "AVI"
    Case "Form1"
      r$ = "MAIN"
    Case "Form4"
    r$ = "HELP"
    Case Else
     GetGuiM2000 r$
    End Select
    End If
                
End Sub
Sub Str1nControlsGR(ByRef r$)
    On Error Resume Next
    If Screen.ActiveForm Is Nothing Then
    r$ = vbNullString
    Else
    Select Case Screen.ActiveForm.Name
    Case "AVI"
    r$ = "ÔÁÉÍÉÁ"
    Case "Form1"
    r$ = "ÊÕÑÉÏ"
    Case "Form4"
    r$ = "ÂÏÇÈÅÉÁ"
    Case Else
    GetGuiM2000 r$
    End Select
    End If
End Sub
Function IsEof(bstack As basetask, A$, r As Variant) As Boolean
Dim VR, myFileLen As Currency, FH As Long
    IsSymbol3 A$, "#"  ' drop it
    If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
        VR = Int(r)
        If Fstep(VR) = 0 Then
            wrongfilenumber A$
        Else
            FH = Module10.ReadFileHandler(CLng(VR))
            API_FileSize FH, myFileLen
            r = myFileLen < CCur(Module10.FileSeek(VR))
            IsEof = FastSymbol(A$, ")", True)
        End If
    Else
        MissParam A$
    End If
End Function
Function IsSeek(bstack As basetask, A$, r As Variant) As Boolean
    Dim VR
    IsSymbol3 A$, "#"  ' drop it
    If IsExp(bstack, A$, r, flatobject:=True, nostring:=True) Then
        r = Int(r)
        If Fstep(r) = 0 Then
            wrongfilenumber A$
        ElseIf Fstep(r) <> 1 Then
            MyErMacro A$, "not valid file TYPE", "ëÜèïò ÔÕÐÏÓ áñ÷åßïõ"
        Else
            r = FileSeek(r)
            IsSeek = FastSymbol(A$, ")", True)
        End If
    Else
         MissParam A$
    End If
End Function

Public Function Validator(bstack As basetask, A$, v$, r) As Boolean
    Dim V1&, w1&, s$, VR&, n$, p
    If FastSymbol(A$, "@") Then
        If IsLabel(bstack, A$, s$) Then
            Validator = True
            If Right$(s$, 1) = "(" Then FastSymbol A$, ")"
            If GetVar(bstack, s$, VR) Then
                r = True
                w1 = Abs(Asc(v$) < 128)
                If IsLabelSymbolNew(A$, "ÙÓ", "AS", w1) Then
                    If IsLabel(bstack, A$, s$) Then
                        If Right$(s$, 1) = "(" Then FastSymbol A$, ")"
                        If GetVar(bstack, s$, V1&) Then
                            r = CheckTwo(VR, V1&)
                        Else
                            r = 0
                        End If
                    Else
                        MissVarName
                        Validator = False
                    End If
                End If
            End If
        End If
        Validator = FastSymbol(A$, ")")
    Else
            Validator = True
            Dim OLD1$, OLD2$
            OLD1$ = LastErName
            OLD2$ = LastErNameGR
            MyEr "", ""
            w1 = 1
            s$ = aheadstatus(A$, True, w1) + "   "  ' version 6.5(11)
            n$ = Left$(A$, w1 - 1)
            If w1 > 1 Then Mid$(A$, 1, w1 - 1) = space$(w1 - 1)
            If Left$(s$, 1) = "S" And Not Left$(s$, 3) = "SoN" Then
                If IsStrExp(bstack, n$, s$, False) Then
                    
                    A$ = Mid$(A$, w1)
                    r = (FastSymbol(A$, ")") And NLtrim$(n$) = vbNullString)
                ElseIf LastErNum <> 0 Then
                    GoTo JUMPHERE
                Else  ' for MyErMacro
                    r = 1
                    If Len(A$) + w1 > Len(n$) Then r = 0
                    r = r * FastSymbol(A$, ")", True)
                End If
    
            ElseIf IsExp(bstack, n$, p) Then
                A$ = Mid$(A$, w1)
                r = (FastSymbol(A$, ")") And NLtrim$(n$) = vbNullString)
            ElseIf IsStrExp(bstack, n$, s$, False) Then
                    
                    A$ = Mid$(A$, w1)
                    r = (FastSymbol(A$, ")") And NLtrim$(n$) = vbNullString)
            ElseIf LastErNum = 0 Then ' ' for MyErMacro
                r = 1
                If Len(A$) + w1 > Len(n$) Then r = 0
                r = r * FastSymbol(A$, ")", True)
            Else
JUMPHERE:
            LastErNum = 0
            LastErNum1 = 0
            LastErNameGR = vbNullString
            LastErName = vbNullString
            A$ = Mid$(A$, w1)
            Validator = FastSymbol(A$, ")")
            r = 0
        End If
        If "" <> LastErName Then r = 0
        If "" <> LastErNameGR Then r = 0
        LastErNameGR = vbNullString
        LastErName = vbNullString
        LastErNum = 0
        LastErNum1 = 0
        End If
        Set bstack.lastobj = Nothing
End Function
Function ProcTargets(bstack As basetask, rest$, Lang As Long) As Boolean
Dim GuiForm As GuiM2000, GuiImg As GuiImage, V1 As Long
If TypeOf bstack.Owner Is GuiM2000 Then
Set GuiForm = bstack.Owner
ElseIf val("0" + bstack.Owner.Tag) > 32 Then
    If GetVar(bstack, players(GetCode(bstack.Owner)).ControlName, V1) Then
        Set GuiImg = var(V1)
    Else
        Exit Function
    End If
ElseIf TypeOf bstack.Owner Is MetaDc Then
oxiforMetaFiles
Exit Function
End If
If Lang = 1 Then
    If IsLabelSymbolLatin(rest$, "NEW") Then
         If Not GuiForm Is Nothing Then
            GuiForm.ClearTargets
        ElseIf Not GuiImg Is Nothing Then
            GuiImg.ClearTargets
        Else
            If Targets Then
                Targets = False
            End If
            ReDim q(0) As target
        End If
    End If
Else
    If IsLabelSymbol(rest$, "ÍÅÏÉ") Then
        If Not GuiForm Is Nothing Then
            GuiForm.ClearTargets
        ElseIf Not GuiImg Is Nothing Then
            GuiImg.ClearTargets
        Else
            If Targets Then
                Targets = False
            End If
            ReDim q(0) As target
        End If
    End If
End If
ProcTargets = True
End Function

Function ProcPrinting(basestack As basetask, rest$, Lang As Long) As Boolean
Dim xp As Printer, Scr As Object
Set Scr = basestack.Owner
  ProcPrinting = True
 If ThereIsAPrinter = False Then Exit Function
If IsLabelSymbolNew(rest$, "ÍÁÉ", "ON", Lang) And pname <> "" And Not basestack.toprinter Then
                            basestack.toprinter = True
                            For Each xp In Printers
                            If xp.DeviceName = pname And xp.Port = Port Then Set Printer = xp
                            Next xp
                            getfirstpage

                            Set Scr = Form1.PrinterDocument1
                            
                            If players(-2).Xt = 0 Then
                            players(-2) = players(0)  'COPY dis
                            With players(-2)
                                .curpos = 0
                                .currow = 0
                                .XGRAPH = 0
                                .YGRAPH = 0
                              Form1.PrinterDocument1.FontSize = .SZ * szFactor
                              .SZ = Form1.PrinterDocument1.FontSize
                            End With
                            
                            End If
                            
                            PlaceBasket Form1.PrinterDocument1, players(-2)
                            SetText Form1.PrinterDocument1
                            ''SetTextSZ scr, players(0).SZ
                            LCTbasket Form1.PrinterDocument1, players(-2), 0, 0
                            Printer.currentX = 0
                            Printer.currentY = 0
ElseIf IsLabelSymbolNew(rest$, "Ï×É", "OFF", Lang) And basestack.toprinter Then
                    getenddoc
                    Set Scr = Form1.DIS
                    basestack.toprinter = False
                    SetNormal Scr
                    
ElseIf IsLabelSymbolNew(rest$, "ÄÉÅÊÏØÅ", "BREAK", Lang) And basestack.toprinter Then
                    pnum = 0
                    oprinter.ClearUp
                    Form1.PrinterDocument1.Picture = LoadPicture("")
                    Set Scr = Form1.DIS
                    basestack.toprinter = False
                    SetNormal Scr
                    Else
                    ProcPrinting = False
                    End If
Exit Function
End Function

Function ProcPage(basestack As basetask, rest$, Lang As Long) As Boolean
ProcPage = True
Dim Scr As Object, X As Double, skip As Boolean
Set Scr = basestack.Owner
If basestack.toprinter Then getnextpage: skip = True
If IsLabelSymbolNew(rest$, "ÊÁÈÅÔÇ", "PORTRAIT", Lang) Then
    Portrait basestack
ElseIf IsLabelSymbolNew(rest$, "ÏÑÉÆÏÍÔÉÁ", "LANDSCAPE", Lang) Then
    Landscape basestack
ElseIf IsNumber(basestack, rest$, X) Then
    If X = 1 Then Portrait basestack Else Landscape basestack
ElseIf Not skip Then
    ClearScr Scr, mycolor(PaperOne)
End If
Set Scr = Nothing
End Function
Function ProcPropeties(basestack As basetask, rest$) As Boolean
Dim s$
  If IsStrExp(basestack, rest$, s$, False) Then
  LoadArray MyDM(), s$
  Else
  SyntaxError
  Exit Function
  End If
ProcPropeties = True
End Function

Function ProcMotion(basestack As basetask, rest$, Lang As Long) As Boolean
Dim Scr As Object, x1 As Long, y1 As Long, p As Variant
Set Scr = basestack.Owner
ProcMotion = True
If Lang = 1 And IsLabelSymbolLatin(rest$, "CENTER") Then
ProcMotion = ProcMode(basestack, str$(players(GetCode(Scr)).SZ) + "," + str$(Scr.Width) + "," + str$(Scr.Height))
ElseIf IsLabelSymbol(rest$, "ÊÅÍÔÑÏ") Then
ProcMotion = ProcMode(basestack, str$(players(GetCode(Scr)).SZ) + "," + str$(Scr.Width) + "," + str$(Scr.Height))
Else
If IsExp(basestack, rest$, p) Then x1 = CLng(p) Else x1 = Scr.Left
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p) Then
y1 = CLng(p)
Else
Set Scr = Nothing
ProcMotion = False
Exit Function
End If
Else
y1 = Scr.top
End If
Scr.move x1, y1
End If
MyRefresh basestack
 'MyDoEvents1 Scr
Set Scr = Nothing


End Function

Function ProcWords(basestack As basetask, rest$) As Boolean
Dim x1 As Long, y1 As Long, s$, sX As Double, I As Long, p As Variant, pppp As mArray
ProcWords = True
    y1 = Abs(IsLabel(basestack, rest$, s$))

    If y1 = 6 Then
                If neoGetArray(basestack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, basestack, s$, I, rest$) Then Exit Function
                Else
                MissingDoc
                Exit Function
                End If
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, sX) Then    ' FROM
            MissNumExpr
            Exit Function
        End If
    Else
 sX = 1
    End If
    
        If y1 = 3 Then
            If GetVar(basestack, s$, I) Then
                If VarTypeName(var(I)) = doc Then
                basestack.soros.Begin 1
                var(I).ExportWords2ObjectAddItem basestack.soros, sX <> 0
                var(I).ResetWords
                    
                Else
                    MissingDoc
                    Exit Function
                End If
            Else
                   MissFuncParameterStringVar
                   Exit Function
                    
            End If
        ElseIf y1 = 6 Then
                    If pppp.ItemType(I) = doc Then
                        basestack.soros.Begin 1
                         pppp.item(I).ExportWords2ObjectAddItem basestack.soros, sX <> 0
                         pppp.item(I).ResetWords
                      Else
                      MissingDoc
                      Exit Function
                      End If
               
                    
    Else
                    
                MissPar
                Exit Function
    End If

End Function

Function ProcSound(bstack As basetask, rest$) As Boolean
Dim s$, ss, h As mHandler, M As MemBlock
If IsStrExp(bstack, rest$, s$) Then
PlaySoundNew s$
ProcSound = True
ElseIf IsExp(bstack, rest$, ss) Then
If Not bstack.lastobj Is Nothing Then
If TypeOf bstack.lastobj Is mHandler Then
    Set h = bstack.lastobj
    If h.T1 = 2 Then
        Set M = h.objref
        PlaySoundNew2 M.GetPtr(0)
        ProcSound = True
    Else
        WrongObject
    End If
End If
    Set bstack.lastobj = Nothing
End If

End If

End Function

Function MyVol(basestack As basetask, rest$) As Boolean
Dim p As Variant
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
    vol = CLng(MyMod(Abs(p), 101))
    If FastSymbol(rest$, ",") Then
         If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
            p = CLng(p)
      MediaPlayer1.SetMasterVolume vol, CLng(p)
  Else
      MissParam rest$
      
 End If
Else
 MediaPlayer1.SetMasterVolume vol
End If
End If
MyVol = True
End Function

Function ProcSettings(bstack As basetask, rest$, Lang As Long) As Boolean
Dim it As Long, ff As Form, ffu As GuiM2000
TweakLang = Lang
Dim thisform As Object
If Not Screen.ActiveForm Is Nothing Then
If TypeOf Screen.ActiveForm Is GuiM2000 Then
    Set thisform = Screen.ActiveForm
ElseIf Screen.ActiveForm Is MyPopUp Then
    Set thisform = MyPopUp.LASTActiveForm
    MyPopUp.Hide
Else
    Set thisform = Screen.ActiveForm
End If

End If
With bstack.Owner
    it = .FontItalic
    .FontItalic = 0
    notweak = True
    MoveFormToOtherMonitorOnly TweakForm
    If Not Form1.Visible Then
    If Screen.ActiveForm Is Nothing Then
    TweakForm.Show , Form5
    Else
         Set ff = Screen.ActiveForm
        If TypeOf ff Is GuiM2000 Then
            Set ffu = ff
            If ffu.Visible Then
            If ffu.Enablecontrol Then
                ffu.SetFocus
            Else
                Set ff = Form5
            End If
            End If
            TweakForm.Show , ff
        Else
            TweakForm.Show , Form5
        End If
    End If
    
    Else
        If bstack.IamThread Or bstack.IamAnEvent Then
            TweakForm.Show , Form1
        Else
            TweakForm.Show 1, Form1
        End If
    End If
   
    If Not notweak Then
        If Form1.Visible Then
            Form1.myBreak bstack
            original bstack, ""
        End If
    Else
        .FontItalic = it
    End If
End With
ProcSettings = True
End Function

Sub i3MouseIcon(basestack As basetask, rest$, Lang As Long)
On Error Resume Next
Dim Scr As Object, s$, X As Double, aPic As StdPicture, I As Long
Set Scr = basestack.Owner

If basestack.toprinter Then
    oxiforPrinter
Else
        If IsLabelSymbolNew(rest$, "ÊÑÕØÅ", "HIDE", Lang) Then
                    If FastSymbol(rest$, "!") Then
                    Set Form1.MouseIcon = Form1.Picture2.MouseIcon
                    Form1.MousePointer = 99
                    Set Form1.DIS.MouseIcon = Form1.Picture2.MouseIcon
                    Form1.DIS.MousePointer = 99
                    For I = 1 To PobjNum
                    Set Form1.dSprite(I).MouseIcon = Form1.Picture2.MouseIcon
                    Form1.dSprite(I).MousePointer = 99
                    Next I
                    Else
                    Set Scr.MouseIcon = Form1.Picture2.MouseIcon
                    Scr.MousePointer = 99
                    With players(GetCode(Scr))
                        .HideIcon = True
                    End With
                End If
                 
        ElseIf IsLabelSymbolNew(rest$, "ÄÅÉÎÅ", "SHOW", Lang) Then
            If FastSymbol(rest$, "!") Then
                    
                    With players(-1)
                    
                    If Form1.MouseIcon = Form1.Picture2.MouseIcon And Not .HideIcon Then
                        Form1.MousePointer = .LastIcon
                        Set Form1.MouseIcon = .LastIconPic
                        
                        End If
                    End With
                    
                    With players(0)
                    If Form1.DIS.MouseIcon = Form1.Picture2.MouseIcon And Not .HideIcon Then
                        Form1.DIS.MousePointer = .LastIcon
                        Set Form1.DIS.MouseIcon = .LastIconPic
                        End If
                    End With
                    For I = 1 To PobjNum
                    
                    With players(val("0" & Form1.dSprite(I).Tag))
                        If Form1.dSprite(I).MouseIcon = Form1.Picture2.MouseIcon And Not .HideIcon Then
                        Form1.dSprite(I).MousePointer = .LastIcon
                       Set Form1.dSprite(I).MouseIcon = .LastIconPic
                        End If
                    End With
                    Next I
                    
            Else
                
                    With players(GetCode(Scr))
                    If Scr.MouseIcon = Form1.Picture2.MouseIcon Then
                     .HideIcon = False
                     If .LastIcon = 99 And Scr.MousePointer = 99 Then
                        Set Scr.MouseIcon = .LastIconPic
                     ElseIf .LastIcon = 99 Then
                        Set Scr.MouseIcon = .LastIconPic
                        Scr.MousePointer = 99
                     Else
                        Scr.MousePointer = .LastIcon
                     End If
                     
                      
                     
                    End If
                    End With
                End If
                
        ElseIf IsStrExp(basestack, rest$, s$) Then
                If s$ <> vbNullString Then
                    s$ = CFname(s$)
                    If s$ <> vbNullString Then
                    If LCase(Right$(s$, 4)) = ".ico" Or LCase(Right$(s$, 4)) = ".cur" Then
                        Set aPic = LoadPicture(GetDosPath(s$))
                    Else
                        
                        Set aPic = LoadMyPicture(GetDosPath(s$))
                        End If
                        
                        If aPic Is Nothing Then MissCdib: Exit Sub
                        If Not FastSymbol(rest$, ";") Then
                        If LCase(Right$(s$, 4)) = ".ico" Then Set Scr.MouseIcon = Form1.Picture2.MouseIcon: Scr.MousePointer = 99
                        End If
                        Set Scr.MouseIcon = aPic
                        Scr.MousePointer = 99
                        With players(GetCode(Scr))
                            Set .LastIconPic = aPic
                            .LastIcon = 99
                        End With
                    Else
                    MissFile
                    End If
                Else
                    Set Scr.MouseIcon = Nothing
                    Scr.MousePointer = 1
                    With players(GetCode(Scr))
                        Set .LastIconPic = Nothing
                        .LastIcon = 1
                    End With
                End If
                
                
    ElseIf IsExp(basestack, rest$, X) Then
                basestack.LastState = False
                On Error Resume Next
                If CLng(X) = 99 Then
                With players(GetCode(Scr))
                If .LastIconPic Is Nothing Then
                Set Scr.MouseIcon = Form1.PrinterDocument1.MouseIcon
                Set .LastIconPic = Form1.PrinterDocument1.MouseIcon
                Else
                Set Scr.MouseIcon = .LastIconPic
                End If
                Scr.MousePointer = 99
                
                    .LastIcon = CLng(X)
                End With
                Else
                Scr.MousePointer = CLng(X)
                If Err Then MyEr "Bad icon bumber", "Ðñüâëçìá ìå ôïí áñéèìü": Err.Clear: Exit Sub
                With players(GetCode(Scr))
                    .LastIcon = CLng(X)
                End With
                End If
    Else
             MyEr "Missing  filename or icon number", "Ëåßðåé üíïìá áñ÷åßïõ Þ áñéèìüò åéêïíéäßïõ"
    End If
End If
End Sub

Sub ExtCall(ByVal where As Long)
   ''  ExecBaseStack
    Dim old As basetask, oldHere$
  '  On Error Resume Next
    Set old = ExecBaseStack
    SwapStrings oldHere$, here$
    here$ = ExecHere$
    Execute ExecBaseStack, (sbf(where).sb), False
    Set ExecBaseStack = old
    SwapStrings oldHere$, here$
End Sub
Function findAddress(bstack As basetask, A$, r) As Boolean
    Dim s$, w1 As Long
    
        MakeThisSub1 bstack, A$
        If IsLabel(bstack, A$, s$) Then
            If Right$(s$, 1) = "(" Then
                GoTo er1045
            End If
            If GetlocalSub(s$, w1) Then
                ElseIf Not GetSub(s$, w1) Then
                If Not GetSub2(bstack, s$, w1) Then
                    GoTo er1045
                End If
            End If
            r = CCur(w1)
            findAddress = True
        Else
er1045:
        MyErMacro A$, "need a module name", "÷ñåéÜæïìáé üíïìá ôìÞìáôïò"
        End If
End Function

Function ProcOpenImage(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pa$, ss$, frm$, s$, W$, Scr As Object, x1 As Long
Dim aaa() As String
If IsSelectorInUse Then
SelectorInUse
Exit Function
End If
olamazi
 
frm$ = mcd
DialogSetupLang Lang

IsStrExp basestack, rest$, s$
If FastSymbol(rest$, ",") Then If IsStrExp(basestack, rest$, pa$) Then frm$ = pa$
If frm$ <> "" Then If Not isdir(frm$) Then NoSuchFolder: Exit Function
If FastSymbol(rest$, ",") Then If IsStrExp(basestack, rest$, pa$) Then ss$ = pa$
If FastSymbol(rest$, ",") Then If Not IsStrExp(basestack, rest$, W$) Then MissNumExpr:  Exit Function
If TypeOf basestack.Owner Is GuiM2000 Then
Set Scr = basestack.Owner
Else
         If Form1.Visible Then
        Set Scr = Form1
        Else
        Set Scr = Nothing
        End If
End If
If InStr(W$, "|") > 0 Then
If InStr(W$, "(*.") > 0 Then
aaa() = Split(W$, "(*.")
Else
aaa() = Split(W$, "|")
End If
W$ = vbNullString
If UBound(aaa()) > LBound(aaa()) Then
W$ = "|"
For x1 = LBound(aaa()) + 1 To UBound(aaa())
W$ = W$ + UCase(Left$(aaa(x1), InStr(aaa(x1), ")") - 1) + "|")
Next x1
End If
End If
    If OpenImage(basestack, frm$, s$, ss$, W$) Then
    ' push to stack
    If multifileselection Then
    If ReturnListOfFiles <> "" Then
    aaa() = Split(ReturnListOfFiles, "#")
    If UBound(aaa()) > LBound(aaa()) Then

For x1 = UBound(aaa()) To LBound(aaa()) + 1 Step -1
    basestack.soros.PushStr aaa(x1)
Next x1
basestack.soros.PushVal UBound(aaa()) - LBound(aaa())
basestack.soros.PushStr aaa(x1)
End If
Else
    basestack.soros.PushStr ReturnFile
    End If
    Else
    basestack.soros.PushStr ReturnFile
    End If
    Else
    basestack.soros.PushStr ""
    End If

Set Scr = Nothing
ProcOpenImage = True
End Function
Sub MakeMyTitle(s$, Lang As Long)
    If InStr(s$, "(") > 0 Then
    If shortlang Then
    If Lang Then Form1.TEXT1.Title = "F. " + s$ + " F12 " Else Form1.TEXT1.Title = "Ó. " + s$ + " "
    Else
    If Lang Then Form1.TEXT1.Title = "Function " + s$ + " F12 " Else Form1.TEXT1.Title = "ÓõíÜñôçóç " + s$ + " "
    End If
    Else
    If shortlang Then
    If Lang Then Form1.TEXT1.Title = "M. " + s$ + " F12 " Else Form1.TEXT1.Title = "Ô. " + s$ + " "
    Else
    If Lang Then Form1.TEXT1.Title = "Module " + s$ + " F12 " Else Form1.TEXT1.Title = "ÔìÞìá " + s$ + " "
    End If
    End If
End Sub
Sub ProcBackGround(bstack As basetask, rest$, Lang As Long, afier As Boolean)
Dim s$, nd&, p As Variant, I As Long, x1 As Long, X As Double, Y As Double, f As Long, y1 As Long, sX As Double, ss$, pa$, it As Long
Dim Scr As Object, frm$, w3 As Long, ya As Long, AddTwipsTopL As Long, once As Boolean, oldprintFlag As Boolean
Set Scr = bstack.Owner
afier = True
Dim prive As basket
If IsLabelSymbolNew(rest$, "ÌÏÕÓÉÊÇ", "MUSIC", Lang) Then
    If IsStrExp(bstack, rest$, s$) Then
        'OPEN OR REPLACE
        If s$ <> "" Then
            If ExtractType(s$) = vbNullString Then s$ = s$ + ".avi"
            If CFname(s$) = vbNullString Then
                s$ = mcd + s$: If CFname(s$) = vbNullString Then Exit Sub
            Else
                s$ = CFname(s$)
            End If
            If s$ <> "" Then
                MediaBack1.closeMovie
                MediaBack1.FileName = s$
                MediaBack1.openMovie
                MediaBack1.playMovie
            End If
        Else
            afier = False
            Exit Sub
        End If
    Else
        ' CLOSE
        MediaBack1.closeMovie
    End If
Else
    oldprintFlag = bstack.toprinter
    If oldprintFlag Then bstack.toprinter = False
    If Not IsExp(bstack, rest$, p) Then p = 0   '' no change
    If lookOne(rest$, "{") Then
        '' check players(-2)
          
        If players(-1).SZ = 0 Or Not NoBackFormFirstUse Then
            If players(-1).Paper <> Form1.BackColor Or Not NoBackFormFirstUse Then
                Form1.BackColor = players(-1).Paper
            End If
            prive = players(GetCode(Scr))
         
            NoBackFormFirstUse = True
            SetTextBasketBack Form1, prive
            SetText Form1, prive.MineLineSpace, True    'load Players() with first values
            With players(-1)
                .mypentrans = 255
                .curpos = 0
                .currow = 0
                .mysplit = 0
                .osplit = 0
                .Paper = prive.Paper
                .ReportTab = ReportTabWidth
            End With
            With Prefresh(-1)
                .k1 = uintnew(timeGetTime + REFRESHRATE): .RRCOUNTER = 1
            End With
            
        End If
        If p > 0 Then
            SetTextSZ Form1, CSng(p)
        End If
        w3 = bstack.tolayer
        bstack.toback = True
        Set bstack.Owner = Form1
     
        nd& = bstack.addlen
        it = Execute(bstack, rest$, False, True, , True)
        bstack.addlen = nd&
        If it = 2 Then
            If rest$ = "" Then
                rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
            Else
                rest$ = ": Goto " + rest$
                If trace Then WaitShow = 2: TestShowSub = rest$
            End If
            it = 1
        End If
    End If
    MyDoEvents2 bstack.Owner
    Set bstack.Owner = Scr
    bstack.tolayer = w3
    bstack.toback = False
    afier = it = 1
    oldprintFlag = bstack.toprinter
    If oldprintFlag Then bstack.toprinter = False
End If
End Sub
Function pipename(bstackstr As basetask, A$, r$) As Boolean
    Dim p
    If IsExp(bstackstr, A$, p, , True) Then
        If VarType(p) = vbString Then
            r$ = p: r$ = validpipename(r$)
        Else
            If CheckInt64(p) Then r$ = validpipename("M" & CStr(p)) Else r$ = validpipename("M" & LTrim$(str$(p)))
        End If
    ElseIf IsStrExp(bstackstr, A$, r$, False) Then
        r$ = validpipename(r$)
    End If
    pipename = FastSymbol(A$, ")")
End Function

Function ProcCircle(bstack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, sX As Double, sY As Double, X As Double, Y As Double, x1 As Long, p As Variant
Dim Col As Long, Col2 As Long, Scr As Object, isarc As Boolean, trans As Long
ProcCircle = True
par = False
If IsLabelSymbolNew(rest$, "ÃÅÌÉÓÌÁ", "FILL", Lang) Then
If IsExp(bstack, rest$, p) Then X = p
If Not FastSymbol(rest$, ",") Then MissNumExpr: ProcCircle = False: Exit Function
par = True
End If
x1 = 0
Y = 1
Dim errorbit As Boolean
With players(GetCode(bstack.Owner))
Col = .mypen
trans = .mypentrans

If IsExp(bstack, rest$, p) Then x1 = p
If FastSymbol(rest$, ",") Then errorbit = True: If IsExp(bstack, rest$, p) Then Y = p: errorbit = False

If FastSymbol(rest$, ",") Then
errorbit = True
If IsExp(bstack, rest$, p) Then Col = mycolor(CLng(p)): trans = 255: errorbit = False
End If
sX = 0
sY = 0
isarc = False
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sX = p: isarc = True Else MissNumExpr: ProcCircle = False: Exit Function
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sY = p: isarc = True Else MissNumExpr: ProcCircle = False: Exit Function
If Not isarc And errorbit Then MissNumExpr: ProcCircle = False: Exit Function
sX = sX / PI2
sX = (sX - Fix(sX)) * PI2
sY = sY / PI2
sY = (sY - Fix(sY)) * PI2
Set Scr = bstack.Owner
Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH
If x1 <= 0 Or Y < 0.001 Then Exit Function
Dim mGDILines As Boolean
If .IamEmf Then
   mGDILines = Not .NoGDI And Not ((Scr.DrawStyle > 0 And Scr.DrawWidth = 1) And Not Scr.DrawStyle)
ElseIf GDILines Or (trans < 255) Then
    mGDILines = Not .NoGDI
Else
    mGDILines = Scr.DrawWidth > 1

End If

If par Then
    Scr.FillStyle = vbFSSolid
    Scr.FillColor = mycolor(X)
    If sX = sY Then sY = PI2
    If sX = sY Or Abs(sX - sY) + 0.0001 > PI2 Then
        If mGDILines Then
            If Not par Then M2000Pen trans, Col Else M2000Pen 255, Col
            Col2 = .pathcolor
            M2000Pen trans, Col2
            If Y > 1 Then
                If .pathgdi > 0 Then
                    DrawEllipseGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                Else
                     Col2 = mycolor(X)
                     M2000Pen trans, Col2
                    DrawEllipseGdi Scr.Hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                End If
            Else
                If .pathgdi > 0 Then
                    'If .IamEmf Then
                        ' rev 49 ver 10
                        ' Dim St As Long
                       ' St = Scr.DrawStyle
                       ' Scr.DrawStyle = 5
                       ' DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y)
                       ' Scr.DrawStyle = St
                        DrawEllipseGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                    'Else
                        DrawEllipseGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                    'End If
                Else
                    Col2 = mycolor(X)
                    M2000Pen trans, Col2
                    DrawEllipseGdi Scr.Hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3)
                End If
            End If
        Else
            sX = MyMod(sX + Pi * 2, 2 * Pi)
            sY = MyMod(sY + Pi * 2, 2 * Pi)
            If TypeOf Scr Is MetaDc Then
                DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y)
            Else
                Scr.Circle (.XGRAPH, .YGRAPH), x1, Col, , , Y
            End If
        End If
    Else
            If sX = 0 Then sX = 0.0001
            If sY = 0 Then sY = PI2
            If mGDILines Then
            ' revision 30, version 9.3 fixed
            If Not par Then M2000Pen trans, Col Else M2000Pen 255, Col
            Col2 = .pathcolor
            M2000Pen trans, Col2
            If Y > 1 Then
            If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                Else
                Col2 = mycolor(X)
                    M2000Pen trans, Col2
                
                    DrawArcPieGdi Scr.Hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3), -sX, -sY
                End If
            Else
                If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                Else
                    Col2 = mycolor(X)
                    M2000Pen trans, Col2
                    DrawArcPieGdi Scr.Hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                End If
            End If
        Else
            sX = MyMod(sX + Pi * 2, 2 * Pi)
            sY = MyMod(sY + Pi * 2, 2 * Pi)
            If Round(sY, 13) = Round(Pi / 2, 13) Then sY = sY - 1 / (Abs(x1) / 8#)
                If TypeOf Scr Is MetaDc Then
                    DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y), (-sX), (-sY)
                Else
                    Scr.Circle (.XGRAPH, .YGRAPH), x1, Col, -sX, -sY, Y
                End If
            End If
        End If
        Scr.FillStyle = vbFSTransparent
    Else
        Scr.FillStyle = vbFSTransparent
        If mGDILines Then
            If Not par Then M2000Pen trans, Col Else M2000Pen 255, Col
            If .pathgdi > 0 Then
                Col2 = .pathcolor
                M2000Pen trans, Col2
            Else
                Col2 = 0
            End If
            If sX = sY Or Abs(sX - sY) + 0.0001 > PI2 Then
            If Y > 1 Then
            If .pathgdi > 0 Then
                    DrawEllipseGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                Else
                    DrawEllipseGdi Scr.Hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                End If
            Else
                If .pathgdi > 0 Then
                    DrawEllipseGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                Else
                    DrawEllipseGdi Scr.Hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3)
                End If
            End If
        Else
            If Y > 1 Then
                If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3), -sX, -sY
                Else
                    DrawArcPieGdi Scr.Hdc, Col, Col2, 1, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3), -sX, -sY
                End If
            Else
                If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.Hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                Else
                    DrawArcPieGdi Scr.Hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                End If
            End If
        End If
    Else
        sX = MyMod(sX + Pi * 2, 2 * Pi)
        sY = MyMod(sY + Pi * 2, 2 * Pi)
        If Round(sY, 13) = Round(Pi / 2, 13) Then sY = sY - 1 / (Abs(x1) / 8#)
        If TypeOf Scr Is MetaDc Then
            DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y), (sX), (sY)
        Else
            Scr.Circle (.XGRAPH, .YGRAPH), x1, Col, sX, sY, Y
        End If
    End If
End If
End With
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing

End Function

Function ProcFLOODFILL(bstack As basetask, rest$, Lang As Long) As Boolean
Dim x1 As Long, y1 As Long, Col As Long, p As Variant, par As Boolean
With players(GetCode(bstack.Owner))
par = IsLabelSymbolNew(rest$, "×ÑÙÌÁ", "COLOR", Lang)
x1 = .XGRAPH
y1 = .YGRAPH
Col = .mypen
If IsExp(bstack, rest$, p) Then x1 = CLng(p)
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = CLng(p)
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then Col = CLng(p) Else MissNumExpr: Exit Function
Ffill bstack.Owner, (x1), (y1), Col, par
End With
MyDoEvents1 bstack.Owner
ProcFLOODFILL = True
End Function
Function ProcFill(bstack As basetask, rest$) As Boolean
Dim prive As Long, X As Double, p As Variant, Y As Double, x1 As Long, y1 As Long, par As Boolean, Col As Long
Dim Scr As Object, ss$
Dim mm As MetaDc
Set Scr = bstack.Owner
prive = GetCode(Scr)
With players(prive)
If FastSymbol(rest$, "@") Then par = True
x1 = 0
y1 = 1
Col = players(prive).mypen
If IsExp(bstack, rest$, p) Then x1 = p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p

Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH
If par Then

'*****************
Y = 5
If FastSymbol(rest$, ",") Then If Not IsExp(bstack, rest$, Y) Then Y = 5
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, X) Then
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, p) Then
MyFill Scr, (x1), (y1), (Y), (X), (p)
Else
    MissNumExpr
    Exit Function
End If
Else
MyFill Scr, (x1), (y1), (Y), (X)
End If
ElseIf IsStrExp(bstack, rest$, ss$) Then
MyFill Scr, (x1), (y1), (Y), ss$
Else
MyFill Scr, (x1), (y1), 5, "?"
End If
Else
MyFill Scr, (x1), (y1), 6, 0
End If

'*******************
Else
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then Col = p Else MissNumExpr: Exit Function
If FastSymbol(rest$, ",") Then 'ok
par = False
    If Not IsExp(bstack, rest$, X) Then
        If Col = 0 Then X = rgb(255, 255, 255) Else X = 0
        Else
        par = True
    End If
    Y = True
    If FastSymbol(rest$, ",") Then 'ok
        If IsExp(bstack, rest$, Y) Then
            Y = Y <> 0
            par = True
        End If
    End If
    p = True
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, p) Then
            p = p <> 0
            par = True
        End If
    End If
    If par Then
    If CBool(p) And Not .NoGDI Then
    If Y Then
    GdiPlusGradient bstack.Owner.Hdc, .XGRAPH / dv15, .YGRAPH / dv15, (x1 + .XGRAPH) / dv15, (y1 + .YGRAPH) / dv15, GDIP_ARGB1(.mypentrans, CLng(mycolor(Col))), GDIP_ARGB1(.mypentrans, CLng(mycolor(X))), -CLng(Y <> 0)
    Else
    GdiPlusGradient bstack.Owner.Hdc, .XGRAPH / dv15, .YGRAPH / dv15, (x1 + .XGRAPH) / dv15, (y1 + .YGRAPH) / dv15, GDIP_ARGB1(.mypentrans, CLng(mycolor(X))), GDIP_ARGB1(.mypentrans, CLng(mycolor(Col))), -CLng(Y <> 0)
    End If
    Else
If .NoGDI And .IamEmf Then
    Set mm = Scr
    mm.FillStyle = vbFSSolid
    mm.FillColor = mycolor(Col)
    p = mm.ForeColor
    mm.ForeColor = mycolor(Col)
    DrawFrameForEmf Scr, .XGRAPH, .YGRAPH, x1 + .XGRAPH, y1 + .YGRAPH
    mm.ForeColor = p
Else

   TwoColorsGradientPart Scr, CBool(p), -CLng(Y <> 0), .XGRAPH, .YGRAPH, x1 + .XGRAPH, y1 + .YGRAPH, mycolor(Col), mycolor(X)
End If
   End If
    .XGRAPH = .XGRAPH + x1
    .YGRAPH = .YGRAPH + y1
    MyRefresh bstack
    'MyDoEvents1 Scr
    Set Scr = Nothing
    ProcFill = True
    Exit Function
    End If
    Set Scr = Nothing
MissNumExpr:  Exit Function
Else
If TypeOf Scr Is MetaDc Then
jump:
    
    Set mm = Scr
    x1 = x1 + .XGRAPH
    y1 = y1 + .YGRAPH
'    mm.Line2 .XGRAPH, .YGRAPH, x1, y1, mycolor(Col), True
    
    mm.FillStyle = vbFSSolid
    mm.FillColor = mycolor(Col)
    p = mm.ForeColor
    mm.ForeColor = mycolor(Col)
    
    DrawFrameForEmf Scr, .XGRAPH, .YGRAPH, x1, y1
    mm.FillStyle = vbFSTransparent
    mm.ForeColor = p
  .XGRAPH = x1
    .YGRAPH = y1
Else
Scr.Line (.XGRAPH, .YGRAPH)-Step(x1 - dv15, y1 - dv15), mycolor(Col), BF
.XGRAPH = Scr.currentX + dv15
.YGRAPH = Scr.currentY + dv15
End If
End If
End If


End With
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing
ProcFill = True
End Function
Function MyCursor(bstack As basetask, rest$) As Boolean
Dim prive As Long, x1 As Long, y1 As Long, p As Variant
prive = GetCode(bstack.Owner)
MyCursor = True
With players(prive)
If FastSymbol(rest$, "!") Then
 .curpos = .XGRAPH \ .Xt
  .currow = (.YGRAPH) \ .Yt '(.Yt + .uMineLineSpace)
ElseIf IsExp(bstack, rest$, p) Then
x1 = CLng(p) Mod 1000 '' Mod (.mx + 1)
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, p) Then
y1 = CLng(p) Mod 1000   ''Mod (.my + 1)
.curpos = x1
.currow = y1

Else
MyCursor = False
End If
Else
.curpos = x1
End If
.lastprint = False
Else
If FastSymbol(rest$, ",") Then
    If IsExp(bstack, rest$, p) Then
    y1 = CLng(p) Mod 1000   ''Mod (.my + 1)
    .currow = y1
    Else
    MyCursor = False
    End If
End If
.lastprint = False
End If
End With
LCTbasketCur bstack.Owner, players(prive)
End Function
Function MyMenu(entrypoint As Long, bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, p As Variant, par As Boolean, x1 As Long, y1 As Long, Col As Long
Dim frm$, it As Long, s$, f As Long
MyMenu = True
If entrypoint = 1 Then GoTo ekei
If bstack.toprinter Then
oxiforPrinter
 MyMenu = False
Exit Function
End If
prive = GetCode(bstack.Owner)
If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
End If
            If IsLabelSymbolNew(rest$, "ÄÅÉÎÅ", "SHOW", Lang) Then
                If Form1.List1.Visible Then
                        If IsStrExp(bstack, rest$, s$) Then
                            p = Form1.List1.Find(s$)
                        ElseIf IsExp(bstack, rest$, p) Then
                            p = p - 1
                        Else
                            SyntaxError
                            MyMenu = False
                        End If
                        If p <> -1 Then
                            If IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then  ' CHANGE MENU ITEM IN AN OPEN MENU
                                If IsStrExp(bstack, rest$, s$) Then
                                    Form1.List1.list(CLng(p)) = s$
                                Else
                                   MissStringExpr
                                  MyMenu = False
                                End If
                            End If
                            If Not FastSymbol(rest$, ";") Then Form1.List1.ShowThis CLng(p + 1) Else Form1.List1.ShowMe2
                        End If
                Else
                        If Form1.List1.listcount > 0 Then  ' YOU CAN OPEN A MENU WITH A START ITEM OTHER THAN 1
                            If IsStrExp(bstack, rest$, s$) Then
                                p = Form1.List1.Find(s$)
                            ElseIf IsExp(bstack, rest$, p) Then
                                p = p - 1
                            Else
                               SyntaxError
                               MyMenu = False
                            End If
                            If p <> -1 Then
                                If IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then  ' CHANGE MENU ITEM IN AN OPEN MENU
                                ' IN A THREAD OR IN A @ VARIANT
                                    If IsStrExp(bstack, rest$, s$) Then
                                        Form1.List1.list(CLng(p)) = s$
                                    Else
                                        MissStringExpr
                                        MyMenu = False
                                    End If
                                Else
                                    If p < Form1.List1.listcount Then Form1.List1.ListIndex = CLng(p)
                                End If
                        End If
                        frm$ = Form1.List1.Tag
                End If
                GoTo ekei
        End If
    ElseIf IsLabelSymbolNew(rest$, "ÐËÁÉÓÉÏ", "FRAME", Lang) Then
            Form1.List1.BorderStyle = 1 - Abs(IsLabelSymbolNew(rest$, "Ï×É", "OFF", Lang))
    ElseIf IsLabelSymbolNew(rest$, "ÂÁØÅ", "FILL", Lang) Then
        If IsExp(bstack, rest$, p) Then
        Form1.List1.CapColor = mycolor(p)
        LEVCOLMENU = 1
        If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, p) Then
                   Form1.List1.BackColor = mycolor(p)
                   LEVCOLMENU = 2
                           If FastSymbol(rest$, ",") Then
                                If IsExp(bstack, rest$, p) Then
                                   Form1.List1.ForeColor = mycolor(p)
                                   LEVCOLMENU = 3
                                   Else
                                   MissNumExpr
                                               MyMenu = False
                                   End If
                        End If
            
                   Else
                   MissNumExpr
                               MyMenu = False
                   End If
            End If
     
        Else
        MissNumExpr
                    MyMenu = False
        End If
        ElseIf IsLabelSymbolNew(rest$, "ÔÉÔËÏÓ", "TITLE", Lang) Then
        If Not IsStrExp(bstack, rest$, s$) Then Exit Function
        If Right$(s$, 2) = vbCrLf Then s$ = Left$(s$, Len(s$) - 2)
        Form1.List1.enabled = Form1.List1.Visible
    
        Form1.List1.HeadLine = s$
        Form1.List1.FloatList = Not IsLabelSymbolNew(rest$, "ÊÑÁÔÇÓÅ", "HOLD", Lang)
        ElseIf IsLabelSymbolNew(rest$, "ÅÐÉËÅÎÅ", "SELECT", Lang) Then
        '' If Form1.List1.LeaveonChoose Then

         Form1.List1.PressSoft

        '' End If
        Else
If FastSymbol(rest$, "@") Then
    par = True
    If Not IsStrExp(bstack, rest$, s$) Then Exit Function
    frm$ = s$
    If FastSymbol(rest$, "!") Then GoTo ekei
    If Not FastSymbol(rest$, ",") Then Exit Function
    
    Else
    par = False
    End If
    If FastSymbol(rest$, "+") Then
    If Not IsStrExp(bstack, rest$, s$) Then Exit Function

    Form1.List1.additemFast s$
       While FastSymbol(rest$, ",")
    If Not IsStrExp(bstack, rest$, s$) Then MyMenu = False: Exit Function
    Form1.List1.additemFast s$
    Wend
   If Form1.List1.LeaveonChoose Then GoTo ekei Else Exit Function
    
    End If
    If Not FastSymbol(rest$, "!") Then
    If Form1.List1.enabled = True Then
    Form1.List1.Visible = False
    If Not par Then Form1.List1.HeadLine = vbNullString
    End If
    If entrypoint = 2 Then GoTo ekei
    Form1.List1.enabled = False
    
    Form1.List1.Clear

    If Not IsStrExp(bstack, rest$, s$) Then
  bstack.Owner.TabStop = False
    Form1.List1.Tag = vbNullString
    Form1.List1.HeadLine = vbNullString: Form1.KeyPreview = True: Exit Function
    End If
    
    
    Form1.List1.additemFast s$
    If TextWidth(bstack.Owner, s$) > f Then f = TextWidth(bstack.Owner, s$)
    While FastSymbol(rest$, ",")
    If Not IsStrExp(bstack, rest$, s$) Then MyMenu = False: Exit Function
    Form1.List1.additemFast s$
    If TextWidth(bstack.Owner, s$) > f Then f = TextWidth(bstack.Owner, s$)
    Wend
    'f = f \ .xt + 1
    Else
ekei:
    it = Form1.List1.listcount
    f = 0
    If it > 0 Then
    With Form1.List1
            
            For it = it - 1 To 0 Step -1
            If TextWidth(bstack.Owner, .list(it)) > f Then f = TextWidth(bstack.Owner, .list(it))
            
            Next
    End With
    End If
    End If
    
    
    it = Form1.List1.listcount
With players(prive)
If .lastprint Then
x1 = (bstack.Owner.currentX + .Xt - dv15) \ .Xt
If x1 < 0 Then x1 = 0
If x1 > .mX Then x1 = .mX - 1
Else
x1 = .curpos

End If
y1 = .currow
If x1 < 0 Then
  x1 = 0
  ElseIf x1 > .mX Then
  x1 = .mX - 1
  Else
  
  ''    GetXYb scr, players(prive), .curpos, .currow
    End If
    f = Int(f / TextWidth(bstack.Owner, "W") + 0.5)
    If it > 0 Then
            If f < 4 Then f = 4  ' 4 chars minimum
            If f > .mX Then f = .mX  ' .mx maximum
            If f + x1 > .mX Then x1 = .mX - f - 1
            If it > .mY \ 2 Then it = .mY \ 2
            If CLng(.mY - y1) < it Then  ' need space above
                 y1 = .currow - it
            End If

            If Not Form1.Visible Then newshow Basestack1: MyDoEvents
            bstack.Owner.Refresh
                If Not Form1.List1.Visible Then
                    If Not bstack.Owner.Visible Then bstack.Owner.Visible
                    If bstack.tolayer Then bstack.Owner.ZOrder 0
                End If
                With Form1.List1
            .enabled = True
            .NoPanRight = False
            .NoFreeMoveUpDown = True
            .FreeMouse = True
            .SingleLineSlide = True
            SetTextBasketBack bstack.Owner, players(prive), True
            .overrideTextHeight = .overrideTextHeight   ' fonttest.TextHeight("fj")
            End With
            Form1.lastitem = 0
    ListChoise bstack, frm$, x1, y1, f + x1, it + y1 - 1
    INK$ = vbNullString
    ''UINK$ = VbNullString
    MINK$ = vbNullString
    End If
    '------------------------
End With

End If
End Function
Function mHex(bstackstr As basetask, A$, r$)
Dim p, LowLong As Long, HighLong As Long, P2 As Integer
Dim chr1$
If IsExp(bstackstr, A$, p, , True) Then

    If VarType(p) = vbString Then
    r$ = p
isstr:
    chr1$ = r$
    r$ = space(LenB(chr1$) * 2)
    If IsSymbol(A$, "!") Then
    HighLong = LenB(chr1$) + 1
    For LowLong = 1 To LenB(chr1$)
        Mid$(r$, LowLong * 2 - 1, 2) = Right$("0" + Hex$(AscB(MidB$(chr1$, HighLong - LowLong, 1))), 2)
    Next LowLong
    Else
    For LowLong = 1 To LenB(chr1$)
        Mid$(r$, LowLong * 2 - 1, 2) = Right$("0" + Hex$(AscB(MidB$(chr1$, LowLong, 1))), 2)
    Next LowLong
    End If
GoTo fin00
    End If
st1:
    If myVarType(p, 20) Then
        P2 = 2
        'CopyMemory LowLong, ByVal VarPtr(p) + 8, 4
        'CopyMemory HighLong, ByVal VarPtr(p) + 12, 4
        'R$ = Right$("00000000" + Hex$(HighLong), 8) + Right$("00000000" + Hex$(LowLong), 8)
        r$ = Hex64$(p)
    ElseIf p > CDec(4294967295#) Then
        If p > maxlonglong Then
        
        Else
            If p > limitlonglong Then
                p = cInt64(p - maxlonglong)
            Else
                p = cInt64((p))
            End If
            GoTo st1
        End If
    ElseIf p < 0 And p > -maxlonglong Then
        p = cInt64((p))
        GoTo st1
    ElseIf p < 0 Then
    
    Else
        P2 = 1
        r$ = PACKLNGUnsign$(p)
    End If

    If LastErNum1 <> 0 Or Len(r$) = 0 Then mHex = False: Overflow: Exit Function
    If FastSymbol(A$, ",") Then
        If Not IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
        MyErMacroStr A$, "missing parameter 1 to 4 (bytes)", "ëåßðåé ðáñÜìåôñïò 1 Ýùò 4"
        mHex = False: Exit Function
        ElseIf p < 1 Or p > 4 * P2 Then
            MyErMacroStr A$, "parameter from 1 to " & (P2 * 4) & " (bytes)", "ðáñÜìåôñïò áðü 1 Ýùò  " & (P2 * 4) & " äõáäéêÜ øçößá (bytes)"
            mHex = False: Exit Function
        Else
            r$ = Right$(r$, p * 2)
        End If
    End If
fin00:
    mHex = True
    If Not FastSymbol(A$, ")") Then mHex = False
ElseIf IsStrExp(bstackstr, A$, r$, False) Then
    GoTo isstr
End If
End Function
Function ProcVersion(bstack As basetask) As Boolean
Dim prive
prive = GetCode(bstack.Owner)
PlainBaSket bstack.Owner, players(prive), CStr(App.Major) & "." & CStr((App.Minor \ 100)) & " (" & CStr(App.Minor Mod 100) & ")"
crNew bstack, players(prive)
ProcVersion = True
End Function
Function ProcSrcoll(bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, p As Variant, dum As Boolean
ProcSrcoll = True
If bstack.toprinter Then
MyEr "No scrolling for printer document", "¼÷é êýëéóç ãéá ôï Ýããñáöï åêôýðùóçò"
ProcSrcoll = False
Else
prive = GetCode(bstack.Owner)
If IsLabelSymbolNew(rest$, "ÊÁÔÙ", "DOWN", Lang) Then
    ScrollDownNew bstack.Owner, players(prive)
ElseIf IsLabelSymbolNew(rest$, "×ÙÑÉÓÌÁ", "SPLIT", Lang) Then
If IsExp(bstack, rest$, p) Then
With players(prive)
    If p < 0 Then p = .mY + p
    If p >= 0 And p < .mY Then .mysplit = p
End With
Else
ProcSrcoll = False
SyntaxError
End If
Else
 dum = IsLabelSymbolNew(rest$, "ÁÍÙ", "UP", Lang)
ScrollUpNew bstack.Owner, players(prive)


End If
End If

End Function

Sub procthreads(Scr As Object, bstack As basetask, rest$, Lang As Long)
If TaskMaster Is Nothing Then Exit Sub
If TaskMaster.QueueCount >= 0 Then

If IsLabelSymbolNew(rest$, "ÓÂÇÓÅ", "ERASE", Lang) Then
TaskMaster.Dispose
bstack.ThrowThreads
Exit Sub
End If
If Lang = 0 Then
        PlainBaSket Scr, players(GetCode(Scr)), "NHMATA ÓÅ ÅÐÅÎÅÑÃÁÓÉÁ:" + str(TaskMaster.QueueCount)
        Else
        PlainBaSket Scr, players(GetCode(Scr)), "THREADS PROCESSING:" + str(TaskMaster.QueueCount)
        End If
        If bstack.ThreadsStr(Lang) <> "" Then
        crNew bstack, players(GetCode(Scr))
        PlainBaSket Scr, players(GetCode(Scr)), bstack.ThreadsStr(Lang)
        End If
Else
        If Lang = 0 Then
        PlainBaSket Scr, players(GetCode(Scr)), "ÔÉÐÏÔÁ ÓÅ ÅÐÅÎÅÑÃÁÓÉÁ"
        Else
        PlainBaSket Scr, players(GetCode(Scr)), "NOTHING PROCESSING"
        End If
End If
crNew bstack, players(GetCode(Scr))
' was mydoevents 2
'MyDoEvents Scr
MyDoEvents2 Scr
Set Scr = Nothing
End Sub


Function ProcPen(basestack As basetask, rest$) As Boolean
Dim Scr As Object, x1 As Long, y1 As Long, p As Variant, ss$, it As Long, nd&, once As Boolean
ProcPen = True
Set Scr = basestack.Owner
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
    If FastSymbol(rest$, "{") Then
        ss$ = block(rest$)
        TraceStore basestack, nd&, rest$, 0
        rest$ = Mid$(rest$, 2)
        
         y1 = GetCode(Scr)
            x1 = players(y1).mypen
           
            players(y1).mypen = CLng(mycolor(p))
            TextColor Scr, players(y1).mypen
            
            Call executeblock(it, basestack, ss$, False, once, , True)
            TraceRestore basestack, nd&
            players(y1).mypen = x1
            TextColor Scr, x1
                If it = 2 Then
                If ss$ = "" Then
                    If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                Else
                    rest$ = ": Goto " + ss$
                    If trace Then WaitShow = 2: TestShowSub = rest$
                End If
                
                        it = 1
                End If
            If it <> 1 Then ProcPen = False: rest$ = ss$ + rest$
        
    Else
    Dim mp As Long
            mp = CLng(mycolor(p))
         With players(GetCode(Scr))
                        p = .mypentrans
            If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                p = Abs(p): If p > 255 Then p = 255
                
                End If
            
            End If
     
       .mypen = mp
       .mypentrans = CLng(p)
       End With
        
        TextColor Scr, mp
    End If
Else
    If FastSymbol(rest$, ",") Then
     If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                p = Abs(p): If p > 255 Then p = 255
                players(GetCode(Scr)).mypentrans = CLng(p)
                ProcPen = True
                Exit Function
         End If
    End If
    ProcPen = False
End If
Set Scr = Nothing
End Function

Sub ProcBold(bstack As basetask, rest$)
Dim p As Variant
If IsExp(bstack, rest$, p) Then
bstack.myBold = (p <> 0)
Else
bstack.myBold = Not bstack.myBold
p = CDbl(bstack.myBold)
End If
players(GetCode(bstack.Owner)).bold = Abs(p <> 0)
bstack.Owner.Font.bold = Abs(p <> 0)

End Sub
Function ProcPoly(bstack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, sX As Double, sY As Double, X As Double, Y As Double, x1 As Integer, p As Variant, f As Long
Dim Col As Long, Scr As Object, trans As Long
ProcPoly = True
trans = 255
Set Scr = bstack.Owner
If IsExp(bstack, rest$, p) Then
Col = mycolor(p)

End If
If Not FastSymbol(rest$, ",") Then SyntaxError: ProcPoly = False: Exit Function
If IsLabelSymbolNew(rest$, "ÃÙÍÉÁ", "ANGLE", Lang) Then par = True
Scr.FillStyle = vbFSSolid
Scr.FillColor = Col
f = 32
ReDim PLG(f)
x1 = 1
With players(GetCode(Scr))
trans = .mypentrans
PLG(0).X = Scr.ScaleX(.XGRAPH, 1, 3)
PLG(0).Y = Scr.ScaleY(.YGRAPH, 1, 3)
Do
If x1 >= f Then f = f * 2: ReDim Preserve PLG(f)
If IsExp(bstack, rest$, p) Then
X = p

If Not FastSymbol(rest$, ",") Then SyntaxError: ProcPoly = False: Set Scr = Nothing: Exit Function
    If IsExp(bstack, rest$, p) Then
        If par Then
      
            sX = X / PI2
            sX = (sX - Fix(sX)) * PI2
            .XGRAPH = .XGRAPH + Cos(sX) * p
            .YGRAPH = .YGRAPH - Sin(sX) * p
        Else
            .XGRAPH = .XGRAPH + CLng(X)
            .YGRAPH = .YGRAPH + CLng(p)
        End If
        PLG(x1).X = Scr.ScaleX(.XGRAPH, 1, 3)
        PLG(x1).Y = Scr.ScaleY(.YGRAPH, 1, 3)
    
    Else
         MissNumExpr
         Set Scr = Nothing
        ProcPoly = False: Exit Function
    End If
Else
MissNumExpr
Set Scr = Nothing
ProcPoly = False: Exit Function
End If

x1 = x1 + 1
Loop Until Not FastSymbol(rest$, ",")
x1 = x1 - 1
PLG(x1) = PLG(0)
Dim mGDILines As Boolean
'If GDILines And Not (scr.DrawWidth < 2 And TypeOf scr Is MetaDc) Then

'End If

'If Not TypeOf scr Is MetaDc Then
' use .IamEmf
    'If GDILines Or .mypentrans < 255 Then
     '   mGDILines = Not .NoGDI
    'Else
     '   mGDILines = scr.DrawStyle <> 5 And scr.DrawWidth > 1
    'End If
    
If .IamEmf Then
   'mGDILines = Not .NoGDI And Not (scr.DrawStyle > 0 And scr.DrawWidth = 1)
   mGDILines = Not .NoGDI And Not ((Scr.DrawStyle > 0 And Scr.DrawWidth = 1) And Not Scr.DrawStyle)
ElseIf GDILines Or (trans < 255) Then
    mGDILines = Not .NoGDI
Else
    mGDILines = Scr.DrawWidth > 1

End If
    
'End If
Dim pencol As Long, bstyle As Long
If .pathfillstyle = 1 And .IamEmf Then mGDILines = False

If mGDILines Then
pencol = .mypen

    If .pathgdi > 0 Then Col = .pathcolor: bstyle = .pathfillstyle Else bstyle = Scr.FillStyle
    M2000Pen trans, Col
 If trans < 255 And bstyle = 5 Then M2000Pen trans, pencol Else M2000Pen 255, pencol
    DrawPolygonGdi Scr.Hdc, pencol, Col, bstyle, Scr.DrawWidth, Scr.DrawStyle, PLG(), CLng(x1 + 1)
    

Else
If Polygon(Scr.Hdc, PLG(0), x1) = 0 Then
    ProcPoly = True: BadGraphic: Set Scr = Nothing: Exit Function
End If
End If
Scr.FillStyle = vbFSTransparent
End With
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing
End Function


Sub DrawFrameForEmf(Scr As Object, ByVal X As Long, ByVal Y As Long, ByVal x1 As Long, ByVal y1 As Long)
Dim PLG(4) As POINTAPI
X = X / dv15
Y = Y / dv15
x1 = x1 / dv15
y1 = y1 / dv15
PLG(0).X = X
PLG(0).Y = Y
PLG(1).X = x1
PLG(1).Y = Y
PLG(2).X = x1
PLG(2).Y = y1
PLG(3).X = X
PLG(3).Y = y1
Polygon Scr.Hdc, PLG(0), 4
End Sub

Function ProcDraw(bstack As basetask, rest$, Lang As Long) As Boolean
Dim Col As Long, x1 As Long, sX As Double, sY As Double, f As Long, y1 As Long
Dim p As Variant, Scr As Object, trans As Long

ProcDraw = True

With players(GetCode(bstack.Owner))
x1 = 0
y1 = 1
Col = .mypen
trans = .mypentrans
If IsLabelSymbolNew(rest$, "ÅÙÓ", "TO", Lang) Then
If IsExp(bstack, rest$, p) Then x1 = p Else x1 = .XGRAPH
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, p) Then y1 = p Else y1 = .YGRAPH
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, p) Then
            Col = mycolor(p)
            If FastSymbol(rest$, ",") Then
                If IsExp(bstack, rest$, p) Then
                    p = Abs(p): If p > 255 Then p = 255
                    trans = p
                Else
                    ProcDraw = False: Exit Function
                End If
            End If
        Else
            ProcDraw = False: Exit Function
        End If
    End If
Else
 y1 = .YGRAPH
End If

Set Scr = bstack.Owner
Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH

If GDILines And Not (Scr.DrawWidth < 2 And TypeOf Scr Is MetaDc) Then
M2000Pen trans, Col
DrawLineGdi Scr.Hdc, Col, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleX(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Scr.ScaleX(y1, 1, 3)
.XGRAPH = x1
.YGRAPH = y1
Else
If TypeOf Scr Is MetaDc Then
Dim mm As MetaDc
Set mm = Scr
mm.Line2 .XGRAPH, .YGRAPH, x1, y1, mycolor(Col)
.XGRAPH = x1
.YGRAPH = y1
Else
Scr.Line (.XGRAPH, .YGRAPH)-(x1, y1), mycolor(Col)
.XGRAPH = Scr.currentX
.YGRAPH = Scr.currentY

End If

End If
'MyDoEvents1 Scr
MyRefresh bstack
Set Scr = Nothing
Exit Function
ElseIf IsLabelSymbolNew(rest$, "ÃÙÍÉÁ", "ANGLE", Lang) Then
If IsExp(bstack, rest$, p) Then sX = p Else ProcDraw = False: Exit Function
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sY = p Else ProcDraw = False: Exit Function
sX = sX / PI2
sX = (sX - Fix(sX)) * PI2
x1 = Cos(sX) * sY
y1 = -Sin(sX) * sY
Else
If IsExp(bstack, rest$, p) Then x1 = p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p
End If
If FastSymbol(rest$, ",") Then
    If IsExp(bstack, rest$, p) Then
        Col = mycolor(p)
        If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, p) Then
                p = Abs(p): If p > 255 Then p = 255
                trans = p
            Else
                ProcDraw = False: Exit Function
            End If
        End If
    Else
        ProcDraw = False: Exit Function
    End If
End If

Set Scr = bstack.Owner
Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH


If GDILines Or TypeOf Scr Is MetaDc And Not (Scr.DrawWidth = 1 And Scr.DrawStyle > 1 And trans = 255) Then
M2000Pen trans, Col
DrawLineGdi Scr.Hdc, Col, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleX(.YGRAPH, 1, 3), Scr.ScaleX(.XGRAPH + x1, 1, 3), Scr.ScaleX(.YGRAPH + y1, 1, 3)
.XGRAPH = .XGRAPH + x1
.YGRAPH = .YGRAPH + y1
ElseIf TypeOf Scr Is MetaDc Then
x1 = x1 + .XGRAPH
y1 = y1 + .YGRAPH
Set mm = Scr
mm.Line2 .XGRAPH, .YGRAPH, x1, y1, mycolor(Col)
.XGRAPH = x1
.YGRAPH = y1
Else
Scr.Line (.XGRAPH, .YGRAPH)-Step(x1, y1), mycolor(Col)
.XGRAPH = Scr.currentX
.YGRAPH = Scr.currentY
End If
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing
End With

End Function
Function ProcStep(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, sY As Double, sX As Double
ProcStep = True
With players(GetCode(bstack.Owner))
If IsLabelSymbolNew(rest$, "ÃÙÍÉÁ", "ANGLE", Lang) Then
If IsExp(bstack, rest$, p) Then sX = p Else ProcStep = False: MissNumExpr: Exit Function
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sY = p Else ProcStep = False: MissNumExpr: Exit Function
sX = sX / PI2
sX = (sX - Fix(sX)) * PI2
.XGRAPH = .XGRAPH + Cos(sX) * sY
.YGRAPH = .YGRAPH - Sin(sX) * sY
Else
If IsExp(bstack, rest$, p) Then .XGRAPH = .XGRAPH + p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then .YGRAPH = .YGRAPH + p Else ProcStep = False: MissNumExpr: Exit Function
End If
End With


End Function
Function ProcMove(bstack As basetask, rest$) As Boolean
ProcMove = True
Dim p As Variant
With players(GetCode(bstack.Owner))
If FastSymbol(rest$, "!") Then
 .XGRAPH = .curpos * .Xt
 .YGRAPH = .currow * .Yt
ElseIf IsExp(bstack, rest$, p) Then .XGRAPH = p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then .YGRAPH = p Else ProcMove = False: MissNumExpr: Exit Function
End If
End With
End Function
Function VALFUNC(A$, r As Variant) As Boolean
Dim sg As Integer
sg = 1
Dim sng&, ex$, ig$, DE$, I As Long, sg1 As Boolean, j As Integer
If Len(A$) = 0 Then VALFUNC = False: Exit Function
If MaybeIsSymbol2(A$, "#+-", sng&) Then
sng& = sng& - 1
Do While sng& < Len(A$)
sng& = sng& + 1
Select Case Mid$(A$, sng&, 1)
Case "#"
    If Len(A$) > sng& Then
    If MaybeIsSymbolNoSpace(Mid$(A$, sng& + 1, 1), "[0-9A-Fa-f]") Then
    ex$ = "0x00" + Mid$(A$, sng& + 1, 6)
    If Len(ex$) < 10 Then Exit Function
        If IsNumberCheck(ex$, r) Then
        If ex$ <> "" Then
          
             
        Else
            ex$ = Right$("00000000" + Mid$(A$, sng& + 1, 6), 8)
            A$ = Mid$(A$, sng& + 7)
            
           r = -(CDbl(UNPACKLNG(Right$(ex$, 2)) * 65536#) + CDbl(UNPACKLNG(Mid$(ex$, 5, 2)) * 256#) + CDbl(UNPACKLNG(Mid$(ex$, 3, 2))))
            sg = 1
            If MaybeIsSymbolNoSpace(Mid$(A$, 1, 1), "[0-9]") Then
            MyEr "Too many digits", "ÐïëëÜ øçößá"
            VALFUNC = False
            Else
            VALFUNC = True
            End If
            Exit Function
        End If
        End If
        Else
        
    End If
    Else

    '' out
    End If
    Exit Function
Case " ", "+", ChrW(160)
Case "-"
sg = -sg
Case Else
Exit Do
End Select
Loop
End If
If sng& > 1 Then Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
    If MaybeIsSymbol3(A$, ".", sng&) Then
    If Len(A$) = sng& Then
        ig$ = "0"
        DE$ = "."
        GoTo conthere
    ElseIf Mid$(A$, sng& + 1, 1) Like "[0-9]" Then
        ig$ = "0"
        DE$ = "."
        GoTo conthere
    Else
        Exit Function
    End If
    
ElseIf Len(A$) < sng& Then
    VALFUNC = False: Exit Function
Else

I = AscW(Mid$(A$, sng&, 1))
If I < 10 Or I > 63 Then
    Exit Function
Else
    I = 0
    j = 0
    If Mid$(A$, sng&, 1) = "0" Then
        If LCase(Mid$(A$, sng& + 1, 1)) Like "[x÷]" Then
                    
jumphere1:
                    sng& = sng& + 2
                    Do While sng& <= Len(A$)
                        Select Case Mid$(A$, sng&, 1)
                        Case "A" To "F", "a" To "f", "0" To "9"
                            I = I + 1
                        Case "_"
                            If I = 0 Then Exit Do
                            I = I + 1
                            j = j + 1
                        Case Else
                            Exit Do
                        End Select
                        
                    sng& = sng& + 1
                    Loop
                    If I - j > 16 Then
                        OverflowValue
                        VALFUNC = False
                        Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                        Exit Function
                    End If
                    If Mid$(A$, sng&, 1) = "%" Then
                        If I - j > 4 Then
                            OverflowValue vbInteger
                            VALFUNC = False
                            Exit Function
                        End If
                        If j > 0 Then
                            r = CInt("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                        Else
                            r = CInt("&H" + Mid$(A$, sng - I, I))
                        End If
                        sng& = sng& + 1
                    Else
                        If I - j > 8 Then ' maybe long long or decimal
                            If Mid$(A$, sng&, 2) = "&&" Then
                                If I - j > 16 Then
                                    OverflowValue 20
                                    VALFUNC = False
                                    Exit Function
                                End If
                                If j > 0 Then
                                    r = cInt64("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                                Else
                                    r = cInt64("&H" + Mid$(A$, sng - I, I))
                                End If
                                sng& = sng& + 2
                            ElseIf Mid$(A$, sng&, 1) = "&" Then
                                OverflowValue vbLong
                                VALFUNC = False
                                Exit Function
                            Else
                                If j > 0 Then
                                    r = CDec(cInt64("&H" + Replace$(Mid$(A$, sng - I, I), "_", "")))
                                Else
                                    r = CDec(cInt64("&H" + Mid$(A$, sng - I, I)))
                                End If
                                If r < 0 Then r = r + maxlonglong
                                If Mid$(A$, sng&, 1) = "@" Then
                                   sng& = sng& + 1
                                End If
                            End If
                        ElseIf Mid$(A$, sng&, 2) = "&&" Then
                            If j > 0 Then
                                r = cInt64("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                            Else
                                r = cInt64("&H" + Mid$(A$, sng - I, I))
                            End If
                            sng& = sng& + 2
                        ElseIf Mid$(A$, sng&, 1) = "&" Then
                            If j > 0 Then
                                r = CLng("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                            Else
                                r = CLng("&H" + Mid$(A$, sng - I, I))
                            End If
                            sng& = sng& + 1
                        ElseIf Mid$(A$, sng&, 1) = "@" Then
                            If j > 0 Then
                                r = CDec(HexToUnsigned(Replace$(Mid$(A$, sng - I, I), "_", "")))
                            Else
                                r = CDec(HexToUnsigned(Mid$(A$, sng - I, I)))
                            End If
                            sng& = sng& + 1
                        Else
                         If j > 0 Then
                            r = HexToUnsigned(Replace$(Mid$(A$, sng - I, I), "_", ""))
                            Else
                            r = HexToUnsigned(Mid$(A$, sng - I, I))
                            End If
                            VALFUNC = True
                        End If
                    End If
                     Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                     VALFUNC = True
                    Exit Function
                End If
    Else
        If Mid$(A$, sng&, 1) = "&" Then
            If LCase$(Mid$(A$, sng& + 1, 1)) = "h" Then GoTo jumphere1
            VALFUNC = False
            Exit Function
        ElseIf Not Mid$(A$, sng&, 1) Like "[1-9]" Then
            VALFUNC = False
            Exit Function
        End If
    End If
    Do While sng& <= Len(A$)
        Select Case Mid$(A$, sng&, 1)
        Case "0" To "9"
        I = I + 1
        Case "."
            ig$ = Mid$(A$, sng& - I, I)
            DE$ = "."
            Exit Do
        Case Else
            ig$ = Mid$(A$, sng& - I, I)
        Exit Do
        End Select
        
       sng& = sng& + 1
    Loop
    If Len(ig$) = 0 Then ig$ = Mid$(A$, sng& - I, I)
End If
    If Len(DE$) = 0 Then
    If Len(A$) > sng& Then
    If InStr("EeÅå", Mid$(A$, sng&, 1)) > 0 Then
    If InStr("1234567890+-", Mid$(A$, sng& + 1, 1)) > 0 Then
        DE$ = "."
        GoTo cont123
    End If
    End If
    End If
   Else
conthere:
      sng& = sng& + 1
cont123:
      I = 0
        Do While sng& <= Len(A$)
       
        Select Case Mid$(A$, sng&, 1)
        Case "0" To "9"
            I = I + 1
        Case "E", "e", "Å", "å"
         If ex$ = vbNullString Then
            sg1 = True
            ex$ = "E"
             Exit Do
        End If
        Case Else
        Exit Do
        End Select
         sng& = sng& + 1
        Loop
        If I > 0 Then DE$ = DE$ + Mid$(A$, sng& - I, I)
        If sg1 Then
        sng& = sng& + 1
         I = 0
         Do While sng& <= Len(A$)
         Select Case Mid$(A$, sng&, 1)
         Case "0" To "9"
             I = I + 1
         Case "+", "-"
            If Len(ex$) = 1 Then
               I = I + 1
            Else
                Exit Do
            End If
         Case Else
             Exit Do
         End Select
          sng& = sng& + 1
         Loop
         If I > 0 Then ex$ = ex$ + Mid$(A$, sng& - I, I)
         sng = sng - Len(ex$)
        End If
    End If

    If ex$ <> "" Then
                If Len(ex$) < 3 Then
                If ex$ = "E" Then
                ex$ = "0"
                ElseIf ex$ = "E-" Or ex$ = "E+" Then
                sng = sng + 2
                End If
                End If
                    
            
                If val(Mid$(ex$, 2)) > 308 Or val(Mid$(ex$, 2)) < -324 Then
                    r = 0 ' val(ig$ & DE$)
                    sng = sng - Len(ex$)
                    ex$ = vbNullString
                    MyEr "Exponet Overflow", "Õðåñ÷åßëéóç ÅêèÝôç"
                    Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                    VALFUNC = False
                    Exit Function
                    Else
                    sng = sng + Len(ex$)
                    If sng <= Len(A$) Then
                        If Asc(Mid$(A$, sng, 1)) = 126 Then
                        Mid$(A$, sng, 1) = " "
                        If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                        On Error Resume Next
                        r = CSng(ig$ + DE$ + ex$)
                            If Err.Number = 6 Then
                                Err.Clear
                                Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                                OverflowValue vbSingle
                                Exit Function
                                Err.Clear
                                Exit Function
                            End If
                        Else
                        On Error Resume Next
                            r = val(ig$ + DE$ + ex$)
                            If Err.Number = 6 Then
                                Err.Clear
                                Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                                OverflowValue vbDouble
                                Exit Function
                            End If
                        End If
                    Else
                        On Error Resume Next
                        r = val(ig$ + DE$ + ex$)
                        If Err.Number = 6 Then
                        Err.Clear
                        Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                        OverflowValue vbDouble
                        Exit Function
                        End If
                    End If
                    On Error GoTo 0
                    
                 
                End If
        Else
        If sg < 0 Then ig$ = "-" + ig$: sg = 1
            If sng <= Len(A$) Then
            
            On Error Resume Next
            Select Case Asc(Mid$(A$, sng, 1))
            Case 64
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                
                r = CDec(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                OverflowValue vbDecimal
                'If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                'R = val(ig$ + DE$)
                End If
            Case 35
            Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CCur(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                OverflowValue vbCurrency
                'If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                'R = val(ig$ + DE$)
                End If
            Case 38
                If Mid$(A$, sng + 1, 1) = "&" Then
                        Mid$(A$, sng, 2) = "  "
                        r = cInt64(ig$)
                        If Err.Number = 6 Then
                            Err.Clear
                            OverflowValue 20
                        End If
                Else
                    Mid$(A$, sng, 1) = " "
                    r = CLng(ig$)
                    If Err.Number = 6 Then
                        Err.Clear
                        OverflowValue vbLong
                    End If
                End If
           Case 37
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CInt(ig$)
                If Err.Number = 6 Then
                Err.Clear
                'R = val(ig$)
                OverflowValue vbInteger
                End If
           Case 126
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CSng(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                OverflowValue vbSingle
                'If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                'R = val(ig$ + DE$)
                End If
            Case Else
                r = val(ig$ + DE$)
            End Select
            Else
            r = val(ig$ + DE$)
            End If
            End If

            If Err.Number = 6 Then
                If Len(ex$) > 2 Then
                    ex$ = Left$(ex$, Len(ex$) - 1)
                    sng = sng - 1
                    Err.Clear
                    r = val(ig$ + DE$ + ex$)
                    If Err.Number = 6 Then
                        sng = sng - Len(ex$)
                        If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                         r = val(ig$ + DE$)
                    End If
                End If
                
           ErrInExponet A$
           Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
          VALFUNC = False
            Exit Function
            End If
        End If
      Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
  
    VALFUNC = True


End Function

Function ExecuteGroupStruct(bstack As basetask, ohere$, vvv As Long, rest$, ByVal addlen As Long, Lang As Long, Optional Glob As Boolean = False, Optional alocal As Boolean = False) As Long
Dim W$, w1$, p As Variant, h, v As Long, s$, ss$, b$, I As Long, lcl As Boolean, j As Long, nm$, x1 As Long, y1 As Long, frm$, skip As Boolean
Dim uni As Boolean, prv As Boolean, stripstack1 As New basetask, hlp As String, vl As String, NoRec As Boolean, Final As Boolean
Dim highpriority As Boolean, ThisGroup As Group, RightAssociative As Boolean, removebypass As Boolean, C As Constant
Dim usehandler As mHandler, usehandler2 As mHandler, it As Long, classfun As Boolean, zeroitem As Object

Const TT$ = "=-+*/<!,{" + vbCr
If Trim$(rest$) = vbNullString Then
If VarTypeName$(var(vvv)) = mGroup Then
Else
    var(vvv) = 0&
    End If
    ExecuteGroupStruct = 1
    Exit Function
End If
Set ThisGroup = var(vvv)
Dim myobject As Object
Dim OvarnameLen As Long, OarrnameLen As Long
Dim f$
Dim pppp As mArray
ThisGroup.IamCleared = False
bstack.CopyStrip stripstack1
OvarnameLen = varhash.count + 1 ' new way
OarrnameLen = OvarnameLen
If Len(here$) > 0 Then
 ThisGroup.Patch = here$ + "." + ohere$
Else
 ThisGroup.Patch = ohere$
End If
If bstack.GroupName <> "" Then
    bstack.GroupName = bstack.GroupName + ThisGroup.GroupName '' & "."
Else
    bstack.GroupName = ThisGroup.GroupName ''& "."
End If

ExecuteGroupStruct = 1
Do
there100:
    nm$ = vbNullString: frm$ = vbNullString: hlp$ = vbNullString
    ClearSpace rest$
there12345:
    If NocharsInLine(rest$) Then Exit Do
    v = IsLabelA(here$, rest$, W$)
    If v = 0 Then Exit Do
    Select Case W$
    Case "ÔÅËÉÊÏ", "ÔÅËÉÊÇ", "FINAL"
        I = v
        ss$ = W$
        v = IsLabelA(here$, rest$, W$)
        If prv Then
        W$ = ChrW(&HFFBF) + W$
        End If
        If v <> 0 Then Final = True: GoTo VarOnly
        v = I
        W$ = ss$
        I = 0
        GoTo VarOnly
    Case "PROPERTY", "ÉÄÉÏÔÇÔÁ"
        I = IsLabelA("", rest$, W$)
        If I = 1 Or I = 3 Then
            If I = 1 Then
                hlp = "[" + W$ + "]"
                If Lang = 1 Then
                    vl = "value"
                Else
                    vl = "áîßá"
                End If
            Else
                hlp = "[" + Left$(W$, Len(W$) - 1) + "]$"
                If Lang = 1 Then
                    vl = "value$"
                Else
                    vl = "áîßá$"
                End If
            End If
            f$ = vbNullString
            If FastSymbol(rest$, "{") Then
                ClearSpace rest$
                nm$ = block(rest$)
                If IsLabelA1("", nm$, ss$) Then
                    ss$ = myUcase(ss$)
                    I = Len(nm$)
                    If FastSymbol(nm$, "(") Then
                        If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", I) Then
                            MyEr "Array with same name", "Ðßíáêáò ìå ßäéï üíïìá"
                            ExecuteGroupStruct = 0
                            Exit Function
                        End If
                        frm$ = BlockParam(nm$)
                        If FastOperator(nm$, "{", Len(frm$) + 2) Then
                            nm$ = "{" + Mid$(nm$, Len(frm$) + 2)
                        Else
                            GoTo errDef
                        End If
                        If frm$ = vbNullString Then frm$ = " "
                    End If
                    Select Case ss$
                    Case "VALUE", "ÁÎÉÁ"
                        If FastSymbol(nm$, "{") Then
                            If lookOne(nm$, "}") Then
                                f$ = f$ + ss$ + " (" + frm$ + "){link parent " + hlp + " to " + W$ + ": =" + W$ + "}" + vbCrLf
                            Else
                                f$ = f$ + ss$ + " (" + frm$ + ") {link parent " + hlp + " to " + W$ + ": " + vl + "=" + W$ + vbCrLf + block$(nm$) + vbCrLf + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "value {link parent " + hlp + " to " + W$ + ":=" + W$ + "}" + vbCrLf
                        End If
                    Case "SET", "ÈÅÓÅ"
                        If FastSymbol(nm$, "{") Then
                            If frm$ <> "" Then
                                If frm$ = " " Then
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + W$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + W$ + "=" + vl + "}" + vbCrLf
                                Else
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + W$ + ": read " + vl + "," + frm$ + vbCrLf + block$(nm$) + vbCrLf + W$ + "=" + vl + "}" + vbCrLf
                                End If
                            Else
                                f$ = f$ + ss$ + " {link parent " + hlp + " to " + W$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + W$ + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "set {link parent " + hlp + " to " + W$ + ": read " + W$ + "}" + vbCrLf
                        End If
                    Case Else
                        rest$ = nm$ + Right$(rest$, I)
                        MyEr "unkown command, use set or value", "Üãíùóôç åíôïëÞ, ÷ñçóéìïðïßçóå èÝóå Þ áîßá"
                        Exit Function
                    End Select
                    frm$ = vbNullString
                ElseIf IsSymbol(nm$, ",") Then
                    f$ = f$ + "value {link parent " + hlp + " to " + W$ + ":=" + W$ + "}" + vbCrLf
                End If
                ClearSpace nm$
                I = FastSymbol(nm$, ",")
                ClearSpace nm$
                If IsLabelA1("", nm$, ss$) Then
                    ss$ = myUcase(ss$)
                    I = Len(nm$)
                    If FastSymbol(nm$, "(") Then
                       If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", I) Then
                           MyEr "Array with same name", "Ðßíáêáò ìå ßäéï üíïìá"
                           ExecuteGroupStruct = 0
                           Exit Function
                        End If
                        frm$ = BlockParam(nm$)
                        If FastOperator(nm$, "{", Len(frm$) + 2) Then
                            nm$ = "{" + Mid$(nm$, Len(frm$) + 2)
                        Else
                            GoTo errDef
                        End If
                        If frm$ = vbNullString Then frm$ = " "
                    End If
                    Select Case ss$
                    Case "VALUE", "ÁÎÉÁ"
                        If FastSymbol(nm$, "{") Then
                            If lookOne(nm$, "}") Then
                                f$ = f$ + ss$ + " (" + frm$ + "){link parent " + hlp + " to " + W$ + ": =" + W$ + "}" + vbCrLf
                            Else
                                f$ = f$ + ss$ + " (" + frm$ + "){link parent " + hlp + " to " + W$ + ": " + vl + "=" + W$ + vbCrLf + block$(nm$) + vbCrLf + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "value {link parent " + hlp + " to " + W$ + ":=" + W$ + "}" + vbCrLf
                        End If
                    Case "SET", "ÈÅÓÅ"
                        If FastSymbol(nm$, "{") Then
                            If frm$ <> "" Then
                                If frm$ = " " Then
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + W$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + W$ + "=" + vl + "}" + vbCrLf
                                Else
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + W$ + ": read " + vl + "," + frm$ + vbCrLf + block$(nm$) + vbCrLf + W$ + "=" + vl + "}" + vbCrLf
                                End If
                            Else
                                f$ = f$ + ss$ + " {link parent " + hlp + " to " + W$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + W$ + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "set {link parent " + hlp + " to " + W$ + ": read " + W$ + "}" + vbCrLf
                        End If
                    Case Else
                        rest$ = nm$ + rest$
                        MyEr "unkown command, use set or value", "Üãíùóôç åíôïëÞ, ÷ñçóéìïðïßçóå èÝóå Þ áîßá"
                        Exit Function
                    End Select
                    ClearSpace nm$
                    If IsLabelA1("", nm$, ss$) Then
                        rest$ = nm$ + Mid$(rest$, I)
                        MyEr "unkown command, use set or value", "Üãíùóôç åíôïëÞ, ÷ñçóéìïðïßçóå èÝóå Þ áîßá"
                        Exit Function
                    End If
                ElseIf I Then
                    f$ = f$ + "set {link parent " + hlp + " to " + W$ + ": read " + W$ + "}" + vbCrLf
                End If
                FastSymbol rest$, "}"
                If Right$(hlp, 1) <> "$" Then hlp = "variant " + hlp
                If FastSymbol(rest$, "=") Then
                    x1 = 1
                    aheadstatus rest$, , x1
                    frm$ = Mid$(rest$, 1, x1 - 1)
                    rest$ = Mid$(rest$, x1)
                    If frm$ = vbNullString Then MyEr "Nothing to assign", "Ôßðïôá ãéá íá ÈÝóù": Exit Function
                    If prv Then
                        f$ = vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    End If
                Else
                    If prv Then
                        f$ = vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    End If
                End If
                If prv Then
                    rest$ = f$ + vbCrLf + "}" + vbCrLf + "private:" + vbCrLf + rest$
                Else
                    rest$ = f$ + vbCrLf + "}" + vbCrLf + rest$
                End If
            Else
               ' If Right$(hlp, 1) <> "$" Then hlp = "variant " + hlp
                If FastSymbol(rest$, "=") Then
                    x1 = 1
                    aheadstatus rest$, , x1
                    frm$ = Mid$(rest$, 1, x1 - 1)
                    rest$ = Mid$(rest$, x1)
                    If frm$ = vbNullString Then MyEr "Nothing to assign", "Ôßðïôá ãéá íá ÈÝóù": Exit Function
                    If Right$(hlp, 1) <> "$" Then
                    If prv Then
                        f$ = vbCrLf + "variant " + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + "variant " + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    End If
                    Else
                    If prv Then
                        f$ = vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    End If
                    End If
                Else
                If Right$(hlp, 1) <> "$" Then
                    If prv Then
                        f$ = vbCrLf + "variant " + hlp + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + "variant " + hlp + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    End If
                Else
                      If prv Then
                        f$ = vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + W$ + "{" + vbCrLf + f$
                    End If
                End If
                End If
                f$ = f$ + "value {link parent " + hlp + " to " + W$ + ":=" + W$ + "}" + vbCrLf
                f$ = f$ + "set {link parent " + hlp + " to " + W$ + ": read " + W$ + "}" + vbCrLf
                If prv Then
                    rest$ = f$ + vbCrLf + "}" + vbCrLf + "private:" + vbCrLf + rest$
                Else
                    rest$ = f$ + vbCrLf + "}" + vbCrLf + rest$
                End If
            End If
            hlp = vbNullString
            GoTo there100
        Else
            MyEr "No name for property", "×ùñßò üíïìá éäéüôçôáò"
            ExecuteGroupStruct = 0
            Exit Function
        End If
    Case "DECLARE", "ÏÑÉÓÅ"  'OBJECT
        bstack.priveflag = prv
        bstack.uniflag = uni
        bstack.finalFlag = Final
        If Not MyDeclare(bstack, rest$, Lang, True, prv) Then   ' stripstack1
            bstack.priveflag = False
            bstack.uniflag = False
            bstack.finalFlag = False
            ExecuteGroupStruct = 0
            Exit Function
        End If
            stripstack1.priveflag = False
            stripstack1.uniflag = False
            stripstack1.finalFlag = False
         '   LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, False 'uni
    Case "METHOD", "ÌÅÈÏÄÏÓ"
    bstack.priveflag = prv
    bstack.uniflag = uni
    bstack.finalFlag = Final
    If Not MyMethod(bstack, rest$, Lang, True, prv) Then
        bstack.priveflag = False
        bstack.uniflag = False
        bstack.finalFlag = False
        ExecuteGroupStruct = 0
        Exit Function
    End If
    stripstack1.priveflag = False
    stripstack1.uniflag = False
    stripstack1.finalFlag = False

    Case "SET", "ÈÅÓÅ"
        Final = IsLabelSymbolNew(rest$, "ÔÅËÉÊÏ", "FINAL", Lang)
        If FastSymbol(rest$, "(") Then
            If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", I) Then
                MyEr "Array with same name", "Ðßíáêáò ìå ßäéï üíïìá"
                ExecuteGroupStruct = 0
                Exit Function
            End If
            ss$ = BlockParam(rest$)
            ThisGroup.HasParametersSet = True
            If FastOperator(rest$, "{", Len(ss$) + 2) Then
                If ss$ <> "" Then
                    rest$ = "{Read " + ss$ + ":If Stack.Size>1 then Shift Stack.Size" + vbCrLf + Mid$(rest$, Len(ss$) + 2)
                Else
                    rest$ = "{If Stack.Size>1 then Shift Stack.Size " + vbCrLf + Mid$(rest$, 2)
                End If
            Else
                GoTo errDef
            End If
        End If
        f$ = ChrW(&H1FFF) + ":="
        x1 = 1
        ThisGroup.HasSet = True
        W$ = "&"
        GoTo funcoperator
    Case "VALUE", "ÁÎÉÁ"
        Final = IsLabelSymbolNew(rest$, "ÔÅËÉÊÇ", "FINAL", Lang)
        If Final Then
            If FastSymbol(rest$, "(") Then GoTo contthere1
            GoTo contthere22
        End If
        If lookOne(rest$, "=") Then
            GoTo conthereplease
        ElseIf FastSymbol(rest$, "(") Then
contthere1:
            If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", I) Then
                MyEr "Array with same name", "Ðßíáêáò ìå ßäéï üíïìá"
                ExecuteGroupStruct = 0
                Exit Function
            End If
            ss$ = BlockParam(rest$)
            ThisGroup.HasParameters = True
            If FastOperator(rest$, "{", Len(ss$) + 2) Then
                If ss$ <> "" Then
                    rest$ = "{Read " + ss$ + vbCrLf + Mid$(rest$, Len(ss$) + 2)
                Else
                    Mid$(rest$, 1, 1) = "{"
                End If
            Else
errDef:
                MyEr "Missing Definition in { }", "Ëåßðåé ïñéóìüò óå { }"
                ExecuteGroupStruct = 0
                Exit Function
            End If
        End If
contthere22:
        If ThisGroup.HasStrValue Then
            f$ = ChrW(&H1FFF) + "$"
        Else
            f$ = ChrW(&H1FFF) + ChrW(&H1FFD)
        End If
        x1 = 1
        ThisGroup.HasValue = True
        W$ = "&"
        GoTo funcoperator
    Case "REMOVE", "ÄÉÁÃÑÁÖÇ"
        x1 = 1
        W$ = vbNullString
        f$ = ChrW(&H1FFF) + "_%"
        Final = True
        removebypass = True
        highpriority = False
        ThisGroup.HasRemove = True
        GoTo funcoperator
    Case "OPERATOR", "ÔÅËÅÓÔÇÓ"
        If prv Then
            MyEr "Private operator not allowed", "Éäéùôéêüò ôåëåóôÞò äåí åðéôñÝðåôáé"
            ExecuteGroupStruct = 0
            Exit Function
        End If
        Final = IsLabelSymbolNew(rest$, "ÔÅËÉÊÏÓ", "FINAL", Lang)
        x1 = 1
        If Not ISSTRINGA(rest$, f$) Then
            If IsLabelSymbolNew(rest$, "ÕØÇËÏÓ", "HIGH", Lang) Then
                highpriority = True
                If Not ISSTRINGA(rest$, f$) Then GoTo error0001
                If Len(f$) > 2 Or Len(f$) = 0 Or Not MaybeIsSymbol(f$, "/*-+=~^&|<>") Then GoTo error0001
            ElseIf IsLabelSymbolNew(rest$, "ÄÅÎÉÏÓ", "RIGHT", Lang) Then
                RightAssociative = True
                If Not ISSTRINGA(rest$, f$) Then GoTo error0001
                If Len(f$) > 2 Or Len(f$) = 0 Or Not MaybeIsSymbol(f$, "/*-+=~^&|<>") Then GoTo error0001
            ElseIf IsLabelSymbolNew(rest$, "ÌÏÍÁÄÉÁÉÏÓ", "UNARY", Lang) Then
                f$ = "-:"
                ThisGroup.HasUnary = True
            ElseIf Not ISSTRINGA(rest$, f$) Then
error0001:
                MyEr "No Proper Symbol for operator, use string literal", "Äåí âñÝèçêå óýìâïëï ÷åéñéóôÞ, ÷ñçóéìïðïßçóå áëöáñéèìçôéêü ìå äéðëÜ åéóáãùãéêÜ"
                ExecuteGroupStruct = 0
                Exit Function
            End If
        End If
        W$ = "&"
        If highpriority Then
            If InStr(ThisGroup.highpriorityoper, "[" + f$ + "]") = 0 Then ThisGroup.highpriorityoper = MergeOperators(ThisGroup.highpriorityoper, "[" + f$ + "]")
        ElseIf RightAssociative Then
            If InStr(ThisGroup.highpriorityoper, "[R" + f$ + "]") = 0 Then ThisGroup.highpriorityoper = MergeOperators(ThisGroup.highpriorityoper, "[R" + f$ + "]")
        End If
        f$ = ChrW(&H1FFF) + f$
        highpriority = False
        GoTo funcoperator
    Case "UNIQUE", "ÌÏÍÁÄÉÊÏ"
        If Not IsOperator(rest$, ":") Then GoTo VarOnly
        prv = False
        uni = True
    GoTo there100
    Case "PRIVATE", "ÉÄÉÙÔÉÊÏ"
        If Not IsOperator(rest$, ":") Then GoTo VarOnly
        uni = False
        prv = True
        GoTo there100
    Case "DEF", "ÊÁÍÅ"
        MyEr "DEF can't be used in a CLASS", "Ç ÊÜíå äåí ìðïñåß íá ÷ñçóéìïðïéçèåß óå ÊëÜóç"
        ExecuteGroupStruct = 0
        Exit Function
    Case "PUBLIC", "ÄÇÌÏÓÉÏ"
        If Not IsOperator(rest$, ":") Then GoTo VarOnly
        NoRec = False
        uni = False
        prv = False
        GoTo there100
    Case "LOCAL", "ÔÏÐÉÊÁ", "ÔÏÐÉÊÇ", "ÔÏÐÉÊÅÓ"
        lcl = True
        GoTo there12345
    Case "CLASS", "ÊËÁÓÇ"
    
        If IsOperator(rest$, ":") Then
            NoRec = True
            uni = False
            prv = False
            GoTo there100
        ElseIf IsLabelSymbolNew(rest$, "ÃÅÍÉÊÇ", "GLOBAL", Lang) Then
            MyEr "GLOBAL can't be used in a CLASS", "Ç êëÜóç óôçí ïìÜäá äåí ìðïñåß íá åßíáé ãåíéêÞ"
            ExecuteGroupStruct = 0
            Exit Function
        End If
        x1 = IsLabelA("", rest$, W$)
      

        If x1 = 1 Or x1 = 3 Then
        classfun = True
        j = 0
        frm$ = vbNullString
            If IsLabelSymbolNew(rest$, "ÔÕÐÏÓ", "TYPE", Lang) Then
                MyEr "Use here a Group not a Class", "×ñçóéìïðïßçóå ìéá ÏìÜäá êáé ü÷é ìéá ÊëÜóç"
                ExecuteGroupStruct = 0
                Exit Function
            ElseIf IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then
            it = x1
Subclass:
                j = IsLabelA("", rest$, w1$)
                If j = 1 Then
                j = 0
                If GetSub(ohere$ + "." + w1$ + "()", j) Then
                ElseIf GetSub(w1$ + "()", j) Then
                End If
                If j > 0 Then
                If sbf(j).Extern > 0 Or Not sbf(j).IamAClass Then
                            MyEr w1$ + " isn't a class", "to " + w1$ + " äåí åßíáé êëÜóç"
                            ExecuteGroupStruct = 0
                            Exit Function
                End If
                
                x1 = InStr(sbf(j).sb, vbCrLf)
                y1 = rinstr(sbf(j).sb, vbCrLf + vbCrLf)
                If y1 > x1 And Len(sbf(j).sb) > y1 Then
                s$ = Mid$(sbf(j).sb, x1 + 2, y1 - x1)
                x1 = InStr(s$, "{")
                 If Lang = 1 Then
                        frm$ = block(Mid$(s$, x1 + 1)) + vbCrLf + "Public:" + vbCrLf + frm$
                    Else
                        frm$ = block(Mid$(s$, x1 + 1)) + vbCrLf + "ÄÇÌÏÓÉÏ:" + vbCrLf + frm$
                    End If
                End If
checkagainsub:
               If IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then GoTo Subclass
            Else
                MyEr "class " + w1$ + " not found", "äåí âñÝèçêå ç êëÜóç " + w1$
                ExecuteGroupStruct = 0
                Exit Function
                End If
               
                End If
                x1 = it
                
            End If
            If here$ = vbNullString Then
                f$ = bstack.GroupName + W$
            Else
                f$ = W$
            End If
            If Lang = 1 Then
                If FastSymbol(rest$, "{") Then
                    ss$ = frm$ + block(rest$)
                    frm$ = vbNullString
                    If x1 = 1 Then
                        s$ = "}" + vbCrLf + vbCrLf + "if module(" + W$ + "." + W$ + ") then call! " + W$ + "." + W$ + vbCrLf + "=group(" + W$ + ")"
                        rest$ = f$ & " {'11001EDIT " & GetModuleName(bstack, here$) & ",-" & str$(Len(rest$)) & "','" & (Len(s$) + 30) & vbCrLf & " group " & W$ & " {type:" & W$ & vbCrLf & ss$ & s$ & rest$
                    Else
                        nm$ = W$
                        W$ = Left$(W$, Len(W$) - 1)
                        s$ = "}" + vbCrLf + vbCrLf + "if module(" + W$ + "." + W$ + ") then call! " + W$ + "." + W$ + vbCrLf + "=group$(" + nm$ + ")"
                        rest$ = f$ & " {'11001EDIT " & GetModuleName(bstack, here$) & str$(Len(rest$)) & ",-" & (Len(rest$)) & "'" & (Len(s$) + 30) & vbCrLf & " group " & nm$ & " {type:" & W$ & vbCrLf & ss$ & s$ & rest$
                    End If
                    nm$ = vbNullString
                    W$ = vbNullString
                    GoTo classcontclass
                Else
                    f$ = W$
                    W$ = "Group "
                End If
            Else
                If FastSymbol(rest$, "{") Then
                    ss$ = frm$ + block(rest$)
                    frm$ = vbNullString
                    If x1 = 1 Then
                        s$ = "}" + vbCrLf + "Áí ÔìÞìá(" + W$ + "." + W$ + ") Ôüôå ÊÜëåóå! " + W$ + "." + W$ + vbCrLf + "=ÏìÜäá(" + W$ + ")"
                        rest$ = f$ & " {'11001EDIT " & GetModuleName(bstack, here$) & ",-" & (Len(rest$)) & "'" & (Len(s$) + 29) & vbCrLf & " ÏìÜäá " & W$ & " {Ôýðïò:" & W$ & vbCrLf & ss$ & s$ & rest$
                    Else
                        nm$ = W$
                        W$ = Left$(W$, Len(W$) - 1)
                        s$ = "}" + vbCrLf + "Áí ÔìÞìá(" + W$ + "." + W$ + ") Ôüôå ÊÜëåóå! " + W$ + "." + W$ + vbCrLf + "=ÏìÜäá$(" + nm$ + ")"
                        rest$ = f$ & " {'11001EDIT " & GetModuleName(bstack, here$) & ",-" & (Len(rest$)) & "'" & (Len(s$) + 29) & vbCrLf & " ÏìÜäá " & nm$ + " {Ôýðïò:" & W$ & vbCrLf & ss$ & s$ & rest$
                    End If
                    W$ = vbNullString
                    GoTo classcontclass
                Else
                    f$ = W$
                    W$ = "ÏÌÁÄÁ "
                End If
            End If
            Do While FastSymbol(rest$, ",")
                If IsLabelA("", rest$, nm$) <> 1 Then
                    SyntaxError
                    ExecuteGroupStruct = 0
                    Exit Function
                End If
                f$ = f$ + W$ + nm$ + vbCrLf
            Loop
            If IsLabelSymbolNew(rest$, "ÔÕÐÏÓ", "TYPE", Lang) Then
                 MyEr "Use here a Group not a Class", "×ñçóéìïðïßçóå ìéá ÏìÜäá êáé ü÷é ìéá ÊëÜóç"
                ExecuteGroupStruct = 0
                Exit Function
            End If
            W$ = Trim$(W$)
            rest$ = f$ + rest$
            GoTo contVar
        Else
            SyntaxError
            ExecuteGroupStruct = 0
            Exit Function
        End If
    Case "TYPE", "ÔÕÐÏÓ"
    If Not IsOperator(rest$, ":") Then GoTo VarOnly
    Do
    If FastPureLabel(rest$, ss$, , True) = 1 Then
        ThisGroup.PutIs = ss$
    End If
    Loop Until Not FastSymbol(rest$, ",")
    Case "REM", "ÓÇÌ"
        If FastSymbol(rest$, "{") Then
            I = blockLen(rest$)
            If I > 0 Then
                Mid$(rest$, 1, I) = space$(I)
            Else
                MissString
                ExecuteGroupStruct = 0
                Exit Function
            End If
        End If
        SetNextLine rest$: GoTo there100
    Case "FUNCTION", "ÓÕÍÁÑÔÇÓÇ"
        If IsLabelSymbolNew(rest$, "ÃÅÍÉÊÇ", "GLOBAL", Lang) Then
            MyEr "GLOBAL can't be used in a Group", "Ç óõíÜñôçóç óôçí ïìÜäá äåí ìðïñåß íá åßíáé ãåíéêÞ"
            ExecuteGroupStruct = 0
            Exit Function
        End If
        Final = IsLabelSymbolNew(rest$, "ÔÅËÉÊÇ", "FINAL", Lang)
classcontclass:
        x1 = Abs(IsLabelF(rest$, f$))
        If prv Then f$ = ChrW(&HFFBF) + f$
funcoperator:
        If x1 <> 0 Then
           If Len(ThisGroup.FuncList) > 0 And Not alocal Then ' maybe we have it
                If InStr(ThisGroup.FuncList, Chr$(2) + f$ + "() ") > 0 Then
                    If FastSymbol(rest$, "(") Then
                        frm$ = BlockParam(rest$)
                        If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$))
                        FastSymbol rest$, ")"
                        frm$ = Trim$(frm$)
                    Else
                        frm$ = vbNullString
                    End If
                    IsSymbol3 rest$, "{"
                    ss$ = block(rest$)
                    If FastSymbol(rest$, "}") Then
                        If GetSub(bstack.GroupName + f$ + "()", I) Then
                            bstack.IndexSub = I
                            If Not sbf(I).locked Then
                                If frm$ <> "" Then
                                    If Lang = 1 Then
                                        sbf(I).sb = "READ " + frm$ + vbCrLf + ss$
                                    Else
                                        sbf(I).sb = "ÄÉÁÂÁÓÅ " + frm$ + vbCrLf + ss$
                                    End If
                                Else
                                    sbf(I).sb = ss$
                                End If
                                Set sbf(I).subs = Nothing
                                sbf(I).locked = Final
                            End If
                            GoTo continuehere22
                        End If
                        Rem MyEr "group struct error1", "ðñïâëçìá óôç äïìÞ1"
                        Rem ExecuteGroupStruct = 0: Exit Function
                    End If
                End If
            End If
            If bstack.OriginalCode < 0 Then
            '  ??? Stop
            ElseIf Left$(sbf(bstack.OriginalCode).sb, 10) = "'11001EDIT" Then
            
                hlp$ = vbNullString
                If FastSymbol(rest$, "(") Then
                    If Not FastSymbol(rest$, ")") Then
                        hlp$ = MyTrim(BlockParam(rest$))
                        If Len(hlp$) > 0 Then hlp$ = vbCrLf + "Read " + hlp$ + vbCrLf
                    Else
                        IsSymbol3 rest$, "("
                        IsSymbol3 rest$, ")"
                    End If
                    
                Else

                End If
                
                If Right$(rest$, 2) <> vbCrLf Then
                    b$ = GetNextLine((sbf(bstack.OriginalCode).sb)) '+ "+2"
                    I = InStrRev(b$, "'")
                    If I > 1 Then
                        j = val(Mid$(b$, I + 1))
                        b$ = Left$(b$, I - 1)
                    Else
                        j = 0
                    End If
                Else
                    b$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))
                End If
              '  nm$ = GetStrUntil(",", Mid$(b$, 12))
               ' GetSub nm$, i
            If hlp$ <> "" Then
                FastSymbol rest$, "("
                
                frm$ = BlockParam(rest$)
                Mid$(rest$, 1, Len(frm$) + 1) = space$(Len(frm$) + 1)

                
            Else
                hlp$ = vbCrLf

                
            
            End If
            IsSymbol3 rest, "{"
            I = Len(rest$)
            s$ = b$
            If Left$(s$, 10) = "'11001EDIT" Then
                'i = Len(rest$)
                's$ = GetNextLine(rest$)
               ' i = i - Len(rest$) + 1
                DropLeft "'", s$
                DropLeft "'", s$
                If s$ <> "" Then
                j = val(s$)
                b$ = Left$(b$, Len(b$) - Len(s$) - 1)
                End If
            End If
           
          
           b$ = "{" + b$ '+ "-" + LTrim(i + 1)
            If Left$(rest$, 10) = "'11001EDIT" Then
            s$ = GetNextLine(rest$)
            End If
            rest$ = b$ + hlp$ + rest$
        End If
        If here$ = vbNullString Then
            If W$ = vbNullString Then
                rest$ = f$ + " " + rest$
                W$ = "FUNCTION"
            Else
                rest$ = bstack.GroupName + f$ + " " + rest$
            End If
        Else
            rest$ = f$ + " " + rest$
            If W$ = vbNullString Then
                If Lang = 1 Then
                    W$ = "FUNCTION"
                Else
                    W$ = "ÓÕÍÁÑÔÇÓÇ"
                End If
            End If
        End If
  
BYPASS3:
        ExecuteGroupStruct = Abs(IdentifierGroup(bstack, W$, rest$, Lang, alocal, addlen))
        If ExecuteGroupStruct = 0 Then Exit Function
        If GetSub(bstack.GroupName + f$ + "()", I) Then
            If sbf(I).locked Then Final = True
            If Final Then sbf(I).locked = True
            If Final Then
                If removebypass Or Not NoRec Then
                    If Not lcl Then
                        ThisGroup.FuncList = Chr$(1) & Chr$(2) & f$ & "() -" & (I) & Chr$(1) & ThisGroup.FuncList
                    Else
                        ThisGroup.localList = ThisGroup.localList + vbCrLf + "Local Function " + f$ + "{" + sbf(I).sb + "}"
                    End If
                End If
            Else
            If classfun Then
            sbf(I).locked = True
            sbf(I).IamAClass = True
            classfun = False
           s$ = " @"
           Else
           s$ = vbNullString
           
            End If
                If Not NoRec Then
                    If Not lcl Then
                        ThisGroup.FuncList = Chr$(1) & Chr$(2) & f$ & "() " & (I) & s$ & Chr$(1) & ThisGroup.FuncList
                    Else
                        ThisGroup.localList = ThisGroup.localList + vbCrLf + "Local Function " + f$ + "{" + sbf(I).sb + "}"
                    End If
                End If
            End If
            If here$ = vbNullString Then
                sbf(I).sbgroup = bstack.GroupName
                sbf(I).tpointer = vvv
            Else
                sbf(I).sbgroup = here$ + "." + bstack.GroupName
                sbf(I).tpointer = vvv
            End If
        End If
    Else
        ExecuteGroupStruct = 0
    End If
    If ExecuteGroupStruct = 0 Then Exit Function
     

Case "MODULE", "ÔÌÇÌÁ"
    If IsLabelSymbolNew(rest$, "ÃÅÍÉÊÇ", "GLOBAL", Lang) Then
        MyEr "GLOBAL can't be used in a Group", "Ç óõíÜñôçóç óôçí ïìÜäá äåí ìðïñåß íá åßíáé ãåíéêÞ"
        ExecuteGroupStruct = 0
        Exit Function
    End If
    Final = IsLabelSymbolNew(rest$, "ÔÅËÉÊÏ", "FINAL", Lang)
    x1 = Abs(IsLabelF(rest$, f$))
    If prv Then f$ = ChrW(&HFFBF) + f$
    If x1 <> 0 Then
        If ThisGroup.FuncList <> "" And Not alocal Then  ' maybe we have it
            If InStr(ThisGroup.FuncList, Chr$(3) + f$ + " ") > 0 Then
                If FastSymbol(rest$, "(") Then
                    frm$ = BlockParam(rest$)
                    If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                    If Not FastSymbol(rest$, ")") Then
                    End If
                    frm$ = Trim$(frm$)
                Else
                    frm$ = vbNullString
                End If
  
                IsSymbol3 rest$, "{"
                ss$ = block(rest$)
                If FastSymbol(rest$, "}") Then
                    If GetSub(bstack.GroupName + f$, I) Then
                        bstack.IndexSub = I
                        If Not sbf(bstack.IndexSub).locked Then
                            If frm$ <> "" Then
                              If Lang = 1 Then
                                  sbf(I).sb = "READ " + frm$ + vbCrLf + ss$
                              Else
                                  sbf(I).sb = "ÄÉÁÂÁÓÅ " + frm$ + vbCrLf + ss$
                              End If
                            Else
                                sbf(I).sb = ss$
                            End If
                            Set sbf(I).subs = Nothing
                            sbf(I).locked = Final
                        End If
                        GoTo continuehere22 'there12345
                    End If


 
    Rem never happen
     Rem   MyEr "group struct error2", "ðñïâëçìá óôç äïìÞ2"
     Rem    ExecuteGroupStruct = 0: Exit Function

   End If
  End If
  Else
  ' we don't have it
  End If
  ' so is the first time, put it back
  If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
   
   ss$ = rest$
   hlp$ = vbNullString
   If FastSymbol(ss$, "(") Then
   If Not FastSymbol(ss$, ")") Then
                         hlp$ = BlockParam(ss$)
                            If hlp$ <> "" Then Mid$(ss$, 1, Len(ss$) + 2) = space$(Len(ss$) + 1)
                            FastSymbol ss$, ")"
                            
                        hlp$ = Trim$(hlp$)
                        If hlp$ <> "" Then hlp$ = vbCrLf + "Read " + hlp$ + vbCrLf
                        Else
                        IsSymbol3 rest$, "("
                        IsSymbol3 rest$, ")"
                        End If
   
   End If
     IsSymbol3 ss$, "{"
    frm$ = block(ss$)
    ' look here
  If Right$(frm$, 2) <> vbCrLf Then
        b$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb)) '+ "+2"
        I = InStrRev(b$, "'")
        If I > 1 Then
        j = val(Mid$(b$, I + 1))
           b$ = Left$(b$, I - 1)
           Else
          j = 0
        End If
  Else
        b$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))

        End If
        nm$ = GetStrUntil(",", Mid$(b$, 12))
      GetSub nm$, I
abc123:
      FastSymbol ss$, "("
      If hlp$ <> "" Then
      frm$ = BlockParam(rest)
      
      End If
        If hlp$ <> "" Then
      FastSymbol rest$, "("
      frm$ = BlockParam(rest$)
      
      Mid$(rest$, 1, Len(frm$) + 2) = space$(Len(frm$) + 2)
      Else
      hlp$ = vbCrLf
      End If
      I = Len(rest$)
      IsSymbol3 rest, "{"
      I = I - Len(rest$) + 1
      If Left$(rest$, 10) = "'11001EDIT" Then
      I = Len(rest$)
       s$ = GetNextLine(rest$)
       I = I - Len(rest$) + 1
       DropLeft "'", s$
       DropLeft "'", s$
       If s$ <> "" Then j = val(s$)
       
      End If
      
    ''  b$ = "{" '+ b$ + "-" + LTrim(Str$(addlen))
    
        
   ' rest$ = b$ + hlp$ + rest$
   rest$ = "{" + hlp$ + rest$
Else
    ss$ = rest$
    hlp$ = vbNullString
    If FastSymbol(ss$, "(") Then
        hlp$ = BlockParam(ss$)
        If hlp$ <> "" Then Mid$(ss$, 1, Len(ss$) + 2) = space$(Len(ss$) + 1)
        FastSymbol ss$, ")"
                            
                        hlp$ = Trim$(hlp$)
                        If hlp$ <> "" Then hlp$ = vbCrLf + "Read " + hlp$ + vbCrLf
   
   End If
         FastSymbol "(", ss$
      If hlp$ <> "" Then
      frm$ = BlockParam(rest)
      
      End If
        If hlp$ <> "" Then
      FastSymbol rest$, "("
      frm$ = BlockParam(rest$)
      
      Mid$(rest$, 1, Len(frm$) + 2) = space$(Len(frm$) + 2)
      Else
      hlp$ = vbCrLf
      End If
      IsSymbol3 rest, "{"
       b$ = "{"
    
        
    rest$ = b$ + hlp$ + rest$

  End If
  If here$ = vbNullString Then
  
  rest$ = bstack.GroupName + f$ + " " + rest$
  Else
  
  rest$ = f$ + " " + rest$
  End If
BYPASS4:
 ExecuteGroupStruct = Abs(IdentifierGroup(bstack, W$, rest$, Lang, alocal Or Glob, addlen))
  If GetSub(bstack.GroupName + f$, I) Then
  If sbf(I).locked Then Final = True
  If Final Then sbf(I).locked = True
  
If Not NoRec Then
If Final Then
 If Not lcl Then
 ThisGroup.FuncList = Chr$(1) & Chr$(3) & f$ & " -" & (I) & Chr$(1) & ThisGroup.FuncList
 Else
  ThisGroup.localList = ThisGroup.localList + vbCrLf + "Local Module " + f$ + "{" + sbf(I).sb + "}"
 End If
Else
 If Not lcl Then
 ThisGroup.FuncList = Chr$(1) & Chr$(3) & f$ & " " & (I) & Chr$(1) & ThisGroup.FuncList
 Else
  ThisGroup.localList = ThisGroup.localList + vbCrLf + "Local Module " + f$ + "{" + sbf(I).sb + "}"
 End If
 End If
End If
        If here$ = vbNullString Then
   sbf(I).sbgroup = bstack.GroupName
   Else
    sbf(I).sbgroup = here$ + "." + bstack.GroupName
  End If
  sbf(I).tpointer = vvv
  End If

     Else
     ExecuteGroupStruct = 0
     End If
     If ExecuteGroupStruct = 0 Then Exit Function
Case "STRUCTURE", "ÄÏÌÇ"
bstack.priveflag = prv
bstack.uniflag = uni
bstack.finalFlag = Final
 If Not makestruct(bstack, rest$, Lang, Glob Or here$ = "", alocal) Then ExecuteGroupStruct = 0: Exit Function
   bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
Case "EVENT", "ÃÅÃÏÍÏÓ", "EVENTS", "ÃÅÃÏÍÏÔÁ"

If ISSTRINGA(rest$, s$) Then
s$ = CleanStr(s$, " ")
If s$ <> vbNullString Then
ThisGroup.RegisterEvent s$
    Do While FastSymbol(rest$, ",")
        If ISSTRINGA(rest$, s$) Then
            s$ = CleanStr(s$, " ")
            If s$ <> vbNullString Then ThisGroup.RegisterEvent s$
        Else
            MyEr "Expected a string literal for event name", "Ðåñßìåíá áëöáñéèìçôéêü óå åéóáãùãéêÜ ãéá üíïìá ãåãïíüôïò"
                    ExecuteGroupStruct = 0
                    Exit Function
        End If
    Loop
Else
    Set ThisGroup.Events = Nothing
End If
GoTo there100
Else
bstack.priveflag = prv
bstack.uniflag = uni
bstack.finalFlag = Final
   ExecuteGroupStruct = Abs(IdentifierGroup(bstack, W$, rest$, Lang, alocal, addlen))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
End If
Case "DIM", "ÐÉÍÁÊÁÓ", "ÐÉÍÁÊÅÓ"
' put back, change HERE$ and
contVar:
bstack.priveflag = prv
bstack.uniflag = uni
bstack.finalFlag = Final

ExecuteGroupStruct = Abs(MyDim(bstack, rest$, Lang, Glob Or alocal, OarrnameLen))

  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
     If ExecuteGroupStruct = 0 Then Exit Function
Case "GROUP", "ÏÌÁÄÁ"
If Final Then
            NoObjectAssign
            ExecuteGroupStruct = 0
            Exit Function
            End If
     x1 = Abs(IsLabel(bstack, rest$, W$))
     hlp = vbNullString
     If x1 = 3 Then
     x1 = 1
     hlp = W$
     W$ = Left$(W$, Len(W$) - 1)
     End If
     If prv Then W$ = ChrW(&HFFBF) + W$
      If x1 = 1 Then
                         If IsLabelSymbolNew(rest$, "ÔÕÐÏÓ", "TYPE", Lang) Then
                                            If IsStrExp(bstack, rest$, ss$) Then
                                            frm$ = bstack.GroupName
                                            prepareGroup bstack, W$, y1, Glob, Len(hlp) > 0, alocal
                                          
                                            LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                            
                                            bstack.priveflag = prv
                                             ExecuteGroupStruct = Abs(ExecuteGroupStruct(bstack, bstack.GroupName + W$, y1, ss$, 0, Lang, Glob, alocal))
                                            bstack.priveflag = False
                                                OvarnameLen = varhash.count + 1 'Len(VarName$) + 1   'we record ...
                                          
                                            
                                             bstack.GroupName = frm$
                                            End If
    
                            Else
                                    If FastSymbol(rest$, "{") Then
                      
                                          frm$ = bstack.GroupName
                                          If Glob Then
                                            If GetVar(bstack, frm$ + W$, y1, True) Then
                                                ' skip preparegroup, we have the group
                                                If y1 > vvv Then GoTo contvvv
                                            End If
                                          End If
                                          prepareGroup bstack, W$, y1, False, Len(hlp) > 0, alocal
contvvv:
                                          
                                        LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                            addlen = Len(rest$)
                                            s$ = block(rest$)
                                            addlen = addlen - Len(s$)
               
                                        If Not Abs(ExecuteGroupStruct(bstack, bstack.GroupName + W$, y1, s$, addlen, Lang, Glob, alocal)) = 0 Then
                                            ExecuteGroupStruct = FastSymbol(rest$, "}")
                                        End If
                                            OvarnameLen = varhash.count + 1  'we record ...
                                  
                                         bstack.GroupName = frm$
                                         If VarTypeName(var(y1)) <> mGroup Then Set var(y1) = New Group
                                    Else
                                      prepareGroup bstack, W$, y1, Glob, Len(hlp) > 0
                                        LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                            End If

                          
                        End If
             End If






     If ExecuteGroupStruct = 0 Then Exit Function
       ''LogGroup bstack, vvv, oHere$, OvarnameLen, OarrnameLen, lcl
Case "GLOBAL", "ÃÅÍÉÊÏ", "ÃÅÍÉÊÇ", "ÃÅÍÉÊÅÓ"
MyEr "No global variables in groups, create global group", "¼÷é ãåíéêÝò ìåôáâëçôÝò óå ïìÜäá - öôéÜîå ãåíéêÞ ïìÜäá"
ExecuteGroupStruct = 0
Exit Function

Case "INTEGER", "ÁÊÅÑÁÉÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbInteger, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "DOUBLE", "ÄÉÐËÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbDouble, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "SINGLE", "ÁÐËÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbSingle, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "BOOLEAN", "ËÏÃÉÊÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbBoolean, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "DECIMAL", "ÁÑÉÈÌÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbDecimal, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "BIGINTEGER", "ÌÅÃÁËÏÓÁÊÅÑÁÉÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbObject, Not (alocal Or Glob), New BigInteger))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "CURRENCY", "ËÏÃÉÓÔÉÊÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbCurrency, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "LONG", "ÌÁÊÑÕÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbLong, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "STRING", "ÃÑÁÌÌÁ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbString, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "VARIANT", "ÁÔÕÐÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbVariant, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "OBJECT", "ÁÍÔÉÊÅÉÌÅÍÏ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbObject, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "BYTE", "ØÇÖÉÏ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbByte, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "DATE", "ÇÌÅÑÏÌÇÍÉÁ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, vbDate, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "COMPLEX", "ÌÉÃÁÄÉÊÏÓ"
        bstack.priveflag = prv: bstack.uniflag = uni: bstack.finalFlag = Final
        ExecuteGroupStruct = Abs(MyAnyType(bstack, rest$, Lang, alocal, 200, Not (alocal Or Glob)))
        bstack.priveflag = False:  bstack.uniflag = False:  bstack.finalFlag = False
        If ExecuteGroupStruct = 0 Then Exit Function
Case "ÊÁÔÁÓÔÁÓÇ", "INVENTORY"
        bstack.priveflag = prv
        bstack.uniflag = uni
        bstack.finalFlag = Final
    ExecuteGroupStruct = Abs(ProcInventory(bstack, rest$, Lang, alocal))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
       If ExecuteGroupStruct = 0 Then Exit Function
Case "ÄÉÁÑÈÑÙÓÇ", "BUFFER"
        bstack.priveflag = prv
        bstack.uniflag = uni
        bstack.finalFlag = Final
    ExecuteGroupStruct = Abs(ProcBuffer(bstack, rest$, Lang, alocal))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
       If ExecuteGroupStruct = 0 Then Exit Function
Case "DOCUMENT", "ÅÃÃÑÁÖÏ"
        bstack.priveflag = prv
        bstack.uniflag = uni
        bstack.finalFlag = Final
    ExecuteGroupStruct = Abs(MyDocument(bstack, rest$, Lang, alocal))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
     If ExecuteGroupStruct = 0 Then Exit Function
Case "ÁÐÁÑÉÈÌÇÓÇ", "ÁÐÁÑ", "ENUMERATION", "ENUM"
        bstack.priveflag = prv
        bstack.uniflag = uni
        bstack.finalFlag = Final
  ExecuteGroupStruct = Abs(ProcEnumGroup(bstack, rest$, LenB(here$) = 0))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
       If ExecuteGroupStruct = 0 Then Exit Function
Case Else
' check if we have a class
conthereplease:
nm$ = vbNullString


If Len(rest$) > 0 Then
If Not MaybeIsSymbol(rest$, TT$) Then
   If GetSub(bstack.GroupName + ChrW(&HFFBF) + W$ + "()", j) Then
    If Not sbf(j).IamAClass Then GoTo grerror
    W$ = ChrW(&HFFBF) + W$
    GoTo cont111
   ElseIf GetSub(bstack.GroupName + W$ + "()", j) Then
   
        If Not sbf(j).IamAClass Then
grerror:
            MyEr W$ + " isn't a class", "to " + W$ + " äåí åßíáé êëÜóç"
            ExecuteGroupStruct = 0
            Exit Function
        End If
cont111:
        f$ = "=" + bstack.GroupName + W$ + "()"
        
        j = IsLabelA(here$, rest$, W$)
        
            If (j And 3) = 0 Then Exit Do
            
            If j And 7 = 3 Then W$ = Replace(W$, "$", "")
            If uni Then
            Else
                If prv Then W$ = ChrW(&HFFBF) + W$
            End If
            If j > 4 Then
            
            Mid$(W$, Len(W$), 1) = " "
            rest$ = Left$(f$, Len(f$) - 1) + rest$
            Else
            rest$ = f$ + rest$
            End If
           
            
            W$ = RTrim(W$)
            nm$ = W$
            Set stripstack1 = bstack
            ''
    ElseIf GetSub(W$ + "()", j) Then
        If Not sbf(j).IamAClass Then
            GoTo grerror
        End If
        f$ = "=" + W$ + "()"
foundit:
        j = IsLabelA(here$, rest$, W$)
        If (j And 3) = 0 Then Exit Do

        If j And 7 = 3 Then W$ = Replace(W$, "$", "")
        If uni Then
            
        Else
           If prv Then W$ = ChrW(&HFFBF) + W$
        End If
        If j > 4 Then
            
            Mid$(W$, Len(W$), 1) = " "
                rest$ = Left$(f$, Len(f$) - 1) + rest$
            Else
                rest$ = f$ + rest$
            End If
           
            
            W$ = RTrim(W$)
            nm$ = W$
            Set stripstack1 = bstack
    ElseIf GetSub(bstack.GroupName + ChrW(&HFFBF) + W$ + "()", j) Then
        If Not sbf(j).IamAClass Then
            GoTo grerror
        End If
        f$ = "=" + bstack.GroupName + ChrW(&HFFBF) + W$ + "()"
        GoTo foundit
    
    Else
        If uni Then
        
    Else
        If prv Then W$ = ChrW(&HFFBF) + W$
    End If
    End If
Else
If uni Then
    
Else
    If prv Then W$ = ChrW(&HFFBF) + W$
End If

End If
Else
If uni Then
    
Else
    If prv Then W$ = ChrW(&HFFBF) + W$
End If
End If
VarOnly:
W$ = ohere$ + "." + W$
skip = False
Select Case v
Case 1
    p = 0#
    If IsLabelSymbolNew(rest$, "ÙÓ", "AS", Lang) Then
    skip = True
            If IsLabelSymbolNew(rest$, "ÁÑÉÈÌÏÓ", "DECIMAL", Lang) Then
                p = CDec(0)
            ElseIf IsLabelSymbolNew(rest$, "ÄÉÐËÏÓ", "DOUBLE", Lang) Then
                p = 0#
            ElseIf IsLabelSymbolNew(rest$, "ÁÐËÏÓ", "SINGLE", Lang) Then
                p = 0!
            ElseIf IsLabelSymbolNew(rest$, "ËÏÃÉÊÏÓ", "BOOLEAN", Lang) Then
                p = False
            ElseIf IsLabelSymbolNew(rest$, "ÌÁÊÑÕÓ", "LONG", Lang) Then
                If IsLabelSymbolNew(rest$, "ÌÁÊÑÕÓ", "LONG", Lang) Then
                p = cInt64(0&)
                Else
                p = 0&
                End If
            ElseIf IsLabelSymbolNew(rest$, "ÁÊÅÑÁÉÏÓ", "INTEGER", Lang) Then
                p = 0
            ElseIf IsLabelSymbolNew(rest$, "ËÏÃÉÓÔÉÊÏÓ", "CURRENCY", Lang) Then
                p = 0@
            ElseIf IsLabelSymbolNew(rest$, "ØÇÖÉÏ", "BYTE", Lang) Then
                p = CByte(0)
            ElseIf IsLabelSymbolNew(rest$, "ÇÌÅÑÏÌÇÍÉÁ", "DATE", Lang) Then
                p = CDate(0)
            ElseIf IsLabelSymbolNew(rest$, "ÌÅÃÁËÏÓÁÊÅÑÁÉÏÓ", "BIGINTEGER", Lang) Then
                Set zeroitem = New BigInteger
            ElseIf IsLabelSymbolNew(rest$, "ÌÉÃÁÄÉÊÏÓ", "COMPLEX", Lang) Then
                p = nMath2.cxZero
            Else
                If IsLabelA(here$, rest$, s$) Then
                    If GetVar(bstack, bstack.GroupName + s$, v, True) Then
                        If MyIsObject(var(v)) Then
                            If TypeOf var(v) Is mHandler Then
                                Set usehandler = var(v)
                                If usehandler.T1 = 4 Then
                                    CopyHandler var(v), bstack
                                    Set usehandler = bstack.lastobj
                                    Set bstack.lastobj = Nothing
                                    usehandler.index_start = 0
                                    usehandler.index_cursor = usehandler.objref.ZeroValue
                                    usehandler.sign = 1
                                    If FastSymbol(rest$, "=") Then
                                        If IsLabelA(here$, rest$, s$) Then
                                            If GetVar(bstack, bstack.GroupName + s$, v, True) Then
                                                If MyIsObject(var(v)) Then
                                                    Set p = var(v)
                                                    If TypeOf p Is mHandler Then
                                                        Set usehandler2 = p
                                                        If usehandler2.T1 = 4 Then
                                                           If Not usehandler.objref Is usehandler2.objref Then
                                                               usehandler2.CopyTo usehandler2
                                                               If usehandler.objref.ExistFromOther2(usehandler2) Then
                                                               Set usehandler2.objref = usehandler.objref
                                                               Set usehandler = usehandler2
                                                               GoTo cont120345
                                                               Else
                                                                s$ = usehandler.objref.EnumName
                                                                Expected s$, s$
                                                                Exit Function
                                                                End If
                                                            End If
                                                            
                                                        Else
                                                            ExpectedEnumType
                                                            Exit Function
                                                        End If
                                                        usehandler2.CopyTo usehandler
cont120345:
                                                        Set p = usehandler
                                                        Set usehandler2 = Nothing
                                                    Else
                                                        ExpectedEnumType
                                                        Exit Function
                                                    End If
                                                Else
                                                    ExpectedEnumType
                                                    Exit Function
                                                End If
                                            Else
                                                ExpectedEnumType
                                                Exit Function
                                            End If
                                        Else
                                            ExpectedEnumType
                                            Exit Function
                                        End If
                                    Else
                                        Set p = usehandler
                                    End If
                                    If Glob Then
                                        v = globalvar(W$, p)
                                    ElseIf here$ = vbNullString Then
                                        v = globalvar(W$, p)
                                    Else
                                        If alocal Then
                                            v = globalvar(W$, p)
                                        ElseIf Not GetlocalVar(W$, v) Then
                                            v = globalvar(W$, p)
                                        End If
                                        Set var(v) = p
                                    End If
                                    p = Empty
                                    GoTo continuehere
                                Else
                                    ExpectedEnumType
                                    Exit Function
                                End If
                                Set usehandler = Nothing
                            Else
                                ExpectedEnumType
                                Exit Function
                            End If
                        Else
                            ExpectedEnumType
                            Exit Function
                        End If
                        SyntaxError
                    End If
                Else
                    MyEr "No type found", "äåí âñÞêá ôýðï"
                    Exit Function
                End If
                GoTo there
            End If
            If FastSymbol(rest$, "=") Then
            If TypeOf p Is cxComplex Then
                If FastSymbol(rest$, "(") Then
                    If IsNumberD2(rest$, p, True) Then
                        rest$ = NLtrim(rest$)
                        If UCase(Left$(rest$, 2)) = "I)" Then
                            p = nMath2.cxNew(0, CDbl(p))
                            Mid(b$, 1, 2) = "  "
                        ElseIf Left$(rest$, 1) = "," Then
                            Mid(rest$, 1, 1) = " "
                            p = nMath2.cxNew(CDbl(p), 0#)

                            If IsNumberD2(rest$, h, True) Then
                                p.I = CDbl(h)
                                rest$ = NLtrim(rest$)
                                If Not UCase(Left$(rest$, 2)) = "I)" Then
                                    SyntaxError
                                    Exit Function
                                End If
                                Mid(rest$, 1, 2) = "  "
                            End If
                        End If
                    End If
                ElseIf IsNumberD2(rest$, p, True) Then
                    p = nMath2.cxNew(p, 0#)
                End If
            ElseIf Not IsNumberD2(rest$, p, True) Then
                If Not zeroitem Is Nothing Then
                If TypeOf zeroitem Is BigInteger Then
                    If ISSTRINGA(rest$, s$) Then
                        Set p = Module13.CreateBigInteger(s$)
                        Set zeroitem = Nothing
                        GoTo there
                    End If
                End If
                End If
                missNumber
                Exit Function
            End If
            
            If Len(rest$) > 0 Then
            If InStr("!@#%~&", Left$(rest$, 1)) > 0 Then
                Mid$(rest$, 1, 1) = " "
            ElseIf Left$(rest$, 1) = "u" Then
            If InStr("bd", Mid$(rest$, 2, 1)) > 0 Then
                Mid$(rest$, 1, 2) = "  "
            Else
                Mid$(rest$, 1, 1) = " "
            End If
            End If
            End If
            If Not zeroitem Is Nothing Then
                If TypeOf zeroitem Is BigInteger Then
                    Set p = Module13.CreateBigInteger(CStr(Int(p)))
                    Set zeroitem = Nothing
                End If
            End If
            ElseIf Not zeroitem Is Nothing Then
                Set p = zeroitem
                Set zeroitem = Nothing
            End If
        End If
there:
        If Glob Then
            v = globalvar(W$, p)
        ElseIf here$ = vbNullString Then
            If Not GetVar(bstack, W$, v) Then v = globalvar(W$, p) ': GetVar bstack, W$, v
        Else
            If alocal Then
            v = globalvar(W$, p)
        Else
            If Not GetlocalVar(W$, v) Then v = globalvar(W$, p)  ': GetlocalVar W$, v
        End If
        If Final Then
            If MyIsObject(var(v)) Then
                If Not TypeOf var(v) Is Constant Then MyEr "No Constant, it is an object", "Äåí Ý÷ù óôáèåñÞ, áëëÜ áíôéêåßìåíï": Exit Function
            Else
                Set var(v) = New Constant
            End If
        End If
    End If
    If skip Then
    ' do nothing
    ElseIf FastSymbol(rest$, "=") Then
         If IsExp(stripstack1, rest$, p) Then
       
            If Not stripstack1.lastobj Is Nothing Then

                If TypeOf stripstack1.lastobj Is lambda Then
                    Set var(v) = stripstack1.lastobj
                    Set stripstack1.lastobj = Nothing
                    LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, False 'uni
              
  
                    If here$ = vbNullString Or Glob Then
                        GlobalSub W$ + "()", "", bstack.GroupName, , v
                    Else
                        If Not alocal Then
                        If GetSub(here$ + "." + W$ + "()", I) Then
                            If rinstr(sbf(I).sbgroup, bstack.GroupName) + Len(bstack.GroupName) - 1 = Len(sbf(I).sbgroup) Then
                            GoTo conthere0001
                            End If
                        End If
                        End If
                       it = GlobalSub(here$ + "." + W$ + "()", "", here$ + "." + bstack.GroupName, , v)
                       sbf(it).tpointer = bstack.tpointer
                    End If
                    If Final Then
                    Set C = New Constant
                    C.DefineOnce var(v)
                    Set var(v) = C
                    End If
                    
conthere0001:
                    OvarnameLen = varhash.count + 1
                ElseIf TypeOf stripstack1.lastobj Is Group Then
                            If Final Then
                            NoObjectAssign
                            ExecuteGroupStruct = 0
                            Exit Function
                            End If
                    Set myobject = stripstack1.lastobj
                   ' If vartypename(var(v)) = "Double" Then Set var(v) = New Group
                    
againgroup:
                    
                        If MyIsObject(var(v)) Then
                            
                            If TypeOf var(v) Is Group Then
                            LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                             If nm$ <> "" Then
                                UnFloatGroupReWriteVars stripstack1, nm$, v, myobject
                            ElseIf Len(stripstack1.UseGroupname) = 0 Then
                                        UnFloatGroupReWriteVars stripstack1, W$, v, myobject
                            Else
                                UnFloatGroupReWriteVars stripstack1, Mid$(W$, Len(ohere$ + ". ")), v, myobject
                            End If
                            Else
                                MissingGroup
                                ExecuteGroupStruct = 0
                                Exit Function
                            End If
                           ' LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                            OvarnameLen = varhash.count + 1  'we record ...
                        Else
                          If VarTypeName(var(v)) = "Double" Then
                          Set var(v) = myobject
                          LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                          Set var(v) = Nothing
                          Else
                          LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                          End If
                          If nm$ <> "" Then
                          
                          UnFloatGroup stripstack1, ohere$ + "." + nm$, v, myobject
                     
                          ElseIf Len(stripstack1.UseGroupname) = 0 Then
                          UnFloatGroup stripstack1, W$, v, myobject
                          
                          Else
                          UnFloatGroup stripstack1, Mid$(W$, Len(ohere$ + ". ")), v, myobject
                          End If
                         
                   
                          OvarnameLen = varhash.count + 1  'we record ...
                         ' LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                            Set stripstack1.lastobj = Nothing
                            Set stripstack1 = New basetask
                            bstack.CopyStrip stripstack1
                            
                          If nm$ = vbNullString Then
                          
                          
                                  GoTo continuehere
                          End If
                          
                    End If
                   
                    If FastSymbol(rest$, ",") Then
                        j = IsLabelA(here$, rest$, nm$)
                        If (j And 3) <> 0 Then
                            nm$ = Replace(nm$, "$", "")
                            If uni Then
                            Else
                            If prv Then nm$ = ChrW(&HFFBF) + nm$
                            End If
                            If j > 4 Then
                            nm$ = Left$(nm$, Len(nm$) - 1)
                            rest$ = Left$(f$, Len(f$) - 1) + rest$
                            v = 1
                            W$ = nm$
                            GoTo VarOnly
                            Else
                            If here$ = vbNullString Then
                                If Not GetVar(stripstack1, ohere$ + "." + nm$, v) Then v = globalvarGroup(ohere$ + "." + nm$, p)    ': GetVar bstack, nm$, v
                            Else
                                If Not GetlocalVar(ohere$ + "." + nm$, v) Then v = globalvarGroup(ohere$ + "." + nm$, p)     ': GetlocalVar W$, v
                            End If
                            GoTo againgroup
                            End If

                        Else
                            SyntaxError
                            Exit Do
                        End If
                    End If
                    Set stripstack1.lastobj = Nothing
                    Set stripstack1 = New basetask
                    bstack.CopyStrip stripstack1
                    GoTo continuehere
                ElseIf TypeOf stripstack1.lastobj Is mArray Then
                        If Final Then
                            NoObjectAssign
                            ExecuteGroupStruct = 0
                            Exit Function
                        End If
                        Set usehandler = New mHandler
                        Set var(v) = usehandler
                        usehandler.T1 = 3
                        Set usehandler.objref = stripstack1.lastobj
                        Set stripstack1.lastobj = Nothing
                        Set usehandler = Nothing
                ElseIf TypeOf stripstack1.lastobj Is BigInteger Then
                    Set var(v) = stripstack1.lastobj
                    Set stripstack1.lastobj = Nothing
                Else
                    If Final Then
                        NoObjectAssign
                        ExecuteGroupStruct = 0
                        Exit Function
                    End If
                    Set myobject = stripstack1.lastobj
                    If CheckIsmArrayOrStackOrCollection(myobject) Then
                        Set usehandler = New mHandler
                        Set var(v) = usehandler
                        If TypeOf myobject Is FastCollection Then
                            usehandler.T1 = 1
                        Else
                            usehandler.T1 = 3
                        End If
                        Set usehandler.objref = myobject
                        Set stripstack1.lastobj = Nothing
                        Set usehandler = Nothing
                    ElseIf TypeOf myobject Is mHandler Then
                        'Set usehandler = myobject
                        If CheckDeepAny(myobject) Then
                            Set var(v) = myobject
                            Set stripstack1.lastobj = Nothing
                        End If
                    End If
                End If
            ElseIf VarType(var(v)) = vbLong Then
                var(v) = CLng(p)
            Else
                If MyIsObject(var(v)) Then
                    If TypeOf var(v) Is Constant Then
                        var(v).DefineOnce p
                    End If
                Else
                If Final Then
                    Set var(v) = New Constant
                    var(v).DefineOnce p
                Else
                    var(v) = p
                    
                End If
                End If
            End If
        Else
            If IsStrExp(stripstack1, rest$, ss$, False) Then
                    p = vbNullString
                    SwapString2Variant ss$, p
                    If Final Then
                    Set var(v) = New Constant
                    var(v).DefineOnce p
                Else
                    var(v) = p
                End If
            Else
                If LastErNum <> -2 Then NoValueForVar W$
                ExecuteGroupStruct = 0
                Exit Function
            End If
        End If
    Else
        ss$ = vbNullString
        I = MyTrimL(rest$)
                If InStr("/*-+=~^&|<>", Mid$(rest$, I, 1)) > 0 Then
                    If InStr("/*-+=~^&|<>!", Mid$(rest$, I + 1, 1)) > 0 Then
                        ss$ = Mid$(rest$, I, 2)
                        If ss$ = "=&" Then
                        ss$ = "="
                        Mid$(rest$, I, 1) = " "
                        Else
                        If Len(rest$) >= 2 Then Mid$(rest$, I, 2) = "  "
                        End If
                    Else
                        ss$ = Mid$(rest$, I, 1)
                        If Len(rest$) > 0 Then Mid$(rest$, I, 1) = " "
                    End If
                If ss$ <> "" Then
                    NoThatOperator ss$
                    ExecuteGroupStruct = 0
                    Exit Function
                End If
                Else
                    
                End If
    End If
    GoTo continuehere
Case 2
    rest$ = W$ + rest$: Exit Function
Case 3
        ss$ = vbNullString
         If MaybeIsSymbol(rest$, "=<") Then
            If FastSymbol(rest$, "<=", , 2) Then
                    NoThatOperator "<="
                    ExecuteGroupStruct = 0
                    Exit Function
            ElseIf FastSymbol(rest$, "=") Then
            ss$ = "="
            End If
        End If
       

If ss$ <> "" Then

    If ss$ = "=" Then
    
    If here$ = vbNullString Then
            If Glob Then
           If IsStrExp(stripstack1, rest$, ss$, False) Then
              v = globalvarEmpty(W$)
          If CheckVarGroup(stripstack1, var(v), ss$, Final) = 1 Then
          GlobalSub W$ + "()", "", bstack.GroupName, , v
        
          End If
 
             
           End If
              
           
          ElseIf GetVar(bstack, W$, v) Then
            
                If IsStrExp(stripstack1, rest$, ss$) Then CheckVarGroup stripstack1, var(v), ss$
                
                If Final Then
                    Set var(v) = New Constant
                    var(v).DefineOnce ss$
                End If
            ElseIf IsStrExp(stripstack1, rest$, ss$) Then   ' when we do global a : set group a {k$="something"}

                CheckVarGroup stripstack1, var(globalvarEmpty(W$)), ss$
                
                
            End If
    Else
           If alocal Then
                If IsStrExp(stripstack1, rest$, ss$) Then GoTo contStr1
           ElseIf GetlocalVar(W$, v) Then
                If IsStrExp(stripstack1, rest$, ss$) Then CheckVar var(v), ss$
            ElseIf IsStrExp(stripstack1, rest$, ss$) Then
contStr1:
            
            If Not stripstack1.lastobj Is Nothing Then
                                         If TypeOf stripstack1.lastobj Is lambda Then
                                         If Glob Then
                                         v = globalvarEmpty(W$)
                                         Else
                                         v = globalvarEmpty(here$ + "." + W$)
                                         End If
                                CheckVarGroup stripstack1, var(v), ss$, Final
                                '         v = globalvar(w$, Empty)
                                'Set var(v) = stripstack1.lastobj
                              '  Set stripstack1.lastobj = Nothing
                               LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                 If here$ = vbNullString Or Glob Then
                                                GlobalSub W$ + "()", "", bstack.GroupName, , v
                                            Else
                                            
                                                GlobalSub here$ + "." + W$ + "()", "", here$ + "." + bstack.GroupName, , v
                                            End If

                                             OvarnameLen = varhash.count + 1
                                             ElseIf TypeOf stripstack1.lastobj Is Group Then
                                             ' here

                                             Set myobject = stripstack1.lastobj
                                             W$ = Replace(W$, "$", "")
                                             
                                       v = globalvar(W$, p)
againgroupstr:
                                               LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                               'nm$ = Left$(nm$, Len(nm$) - 1)
                                               
                                               
                                              If nm$ <> "" Then
                        UnFloatGroup stripstack1, ohere$ + "." + nm$, v, myobject
                        ElseIf Len(stripstack1.UseGroupname) = 0 Then
                        UnFloatGroup stripstack1, W$, v, myobject
                        Else
                        UnFloatGroup stripstack1, bstack.GroupName + Mid$(W$, Len(ohere$ + ". ")), v, myobject
                        End If
                        
                  
                        OvarnameLen = varhash.count + 1  'we record ...
                                Set stripstack1.lastobj = Nothing
                                Set stripstack1 = New basetask
                                bstack.CopyStrip stripstack1
                        If nm$ = vbNullString Then

                                GoTo continuehere
                        End If
                         If FastSymbol(rest$, ",") Then
                         j = IsLabelA(here$, rest$, nm$)
                        If (j And 3) <> 0 Then
                        'If (IsLabelA(here$, rest$, nm$) And 3) <> 0 Then
                        nm$ = Replace(nm$, "$", "")
                                    If uni Then
                            Else
                                If prv Then nm$ = ChrW(&HFFBF) + nm$
                            End If
                        If j > 4 Then
                            nm$ = Left$(nm$, Len(nm$) - 1)
                            rest$ = Left$(f$, Len(f$) - 1) + rest$
                            v = 3
                            W$ = nm$
                            GoTo VarOnly
                            Else
                        frm$ = ohere$ + "." + nm$
                            If here$ = vbNullString Then
                                If Not GetVar(stripstack1, frm$, v) Then v = globalvar(frm$, p)   ': GetVar bstack, nm$, v
                            Else
                                If Not GetlocalVar(frm$, v) Then v = globalvar(frm$, p) ': GetlocalVar W$, v
                            End If
                            frm$ = vbNullString
                             
                            GoTo againgroupstr
                            End If
                        Else
                            SyntaxError
                            Exit Do
                        End If
                    End If
                    Set stripstack1.lastobj = Nothing
                    Set stripstack1 = New basetask
                    bstack.CopyStrip stripstack1
                    GoTo continuehere
                        
                        
                                             Else
                                     NoValueForVar W$
                       End If
               Else
                
                v = globalvar(W$, ss$)
                If Final Then
                Set var(v) = New Constant
                var(v).DefineOnce ss$
                End If
            End If
            End If
            End If
    End If
Else
' NO VALUE IS OK
If Not GetlocalVar(W$, v) Then
                v = globalvar(W$, ss$)
                        If Final Then
        If MyIsObject(var(v)) Then
        If Not TypeOf var(v) Is Constant Then MyEr "No Constant, it is an object", "Äåí Ý÷ù óôáèåñÞ, áëëÜ áíôéêåßìåíï": Exit Function
        Else
        Set var(v) = New Constant
        End If
        Else
                var(v) = vbNullString
        End If
        

            End If
End If
Case 4
    p = 0#
If Glob Then
     v = globalvar(W$, Round(p, 0), , True)
     If Final Then
                    
                    Set var(v) = New Constant
                    var(v).DefineOnce Round(p, 0)
                
     End If
ElseIf here$ = vbNullString Then
If Not GetVar(bstack, W$, v) Then v = globalvar(W$, p) '': GetVar bstack, W$, v
Else
If alocal Then
 v = globalvar(W$, p)
Else
If Not GetlocalVar(W$, v) Then v = globalvar(W$, p) '': GetlocalVar W$, v
End If
        If Final Then
        If MyIsObject(var(v)) Then
        If Not TypeOf var(v) Is Constant Then MyEr "No Constant, it is an object", "Äåí Ý÷ù óôáèåñÞ, áëëÜ áíôéêåßìåíï": Exit Function
        Else
        Set var(v) = New Constant
        End If
        End If
End If
ss$ = vbNullString
        I = MyTrimL(rest$)
                If InStr("/*-+=~^&|<>", Mid$(rest$, I, 1)) > 0 Then
                    If InStr("/*-+=~^&|<>!", Mid$(rest$, I + 1, 1)) > 0 Then
                        ss$ = Mid$(rest$, I, 2)
                        If ss$ = "=&" Then
                        ss$ = "="
                        Mid$(rest$, I, 1) = " "
                        Else
                        Mid$(rest$, I, 2) = "  "
                        End If
                    Else
                        ss$ = Mid$(rest$, I, 1)
                        Mid$(rest$, I, 1) = " "
                    End If
                If ss$ <> "=" And ss$ <> "" Then
                    NoThatOperator ss$
                    ExecuteGroupStruct = 0
                    Exit Function
                End If
                Else
                    
                End If


            If ss$ = "=" Then
                If IsExp(stripstack1, rest$, p) Then
                If MyIsObject(var(v)) Then
                If TypeOf var(v) Is Constant Then
                  var(v).DefineOnce MyRound(p)
                
                End If
                Else
                 var(v) = MyRound(p)
                 End If
                If Err.Number = 6 Then ExecuteGroupStruct = 0:   Exit Function

                Else
                      If LastErNum <> -2 Then NoValueForVar W$
                      ExecuteGroupStruct = 0
                      Exit Function

            
            End If
End If
GoTo continuehere
Case 5
If Final Then
rest$ = Mid$(W$, Len(ohere$) + 2) + rest$
W$ = "DIM"
GoTo contVar
End If
    If neoGetArray(stripstack1, W$, pppp, , Glob) Then
        If Not NeoGetArrayItem(pppp, stripstack1, W$, v, rest$) Then ExecuteGroupStruct = 0:  Exit Function
        On Error Resume Next
JUMPHERE:
        If Not FastSymbol(rest$, "=", True) Then
        SyntaxError
           ExecuteGroupStruct = 0: Exit Function
        End If
        Set myobject = Nothing
        If pppp.Arr Then
        If GetData(stripstack1, rest$, myobject) Then
            FeedArray pppp, v, myobject
        Else
            ExecuteGroupStruct = 0: Exit Function
        End If
        Else
           SyntaxError
           ExecuteGroupStruct = 0: Exit Function
        End If
        lcl = False
    Else
        MyEr "Can't find array " + W$ + ")", "Äåí âñßóêù ðßíáêá " + W$ + ")"
        ExecuteGroupStruct = 0:   Exit Function
    End If
GoTo continuehere
Case 6
If Final Then
rest$ = Mid$(W$, Len(ohere$) + 2) + rest$
W$ = "DIM"
GoTo contVar
End If
If neoGetArray(stripstack1, W$, pppp, , Glob) Then
If Not NeoGetArrayItem(pppp, stripstack1, W$, v, rest$) Then ExecuteGroupStruct = 0:   Exit Function
    On Error Resume Next
    GoTo JUMPHERE
Else
ExecuteGroupStruct = 0:   Exit Function
End If
Case 7
If Final Then
rest$ = Mid$(W$, Len(ohere$) + 2) + rest$
W$ = "DIM"
GoTo contVar
End If
If neoGetArray(stripstack1, W$, pppp, , Glob) Then
If Not NeoGetArrayItem(pppp, stripstack1, W$, v, rest$) Then ExecuteGroupStruct = 0:   Exit Function
On Error Resume Next
If Not FastSymbol(rest$, "=") Then ExecuteGroupStruct = 0: Exit Function
If Not IsExp(stripstack1, rest$, p) Then ExecuteGroupStruct = 0: Exit Function
p = MyRound(p)
If Err.Number > 0 Then ExecuteGroupStruct = 0: Exit Function
pppp.item(v) = p
Do While FastSymbol(rest$, ",")
If pppp.UpperMonoLimit > v Then
v = v + 1
If Not IsExp(stripstack1, rest$, p) Then ExecuteGroupStruct = 0: Exit Function
pppp.item(v) = MyRound(p)
Else
Exit Do
End If
Loop
Else
ExecuteGroupStruct = 0: Exit Function
End If
GoTo continuehere
Case Else

If MaybeIsSymbol(rest$, ",-+*/_!@()[];<>|~`") Then
SyntaxError
ExecuteGroupStruct = 0
Exit Function
End If
End Select
End Select
continuehere:
''\\\\\\\\\\\\\\\\

LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni

continuehere22:
If lookOne(rest$, "}") Then

ExecuteGroupStruct = 1
Exit Do
End If
If Not FastSymbol(rest$, ",") Then
Final = False
SetNextLine rest$
lcl = False
End If
ExecuteGroupStruct = 1
Loop Until Trim$(rest$) = vbNullString
End Function
Function uniondata(bstackstr As basetask, A$, r$) As Boolean
Dim w3 As Long, many As Integer, leng As Long, I As Long, s As String, p
Dim buf$()
I = -1
Do
    I = I + 1
    If Len(aheadstatus(A$, False, I)) Then many = many + 1 Else Exit Do
   ' Debug.Print Mid$(a$, i, 30)
    Select Case Mid$(A$, I, 1)
    Case ")"
        Exit Do
    Case ","

    Case Else
        many = 0: Exit Do
    End Select
Loop
If many = 0 Then
    uniondata = FastSymbol(A$, ")", True)
    Exit Function
Exit Function
End If
ReDim buf$(many - 1)
many = 0
Do
  If IsExp(bstackstr, A$, p, , True) Then
    If VarType(p) = vbString Then
        s = p
    Else
        w3 = UINT(p)
        If w3 >= &H10000 And w3 <= &H10FFFF Then
            w3 = w3 - &H10000
            s = ChrW(UINT(w3 \ &H400& + &HD800&)) + ChrW(UINT((w3 And &H3FF&) + &HDC00&))
        Else
            s = ChrW$(w3)
        End If
    End If
  ElseIf Not IsStrExp(bstackstr, A$, s, False) Then
    s = ChrW(0)
  End If
  
  buf$(many) = s
  leng = leng + LenB(s)
  many = many + 1
  Loop Until Not FastSymbol(A$, ",") Or A$ = vbNullString
  
  If leng = 0 Then
    uniondata = FastSymbol(A$, ")", True)
    Exit Function
  End If
  If leng Mod 2 = 1 Then
    r$ = StrConv(String$(leng, Chr(0)), vbFromUnicode)
  Else
    r$ = space$(leng \ 2)
  End If
  w3 = 1
  If FastSymbol(A$, ")", True) Then
  For I = 0 To many - 1
    leng = LenB(buf$(I))
    MidB$(r$, w3, leng) = buf$(I)
    w3 = w3 + leng
  Next I
  uniondata = True
  End If
End Function
Function grabfrm$()
    If AVIUP Then
        If MediaPlayer1.MovieHeight > 0 Then
            grabfrm$ = GrabFrame
        End If
    End If
End Function
Function StrToArray(bstackstr As basetask, A$, r$) As Boolean
    Dim p, q$, usehandler As mHandler, pppp As mArray, anything As Object
    If IsStrExp(bstackstr, A$, q$, False) Then
        If FastSymbol(A$, ",") Then
            If IsStrExp(bstackstr, A$, r$, False) Then
                If FastSymbol(A$, ",") Then
                    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                        p = Abs(Fix(p))
                        Set usehandler = GETarrayFROMstr(q$, r$)
                        Set pppp = usehandler.objref
                        Set usehandler = Nothing
                        r$ = pppp.item(CLng(p - 1))
                        Set pppp = Nothing
                    Else
                        MissNumExpr
                        Set anything = Nothing
                        Exit Function
                    End If
                Else
                Set usehandler = GETarrayFROMstr(q$, r$)
                
                
                If FastSymbol(A$, ")(", , 2) Then
                    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                        p = Abs(Fix(p))
                        Set pppp = usehandler.objref
                        r$ = pppp.item(CLng(p))
                        Set pppp = Nothing
                    Else
                        Set bstackstr.lastobj = usehandler
                        Set usehandler = Nothing
                    End If
                Else
                    Set bstackstr.lastobj = usehandler
                    Set usehandler = Nothing
                    
                    
                r$ = vbNullString
                End If
                ' RETURN ARRAY
                End If
            Else
                MissStringExpr
                Exit Function
            End If
        Else
            MissPar
            Exit Function
        End If
    Else
        MissStringExpr
        Exit Function
    End If
StrToArray = FastSymbol(A$, ")", True)
End Function
Sub errOutOfLimit()
    MyEr "Index out of limits", "Ï äåßêôçò åßíáé åêôüò ïñßùí"
End Sub
Private Function fixthis(p As Variant) As String
        If TypeOf p Is cxComplex Then
            If p.I = 0 Then
                fixthis = fixthis(CVar(p.r))
            ElseIf p.r = 0 Then
                fixthis = "(" & fixthis(CVar(p.I)) & "i)"
            Else
                If p.I < 0 Then fixthis = "" Else fixthis = "+"
                If Abs(p.I) = 1 Then
                    If p.I < 0 Then
                        fixthis = "(" & fixthis(CVar(p.r)) & "-i)"
                    Else
                        fixthis = "(" & fixthis(CVar(p.r)) & "+i)"
                    End If
                Else
                    fixthis = "(" & fixthis(CVar(p.r)) & fixthis & fixthis(CVar(p.I)) & "i)"
                End If
            End If
        ElseIf MemInt(VarPtr(p)) = vbDate Then
            fixthis = FormatDateWithLocale(GetlocaleString2(&H1F, Clid), CDate(p), Clid)
        Else
            fixthis = LTrim$(str(p))
            If Left$(fixthis, 1) = "." Then
            fixthis = "0" + fixthis
            ElseIf Left$(fixthis, 2) = "-." Then
            fixthis = "-0" + Mid$(fixthis, 2)
            End If
            If InStr(fixthis, ".") > 0 Then
            If NoUseDec Then fixthis = Replace(fixthis, ".", NowDec$)
            End If
        End If
End Function
