MODULE A {Superclass alfa {
      Unique:
            counter=1
      Public:
            Value {
                  For SuperClass {
                        =.counter
                        .counter++
                  }
            }
            Module Reset (x){
                  For SuperClass {
                        .counter<=x
                  }
            }
}
a=alfa
b=alfa
Print a=1, b=2, a=3, a=4, b=5 ' true true true true true
\\ we have to use group(a) to get the group not the value
\\ we use ( ) to get a copy
z->(group(a))
Print eval(z)=6, a=7, b=8, eval(z)=9 ' true true true true
z=>Reset 100
Print eval(z)=100, a=101, b=102, eval(z)=103 ' true true true true
For z {
      .Reset 10
}
Print eval(z)=10, a=11, b=12, eval(z)=13 ' true true true true
}
MODULE GEORGE {Binary {
      /9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQIBAQEBAQIB
      AQECAgICAgICAgIDAwQDAwMDAwICAwQDAwQEBAQEAgMFBQQEBQQEBAT/2wBDAQEB
      AQEBAQIBAQIEAwIDBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE
      BAQEBAQEBAQEBAQEBAT/wAARCABQAFADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEA
      AAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIh
      MUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6
      Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZ
      mqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx
      8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREA
      AgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAV
      YnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hp
      anN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPE
      xcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD+
      2GymJXCnLLzjJAOP6/410FtdEZUsM5yFAIzzgnP51zdqrfKT24xnBOOn9K2IA2VY
      KAMfeAyOuOfyrdSqJaLc3ioydt/vOkiutqBjkcZPzdc9K+fPjN+2D+z7+z3byj4o
      /ErQ9D1GOMSjw9DIdW8ROGVmU/Y4Q0gBCk7nCjpyK8N/b8/aP8R/s7fBaC6+H8LX
      nxU+I/iOHwH8O7eO2W+nsriaKWe6vxCQVb7NbwSsu8FBK8O7KkivzW/Z1/4J8weO
      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
} As A

Gradient 13,5
ImgRenderX=scale.x div 2
For ImgRenderX=ImgRenderX to ImgRenderX/4 step 150
	TopMargin=(scale.y-(ImgRenderX)*image.y(A)/image.x(A)) div 2
	LeftMargin=(scale.x-ImgRenderX) div 2
	move LeftMargin, TopMargin
	Image A, ImgRenderX
Next
cursor 12, height-2
Writer
Escape Off
while mouse=0 and inkey$=""
	refresh
End While
Escape On
cls 
}
MODULE B {\\ m is an auto array (a tuple)
\\ z is an iterator of m
m=(1,2) : Print valid(m^)=false ' bug return valid(m^)=true
z=each(m): Print Valid(z^)=true
}
MODULE C {dim a(), b()
a()=(1,2,3)
b()=(3,2,1)
for i=0 to 2
print max(a(i), b(i)), max(b(i), a(i))
print min(a(i),b(i)), min(b(i), a(i))
print compare(a(i), b(i)), a(i), b(i)
next i


dim a()
a()=(1,2,3)
for i=0 to 2
print max(a(2-i), a(i)), max(a(2-i), a(i))
print min(a(2-i),a(i)), min(a(2-i), a(i))
print compare(a(i), a(2-i)), a(2-i), a(i)
next i
}
MODULE B1 {Module ViewStatic  {
      static Img1, tempo=1, gx=3, gy=5
      ? tempo, gx, gy
      tempo++
      gx++
      gy++
}
clear
for i=1 to 10
	ViewStatic
next   
clear
}
MODULE BB {Print "check mouse buttons"
Print "Press Esc to exit"
m=false
Every 100 {
if mouse.key then { m=true } else m=false
print not m
}
}
MODULE BB1 {Print "press mouse button"
a=mouse
while not a {a=mouse: print a ,  not -a}
? "ok"
}
MODULE D {\\ Identifiers in Greek language
\\ see DR for the same program with statements in English language

\\ [] return the pointer of last current stack, and leave an empty current stack
? "The Greek Version - Statements/Messages in Greek language"
Τμήμα Λατινικοί_Αριθμοί {
      Άδειασε
      Διαμέσου Αρχικοποίηση
      Έγγραφο Εγγ$
      Ενώ όχι κενό
            Διάβασε λατ$
            Τύπωσε λατ$;"=";ΤιμήΛατινικού$(λατ$)
            Εγγ$=λατ$+"="+ΤιμήΛατινικού$(λατ$)+{
            }
      Τέλος Ενώ
      Πρόχειρο Εγγ$
      Τέλος
Αρχικοποίηση:
      Συνάρτηση ΤιμήΛατινικού$(λατ$) {
            Άδειασε
             ="άκυρο"
            Αν Φίλτρο$(λατ$,"MDCLXVI")<>"" Τότε Έξοδος
            \\ θα μπουν ανάποδα, το τελευταίο πρώτο.
            Βάλε "CM", "MD", "Q","CD", "MD","W", "XC", "DL", "E","XL", "X","R", "IX","V","T", "IV","I","Y"
            διπλό_λατινικό=[]
            \\ θα μπουν με το τελευταίο να είναι τελευταίο.
            Σειρά "M", 1000, "Q",900,"D", 500,"W", 400,"C",100,"E",90, "L",50,"R", 40,"X", 10, "T", 9, "V", 5, "Y", 4, "I",1
            απλό_λατινικό=[]
            σύνολο=0
            μια_τιμή=0
            μετρητής=0
            Σωρός διπλό_λατινικό {
                  Αν κενό Τότε Έξοδος
                  Διάβασε απ$, μη_έγγυροι_χαρακτήρες$,χαρακτ$
                  ι=Θέση(λατ$,χαρακτ$)
                  Αν ι >0 Τότε
                        προσωρινή_τιμή$=Μεσ$(λατ$,ι+2)
                        λ=Μήκος(προσωρινή_τιμή$)
                        Αν λ>0 Τότε Αν Μήκος(Φίλτρο$(προσωρινή_τιμή$, μη_έγγυροι_χαρακτήρες$))<>λ Τότε λατ$="A": Έξοδος
                        Αν Θέση(λατ$,Μεσ$(λατ$,ι,1))<ι Τότε λατ$="A": Έξοδος
                        insert ι, 2 λατ$=απ$ '  2 λέμε αλλα δίνουμε 1 χαρακτήρα και ο μεταφραστής θα βάλει ένα διάστημα 
                  Τέλος Αν
                  Κυκλικά
            }
            λατ$=Φίλτρο$(λατ$," ")
            Σωρός απλό_λατινικό {
                  Αν κενό Τότε Έξοδος
                  Διάβασε χαρακτ$, μια_τιμή
                  μετρητής=0
                  Ενώ Αρισ$(λατ$,1)=χαρακτ$
                         Παρεμβολή 1, 1 λατ$=""
                         μετρητής++
                         σύνολο+=μια_τιμή
                  Τέλος Ενώ
                  Αν μετρητής>3 Τότε έξοδος
                  Κυκλικά
            }
            Αν Μήκος(λατ$)>0 ή μετρητής>3 Αλλιώς
            =Γραφή$(σύνολο,1033)
            Τέλος Αν
      }
      Σειρά "MMMCMXCIX", "LXXIIX", "MMXVII", "LXXIX", "CXCIX","MCMXCIX","MMMDCCCLXXXVIII"
      Σειρά "CMXI","M","MCDXLIV","CCCC","IXV", "XLIXL","LXXIIX","IVM"
      Σειρά "XXXIX", "XXXX", "XIXX","IVI", "XLIX","XCIX","XCIV","XLVIII"
      Επιστροφή
}
Λατινικοί_Αριθμοί
}
MODULE DD {Print "A structure in a Class"
class beta {
      structure alfa1 {
            a as long*4
            b as long*4
      }
      structure alfa {
            a as long*4
            b as long*4
            c as alfa1*3
      }
      buffer delta as alfa*3
}
beta=beta()
Print "Offset b in structure alfa"
Print beta.alfa("b")
list
}
MODULE DD1 {local group alfa {
      x=10, y%=50, z$="anything here"
      dim M(4)=10
      event alfa {read b}
      document a$="100"
      class allo {
            q=4
      }
      Group M {
            k=10
      }
      function delta {
           
      }
      module kappa {
           
      }
}
testMe()
Print "After the call"
List !
Modules ?

End
Sub testMe()
Print "Create a second alfa group, hidding the old one"
local group alfa {
      x=10, y%=50,z$="anything here"
      dim M(4)=10
      event alfa {read b}
      document a$="100"
      class allo {
            q=4
      }
      Group M {
            k=10
      }
      function delta {
           
      }
      module kappa {
           
      }
}
List !
Modules ?
End Sub

}
MODULE DD2 {Print "Make some constant lambda functions"
const b=lambda->100
const b%=lambda->100
const b$=lambda$->"hello"
Print b%()
Print b$()
Try ok {
      b=lambda->500
}
if Error or Not ok Then Print Error$
Print b()
}
MODULE DD3 {cursor 0,height-1
Pen 11 {Print "When report stop press space or mouse button"}
Report "Reassign a lambda function in a Group - static link group, we use a unique name of group as local identifier"
Report {
      group alfa {
            x=100
            b=lambda->{
                  =.x
                  .x++
            }
      }
}
\\ this is in a global module A
group alfa {
      x=100
      b=lambda->{
            =.x
            .x++
      }
}
\\ get a copy to alfa
Report {
	We make a beta as a copy of alfa
}
beta=alfa
Print "alfa.b()=";alfa.b()
Print  "beta.b()=";beta.b()
Report {
	Try to change function with a fake one
	function alfa.b {
		=500
	}
}
function alfa.b {
      =500
}
Modules ?
Print "alfa.b()=";alfa.b()

Report {
	 References for functions are strings with code. We get  {CALL EXTERN 3}A.ALFA, but is not the actual hard link. The actual code is in lambda object. 3 is the actual "slot" or index in a var(), an array of variants inside M2000 code where all the variables and this object exist.
}
pen 15 {Report 2,  &alfa.b()}
Report {
	We can make a link of alfa.b() to f() (only for new identifiers). The reference has the same weak reference to the name of group. So we can make a reference if the group has a name (is not keep it by a pointer, or exist in an array or other object like stacks and inventories)
}
Link  alfa.b() to f()
Report {
	This is the function f() code (a reference to a function is actual the code of the function in a string in a block {}). We see two things. One is a line 11001edit which used when an error happen to display the line of the code, and the other is the weak reference of the actual group, which copied by the link statement (a link statement is actual two statements a Push and a Read). We can't assign a second reference.
}
Pen 15 {Report 2,  &f()}
Report  {
	This function can be changed because has no "hard link" with lambda
	All functions except final in groups can be changed:
	function f {
               =500
         }
}

function f {
      =500
}
Print "f()=";f()
Print "alfa.b()=";alfa.b()
Print  "beta.b()=";beta.b()
\\ we can test pointers
\\ there is two type of pointers
\\ 1. pointers to float groups (holded in containers or by pointers)
\\ 2. pointer to named groups (using a weak reference)
\\ this type has no use when referenced group get out of scope
\\ but as all pointers can change value later
\\ pointers can be null, using p->0 but they hold just an empty group
\\ so never a pointer in M2000 has a real null value, but an "empty" one.
Report {
	Reassign a lambda function in a float group -group handled by pointer(s) - no static linked
	We use p->pointer((beta)), is the same as p->(beta)
	Parenthesis used to make the beta a copy as a float group, so we get the pointer to that float group
	Without Parentesis the pointer is a weak reference to beta, so if we pass the pointer as a return value the beta group deleted and the weak reference be invalid. Using the float group, we can move it (like a float object) any where. The float group destroyed when no pointer points to it.
	So the copy we get has the last state of the object, where beta.x is 102.
	We can use -> in place of = for a return value from a function, but we have to use (name_of_group) to return a float group not a reference.
}
\\ p->(beta) is the same as this:
p=pointer((beta)) ' a copy of beta
Print "p=>b()=";p=>b(),"p=>b()="; p=>b()
Print "beta.b()=";beta.b()
\\ p->beta is same as this
Report {
	Now we change p to point to beta, using p=pointer(beta)  same as p->beta  (we use pointer() to pass as an argument, where we can't use ->)
}
p=pointer(beta) ' as reference to beta
Print "p=>b()=";p=>b(),"p=>b()="; p=>b()
Print "beta.b()=";beta.b()
}
MODULE DD4 {Report {
	This example show how to use closures in lambda functions
}
n=lambda ->500
a=lambda n (x)->{
      if x<=0 then=0 : exit
      =lambda(x-1)+x+n()
}
Print a(3)=1506
Print a(10)=5055
n=lambda->100
\\ closures are copies, and are like globals for lambda
Print a(3)=1506
\\ closures can be change only from inside
\\ if they are value types (lambda is a value type)
m=lambda->100
a=lambda n, m (x)->{
      if x>5 then n=lambda ->500
      if x<=0 then=0 : n=m : exit
      =lambda(x-1)+x+n()
}

Print a(3)=306
Print a(10)=1055
\\ touple is an array, can have zero items (,)
\\ or one ore more, and it is a reference type
z=(m,)
Print Function("m")=100
Link z to Z()
Print Z(0)()=100
a=lambda z (x) -> {
      if x<=0 then=0 : exit
      link z to z()
      =lambda(x-1)+x+z(0)()
}
\\ now we change value in z(0), which is the z
Print a(10)=1055
z(0)=lambda->300
\\ so now lambda change because hold a closure to a reference
Print a(10)=3055
Print eval(z)(0)()=300
\\ without using link we can get the first element in 0 posiiton, and ask for function
\\ this function has a life for the moment of call
\\ interpreter just open the lambda object, invoke, and close again.
a=lambda z (x) -> {
      if x<=0 then=0 : exit
      =lambda(x-1)+x+Eval(z)(0)()
}
Print a(10)=3055
}
MODULE DD5 {class a {
      counter as long
}
b=lambda k=pointer(a()) (x)-> {
      k=>counter+=x
      \\ we can return pointers from groups (if they are float type)
      ->k
}
m=b(30)
Print m=>counter=30
\\ get a pointer and convert it to a named group, and then return  a float group (as is, without pointer)
def copy(x as group)=x
group k=b(300)
z=b(300)
Print z=>counter=630
Print m=>counter=630
Print z is m ' false
z->b(300)
Print z is m 'true
Print z=>counter=930
Print k.counter=330 ' old value
}
MODULE DD6 {group beta {
      x$="1000mm"
      m=100
}
\\  beta copied here
inventory alfa=1:=(list:=1,2,300:=(1,2,3,3,5,beta), 500:="ok")

dim g()
\\  beta copied here
g()=(100,beta,(1, (list:=1:=beta,2,"z":=(1,200,3,alfa), "s":="string"), "Hello there"), 500@, "ok")
g(1).m*=100
Print g(1).m=10000
link g() to g$()
Print type$(g(2), 1)="Inventory"
Print type$(g(2), 1!)="List"   ' show type of inventory (list or queue)
Print type$(g(2), 2)="String", g(2)#val$(2)="Hello there"
Print g$(2)(2)="Hello there"    ' using g$() a reference to g()
Print g$(2)(1)("s")="string"
Print g$(2)(1)("z")(3)(1)(500)="ok"
\\ new this also
Print  g(2)(1)("z")(3)(1)(300)(5).m=100 ' multiple object opening until a group object
\\ new this also. we can get a pointer from inner group
n->g(2)(1)("z")(3)(1)(300)(5)
Print n=>m=100
n=>m++ ' increment one
Print g(2)(1)("z")(3)(1)(300)(5).m=101
Print g(2)(1)("z")(3)(1)(300)(5).x$="1000mm"
n=>x$="2000mm"
Print g(2)(1)("z")(3)(1)(300)(5).x$="2000mm"
m=g() ' we get a pointer to array ' these are not the same as the group's pointers
\\ stacks, inventories and arrays (not those we make with Dim) are pointers
\\ we can use IS operator to check two of them if show same object
z=list:=100, 150:=m, 200
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=101
\\ using g() we pass a copy
\\ but anything which is a pointer (like a list, or a pointer to array) only pointer copied
\\ groups may have or may haven't pointers. Those with no pointers copied when we get an array copy.
\\ Only arrays with names with parenthesis copied. So here we get a copy of g().
z=list:=100, 150:=g(), 200
g(1).m+=100
Print g(1).m=10100
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=101 ' group has a pointer/ also list is the same
Print z(150)(1).m=10000 ' group copied
n=>m++
Print z(150)(2)(1)("z")(3)(1)(300)(5).m=102
Print g(2)(1)("z")(3)(1)(300)(5).m=102
}
MODULE DD7 {module Checkit {
      Stack New {
            Data "foo://example.com:8042/over/there?name=ferret#nose", "urn:example:animal:ferret:nose"
            Data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true", "ftp://ftp.is.co.za/rfc/rfc1808.txt"
            Data "http://www.ietf.org/rfc/rfc2396.txt#header1", "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
            Data "mailto:John.Doe@example.com", "news:comp.infosystems.www.servers.unix", "tel:+1-816-555-1212"
            Data "telnet://192.0.2.16:80/", "urn:oasis:names:specification:docbook:dtd:xml:4.1.2", "ssh://alice@example.com"
            Data "https://bob:pass@example.com/place", "http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"
            a=Array([])
      }
      function prechar$(a$, b$) {
            if a$<>"" then {=quote$(b$+a$)} else ={""}
      }
      z=each(a)
      document s$="["+{
      }
      While z {
            a$=array$(z)
            s1$={           "uri": }+quote$(a$)+{,
                  "authority": }+ quote$(string$(a$ as URLAuthority))+{,
                  "userInfo": }+ quote$(string$(a$ as URLUserInfo))+{,
                  "scheme": }+quote$(string$(a$ as URLScheme))+{,
                  "hostname": }+quote$(string$(a$ as UrlHost))+{,
                  "Port": }+quote$(string$(a$ as UrlPort))+{,
                  "pathname": }+quote$(string$(a$ as UrlPath))+{,
                  "search": }+prechar$(string$(a$ as URLpart 6),"?")+{,
                  "hash": }+prechar$(string$(a$ as UrlFragment),"#")+{
            }
            s$="     {"+{
            }+s1$+"     }"
            \\ z^ is the iteraror's counter (z is an iterator of a, a touple - array in M2000)
            if z^<len(a)-1 then s$=" ,"   ' append to document
            s$={
            }
      }
      s$="]"
      Print "Press any keyboard key or mouse key to continue scrolling"
      Report s$   
      Clipboard s$
}
Checkit
}
MODULE DD8 {Module Pairs {
      \\ using Gdi+ antialiasing (not work with Wine in Linux, but we get no error)
      smooth on
      Const center=2, right=3, left=1, blue=1, angle=0, dotline=3
      Const size9pt=9, size11pt=11
      Cls ,0 ' use current background color, set split screen from line 0
      Cursor 0,3
      Report center, "Coordinate pairs"
      x = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
      y = (2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0)
      dx=scale.x/2/len(x)
      dy=dx 'ratio 1:1
      graH=dy*len(x)
      Basex=scale.x/4
      Basey=(scale.y+graH)/2
      Move Basex, Basey
      \\ draw use relative coordinates
      Draw 0,-graH
      \\ Step just move graphic cursor
      Step 0, graH
      Draw scale.x/2, 0
      Step -scale.x/2, 0
      \\ scX is 1, not used
      max=Y#max()
      \\ Auto scale for Y, using 0 for start of axis Y
      scY=-graH/((max+5^log(max) ) div 100)/100
      \\ make vertical axis using dots with numbers center per dx
      j=1
      For i=basex+dx to basex+dx*x#max() Step dx
            Move i, basey
            Step 0, twipsy*10
            Legend format$("{0}",array(x,j)), "courier", size9pt, angle, center
            Width 1, dotline { draw 0, -graH-twipsy*10,7}
            j++
      Next i
      \\ the same for horizontal axis
      HalfTextHeight=Size.y("1","courier", size9pt)/2
      For i=basey-dy to basey-dy*x#max() Step dy
            Move basex, i
            Step -twipsx*10
            Width 1, dotline { draw scale.x/2+twipsx*10,,7}
            Move basex-100, i+HalfTextHeight
            Legend format$("{0}",(i-basey)/scY), "courier", size9pt, angle, left
      Next i
      ex=each(x) : ey=each(y)
     \\ start from first point. We use Draw to for absolute coordinates
      Move array(x,0)*dx+Basex, array(y,0)*scy+Basey
      While ex, ey {
            Width 2 {
                  Draw to array(ex)*dx+Basex, array(ey)*scy+Basey, blue
            }
      }
      \\ second pass for marks and labels
      ex=each(x) : ey=each(y)
      While ex, ey {
            Move array(ex)*dx+Basex, array(ey)*scy+Basey
            Step -75, -75
            Pen 12 {draw 150: draw 0,150 : draw -150 : draw 0,-150}
            Pen 13 {
                  Step 200, -200
                  Legend format$("({0}-{1})",array(ex),array(ey) ), "courier bold", size11pt, angle, right
            }
      }
      \\ screenshot to clipboard
      Screenshot$=""
      Move 0,0
      Copy scale.x, scale.y to Screenshot$
      Clipboard Screenshot$
      a$=key$
}
Pairs
}
MODULE DD8GRNEW {\\ Like DD8 but better
\\ Using Greek identifiers
\\ we get the pairs and then short them
\\ Also the first array X may have now spaces more than one (look second χ=(,,,,))
\\ Now we can use negatives in second array so a ψ-=100 make some under zero.
\\ For X we get always the lower value as the first value in X-axis.
\\ For Y we make a first value according to the lower
\\ also we can make narrow the graph changing the ΖουμΧ value (2 for half the width of console screen)
Τμήμα Ζεύγη_Τιμών {
      Ομαλά όχι
      Σταθερές κέντρο=2, δεξιά=3, αριστερά=1, μπλε=1, γωνία=0, γραμμή_με_τελίτσες=3
      Σταθερές μέγεθος_12pt=12, μέγεθος_11pt=11, ΑπόσταστηΑριθμών=10
      Οθόνη ,0
      Δρομέας 0,1
      Διπλά
      Αναφορά κέντρο, "Γράφημα: Ζεύγη Τιμών"
      Κανονικά
      Άδειασε
      χ=(0,1,2,3,4,5,6,7,8,9)
Σημ    χ=(1,2,3,4,5,6,9,10, 15,19)
Σημ      χ+=10  \\ αύξηση κατά 10
Σημ      χ*=3   \\ πολλαπλασιασμός επί 3, άρα το τελευταίο ειναι στο 29*3=87
      Σειρά ! χ
      ψ= (2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0)
Σημ      ψ-=100
Σημ      ψ*=40
      μέγιστο=ψ#μεγ()
      ελάχιστο=ψ#μικ()
      Σειρα ! ψ
      \\ Μοιράζουμε τα στοιχεία της τελευταίας σειράς που μπήκε
      \\ πίσω από το καθένα της πρώτης.
      Μ=Μέγεθος.Σωρού δια 2
      Για ι=0 εως Μ-1 : ΦέρεΠίσω Μ+ι : Επόμενο
      \\ Μαζεύουμε τα ζεύγη στα Α(ι,0) κα Α(ι,1)
      Πίνακας Βάση 0,  Α(10,2)
      Μ--
      Για ι=0 εως Μ: Διάβασε Α(ι,0), Α(ι,1) : Επόμενο
      \\ Τώρα τα ταξινομούμε ώστε να είμαστε σίγουροι ότι
      \\ στο Α(Μ,0) έχουμε το μεγαλύτερο και στο Α(0,0) το μικρότερο
      \\ (για τον Χ άξονα)
      Ταξινόμηση Α(), 0, Μ, 0,0
          
      ΕύροςΤιμώνΧ=Α(Μ,0)-Α(0,0)
      ΒάσηΤιμώνΧ=Α(0,0)
      μέρη=ΕύροςΤιμώνΧ  'Αν(ΕύροςΤιμώνΧ<10->10,ΕύροςΤιμώνΧ)
      κλΧ=1
      Αν μέρη>15 τότε
            κλΧ=ΕύροςΤιμώνΧ δια 15 : μέρη=Στρογγ(ΕύροςΤιμώνΧ/κλχ+.5,0)
      Αλλιώς
            κλΧ=ΕύροςΤιμώνΧ / μέρη:
      Τέλος Αν
      ΖουμΧ=1.2
      δχ=χ.σημεία/ΖουμΧ/(μέρη+δεκ(κλΧ))
      δψ=υ.σημεία/1.5/10
      βαθμόςΥ=δψ*10
      ΒάσηΧ=(χ.σημεία-χ.σημεία/ΖουμΧ)/2
      ΒάσηΥ=(υ.σημεία+βαθμόςΥ)/2
      Θέση ΒάσηΧ, ΒάσηΥ
      Χάραξε 0,-βαθμόςΥ
      Βήμα 0, βαθμόςΥ
      Βήμα χ.σημεία/ΖουμΧ, 0
      Χάραξε -χ.σημεία/ΖουμΧ, 0
      κανε αα(μέγιστο, κάτω=0, Ν=50)=ΑΝ(μέγιστο=0->0, Ν*(((μέγιστο+2^Λογ(Απολ(μέγιστο)) ) διά Ν)-(μέγιστο>0)-κάτω))
      \\ άλαξε το 100 με το 50 ή το 500
      μέγιστο=αα(μέγιστο,,100)
      ελάχιστο=αα(ελάχιστο,1,100)
      κλψ=-βαθμόςΥ/(μέγιστο-ελάχιστο)


      \\Φτιάχνουμε οριζόντιους γραμμές με τελίτσες ανά δχ
      \\ Το ύψος.σημείου είναι ο αριθμός σε twips του ύψους ενός σημείου στο μέσο που γράφουμε
      \\ αν στην οθόνη έχουμε 96dpi, τότε έχουμε σε 1 ίντσα, 1440 twips, ή 96 σημεία,
      \\ άρα κάθε σημείο θα έχει 1440/96 = 15 twips
      \\ και πράγματι τόσο είναι το Ύψος.Σημείου σε 96dpi. Όμως μπορεί να έχουμε οθόνη με διαφορετικά dpi.
      \\ Αν θέλουμε να μετρήσουμε αποστάσεις βάσει σημείων πρέπει να πολλαπλασιάζουμε με τον αριθμό
      \\ των twips ανά σημείο. Ορισμένες φορές μπορεί να μην έχουμε τετράγωνο σημείο, δηλαδή να διαφέρουν
      \\ τα  Ύψος.Σημείου με Πλάτος.Σημείου. Για το λόγο αυτό χρησιμοποιούμε και τα δύο.
      κ=1
      τ=ΒάσηΤιμώνΧ
      δτ=κλΧ
      αν δτ=0 τότε δτ=1

      Πενα 15 {
            Για ι=ΒάσηΧ έως ΒάσηΧ+δχ*μέρη Ανά δχ
                  Θέση ι, ΒάσηΥ
                  Βήμα 0, Ύψος.Σημείου*(10+ΑπόσταστηΑριθμών)
                  Επιγραφή μορφή$("{0}",τ), "courier new", μέγεθος_12pt, γωνία, κέντρο
                  Βήμα 0, -Ύψος.Σημείου*ΑπόσταστηΑριθμών
                  Αν ι>ΒάσηΧ Τότε Πάχος 1, γραμμή_με_τελίτσες { Χάραξε 0, -βαθμόςΥ-Ύψος.Σημείου*10,7}
                  κ++ : τ+=δτ
            Επόμενο
      }
      \\ φτιάχνουμε κάθετες γραμμές ανά δψ
      ΜισόΎψοςΚειμένου=Μέγεθος.Υ("1","courier new", μέγεθος_12pt)/2
      ΣτόχοςΥ=ΒάσηΥ-δψ*10
      Πένα 15 {
            Για ι=ΒάσηΥ έως ΣτόχοςΥ Ανά δψ
                  Θέση ΒάσηΧ, ι
                  Βήμα -Πλάτος.σημείου*10
                  Αν ι<ΒάσηΥ Τότε Πάχος 1, γραμμή_με_τελίτσες { Χάραξε χ.σημεία/ΖουμΧ+Πλάτος.σημείου*10,,7}
                  Θέση ΒάσηΧ-Πλάτος.Σημείου*(4+ΑπόσταστηΑριθμών), ι+ΜισόΎψοςΚειμένου
                  Επιγραφή μορφή$("{0}",(ι-ΒάσηΥ)/κλΨ+ελάχιστο), "courier new", μέγεθος_12pt, γωνία, αριστερά
            Επόμενο
      }
      
      \\ Τώρα χαράζουμε μια γραμμή που θα περάσει από όλα τα σημεία
      \\ με την Χάραξε Έως δίνουμε απόλυτες συντεταγμένες (χωρίς το Έως δίνουμε σχετικές)
      δχ/=κλΧ
      ΒάσηΥ-=ελάχιστο*κλψ
      Θέση ΒάσηΧ, πίνακας(ψ,0)*κλΨ+ΒάσηΥ
      ΒάσηΧ-=Α(0,0)*δχ

      Για ι=0 έως Μ
            Πάχος 2 {
                  Χάραξε έως Α(ι,0)*δΧ+ΒάσηΧ, Α(ι, 1)*κλΨ+ΒάσηΥ, μπλε
            }
      Επόμενο
      \\ Δεύτερο πέρασμα για επιγραφές και σημάδια

      Για ι=0 έως Μ
            Θέση Α(ι,0)*δΧ+ΒάσηΧ, Α(ι, 1)*κλΨ+ΒάσηΥ
            Βήμα -Πλάτος.σημείου*5, -Ύψος.Σημείου*5
            \\ τετράγωνο γύρω από το σημείο
            Πένα 12 {
                  Χάραξε Πλάτος.σημείου*10
                  Χάραξε 0,Ύψος.Σημείου*10
                  Χάραξε -150
                  Χάραξε 0,-Ύψος.Σημείου*10
            }
            Πένα 13 {
                  Βήμα Πλάτος.σημείου*13, -Ύψος.Σημείου*13
                  Επιγραφή μορφή$("{0}|{1}", Α(ι,0), Α(ι,1) ), "courier bold", μέγεθος_11pt, γωνία, δεξιά
            }
      Επόμενο
      Ομαλά Όχι
}
'Ζεύγη_Τιμών
'εξοδος
Σχέδιο Κλίμαξ.Χ, Κλίμαξ.Υ {
	Ζεύγη_Τιμών
} ως Α
Οθόνη,0
Θέση 0,0
Εικόνα Α
Πρόχειρο Α
}
MODULE DD9 {Report {Execute a Clear statement to erase static variables from console. Static variables reduce a bit the speed of interpreter. Except for static varibales in threads, they erased when a thread erased}

a=10
Module Checkit {
      if random(10)=1 then Clear ' erase all statics and variables from this level
      Module Checkit {
            flush
            module Checkit {
                  static k=(Queue:=1,2)
                  Try {
                        Read ? k as queue
                  }
                  Print type$(k)
                  Print k
            }
            group alfa {
                  x=10
            }
            z->(alfa)
            Checkit
            Checkit z
            Checkit (Queue:=1,2,3,1,2,3)
            Checkit (List:=1,2,3)
      }
      Checkit
}
Checkit
Print a ' a exist always
}
MODULE F1 {Report {
	OOP part 1
	We make a group alfa as named group in this module, with a private x variable, and two modules (as methods)
	We check that alfa.x not exist using valid(alfa.x)
}
Group alfa {
      private:
            x=10
      public:
      \\ we can use Print as module name
      Module Print {
            Print .x
      }
      Module IncX {
            .x++
      }
}
alfa.print    ' print 10
Print valid(alfa.x)=false
alfa.incX
alfa.print   ' print 11
}
MODULE F2 {module checkit {
      Report{
             OOP part2
             We make a class b1 which is a function which return a float group (nameless), but not a pointer to a group
             We make b as pointer of a float group (which made by b1() function)
             Just for the example we call beta(), a subroutine, which expect a z idenifier whch not exist
             So we catch this in a Try {} structure
             Now we make Z as pointer of a new float group using z->b1()
             We call sub alfa() using a local b as a predefined pointer to a float group b1().
             If we didin't pass a group or we pass ?, we use b as the predefined
             If we have something else in stack we get error, so before that type of call we have to know what we have in stack or we can use ?
      }
      flush ' we use alfa() with an optional parameter. if stack has wrong type then we get error
      rem push 1  \\ this raise eror in alfa()
      def long counter=0
      class b1 {
            x=10
      }
      \\ b is a pointer to a new group from b1()
      b->b1()
      Try {
            beta()
      }
      Print Error$ ' z not found in scope, we can't use it as pointer
      \\ z is a pointer to a new group from b1()
      z->b1()
      \\ now z exist
      rem {
             alfa(?)  ' use these  if you use the Push 1 (see above)
             beta(?)
      }
      alfa() ' 11 - use of internal pointer to group
      beta() ' 11
      Print b=>x=10 ' true
      alfa(z) ' 12
      alfa(z) '13
      beta() ' 14
      alfa() ' 11  - use of internal pointer to group
      Print b=>x=10 ' true
      alfa(b) '11
      alfa(b) '12
      Print b=>x=12 ' true
      Print z=>x=14
      beta() ' 15
      Print z=>x=15
      Print counter
      Rem Flush ' if you use the Push 1

      Sub alfa()
            \\ we make a local variable b
            \\ we assign a fresh group
            \\ then we read optional a pointer
            local b : b->b1() : Read ? b as pointer
            \\ now we make a second local variable
            \\ we assign a pointer
            local z : z->b
            beta()
      End Sub
      Sub beta()
            \\ increment member x
            z=>x++
            Print z=>x
            \\ subs have same scope as the module from where called
            counter++
      End Sub
}
Checkit
}
MODULE F3 {Module Checkit {
      group alfa {
      x=10
      }
      b->alfa
      checkme(b)
      Print b=>x=10
      Print alfa.x=10
      checkme2(b)
      Print b=>x=11
      Print alfa.x=11
      checkme3(&b)
      Print b=>x=12
      Print alfa.x=12
    
      \\ sub is like End if execution find it
      sub checkme(a as group)
            print type$(a)
            a.x++
            Print a.x
      End sub
      sub checkme2(a as pointer)
            print type$(a)
            a=>x++
            Print a=>x
      End sub
      sub checkme3(&a as pointer)
            print type$(a)
            a=>x++
            Print a=>x
      End sub
}
Checkit
}
MODULE F4 {\\ gosub call subs (subs with () or plain subs)
\\here we call a plain sub which is like we place the lines between label and return in the code where we call it
gosub modules
Report {
	This is a definition for alfa group with one public variable x
	group alfa {
		x=10
	}
}
group alfa {
	x=10
}
Report {
	we make b as pointer to alfa (is a simple reference - is a pointer to a static object)
	static object means named object, which exist until the get out of scope
	
	We have three modules and we call them passing the pointer b
	In each module we increase x value
	
	For first module we pass the b and read it as a group. So we get a new group as a copy
	For second module we pass the b and read it as pointer so we get the change after the call (this is the default if a in module is a new variable)
	For third module we pass the pointer by reference s &b, so we get the change after the call
	
}
b->alfa
checkme b
Print b=>x=10
Print alfa.x=10
checkme2 b
Print b=>x=11
Print alfa.x=11
checkme3 &b
Print b=>x=12
Print alfa.x=12
End
modules:
module checkme {
            Read a as group
            print type$(a)
            a.x++
            Print a.x
}
module checkme2 {
            Read a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Module  checkme3 {
            Read &a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Return
}
MODULE F5 {report {
	Same as F4 but now we use modules not subs
	A module has own scope
	A sub has the scope from where caled
}
flush  '' emprty the stack
gosub modules
group alfa {
x=10
}
b->alfa
\\ also here we can call like checkme ?  where ? means get the default value
\\ but we have to provide the default value before the actual read
\\ the last moduleget a group pointer by reference so we can't provide a default value
checkme
checkme b
Print b=>x=10
Print alfa.x=10
checkme2
checkme2 b
Print b=>x=11
Print alfa.x=11
checkme3 &b
Print b=>x=12
Print alfa.x=12
End
modules:
module checkme {
            group a {
                  x=100
            }
            Read ? a as group
            print type$(a)
            a.x++
            Print a.x
}
module checkme2 {
            group a1 {
                  x=100
            }
            a->a1
            Read ? a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Module  checkme3 {
            Read &a as pointer
            print type$(a)
            a=>x++
            Print a=>x
}
Return


}
MODULE F6 {\\ using static variables
\\ a class function is a global one
\\ from the definition point until the function get out of scope
\\ here the scope is the checkme and for gloabals the checkit module
Module CheckMe {
      Class alfa {
            x=1000
      }
      Global Enum aaa {a,b,c,d}
      \\ use Clear to clear static from level of modules like Checkit
      Rem : Clear
      Module Checkit {
            \\ we can use stacks, arrays, inventories and pointers to groups
            \\ enumerators
            \\ for stacks
            static z=(stack:=1,2), m=(1,2,3,4), k->alfa()
            static b as aaa=a, cc=(List:="a":=100,"b":=500,"c":=200)
            read ? z
            Print k=>x
            k=>x++
            Print z
            Stack z {
                  if isnum then print number
            }
            Print m
            m++
            Return cc, "a":=cc("a")+1
            If Exist(cc,"a") Then Print Eval(cc)
     
      }
      flush  ' empty stack
      Checkit
      Checkit
      Checkit (stack:=5,6,7)
      Checkit
      Checkit
}
CheckMe
Clear  ' clear all static variables
}
MODULE F7 {Report "Using advapi32.SystemFunction036 as external function to make random bytes in a buffer"
Module checkit {
      Declare random1 lib "advapi32.SystemFunction036" {long lpbuffer, long length}
      Buffer Clear Alfa as long*2
      Print Eval(Alfa,0)
      Print Eval(Alfa,1)
      call void random1(alfa(0), 8)
      Print Eval(Alfa,0)
      Print Eval(Alfa,1)
}
checkit
}
MODULE F8 {Report {
	Another example using advapi32.dll to declare three external functions
	We use Constan identifiers at a global level.
	Also the Global scope end when this module exit
}
Declare Global CryptAcquireContext Lib "advapi32.CryptAcquireContextW" {Long &hProv, pszContainer$,pszProvider$, long dwProvType, long dwFlags}
Declare Global CryptReleaseContext Lib "advapi32.CryptReleaseContext" {Long hProv, Long dwFlags}
Declare Global CryptGenRandom Lib"advapi32.CryptGenRandom" {Long hProv, Long dwLen, Long &ByRef}
Global Const PROV_RSA_FULL As Long = 1
Global Const VERIFY_CONTEXT As Long = 0xF0000000&
 
\\ a call to a function can be done like a procedure call (calling a module)
\\ we have to drop the return value, because any value except zero raise an error
\\ we use the clause Void to drop the value

\\ In CryptGenRandom() we pass a Long which is a pointer to a Long variable
\\ So we say to declaration Long &Byref (then name can be anything, but not a string identifier, we wand number)
\\ So when we call the CryptGenRandom() we pass the &Rand  where Rand is long variable (it is a variant of type LONG inside)

 
Function  Random2 {
      Long Rand=0, hProv=0
      Call void CryptAcquireContext(&hProv, "", "", PROV_RSA_FULL, VERIFY_CONTEXT)
      Call Void CryptGenRandom( hProv, 4&, &Rand)
      Call Void CryptReleaseContext(hProv, 0&)
      =Rand
}
m= Random2()
mUnsigned=uint(m)
Print m
Print mUnsigned
Print hex$(mUnsigned, 4)
Print sint(mUnsigned)=m

Print m=eval("0x"+hex$(mUnsigned, 4)+"&")  ' using & at the end we get the signed long 32 bit
Print type$(mUnsigned)
m1=sint(mUnsigned)
Print type$(m1)
m2=binary.and(m1, 0xFF00FF00)
Print type$(m2)
k=0xFF01FF02
Print type$(k)
hex k
k1=Binary.Shift(k,-8)
Print type$(k1)
hex k, k1
k2=Binary.Rotate(k,4)
Print type$(k2)
hex k, k2
\\ binary.add() make the addition of two 32bit numbers and a Mod 2^32,
\\ so always we cut the overflow bit
\\ The type internal is Currency, not a long, but it used in this functions like it is a 32bit value
k3=binary.add(0xFF123456,0xF1234567,0xFFFFFFFF)
Print type$(k3)
hex K3
}
MODULE URL {Report {See also DD7 module which decoding for URI use internal funations
Here we see the decoding using M2000 code (slow)
}
Module checkit {
      document doc$
      any=lambda (z$)->{=lambda z$ (a$)->instr(z$,a$)>0}
      one=lambda (z$)->{=lambda z$ (a$)->z$=a$}
      number$="0123456789"

      series=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        if line$="" then exit
                        k=each(func)
                        def p=0,ok as boolean
                        while k {
                              ok=false : p++ : f=array(k)
                              if not f(mid$(line$,p,1)) then exit
                              ok=true
                        }
                        if ok then res$=left$(line$, p) : line$=mid$(line$, p+1)
                        =ok
                  }
      }

      is_any=lambda series, any (c$) ->series(any(c$))
      is_one=lambda series, one (c$) ->series(one(c$))
      Is_Alpha=series(lambda (a$)-> a$ ~ "[a-zA-Z]")
      Is_digit=series(any(number$))
      Is_hex=any(number$+"abcdefABCDEF")

      optionals=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        k=each(func)
                        def ok as boolean
                        while k {
                              f=array(k)
                              if f(&line$,&res$) then ok=true : exit
                        }
                        =ok
                  }
      }
      repeated=Lambda (func)-> {
                  =lambda func (&line$, &res$)->{
                        def ok as boolean, a$
                        res$=""
                        do {
                              sec=len(line$)
                              if not func(&line$,&a$) then exit
                              res$+=a$
                              ok=true
                        } until line$="" or sec=len(line$)
                        =ok
                  }
      }

      oneAndoptional=lambda (func1, func2) -> {
            =lambda func1, func2 (&line$, &res$)->{
                              def ok as boolean, a$
                              res$=""
                              if not func1(&line$,&res$) then exit
                              if func2(&line$,&a$) then res$+=a$
                              =True
                        }      
      }
      many=Lambda -> {
                  func=Array([])
                  =lambda func (&line$, &res$)->{
                        k=each(func)
                        def p=0,ok as boolean, acc$
                        oldline$=line$
                        while k {
                              ok=false
                              res$=""
                              if line$="" then exit
                              f=array(k)
                              if not f(&line$,&res$) then exit
                              acc$+=res$
                              ok=true
                         }
                        if not ok then {line$=oldline$} else res$=acc$
                        =ok
                  }
      }
      is_safe=series(any("$-_@.&"))
      Is_extra=series(any("!*'(),"+chr$(34)))
      Is_Escape=series(any("%"), is_hex, is_hex)
      \\Is_reserved=series(any("=;/#?: "))
      is_xalpha=optionals(Is_Alpha, is_digit, is_safe, is_extra, is_escape)
      is_xalphas=oneAndoptional(is_xalpha,repeated(is_xalpha))
      is_xpalpha=optionals(is_xalpha, is_one("+"))
      is_xpalphas=oneAndoptional(is_xpalpha,repeated(is_xpalpha))
      Is_ialpha=oneAndoptional(Is_Alpha,repeated(is_xpalphas))
      is_fragmentid=lambda is_xalphas (&lines$, &res$) -> {
            =is_xalphas(&lines$, &res$)
      }
      is_search=oneAndoptional(is_xalphas, repeated(many(series(one("+")),is_xalphas)))
      is_void=lambda (f)-> {
            =lambda f (&oldline$, &res$)-> {
                  line$=oldline$
                  if f(&line$, &res$) then {oldline$=line$ } else res$=""
                  =true
            }
      }
      is_scheme=is_ialpha
      is_path=repeated(oneAndoptional(is_void(is_xpalphas), series(one("/"))))
      is_uri=oneAndoptional(many(is_scheme, series(one(":")), is_path), many(series(one("?")),is_search))
      is_fragmentaddress=oneAndoptional(is_uri, many(series(one("#")),is_fragmentid ))
      
      Flush ' empty the stack of values

      data "foo://example.com:8042/over/there?name=ferret#nose"
      data "urn:example:animal:ferret:nose"
      data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true "
      data "ftp://ftp.is.co.za/rfc/rfc1808.txt"
      data "http://www.ietf.org/rfc/rfc2396.txt#header1"
      data "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
      data "mailto:John.Doe@example.com"
      data "tel:+1-816-555-1212"
      data "telnet://192.0.2.16:80/"
      data "urn:oasis:names:specification:docbook:dtd:xml:4.1.2"

      while not empty {
            read What$
           
            pen 15 {
                  Print(What$)
            }
            a$=""
            If is_scheme(&What$, &a$) Then Print( "Scheme="+a$ ): What$=mid$(What$,2)
            If is_path(&What$, &a$) Then {
                  count=0
                  while left$(a$, 1)="/" { a$=mid$(a$,2): count++}
                  if count>1 then {
                        domain$=leftpart$(a$+"/", "/")
                        if left$(what$,1)=":"  and instr(what$,"@")<instr(what$,"/")  and instr(what$,"@")>0  then
                        username$=domain$
                        Print "uername:"+username$
                        what$=mid$(what$,2)
                        password$=leftpart$(what$,"@")
                        Print "password:"+password$
                        what$=rightpart$(what$,"@")
                        domain$=leftpart$(what$+"/", "/")
                        what$=Rightpart$(what$,"/")
                        end if
                        
                        a$=rightpart$(a$,"/")
                        
                        if domain$<>"" Then Print( "Domain:"+Domain$)
                        if a$<>"" Then Print("Path:"+a$)
                  } else.if left$(What$,1) =":" then {
                        Print( "path:"+a$+What$): What$=""
                  } Else Print("Data:"+ a$)

            }

            if left$(What$,1) =":" then {
                  is_number=repeated(is_digit)
                  What$=mid$(What$,2): If is_number(&What$, &a$) Then Print("Port:"+a$)
                  if not left$(What$,1)="/" then exit
                  If is_path(&What$, &a$) Then {
                        while left$(a$, 1)="/" { a$=mid$(a$,2)}
                        if a$<>"" Then Print("Path:"+a$)
                  }
            }
            if left$(What$, 1)="?" then {
                        What$=mid$(What$,2)
                        If is_search(&What$, &a$) Then {
                        v$=""
                        if left$(What$, 1)="=" then {
                              What$=mid$(What$,2)
                              If is_search(&What$, &v$) Then Print("Query:"+a$+"="+v$)
                        }  else Print("Query:"+a$)
                        }
            }
            While left$(What$, 1)="#"  {
            What$=mid$(What$,2)
            if not is_xalphas(&What$, &a$) Then exit
            Print( "fragment:"+a$)
            }
            if What$<>"" Then print("Data:"+ What$)
      }
      clipboard doc$
      Sub Print(a$)
            print a$
            doc$=a$+{
            }
      End Sub
}
Checkit
}
MODULE T1 {a=(1,2,3,4,5)
Print a#rev()
Print a#sum()=15
Print a#max()=5, a#min()=1
k=-1
L=-1
Print a#max(K)=5, a#min(L)=1
Print K=4 ' 5th position
Print L=0 ' 1st position
Print a#pos(3)=2 ' 3rd position
Print a#val(4)=5
\\ tuples in tuple
a=((1,2),(3,4))
Print a#val(0)#val(1)=2
Print a#val(1)#val(1)=4
a=(1,2,3,4,5,6,7,8,9)
fold1=lambda ->{
      push number+number
}
Print a#fold(fold1)=a#sum()
Print a#fold(fold1,1)=a#sum()+1
even=lambda (x)->x mod 2=0
b=a#filter(even, (,))
Print b ' 2 4 6 8
Print a#filter(even)#fold(fold1)=20
map1=lambda (a)->{
      push a+100
}
c=b#map(map1)
Print c ' 102,103, 104, 105
numbers=lambda p=1 (x) ->{
      push x+p
      p++
}
oldnumbers=numbers ' we get a copy of numbers with p=1
c=c#map(numbers)
Print c ' 103, 106, 109, 112
zfilter=lambda -> number>106
tostring=lambda -> {
      push chrcode$(number)
}
oneline=lambda -> {
             shift 2 ' get second as first
             push letter$+letter$
}
Line$=c#filter(zfilter)#map(tostring)#fold$(oneline,"")
print Line$="mp", chrcode$(109)+chrcode$(112)
zfilter=lambda -> number>200
Line$=""
Line$=c#filter(zfilter)#map(tostring)#fold$(oneline,"")
\\ lines$ can't change value becuse filter has no items to give
Print Line$=""
\\ if we leave a second parameter without value the we get No Value error
Try {
      Line$=c#filter(zfilter, )#map(tostring)#fold$(oneline,"")
}
Print error$=" No value"
\\ second parameter is the alternative source
Line$=c#filter(zfilter,(109,112))#map(tostring)#fold$(oneline,"")
Print Line$="mp"
c=(1,1,0,1,1,1,1,0,1,1,0)
\\ hard insert
Print c#pos(1,0,1) ' 1  means 2nd position
Print c#pos(3->1,0,1) ' 6  means 7th position
\\ using another tuple
Print c#pos((1,0,1)) ' 1  means 2nd position
Print c#pos(3->(1,0,1)) ' 6  means 7th position
t=(1,0,1)
Print c#pos(t) ' 1  means 2nd position
Print c#pos(3->t) ' 6  means 7th position
}
MODULE R1 {Report {Reverse a string holding the right chaacters in order (not reversed)
Using StrRev$() we get error in third exanple
}
Function DispRev$(a$) {
      i=1: j=Len(a$): if j=0 then ="": exit
      z$=String$(" ",j): j++
      do {
            k$=mid$(a$, i, 1)
            if i<len(a$) then {
            while len.disp(k$+mid$(a$, i+1,1)) =len.disp(k$) {
                  k$+=mid$(a$, i+1,1) : i++ : if i>len(a$) then exit
                  j-- } : j-- : insert j, len(k$) Z$=K$
            } else j-- :Insert j,1 z$=k$
            i++
           
      } until i>len(a$)
       =z$
}
Print DispRev$("abcd")="dcba"
Print DispRev$("")=""
Print DispRev$("s⃝df̅")="f̅ds⃝", StrRev$("s⃝df")="f̅ds⃝"
}
MODULE W1 { Report {
        This is an evolutionary Algorithm, where is a target string, a fitness function which return a number of how many charachters are at the right position, but no information returned for which character is in wrong position.
        So we use a random solution as the start point
        Then algorithm make small changes and produce a number of solutions, and get the better one using the fitness function
        So the alogrithm produce always a same or better solution in each iteration.
        Finally we get the solution with the maximum fitness, which means we get the target string.
        Without the algorithm we need to more then  1.18376868261619E+39 strings to check
        Or Miliion of computational years.
        Here the tools to find it are two major:
              The small random changes
              The choise of a better solution from a list of solutions
         And a minor to make it faster
               After a level of fitness we use less changes (only one character), changing the starting lambda function with another. Lambda functions are first citizens in M2000.
        
        From the code the statement Dim a$(1 to gen)<<mutate$(f$) place for each item in a$() a new solution from mutate$() providing a starting string
        
 }
 Module WeaselAlgorithm {
      Print "Evolutionary Algorithm"
      \\ Weasel Algorithm
      \\ Using dynamic array, which expand if no fitness change,
      \\ and reduce to minimum when fitness changed
      \\ Abandon strings when fitness change
      \\ Also lambda function Mutate$ change when topscore=10, to change only one character
      l$="ABCDEFGHIJKLMNOPQRSTUVWXYZ "
      randomstring$=lambda$ l$ ->{
            res$=""
            For i=1 to 28: res$+=Mid$(L$,Random(1,27),1):next i
            =res$
      }
      m$="METHINKS IT IS LIKE A WEASEL"
      lm=len(m$)
      fitness=lambda m$, lm (this$)-> {
            score=0 : For i=1 to lm {score+=If(mid$(m$,i,1)=mid$(this$, i, 1)->1,0)} : =score
      }
      Mutate$=lambda$ l$ (w$)-> {
            a=random(1,28) : insert a, 1 w$=mid$(l$, random(1,27),1)
            If random(3)=1 Then b=a:while b=a {b=random(1,28)} : insert b, 1 w$=mid$(l$, random(1,27),1)
            =w$
      }
      Mutate1$=lambda$ l$ (w$)-> {
            insert random(1,28), 1 w$=mid$(l$, random(1,27),1) : =w$
      }
      f$=randomstring$()
      topscore=0
      last=0
      Pen 11 {Print "Fitness |Target:", @(16),m$, @(47),"|Total Strings"}
      Print Over $(3,8), str$(topscore/28,"##0.0%"),"",$(0),f$, 0
      count=0
      gen=30
      mut=0
      {
            last=0
            Dim a$(1 to gen)<<mutate$(f$)
            mut+=gen
            oldscore=topscore
            For i=1 to gen {
                  topscore=max.data(topscore, fitness(a$(i)))
                  If oldscore<topscore Then last=i:Exit
            }
            If last>0 Then {
                  f$=a$(last) : gen=30 : If topscore=10 Then mutate$=mutate1$
            } Else gen+=50
            Print Over $(3,8), str$(topscore/28,"##0.0%"), "",$(0),f$, mut : refresh
            count+=min(gen,i)
            If topscore<28 Then loop
      }
      Print
      Print "Results"
      Print "I found this:"; a$(i)
      Print "Total strings which evalute fitness:"; count
      Print "Done"
}
WeaselAlgorithm
}
MODULE S1 {Report {
	Drawing 5 spheres using a lambda function each time different, which produce a texture
	The last one is the Transparent function which read the color of the point where we
	Aftr the drwaing complete we get it in cliboard as an image (a DIB type) whichw we can import to any application which imports images from clipboard.
	
	Press a key
}
Push key$: Drop
Module CheckIt {
      Flush
      Form ! 60, 40    ' use ! to reduce form (for safe area for TV)
      oldback=point  ' read color from 0,0  ' (Mode, Form. and Widow statement reset graphic cursor)
      Cls 0 ' Black
      Gradient 0,1
      Pen 14 ' Yellow
      Set Fast !
      Refresh 500
      Module Sphere (R as long, X0 as long, Y0 as long, fun){
            R2 = R * R
            Def Long X, Y, D2
            Let Scale=twipsx/R*13.5
            For Y = -R To R step twipsx {
            Move X0-R, Y+Y0
            For X = -R To R step twipsy {
                  D2 = X **2 + Y **2
                  IF R2>D2 THEN Pset Fun(Max.Data(Min.Data((Sqrt(R2 - D2) - ( X + Y) / 2 )*Scale ,255),0))
                  Step twipsx
            }
            }
      }
      Blue=lambda (c)->{
            c1=c/4+192
            =Color(c,c,c1)
      }
      Blue1=lambda (c)->{
            c1=c/4+Random(150,192)
            =Color(c,c,c1)
      }
      Mystery=lambda m=1 (c)->{
            c1=c/4+m
            m+=10
            if m>192 then m=1
            =Color(c,c,c1)
      }
      Mystery2=lambda m=1, p=true (c)->{
            c1=c/4+m
            if p then m+=10
            Else m=-10   ' we can break the if statement when e didn't use an if inside
            if m>192 then m-=10 : p=false
            If m<0 then m+=10: p=true
            =Color(c,c,c1)
      }
      Buffer Alfa as byte*8
      \\ we place the Alfa as a closuer (Alfa is a pointer to a Buffer object)
      Trans =lambda Alfa (c) -> {
            Return Alfa, 0:=-point as long
            Return Alfa, 4:=-color(c,c, c/4+192) as long
            for i=0 to 2: Return Alfa, i:=(Eval(Alfa, i)+Eval(Alfa, i+4))/2: Next i
            =-Eval(Alfa, 0 as long)
      }
      Sphere 2400, 9000,7000, Blue
      Sphere 800, 6000, 7000, Blue1
      Sphere 1200, 5000,5000, Mystery
      Sphere 1200, 10000,6000, Mystery2
      Sphere 1200, 8000,5000, trans
      \\ set spped to normal  (Fast is normal)
      Set Fast
      Refresh 30
      copy$=""
      move 0,0
      copy scale.x, scale.y to copy$
      clipboard copy$
      Print Part @(0,height),"Press a Key"
      A$=Key$
      Cls oldback
      Clear ' clear variables
      \\ addition using clipboard.image$ to read a DIB image to string variable
      A$=Clipboard.Image$
      Move 3000, 3000
      Image A$, 6000    ' produce the image with a width of 6000 twips, and a height based on image ratio of Width/Height
      Move 3000,1000
      Image A$, 2000,2000  ' define both width and height (stretching the image)
}
Checkit
}
MODULE M1 {  Print @(tab(1)),
  Report {
         This example use code to make functions for filters to fold, and or map an array
         There are #functions to do that, but here we use code to do these functions (see M2)
         Se help  #map amd help #filter tp see the use of internal functions
         
         
         You can follow the code using Stop where you want to stop it then use exit statement to exit
         From stop state you can use List amd Modules ? to see variables and modules in modules list
         Also you can use print or you can change variables. Try ? C to print C array at the Stop statement (see the code). From editor mark the stop staterment here and press F3 to find it at the lines bellow. Use F2 to serch back.
         
         Press a key
        }, width-tab(1)*2
Print
      Push key$: Drop
Module FilterMapFold {
      Form 80,40
      \\ HasString()
      \\ used to find if an array has strings or numbers
      \\ looking first element
      \\ because a is an iterator of array we have to copy first item
      \\ in a fresh array, which is base 0 by default
      \\ car(a) return first item as an array of one item
      \\ cdr(a) return all others as an array - not used here
      \\ (,) is the empty array - we can use Len() to check this
      HasString=Lambda (&a) ->{
            z=car(a)
            if len(z)=0 then =false :exit
            link z to s()
            =type$(s(0))="String"
      }
      \\ FilterFold$()
      \\ get an array or a pointer to array or an iterator to array
      \\ then optional get filter
      \\ then get the fold function (not optional)
      \\ then get the initial string value - optional
      \\ return string
      FilterFold$=lambda$ HasString (w)-> {
            f=lambda->true
            res$=""
            Read ? f
            Read fold, ? res$
            flush ' empty stack no other arguments allowed
            if not valid(w^) then {m=each(w)} else m=w
            if HasString(&m) then {
                  while m {
                        if not f(array$(m)) then continue
                         Call fold(array$(m), &res$)
                  }
            } else {
                  while m {
                        if not f(array(m)) then continue
                         Call fold(array(m), &res$)
                  }
            }
            =res$
      }
      \\ FilterFold()
      \\ get an array or a pointer to array or an iterator to array
      \\ then optional get filter
      \\ then get the fold function (not optional)
      \\ then get the initial number value - optional
      \\ return number
      FilterFold=lambda HasString (w)-> {
            f=lambda->true
            res=0
            Read ? f
            Read fold, ? res
            flush ' empty stack no other arguments allowed
            if not valid(w^) then {m=each(w)} else m=w
            if HasString(&m) then {
                  while m {
                        if not f(array$(m)) then continue
                         Call fold(array$(m), &res)
                  }
            } else {
                  while m {
                        if not f(array(m)) then continue
                         Call fold(array(m), &res)
                  }      
            }
            =res
      }
      \\ FilterMap()
      \\ get an array or a pointer to array or an iterator to array
      \\ check to see if is an iterator, if not make one
      \\ then optional get filter function
      \\ check if has string or number
      \\ then optional get mapfunction
      \\ return a poinrer to a new array with results
      \\ [ ] get all items from stack and return a stack object
      \\ Array([])  convert stack object to array
      FilterMap=lambda HasString (w)-> {
            if not valid(w^) then {m=each(w)} else m=w
            f=lambda->true
            if HasString(&m) then {
                  map$=lambda$->Letter$
                  Read ? f, map$
                  flush ' empty stack no other arguments allowed
                  while m {
                        if not f(array$(m)) then continue
                        data map$(array$(m))
                  }
            } Else {
                  map=lambda ->Number
                  Read ? f, map
                  flush ' empty stack no other arguments allowed
                  while m {
                        if not f(array(m)) then continue
                        data map(array(m))
                  }
            }
           =Array([])
      }
      \\ we can combine filters using filter()
      \\ we can have any number of lambda functions as parameters
      \\ if any function return false then exit and return falsa
      \\ so return true only if all functions return true
      \\ here we use it with one parameter
      \\ s is a pointer to stack object
      \\ stack(s) is a stack object as copy of s
      \\ ! stack(s)  paste all items to current stack, the lambda stack
      \\ so filter  return a lambda which works for any number and type of arguments
      \\ we use T and F as boolean values - only for print statement
      \\ because True and False are doubles, not boolean, but works nice in boolean expressions
      \\ All comparisons return boolean.
      Function filter {
            Def boolean T=True, F=False
            dim all() : all()=Array([]) : L=len(all())-1
            =lambda all(), L , F, T -> {
                s=[] : =T
                for i=0 to L { if all(i)(!stack(s)) else =F : exit
                }
            }
      }
      \\ example for two parameters
      greater=lambda (x, z)->x>z
      divided=lambda (x, z)->x mod z=0
      myfilter=filter(greater, divided)
      Print myfilter(10,2)=true, myfilter(2,10)=false, myfilter(7,3)=false
    
      \\ combine$()
      \\ take any number of lambda functions, which return string/object result
      \\ combine$() get all parameters to an array and make it  a closure in the returned lambda
      \\ stackitem$() return any type from stack (string or object), without dropping it
      \\ because function's stack always erased at the exit, it make the drop for us.
      Function combine$ {
            dim all$()
            all$()=Array$([])
            L=len(all$())-1
            =lambda$ all$(), L -> {
                for i=0 to L {Push all$(i)(![])} : =StackItem$()
            }
      }
      \\ combine(
      \\ take any number of lambda functions, which return number/object result
      \\ combine() get all parameters to an array and make it  a closure in the returned lambda
      \\ stackitem() return any type from stack (number or object), without dropping it
      \\ because function's stack always erased at the exit, it make the drop for us.
      Function combine {
            dim all()
            all()=Array([])
            L=len(all())-1
            =lambda$ all(), L -> {
                for i=0 to L {Push all(i)(![])} : =StackItem()
            }
      }
      \\ so now we see some example of using these functions
      \\ b is a pointer to array
      b=(1,2,3,4,5,6,7,8)
      \\ just  return a copy of b
      Print FilterMap(b)
      \\ we make a lambda to be used to FilterFold
      \\ second parameter has to be passed by reference
      \\  We can use FilterFolder with String Arrays or Number Arrays
      \\ but we get number  as result (from FilterFolder$ we get string)
      \\ so the reference here must be for a number
      \\ the first parameter here is number because we have number array to fold
      mul=lambda (x, &p) -> {
            p*=x
      }
      \\ using initial value 1  (default is 0, but here 0 isn't good)
      Print FilterFold(b,,mul,1)
      \\ so now we use the same number array but for string result
      \\ we make a text with one to eight starts, like a triangle of stars
      bar$=lambda$ (x, &ret$) ->{
            ret$+=string$("*", x)+{
            }
      }
      \\ Report using 2 center each line, so we get something like a tree
      \\ also report use proportional spacing
      Report 2, FilterFold$(b,,bar$) +"*"
      \\ we can make a new array adding three times b, so now b point to a new array
      b=cons(b,b,b)
      \\ we want the sum of all numbers in b
      Sum=lambda (x, &total)->{
            total+=x
      }
      \\ we leave empty the filter, we place the sum function. Initial value is 0 and this is nice here.
      Print FilterFold(b, ,Sum)
      \\ We want now to get an array of all squares of even numbers in array
      \\ so we want  the Even function as filter (return a boolean)
      \\ and the square function which return squares
      Even=lambda (x)->x mod 2=0
      Square=lambda (x)->x**2
      \\ this is the same
      Square=lambda (x) -> {
            =x**2
      }
      \\ and this is the same too
      Square=lambda -> {
            Read x
            =x**2
      }
      \\ or better , using  Number  which pop a number from lambda's stack
      Square=lambda ->Number**2
      \\ so now we get an array with all values
      Print FilterMap(b, Even, Square)
      \\ We can get the sum too easy:
      Print FilterFold(FilterMap(b, Even, Square), , sum)
      \\ Warning
      \\ Each( )can't work with expression, it need a pointer to array or an array like a()
      \\ so we use c as a pointer to array
      c=FilterMap(Each(b 1 to 8), Even, Square)
      \\ we can see items and length
      Print c, len(c)
      \\ so now we can use each(c,1,2) to get the two first items
      \\ and using FilterFold we get the sum ot those two items
      Print FilterFold(each(c,1,2), , sum)
      Stop
      \\ We can use two dimensional arrays, or more (maximum ten dimensions)
      \\ we can set different base (low bound) for each dimension
      \\ Dim is always like a "Dim Preserve" in VB6
      Dim z(1 to 4, 1 to 2)
      z(1,1)=1,2,3,4,5,6,7,8
      \\ So now we pass z() to FilterFold, and this check that it has numbers
      \\ and apply the proper code to support the sum function
      Print FilterFold(z(), , sum)
      \\ no it has numbers
      Print HasString(&Z())
      \\ so now we see examples with strings in array
      a=("car","boat","cat","frog")
      \\ check that HasString() works
      Print HasString(&a) ' true
      \\ filters
      \\ check if a$ has a "t" upper or lower case
      HasAt=lambda (a$)->instr(lcase$(a$),"t")>0
      \\ check if a$ has three characters length
      IsThreeLetters=lambda (a$)->len(a$)=3
      \\ maps
      \\ convert to uppercase
      capitalize$=lambda$ (a$)->Ucase$(a$)
      \\ add "123"
      add123$=lambda$ (a$)->a$+"123"
      \\ add brackets
      addbrackets$=lambda$ (a$)->"["+a$+"]"
      \\ Using filterMap with no filter/map, so we get the first two items by each()
      Print filterMap(each(a,1,2))
      \\ now we get all items capitalize
      Print filterMap(a,,capitalize$)
      \\ now we get items with three letters capitalize
      Print filterMap(a,isThreeletters,capitalize$)
      \\  We pass a composite filter using  filter()
      \\ so now we want items with three letters and  have a "t" inside, and map to capitalize
      Print filterMap(a,filter(isThreeletters,HasAt), capitalize$)
      \\  Here we get all items with three letters an apply combine map of two functions
      \\ last function applied last
      Print filterMap(a,isThreeletters, combine$(capitalize$, add123$))
      \\  Here we get all items with three letters an apply combine map
      \\ last applied the addbrackets so we get [CAR123] [CAT123]
      Print filterMap(a,isThreeletters, combine$(capitalize$, add123$, addbrackets$))
      \\ So now we make a folding function
      \\ using string for items and by reference string for accumulator
      appendstring=lambda (x$, &all$)->{
            all$+=x$
      }
      \\ we get all items in a string without spaces
      Print FilterFold$(a,,appendstring)
      \\ we use each with no coma using "to" and Start and End (1 and -1), in reverse
      \\ so we get the items in a string in reverse order
      \\ reverse, we can use each(a, -1, 1)
      Print FilterFold$(each(a End to Start),,appendstring)
      \ like this
      Print FilterFold$(each(a,-1,1),,appendstring)
      \\ we can apply a filter
      Print FilterFold$(a,isThreeletters,appendstring)
      \\ or we can use the FilterMap() as a parameter for FilterFold$()
      Print FilterFold$(FilterMap(a,isThreeletters, combine$(capitalize$, addbrackets$)),,appendstring)
      \\ Another folding function, to get the total length, so we need number,
      \\ so we use FilterFold and not FilterFold$
      GetLength=lambda (x$, &all)-> {
            all+=len(x$)
      }
      \\ Also we can get the maximum length from items
      GetMaxLength=lambda (x$, &max)-> {
            If len(x$)>max then max=len(x$)
      }
      \\ so now we get the length from all items with three letters
      Print FilterFold(a,isThreeletters,GetLength)=6
      \\ and we get the maximum length from all items
      Print FilterFold(a,,GetMaxLength)=4
}
FilterMapFold

}
MODULE H1 {Form 80, 66
Cursor tab(1)
Report {
	This is an example to show how the light events in a group can be used.
	The theory about light events have some standards:
		1,	A call to an Event can be done, although this maybe do not call anything id we don't have a service function to use it
		2.	A servuce function has the same scope as the module we write to it. It is like we call a subroutine. But this call happen from another module, a group module. So the event call is a call BACK to module which we tie the group with DoEvents. The stack of values in event calls is new one, sp we can't a;ter the module's stack either in group module or in target module (where we tie the group with DoEvents)
		3.	We can't use multicast call using the light events. We have to use Evemt Object which use a list of functions to call. Event Objects can alter the finction list. The light events can't alter the service funcitons, but we can alter a function as usual by defining another time using tthe same name.  This can't be happen from group module where we call the event.
		4.	We can make float groups from a group which has light events and we tie it to a module. The internal code in M2000 make a list of weaj references to servixe functions and when we call en event check if the weak reference exist and call it or drop the call if not exist.
	Prees a key
	}, width-tab(1)*2
Print
Push Key$: Drop
Class HttpStatus {
Events "trace", "err","high","low"
Private:
      myvalue
Public:
      Enum Status { NotFound=404, MethodNotAllowed=405}
      Set {
            read x ' number or enum
            \\ if number not exist in enum list Then we get an error
            Call event "trace", x
            Try ok {
                  .myvalue<=x
            }
            if not ok Then call event "err", format$("value {0} not accepted", x)
      }
      Value {
            =.myvalue
      }
      Operator "++" {
            old=.myvalue
            .myvalue++
            if old=.myvalue Then call event "high"
      }
      Operator "--" {
            old=.myvalue
            .myvalue--
            if old=.myvalue Then call event "low"
      }
      class:
      Module HttpStatus {
      .myvalue<=.NotFound
      }
}
Group WithEvents HttpStatus=HttpStatus()
Function HttpStatus_trace(New a){
      Print ">>>",a
}
Function HttpStatus_err(New a$) {
      Print a$
}
accHigh=0
Function HttpStatus_high {
      Print "high limit"
      accHigh++
}
Function HttpStatus_low {
      Print "low limit"
}
Print HttpStatus.NotFound, HttpStatus.MethodNotAllowed
Print HttpStatus=404
HttpStatus=HttpStatus.MethodNotAllowed
Print HttpStatus=405
HttpStatus=10
Print HttpStatus=405
\\ 404 is ok
HttpStatus=404
Print HttpStatus
HttpStatus--
HttpStatus++
Print HttpStatus=405
HttpStatus++
Print accHigh=1
Print Type$(HttpStatus)="Group"
Def InferType$(x)=Type$(x)
Print InferType$(HttpStatus)="Status"
\\ for enum types Status letter Case have to match the Case in definition
Module Checkit(a as Status) {
      Print type$(a) ' it is a enum type, not a group, so no events happen
      Print a
      a--
      Print a, eval$(a)="NotFound"
     
}
Checkit HttpStatus.NotFound ' 404 404
Checkit HttpStatus ' 405 404
Print Eval$(HttpStatus)="MethodNotAllowed"
Try ok {
      Checkit 405
}
If error or not ok Then Print Error$ ' Wrong type in module A.CHECKIT
Module CheckThis(a as group) {
      Print "ok", a=405
      a++ ' raise high event, add one to acchigh
}
Try ok {
      CheckThis HttpStatus
}
If Error or not ok Then Print Error$ ' Wrong type in module A.CHECKTHIS
\\ we can pass group not value of HttpStatus
CheckThis Group(HttpStatus)
Print acchigh=2
Select Case HttpStatus
Case HttpStatus.NotFound
      Print "Not Found"
Case HttpStatus.MethodNotAllowed
      Print "Method Not Allowed"
End Select
HttpStatus=HttpStatus.NotFound
Module CheckThisToo(&a as group) {
      Print "ok", a=404
      a++ ' raise high event, add one to acchigh
}
\\ pass by reference
CheckThisToo &HttpStatus
Print HttpStatus=HttpStatus.MethodNotAllowed
\\ check a copy of HttpStatus to a
a=HttpStatus
a++
a++ ' we have no events now, a has a new cleared event list
Print a =405
\\ check a pointer to HttpStatus
b->HttpStatus
Print Eval(b), b=>NotFound, Eval$(b=>NotFound)="NotFound"
b++ ' we get event because b is a pointer to HttpStatus
Try {
      \\ b is an object so we get wrongtype
      Checkit b
}
\\ now we can get the value from b
Checkit eval(b)
\\ no used & because  b is actual a reference to HttpStatus
\\ if we use & then we pass the reference of pointer, not the the reference of Httpstatus
CheckThis b
Dim a(2)
\\ this is the second type of pointer, a pointer to a copy of HttpStatus
a(1)->(Group(HttpStatus))
b->a(1)
Print Eval(a(1))=405
a(1)--
Print Eval(a(1))=404
a(1)=405
Print Type$(a(1))="Group", InferType$(Eval(a(1)))="Status"
a(1)++ ' we get high limit, because a(1) has a float group (nameless), and event list inside is the original one.
b++ ' now we get high limit because b and a(1) show the same nameless (or float) group
}
MODULE H2 {\\ The task is simple;
\\ first we make a class function to produce a group with one variable and a value
\\ then we make p as a pointer to a float group produced from alfa()
\\ then we use p=>x to get the x value, and eval(p) to get the group value

\\ Then we want a named group, m, with a variable m to merge it with a group
\\ The group is a pointer to a float group in the stack, so we push p to stack
\\ We use a function which get any group (pointer on not pointer) as m
\\ then make a z and then we return z as group (using Group(), because without we get the value of z, if z has a value)

\\ We make the same, but now we didn't use the function but we do something else.
\\ First we have to use a fresh name, say m1, and read from stack as group, so if it is a pointer we get a group from the pointer
\\ now we can append a Y variable, using Group {} or using m1=class1() 

class alfa {
	x=10
	value {
		=.x*2
	}
}
\\ we can use p=pointer(alfa())
rem
p=pointer(alfa())
rem p->alfa()
Print p=>x, eval(p)=20
push p
group m {
	y=20
}
if rnd>.5 then
	Print "using getGroup(m)"
	function getGroup(m){
		group z=m
		=group(m)
	}
else
	Print "using getGroup(m as group)"
	function getGroup(m as group){
		=group(m)
	}
end if
m=getGroup(Group)
Print m=20, m.x, m.y
Push p
Read m1 as group
if rnd>.5 then
	Print "using group {}"
	group m1 {
		y=20
	}
else
	Print "Using class"
	class class1 {y=20}
	\\ Let is like Push class1() : read m1
	\\ without Let we get error: property can't change (there isn't a set { } session in class alfa)
	Let m1=class1()
end if
Print M1
M2=Group(M1)
Print M2.y=20, M2=20
list

}
MODULE H3 {\\ Like H2 but p is a special pointer, a reference to alfa
\\ In h2 a pointer to a float group when deleted or change pointer decrement the pointers number inside the group. So when this number goes to zero (no pointer point to foat group) then the group deleted
\\ the type of pointer we use here is a reference to a named group.. Internal the pointer holds only a weak reference so if no reference exist we get error when we try to use it
\\ A named group deleted when the owner (the module or function or block with temporary definitions) end the execution. We can say that a named group is a static group, but the name static used for static variables a subset of variable types which can be used for each call in a module or function or thread with only one time intialization at the Static statement. See Help Static
\\ Also a named group may use Light Events. Here the "p" event may have or not a Function alfa_p.
Print "Run this many times, to see all variants"
counter=0
group withevents alfa {
	event "p"
	x=10
	value {
		call event "p", 1
		=.x*2
	}
}
function alfa_p(x) {
	counter+=x
}
\\ we can use p=pointer(alfa())
rem
p=pointer(alfa)
rem p->alfa
Print p=>x, eval(p)=20, counter
push p
group m {
	y=20
}
Pen 11 {Print "We have a pointer to a group in stack"}
Stack
Over
Pen 11 {Print "Now we have a pointer to a group in stack two times"}
Stack
read NewGroup
def getGroup(m as group)=group(m)
Print counter=1
if rnd>.5 then
	Pen 15 {Print "using Group reading from stack"}
	m=Group
else
	Pen 15 {Print "using getGroup(m)"}
	m=getGroup(Group)
end if
Print m=20, m.x, m.y, counter
m.x++
print m.x=11, alfa.x=10, p=>x=10
print m, counter
Push p
Read m1 as group
\\ because m1 has a copy of weak reference to alfa_p and alfa_p exist
Print counter=3, m1, counter=4
if rnd>.5 then
	Pen 12 {Print "using group {}"}
	\\we get a clear event list, the counter=5 return false
	group m1 {
		y=20
	}
	Print counter=4, m1, counter=5
	\\ we can make a group m2 {y=20} and a let m1=m2 to get the y without deleting the event list.
else
	Pen 13 {Print "Using class in a let statement"}
	class class1 {y=20}
	\\ Let is like Push class1() : read m1
	\\ without Let we get error: property can't change (there isn't a set { } session in class alfa)
	\\ the error happen if we have a value {} session which make the group as a property
	Let m1=class1()
	Print counter=4, m1, counter=5
end if
def TypeExpression$(val)=type$(val)
Print "m1 is a group and return a double as value"
Print type$(m1), TypeExpression$(m1)
\\ so we get the group not the value using group()
M2=group(m1)
oldcounter=counter
Print counter
Print M2.y=20, M2=20
Print counter
if counter=oldcounter then
	Print "counter not changed because the event list inside group is empty"
end if
\\ We can get the value from NewGroup which is a pointer to a group
\\ but has event list from the original alfa
Print Eval(NewGroup)
Print Counter
\\ we use group(alfa) to get the group, not the value
\\ now NewerGroup is a real pointer to a copy of alfa
NewerGroup->(group(alfa))
Print Eval(NewerGroup)
\\ event list also copied, and because the actual event service function exist the event served
Print Counter
list
}
MODULE INF { locale 1033
Module CheckIt {
      Form 66,40
      Cls 5
      Pen 14
      \\ Ensure True/False for Print boolean (else -1/0)
      \\ from m2000 console use statement Switches without Set.
      \\ use Monitor statement to see all switches.
      Set Switches "+SBL"
      IF version<9.8 then exit
      IF version=9.8 and revision<18 then exit
      rem {
            \\ from revision 18 there is a constant infinity
            Function Infinity(positive=True) {
                  buffer clear inf as byte*8
                  m=0x7F
                  if not positive then m+=128
                  return inf, 7:=m, 6:=0xF0
                  =eval(inf, 0 as double)
            }
            K=Infinity(false)
            L=Infinity()
      }
      K=-Infinity
      L=Infinity
      Function TestNegativeInfinity(k) {
            =str$(k, 1033) = "-1.#INF"
      }
      Function TestPositiveInfinity(k) {
            =str$(k, 1033) = "1.#INF"
      }
      Function TestInvalid {
            =str$(Number, 1033) = "-1.#IND"
      }
      Pen 11 {Print "       True       True"}    
      Print TestNegativeInfinity(K), TestPositiveInfinity(L)
      Pen 11 {Print "    -1.#INF     1.#INF    -1.#INF     1.#INF    -1.#INF     1.#INF"}
      Print K, L, K*100, L*100, K+K, L+L
      M=K/L
      Pen 11 {Print "    -1.#IND    -1.#IND       True       True" }
      Print K/L, L/K, TestInvalid(M), TestInvalid(K/L)
      M=K+L
      Pen 11 {Print "    -1.#IND    -1.#IND    -1.#IND       True       True"}
      Print M, K+L, L+K, TestInvalid(M), TestInvalid(K+L)
      Pen 11 {Print "    -1.#INF     1.#INF"}
      Print 1+K+2, 1+L+2
      Pen 11 {Print "    -1.#INF"}
      Print K-L
      Pen 11 {Print "     1.#INF"}
      Print L-K
      Pen 11 {Print "       True       True       True       True"}    
      Print L<>k, 100>K, 100>K+1, L>K
      Pen 11 {Print "       True       True          1          0"}
      Print L+10>100, 100+L>K, L<=>k, L<=>L
}
Checkit
}
MODULE CONV { Module Checkit {
      Conv2dec=lambda (n$, frombase=10, dp$=".") -> {
           neg=left$(n$,1)="-": if neg then n$=mid$(n$,2)
           if instr(n$, dp$)>0 then {
                 n2$=Piece$(n$,dp$,2)
                 n$=Piece$(n$, dp$,1)
           } else n2$=""
           n0=0
           l1=len(n$)+1
           For i=len(n$) to 1
                 dig$=Mid$(n$,l1-i,1)
                 dig=asc(dig$)-48
                 if dig$>"9" then dig-=7
                 if dig>=frombase then error "not in base:"+frombase
                 n0+=dig*frombase^(i-1)
           next i
           if n2$<>"" then {
              For i=1 to len(n2$)
                 dig$=Mid$(n2$,i,1)
                 dig=asc(dig$)-48
                 if dig$>"9" then dig-=7
                 if dig>=frombase then error "not in base:"+frombase
                 n0+=dig/frombase^i
              Next i
           }
           if neg then n0-!
           =n0
      }
      Conv2Any$=Lambda$ (dec, tobase=10, dp$=".", prec=16) -> {
           a$=""
           neg=false
           if dec<0 then neg=true
           dec=abs(dec)
           n2=frac(dec)
           if dec=0 then {
                 a$="0"
           } else {
                 do {
                        n=dec mod tobase
                        if n>=10 then n+=7
                        a$=chr$(n+48)+a$
                        dec=dec div tobase
                  } until dec==0
            }
            if n2<>0 then {
                 a$+=dp$
                 prec--
                 do {
                      prec--
                      dec=n2*tobase
                      n2=frac(dec)
                      dec-=n2
                      n2=round(n2)
                      if dec>=10 then dec+=7
                      a$+=chr$(dec+48)
                 } until n2=0 or prec<0
            }
            if neg then {="-"+a$} else =a$
      }
      Rem : Locale 1033 ' use . for all print out for decimal point
      Print Conv2dec("10111.01011",2); " => ";Conv2Any$(23.34375,2)
      Print Conv2Any$(11.90625, 2); " => "; Conv2dec("1011.11101",2)
      \\ using , for decimal point
      Print Conv2Any$(Conv2dec("1011,11101",2, ","), 10, ",")
      Print 12312321.1212
      clipboard Conv2Any$(12312321.1212, 2)
      \\ using . for 1033 locale
      Print Str$(Conv2Dec(Conv2Any$(12312321.1212, 2), 2), 1033)="12312321.1211853"
      Print Str$(Conv2Dec(Conv2Any$(12312321.1212, 2,,52), 2), 1033) ="12312321.1212"
}
Checkit
}
MODULE RAT {Report {
	Rational Numbers
	Using a class Rational() which give a group object and set operators for evaluation of rational expressions
	A rational(10,15) is 10/15
	We can make arrays of rational numbers
}
Module RationalNumbers {
      Class Rational {
            numerator as decimal, denominator as decimal
            gcd=lambda->0
            lcm=lambda->0
            operator "+" {
                 Read l
                 denom=.lcm(l.denominator, .denominator)
                 .numerator<=denom/l.denominator*l.numerator+denom/.denominator*.numerator
                 if .numerator==0 then denom=1
                 .denominator<=denom
            }
            Operator Unary {
                  .numerator-!
            }
            Operator "-" {
                  Read l
                  Call Operator "+", -l
            }
            Operator high "*" {
                  Read l
                  g1=.gcd(l.numerator,.denominator)
                  g2=.gcd(.numerator, l.denominator)
                  Push l.numerator/g1*.numerator/g2
                  Push l.denominator/g2*.denominator/g1
                  Read .denominator, .numerator

            }
            Function Inverse {
                  if .numerator==0 then Error "Division by zero"
                  ret=This
                  sign=Sgn(ret.numerator) : if sign<0 then ret.numerator-!
                  swap ret.numerator, ret.denominator
                  if sign<0 then ret.numerator-!
                  =ret
            }
            Operator high"/" {
                  Read l
                  call operator "*", l.inverse()
            }
            Function Power {
                  Read pow as long
                  ret=This
                  ret.numerator<=.numerator^pow
                  ret.denominator<=.denominator^pow
                  =ret
            }
            Operator "=" {
                  Read l
                  Def boolean T=True, F=False
                  if Abs(Sgn(l.numerator))+Abs(Sgn(.numerator))=0 then Push T: exit
                  if Sgn(l.numerator) <>Sgn(.numerator) then Push F : exit
                  pcomp=l/this
                  PUSH pcomp.numerator=1 and pcomp.denominator=1
            }
            Operator  ">" {
                  Read l
                  Def boolean F
                  if Abs(Sgn(l.numerator))+Abs(Sgn(.numerator))=0 then Push F: exit
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator>0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real>1
                  }
            }
            Operator ">=" {
                  Read l
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator>=0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real>=1
                  }
            }      
            Operator "<" {
                  Read l
                  Def boolean F
                  if Abs(Sgn(l.numerator))+Abs(Sgn(.numerator))=0 then Push F: exit
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator<0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<1
                  }
            }
            Operator "<=" {
                  Read l
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator<=0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<=1
                  }            
            }
            Operator "<>" {
                  Read l
                  if Sgn(l.numerator)=0 then {
                        PUSH .numerator<>0
                  } Else {
                        pcomp=this/l
                        PUSH pcomp.real<>1
                  }            
            }
            Group Real {
                  value {
                        link parent numerator, denominator to n, d
                        =n/d
                  }
            }
            Group ToString$ {
                 value {
                        link parent numerator, denominator to n, d
                        =Str$(n)+"/"+Str$(d,"")
                  }      
            }
            class:
            Module Rational (.numerator, .denominator) {
                  if .denominator=0 then Error "Zero denominator"
                  sgn=Sgn(.numerator)*Sgn(.denominator)
                  .denominator<=abs(.denominator)
                  .numerator<=abs(.numerator)*sgn
                  gcd1=lambda (a as decimal, b as decimal) -> {
                        if a<b then swap a,b
                        g=a mod b
                        while g {
                              a=b:b=g: g=a mod b
                        }
                              =abs(b)
                  }
                  gdcval=gcd1(abs(.numerator), .denominator)
                  if gdcval<.denominator and gdcval<>0 then
                        .denominator/=gdcval
                        .numerator/=gdcval
                  end if
                  .gcd<=gcd1
                  .lcm<=lambda gcd=gcd1 (a as decimal, b as decimal) -> {
                        =a/gcd(a,b)*b
                  }
            }
      }
      Print rational(-3,3)<>rational(-3,3)  ' false
      M=Rational(10, 150)
      N=Rational(2, 4)
      Print "M.real+N.real=";M.real+N.real
      Print "Z=M+N"
      Z=M+N
      Print 10/150@+2/4@
      Print "Z.real="; Z.real
      Print "(";M.numerator;"/"; M.denominator;") + (";N.numerator;"/"; N.denominator;") = (";Z.numerator;"/";Z.denominator;")"
      Print M.tostring$+ " +"+N.tostring$+" ="+Z.tostring$
      Print -10/150@+2/4@
      Z=-M+N
      Print "-"+M.tostring$+ " +"+N.tostring$+" ="+Z.tostring$
      Print Z.numerator, Z.denominator, Z.numerator/Z.denominator
      Print -10/150@+2/4@
      Print Z.real
      Z=M-N
      Print Z.numerator, Z.denominator
      Print 10/150@-2/4@
      Print Z.real
      Z=M*N
      Print Z.numerator, Z.denominator
      Print (10/150@)*(2/4@)
      Print Z.real
      Z=M/N
      Print Z.numerator, Z.denominator
      Print (10/150@)/(2/4@)
      Print z.tostring$
      Print Z.real
      Print "Z power 2 = ";
      
      Z=Z.Power(2)
      Print Z.real
      Print z.tostring$;" = ";eval(z.tostring$)   
      Print Z=Z
      Print Z=N  ' false
      Print Z=-Z  ' false
      ZZ=-Z
      Print ZZ=ZZ
      Print -Z=-Z
      Print Z.numerator, Z.denominator
      Print Z.real, Z.tostring$
      \\ Array of rational numbers
      Dim K(100)=rational(1,1)
      M=K(4)+K(3)
      Print M.real
      Print K(4).toString$

      pk->(Z)
      Print pk=>toString$+" +"
      zzz=k(4)+pk
      Print zzz.toString$+ " ="+K(4).toString$+" +"+pk=>toString$
      
      zzz=Rational(10,1)+Rational(3,1)*Rational(2,1)
      Print zzz.toString$, zzz.real=16
      zzz=Rational(10,1)*Rational(3,1)+Rational(2,1)
      Print zzz.toString$, zzz.real=32

}
RationalNumbers
}
MODULE TUPLE { Form 80, 60
\\ Tuple of items (as one dimension arrays)
A=(1,2,3,4,5)
B=("George", 10, "Bob", 5)
C=(("George", 10),("Bob", 5))
Print Len(A)=5 ' true
Print Len(B)=4 ' true
Print Len(C)=2 ' true
\\ get reference of A to A1
A1=A
B1=B
C1=C
\\ Get Shallow Copy
Dim A(), B$(), C()
A()=A
B$()=B
C()=C
A(0)=10
Print A ' 1 2 3 4 5
Print A() ' 10 2 3 4 5
Link B$() to B()
B$(0)="Hello George"
B(1)=1000
Print B ' George 10 Bob 5
Print B$() ' Hello George 1000 Bob 5
C()=C
C(0)=("New Name", 500)
Print Array(C,0), Array(C, 1) ' George 10 Bob 5
Print C(0)(), C(1)() ' New Name 500 Bob 5
\\ Test Shallow Copy
\\ we keep pointer to second array but we change values
\\ we need a pointer to C[1]
N=Array(C,1)
\\ So we can use Return to return multiple values
Return N, 0:="New Bob", 1:=5000
\\ So Array(C,1) show us new values
Print Array(C,0), Array(C, 1) ' George 10 New Bob 5000
\\ And because we get shallow copy (pointer only) we get C(1)() array with new values
Print C(0)(), C(1)() ' New Name 500 New Bob 5000
\\ Now C(1) get a new pointer
C(1)=("Another Name", 2000)
Print Array(C,0), Array(C, 1) ' George 10 New Bob 5000
Print C(0)(), C(1)() ' New Name 500 Another Name 2000
\\ we can get a copy of A using Cons() with one argument
NewArray=Cons(A) ' copy of A
Print NewArray
NewArray2=Cons(A, A) ' add A twice
Print NewArray2
\\ Get a copy of C() to a pointer
CopyC=Cons(C())
Print Array(CopyC, 0), Array(CopyC, 1)
Return CopyC, 1:=("Just Another Name", 3000)
Print Array(CopyC, 0), Array(CopyC, 1) ' New Name 500 Just Another Name 3000
Print C(0)(), C(1)() ' New Name 500 Another Name 2000

\\ Pointers for multi dimension arrays
Dim A(2 to 10, 5 to 10)=1
M=A()
Print Len(M) = 54 ' 9X6
Print array(M, 2,5)=1 \\ M point to a 2 dimension Array
\\ Return use one dimension, so 0 is the first element
Return M, 0:=1000, 6:=5000 ' 6 is the 7th item, first in second row (row, columns)
Print array(M, 2,5)=1000, array(M, 3,5)
Dim A(2 to 11, 5 to 10) ' add one row
Print Len(M) = 60 ' 10X6
Print Type$(A(11, 5))="Empty"  ' new raw has Empty as value (in calculations this is same as 0 or empty string)
\\ So now we put a value
For i=5 to 10:A(11,i)=1:Next i
\\ we can alter last item using pointer M
Return M, 59:=9999
Print A(11, 10)=9999
\\ assuming we have defalut base 0
Dim A(10,6) ' redim preserving values
Print A(9, 5)=9999, Len(A())=60
\\ we can use Base 1 or Base 0 to explicit declare base
Dim Base 1, A(10,6) ' redim preserving values
Print A(10, 6)=9999, Len(A())=60
\\ or we can use for each dimension a new base
Dim A(5 to 14, 10 to 15) ' redim preserving values
Print A(14, 15)=9999, Len(A())=60
\\ Get dimensions, width for each dimension, base (min value) for each dimension, max value for each dimension
Print Dimension(A())=2 ' 2 dimension
Print Dimension(A(),0)=5 ' first dimension base is 5
Print Dimension(A(),1)=10 ' 10 items
Print Dimension(A(),2)=6 ' 6 items, so we have 10x6 items
Print Dimension(A(),1,0)=5
Print Dimension(A(),1,1)=14
Print Dimension(A(),2,0)=10
Print Dimension(A(),2,1)=15
\\ Copy all item to stack using pointer to array (not A() but M)
Flush  ' now stack is empty stack
Push ! M ' now get 60 items
Print stack.size=60 ' true
Stack   ' now display all stack items
Flush ' now empty stack
\\ if we use Push ! M we send values in reverse
Data ! M ' now get 60 items
\\ now all item make an array and return a pointer to Z
Z=Array([])
Print stack.size=0
Link Z to Z()
Dim Z(5 to 14, 10 to 15)
Print Z()
Print Z(14,15)=9999
Z++ ' Add 1 to all items
Print Z()
Z(14,15)-- ' Subtract 1 from one item
Print Z(14,15)
}
MODULE TU {Module TestGroup {
      Group A {
            X=10
            Dim K(10)=1
      }
      Dim A(), B()
      A()=(A,)
      B()=A()
      A(0).X++
      A(0).K(0)=1000
      Print A(0).X=11, A(0).K()
      Print B(0).X=10, B(0).K()
}
TestGroup


Module TestGroup2 {
      Group A {
            X=10
            Dim K(10)=1
      }
      Dim A(), B()
      A()=(0,) ' one item
      A(0)->(A) ' now A(0) has a pointer to a copy of  A
      B()=A()
      A(0).X++
      A(0).K(0)=1000
      Print A(0).X=11, A(0).K()
      Print B(0).X=11, B(0).K()
}
TestGroup2
}
MODULE PEND {Module Pendulum {
      back()
      degree=180/pi
      THETA=Pi/2  ' +p/8
      SPEED=0
      G=9.81
      L=0.25
      Refresh 5000
      Profiler
      lasttimecount=0
      cc=50
      accold=0
      ACCEL=0 'G*SIN(THETA*degree)*L
      time=now
      timed=1/24/3600*(cc*1.5)/1000
            Thread {
            time+=timed
            ACCEL=G*SIN(THETA*degree)*L
            SPEED+=ACCEL/cc
            THETA+=SPEED
            if sgn(accold)<>sgn(ACCEL) then lasttimecount=timecount: Profiler
            accold=ACCEL
      } as M interval cc
      Main.Task 20 {
            Pendulum(THETA)
            if KeyPress(32) Then Exit
      }
      Threads Erase
      Sub back()
            If not IsWine then Smooth On
            Cls 7,0
            Pen 0
            Move 0, scale.y/4
            Draw scale.x,0
            Step -scale.x/2
            circle fill #AAAAAA, scale.x/50
            Hold ' hold this as background
      End Sub

      Sub Pendulum(x)          
            x+=pi/2
            Release ' place stored background to screen
            Width scale.x/2000 {
                  Draw Angle x, scale.y/2.5
                  Width 1 {
                        Circle Fill 14, scale.x/25
                  }
                  Step Angle x, -scale.y/2.5
            }
            cursor 0,1
            Print time$(time,,"mm:ss"), round(lasttimecount,2), "", time$(now,,"mm:ss"), round((now-time)*100000, 2)
            refresh 1000
      End Sub
}
while inkey$<>"" : end while
Set Fast!
Pendulum
Set Fast
keyboard "Info"+chr$(13)
}
MODULE LOGO {smooth off  ' can't use xor with GDI+, so we work with GDI32 (by default)
Form 80, 50
BackGround {cls 11 :height.pixels=scale.y  div twipsY : width.pixels=scale.x div twipsX }
if height.pixels=1024 or height.pixels/width.pixels>0.70 then
      Form  80,50
else
     Form !  120,60    // we use ! to add more space for TV-MONITORS - Remove it then press Esc and then F1 to save it
  end if
Refresh 10000
Cls 5,0
Pen 14
Cursor 0,0
Move 0,0
Fill scale.x,600,5,12
move 0, 600
Fill scale.x,800,12,5
Cursor 3
drawframeM()
drawframe2()
drawframe0()
drawframe0()
drawframe0()
Move 0, 1400
Cursor !  ' turn character cursor as near to graphic cursor 
cls, row
Refresh 50
Sub drawframeM()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,1000, -200,0, 0,-700,-200, 0, 0,700, -200,0, 0,-700,-200, 0, 0,700, -200, 0, 0,-1000
                        Step 200, 300
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
Sub drawframe2()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,600, -700,0, 0,100,700,0,0,300, -1000,0,0,-600,700,0,0,-100,-700,0,0,-300
                        Step 200, 300
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
Sub drawframe0()
      local i, n=0
      Move !
      Pen 0 {
            Step 100, 100
            For i=1 to 2 {
                  Path n {
                        Polygon 0, 1000, 0, 0,1000, -1000,0, 0,-1000
                        Step 200, 300
                        Polygon 0, 600, 0, 0,400, -600,0, 0,-400
                  }
                  Step -300, -400
                  n=15-n
            }
      }
      Step 1400,0
      Cursor !
End Sub
}
MODULE EN {if version< 9.9 Then 1000
If revision<19 Then 1000
\\ by default Dog=1, Cat=2
\\ we can change it: Dog=0, Cat   ' so now Cat=1
\\ we can change it: Dog=100, Cat=200
\\ we can put a new line in place of comma
\\ or after comma,
\\ we can't leave a comma as last character except new lines, in the enum block.
Enumeration Pets {
      Dog
      Cat
}
a=Dog
Print a=1 ' true
a++
Print Eval$(a)="Cat", a=2
k=Each(Pets)
While k {
      Print Eval$(k), Eval(k), k^    ' k^ from 0
      a=Eval(k)
      Print a<Cat
      Alfa(a)
}
a=Dog

AlfaByRef(&a)

Print a=Cat  ' true
Print "a value by name:";@Name$(a)
\\ k is integer type
For k=Dog to Cat
      Print "k value by name:";@Name$(k), type$(k)
Next

kk=Each(Pets)
While kk
      Print @Name2$(kk), @Name$(kk)
End While

Sub Alfa(b as Pets)
      Print b
End Sub
Sub AlfaByRef(&b as Pets)
      Print b
      b++
End Sub
\\ handle number and Pets type and iterator for Pets Type
Function Name$(a)
      local b as Pets
      b=a
      =Quote$(Eval$(b))
End Function
\\ hanlde only Pets type and iterator of Pets type
Function Name2$(b as Pets)
      =Quote$(Eval$(b))
End Function
1000  Error "From revision 19, Version 9.9"
}
MODULE FS {\\ appdir$ is the application directory. Normally we nevert use it
\\ dir$ is the current dir
\\ see Help "file operations" or Help "file "
\\ Help Files  (or one of this list BITMAPS, CLOSE, DRAWINGS, FILES, GET, LINE INPUT, MOVIES, NAME, OPEN, PUT, SEEK, SOUNDS, WRITE)

Dir user  ' set current directory to M2000 user
userdir$=dir$
Declare fs "Scripting.FileSystemObject"
show_members(fs)
Method fs, "GetFolder", dir$ as fc
Print "GetFolder members"
show_members(fc)
With fc, "SubFolders" set SubFolders
Print type$(SubFolders)
show_members(SubFolders)


With SubFolders, -4& as Folder, "count" as SF.count
Print SF.count
if SF.count>0 then
	Show_Folders(SubFolders)
else
	Try ok {
		SubDir NewFolder1
		wait 100  ' give some time to system
		if exist.dir("..\NewFolder1") then
			Print "Folder Created"
			Dir ..\     ' return
		else
			dir user
		End if
	
	}
	if error or not ok then Print "Error from SubDir:"+Error$
	Print "Total folders="; SF.count
	If SF.count> 0 then Show_Folders(SubFolders)
End If
Win Dir$  ' open explorer in M2000 user directory
Rem Win "explorer", "/select,"+dir$  ' open explorer with selected name the folder dir$
declare fs nothing


sub show_members(obj)
local mm=param(obj), i
IF LEN(mm)>1 THEN {
      For i=0 to len(mm)-1
            Report 3, mm$(i!) ' use index, not key
      Next i
}
end sub
sub Show_Folders(obj)
With obj, -4& as new Folder

	With Folder, "Name" as FolderName$
	
	While Folder {
	      Print FolderName$
	}

end sub
}
MODULE FS1 {Declare fs "Scripting.FileSystemObject"
Method fs, "GetFolder", dir$ as fc
With fc, "files" set files
\\ Produce the TypeLib
mm=param(files)
IF LEN(mm)>1 THEN {
      For i=0 to len(mm)-1
            Report 3, mm$(i!) ' use index, not key
      Next i
}
Print "Press a key ": Print Key$
With files, "count" as count
if count>0 then
      With files, "item" set myfile ("llist1.gsb")
      \\ this is a property -4 which return a IEnumVariant
      With files, -4& as EnumFile
      Print Type$(EnumFile)
      \\ Produce the TypeLib
      m=param(EnumFile)
      IF LEN(m)>1 THEN
            For i=0 to len(m)-1
                  Report 3, m$(i!) ' use index, not key
            Next i
      End If
      Print "Press a key ": Print Key$
      With EnumFile, "Name" as aName$
      While EnumFile
            Print aName$
      End While
End if
Declare fs nothing

}
MODULE GAME {Module Game2048 {
      \\ 10% 4 and 90% 2
      Def GetTlleNumber()=If(Random(1,10)=1->4, 2)
      \\ tile
      Def Tile$(x)=If$(x=0->"[    ]", format$("[{0::-4}]", x))
      \\ empty board
      BoardTileRight =lambda (x, y)->x+y*4
      BoardTileLeft=lambda (x, y)->3-x+y*4
      BoardTileUp=lambda (x, y)->x*4+y
      BoardTileDown=lambda (x, y)->(3-x)*4+y
      Dim Board(0 to 15)
      Inventory EmptyTiles
      \\ Score is a statement but we can use it as a variable too.
      Score=0
      \\ Win is also a statement but we can use it as a variable too.
      Win=False
      ExitNow=False
      BoardDirection=BoardtileRight
      Process(BoardDirection)
      \\ Split Rem lines to insert start condition to check valid moves
      Rem : board(0)=2
      Rem : board(1)=2, 2, 2 ' place to (1), (2), (3)
            While len(EmptyTiles) {
            NewTile()
            DrawBoard()
            Action=False
            do {
                  a$=key$
                  if len(a$)=2 then {
                        Action=true
                        Select case Asc(mid$(a$,2))
                        Case 72
                        BoardDirection=BoardTileUp
                        Case 75
                        BoardDirection=BoardTileRight
                        Case 77
                        BoardDirection=BoardTileLeft
                        Case 80
                        BoardDirection=BoardTileDown
                        Case 79 ' End key
                              ExitNow=True
                        Else
                        Action=false
                        end select
                  }
            } until Action
            If ExitNow then exit
            Process(BoardDirection)
      }
      If Win then {
            Print "You Win"
      } Else {
            Print "You Loose"
      }
      Refresh 30
      End
      Sub Process(Boardtile)
      Inventory EmptyTiles ' clear inventory
      local where, i, j, k
      For i=0 to 3
            Gravity()
            k=boardtile(0,i)
            For j=1 to 3
                  where=boardtile(j,i)
                  if Board(where)<>0 then {
                        if board(k)=board(where) then {
                               board(k)*=2 : score+=board(where): board(where)=0
                               if board(k)=2048 Then Win=True : ExitNow=true
                        }
                  }
                  k=where
            Next j
            Gravity()
            For j=0 to 3
                  where=boardtile(j,i)
                  if board(where)=0 then Append EmptyTiles, where
            Next j
      Next i
      End Sub
      Sub NewTile()
            local m=EmptyTiles(Random(0, len(EmptyTiles)-1)!)
            Board(m)=GetTlleNumber()
            Delete EmptyTiles, m
      End Sub
      Sub DrawBoard()
            Refresh 2000
            Cls
            Cursor 0, 10
            Local Doc$, line$
            Document Doc$
            Doc$=Format$("Game 2048 Score {0}", score)
            \\ Using Report 2 we use rendering as text, with center justify
            Report 2, Doc$
            Doc$={
            }
            Local i, j
            For i=0 to 3
                  line$=""
                  For j=0 to 3
                        line$+=Tile$(Board(BoardTileRight(j, i)))
                  Next j
                  Print Over $(2), Line$
                  Print
                  Doc$=Line$+{
                  }
            Next i
            Report 2, "Next:Use Arrows | Exit: Press End"
            Refresh
            ClipBoard Doc$
      End Sub
      Sub Gravity()
            k=-1
            for j=0 to 3 {
                  where=boardtile(j,i)
                  if k=-1 then if board(where)=0 then k=j : continue
                  if board(where)=0 then continue
                  if k=-1 then continue
                  board(boardtile(k,i))=board(where)
                  board(where)=0
                  k++
            }  
      End Sub
}
Game2048
}
MODULE FIX1 {Class fixme {
      f=lambda->1
}
fix->fixme()
next_fact=lambda fix (x)->{
     if x<=1 then =1 :exit
     =x*fix=>f(x-1)
}
fix=>f=next_fact
Print next_fact(5)
m=next_fact
Print m(5)
}
MODULE Y {op=Pen
Pen 15
Report {
	Y combinator in M2000
	Two versions for two functions 	factorial and fibonacci
	For example (the Lamnda identifier removed for now)
	(g, x)->{
		=g(g, x)
	}((g, x)->if(x=0->1, x*g(g, x-1)), 24@)
	
	We pass by value for first g this: (g, x)->if(x=0->1, x*g(g, x-1))
	and for x the value 24@ (decimal type)
	
	so we call the g function passing by value the same g (lambda functions are first citizen)
	we never call the current function g (by using lambda() for a reccursion call)
	
	so the combinator Y combinbe two functions, the first one and the internal function g which always provide.
	the result from internal g is either 1 or x*g(g, x-1) depends on value of x.
	
	We use If() statement which execute only one part after arrow.
	
	a lambda function need the Lambda identifier before and we can provide
	This is a simple lambda:
	a=lambda->0
	? a()=0   ' true
	Now with a parameter  (it is a simple form without {} and we can use it if we didn't provide a comma after)
	
	a=lambda (k)->k**2
	? a(2)=4
	Or
	a=lambda (k)->{
		' we can use many statements
		' the = statament never exit the function and is optional (without it a 0 returned)
		' the function ends with a break, or an exit, or at the end of a block, and on error
		=k**2
	}
	We can execute a lambda without assign a lambda to a variable, just use after arrow {funtion code here}():
	Print lambda (x)->{=x**2}(2)=4
	
	In the curly brackets we have a regular function with one diffrence. If we use closures that closures stay to lambda
	The closures in lambda can change state if we want. Using lambda() we can call again the same function, but closures are the same for each call
	If we want a lambda to return a string we use Lambda$ and for recursion lambda$()
	We can use lambda() and lambfa$() in any regular function.
	Also we can use &a to pass a lambda in a variable by reference, or &a() to pass the function by reference
	Passing the variable by reference we can change it and the change return back.
	Passing the function by reference only pass the code to a new function, but for lambda functions the clousres can be used
	We can define a closure in the lambda definition proviing a value, or we can just use a copy of an already defined one
	So we can make generators
	x=1
	a=lambda X -> {
		=X
		X++
	}
	Print a()=1, a()=2
	See the LambdaExample in the Y code (use Edit Y)
	
}
Module Ycombinator {
	\\ factorial  - 10@ is a decimal literal (29 digits)
	Print @(tab(2)), "factorial of 24 = ";lambda (g, x)->{=g(g, x)}(lambda (g, x)->if(x=0->1, x*g(g, x-1)), 24@)
	\\ fibonacci
	Print @(tab(2)),"fibonacci 10th = ";lambda (g, x)->{=g(g, x)}(lambda (g, x)->if(x<=1->x,g(g, x-1)+g(g, x-2)), 10)
	
	\\ Using closure in y, y() return function
	y=lambda (g)->lambda g (x) -> g(g, x)
	
	fact=y((lambda (g, x)-> if(x=0@->1@, x*g(g, x-1))))
	Print @(tab(2)), fact(6)," ", fact(24)
	
	fib=y(lambda (g, x)->if(x<=1->x,g(g, x-1)+g(g, x-2)))
	Print @(tab(2)), fib(10)
}
Pen 14
Ycombinator
Pen 15
Report {
	The lambda example
}
Pen 14
Module LambdaExample {
	x=1
	a=lambda X -> {
		=X
		X++
	}
	Print @(tab(2)), a()=1, a()=2
	b=a
	Print @(tab(2)), a()=3, a()=4
	Print @(tab(2)), b()=3, b()=4
	Module Inner(&z()) {
		Print @(tab(2)), z(), z()
	}
	Inner &b()    ' 5 6
	Print @(tab(2)), b()=7
	Module Inner2(z) {
		Print @(tab(2)), z(), z()
	}
	Inner2 b    ' 8 9
	Print @(tab(2)), b() ' 8
	Module Inner3(&m, n) {
		m=n
	}
	Inner3 &b, a
	Print @(tab(2)), b() '5
	
}
Pen 14
LambdaExample
Pen 15
Report {
	A closure isn't like a static variable. A static variable has a bond with the caller
	A closure has a bond only with the current lambda
	Exception exist for those closures which are pointers, we get a copy of pointer, so maybe two lambda share the same closure, because point to same container
	Containers maybe anything that provide a pointer
	Groups may or may not provide a pointer.
	
	The Counter function use a static variable.
	When we pass it by reference the C() called inside Inner4 create a new static x
	Next time this new static used
	But outside the Inner4 module we use the first static
	
	So static variables are not the same as closures.
	
}
Pen 14
Function Counter {
	Static x=1
	=x
	x++
}
Print @(tab(2)), Counter(), Counter()   ' 1 2
Module Inner4(&C()) {   
	Print @(tab(2)), C(), C()
} 
Inner4 &Counter()     ' 1 2
Inner4 &Counter()     ' 3 4
Print @(tab(2)), Counter(), Counter()  ' 3 4
Pen 15
report {
	Except of lambda and regular functions the latest M2000 version has the analogus to subs but as functions
	We can call these functions as Inner Functions because can exist only in a module or in a function (lammbda or regular function)
	Code for inner functions always are at the end of code, after END or after END SUB
	We can make number or string functions. The name of a function used by the subs system, with one exception: We can call an inner function if this function has different name from any of internal functions like Abs() and Sgn().  We can replace Abs() using regular function for a module, but the @Abs() always call the internal original function. So inner functions use the @ character, so first the interpreter check if it is an internal code and then call the inner function.
	An inner function has the same scope as a sub, has module scope.
	An inner function use the same stack for values as the module (regular functions and lambdas in an expresion start with a fresh stack of values, if we call them using Call like a module then we pass the module stack).
	We can't call an inner function using Call or Function() and Funcrion$().
	Interpreter search for inner function  the first time from the end in current code or from parent original code, but the code executed in the scope of current executed code.
	Goto can be used inside a Function ...End Function structure, also we can call subs or simple routines from.
	
}
\\ rules for names are like subs, but not like simple routines with Gosub to a label (which we have to use same case label)
Pen 14
Print @(tab(2)), @FACTORIAL(24) 
Print @(tab(2)), @factorial(10)
Pen 15
Report {
	Conclusion:
	For Y combinator we can use only lanbda functions which we use them as first citizens
	regular functions and inner functions can't be used.
	
	A regular function defined as the code executed. We can change the definition later or using an if before so we can select the code as we wish. Also we can pass it by reference. Also we can pass it to Event objects (which they hold list of functions)
	
	An inner function can't change
	
	
}
Pen OP
Clear \\ clear all static variables
End
Function factorial(x)
	if x<2 then =1@ : Exit Function
	=@factorial(x-1)*x
End Function

}
MODULE EV {Module CheckEvents {
      \\ we can use standard functions (not lambda functions)
      \\ we can use lambda() so we can use function with different names
      \\ We can define functions inside groups with events
     Group WithEvents Alfa {
           Event "GetIt", "PushIt"
           Function fib(n) {
                  if n<=1 then {
                        =val(n->Decimal)
                  } else {
                        if n<140 then { m=-1@} else m=-1
                        call event "Getit", n, &m
                        if m>-1 then =m : exit
                        \\ m1 may get double if a decimal can write the result
                        \\ if we use m we get overflow error
                        m1=lambda(n-1)+lambda(n-2)
                        call event "Pushit", n, m1
                        =m1
                  }            
            }
      }
      \\ we use an Inventory list to save old values
      Inventory Getit
      \\ event's service functions
      \\ if not event's functions exist, call event skipped
      Function Alfa_Getit {
            Read new key, &m
            if exist(Getit, key) then m=eval(Getit)
      }      
      Function Alfa_Pushit {
            Read new key, m
            Append Getit, key:=m
      }
      Module Inner (&fibonacci()){
            acc=0
            For i=1 to 200 ' until 139 we get decimal type, above it we get double
                  Print fibonacci(i),
            Next i
      }
      Form 80,32
      print $(4,20),	' set: proportional text, 20 characters column width
      Inner &Alfa.fib()
      print $(0,10),	' reset: no proportional text, 10 characters column width

}
CheckEvents
}
MODULE MG {oldfont$=Fontname$
Font "Arial"
Form 60,44
Escape Off
Flush
Flush Garbage
mybg=5
Cls mybg,0 : Pen 11
Bold 1
Report "Console Input Parameters Easy"
Bold 0
Cursor 0,0 : Print Under
Cls , 1

\\  ValidateValue(number, letter$)
\\  return a lambda function with closures And signature lambda(letter$), returning boolean
\\  ValidateValue( number, number)
\\  return a lambda function with closures And signature lambda(number), returning boolean

Function ValidateValue {
      IF match("NN") Then {
            Read X1, Y1
            =lambda X1, Y1 (n) ->{
                  =X1<=n And n<=Y1 ' Or n<Y1
            }
      } Else {
            Read what, x1$
            =lambda x1$, what (n$) ->{
                  IF what=0 Then {
                        =n$ ~ x1$
                  } Else.If what>0 Then {
                         =n$ >= x1$ And len(n$)>what
                  } Else = n$ >= x1$ And len(n$)>-what And n$=filter$(n$, " ")
            }      
      }
}
\\ InpValueClass make a group
\\ We can display labels, values, recording positions
\\ Using ScanRange we can use arrows To move from a range of input values, in Loop
\\ using Esc we get out from Loop
\\ we can give two more parameters
\\ the "Exit" value  And a flag, IF True Then Exit IF value changed
\\  mygroup=InpValueClass(#FF5522)  '' need a color for background
\\
\\  .Record=True  needed for recording
\\  .PrintLabel
\\  .PrintNext
\\  .PrintUp
\\  .UseLastAsList
\\ when we record we make ranges of input/print values And we can use
\\ .RenderView To print labels/values
\\ .ScanRange 
\\
Class InpValueClass {
Private:
      NoKey, LastKey$, UseInteger, drawbg, overridecolors, mybg, overfr, overbg
      Inventory Bag, EditItems
Public:
      Record=True,  item
      Property mywidth {
            Value, 
            Set {
                  IF value>width Then value=width
                  IF value<3 Then value=3
            }
       } = 10
      Property myheight {
            Value,
            Set {
                  IF value>height-1 Then value=height-1
                  IF value<1 Then value=1
            }
      }=1
      Group MaxInputItem {
            Value {
                  Link Parent EditItems To Ed
                  =Len(Ed)
            }
      }
      Group MaxItem {
            Value {
                  Link Parent Bag To Bag
                  =Len(Bag)
            }
      }
      Group ItemValue {
            Value (akey$) {
                  Link Parent Bag To Bag
                  =Bag(akey$+".value")
            }
            Set (akey$) {
                  Read mGroup
                  Link Parent Bag To Bag
                  IF exist(Bag, akey$+".value") Then {
                        Return Bag, akey$+".value":=mGroup
                  }
            }
      }
      Class Info {
            iskey, isbutton, menuitem, isnumeric
            Event CallBack { Read &What }
            ValidValue=Lambda->True
            myvalue$
            stackA=stack
            X, Y, mycolor, boldface
            W=10, H=1
            \\ only for button
            mybg
      Class:
            Module Info {
                  Read .isnumeric, .iskey, .MyValue$
                  Read .X, .Y, .W, .H, .mycolor, .boldface, .ValidValue
            }
      }
       Module PrintNext {
            Cursor 0, Row-1
            .PrintLabel
      }
      Module PrintLabel {
            ticket=False
            IF IsNum Then {
                  ticket=1-.UseInteger 
                  Read N 
                  IF ticket=2 Then { what$=Trim$(Str$(N,"0")) } Else  what$=Trim$(Str$(N))
            } Else Read what$
            Let colour=pen, spaces=0, boldface=0
            Read ?  spaces, colour, boldface
            bold Abs(boldface<>0)
            Pen colour {
                  Print @(spaces),
                  IF .Record Then RecordMe()
                  IF ticket Then  what$=Format$("{0}",N)
                  IF .drawbg Then .drawbg<=False : Print @(Pos,Row,Pos+.mywidth, Row+.myheight, .mybg);
                  IF .myheight>1 Then {
                        Legend ! what$, .mywidth, .myheight
                  } Else {
                        Legend ! what$, .mywidth, 1          
                  }
                  Print
            }
            bold 0
            Sub RecordMe()
                  Local mylambda=lambda->True
                  IF Not empty Then Read myLambda
                  IF  Not .NoKey Then {
                        Append .Bag, what$:=.Info(False, true, what$, Pos, Row, .mywidth, .myheight, colour, Abs(boldface<>0), mylambda)
                        .lastkey$<=what$+".value"
                        \\ using = And Not  <= we get Error in next call
                        \\ becaue = make a Local variable, but .lastkey$ is a group variable.
                  } Else {
                        Try ok {
                              Append .EditItems, len(.Bag)
                             Append .Bag, .lastkey$:=.Info(ticket, False, what$, Pos, Row, .mywidth, .myheight, colour, Abs(boldface<>0), mylambda)
                         }
                         \\ using of Flush Error To clean Error message first
                         IF Error Or Not ok Then Flush Error : Error "You can't record two values in same key"
                  }
            End Sub
      }
      Module PrintButtonNext {
            Cursor 0, Row-1
            .PrintButton
      }
      Module  PrintButton {
            Read .LastKey$, caption$
            Oldmybg=.mybg
            Read ? .mybg
            Push caption$
            .LastKey$<=.LastKey$+".value"
            .NoKey~
            .drawbg~
            .PrintLabel
            .NoKey~
            \\ Bag(key) Or Bag(num!) num from 0 To len(Bag)-1
            Read ? event_copy
            there=Len(.Bag)-1
            
            For .Bag(there!), this {
                 .isbutton<=True
                 .callback<=event_copy
                 .mybg<=..mybg
            }
            swap Oldmybg, .mybg
      }
      Module PrintText (Lines, TextWidth) {
            Cursor 0, Row-1
            .NoKey~
            Let oldw=.mywidth, oldH=.myHeight
             .mywidth<=TextWidth
             .myheight<=Lines
            .PrintLabel 
            swap .mywidth, oldw
            swap .myHeight, oldH
            .NoKey~
      }
      Module  UseLastAsList (ArrayA) {
            Read ? event_copy
            IF  Instr(.lastkey$,".value") Else Exit
            For .Bag(.Lastkey$)  {
                  Stack New {
                        Data !ArrayA
                        .CallBack<=event_copy
                        \\ this [] pass current stack To .StackA, and leave a new empty stack
                        \\ [] is "[" and "]" (these chars can be used in variables names too)
                        .StackA<=[]
                  }
            }
      }
      Module InpList {
            a=Each(.EditItems)
            While a {
                  \\ ! use position (form 0) And no key To walk in .bag()
                  for .bag(eval(a)!) {
                        Print .MyValue$, Len(.stackA)>0, .isbutton, .iskey
                  }
            }
      }
      Group Json$ {
            Value (x) {
                 ' quote$(string$(MyValue$ as json)) 
                 bag$=""
                 nl$={
                 }
                 if x<=0 then nl$="" : x=0
                  space$=string$(" ",x)
                  Link Parent bag To bag
                  a=Each(bag)
                  While a {
                        M= bag(a^!)
                        For M {
                              IF Not .iskey and Not .isbutton Then {
                              if bag$<>"" then bag$=bag$+", "+nl$
                                    bag$=bag$+space$+quote$(Replace$(".value","",Eval$(bag, a^-1)))+" : "+quote$(string$(.MyValue$ as json)) 
                               }
                        }
                  }
                  ="{"+nl$+bag$+nl$+"}"
            }
            Set {
                  Read bag$
                  c$=""""   \\ this is one char 34
                  nl$={
                  }
                  end$=""
                  Link Parent bag To bag
                  safety=len(bag$)
                   Stack New {
                   if left$(trim$(bag$),1)="{" then  {
                         bag$=Trim$(RightPart$(bag$,"{"))
                         end$="]"
                   } else.if left$(trim$(bag$),1)="[" then  { 
                        bag$=Trim$(RightPart$(bag$,"{"))
                        end$="}"
                   }
                        do {
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$, c$))
                              mkey$=LeftPart$(bag$, c$)+".value"
                              bag$=Trim$(RightPart$(bag$, c$))
                              if mkey$="" then exit
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$,":"))
                              While Left$(bag$,2)=nl$ {bag$=Trim$(Mid$(bag$, 3))}
                              bag$=Trim$(RightPart$(bag$, c$))
                              mval$=LeftPart$(bag$, c$)
                              bag$=Trim$(RightPart$(bag$, c$))
                              Group M
                              if exist(bag, mkey$) Then {
                                    M=eval(bag)
                                    M.myvalue$<=format$(mval$)
                                    Return bag, mkey$:=M
                              }
                              If left$(bag$, 1)="," then bag$=Trim$(Mid$(bag$, 2)) : Restart
                              if end$<>"" then if left$(bag$,1)=end$ then exit
                              if safety=len(bag$) then Error "Json parse problem"
                              safety=len(bag$)                              
                        } Until bag$=""
                        
                  }
            }
      }
      Group Serialize$ {
            value {
                  bag$=""
                  Link Parent bag To bag
                  a=Each(bag)
                  While a {
                        M= bag(a^!)
                        For M {
                              IF Not .iskey and Not .isbutton Then {
                                    IF .isnumeric Then {
                                     bag$=bag$+" "+.MyValue$
                                    } else  bag$=bag$+stack$(.MyValue$)
                               }
                        }
                  }
                  =bag$
            }
            Set {
                  Read bag$
                  Stack New {
                        Stack bag$  \\ fill stack with special format string for stack
                        Link Parent bag To bag
                        a=Each(bag)
                        Try ok {
                              While a {
                                    M= bag(a^!)
                                    For M {
                                          IF Not .iskey And Not .isbutton Then {
                                                IF .isnumeric=1 Then {
                                                      Read N
                                                      .MyValue$=Trim$(Str$(N))
                                                } Else.If  .isnumeric=2 Then {
                                                      Read N%
                                                      .MyValue$=Trim$(Str$(N%))
                                                } Else Read .MyValue$
                                           }
                                    }
                              }
                        }
                        If Error Or Not ok Then Flush Error : Error "Serialize Input Not Compatible"
                  }
            }
      }
      Module PrintUp {
            Cursor 0, Row-1
            .NoKey~
            .PrintLabel
            .NoKey~
      }
      Module PrintUpInteger {
            Read N
            Push Val(Str$(N,"0"))
            Cursor 0, Row-1
            .NoKey~
            .UseInteger~
            .PrintLabel
            .UseInteger~
            .NoKey~
      }
      Module RenderThis {
            Read M
            Read ? offsetX, offsetY
            IF .overridecolors Then {
                  mybg= .overbg
            } else {
                  mybg=.mybg
            }
            local inuse, final$
            For M {
                        IF this.overridecolors and .isbutton Then exit
                        offsetX+=.X
                        offsetY+=.Y
                        Cursor offsetX, offsetY
                        IF .isbutton Then mybg=.mybg  \\ from M.mybg
                        Print @(offsetX, offsetY, offsetX+.W, offsetY+.H, mybg);
                        IF this.overridecolors Then {inuse=this.overfr} else inuse=.mycolor
                        Pen inuse {
                              Bold .boldface
                              if .isnumeric then {
                                   final$=format$( "{0}", Val(.MyValue$) )
                              } else final$=.MyValue$
                              IF .H>1 Then {
                                    Legend ! final$, .W, .H
                              } Else Legend ! final$, .W, 1
                              Bold 0
                        }
                  }
      }
      Module RenderView {
            local fromA=1, toB=-1, offsetX, offsetY
            Read ? FromA, toB, offsetX, offsetY, .overridecolors
            IF .overridecolors Then Read .overfr, .overbg
            N=Each(.Bag, FromA, toB)
            While N {
                  .RenderThis .Bag(N^!),offsetX, offsetY
            }
            Print
            .overridecolors<=false
      }
      Module ScanRange {
            Local FromA=1, ToB=.maxitem, vert, curx, cury, mKey$
            IF ToB=0 Then Exit
            Read ? FromA, ToB
            Read ? ExitC, forever
            Local changed
            .item<=FromA
            Field New 1 ' reset To 1 the Field internal variable.
            mybg=.mybg
            {
                  GetAValue(.item, &changed)
                  IF changed Then vert=False
                  IF Field=99 Or Field=121 Then .item<=0 : Exit
                  IF Field=1000 Then Exit
                  IF .item=ExitC And (changed Or Not forever) Then Field New 1000 : Exit
                  IF vert  Then {
                        vert=False
                        IF .item>=ToB  And Field=1 Then Exit
                        IF .item<=FromA  And Field=-1 Then Exit
                        IF Field=1 Then {
                              a=Each(.EditItems, .item+1, ToB)
                        } Else  a=Each(.EditItems, .item, FromA)
                        last=.item
                        Try {
                              While a {
                                    IF Field=1 Then {
                                           for .bag(eval(a)!) {
                                                IF .x>=curx And .y>cury Then last<=a^ :Break
                                         }
                                    } Else {
                                           for .bag(eval(a)!) {
                                          IF .x>=curx And  .y<cury Then {
                                                field new 0 : last<=a^+1 
                                                IF .x>curx   else  Break
                                          }
                                          }
                                    }
                              }
                        }          
                        .item<=last      
                  } 
                  IF Field=1 Then .item++
                  IF Field=-1 Then .item--
                  IF .item<FromA Then .item<=ToB
                  IF .item>ToB Then .item<=FromA
                  CONTHERE:
                  Loop
            }
            Sub CheckOk()
                  Refresh
                  ok=-2
                  {
                        ok=inkey(100)  \\ delay 100ms IF no key pressed (return -1 IF no key pressed in 100ms)
                        IF ok=-1 Then Loop   ' any block can performe once using loop statement
                  }
                  Select Case ok
                  Case 121 ' F10
                        oldfield=121
                  Case 262162
                        oldfield=99
                  Case 38
                        { oldfield=-1 : vert=True }
                  Case 40  ' two Or more statements need a block after Case
                        { oldfield=1 : vert=True}
                  Case 39 ' left
                        oldfield=1 
                  Case 37 ' right
                        oldfield=-1  
                  Case 27, -2
                        {
                              While keypress(27) {} : oldfield=99
                        }
                  End Select
            End Sub
            Sub GetAValue(where, &changed)
                  Local N,N$, posnow=Pos, rownow=Row, StackB, k$, oldfield=Field, ok
                  IF Not Abs(oldfield)=1 Then oldfield=1
                  Try ok {
                        where=val(eval$(.EditItems, where-1))
                  }
                  IF Error Or Not ok Then Exit Sub
                  Try {
                        mKey$=Eval$(.Bag, where)
                  }
                  IF mKey$="" Then Exit Sub
                  IF  Instr(mKey$,".value") Else Exit Sub
                  temp=.Bag(mKey$)
                  For temp {
                        Let curx=.x, cury=.y
                        IF  Len(.stackA)>0 Then {
                              Print @(.X,.Y, .X+.W, .Y+.H, 7),
                              IF Not .isbutton Then  Mark 1,1, 8: Print " ";
                              Pen .myColor {
                                    Bold .boldface
                                    IF .H>1 Then {
                                          Legend ! .MyValue$, .W, .H
                                    }  Else  Legend ! .MyValue$, .W, 1
                                    Bold 0
                              }
                              CheckOk()
                              IF ok=13 Or ok=9 Or ok=32 Then {
                                    ShowMenu()   
                              }
                        } Else.If  .isnumeric Then {
                              Print @(.X,.Y, .X+.W, .Y+.H, 7);
                                          Pen .mycolor {
                                                Bold .boldface
                                                Legend ! Format$("{0}",val(.MyValue$)), .W, 1
                                                Bold 0
                                          }
                                          CheckOk()
                                          IF ok>=96 And ok<=105 Then ok=ok-48
                                          IF ok=13 Or ok=9  Or Chr$(ok) ~ "[0-9]" Then {
                                                N=Val(.MyValue$)
                                                Pen .mycolor {
                                                IF Chr$(ok) ~ "[0-9]" Then {
                                                      IF N=0 Then {N=Val(Chr$(ok))} Else N=Val(.MyValue$+Chr$(ok))
                                                }
                                                    Print @(.X,.Y,.X+.W, .Y+.H, 7);
                                                    IF .isnumeric=2 Then {
                                                            N%=N
                                                            Input ! N%, .W
                                                            N=N%
                                                    } Else Input ! N, .W
                                                }
                                                IF .ValidValue(N) Then {
                                                      changed=Not .MyValue$=Trim$(Str$(N))
                                                      .MyValue$<=Trim$(Str$(N))
                                                }
                              }
                        }  Else {
                                   Print @(.X,.Y,.X+.W, .Y+.H, 7);
                              IF .isbutton Then {
                                   Pen .mycolor {
                                          Bold .boldface
                                          IF .H>1 Then {
                                                Legend ! .MyValue$, .W, .H
                                          }  Else Legend ! .MyValue$, .W, 1
                                          Bold 0
                                    } 
                                    CheckOk()
                                    Field New oldfield
                                    IF  ok=13 Then  Call Event .callback,  &This, Replace$(".value","", mKey$) : changed=True
                                    oldfield=Field
                              } Else { 
                                    N$=.MyValue$
                                    Pen .mycolor {
                                          Bold .boldface
                                          IF .h>1 Then {
                                                Legend ! .MyValue$, .W, .H
                                                CheckOk()
                                                IF ok=13 Or ok=9  Or ok=32 Then  Input ! N$, .w, .h,"Editor"
                                          } Else {
                                                Legend ! .MyValue$, .W, 1
                                                CheckOk()
                                                IF ok=13 Or ok=9 Or ok=32 Then Print @(.X,.Y,.X+.W, .Y+.H, 7); : Input ! N$, .w
                                          }
                                          Bold 0                              
                                    }
                                    IF  .ValidValue(N$)  Then {
                                          changed=Not .MyValue$=N$
                                          .MyValue$<=N$
                                    }
                              }
                        }
                        IF .isbutton Then {
                        Print @(.X,.Y, .X+.W, .Y+.H, .mybg);
                        } Else  Print @(.X,.Y,  .X+.W, .Y+.H, mybg);
                        Pen .mycolor {
                              Bold .boldface
                              IF .H>1 Then {
                                    Legend ! .MyValue$, .W, .H
                              }  Else {
                                    IF .isnumeric Then {
                                      Legend ! Format$("{0}",val(.MyValue$)), .W, 1
                                     } Else  Legend ! .MyValue$, .W, 1 
                                }
                              Bold 0
                          }        
                  }
                  Field New oldfield
                  Cursor posnow, rownow
                 Return  .Bag, mKey$:=temp
            End Sub
            Sub ShowMenu()
                        oldfield=1
                        Print @(.X,.Y+1),
                        IF Not .isbutton Then Print @(.X,.Y), :Mark 1,1, 15 :  Print " ";
                        menu fill 7,7, .mycolor
                        menu frame off
                        menu  \\ erase menu
                        StackB=Each(.stackA)
                        While StackB {
                              Menu  + stackitem$(StackB)
                        }
                        try ok {
                              menu show .MyValue$
                        } 
                       IF Error Or Not ok Then Error flush : Menu !   \\ show menu
                       Menu fill 1  \\ reset fill colors
                       menu frame  \\ reset frame
                       IF menu>0 Then {
                             IF Not .isbutton Then {
                                    changed=Not .MyValue$=menu$(menu)
                                    .MyValue$<=menu$(menu)
                              } Else .menuitem<=menu
                              Field New oldfield
                              Call Event .callback,  &This, Replace$(".value","", mKey$)
                              oldfield=Field
                              IF Abs(oldfield)=1 Then oldfield=0
                        } Else oldfield=0
      End Sub
      }
      Class:
      module  InpValueClass (.mybg) {
            Read ? .mywidth, .myheight
      }
}

LocalVar$="New Title - Module scope variable"
exitthis=False
Function FromEvent {
      Read New &What, mykey$
      Local K
      K=Ask(what.myvalue$, LocalVar$,"*")
}
Function FromEvent2 {
      Read New &What, mkey$
      Local K
      IF what.menuitem>0 Then {
            IF instr(Menu$(what.menuitem),"---")>0 Then Break
            K=Ask(what.myvalue$+" "+Menu$(what.menuitem), "No2",,"*")
            If K<>1 then break
            IF what.menuitem=2 Then {
                  M=InpValue2.ItemValue("Exit")
                  M.myvalue$="Press me "+Time$(Now)
                  InpValue2.ItemValue("Exit")=M
                  InpValue2.RenderThis M
            }
      } Else {
             K=Ask(what.myvalue$, "No2")
      }
      IF mKey$="File" And what.menuitem=4 Then Field New 99  : exitthis=True : Exit
      Cls, -14
      InpValue2.InpList
}
Function FromEvent3 {
      \\ this is a module's variable
'     exitthis=True
'      Field New 99
      \\ We can use 1000 as default Exit
      Field New 1000
}
Event E1 { Read &A, B$}
E2=E1  ' copy of E1 To E2
FIN=E2 ' copy of E2 To FIN
\\ Using  Lazy$(&FromEvent()) And Not FromEvent() we pass code from module
\\ when run take the module name space, so all modules variables/modules/functions are visible
\\ except subrutines.
Event E1 New Lazy$(&FromEvent())
Event E2 New Lazy$(&FromEvent2())
Event FIN New Lazy$(&FromEvent3())
\\ Now we have
 InpValue=InpValueClass(mybg)
 InpValue2=InpValueClass(mybg)
middlepoint=0
For InpValue {
      .mywidth=6
      .PrintButton "File","File [F10]",,,8,1,,E2
      .UseLastAsList ("Menu1","Menu2","Menu3","Exit")
      .PrintButtonNext "Edit","Edit",,6,8,1,,E2
      .UseLastAsList ("Help","Update","--------","About")
      }
For InpValue2 {      
      .mywidth=10
      .PrintLabel "Element",,15,1
      .PrintLabel "Type", 4
      .PrintUp "Combo", 10, 14
      .UseLastAsList ("ListBox","Combo", "TextBox", "EditBox"), E1
      .PrintLabel "Name", 4
      .PrintUp "Combo1", 10, 14,,ValidateValue(-3, "A")
      .PrintLabel "Text Field",4
      Document AA$={aaaaaaaaaaaaa
                                          bbbbbbbbbbbbb
                                          cccccccccc
                                          }
      .PrintText 3, 30, AA$, 10,14
      middlepoint=.maxitem
      Cursor 0, Row+4
      .PrintLabel "Attributes",,15,1
      .PrintLabel "Title", 4
      .PrintUp "Form1", 10, 14
      .PrintLabel "Top", 4
      .PrintUpInteger 0, 10, 14
      .PrintNext "Left",24
      .PrintUpInteger 0, 30, 14
      .PrintLabel "Width",4
      .PrintUpInteger 4000, 10, 14, ,ValidateValue(3000, 12000)
      .PrintNext "Height",4+20
      .PrintUpInteger 6000, 10+20, 14
      .PrintLabel "Double",4
      .PrintUp pi, 10, 14
      .PrintNext "Double1",24
      .PrintUp 2*pi, 30, 14
      .PrintNext "Double2",44
      .PrintUp 4*pi, 50, 14
      .PrintButton "Exit","For Exit Come Here", 8, 10, 15, 1,,FIN
       Print "Press Esc Key"
      THERE:
     Cls, Row
   \\    .RenderView
}
\\Exit
maxInputitem=InpValue2.maxInputItem
do {
      do {
      InpValue.ScanRange
      } until Field<>121
      IF exitthis Then Exit
      InpValue2.ScanRange 1, maxInputitem, maxInputitem-1, True
} until exitthis Or Field=1000

\\ Part 2
Cls 15, 1
Pen 0
Report "Print to Paper <Demo on Screen>"
\\ export without buttons, black color on white paper
InpValue2.RenderView 1,7, 5, 5, true, 0, 15
\\ -1 is the maxitem in bag
Cursor 0,15
Report "We can move a group by offset X and Y"
\\ using -1 for end mark
\\ 5 chars right, 10 char lines down
InpValue2.RenderView 8, -1, 5, 10, true, 0, 15

Print InpValue2.maxitem
A$=InpValue2.Serialize$
Print A$
InpValue2.Serialize$=A$
A$=key$
cls mybg,1
Pen 15
Report "RenderView"
InpValue2.RenderView 
Report "Json 2 chars indent"
Pen 14
Report InpValue2.Json$(2)
A$=InpValue2.Json$(0)
Pen 15 {
      Report "Json 0 chars indent"
}
Report A$
Pen 15 {
      Report "Len json$ vs Serialize$"
}
Print  Len(A$), Len(InpValue2.Serialize$)  '' 216, 123
InpValue2.Json$=A$
Pen 15 {
      Report {InpValue2.Json$={"Left" : "1000", "Top" : "500"}}
}

InpValue2.Json$={"Left" : "1000", "Top" : "500"}
Report InpValue2.Json$(0)
Escape on
bold true
Font OldFont$
}
MODULE QSORT3 {Module Checkit3 {
      Class Quick {
      Private:
            partition=lambda-> {
                  Read &A(), p, r : i = p-1 : x=A(r)
                  For j=p to r-1 : If .LE(A(j), x) Then i++:Swap A(i),A(j)
                  Next j : Swap A(i+1), A(r) :  Push  i+2, i 
            }
      Public:
            LE=Lambda->Number<=Number
            Module ForStrings {
                  .partition<=lambda-> {
                        Read &A$(), p, r : i = p-1 : x$=A$(r)
                        For j=p to r-1 : If A$(j)<= x$ Then i++ : Swap A$(i),A$(j)
                        Next j : Swap A$(i+1), A$(r) : Push i+2, i
                  }
            }
            Function quicksort {
                  Read ref$
                  do 
                        loop : If Stackitem() >= Stackitem(2) Then 
                        Drop 2  
                        \\ if  empty then Break else continue  
                                           \\ because is hidden  if empty then {Break} else continue
                         \\ but here 
                         if  empty then
                               exit 
                        else
                              continue
                        end if
                        end if
                        over 2,2 : call .partition(ref$) :shift 3 
                  always
            }
      }
      Quick=Quick()
      Dim A(10)<<Random(50, 100)
      Print A()
      Call Quick.quicksort(&A(), 0, Len(A())-1)
      Print A()
      Quick=Quick()
      Function join$(a$()) {
            n=each(a$(), 1, -2)
            k$=""
            while n {
                  overwrite k$, ".", n^:=array$(n)
            }
            =k$
      }
      Stack New {
                  Data "1.3.6.1.4.1.11.2.17.19.3.4.0.4" , "1.3.6.1.4.1.11.2.17.19.3.4.0.1", "1.3.6.1.4.1.11150.3.4.0.1"
                  Data "1.3.6.1.4.1.11.2.17.19.3.4.0.10", "1.3.6.1.4.1.11.2.17.5.2.0.79", "1.3.6.1.4.1.11150.3.4.0"
                  Dim Base 0, arr(Stack.Size)
                  i=0 : While not Empty {Let arr(i)=piece$(letter$+".", ".") : i++ }
      }
      \\ change comparison function
      Quick.LE=lambda (a, b)->{
            Link a, b to a$(), b$()
             def i=-1
             do {
                   i++
             } until a$(i)="" or b$(i)="" or a$(i)<>b$(i)
             If b$(i)="" Then =a$(i)="":Exit
             If a$(i)="" Then =true:Exit
             =val(a$(i))<=val(b$(i))
      }
      Call Quick.quicksort(&arr(), 0, Len(arr())-1)
      For i=0 to len(arr())-1 {
            Print join$(arr(i))
      }
      \\ Fresh load
      Quick=Quick()
      Quick.ForStrings
      Dim A$()
      A$()=("one","two", "three","four", "five")
      Print A$()
      Call Quick.quicksort(&A$(), 0, Len(A$())-1)
      Print A$()
}
Checkit3
}
MODULE CONC {Thread.Plan Concurrent
Module CheckIt {
      Flush  \\ empty stack of values
      Data "Enjoy", "Rosetta", "Code"
      For i=1 to 3 {
            Thread {
                  Print A$
                  Thread This Erase
            } As K
            Read M$
            Thread K Execute Static A$=M$
            Thread K Interval Random(500,1000)
            Threads
      }
      Rem : Wait 3000   ' we can use just a wait loop, or the main.task loop
      \\ main.task exit if all threads erased
      Main.Task 30 {
      }
\\ when module exit all threads from this module get a signal to stop.
\\ we can use Threads Erase to erase all threads.
\\ Also if we press Esc we do the same
}
CheckIt
 
\\ we can define again the module, and now we get three time each name, but not every time three same names.
\\ if we change to Threads.Plan Sequential we get always the three same names
\\ Also in concurrent plan we can use a block to ensure that statements run without other thread executed in parallel.
\\ Also there is another statement (not used here): Part { code block} As Variable  Look Help Part 
Module CheckIt {
      Flush  \\ empty stack of values
      Data "Enjoy", "Rosetta", "Code"
      For i=1 to 3 {
            Thread {
                  Print A$
                  Print A$
                  Print A$
                  Thread This Erase
            } As K
            Read M$
            Thread K Execute Static A$=M$
            Thread K Interval Random(500,530)
            Threads
      }
      Rem : Wait 3000   ' we can use just a wait loop, or the main.task loop
      \\ main.task exit if all threads erased
      Main.Task 30 {
      rem refresh  ' use refresh to show something
      }
\\ when module exit all threads from this module get a signal to stop.
\\ we can use Threads Erase to erase all threads.
\\ Also if we press Esc we do the same
}
CheckIt
Thread.Plan Sequential
}
MODULE LISP {Profiler
EntryLevel =0
Module forall {  \\ For all subs - reusable code use Call ! Local forall
      Local MyAcc$
      Document MyAcc$
      Clear Buffer$  \\ delete command - need Clear /  = is For append
      Call Local Parser(level,  &MyAcc$)
}
Module Comm {
      Read proc$
      Call ! Local forall
      Local dummy$=paragraph$(MyAcc$,-1,-1)
      Local a, d, acc
      Long a, d=forward(MyAcc$, a)  \\ there is a  backward() function too
      If d<>0 Then {
      Select Case proc$
      Case "+"
      { While a<>0 { acc+=Val(paragraph$(MyAcc$, (a))) }}
      Case "-"
            {         If a<>0 Then   acc=Val(paragraph$(MyAcc$, (a))) 
                       While a<>0 { acc-=Val(paragraph$(MyAcc$, (a)))  }}
      Case "*"
            { acc=1: While a<>0 { acc*=Val(paragraph$(MyAcc$, (a))) }}
      Else  '  Case "/"
            { acc=1
                  If a<>0 Then  acc=Val(paragraph$(MyAcc$, (a))) 
                  While a<>0 { acc/=Val(paragraph$(MyAcc$, (a))) }}
      End Select    
       Accum$=Format$("{0}", acc)+nl$
      } 
}
Module CommWrite {
      Call ! Local forall
      Print "Lisp:";
      Local i, f=Doc.Par(MyAcc$)
      If f>1 Then {
      f--  : If f>1 Then Print "(";
      For i=1 to f
            Print paragraph$(MyAcc$, i); : If i<f Then  Print " ";
      Next i
      }
      If f>1 Then { Print ")" } Else Print
}
Module LoopLisp {
      Local dummy$ : Clear Buffer$
      cnt++ : Local backhere=cnt
      Local mylevel=level
      {
            Call Local Parser(myLevel, &Accum$)
            dummy$=paragraph$(Accum$,-1,-1)     \\ throw  last nl$
            dummy$= paragraph$(Accum$,-1,-1)
            Accum$=nl$  \\ insert  last nl$
            If dummy$="t" Then Exit
            cnt=backhere
            level=mylevel
            loop   
      }          
}
Module MyList {
      Local MyAcc$
      Document MyAcc$ : Clear Buffer$
      Call Local Parser(level, &MyAcc$)
      Accum$="("+Trim$(Replace$(nl$," ", MyAcc$))+")"+nl$       
}
Module Myif {
      Call ! Local forall
      If paragraph$(MyAcc$, 1)="t" Then {
            Accum$=paragraph$(MyAcc$, 2)+nl$
      } else {
            Accum$=paragraph$(MyAcc$, 3)+nl$
      }
}
Module DefVar {
      Local MyAcc$, Iddoc$
      Document MyAcc$, Iddoc$ : Clear Buffer$
      cnt++
      Call Local Parser(level,  &Iddoc$, True)
      Call Local Parser(level,  &MyAcc$)
      Local id$=paragraph$(Iddoc$, 1,-1)  \\ third parameter If is -1 Then delete the paragraph 
      If id$="" Then Error "No name For variable"
      While Doc.Par(iddoc$)>0 {
            Call Local PrintNewLine "Var :"+id$
            If not exist(Mem,id$) Then {
                  Append Mem, id$:=MyAcc$
            } Else Error "Variable "+id$+" already defined"
           id$=paragraph$(Iddoc$, 1,-1)
      }
}
Module SetVar {
      Local MyAcc$, Iddoc$
      Document MyAcc$, Iddoc$ : Clear Buffer$
      cnt++
      Call Local Parser(level, &Iddoc$, True)
      cnt--
      Call Local Parser(level, &MyAcc$)
      Local id$=paragraph$(Iddoc$, 1,-1)  \\ third parameter If is -1 Then delete the paragraph 
      If id$="" Then Error "No name For variable"
      While Doc.Par(iddoc$)>0 {
            Call Local PrintNewLine "Var :"+id$
            If exist(Mem,id$) Then {
                  Return Mem, id$:=MyAcc$
            } Else Error "No such variable"
           id$=paragraph$(Iddoc$, 1,-1)
      }
}
Module Cons {
      Call ! Local forall
      Accum$=MyAcc$
}
Module Remark {
     while cnt<=tmproof {
           cnt++
           If mid$(a$, cnt,2)=nl$ Then cnt++ : exit
     }
}
Module String {
     Local check=cnt
     Clear Buffer$ : numeric=false
     while cnt<=tmproof {
           cnt++
           If mid$(a$, cnt,1)=qu$ Then exit
     }
     if cnt-check>1 Then { Buffer$=Mid$(a$,check, cnt-check+1)} Else Buffer$={""}
}
Module  PrintBuffer {
      If Doc.Len(Buffer$)>0 Then {
                  If exist(Mem, Buffer$) and not GetQuote Then {
                       Accum$=Mem$(Buffer$)
                  } else   Accum$=Buffer$+nl$
            Call Local PrintNewLine Buffer$
            Clear Buffer$ : prints++
      }
}
Module PrintNewLine {
      Read New What$
     If mess Then Print what$
}
Module StopChar {
      Read New val    
      com = val=1
      level+=val
      If GetQuote And level<=EntryLevel Then Call Local PrintBuffer : GetQuote=false: tmproof=cnt : Exit
      If val<>0 Then Local oldprints=prints : prints=0
      Call Local PrintBuffer
      If profil=1 And val=-1 Then If prints=0 Then If oldprints=prints Then Buffer$="()" : Call Local PrintBuffer
      profil=val
}
Module StopCharZero {
      If GetQuote And level=EntryLevel Then Call Local PrintBuffer:GetQuote=false: tmproof=cnt : Exit
      If com Then Call Local CheckCommand
      If not com Then Call Local PrintBuffer : Exit
}
Module StorePeriod {
      If Doc.Len(Buffer$)=0 Then Call Local StoreNumeric : Exit
      If numeric Else Call Local StoreLabel : Exit  \\ see Else, same as If not numeric Then
      If Instr(Buffer$,".")>0 Then Call Local PrintBuffer
      Call Local StoreNumeric
}
Module StoreSign {
      If Doc.Len(Buffer$)>0 And numeric Then Call Local PrintBuffer : Call Local  StoreNumeric : Exit
      Call Local StoreNumeric  \\ maybe numeric=False so this is like storelabel...
}
Module StoreNumeric {
      If Doc.Len(Buffer$)=0 Then  numeric=True 
      buffer$=one$
}
Module StoreLabel {
      numeric=False
      buffer$=one$
}
Module CheckCommand {
      com=false
      If GetQuote Then Exit
      If numeric Then {
            If Doc.Len(Buffer$)=1 Then If Instr("*/+-",Buffer$)>0 Then Exit
            Exit
      }
      If Exist(commands, Buffer$) Then  push eval$(commands) : Call Local letter$
}
Module Sym {
      Read new w$
      Call ! Local forall
      If Evall(quote$(paragraph$(MyAcc$, 1) )+ w$+ Quote$(paragraph$(MyAcc$, 2) )) Then {
       Accum$=t$  } Else  Accum$=nil$
}
Module Quote {
      Clear Buffer$
      cnt++
      Call Local Parser(level, &Accum$, True)
      cnt--
}
Module Car {
      Call ! Local forall     
      Accum$=paragraph$(MyAcc$, 1)+nl$
}
Module Cdr {
      Call ! Local forall     
      Local drop$=paragraph$(MyAcc$, 1,-1)
      Accum$=MyAcc$
}
Module Eq {
      Call ! Local forall
      If paragraph$(MyAcc$, 1)=paragraph$(MyAcc$, 2) Then {
            Accum$=t$
      } Else  Accum$=nil$
}
Function Parser {
      Read New EntryLevel,  &Back$
      Local GetQuote  
      Read ? GetQuote  \\ this is an optional argument For Parser
      Local tmproof=roof, Accum$
      Document Accum$
      Repeat  {
      If level<EntryLevel Then cnt-- : Back$=Accum$ : Exit
      one$=mid$(a$,cnt,1)
      \\ warning in each Case one command in one line or use { } For multiple commands/lines
      \\ no empty lines allowed. 
      Select Case one$
      Case  qu$
            Call Local String
      Case ";"  \\ remark
            Call Local Remark
      Case "'"  \\ quote
            Call Local Quote
      Case "("
            Call Local StopChar, 1 ''StopChar(1)
      Case ")"
            Call Local StopChar, -1 ''StopChar(-1)
      Case " ", Ch10$, Ch13$  ' white space too
            Call Local StopCharZero
      Case "0" to "9"
            Call Local StoreNumeric
      Case "."
            Call Local StorePeriod
      Case "-", "+"
            Call Local StoreNumeric
      Else Case
            Call Local StoreLabel
      End Select
      cnt++
      } Until cnt>tmproof 
      if cnt>tmproof  then  Back$=Accum$

}
\\ Mini lisp ver 0.01
Clear \\ clear variables
Flush \\ empty stack
Form ! 60,48

Print "MiniLisp Ver 0.01"
Scroll Split  Row  \\ make this row start of scrolling screen
\\ A simple lisp interpreter written in M2000 by George Karras
\\For Documents "=" is For append text. Clear a$, give a new object Document.
Document a$={
                        "hello there this is a string"  ; this is going to result
                        (write 1223345.788)(defvar Hello "M2000")(write Hello)
                        (write 121 "Hello again...")
                        (eq 7 7)(write (list 1 2 4 5))(defvar A (+ 7 9 13 1 5 7) ) (write A  (- A 10) (* A 3) (/ 5 2))
                        (defvar (a b c d) 100)(write a b c d)(setq a (+ a 1))(write '(a =) a)(write (car '(a b c))(cdr '(a b c))) ; remark
                        (write (cons 'a '(b c)))(write George 'Karras)(write (eq a 101))
                        (this is written as result)(write '(This written before results) (+ a 1))
                        (quote (Hello 1 There a b))  '(Hello 2 There a b)(eq 5 5)
                        (loop (write a) (eq a 107) (setq a (+ a 1))) (write (list 1 A (+ A 1) 3 4 5))
                        (write 1 A (+ A 1) 3 4 5)
                        (write (If t 5 6))  (write ok)
                        (write (If nil (list 1 2 3) (list 4 5 6)))
                        (write (If nil 5 6))
                        (write (If t (list 1 2 3) (list 4 5 6)))
                        ; A form which calls the + function with 1,2 and 3 as arguments.
                        ; It returns 6.
                        (write (+ 1 2 3))
                        }                    
Print "Parse:";
Report a$
Print
nl$={
} \\ nl$ is new line
Let level=0, one$="", numeric=False, prints=0, com=False, profil=1, ch10$=chr$(10),ch13$=chr$(13), qu$=chr$(34)
Let mess=false '\\true   \\ For messages
Let cnt=1, roof=len(a$), comlevel=-1 
' no command
Document Buffer$, Result$
\\ Inventory is a hash table.
Inventory commands="+":="Comm {+}",  "-":="Comm {-}" , "*":="Comm {*}", "/":="Comm {/}", "write":="CommWrite", "car":="Car", "cdr":="Cdr", "cons":="Cons",  "defvar":="DefVar", "eq":="Eq", "setq":="SetVar", "quote":="Quote", "loop":="loopLisp",">":="Sym {>}" ,"<":="Sym {<}", ">=":="Sym{>=}","<=":="Sym{<=}", "<>":="Sym{<>}", "list":="MyList","If":="Myif"
Clear t$, nil$
\\ we want a paragraph only - with new line
Inventory mem  \\ For variables
t$="t"+nl$
nil$="nil"+nl$
Append Mem, "t":=t$,"nil":=nil$
Try ok {  Call Local Parser(level,  &Result$)}
If Error or Not Ok Then Print Error$
If level>0 Then Error "more ("
If Not Mess Then {
      Report 2, "Results" 
      Report Replace$(nl$," ", Result$)
}
Print Timecount
}
MODULE P {// this is not a game is an example for how we make a game using threads and sprites. Images are simple for this example.

SET FAST !
PEN #fff9aa
// BLOCK ESCAPE KEY
ESCAPE OFF
//thread.plan sequential //WE CAN USE THREAD plan sequential also.
THREAD.PLAN CONCURRENT
ox=scale.x*1.4
oy=scale.y*1.4
REFRESH  500 
Layer 1 {
	Window Mode, ox, oy
	CLS 1 ,0   ' COLOR BLUE AND  RESET SPLIT SCREEN SETTING TO TOP LINE
	MOVE 1500,1000
	polygon 13, 1000,-500,300,1000, -2000, -500,0, -1000
	PRINT "This is first line"    ' WE CAN'T SEE THE FOUR PRINTS 
	PRINT "This is second line"   'BECAUSE WE SET A HIGH REFRESH RATE
	PRINT "This is third line"
	PRINT "This is forth line"
	PRINT $(1)  // NOT allowed  a PRINT of an item to exceed a column (1,2,3,5,6,7,8,9)
	MOVE 0,0
	A$=""
	COPY 3000,2000 TO A$
	GRADIENT 1, 9   ' CLEAR SCREEN WITH GRADIENT
	PEN 14 {
	FOR i=1 TO 100 {
	      MOVE RANDOM(SCALE.X),RANDOM(SCALE.Y)
	      CIRCLE FILL 14, RANDOM(3)*TWIPSX
	}
	}
	//COPY 6000,6000 TOP A$, 10, 200
	//COPY 6000,6000 TOP A$, 45
	//COPY 2000,2000 USE A$, 45
	h$="	"
	Move 0,0
	copy scale.x, scale.y to h$
}
MOVE 6000,6000
I=1
LET X=MOUSE.X, Y=MOUSE.Y
LET range=6000, ANGLE=0
LET canfire= true, fireX=0, fireY=0, firesize=0
Let sX=SCALE.X/2, sY=SCALE.Y/2
THREAD {
IF abs(fireX-sx)>500 THEN {
      fireX=(fireX*4+SX)/5
      fireY=(fireY*4+SY)/5
} ELSE {
THREAD L HOLD
canfire=true
}
} AS L
e1x=6000 : e1y=6000 : e1z=20
enemy1=true 
THREAD {
      e1z+=5
      IF e1z>180 OR NOT enemy1 THEN enemy1=FALSE : THREAD this HOLD
} AS E1 INTERVAL 30
THREAD {
      e2z+=5
      IF e2z>180 OR NOT  enemy2 THEN enemy2=FALSE : THREAD this HOLD
} AS E2
e2x=SCALE.X*.8 : e2y=6000 : e2z=20
enemy2=FALSE : THREAD e2 HOLD :  THREAD E2 INTERVAL 30
THREAD {
      e3z-=10
      IF e3z<30 OR NOT  enemy3 THEN enemy3=FALSE : THREAD this HOLD
} AS E3
e3x=SCALE.X*.8 : e3y=SCALE.Y: e3z=180
enemy3=FALSE : THREAD e3 HOLD :  THREAD E3 INTERVAL 50

enemy4=FALSE
pp=.02
X=MOUSE.X
Y=MOUSE.Y
// simple routine name is case sensitive
GOSUB basicpart
//MOVE x,y
//GOSUB ship
SHOW

TASK.MAIN 20 { 
      I++
      IF KEYPRESS(49) THEN EXIT
      ' YOU CAN MAKE THE SECOND ROTATED OBJECT TO HAVE FLICKERING
      ' IF YOU DO THAT:
      ' COMMENT THE LINE BELOW AND PUT REFRESH TO 10 IN THE FIRST LINE
      {
            Move -(scale.x/2-x)/scale.x*300,-(scale.y/2-y)/scale.y*300 : Image h$
            // PART USE $(4) (PROPORTIONAL TEXT), AND WRITE ONLY IN ONE LINE WITH NO WRAP
            PRINT PART $(0),@(0,0),"SPACE BAR TO FIRE OR KEY 1 TO QUIT"

            PRINT PART @(0,1),STR$(NOW,"HH:MM:SS"), e1z   //, $(0),format$("({0},{1})", sX, sY)
            
            GOSUB basicpart
            IF enemy1 THEN {
                  MOVE e1x, e1y
                  STEP sx*e1z/100-SCALE.X/2, sy*e1z/100-SCALE.Y/2
                  SPRITE A$, 1, ANGLE/10, e1z,30+e1z/4
            }
            IF enemy2 THEN {
                  MOVE e2x, e2y
                  STEP sx*e2z/50-SCALE.X/2, sy*e2z/50-SCALE.Y/2
                  SPRITE A$, 1, ANGLE/10, e2z,30+e2z/4
            }
            IF enemy3 THEN {
                  MOVE e3x, e3y
                  STEP -( sx*e2z/100-SCALE.X/2), -(sy*e2z/50-SCALE.Y/2)
                  SPRITE A$, 1, ANGLE/10, e3z,30+e3z/4
            }
            IF enemy4 THEN {
                  MOVE 8000,4000
                  STEP sx-SCALE.X/2, sy-SCALE.Y/2
                  SPRITE A$, -1, I, 100,30
            }
            IF canfire AND KEYPRESS(32) THEN {
                  SCORE 2, 100,"c"  ' SET A MIDI MUSIC SCORE
                  canfire~ : fireX=x : fireY=y
                  firesize= (SQRT((SCALE.X/2)**2+(SCALE.Y/2)**2)-SQRT((x-SCALE.X/2)**2+(y-SCALE.Y/2)**2))/10
                  THREAD L RESTART
                  THREAD L INTERVAL 10
                  PLAY 2, 10  ' PLAY THE SCORE 2 USING ORGAN 10
            } else.if NOT canfire THEN {
                  MOVE fireX, fireY
                  TRY { PEN 4{CIRCLE FILL 4, firesize}}
            }
            MOVE X, Y   
            GOSUB ship
      }
       IF NOT enemy1 and RANDOM(100)>95 THEN GOSUB enshow1
       IF NOT enemy2 and RANDOM(100)>95 THEN GOSUB enshow2
       IF NOT enemy3 and RANDOM(100)>97 THEN GOSUB enshow3
              
      REFRESH 5000   ' DO NOW A SCREEN REFRESH ONLY
      IF MOUSE=1 THEN {
            X=MOUSE.X
            Y=MOUSE.Y
      }     
}
// UNBLOCK ESCAPE KEY
ESCAPE ON
REFRESH 30
THREADS ERASE
THREAD.PLAN SEQUENTIAL
EXIT
enshow1:
      e1x=6000+RANDOM(2000) : e1y=6000+RANDOM(2000) : e1z=20
      enemy1=true : THREAD E1 RESTART
RETURN
enshow2:
      e2x=SCALE.X*.8-RANDOM(2000) : e2y=6000-RANDOM(2000) : e2z=20
      enemy2=true : THREAD E2 RESTART
RETURN
enshow3:
      e3x=SCALE.X*.8 +RANDOM(2000): e3y=SCALE.Y: e3z=180
      enemy3=true : THREAD E3 RESTART
RETURN
basicpart:
      range = SQRT((x-SCALE.X/2)**2+(y-SCALE.Y/2)**2)
      ANGLE =(360*(SCALE.Y-y)/SCALE.Y/2)*(SCALE.X/2-x)/SCALE.X
      sx=SCALE.X/2-(x-SCALE.X/2)/4
      sy=SCALE.Y/2-(y-SCALE.Y/2)/4
      MOVE sx, sy
      CIRCLE 300
      MOVE 0,SCALE.Y-range/2
      PEN 2 { polygon 2, 0,0,SCALE.X, 0,0, range/2,-SCALE.X,0,0,-range/2 }
      STEP SCALE.X/2,0
      PEN 0 {
            DRAW to SCALE.X/2+(x-SCALE.X/2)/4, SCALE.Y
            IF 1.1-PP<1 THEN {
                  MOVE 0, SCALE.Y-range/2*(1.1-PP)
                  DRAW SCALE.X,0 
            }
            MOVE 0, SCALE.Y-range/1.9*(.9-PP)
            DRAW SCALE.X,0
            MOVE 0, SCALE.Y-range/1.8*(.7-PP)
            DRAW SCALE.X,0
            IF NOT 1.1-PP<1 THEN {
                  MOVE 0, SCALE.Y-range/1.75*(.5-PP)
                  DRAW SCALE.X,0
            }
            pp+=.04
            IF pp>.20 THEN pp=.02
      }
RETURN
ship:
TRY {
      CIRCLE  300 *(12000-range)/5000    
      SPRITE A$, 1, ANGLE, (12000-range)/50, 100-range/200 
}
RETURN
}
MODULE MEDITOR {\\ notepad for M2000 programs (gsb files)
\\ Use F1 in editor to change to no wrap<->wrap
Clear \\ Clear all variables/objects
Global aLL$
Document aLL$
if exist(appdir$+"help2000utf8.dat") then
	Global aa, bb, where, no_par
	Load.doc aLL$, appdir$+"help2000utf8.dat"
	aa<=Val(paragraph$(aLL$, 1))
	bb<=Val(paragraph$(aLL$, 2+aa))
	find aLL$, paragraph$(aLL$,2+aa+1+2*bb)
	where<=number : no_par<=number: flush
end if
Flush \\ Empty the stack
CurDir$=Dir$
Title$="M2000 Pad"
Title "", 0   ' hide the console - 0
def docFolder$
\\ Gui Elements
oldlinespace=linespace
linespace 60
// using this way, setting linespace for console as ListBoxes and EditBoxes (and popup listboxe inside Combobox)
// Also layer NotePad get the linespace from console, execpt we use Form statement or Linespace statement
// inside a Layer NotePad { }. For the form there is no porperty named Linespace.  We use statement insided Layer. 
Declare NotePad Form
Declare Pad EditBox Form NotePad
Declare HelpPad EditBox Form NotePad
Declare Handle1 Listbox Form NotePad
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Run1 Combobox Form NotePad
Declare Help1 Combobox Form NotePad
Declare Inform1 Button Form NotePad
linespace oldlinespace
With Handle1, "Visible" as handle1.visible, "locked" as handle1.locked, "headeronly", true, "tabstop", false, "TitleBackColor" as mcol, "top" as handle1.top
Method Handle1, "UseVerMove"
mcol=#FFA000
handle1.locked=true
handle1.visible=false
\\ we can display an icon (the M2000 by default)
\\ Normal the icon is in the rright side, the control icon for close is in the left side. Here we do the oposite
\\ Also we get the Quit property. Is a property which a Document read when do a busy work of loading to quit it.
With NotePad,"UseIcon", True, "UseReverse", True, "Quit" as Quit

\\ We nead then title height after title displayed toget the height where we place the elements, in resize event
\\ we set the form to produce resize event by grabing the low right corner of form
With NotePad, "Title" as Caption$, "Visible" as Visible, "TitleHeight" as tHeight, "Sizable", True


\\ setting form, to show control box icon using english labels (use 0 for greek)
\\ we have to place afrer "Sizable", true to have "maximeze" enabled from the start.
Method NotePad,"MakeStandardInfo", 1


\\ Elements Properties (some of them changed using Methods, to pass more than one value)
\\ Change bavkground to M2000 Orange
Method Inform1, "Colors", 15, #FFA000

\\ We want the Button to act as a label only
With Inform1, "Locked", true

\\ Set the font for Pad, and for HelpPad, the two EditBoxes
Method Pad, "FontAttr", "Verdana", 12, true   '  size=12, bold=true
Method HelpPad,"FontAttr","Verdana", 10, true 

\\ We call a method to setup EditBox for Text View (we can use keys to move the text)
Method HelpPad, "TextViewOnly"


\\ ShowAlways prevent changing color when HelpPad is inactive
\\ We make some variables bound to properties
With HelpPad, "visible" as helpshow, "ShowAlways", True, "Text" as HelpText$, "enabled" as HelpEnabled
With HelpPad, "NoCenterLineEdit", True, "SetM2000", True, "EditDoc" as HelpEdit ' predifined for word picking
\\ we want HelpPad not shown from beginning, so we disable it
HelpEnabled=false
With Pad, "NoWrap" as NoWrap
NoWrap=True
With Pad,  "SetM2000", True, "SelLength" as SelLength, "HighlightParagraph", True

\\ Set labels for menu's headers. and thecolor for check mark/ disable items,  in menus which we have those
With File1,"label","File", "Hover", true
With Edit1,"label","Edit",  "Mark", Color(255,100,0),  "Hover", true
With Run1,"label","Run",  "Mark", Color(255,100,0),  "Hover", true
With Help1,"label","Help",  "Mark", Color(255,100,0), "Id" as Id$(), "Hover", true

\\ set a property variable to read/write text to pad, also we can use Tab
With Pad, "Text" as Pad.Text$, "NoColor", False, "ShowAlways", True, "UseTab", True, "tabwidth", 6

\\ we want to control by menu  these two properties (they can change by keystroke also)
\\ F10 tongle to hidden/no hidden characters, and Ctrl+F9 change the edit style in EditBox
With Pad, "showparagraph" as par_Status, "NoCenterLineEdit" as style_status
\\ they are false by default
par_Status=False
style_status=True

\\ Just for beginnig we make a function to alter the first letter of a name, to be a title
Def TitleStr$(a$)=ucase$(left$(a$,1))+mid$(a$,2)
Filename$=Dir$+"Untitled.gsb"
\\ Caption$ is the Title property of form. This is the formula to display proper the filename$ (excluding path)
Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
\\ The form is hidden, but we can move it
Method NotePad,"move", 2000, 4000, 8000, 4000
\\ Also we like to give M2000 Orange to layer unter the title
Layer NotePad {Cls #FFA000}

\\ Now we make the menu. We set 4000 twips for each dropdown list (height calculated automatic)
With File1,"MenuStyle", True, "MenuWidth", 4000 
With Edit1,"MenuStyle", True, "MenuWidth", 4800 
With Run1,"MenuStyle", True, "MenuWidth", 4000 
With Help1,"MenuStyle", True, "MenuWidth", 4000 

\\ the for This block used for erasing temporary variables, here the mi$ and mr$
\\ we have to give a Group name (anything, so here we pick "This")
\\ A Menuitem without name is a line separator
\\ Menuradio used in Edit1, all other are Menuitems
\\ the last two items in Edit1 have a third parameter to True, which means they are checkboxes
\\ Internal
\\ MenuItem(a$, Optional enabledthis As Boolean = True, Optional checked As Boolean = False, Optional radiobutton As Boolean = False, Optional firstate As Boolean = False, Optional IdD)

For This {
	const mi$="MenuItem"  \\ is a temporary variable only for For This Block
	const mr$="MenuRadio"
	Method File1, mi$,"Open",true, acc:="O", ctrl:=true
	Method File1, mi$,"Save",true, acc:="S", ctrl:=true
	Method File1, mi$,""    \\  only  a line here
	Method File1, mi$,"Close",true, acc:="C", alt:=true
	Method File1, mi$,"Quit",true, acc:="Q", alt:=true

	
	With File1, "MenuGroup","This"
	
	Method Edit1, mi$,"Cut",true, acc:="X", ctrl:=true
	Method Edit1, mi$,"Copy",true, acc:="C", ctrl:=true
	Method Edit1, mi$,"Paste",true, acc:="V", ctrl:=true
	Method Edit1, mi$,""
	Method Edit1, mi$,"Less Indent",true, acc:=9, ctrl:=true, shift:=true, legend:="TAB"
	Method Edit1, mi$,"More Indent",true, acc:=9, ctrl:=true, legend:="TAB"
	Method Edit1, mi$,""
	Method Edit1, mr$,"Tabs for Indent",true,true , acc:="T", alt:=true
	Method Edit1, mr$,"Spaces for Indent",true,false, acc:="S", alt:=true
	Method Edit1, mi$,""
	Method Edit1, mi$,"Show Hidden Characters", true, true, acc:="F10"
	Method Edit1, mi$,"Free Style Edit", true, true, acc:="F9", shift:=True
	Method Edit1, mi$,"Wrap Text", true, true, acc:="F1"

	
	With Edit1, "MenuGroup","This"

	Method Run1, mi$,"Debug",true, acc:="F5", alt:=true
	Method Run1, mi$,""
	Method Run1, mi$,"Test Slow",true, acc:="F8", alt:=true
	Method Run1, mi$,"Test Normal", true, acc:="F6", alt:=true
	Method Run1, mi$,""
	Method Run1, mi$,"Settings", acc:="U", ctrl:=true
	Method Run1, mi$,"Default Folder", acc:="D", ctrl:=true
	Method Run1, mi$,"Documents Folder",  acc:="D", alt:=true

	With Run1, "MenuGroup","This"
	Method Help1, mi$,"About",true, id:="ABOUT" ,  acc:="A", alt:=true
	Method Help1, mi$,""
	Method Help1, mi$,"Find Topic",true ,ID:="FIND", acc:="F", alt:=true
	Method Help1, mi$,"Open Topic",HelpShow ,ID:="OPEN", acc:="O", shift:=true, alt:=true
	Method Help1, mi$,""
	Method Help1, mi$,"Close Help",HelpShow ,ID:="CLOSE", acc:="C", ctrl:=true, shift:=true


	With Help1, "MenuGroup","This"
}

\\ Some variable for program. We can ue Def for a variable once, if we do that a second time the we get error.
\\ always Def make local variables. We can set a type before for all non typed names after
\\ or we can use as type and give a first value (not an expression here).
\\ by defailt false is the va;ue for boolean type, so the =false not needed
Def boolean LoadState=false,  old_status=false, lastword$, old_wrap=true

 \\ We need some properties with inexes, so we make these as arrays 
 \\ They look as arrays but they are objects (PropReference)
 \\ We can give names with dot, isn't a problem. Dot can be used for any name
With Edit1,"ListSelected" as Edit1.Selected(), "MenuEnabled" as Edit1.Enabled()
With Help1, "MenuEnabled" as Help1.Enabled()

\\ Some variables for specific task.
\\ Document make or change a local string variable (or global using <=)  to a Document type object (a linked list of paragraphs)
\\ we have to use Clear Name$ to erase the document's paragraphs.
\\ Using = or <= for globals we append text to it
Document BackUp$="\\Write something...", LoadFile$
Def ok as boolean
Const nl$=chr$(13)+chr$(10)
Pad.Text$=BackUp$
Def what$, lastcommand$, mod2run$

\\ function to retrieve info from help database, help2000.mdb in appdir$
Def boolean HelpView


if doc.par(aLL$)=0 then
	\\ Old for HelpM2000.mdb
	Function GetHelp$(&word$, findit) {
		word$=ucase$(word$)
		Eng=chrcode(word$)<128
		If  findit Then
			Retrieve appdir$+"HELP2000", "Select * FROM [COMMANDS] WHERE "+If$(Eng-> "ENGLISH","DESCRIPTION")+" Like '"+word$+"%'",1,"",""
		Else
			Retrieve appdir$+"HELP2000", "COMMANDS",1,If$(Eng->"ENGLISH","DESCRIPTION"),word$
		End If
		If number>0 Then
			read new word1$, hlp$, word2$
			=If$(Eng->RightPart$(hlp$,"__<ENG>__"), LeftPart$(hlp$,"__<ENG>__")) :	word$=If$(Eng->word2$, word1$)
		End If
	}
Else
	Function GetHelp$(&word$, findit) {
		Local Nword$=ucase$(word$)	
		select case Nword$
		case "ΓΕΝΙΚΑ"
			Nword$="ΟΛΑ"
		case "GENERAL"
			Nword$="ALL"
		End Select
		if findit then
			find aLL$, "\"+Nword$, where
		else
			find aLL$, "\"+Nword$+"!", where
		end if
		Read Where1
		if Where1>0 then
			Read  There : drop
			Ret$=mid$(Paragraph$(aLL$, There), 2)
			Word$=leftpart$(Ret$,"!")
			lbl=Val(Rightpart$(Ret$,"!"))
			info=Val(Rightpart$(Ret$,"-"))
			if info=0 then
				="["+LeftPart$(Paragraph$(aLL$,lbl+1), ", ")+"] "+format$(paragraph$(aLL$, 2+aa+1+There-no_par))
			else
				="["+RightPart$(Paragraph$(aLL$,lbl+1), ", ")+"] "+format$(paragraph$(aLL$, 2+aa+bb+info))
			end if
		end if
	}
End If



\\ this call using Call Local (otherwise we get error because GetHepl$() isn't a global, or a local to FindWord)
Function FindWord() {
	read new word$, find=false
	Local hlp$=GetHelp$(&Word$, find)
	If len(hlp$) else exit
	lastword$=word$
	HelpText$=word$+nl$+hlp$
	If not helpview Then helpview=true : helpenabled=true
	Call Local Notepad.Resize(true)
}

\\this call using Call Local too, because inform1 is in this module scope
\\ we use letter$ to pop a string (so we don't have to make a variable first)
Function InformNow {
	With Inform1, "Caption",  letter$
}



\\ so now we have to make some event service functions.
\\ all these functions call local, means they use the same namespace as the one which the object defined
\\ we have to use Read New  or place a new in parameter list () like in NotePad.Unload
\\ this prevents to use a same local variable. Events may be called again, while still executed
\\ to prove that we have to open a big file (rename a big txt file as gsb, say bigger than 10Mbytes)
\\ then open it, and before actual placed in Pad, we can use he same service function to close the NotePad

\\ Form's Events  (NotePad is the object)
\\ The NotePad.Unload event get an argument by reference. If this change to true the unload canceled

Function NotePad.Unload(New &Ok) {
	If LoadState Then Quit=true : Call Local InformNow("Quit Loading..") : Exit
	If Pad.Text$<>BackUp$ Then
		After 50 {Call Local File1.DblClick(4)}
		Ok=True
	End If
}
\\ we can change this in code if we change the font of title (because a new TitleHeight  prodced), or if we remove the header (make it invinsible)
def third, free
third=1000
With NotePad, "Width" as NP.Width, "Height" as NP.Height, "TitleHeight" as tHeight
Method File1,"move", twipsX*3, tHeight,  twipsX*80, tHeight
Method Edit1,"move", twipsX*3+twipsX*80, tHeight,  twipsX*80, tHeight
Method Run1,"move",  twipsX*3+twipsX*160, tHeight,  twipsX*80, tHeight
Method Help1,"move", twipsX*3+twipsX*240, tHeight,  twipsX*80, tHeight
Method Inform1,"move", twipsX*3+twipsX*320, tHeight,  twipsX*160, tHeight


Function Notepad.Resize {
	Local FromHelp=false
	if match("N") then Read FromHelp
	Layer NotePad { Cls Color(255, 160, 0) ,0}
	local tHeight1=theight*2
	Local free=NP.Height-tHeight1-twipsX*3
	local oldhelpshow=helpshow
	If NP.height>1800 Then {
		If helpview Then
			if oldhelpshow else
				Method Handle1, "move",twipsX*3, tHeight1+free-free/3-twipsX*3,  NP.Width-twipsX*6,twipsY*3
			end if
			if handle1.locked then handle1.locked=false
			local third=handle1.top-tHeight1
			if third<twipsX*10 then third=twipsX*10
			if free<third then third=free/3
			Method Pad,"move", twipsX*3, tHeight1,  NP.Width-twipsX*6, third
			third+=tHeight1
			Method Handle1, "move",twipsX*3, third,  NP.Width-twipsX*6,twipsX*3
			Method HelpPad,"move", twipsX*3, third+twipsX*3,  NP.Width-twipsX*6,free-third-twipsY*3+tHeight1		
			handle1.visible=true
			helpshow=true
			Method HelpPad, "resize"
		Else
			helpshow=false
			handle1.visible=false
			Method Pad,"move", twipsX*3, tHeight1,  NP.Width-twipsX*6, NP.Height-tHeight1-twipsY*3
		End If
		Method Pad,"Resize"
	}
}

ms$={Find Topic
Use ALL to get a list of all topics}
Function HelpPad.click() {
	Method  HelpPad, "EditTextView", false:
	what$=lastword$
	If ask(ms$,,,,, what$)=1 Then Read New what$ :Call Local FindWord(what$, true)
}


\\ this is the event to do something with a word clicking on heplPad
Function HelpPad.word {
	Call Local FindWord(letter$, false)
}


\\ From Pad we want to intercept the Ctrl+F5, to call the the first menu item in Run1
\\ We can use a After {} thread (a M2000 Thread), to make the call asyncronus
\\ also we make the key and shift zeroes, to not used by Pad (normaly F5 open the Replace Input Box, if we mark a word )
Function Pad.KeyDown {
	Read New &kc, &Shf
	If kc=116 and shf=2 Then
		kc=0 : shf=0
		After 20{
			Call Local Run1.DblClick(0)
		}
	else.if kc=70 and shf=2 then
		kc=112
	End If
}


\\Also we want from Pad to get a word, and open/change HelpPad

\???

\\ Also Local can be used if we didn't use &, for by reference variables
\\ PopUpMenu is the standard menu for EditBox, but we can change it
\\ using this event
\\ This event fires when we use right mouse button  or Ctrl+F10, or Contex Menu Key.
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}

\\ Each time we change SelStart or SelWidth of Pad, we get an Inform event
Function Pad.Inform {
	Read New L, P
	If old_status<>par_status Then
	With Inform1, "Caption",If$(par_status->"Hidden", "No Hidden")
		old_status=par_status
	else.if old_wrap <> NoWrap then
		With Inform1, "Caption",If$(NoWrap-> "No Wrap", "Wrap Text")
		old_wrap=NoWrap
	Else
		With Inform1, "Caption", format$("{0}-{1}", L,P)
	End If
	\\ set focus to Pad - refresh if not scheduled
	Method Pad,"Show"
}

\\ Helper functions for Edit1
Function SetTabs {
	With Pad, "UseTab", True,"tabwidth",6
	With Inform1, "Caption","Set Tabs"
	Method Pad,"Show"	
}
Function SetSpaces {
	With Pad, "SpaceIndent", 6
	With Inform1, "Caption","Set Spaces"
	Method Pad,"Show"
}
Function ChangeHidden {
	Edit1.Selected(10)=not par_Status
	Method Pad,"PressKey", 121, 0   ' 121=vbkeyF10
	old_status=par_status
	With Inform1, "Caption",If$(Edit1.Selected(10)->"Hidden", "No Hidden")
	Method Pad,"Show"
}
Function ChangeStyle {
	Edit1.Selected(11)=not style_status
	Method Pad,"PressKey", 120, 1
	\\ no need to refresh, the effect is internal, and we see the cursor
	\\ to leave the center line if free style used, not only in top or bottom page
}
Function ChangeWrap {
	old_wrap~
	Edit1.Selected(12)=not old_wrap
	NoWrap=old_wrap
	With Inform1, "Caption",If$(NoWrap-> "No Wrap", "Wrap Text")
'	Method Pad,"Show"
}

\\ Befor Edit1 opened
Function Edit1.OpenMenu {
	Local X
	X=SelLength>0
	Edit1.Enabled(0)=X
	Edit1.Enabled(1)=X
	Edit1.Selected(10)= par_Status
	Edit1.Selected(11)= style_status
	Edit1.Selected(12)=Not NoWrap
	
}
\\ We can check in checkboxes and radiobutton withou closing the menu
\\ if we click on checks - (not on names)
\\ here we use If Else.If Else End If

Function Edit1.MenuChecked {
	Read New RadioIndex 
	If RadioIndex=7 Then
		Call Local SetTabs()
	Else.If RadioIndex=8 Then
		Call Local SetSpaces()
	Else.If RadioIndex=10 Then
		Call Local ChangeHidden()
	Else.If RadioIndex=11 Then
		Call Local ChangeStyle()
	Else.If RadioIndex=12 Then
		Call Local ChangeWrap()
	Else
		With Inform1, "Caption","??"
		Method Pad,"Show"	
	End If
}

\\ When we double click on a menu item
\\ We use Select Case
\\ In M2000 after a Case can be one line of commands, or a block of commands {}
\\ but no two or more lines of commands
Function Edit1.DblClick {
	Read New Edit1index
	Select Case Edit1index
	Case 0
		Method Pad,"mn1sub" : Method Pad,"Resize"
	Case 1
		Method Pad,"mn2sub"
	Case 2
		Method Pad, "mn3sub" : Method Pad,"GetFocus" : Method Pad,"Resize"
	Case 4
		Method Pad,"PressKey", 9, 1
	Case 5
		Method Pad,"PressKey", 9, 0
	Case 7
		Call Local SetTabs()
	Case 8
		Call Local SetSpaces()
	Case 10
		Call Local ChangeHidden()
	Case 11
		Call Local ChangeStyle()
	Case 12
		Call Local ChangeWrap()		
	End Select
}

\\ Prepare the Run part
Document TestFile$
UseShow$={
	Use statement Show to select when console open. Use { END } to skip waiting for key before end
	}
	
\\ 0,2,3 menuitems call the same 
\\ 1 is the line separator
Function Run1.DblClick {
	Read New Run1index
	if Run1index=1 then
		exit
	else.if Run1index=5 then
		Clear TestFile$
		Prototype {
		Module A {
			Title "Settings", 0
			Settings
			Wait 2000
			While Control$="SETTINGS"
				Wait 500
			End while
		}
		A : End
		} as TestFile$
		Save.Doc TestFile$, "Test1235.gsb"
		Win appdir$+"m2000.exe", dir$+"Test1235.gsb"
	else.if Run1index=6 then
		dir user
		local n=ask("Directory:"+nl$+dir$, "Information","ok","")
	else.if Run1index=7 then
		local olddir$=dir$
		if docFolder$<>"" then dir docFolder$
	       dir ? "*","Documents Folder"
	       docFolder$=dir$
	       dir olddir$
	else.If ask(if$(Run1index=0->"Module to run","Command(s) to execute"	+UseShow$),,,,,mod2run$)=1 Then
		Read mod2run$
		Clear TestFile$
		TestFile$=If$(Run1index=2->"Set Slow"+nl$,"")
		if docFolder$<>"" then TestFile$="Dir "+docFolder$+nl$
		TestFile$="Module TestThis {"+Pad.Text$+nl$+"}"+nl$
		TestFile$="Title "+quote$(LeftPart$(Caption$," -"))+nl$
		TestFile$="Script TestThis :"+If$(Run1index=0->"Test ","")+mod2run$+": Push Key$: Drop: End"
		Save.Doc TestFile$, "Test1234.gsb"
		Win appdir$+"m2000.exe", dir$+"Test1234.gsb"

	End If
}

\\ This is the File1 DblCkick event
\\ We use On Goto who start from 1, so we add one to File1index
\\ We use labels and goto because the logic is a kind of spagheti
\\ From Open1: may we go to Save1:
\\ From Unload: we go to Save2:
\\ From Save2: may we go to Save1:
\\ There several cases to exit
\\ the code use If with blocks {}  ' not updated yet
\\ The Break statement stopped only from a Try {},
\\ so Break make exit from all blocks, and exit from function.

Function File1.DblClick {
	Read New File1index
	Local cont, cont2, f$, nl$={
	}
	File1index++
	\\ Because we want some jumps..we use  On Goto
	\\ on Goto need here a block
	{
		On File1index Goto Open1, Save1, ExitNow, Save2, Unload
Exitnow:
		Exit
Open1:
		If Pad.Text$<>BackUp$ Then {
			If ask("Save Changes first?",Title$)=1 Then Goto Save1
		}
		Layer NotePad {
			\\Using "**" we can go up to drives.
			Try ok {
				Open.file filename$,"**","Load M2000 (Gsb) File","gsb"
			}
			If not ok Then push "" : Dir User
		}
		Method Pad,"GetFocus"
		Read f$
		If f$<>"" Then
			If exist(F$) Then {
				Clear LoadFile$
				Method Pad,"PressKey", 0, 0
				LoadState=true
				Call Local InformNow("Loading...")
				layer NotePad {
					Load.Doc LoadFile$, f$
				}
				\\ set the current directory
				If quit Then break
				Filename$=f$
				dir file.path$(Filename$)
				If not quit Then 
					Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
					Clear Backup$
					BackUp$=LoadFile$
					Clear LoadFile$
					Pad.Text$=BackUp$
				End If
			} Else Pad.text$="": Clear BackUp$
			Call Local InformNow("Rendering...")
			Method Pad, "Resize"
			Call Local InformNow("Ready...")
			LoadState=false
		End If
		Exit
Save1:
		Layer NotePad {
			try ok {
				Save.As Filename$,"**","Save M2000 File","gsb"
			}
			If not ok Then Push "" : Dir User
		}
		If not cont2 Then Method Pad,"GetFocus"
		Read f$
		If f$="" Then Exit 
		If lcase$(file.type$(f$))<>"gsb" Then f$=f$+".gsb"
		If Exist(f$) Then  If Ask(nl$+"Overwrite"+nl$+f$,Title$)<>1 Then Exit
		Try ok {
			Clear BackUp$
			BackUp$=Pad.Text$
			Save.Doc BackUp$, f$
			filename$=f$
			dir file.path$(Filename$)
			Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
		}
		If ok Else beep
		If not cont Then Exit
Save2:
		cont=True
		If Pad.Text$<>BackUp$ Then {
			If ask("Save Changes?",Title$,"*SAVE", "CANCEL")=1 Then Goto Save1
		}
		Clear BackUp$
		Pad.Text$=""
		If Cont2 Then
			Dir CurDir$
			Method NotePad, "CloseNow"
		Else
			//if docFolder$<>"" then dir docFolder$
			FileName$=Dir$+"Untitled.gsb"
			Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
			Method Pad, "Resize"
			Method Pad,"GetFocus"
		End If
		Exit
Unload:
		Cont2=True : Goto Save2
	}
}

\\ These are the Help1 events
\\ We want to enable/disable 3 and 5 menuitems
GetIndex=lambda Help1 (id$) ->{
	ret=-1&
	Method Help1, "GetMenuId", id$, &ret as ok
	if ok then =ret else =-1&
}

Function Help1.OpenMenu {
	Help1.Enabled(GetIndex("OPEN"))=HelpShow  and not HelpEdit
	Help1.Enabled(GetIndex("CLOSE"))=HelpShow
}

Function Help1.DblClick {
	read new  Help1.index
	call local InformNow(id$(Help1.index))
	Select Case id$(Help1.index)
	Case "ABOUT"
	{
		Local A, info$
		Info$={
			This is an example of a notepad for M2000 Programs written in M2000 and run in M2000 Environment. Choose a blue word and press ctrl+f1 or F for help.
			}
		A=Ask(info$,Title$,"","")
	}
	Case "FIND"
		Call Local HelpPad.click()
	Case "OPEN"
		Method  HelpPad, "EditTextView", True: Call Local Notepad.Resize(true)
	Case "CLOSE"
		Method  HelpPad, "EditTextView", false : HelpView=false: handle1.visible=false: Call Local Notepad.Resize(true)
	End Select
	
}
Function Handle1.ValidMove {
	Drop
	Read New &Y
	mcol=7
	if y<tHeight+1000 then y=tHeight+1000 : exit
	if y>NP.Height-tHeight then y=NP.Height-tHeight
}
Function Handle1.MouseUp {
	Call Local Notepad.Resize()
	mcol=#FFA000
}
Function HelpPad.Word() {
	Call Local FindWord(letter$, false)
}
\\ this work with help
Function Pad.Word() {
	lastword$=letter$
}
Function Pad.Help {
	Read New what$ :Call Local FindWord(what$, true)
}
Function Pad.About {
	Call Local FindWord("ALL", true)
}
Function Notepad.InfoClick {
	Read New X
	If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Call Local Notepad.Resize()
\\ make this as the default control (get focus)
With Pad,"Default",True
\\ open as modal
With NotePad,  "Blink", 50, "BlinkTimes", 20
Method NotePad,"Show", 1
Declare Pad Nothing
Declare NotePad Nothing 
If Module(Info) Then
	Title "Info"
	keyboard "INFOBasic"+chr$(13)
end if
}
MODULE INFOBASIC {if fontname$<>"Verdana" then font "Verdana"
Set Edit !4   ' 4 chars fpr tabs in edit
\\
\\ Press Esc to exit this editor - look the context drop down menu too (ctrl+F10 also open context dropdown menu)
\\
\\
refresh 10000
hide
\\ window show again
window 8, window 
Form 80, 66
BackGround {cls 11 :height.pixels=scale.y  div twipsY : width.pixels=scale.x div twipsX }
if height.pixels=1024 or height.pixels/width.pixels>0.70 then
      Form  80,68
else
     Form !  120 ,68    // we use ! to add more space for TV-MONITORS - Remove it then press Esc and then F1 to save it
  end if
backcolor=5   'point
oldpen=14  ' pen
Pen 0 {
	cls 7
	ico 1   ' draw icon (a png image, loaded as text as BASE64 encoded)
	Double
	Print part "   ";~(1);" M2000 Interpreter";~(#2222bb);str$(version)+if$(revision>0->" ("+str$(revision,0)+")","")
	Print
	Normal
	italic
	Report " A collection of modules for tests version 37 for M2000 Interpreter version 11, revision 9 and above"
	italic
	Pen 5{
		cursor 0, row-1
		Report 1, "George Karras 2021-2022"
	}
}
cls backcolor, row
Scroll split 0  ' reset the row+1 which given in cls
pen oldpen
Clear ' clear local variables
title("Modules ?")
Report {
	Modules ?    (or control+N, display all loaded modules, If nothing loaded display files)
	Modules ? "","Print"  (search all loaded modules for those who have Print in any case like PrINt)
	You can call any module by name, try Info
	Modules (Show every loaded module, plus files on user folder)
	}
Pen 15 {
	Modules ?
	Print
}
title("List")
Report {
	You can see the global variables, If any exist, defined in console  (write A=10, press enter then press F3 )
	Use statement Clear to clear all variables (including static variables if any). If a module not run as expected use CLEAR before run the module.
	}
Pen 11 {List}
title("Stack")
Report {
	You can see the stack of values, If has any value. 	Use statement Flush to empty the stack
	}
Pen 11 {Stack}
title("Useful Statements")
Report {
	Help All, Help Print, Help  |   Monitor  (to see switches), shitches  (some staments can be used from a module using the Set statement)
	(Set Monitor - because Monitor is known to Console Interpreter)
	Edit info  (press esc to exit editor) | Edit "disk_file.gsb"  (to edit from disk - saved at exit)
	Edit  (no argument) open command editor (we pick in console line using up/down arrows)
	Save filename   (without quotes, except If we want spaces) | load filename  (filename without "" and type)
	Settings (open dialog for setting environment) |	Start  ' restart console
	Use filename  (use info open another info in another console)  | Dir to show current directory or Dir user to set current dir to user folder
	Files "GSB","PRINT|FOR" (search files *.gsb for words PRINT and FOR) | Win Dir$ | Win Calc | Win Appdir$ | End (to exit from console)  
	}
Fkey Clear
FKey 1,"Saveme ' save all loaded modules"
FKey 2,"Logo : Edit InfoBasic : hide : InfoBasic ' edit this"
FKey 3,"InfoBasic ' this page"
FKey 4,"M2000_Editor_Information  ' about editor"
FKey 5,"Demo1  ' 3d Drawing in a Window"
\\FKey 6,"Edit M2000_editor_information"
FKey 6,"icons ' an example using sprites of type png"
Fkey 7,"Tr 'Three Oscilloscopes"
Fkey 8,"mEditor ' A window based M2000 Editor"
Fkey 9,"kb ' A keyboard to play music"
FKey 10,"Settings"
FKey 11,"Dijkstra"
Fkey 24, {chessgame "rnb2rk1/ppp1q1pp/5n2/2bpp3/2Q1p3/1B3P2/PPPP1NPP/RNB2RK1 w - - 0 10"}
Fkey 12, "chessgame"
FKey 19,"List33  ' Listbox control Example"
FKey 18,"Form44  ' Muliple Windows Example"
FKey 17,"Maze2  ' Maze Drawing in console"
FKey 16,"Cal  ' Snoopy Calendar"
FKey 15,"OOP1  ' EventHandler Class"
FKey 14,"Pend  ' Pendulum Animation"
FKey 20,"Pong  ' SoloPong - for one player"
Fkey 21, "minesweeper  ' edit the code to change the game board size"
FKey 22,"Jukebox  'Play mp3, non stop music"
Title("Fkey")
Report {
Fkey + Enter to see the Function Keys
}
\\title("M2000 Writer")
\\Keyboard "Writer"+chr$(13)
show
End
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
}
MODULE SAVEME {Print "Wait..."
Title "Info"
dir user
save info, {UseThis : InfoBasic :Fkey: Pen 15 {Print "Press F3 now"}}
Print "Done"

}
MODULE M2000_EDITOR_INFORMATION {\\if width<>80 and height<>66 then window 10, window : form !80,66
thread.plan sequential   ' can run as concurrent too
linespace twipsY*2
' Mode as read only value return the height of layer form in pt. Using Mode we set to the same Mode but we cut extra space (use linespace also)
Mode Mode   
'Cls,0
backcolor=point
oldpen=pen
Refresh 500
Pen 0 {
	cls 7
	call ico, 1
	Double
	Print part  "  M2000 Interpreter"+str$(version)+" ("+str$(revision,0)+")"
	Print
	Normal
	Report " Internal M2000 Editor"
	Pen 5{
		cursor 0, row-1
		Report 1, "George Karras 2019"
	}
}
cls backcolor, row
pen oldpen
title("Define a Module")
Report {
	Edit Alfa   (open editor to edit Alfa Module, and all modules/functions inside of it)
	}, width-12
title("Define a Function")
\\ we can't put a left parenthesis without a match right parenthesis (including for strings) in a { } string literal
Report {
	}+"Edit Alfa() or Alfa("+{  (open editor to edit Alfa() Function, and all modules/functions inside of it)
	}
title("Open for edit at specific position")
Report {
	Edit Alfa, 100
	}
title("Indent a line")
Report {
	just press tab before any letter, to delete indentation mark the text shift +End and then press shift tab
	You can start a indentation with spaces (Default is tab - characrer 9), using shift tab in a clear line, or a line without leading tabs.
	}, width-12
title("Indent multiple lines")Report {
	Mark a block and then press tab or shif tab to move text right or left
	}, width-12
title("Functions Keys for Editor")
Report {
	F1 - Toggle Wrapping setting (on or off)
	F2 - search marked or last searched word/characters up
		using shift  to search characters using  ctrl to search words (both open a messabox)
	F3 - search marked or last searched word/characters down
		using shift  to search characters using  ctrl to search words (both open a messabox)
	F4 - change the letters case using the marked word (no undo for this)
	F5 - Replace marked word with one we provide in inputbox (multiple undo) - using shift replace characters - Ctr-Z undo the action
	F6, F7, F8 Bookmarks. One press for Set, Delete, Goto Bookmark. Messages displayed
	F9 - Count words  - Shift F9 change Editor Style
	F10 - Show hidden characters (paragraph, spaces as dot, nbsp as space, figure space, tab)
	F10 & Shift - Open Popup Menu
	F11 - Change Syntax Color On, Language Width Normal, Syntax color Off, Language Width Small
	F12 - Open a form displaying all names of loaded modules, we can click on any to read or copy part of source
	Shift F12 Exit without changes (useful if Editor get crazy...)
	}, width-12
title("Holding Ctrl")
Report {
	Ctrl+X Cut	Ctrl+C Copy   (copy Html and Simple Text, Html has <pre></pre> if tabs exist in copied text)
	Ctrl+V Paste	Ctrl+A Select all
	Ctrl+Z Undo (unlimited, but we loose it if we press Esc to leave from editor)		Ctrl+Y Redo (unlimited too)
	}, width-12
title("Using TAB")	
Report {
	Shift+Tab Insert spaces not tab
		we can change the tab width using a commmand: Edit ! Number. We can set spaces as tab using Switches "-TAB"
	Tab  insert a tab in umarked text, apply indentation in marked text
	Tab + Shift remove indentation in marked text,  Insert spaces as tab if no leading tab exist
	}, width-12
title("Special Key Combinations")
Report {
	Ctrl+Shift Enter place Braces and a line inside with proper indentation
		We can mark text and place braces and indentation for all marked text
	Ctrl+Shift+Space insert a non break space
	Alt+Shift+Space insert a figure space
	Alt + 5 + 9 return ANSI 0x59 (;)  (we can give any number - the number is in decimal Unicode format)
	a Alt "+" 3 0 2 a give â (Combining Diacritical Mark 0x302)  - we can use Ins if no Number Keypad exist (lfor aptos)
		We can use  numbers above 0x10000 . Hold Alt and press Ins 1 0 4 3 7 on keypad or number keys and release Alt to get 𐐷
	Pairs:() {} "" []  we press the first and we get the other and cursor set inside them
		Also we can mark text and press one of above to place makred text inside
	}, width-12
Press()
Cls
title("PopUp Menu")
Report {
	Open with Shift+F10, Key Context Menu if exist, left mouse button in edit area, right mouse button in header area
	We can move the menu (stay open until lost focus)
	We can resize the menu to get bigger text (also this operation resize other interpreter forms)
	
	First line show line number, character position and can input a line number to move this line to center vertical as possible
	Cut
	Copy
	Paste
	Save and Exit
	Discard Changes
	Search up
	Search down
	Make same All
	Replace word
	Word Wrap
	Drag Enabled (by default drop is enabled, to allow drag operation we have to set this)
		(drag start when we give a double click inside marked text. By default for inside drop is a cut and paste procedure)
		(Shift/Ctrl works also)
	Color/Short Language
	Paragraph Mark (show hidden characters, we can edit in this mode)
	Word Count
	Help  (if we makred a word - just click on it- we get a form with information about it).
	Modules/Functions.
	Insert File  (this is a macro which insert a file as Base64 encoded in text, for a string variable).
	Load Resource (this is a macro which insert a binary file to a buffer type variable).
	}, width-12
title("View code without moving the cursor from position")
Report {
	We can scroll up or down using vertical scroll bar. Press left or right or up or down or an key to return to previous view
	Use F1 to change wrap (this also has no affect to cursor).
	Move some lines up or down holding down right mouse button. There is a timer which enable quick move.
	The same timer enabled when we click the top or bottom areas of the scroll bar control.
	}, width-12
title("View/Select code as you change the cursor from position")
Report {
	Use arrows, Home (change from position 1 to first non space  in row, each time we use it).
	End to end of line. Ctrl+PageUp to first line, Ctrl+Page Down to last line
	Page Up, Page Down  (Page is the  half page of view).
	Clicking with right mouse button.
	Shift with all above mark text.
	**New**	Ctrl+Left or Right arrow make long jump based on context, can be used with Shift to mark text also
			Ctrl+Delete, Ctrl+Backspace delete multiple characters base on the jump system.
	Using mouse wheel we change half pages (moving the cursor too), shift has no effect.
	Using F6 to F8 (Bookmarks) to jump to a bookmark.

	When we edit a line editor keep the line in the middle of view if it is possible.
	If no warp enabled then the horizontal moving is automated, when we type, or when we move text to drop it,
	depending of the position of the "running cursor" (if we miss the drop, the cursor return to starting position).
	}, width-12
Press()
cls, -2
Keyboard "infoBasic"+chr$(13)
End  ' we can omit this
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	a$=replace$(chr$(9),"      ", a$)
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
Sub Press()
	wait 200
	local col=15,  col2=backcolor, threadid
	Input End  ' empty buffer too
	Print @(0,Height);
	Thread {
		Pen col {
		Print Over $(3), "Press space bar or mouse key":Refresh
		}
		swap col, col2
	} as threadid interval 250
	Main.Task 10 {
		if keypress(1) or keypress(32) then exit
	rem		if mouse>0 or inkey$<>"" then exit
	}
	Threads Erase
End Sub
}
MODULE FORM44 {Module TryIt {
	Rem : Set slow
	Set fast
	Thread.Plan  Concurrent  ' Sequential
	Refresh 40
	SMOOTH on
	Cls,0
	\\ using ,0 we switch console to minimize state
	\\ any value else or no value restore to normal state
	title "Start Up" ', 0
	N=3
	\\ we choose to use automatic event object
	\\ this event object expect to find Form1() function
	\\ using automatic object we can't disable it
	\\ also events which expect changes to variables
	\\ bypass the stantard callback and resolve to a function
	\\ like  Form1.Unload() which get back the Nook value
	
	Declare Form1(N) Form
	
	\\ Buttons can be clicked or shifted right (same as clicked)
	
	Class Buttons { 
	      Dim Butt() 
	      Module SetCaption { With .Butt(Number), "Caption",Letter$}
	      Function ReadCaption$ { With .Butt(Number), "Caption" as Result$ : = Result$}
	}  
	Dim Controls(N)=Buttons()  \\ an array of arrays
	\\ 
	For i=0 to N-1 {
	      For Controls(i) {
	            \\ need to be a new name for array
	            \\ a For object { } delete any new name
	            \\ so each time this block run, starts with no Button1() array
	            \\ then make one, then we get a copy (and references to actual objects)
	            \\ and then Button1() erased
	            \\ but Controls(i).Butt() can't erased because exist before we enter the loop
	            Declare Button1(2) button Form Form1(i)
	            For j=0 To 1 {
	                  Method Button1(j), "move", 1000+4000*j, 2000,3000,1000
	                  if j=1 then {
	                        Method Button1(j), "curve",3
	                  } else Method Button1(j), "transparent"
	                 
	            }
	            .Butt()=Button1()
	      }
            With Form1(i), "TitleBarColor",#aaaa88, "TitleTextColor",14, "TitleIconColor",#eeeeee
            Method Form1(i), "TransparentTitle"
            Layer Form1(i) {
                Cls 4, 0
                Gradient 1,4
                Cursor 0,3
                Report 2, "Hello There"
            }
            Method Form1(i), "Show"
	}
	\\ check this. After 6 second we can unload two forms
	\\ Ttry to close anything. You can without a problem
	\\ and after 3 seconds one more
	\\ just press enter after Rem 1: to make lines ready for execution
	Rem 1: Wait 6000 : PrintAndRefresh("CloseNow") : For i=1 to 2 : Method Form1(i), "CloseNow" : Next i
	Rem 2: Wait 3000 : PrintAndRefresh("Unload") : Refresh  : Declare Form1() Nothing
	Rem 3: Show \\ get the focus back
	Rem 4: Print "ok" : Exit
	
	Form1_1=true
	Controls(1).SetCaption 0, "Click Me"
	Controls(1).SetCaption 1, "ok"
	Controls(2).SetCaption 1, "Test Me"
	\\ we make a variable bound to a property
	With form1(0), "Visible" As visible
	CloseThisForm=0
	CloseThisTitle$=""
	Function CloseAfter {
	
	      If Ask("Close Form?", CloseThisTitle$)=1 Then {
	      If CloseThisForm=1 Then Form1_1=false
	      Method Form1(CloseThisForm), "CloseNow"
	      }
	}
	Function Form1.Unload {
	      Read New index, &Nook
	      Nook=True  \\ no unload now
	      \\ After make an unamed thread
	      \\ we use this of async waiting for user to
	      \\ provide feedback from a message box
	      with Form1(index), "title" as title$
	      CloseThisTitle$=title$
	      CloseThisForm=Index
	      After 50  { Call Local CloseAfter() }
	}
	Function Button1.Click {
	      Read New K, L
	      Print "Form:";L,"Button:";K
	      Print Controls(L).ReadCaption$(K)
	      if k=1 and l=2 then after 20 {test}
	}
	Function Form1.MouseMove {
	      Read New K, Button, Shft, X, Y
	      If Button=1 Then {
	           Layer Form1(K) {    
	                  move X, Y
	                  circle 500, 1, 14-K
	            }
	      }
	}
	Function Form1.MouseDown {
	      Read New K, Button, Shft, X, Y
	      If Button=2 Then {
	            Method Form1(K), "Control", 1 As UserControl
	            \\ we have to use new names if we "call local" a function
	            With UserControl, "Visible" As uVisible
	            uVisible=Not uVisible  \\ we can't use X~ as X = Not X     
	      }
	}
	'goto aaa
	For i=0 to N-1 {
	\\ Threads get current layer as starting layer
	      Layer Form1(i) {
	            \\ so we make the thread inside Form Layer 
	            Thread {
	            part {
	                  If Form1_1 Then {    
	                              if not scale.x then  thread this erase
	                            \\ third parameter is for color, we can use Color(r,g,b) or Colour(r,g,b) 
	                            \\ for rgb value, or we can give an Html number like #FF0000	                            \\ another way is by using hex 0X80000012 for system colors
	                            \\ Here we use values from the range 0 to 15 (here from 7 to 15)
	                            \\ and these are the standard colors.
	                           Draw To Random(Scale.x), Random(Scale.y), Random(7,15)
	                           \\ sub PrintAndRefresh can be run because all threads are in the same module
	                           \\ Threads have their execution object and an object to draw, here the form1
	                           \\ When thread call sub, sub run on same execution object.
	                           \\ modules and functions have own execution object
	                           \\ so subs are light and interest because the see every variable as local
	                           \\ but we can make temporary anything
	                           \\ we can also create threads in a sub, without erase them. 
	                           \\ Threads erased when parent object erased, or when we send erase command
	                           \\ or when we exit Task.Main
	                           \\ for the situation of a thread created on a thread we can use Threads Erase
	                           \\ too remove all, including these. This we need it because, the second level of thread may
	                           \\ end after the erasing of module, where we create it, so can run code with variables which
	                           \\ are cleared. So With Threads Erase before exit module we are sure that Threading Pool is empty.
	                           \\ But this in not an every day situation.
	                           \\  (an after {}  thread creation in a thread execution is an example for a second level thread)
	                           Rem 100 :
	                          If random(100)<4 then  PrintAndRefresh("draw lines")
	                          refresh
	                  } Else Thread This Erase
	                  } as mine
	            } As OneMore   Interval 30
	            thread OneMore  execute  static me=i
	            \\ OneMore is a handler, so we lost first and second handler
	            \\ but we dont care, we close thread inside using This
	            \\ or we can let the Main Task erase it at the exit 
	      }
	}
	
	Thread {     
	      PrintAndRefresh(Str$(Now,"hh:mm:ss"))
	} As Inform Interval 1000
	\\ Inform is the Thread Handler, we don't use it here
	aaa:
	\\ Need a thread to run a Main.Task
	Main.Task 100 {
	'Every 100 {
	      \\ using property  \\ 
	      
	            
	            Rem 1 :       Print Type$(Visible), Type$(Form1_1)
	            If Not visible Then break
	            threads
	      
	}
	
	\\  Cleaning;
	\\ A control has two objects, one in form (a UserControl, one type for all),
	\\ and the other is the wrapper, which serve as an event publisher,
	\\ and we can use propertiers and methods
	\\ When a Form unloaded not only erase UserControls but becaue hold referencse to wrappers
	\\ send deconstruct command to each one, to break any reference to form
	\\ and  erase internal collection - just throw references to actual objects
	\\ So our last references to wrappers are in Controls(i)
	\\ We can let M2000 to destroy the arrays, so the referecses, or we can do the job
	\\ and we can reuse it
	\\ so we check this with a jump to there
	Goto there
	For i=0 to N-1 {
	      For Controls(i) {
	            Dim .Butt()
	      }
	}
	there:
	\\ this command unload forms
	Declare Form1() Nothing
	'title "End"
	'Show
	Threads Erase
	Smooth off
	Thread.Plan Sequential  ' set the default again (can be set if no thread exist)
	Refresh 30
	Sub PrintAndRefresh(A$)
	            Print A$
	            Refresh
	End Sub
}
While inkey$<>"" {}
Cls ,0
Report {Form44
You can:
      1. draw on Windows using right mouse button.
      2. slide or click a button to see the response in console.
      3. hide title using left mouse button.
      4. click on Test button on Window 2, to open test dialog.
      5. move the windows
      6. Use Shif + F4 to close a form (even with hidden title)
      
      Closing form 2 stop threads for line drawing.
      Closing form 1 close all forms, program exit
      
      Enjoy
      George Karras
      
      (press any key)

}
push key$ : drop
TryIt
test !
Keyboard "info"+chr$(13)
}
MODULE LIST33 {Declare Simple Form
With Simple, "Title" As myTitle$
\\ make window, not show yet
Layer Simple {
      Linespace 60
      Font "Arial Black"
      Window 16, 8000,6000
      gradient 11, 1, 0
      Cursor 0, height div 2
      Report 2,"Hello World"
}
\\ now put a ListBox
Declare Listbox1 Listbox Form Simple
Method Listbox1, "move", 1000,1000,6000,4200
//Method Listbox1, "SetBarStyle", 11
Method Listbox1, "SetBarStyle", color(50, 100,  200), 3
\\ and fill with some data
With ListBox1,"Text",{London
                                    Paris
                                    Athens
                                    Rome
                                    Tirana
                                    Nicosia
                                    Brussels
                                    Copenhagen
                                    Berlin
                                    Dublin
                                    Luxembourg
                                    London2
                                    Paris2
                                    Athens2
                                    Rome2
                                    Tirana2
                                    Nicosia2
                                    Brussels2
                                    Copenhagen2
                                    Berlin2
                                    Dublin2
                                    Luxembourg2
                                    }
\\ and set some properties, and some of them are bind to objects that are properties to objects.
\\ also when we call a method, internal a resolved done in first time, so next time a method call will be faster.
With Listbox1, "transparent", True , "ListIndex" As ListIndex, "ListCount" As  ListCount
With Listbox1, "Find" As Find(),  "List" As List$(), "maychange", true
\\ make simple sizable form (units for forms are in twips)
With Simple,"Sizable", True,"SizerWidth",90
\\ now these are the event handlers
\\ event handlers can see anything defined in parent module
\\ for this reason for &rgb we need a Read New (so a new rgb prepared before a reference assign to it)
\\ any variable can get a reference to other variable once, at defining stage.
Inventory Blocked= "Rome", "Rome2", "Berlin"
Function Simple.Unload {
      Keyboard "!"   \\ like press !
}
Function listbox1.Color {
      Read New &rgb
            rgb=#FF7700
}
Function listbox1.Sep {
      Read New &D
		if exist(Blocked, List$(d)) then d=-1
		
}
Function Listbox1.DblClick {
            Read Where 
            if Right$(List$(Where),1)="✓" then {
                  List$(Where)=leftPart$(List$(Where)+" "," ")
            } else {
                  List$(Where)=leftPart$(List$(Where)+" "," ")+" ✓"
            }
            Mytitle$= List$(Where) 
'            Method Simple,"RefreshAll"
            Method Listbox1,"Refresh"

}
Function simple.click {
            If ListIndex>=0 Then {
                  local K$=List$(ListIndex), i
                  Method listbox1,"Sort"
                  ListIndex=Find(K$)
                  Layer {
                        \\ we print to standard cosnole layer
                        Print ">>", control$
                  }
            } Else Method Listbox1,"Sort"
}
Function Simple.Resize {
      Layer Simple {
            Mode 16
	     gradient 11, 1, 0
            Cursor 0, height div 2
            Report 2,"Hello World"
            Method Listbox1,"Refresh"
      }
      \\ we put a refresh to console because
      \\ when this handler run, can't run thread k.
      Layer { Refresh}
      Method Simple, "refreshALL"
}
\\ now we want to show (without modal showing)
Method Simple, "TransparentTitle"
Method Simple, "Show"
\\ We can put a background task (a thread), triggering each 100 mSec
Thread {
      Print tick  \\ tick is thread manager timer
      refresh
} as K interval 100
a$=Key$ \\ no loop just wait a key, in console only
Threads Erase
Declare Simple Nothing
}
MODULE TEXTOUT {Module UsingEvents {
      rem Form ! 80,66
      \\ from version 9.9 we have to get the byvalue parameters to variables without & (which used for byref read)
      Declare WithEvents sp "SAPI.SpVoice"
      That$={Rosetta Code is a programming chrestomathy site.
      The idea is to present solutions to the same task in as many different languages as possible, to demonstrate how languages are similar and different, and to aid a person with a grounding in one approach to a problem in learning another. Rosetta Code currently has 913 tasks, 214 draft tasks, and is aware of 707 languages, though we do not (and cannot) have solutions to every task in every language.}
      EndStream=False
      LastPosition=-1
      TxtWidth=0
      Function sp_Word {
            Read New StreamNumber, StreamPosition, CharacterPosition, Length
            Rem:  Print StreamNumber, StreamPosition , CharacterPosition, Length
            If  LastPosition=CharacterPosition Then exit
            LastPosition=CharacterPosition
            Local f$=" "
            If TxtWidth=CharacterPosition+length Then f$=". "
            If length+pos+2>width then Print
            Print Mid$(That$, CharacterPosition+1, Length);f$;
            If f$=". " Then Print
            Refresh
      }
      Function sp_EndStream {
            Refresh
            EndStream=True
      }
      Function sp_Sentence {
            Read New StreamNumber, StreamPosition, CharacterPosition, Length
            if Length>0 and not CharacterPosition=0 then Print
            Print "  ";
            TxtWidth=CharacterPosition+Length-1
      }
      Const  SVEEndInputStream = 4
      Const  SVEWordBoundary = 32
      Const  SVESentenceBoundary = 128
      Const SVSFlagsAsync = 1&
 
      With sp, "EventInterests", SVEWordBoundary+SVEEndInputStream+SVESentenceBoundary
      Method sp, "Speak", That$, SVSFlagsAsync
      While Not EndStream {Wait 10}
      Wait 100
}
oldVolume=Volume
Volume 100
UsingEvents
Volume oldVolume
}
MODULE MOVEBUTTON {Declare Form1 Form
Declare Button1 Button Form Form1
Declare TextBox1 TextBox Form Form1
Bx=4
Layer Form1 {
      Linespace 0
      Window 8, 10000, 6000
      Cls 1,0
      Form 30, 10
      Print @(0,4),"123456789012345678901234567890"
      Cursor Bx, 5
      Move !
      Button1_Xpos=Pos.x
      Button1_Ypos=Pos.y
      Xt=Button1_Xpos div Bx
      Yt=Button1_Ypos div 5
}
Method Textbox1,"Move", 1000,1000, 6000,600
Method Button1,"Move", Button1_Xpos, Button1_Ypos, Xt*5, Yt*2
Method Button1,"Curve",1 \\ 2 - 3 (single float)
Method Form1, "Show"
Function Form1.Unload {
      Keyboard "!"
}
Function Button1.Click {
      \\ print to console
      layer Form1 {            
            motion.w 0 ;
            
      }
      Print "Hello"
}
Function Form1.MouseDown {
      Drop 2 ' no need now (keycode and shift)
      Read New X, Y
      Layer Form1 {
            Move X, Y
            Cursor ! \\ transform to char coordinates
            Move ! \\ transform to graphic, at the up left corner of a char
            Method Button1,"Move", Pos.x, Pos.y
      }
}

A$=key$
Declare Button1 Nothing
Declare Form1 Nothing
}
MODULE DR {Module RomanNumbers {
      flush  ' empty current stack
      gosub Initialize
      document Doc$
      while not empty
            read rom$
            print rom$;"=";RomanEval$(rom$)
            Doc$=rom$+"="+RomanEval$(rom$)+{
            }
      end while
      Clipboard Doc$
      end
Initialize:
      function RomanEval$(rom$) {
            Flush
            ="invalid"
            if filter$(rom$,"MDCLXVI")<>"" Then Exit
            \\ "Y" is in top of stack
            Push "CM", "MD", "Q"
            Push "CD", "MD","W"
            Push "XC", "DL", "E"
            Push "XL", "X","R"
            Push "IX","V","T"
            Push  "IV","I","Y"
            \\ stack flush to doublerom
            doublerom=[]
            \\  "M" is in top of stack
            Data "M", 1000, "Q",900
            Data "D", 500,"W", 400
            Data "C",100,"E",90
            Data "L",50,"R", 40
            Data "X", 10, "T", 9
            Data "V", 5, "Y", 4, "I",1
            \\ stack flush to singlerom
            singlerom=[]
            acc=0
            value=0
            count=0
            stack doublerom {
                  if empty then exit
                  read rep$,exclude$,cc$
                  i=instr(rom$,cc$)
                  if i >0 then
                        tmp$=mid$(rom$,i+2)
                        L=Len(tmp$)
                        if L>0 then if Len(filter$(tmp$, exclude$))<>L then rom$="A": exit
                        if Instr(rom$,mid$(rom$,i,1))<i then rom$="A": exit
                        insert i,2 rom$=rep$  ' replace at pos i with rep$ and place a space to i+1
                  end if
                  loop
            }
            rom$=filter$(rom$," ") ' remove spaces if exist
 
            stack singlerom {
                  if empty then exit
                  read cc$, value
                  count=0
                  while left$(rom$,1)=cc$
                         insert 1, 1 rom$=""
                         count++
                         acc+=value            
                  end while
                  if count>3 then exit
                  loop
            }
            if len(rom$)>0  or count>3 Else
                  =Str$(acc,1033)
            end if      
      }
      data "MMMCMXCIX", "LXXIIX", "MMXVII", "LXXIX", "CXCIX","MCMXCIX","MMMDCCCLXXXVIII"
      data "CMXI","M","MCDXLIV","CCCC","IXV", "XLIXL","LXXIIX","IVM"
      data "XXXIX", "XXXX", "XIXX","IVI", "XLIX","XCIX","XCIV","XLVIII"
      return
}
RomanNumbers
}
MODULE G1 {t=0
{
'loop
t++
on t goto 100, 101

end
Print 0100
Print "fault"
0100 Print "ok1"
Restart
10100 Print "ok2"
exit
101 Print "ok"
}
}
MODULE G2 {goto 100

end
Print 0100
Print "fault"
0100 Print "ok1"
}
MODULE G3 {goto 100

end
Print 100
Print "fault"
100 Print "ok1"
}
MODULE G11 {t=0
again:
t++
on t goto 100, alfa
end
Print 0100
Print "fault"
0100 Print "ok1" : Print "100"
goto again
10100 Print "fault"
exit
alfa:
101 Print "ok2", t

}
MODULE G12 {alfa:
101  static a=10
110 a--
120 print a
130 if a>1 then goto alfa
140 Clear
}
MODULE G4 {Module beta {
      print "i am beta"    
}
X=4
beta: Print "ok"  \\ call beta then print ok
beta: \\ only rem
Print x
x--
If x<1 Else Goto beta
k=false
x=100

}
MODULE M2 {a=(1,2,3,4,5)
fold1=lambda (a, b)-> {
      push a+b
}
fold2=lambda (a, b$) -> {
      if len(b$) Then {push b$+","+str$(a,"")} else push str$(a,"")
}
'? a#fold(fold1, 0)=a#sum()
odd=lambda (x) ->x mod 2=1
even=lambda (x)->x mod 2=0
add2=lambda (x)-> {
      push x+2
}
square=lambda (x)-> {
      push x*x
}
combine=lambda  -> {
      a=Array([])
      if len(a)=0 then =lambda->{} : exit
      =lambda  a ->{
            for i=0 to len(A)-1 { 
                  m=array(a,i)
                  call m()
            }
      }
}
? "["+a#filter(odd)#fold$(fold2, "")+"]"
? "["+a#filter(even)#map(add2)#fold$(fold2, "")+"]"
a=(,)
z=a#filter(even,(0,))#map(add2)
Print z, type$(z)
a=(1,2,3,4,5)
? a#map(add2, square)
? "["+a#map(add2, square)#fold$(fold2, "")+"]"
}
MODULE FS2 {Form ! 60,40
linespace twipsY*4
Form ! 60
refresh
\\ using M2000 commands
Menu   ' clear Menu list
Files !  + "gsb|txt"   ' ! sorted by name, + add to menu
Print Len(menu$())

a=menu$()

\\ we can use Print a
\\ but get refresh after the last item
\\ so we can use code to diplay names in columns (expand if name is bigger for one column)
k=each(a)
mp=width/tab
mc=mp*height*3/5
m=mc
Print $(6, 15)  ' use numbers from 0 to 9  - colum width 15
While k {
	Print array$(k),
	m--
	if pos>=width then m--
	if m<mp and pos=0 and row=height-1 then
	m=mc
	Pen 15 {
		Print Part "Press a key on keyboard or mouse (except Esc/Break)"
		While mouse=0 and inkey$="" {Refresh}
		Print Over @(0),
	}
	end if
}
}
MODULE DEMO1 {set Fast !
Smooth on
Rem :Thread.plan sequential :ComputeInterval=30: Rate=60:TM=100
\\ we can set Thread.plan before any thread created
Rem :
Thread.plan concurrent : ComputeInterval=30:Rate=60:TM=100
\\ concurrent execute one by one statements
\\ except those in { }
\\ also from Revision 52 Part {} as variable works fine with it
local counter1, counter2
Title "", 0 ' 0  to hide console
Set FAST !
\\ by api
Structure VecType {
          x As Double
          y As Double
          z As Double
}
\\ Program
Structure Variables {
      vRot1 As VecType
      vRot2 As VecType
      vRot3 As VecType
      vRot4 As VecType
      vBase As VecType
      vAxis As VecType
}
Buffer Clear Var As Variables
\\ utility function
VecAdr=Lambda Var (a$) -> {
      =Var(0,a$)
}
VecOff=Lambda Var, VecType (a$, b$) -> {
      =Var(0, a$, VecType(b$)!)
}
Class cLine {
      X1, Y1, X2, Y2, color
      Module Render {
            ' read Number from stack
            z=Round(Number,4)
            z1=Round(Number, 4)
            If z>=z1 Then {
                  Move .X1, .Y1
                  Width 3 {Draw to .X2, .Y2, .color}
                  Circle Fill #aa33cc, z/40+200
            } Else {
                  Move .X2, .Y2
                  Circle Fill #aa33cc, z/40+200
                  Width 3 {Draw to .X1, .Y1, .color}
            }
      }
Class:
      Module cLine (.color){
            If Match("NNNN") Then Read .X1, .Y1, .X2, .Y2
      }     
}

\\ find address
vBase=VecAdr("vBase")
vBase.x=VecOff("vBase","x")
vBase.y=VecOff("vBase","y")
vBase.z=VecOff("vBase","z")
vRot1=VecAdr("vRot1")
vRot1.x=VecOff("vRot1","x")
vRot1.y=VecOff("vRot1","y")
vRot1.z=VecOff("vRot1","z")
vRot2=VecAdr("vRot2")
vRot2.x=VecOff("vRot2","x")
vRot2.y=VecOff("vRot2","y")
vRot2.z=VecOff("vRot2","z")
vRot3=VecAdr("vRot3")
vRot3.x=VecOff("vRot3","x")
vRot3.y=VecOff("vRot3","y")
vRot3.z=VecOff("vRot3","z")
vRot4=VecAdr("vRot4")
vRot4.x=VecOff("vRot4","x")
vRot4.y=VecOff("vRot4","y")
vRot4.z=VecOff("vRot4","z")
vAxis=VecAdr("vAxis")
Refresh 100
Declare Alfa Form
With Alfa, "Title", "Demo1", "UseIcon", True, "UseReverse", True  ' icon now is in the left side
Method Alfa,"MakeStandardInfo", 1   ' 1 for English
Def  info$, AskRet
OpenInfo=False
Function Alfa.InfoClick {
	Read New X
	If X=0 then
		OpenInfo=True
	end if
}
\\ a string to hold static background
screen$=""
disp=False
Inventory Depth
aLine=Each(Depth)
once=False
Function DepthSort() {
	Inventory Queue Depth ' clear Depth, Then make keys As numbers
	Append Depth, Eval(Var, vRot1.z As double):=1, Eval(Var, vRot2.z As double):=2, Eval(Var, vRot3.z As double):=3
	Sort Depth As number
}
Thread {
	part {
		Method Math, "RotVectMult", 4, vRot1, vAxis, vRot1, dAngle
		Push Eval(Var, vBase.y As double), Eval(Var, vBase.x As double)
		\\ x is in top, y is after x
		Over 2, 2 \\  copy two times from second, so double two top
		Push Eval(Var, vRot4.x As double)+Number : Over 1, 2 \\ copy 2 times top only
			Read Line1.X1, Line2.X1, Line3.X1
			Push Eval(Var, vRot4.y As double)+Number : Over 1, 2
			Read Line1.Y1, Line2.Y1, Line3.Y1
			Over 2, 4 \\ now original 2 values copied 4 times
			Line1.X2 = Eval(Var, vRot1.x As double)+Number
			Line1.Y2 = Eval(Var, vRot1.y As double)+Number
			Line2.X2 = Eval(Var, vRot2.x As double)+Number
			Line2.Y2 = Eval(Var, vRot2.y As double)+Number
			Line3.X2 = Eval(Var, vRot3.x As double)+Number
			Line3.Y2 = Eval(Var, vRot3.y As double)+Number
			call local depthsort()
			counter1++
			if random(20)>1 then exit
			Method Math, "Vector", vAxis,.4 -.8*rnd, 1.6, .2-.3*rnd
			Method Math, "UnitVect", vAxis
	}  As once
} As Compute
dim All(1 to 3)
Layer Alfa {
	Window 12, 10000, 8000;
	Form 40, 20
	Line1=cline(#0000FF, scale.x/2, scale.y/2, scale.x/2, scale.y/2-2220 )
	Line2=cline(#FF0000, scale.x/2, scale.y/2, scale.x/2-2340, scale.y/2-60 )
	Line3=cline(#00FF00, scale.x/2, scale.y/2, scale.x/2-780, scale.y/2-1200 )
	All(1)->Line1
	All(2)->line2
	All(3)->line3
	Declare Math Math
	Method Math, "Vector", vBase,scale.x/2-1500, scale.y/2+1500, 1500 '  -1000
	Method Math, "Vector", vRot1, Line1.X2, Line1.Y2, -1000
	Method Math, "Vector", vRot2, Line2.X2, Line2.Y2, -1200
	Method Math, "Vector", vRot3, Line3.X2, Line3.Y2, 1700
	Method Math, "Vector", vRot4, Line1.X1, Line1.Y1, 0
	Method Math,  "VecDiffMult", 4, vRot1, vBase, vRot1
	Inventory Depth=Eval(Var, vRot1.z As double):=1, Eval(Var, vRot2.z As double):=2, Eval(Var, vRot3.z As double):=3
	Sort Depth As number
	Method Math, "Vector", vAxis, -.8, 1.6, .3
	Method Math, "UnitVect", vAxis
	Rad2Deg =Lambda pidivby180=pi/180 (RadAngle)->RadAngle / pidivby180
	dAngle =5
	Pen 0
	Cls 7
	Gradient 11, 13
	Move 0,0
	Cursor 0, Height-1
	Cls 7, Height-1
	hold
	//Copy scale.x, scale.y to screen$
	Cursor 0,Height
	together=False
	ok1=true
	Thread {
		{ok1~: if ok1 then tm=timecount
		}
	} as mm interval 1000/50
	tm=0
	Thread {
		static internal=1
		'Move 0,0
		'Copy 0,0 use screen$
		{
			release
			Print @(3,3); format$("{0:2:-7}",tm)
			Cursor 0,height-1
			Print Part $(5,Width/4), counter1, counter2,internal, $(7),Str$(Now , "hh:mm:ss" )
		}
		Part {
			Part {
				aLine=Each(Depth)
				push  Eval(Var, vRot4.z As double) : Over 1, 2
				while aline {
					pp=all(eval(aLine))
					pp=>render  Val(eval$(Depth, aLine^))
				}
				counter2++
			} As disp
			if not OpenInfo then Refresh 5000
		} As together
		internal++
		Profiler
	} As PlayThis
}
\\ we set variables outside threads
State=False
blinking=False
Thread {
       If state Then disp~
 } As blink
Thread blink Hold
ExitNow=False
Function Alfa.Unload {
      ExitNow=True
      threads erase
}
Function Alfa.Click {
                  State~
                  If State Then {
                         Thread compute Hold
                         Thread blink interval 1000/4
                         Thread blink Restart
                         blinking=true
                  } Else {
                        disp=False
                        If blinking Then Thread blink  Hold : blinking~
                        Thread compute Restart
                  }
}
if IsWine then
      Thread PlayThis interval 1000/30
else
      Thread PlayThis interval 1000/Rate
end if  
Thread compute interval ComputeInterval
Wait 200
Method Alfa, "Show"
\\ Change Task.Main with Every
\\ Task.Main is a Thread
\\ ExitNow needed If we have Every in place of Task.Main
Task.Main TM {
      if not together  then if OpenInfo then showinfo()
      If ExitNow Then Exit
}
Threads Erase
Thread.plan sequential   ' to default plan
Wait 100  \ some delay here
Method Alfa, "CloseNow"
Declare Alfa Nothing
Declare Math Nothing
Print counter1, counter2
Title "Demo Complete"
Smooth off
Set Fast   ' return to normal
sub showinfo()
	OpenInfo=false
	refresh 10
	Info$={
		This is an example
		of  using MATH object
		(included in M2000 Interpreter)
		}
	AskRet=Ask(info$,"About Demo1","","")	
end sub
}
MODULE UPDATE {// if you can't run update, means that you get an error and the name of the module erased from the list where the we place a statement replacer
// the update clause is a statement for M2000, so when we load inform the update clause replace by this module
// we can call this module using @update  if we can't call by name update
// don't use this module, use the saveme module Press F1 in the  m2000 console.

beep
Title "Info"
dir appdir$
save info, {UseThis : InfoBasic : Fkey : Pen 15 {Print "Press F3 now"}}
if isnum then {
	drop
	open "info.bck" for output as #N
	close #N
}
dir user
save info, {UseThis : InfoBasic : Fkey: Pen 15 {Print "Press F3 now"}}
}
MODULE BJ { Escape Off
 Flush  \\empty Stack, we use optional arguments in Modules
 NoPlayers=4
\\ Dealer get one hidden And one open Card
\\ Player's get two open cards, one at a time
\\ Options for Split and Double Down
\\ If Player has a BlackJack Then dealer play for 21, changing cards for other players/splits
\\ Standard Bet 100 credits.  Each player start with 10000 credits
MakeLayer()

Print $(4)
Inventory Suits = "♠":=0, "♥":=4, "♦":=4, "♣":=0 'suit -> color
Inventory Cards = "two":=2, "three":=3, "four":=4, "five":=5
Append Cards, "six":=6, "seven":=7, "eight":=8, "nine":=9
Append Cards, "ten":=10, "jack":=10, "queen":=10, "king":=10, "ace":=1
Global CardsView
\\ use <= to feed CardsView
Inventory CardsView <= 2, 3, 4, 5, 6, 7, 8, 9,10, "jack", "queen", "king","ace"

\\ We use Module because each module has own use of dots..
\\ And we call it inside a For Object {} And outside of it
DealerMoney=0
Module PrintCardOnly (k, Suits, Cards, x=0) {
          For k {
                Pen Suits(.suit!) {
                        Print Part @(10+x,row,15+x,row+1,#FFE4E1,0), Eval$(Suits, .suit)+" "+CardsView$(.card!)
                        Print
                   }
        }
}
' Using a Stack object
StackPack = Stack
Module AppendArray (N, A) {
      Stack N {Data !A}
}
Class OneCard {
      suit=-1, Card
Class:
     Module OneCard {
           \\ ? for optional reading
           read ? .suit, .card
     }
}
\\ 3X52 cards
Dim Pack(Len(Cards)*Len(Suits)*(NoPlayers+1)) \\ Not used here =OneCard()
Pen 14
Double
Pen 14 {Report 2, "BlackJack"}
Normal
Cls, 2
k=0
\\ fill cards to Pack()
For times=NoPlayers+1 To 1 {
      N=each(Suits)
      While N {
            M=each(Cards)
            While M {
                  Pack(k)=OneCard(N^, M^)
                  k++
            }
      }     
}
Layer 1 {
	Report 2, "Prepare Cards"
}
Rem : DisplayAll() ' in order
Suffle()
Rem : DisplayAll() ' at random positions
Print
' first cut for player
layer 1{
	Print "Make a Cut: 0-51:";
	Repeat {
	      N1=Random(0,51)
	      Try {
	            Input ! N1, 10
	      }
	      Stack StackPack {
	            Drop N1
	      }
	} Until N1>=0 And N1<=51
	Print N1
}
\\ used to pass the Dealer's hidden Card
Hidden=OneCard()
DealerHidden=OneCard()
Class PlayerJB {
      Class PlayerGame {
            \\ Class is a Group Factory - a function whuch return Group
            \\ Class Definition in a Group is local else is Global
            \\ until erased when Definition Holder exit or end (a Module/Function where we define a class)
            Playervalue, Bet
            \\ we can define groups using class like this If class constructor work without parammeters
            OneCard LastCard
            Class:
            \\ Class: means that this module exist only at construction stage
            Module PlayerGame {
                  ' This module as part of constructor
                  ' so has own Stack when called as constructor
                 Read .Playervalue, .Bet
                 If Not Empty Then Read .LastCard
            }
      }
      Inventory queue PlayerCards
      OneCard PlayerFaceUp2nd, SplitCard
      Bet=100, PlayerMoney
      Playervalue
      OldPlayerValues=Stack
      Done=false
Class:
      Module PlayerJb (.PlayerMoney) {}
}
Dim Base 1, Players(NoPlayers)=PlayerJB(10000)
Def Val$(x)=If$(x=-1 -> "Black Jack", Str$(x,""))
Card=OneCard()
Function ClearCards {
      Inventory queue ClearCards
      =ClearCards
}
Function PlayerHasNoBlackJack(HasTheDealer) {
      ' we get two parameters
      If Not HasTheDealer Then Exit ' the second parameter droped from Stack
      ' now we read 2nd
      Read k
      Def Range(X, X1, X2)=X>=X1 and X<=X2
      m=false
      If k.PlayerCards(0!).card=12 And Range(k.PlayerFaceUp2nd.card,8 ,11) Then m=m or true
      If k.PlayerFaceUp2nd.card=12 And Range(k.PlayerCards(0!).card,8 ,11) Then m=m or true
      =Not m
}
DealerRow=0
Repeat {
      layer 1 {cls}
      donecount=0
      For i=1 to NoPlayers {
            For Players(i) {
                  .SplitCard=OneCard()
                  .OldPlayerValues=Stack
                  If .done Then donecount++ :  Exit
                  If .PlayerMoney<.Bet Then {
                      Layer 1{
                          Print Format$("Player({0}), you run out of money...Bye Bye", i)
                      }
                        .done=true
                         donecount++
                  } Else {
                     Layer 1{
                           Print format$("Player({0}) Money:",i), .PlayerMoney
                              Print "Play Game ?(Y/N)"
                              If Key$ ~ "[NnΝν]" Then .done=true :  donecount++
                    }
                  }
            }
      }
      if donecount<NoPlayers Then Print "Press space to deal cards" : while Key$<>" " {}
      cls,2
      AllPlayers=NoPlayers
      BlackJack=false
      PlayersBurst=0
      Clear dealervalue
      DealerCards=ClearCards()
      For i=1 to NoPlayers {
            For Players(i) {
                  If .done Then AllPlayers-- : Exit
                  Clear .playervalue
                   .PlayerCards=ClearCards()
                  Print Format$("Player {0} Hand: 1st Card", i)
                  PlayerCard(&.playervalue, .PlayerCards)
            }
      }
      If AllPlayers=0 Then Print "No More Players" : Exit
      Print "Dealer Hand: 1st Card"
      DealerRow=row
      DealerCard(&dealervalue)
      cursor 0,2
      For i=1 to NoPlayers {
            If Not Players(i).done Then {
                  Print @(18),Format$("2nd Card", i)
                  For Players(i) {
                        NextCard()
                        .PlayerFaceUp2nd<=Card
                        PrintCardOnly Card, Suits, Cards, 18
                  }
            }
      }
      Print @(18), "2nd Card"
      NextCard()
      Print @(18), "Face Down Card"
      cls , row+1 
      DealerHidden=Card
      ' now If dealer face up Card is Ace or 10 or Figure can see If has a black jack
      N2=Cards(Card.card!)
      If N2=10 And Cards(DealerCards(0!).card!)=1 Then DealerBlackJack()
      If N2=1 And Cards(DealerCards(0!).card!)=10 Then DealerBlackJack()
      For i=1 to NoPlayers {
           If Not Players(i).done Then
                  If PlayerHasNoBlackJack(BlackJack, Players(i)) Then
                  cls, 2
                  For Players(i) {.PlayerMoney-=.Bet : DealerMoney+=.Bet} 
                  Exit
                  end If
                   For Players(i) {
                         Bet=.Bet
                         Again:
                              Print format$("Player {0} Play", i)
                              If .PlayerCards(0!).card=.PlayerFaceUp2nd.card Then {
                                    If .PlayerMoney<2*.Bet Then exit
                                    Print "Split Cards ?(Y/N)"
                                    If Key$ ~ "[NnΝν]" Then Exit
                                    AllPlayers++
                                    .SplitCard<=.PlayerFaceUp2nd
                                    NextCard()
                                    .PlayerFaceUp2nd<=Card
                                    Stack .OldPlayerValues {Push .PlayerGame(.playervalue, Bet)}
                              }
                              Print "Player Hand:"
                              Hidden=.PlayerFaceUp2nd : .PlayerFaceUp2nd<=OneCard()
                              PrintCardOnly .PlayerCards(0!), Suits, Cards ' show first Card
                              PlayHand(.PlayerCards,&.playervalue, False, False, .PlayerMoney)
                              ' first we get Bet
                              .PlayerMoney-=Bet
                              DealerMoney+=Bet
                              Print
                              If .playervalue>21 Then {
                                    PlayersBurst++
                                    Print "Dealer Win"
                              } else.if .playervalue=-1 Then {
                                    ' dealer has to play with player now
                                    PlayersBurst++
                                    Print Format$("Dealer play against Player({0})",i)
                                    PrintCardOnly DealerCards(0!), Suits, Cards
                                    Hidden=DealerHidden : DealerHidden=OneCard()
                                    \\ ? means undefined value
                                    PlayHand(DealerCards,&dealervalue, true, true, ?)
                                    If dealervalue<>21 Then {
                                            Print "Player Win", Bet*3/2 : .PlayerMoney+=Bet*5/2 ' one we get before
                                            DealerMoney-=Bet*5/2
                                    } Else {
                                          Print "Dealer Win"  
                                    }
                                    If PlayersBurst<AllPlayers Then {
                                          Clear dealervalue, DealerCards
                                          ' dealer take two cards to play with others
                                          Print "Dealer Hand: 1st Card"
                                          DealerCard(&dealervalue, DealerRow)
                                          Print "Dealer Hand: 2nd Card"
                                          NextCard()
                                          Print @(10), "Face Down Card"
                                          DealerHidden=Card
                                          ' now If dealer face up Card is Ace or 10 or Figure can see If has a black jack
                                          N2=Cards(Card.card!)
                                          If N2=10 And Cards(DealerCards(0!).card!)=1 Then DealerBlackJack()
                                          If N2=1 And Cards(DealerCards(0!).card!)=10 Then DealerBlackJack()
                                    }
                              }
                              ' Data push to end of Stack
                              ' Push push to top of Stack
                              ' Read read always from top
                                    If .SplitCard.suit<>-1 Then {
                                    Card=If(Bet>.Bet -> .PlayerCards((Len(.PlayerCards)-1)!), OneCard())
                                    Stack .OldPlayerValues {Data .PlayerGame(.playervalue, Bet, Card) : Read NextGame}
                                    Bet=NextGame.Bet
                                    Drop .PlayerCards Len(.PlayerCards) ' erase all cards
                                    Append .PlayerCards, "Split":=.SplitCard
                                    '.playervalue=Cards(.SplitCard.Card!)  ' this is the same
                                    .playervalue=NextGame.playervalue
                                    NextCard()
                                    .PlayerFaceUp2nd<=Card
                                    .SplitCard.Suit=-1
                                    Goto Again
                              }
                        Card=If(Bet>.Bet -> .PlayerCards((Len(.PlayerCards)-1)!), OneCard())
                        Stack .OldPlayerValues {Data .PlayerGame(.playervalue, Bet, Card)}
                  }
           end If      
      }
      If PlayersBurst<AllPlayers And Not BlackJack Then {
            Print "Dealer Play"
            PrintCardOnly DealerCards(0!), Suits, Cards
            Hidden=DealerHidden : DealerHidden=OneCard()
            PlayHand(DealerCards,&dealervalue, true, false, ?)
            Layer 1 {
                  Pen 3 {
                        Report 2, "Table Results"
                        For i=1 to NoPlayers {
                              For Players(i) {
                                    Repeat {
                                          If .done Then exit
                                          Stack .OldPlayerValues { Read NextGame }
                                          playervalue=NextGame.playervalue
                                          Bet=NextGame.Bet
                                          If Not playervalue=-1 Then {
                                                If Bet>.Bet Then {
                                                      Print "Face Up Card"
                                                      PrintCardOnly NextGame.LastCard, Suits, Cards
                                                }
                                                If playervalue>21 Then {
                                                     Print Format$("Dealer Win Player({0})", i)
                                                } Else.If dealervalue>playervalue And dealervalue<22 Then {
                                                     Print Format$("Dealer Win Player({0})", i)
                                                } Else.If dealervalue>21 Or dealervalue<playervalue Then {
                                                      Print Format$("Player({0}) Win Dealer", i)
                                                      .PlayerMoney+=Bet*2
                                                      DealerMoney-=Bet*2
                                                } Else {
                                                      Print Format$("Player({0}) keep bet for next time", i)
                                                       .PlayerMoney+=Bet
                                                      DealerMoney-=Bet
                                                }
                                                Print format$("Player({0}): {1}  Dealer: {2}", i, Val$(playervalue), Val$(dealervalue))
                                          }
                                    } Until Len(.OldPlayerValues)=0
                                    Refresh
                              }
                        }
                  }
                  Print "Press space to continue" : while Key$<>" " {}
            }
            Cls ,2
      }
} Always
Print "Dealer Money:", DealerMoney
Print "Press space to exit" : while Key$<>" " {}
Player 0
cls,0
Escape On
If module(info) then Keyboard "info"+chr$(13)
End
Sub Suffle()
      Layer 1 {
            Print
            Local N=Len(Pack())-1, N2, i, j, total=N*4+4, cur=1
            For j=1 To 4 {
                  For i=0 To N {
                        If cur Mod 4=3 Then Print Over format$("Suffle {0:0}%",cur/total*100)
                        N2=random(0, N)
                        While N2=i {N2=random(0, N)}
                        Swap Pack(i), Pack(N2)
                        cur++
                  }
            }
            AppendArray StackPack, Pack()
            Print
      }
End Sub
Sub DisplayAll()
      For k=0 To Len(Pack())-1 {
            PrintCard(k)
      }
End Sub
Sub PrintCard(k)
      For Pack(k) {
            Pen Suits(.suit!) {
                  Print Eval$(Suits, .suit)+Eval$(Cards, .card),
            }
       }
End Sub
Sub DealCard()
      Layer 1 {
            Print "PRESS A KEY TO DEAL CARD"
            If Key$="9" Then  Stack STACKPACK {Flush}
      }
End Sub
Sub NextCard()
          Rem :  DealCard()
            If Len(StackPack)=0 Then {
                  Suffle()
                  Stack StackPack {
                        Drop Random(0, 51)
                  }
            }
            Stack StackPack {
                  Read Card
            }
End Sub
Sub PlayerCard(&acc, MyCards)
      NextCard()
      PrintCardOnly Card, Suits, Cards
      acc+=Cards(Card.Card!)
      Append MyCards, len(MyCards):=Card
End Sub
Sub DealerCard(&acc, thisrowtoo=-1)
      NextCard()
      PrintCardOnly Card, Suits, Cards
      local oldrow=row
      If thisrowtoo>=0 Then
      cursor 0, thisrowtoo
      PrintCardOnly Card, Suits, Cards
      cursor 0, oldrow
      end If
      acc+=Cards(Card.Card!)
      Append DealerCards, len(DealerCards):=Card
End Sub
Sub PlayHand(MyCards, &acc, nomessage, sorryblackjack)
      ' Optional - We have to pass a ? If we have module or Sub
      Read ? MyMoney
      Local N2, morevalues=0, ok, Card=OneCard(), DoublingDown
      If MyCards(0!).card=12 Then morevalues=10
      Repeat {
            If Hidden.suit>=0 Then {
                  N2=Hidden.card
                  PrintCardOnly Hidden, Suits, Cards
                  Append MyCards, Len(MyCards):=Hidden
                  Hidden=OneCard()
            } Else {
                  NextCard()
                  If DoublingDown Then {
                        Print @(10), "Face Down Card"
                  } Else {
                        PrintCardOnly Card, Suits, Cards
                  }
                  N2=Card.Card
                  Append MyCards, Len(MyCards):=Card
            }
            If N2=12 Then {
                  If morevalues=0 Then {
                        morevalues=10
                  } Else N2=13 : morevalues=-50
            }
            If acc=10 And N2=12 And Len(MyCards)=2 Then acc=-1: Pen 15 {Print "BlackJack" }: Exit
            If morevalues>0 And Cards(if(N2<13 -> N2, 1)!)=10 And Len(MyCards)=2 Then acc=-1: pen 15 {Print "BlackJack" } : Exit
            If N2<=12 Then {
                  acc+=Cards(N2!)
            } Else acc+=11
            If acc>21 And Not DoublingDown Then Print "Busting" : Exit
            If acc=21 Then Exit
            If nomessage Then {
                  If sorryblackjack Then {
                              ok=acc>20 Or acc+morevalues=21
                  }  Else  ok=acc>16 Or (acc+morevalues<22 And acc+morevalues>16)
            } Else {
                  If DoublingDown Then ok=True : Exit
                  If Len(MyCards)=2 Then If acc=9 or acc=10 or acc=11 And acc+morevalues<>21 Then DoublingDown=true
                  If DoublingDown Then {
                        If MyMoney>=2*Bet Then {
                              Print "Doubling Down ?(Y/N)"
                              DoublingDown=Not Key$ ~ "[NnΝν]"
                        } Else DoublingDown=False
                  }
                  If DoublingDown Then {
                        ' get a card Face Down
                        Bet*=2
                        ok=false
                  } Else {
                        Print Part "Stand or Hit ?(S/H)"
                        ok=Key$ ~ "[SsΣσ]"
                  }
            }
      } Until ok
      If acc=-1 Then morevalues=0
      While morevalues>0 {
            If acc+morevalues<22 Then Exit
            morevalues-=10
      }
      If morevalues<0 Then Exit Sub
      acc+=morevalues
End Sub
Sub DealerBlackJack()
      Pen 15 {Print "BlackJack" }
      PrintCardOnly Card, Suits, Cards
      Print "Face Up Card"
      Print "Dealer Win All"
      Print "Press space to continue" : while Key$<>" " {}
      BlackJack=True
End Sub
Sub MakeLayer()
      Font "Arial"
      back {
            Cls #477148,0
            Local k=if( scale.x*4/3<scale.y->40, 60)
      }
      Form ! k, 30
      linespace twipsY*4
      Mode Mode*.8;
      
      Cls #477148,0    ' Poker Green Color
      cursor width/2, 2
      Move !   ' move graphic cursor to cursor
      myMode=Mode
      x1=scale.x/2
      y1=scale.y-pos.y
      y2=pos.y+motion.y
      x2=x1+motion.x
      player 0
      Layer 1 {
            window myMode, x1, y1
            motion x2,y2
            Cls #FFE4C4,0
            Pen 0
            show
            bold 1
            Print $(4)
      }
      Cursor 0,0

End Sub
}
MODULE JSON {Pen 15 {
      Report {
            Press any key or mouse button to continue the report
            
      }
      Wait 200
      Report {
            This is the module list. Look at the end of list. We have the new created modules/functions. These will be erased at the exit of the current modu.le.
            
      }
}
' Process data in json format

' we can load from external file with Inline "libName"
' or multiple files Inline "file1" && "file2"
' but here we have the library in a module
Inline Code Lib3
' So now we make a Parser object (a group type in M2000)
Parser=ParserClass()
' We can display any function, module that is public and known list
Modules ?
' And this are all known variables (or and objects)
List !
'exit
Document json$
' We can load from file
'Load.Doc json$, "alfa.json"
json$={{
      "zero": 0,
      "alfa":-0.11221e+12,
      "array" : [
            -0.67,
            "alfa1",
            [
                  10,
                  20 
            ],
            "beta1",
            1.21e12,
            [
            ],
            21.12145,
            "ok"
      ],
      "delta": false, "epsilon" : true, "Null Value" : null
}}
Save.Doc json$, "json2.json"    \\ by default in Utf-8 with BOM
' just show multiline text
' Report display lines and stop after 3/4 of console height lines
' just press a key or click mouse button
Report json$
' so now we get text to a new object
alfa=Parser.Eval(json$)
' check t
Print Type$(alfa)  ' it is a group
Print "alfa.type$=";alfa.type$  \\ this is a read only property

Report "as one line"
Report Parser.Ser$(alfa, 0)

Report "as multiline"
Report Parser.Ser$(alfa, 1)

Print "Using Print"
Print Parser.ReadAnyString$(alfa)

Print "Value for alfa, id alfa"
Print Parser.ReadAnyString$(alfa,"alfa")
Report "as multiline"
Report Parser.Ser$(Parser.Eval(Parser.ReadAnyString$(alfa,"array", 2)), 1)
' We get a copy of an array as a Group (a group which return an array)
Alfa3=Parser.Eval(Parser.ReadAnyString$(alfa,"array", 2))
' First value is for actual object, second value is a reafonly property of this object
Print type$(Alfa3),  Alfa3.type$
Dim B()
' Now Alfa3 run Value part and pass a pointer of array
' B()  is an array and here take a pointer to Alfa3 array (as value of Alfa3)
B()=Alfa3
' each() make an iterator for B()
N=each(B())
While N {
      \\ Using B() we get values always. but if we have "object" or "array" then Print prints items **
      Print B(N^)
}
' ** Print show here nothing because if value is object then "print" just leave a column and continue to next one
Print B()
' we have to use Group() to get group not value of group (if any).
' Group() works for "named" group, not for stored in an array or an inventory or a stack
Print Parser.StringValue$(Group(Alfa3),  0)
Print Parser.StringValue$(Group(Alfa3),  1)
' Now we want to pass a new value
' Interpreter want to match type of expression from left side to right side
' Because Parser.StringValue$ is actuall a Group (As property),
' we have a second linked name:  Parser.StringValue
' we have to use Parser.StringValue()
' and all values must be groups, as those provided by Parser
Parser.StringValue(Group(Alfa3),  1)=Parser.Numeric(1234)
Print Parser.StringValue$(Group(Alfa3),  1)
Print Parser.StringValue$(Group(Alfa), "array", 2, 0)
' we have to use Parser.StringValue$()
Parser.StringValue$(Group(Alfa), "array", 2, 0)=Parser.JString$("Changed to String")
Print Parser.StringValue$(Group(Alfa), "array", 2,0)
Try ok {
      Print Parser.StringValue$(Group(Alfa), "array", 2)
}
If  Error or not ok Then Print Error$
Parser.StringValue.Add = True
Parser.StringValue$(Group(Alfa), "array", 2, 10)=Parser.JString$("Changed to String 2")
Parser.StringValue(Group(Alfa), "Last value")=Parser.Boolean(true)
Report "as multiline"
Report Parser.Ser$(alfa3, 1)
Report Parser.Ser$(alfa, 1)
Parser.StringValue.Add = False
Parser.StringValue.Del = True
Parser.StringValue(Group(Alfa), "array", 0)=Parser.Null()
Parser.StringValue(Group(Alfa), "delta")=Parser.Null()
Parser.StringValue.Del = False
For Parser {
      .StringValue(Group(Alfa), "array", 1,5)=.Arr((.Numeric(10), .Jstring$("ok 20"), .Boolean(true)))
}
Report Parser.Ser$(alfa, 1)
}
MODULE LIB3 {      Class ParserClass {
      Private:
            Class bStream {
                  Private:
                  cnt, Buffer A
                  Public:
                  Value (&c) {Try { c=eval(.A, .cnt) : .cnt++:=true}}
                  Class:
                  Module final bStream (a$){
                        Buffer .A as Integer*Len(a$)
                        Return .A, 0:=a$           
                  }
            }
            Func=Lambda->false
            char=0
            ' using obj as pointer to  Stack 
            obj=Stack
            Function final IsId {
                  If .char=34 Then =.IsString(false)
            }
            Function final IsTrue {
                  ' U+0074 U+0072 U+0075 U+0065
                  If .char=0x74 Then If .func() Then If .char=0x72 Then If .func() Then If .char=0x75 Then If .func() Then If .char=0x65 Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Boolean(True)
                        }
                  End Sub
            }
            Function final IsFalse {
                  ' U+0066 U+0061 U+006c U+0073 U+0065
                  If .char=0x66 Then If .func() Then If .char=0x61 Then If .func() Then If .char=0x6c Then If .func() Then If .char=0x73 Then If .func() Then If .char=0x65 Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Boolean(False)
                        }
                  End Sub
            }
            Function final IsNull {
                  ' U+006E U+0075 U+006C U+006C
                  If .char=0x6e Then If .func() Then If  .char=0x75 Then If .func() Then If .char=0x6c Then If .func() Then If .char=0x6c Then PushIt() : =True
                  Sub PushIt()
                        Stack .obj {
                              Push .Null()
                        }
                  End Sub
            }
            Function final IsSemiCol {
                    If .char=0x3a Then =true 
            }
            Function final IsComma {
                    If .char=0x2c Then =true 
            }
            Function final IsObject {
                  If  .char=123 Else exit
                  inventory objinv
                 ' we push object with a pointer to objinv
                 Stack .obj { Push .Object(objinv)}
                 .Trim
                 While .IsId() 
                       .Trim
                       If  .IsSemiCol() Then
                             .Trim
                             If .IsValue() Then
                                   Stack .obj {
                                          Shift 2   ' move top as second
                                          ' letter$ is ok If top is string, and throw it
                                          Append objinv, Letter$:=Group
                                    }
                              End If
                       Else
                             Exit
                       End If
                       .Trim
                        If not .IsComma() Then exit
                       .Trim
                  End While
                  If .char=125 Then =true  Else .obj<=Stack : .func<=lambda->0 
            }
            Function final IsValue {
                  If .IsString(True) Then
                         =True    
                  Else.if .IsNumber() Then
                        =True
                  Else.if .IsTrue() Then
                        =True
                  Else.if .IsFalse() Then
                        =True
                  Else.if .IsNull() Then
                        =True
                  Else.if .IsArray() Then
                        =True
                  Else.if .IsObject() Then
                        =True
                  Else
                        ? "what", .char
                        Stack .obj { Stack}
                        .func<=lambda->0
                  End If
            }
            Function final Digits (private_stack){
                  While .func()
                        Select Case .char
                        Case 48 to 57
                        {
                              =true
                             Stack private_stack { Data .char}
                        }
                        Else Case
                             break
                        End Select
                  End While    
            }
            Function final IsNumber {
                  a=Stack
                  Select Case .char
                  Case 45 ' -
                  {
                              oldfunc=.func            
                              Stack a { Data .char}
                              If .Func() Then
                                    Select Case .char
                                    Case 48 
                                    {
                                            Stack a { Data .char}
                                            If  .func() Then
                                                If .char=46 Then
                                                      Fraction()
                                                      Exponent()
                                                End If
                                          End If
                                    }
                                    Case 49 to 57
                                    {
                                          Stack a { Data .char}
                                          If .Digits(a) Then {}
                                          Fraction()    
                                          Exponent()
                                    }
                                    Else Case
                                          a=stack
                                    End Select
                              End If
                  }
                  Case 48  ' 0
                  {
                        oldfunc=.func
                        Stack a { Data .char}
                        If  .func() Then
                            If .char=46 Then
                                  Fraction()
                                  Exponent()
                            End If
                      End If
                  }
                  Case 49 to 57
                  {
                              oldfunc=.func
                              Stack a { Data .char} 
                              If .Digits(a) Then {}
                              Fraction()
                              Exponent()
                  }
                  End Select
                  
                  If len(a)>0 Then {
                        b=each(a)
                        Document D$
                        While b
                              D$=chrcode$(StackItem(b))
                        End While
                        .func<=oldfunc
                        If len(D$)>1 Then For i=2 to len(D$) { .Trim}
                        Stack .obj { Push .Numeric(D$) }
                        =True
                  }
                  '  here is an auto exit from function. Sub as command is an exit
                  Sub Fraction()
                        If .char=46 Then Stack a { Data .char}
                        If .Digits(a) Then { }
                  End Sub
                  Sub Exponent()
                        If .char=101 or .char=61 Then
                              Stack a { Data .char}
                              If .func() Then
                                    If .char=43 or .char=45  Then
                                          Stack a { Data .char }
                                          If .Digits(a) Else
                                                a=Stack  ' cleat by point to new Stack
                                          End if
                                    Else.if  .char>47 and .char<58  Then
                                          Stack a { Data .char}
                                          If .Digits(a) Then {}
                                    Else 
                                           a=Stack
                                    End If
                              End If
                        End If
                  End Sub
            }
            Function final IsString (as_object){
            If .char=34 Else exit
                  Document D$
                  While  .func()
                        If .char=34 Then 2000
                        If .char=92 Then
                              ' special care
                              If .func() Then
                                    Select Case .Char
                                    Case 117 'u
                                    GetHex()
                                    Case 114 ' r
                                    .char<=0x0d
                                    Case 110 ' n
                                    .char<=0x0a
                                    Case 116 ' t
                                    .char<=0x09
                                    Case 98 ' b
                                    .char<=0x08
                                    Case 102 ' f
                                    .char<=0x0c
                                    Case 0x22, 0x2f , 0x5c 
                                    Else
                                    Exit   ' not normal
                                    End Select
                              End If
                        End If
                        D$=chrcode$(.char)
                  End While
                  Exit
      02000    Stack .obj { 
                        If as_object Then Push .JString$(D$) Else Push D$
                  } : =True 
                  Sub GetHex()
                        Local D$
                        Document D$="0x"
                        For i=1 to 4
                              If .func() Then End If
                                    If  Chrcode(.char) ~ "[0123456789ABCDEFabcdef]"  Then
                                          D$=Chrcode(.char)
                                    Else
                                          Goto 3000
                                   End If
                              End If
                        Next I
                        If i<>5 Then 3000
                        .Char=Eval(D$)
      03000    End Sub
            }
            Function final IsArray {
                
                  If  .char=91 Else exit
                  Dim Gr()
                  ' We place a pointer ro Array
                  .Trim
                  If .char=93 Then  =true : Stack .obj { Push .Arr(Gr())}  : exit
                        While .IsValue()
                              Stack .obj {
                                    Dim Gr(Len(Gr())+1)
                                    Gr(len(Gr())-1)=Group
                              }
                              .Trim
                              If not .IsComma() Then exit
                              .Trim
                        End While
                  ' Push later pointer to array (maybe altered in redimension)
                  If .char=93 Then  =true :  Stack .obj { Push .Arr(Gr())}  Else .Func<=lambda->false
            }
            Module final Trim  {
                  While  .func()
                         If  .char<33 or .char=160 Else exit      
                  End While
            }
            Function final  IsContainer {
                 .Trim
                 Select Case chrcode$(.char)
                 Case "{"
                        =.IsObject() 
                 Case "["
                        =.IsArray()
                 end select
            }
      ' merge a foreign group here
            Module final ReadArrayItem (temp, object){
                   Select Case temp.type$
                        Case "String","Boolean","Number", "Null"
                        {
                              If object Then Error "No object "+quote$(temp.type$)
                              Push temp.str$
                        }
                        Case "Object"
                        {
                              If not Empty Then
                                 Call .ReadObject temp, object, letter$
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        Case "Array"
                        {
                              If not Empty Then
                                    ' recursion only with Call statement for modules
                                    Call .ReadArrayItem, Array(temp, number), object
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        End Select
            }
            Module final ReadObject (json, object){
                  If type$(json)="Inventory" Then
                        If exist(json, Letter$) Then
                              temp=eval(json)
                        Else
                             push "none"
                             Break  ' exit Module final  (Break do something Else in Select End Select)
                        End If
                  Else
                        temp=json
                  End If
                        Select Case temp.type$
                        Case "String","Boolean","Number", "Null"
                        {
                              If object Then Error "No object "+quote$(temp.type$)
                              Push temp.str$
                        }
                        Case "Object"
                        {
                              If not Empty Then
                                    Call .ReadObject temp, object ', letter$
                              Else
                                    If object Then Push Temp : exit                              
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        Case "Array"
                        {
                              If not Empty Then
                                    Call .ReadArrayItem array(temp, number), object
                              Else
                                    If object Then Push Temp : exit
                                    Push .ser$(group(temp),0)
                              End If
                        }
                        End Select
            }
            Module final Worker (object){                        
                         If match("IN") Or match("IS") Then   ' inventory & number or inventory and string
                         '    maybe we have more items in Stack
                               Push object : ShiftBack 2
                              .ReadObject
                         Else
                              read Temp  ' get  a group which returns Iventoty or an mArray
                              If Type$(Temp)="mArray" Then
                                    If not Empty Then
                                          Call .ReadArrayItem, Array(Temp, number), object
                                    Else
                                          If object Then Push Temp : exit
                                          Push .ser$(Temp,0)
                                    End If
                              Else
                                    If not Empty Then
                                                Call .ReadObject Temp, object
                                    Else
                                          If not Empty Then
                                                Call .ReadObject Temp, object
                                          Else
                                                If object Then Push Temp : exit
                                                If Type$(Temp)="Inventory" Then
                                                      Push .ser$(.Object(Temp),0)
                                                Else
                                                      Push .ser$(group(Temp),0)
                                                End If
                                          End if
                                   End If
                              End If
                        End If
            }
      Public:
      \\ This is the Public part
      \\ First we set Public some class for later use
      \\ Using Pointer to Array in Class Arr
            Class Arr {
            Private:
                  MyValue
            Public:
                  Property Type$ {Value} ="Array"
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Arr (.MyValue) {}
            }
            Class Null {
                 Property Type$ {Value} ="Null"
                 Property Str$ {Value}="null"
                 Value { =0}
            }
            Class JString$ {
            Private:
                  MyValue$=""
            Public:
                  Property Type$ {Value} ="String"
                  Property Str$ {
                        Value{
                              Link parent MyValue$ to MyValue$
                              value$=quote$(string$(MyValue$ as json))
                        }
                  }
                  Value {
                        =.MyValue$
                  }
            Class:
                  Module final JString (.MyValue$) {}
            }
            Class Numeric {
            Private:
                  MyValue$=""
            Public:
                  Property Type$ {Value} ="Number"
                  Property Str$ {
                        Value{
                              Link parent MyValue$ to MyValue$
                              value$=MyValue$
                        }
                  }
                  Value {
                        =Val(.MyValue$)
                  }
            Class:
                  Module final Numeric {
                  If match("S") Then
                        Read .MyValue$
                  Else
                        value$=trim$(str$(Number))
                        ' M2000 return -.3 for -0.35
                        ' using ? str$(MyValue, "0.#############")
                        ' we get locale decimal char - maybe is comma
                        ' so using str$(MyValue) we get integer or float with char "." for decimal always
                        ' so we have to add 0
                        If left$(value$, 1)="." Then
                              value$="0"+value$
                        Else
                               If  value$ ~ "-.*" Then value$=replace$("-.","-0.", value$)
                         End If
                        .Myvalue$<=value$
                  End If
                  }
            }
            Class Boolean {
            Private:
                  MyValue=false
            Public:
                  Property Type$ {Value} ="Boolean"
                  Property Str$ {
                        Value{
                              Link parent MyValue to MyValue
                              If MyValue Then {
                                    value$="true"
                              } Else value$="false"
                        }
                  }
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Boolean (.MyValue) {}
            }
            Class Object {
            Private:
                  Inventory MyValue
            Public:
                  Property Type$ {Value} ="Object"
                  Value {
                        =.MyValue
                  }
            Class:
                  Module final Object (.MyValue) {}
            }
      \\ Empty group, with $, so we get two vars, Ser and Ser$ ( Ser$ we want to return a value type String)
            Group Ser$
            Module final SetSpace (.ser.space) { ' set space for values - 6 by default
            }
            Function final UseDecimalPoint$ {
                  ' use this to change standard decimal point to local decimal point character
                  =str$(val(letter$),"")
            }
            Function final ReadNumber$ {
                        .Worker false   'modules get caller Stack
                        =.UseDecimalPoint$( Letter$)
            }           
            Function final ReadAnyString$ {
                        \\ read an inventory
                        .Worker false
                        =Letter$
            }
            Function final ReadAny {
                        \\ read an inventory
                        .Worker true
                        Read A
                        =A
            }
            Function final Eval {
                  ' Letter$  pop a string ftom Stack Else give error
                   .func<=Lambda z=.bStream(Letter$) -> {
                         link .char to c
                         ' we can't pass reference in a private member
                         =z(&c)
                   }
                  ' In this Parser we use a dedicated Stack
                  ' for use from recuirsive memberts
                  ' .obj is a pointer to Stack
                  ' we can delete it simply setting a new Stack
                  ' .obj<=Stack 
                  ' or we can flush all elements Using a command Flush
                  ' .obj,  char and .func() are visible from group members
                  ' test
                  Stack .obj { Flush}
                  .char<=0
                  If   .IsContainer()  Then
                        ' we get the pointer
                        =StackItem(.obj)
                        .obj<=Stack
                  Else
                        ' return an Empty object
                        inventory emptinv
                        =.Object(emptinv)
                  End If
            }
            Group StringValue$ {
                  Add=false
                  Del=false
                  ' from revision 12 we can place temp in parameter block
                  Set (temp) {
                        ' always first read is for the assigned value to Group
                        Read temp1
                        If type$(temp)<>"Group" Then error "Need a group"
                        If not valid(temp.type$="") Then error "not a proper group"
                        If not valid(temp1.type$="") Then error "not a proper group for value"
                        ' because Null() is out of this scope we have to link
                        Link parent Null() to MyNull()
                        Null=MyNull()
                        ' or we can hard code the Null object
'                        Group Null {
'                                  Property Type$ {Value} ="Null"
'                                  Property Str$ {Value}="null"
'                                  Value { =0}
'                       }
                        Dim Base 1, A(1)
                        \\ now we get the second interface for arrays
                        \\ bb() has a reference to b (one reference allowed)
                        \\ but b is pointer to array and can change to point to other arrrays
                        \\ we need ths to perform some tasks which belong to standard arrray interface
                        b=(,) : Link b to bb()  
                        A(1)=Group(temp)
                        Do
                              again=false
                              Select Case A(1).type$
                              Case "Array"
                              {
                                    If match("N") Then
                                          Read where
                                          If len(A(1))<=where and Empty Then
                                          ' only the last array we can redimension
                                                If .add and not .del Then
                                                      cursize=Len(A(1))
                                                      b=A(1) ' A(1) has a pointer so now b has the same pointer
                                                      ' dim preserve values
                                                      Dim bb(where+1)  ' need one more because all "automatic arrays" have base 0
                                                      Stock bb(cursize) sweep Len(b)-cursize, Group(Null)
                                                Else
                                                      Error "Index out of limits"+str$(where)
                                                End If
                                          Else
                                                If where<0 Then Error "Index out of limits "+str$(where)
                                          End If
                                          If Empty Then
                                                If .del Then
                                                      cursize=Len(A(1))
                                                      b=A(1) ' A(1) has a pointer so now b has the same pointer
                                                      If where<cursize-1 Then
                                                            Stock bb(where+1) Keep cursize-where, bb(where)
                                                      End If
                                                      Dim bb(cursize-1)   ' bb(0) is an empty array
                                                Else
                                                      Return A(1), where:=Group(temp1)
                                                End If
                                          Else
                                                A(1)=Array(A(1),where)
                                                again=True
                                          End If
                                    Else
                                          Error "No Index Found"
                                    End If
                              }
                              Case "Object"
                              {
                                    If match("S") Then
                                          Read k$
                                          If Exist(A(1), k$)   Then
                                                If Empty Then
                                                      If .del Then
                                                           Delete A(1) , k$
                                                      Else
                                                            Return A(1), k$:=Group(temp1)
                                                      End If
                                                Else
                                                      A(1)=Eval(A(1))  ' Eval(inventory_pointer) return  object pointer
                                                      again=True
                                                End If
                                        Else.if .add and not .del Then
                                                 If Empty Then
                                                            Append A(1), k$:=Group(temp1)
                                                Else
                                                      Error "No such Tag "+k$
                                                End If
                                         Else
                                               Error "No such Tag "+k$
                                         End If
                                    Else
                                          Error "No Tag Found"
                                    End If
                              }
                              End Select
                         until not again
                  }
                  Value (temp) {
                        If type$(temp)<>"Group" Then error "Need a group"
                        If not valid(temp.type$="") Then error "not a proper group"
                        Dim Base 1, A(1)
                        A(1)=Group(temp)
                        Do
                              again=false
                              Select Case A(1).type$ 
                              Case "String", "Number", "Null", "Boolean"
                                    Exit
                              Case "Array"
                              {
                                    If match("N") Then
                                          A(1)=Array(A(1), Number)
                                    Else
                                          Error "No Index Found"
                                    End If
                                    again=True
                              }
                              Case "Object"
                              {
                                    If match("S") Then
                                          If Exist(A(1), Letter$)   Then
                                                A(1)=Eval(A(1))  ' Eval(inventory_pointer) return  object pointer
                                          Else
                                                Error "No such Tag"
                                          End If
                                    Else
                                          Error "No Tag Found"
                                     End If     
                                    again=True
                              }
                              End Select
                        until not again
                         =A(1).str$
                  }
            }
      Class:
      \ one time definitions
            Class CreatSerialize$ {
            Private:
                  usen=0
                  n=0
                  nl1$={
                  }
                  Function final Jarray$ (json1, n){
                        \\ json1 is group type Array
                                 A=json1
                              \\ A is mArray (pointer to Array)
                              nl$=.nl1$
                              If .usen>0 Then
                                    nl$=nl$+string$(" ",  n+.space)
                              End If
                              document a$
                              a$="["
                              If Len(A)>0 Then
                                    If .usen>0 Then a$=nl$
                                     k=each(A)
                                     M=len(A)-1
                                     while k
                                          For This {
                                                \\ temporary group
                                                Temp=array(k)
                                                select Case temp.type$
                                                Case "Number", "Null","Boolean", "String"
                                                a$=temp.str$
                                                Case "Array"
                                                {
                                                      nn=0
                                                      If .usen>0 Then
                                                            nn=n +.space
                                                      End If
                                                      a$=.Jarray$(Temp, nn, "")
                                                }
                                                Case "Object"
                                                {
                                                     nn=0
                                                      If .usen>0 Then
                                                            nn=n +.space
                                                      End If
                                                      a$=.Jobject$(Temp, nn,"")
                                                }
                                                Else Case
                                                      a$=" "+temp.type$
                                                end select
                                                 If k^<M Then
                                                     a$=", "
                                                      If .usen>0 Then a$=nl$
                                                Else
                                                      If .usen>0 Then a$=.nl1$
                                                End If
                                          }
                                    End While
                               Else
                                     If .usen>0 Then  a$=.nl1$
                               End If
                               If .usen>0 Then a$=string$(" ", n)
                        a$="]"
                           =a$+letter$
                  }
                  Function final Jobject$ (json1, n){
                                    json=json1
                                    \\ json has to be an object inventory
                                    nl$=.nl1$
                                    If .usen>0 Then
                                          nl$=nl$+string$(" ",  n+.space)
                                    End If
                                    document a$
                                    a$="{"
                                    If .usen>0 Then a$=nl$
                                     k=each(json)
                                     M=len(json)-1
                                     while k
                                          a$=quote$(eval$(json, k^)) +" : "
                                          select Case json(k^!).type$
                                          Case "Array"
                                          {
                                                nn=0
                                                If .usen>0 Then
                                                      nn=n +.space
                                                End If
                                                a$=.Jarray$(eval(k), nn, "")
                                          }
                                          Case  "Boolean", "Null", "Number", "String"
                                                a$=json(k^!).str$
                                          Case "Object"
                                          {
                                                nn=0
                                                If .usen>0 Then
                                                      nn=n +.space
                                                End If
                                                a$=.Jobject$(eval(k), nn, "")
                                          }
                                          Else Case
                                                a$=" "+json( k^!).type$
                                          end select
                                          If k^<M Then
                                               a$=", "
                                                If .usen>0 Then a$=nl$
                                          Else
                                                If .usen>0 Then a$=.nl1$
                                          End If
                                    End While
                               If .usen>0 Then a$=string$(" ", n)
                              a$="}"
                              =a$+letter$
                  }
                  Class Object {
                  Private:
                        Inventory MyValue
                  Public:
                        Property Type$ {Value} ="Object"
                        Value {
                              =.MyValue
                        }
                  Class:
                        Module final Object (.MyValue) {}
                  }
            Public:
                  space=10
                  Value (json, n) {
                              a$=.nl1$
                              b$=""
                              .usen<=n
                              n--
                              If n<=0 Then  a$="" : n=0 Else b$=string$(" ", n)
                              If type$(json)<>"Group" Then
                                    If type$(json)="Inventory" Then
                                          =b$+.Jobject$(.Object(json),n, a$)
                                    Else.if type$(json)="mArray" Then
                                          =b$+.Jarray$(json, n, a$)
                                    End If
                              Else
                                    If json.type$="Object" Then
                                          =b$+.Jobject$(json, n,a$)
                                    Else.if json.type$="Array" Then
                                          =b$+.Jarray$(json, n, a$)
                                    End If
                              End If
                  }
            }
            Module final ParserClass {
                  \ constructor
                  \ Let work as Push .CreatSerialize$() : Read .Ser
                  \ So now Group Ser loaded from CreatSerialize$()
                  \ Class CreatSerialize$ is a Function final, and because it is after Class:
                  \ Deleted before ParserClass return Group
                  Let .Ser=.CreatSerialize$()
            }
      }
}
MODULE R2 {\\ we can change mid$(), only for this sub
\\ integer has value 3 (as a M2000 read only value)
\\ also control$ is a string read only value
function mid$(a$, x) {
	=string$(a$, x)
}
Module Inside {
	Print mid$("aaa",2), "from inside module"
}
see_work()
inside
print mid$("aaa",2), integer, control$="MAIN"

sub see_work()
	Local integer=10, control$="Hello"
	\\ we can redifine functions, but using New, we make a new one, without erasing an other
	\\ if you change new with global you get error because mid$() defined as local in this module
	\\ so a local function has priority over a global one
	\\ We get error because the local one expect string first, not a number
	function new mid$(x) {
		read x
		=str$(x,"0.00")
	}
	'inside
	Print mid$(10), integer, control$
end sub
}
MODULE FL {\\ Slow,  Fast and Fast !
\\ Normal is Fast
Smooth off
Set Fast !
Rem Try To unhide this line : Test "flowers"
N=Random(!123567)
N=7
Dim Px(N+1), Py(N+1), Pz(N+1)
For i=1 To N {      \\ x.twips and y.twips are the resolution of the displayed form in twips.
      Px(i)=random(50,1100)*15
      Py(i)=random(50, 800)*15
      Pz(i)=random(2,6)*500
}
Dim Dx(100),Dy(100)
For i=0 To 99 {
      Dx(i)=COS(i*36)*150
      Dy(i)=SIN(I*27)*150
}
Let mx=Mouse.X, my=Mouse.Y
Let kk=Pi/5, kkk=kk, mx1=mx, my1=my, nnn=100, m=0
Refresh 1000
Cls #1155AA, 0
j=0
Repeat {
      Cls
      j++
      nnn= nnn Mod 64
      For i=1 To N {      \\ x.twips and y.twips are the resolution of the displayed form in twips.
            Px(i)+=Dx((j+3*i) Mod 100) +mx1-mx
            Py(i)+=Dy((j+i) Mod 100) +my1-my
            Let mx1=mx, my1=my
            Move Px(i),Py(i)
            Width 5 {    \\ setting line width
                  Pen #AA6600  {  \\using colors like html hex values
                        nnn+=kk    
                       kkk=Pi-nnn/Pi
                       For q=Pi/8 To 2*Pi-Pi/8 Step Pi/4 {
                              Move Px(i), Py(i)
                              Path #FF66FF, abs(m) { curve angle Pi/3+q-kkk, Pz(i)/6,Pi/4+q-kkk,Pz(i),Pi+q-kkk,Pz(i)*2/3 }
                        }
                        Move Px(i),Py(i)
                        Circle Fill #FFAA20, Pz(i)/3
                  }
            }
            m=Keypress(1)
            If m then {
                  px(i)=Mouse.X
                  py(i)=Mouse.Y
            }
            mx=Mouse.X
            my=Mouse.Y
      }
      Refresh 1000
 }  Until Keypress(2)

Hold   \\ save screen to memory
Move Scale.X/2, Scale.Y/2
def speed(i)=1.45*i
i=8
While i<120 {
      Legend  "Game Over","ARIAL BLACK", speed(i), i/180,2,0
      Refresh 1000
      Wait 30
      release  \\ copy from memory
      i*=1.05
}
SET FAST
CLS
}
MODULE FB {Cls , 0
Report {
	Fibonacci sequence
	
	The Fibonacci sequence is a sequence   Fn   of natural numbers defined recursively: 
				F0 = 0 
				F1 = 1 
				Fn = Fn-1 + Fn-2, if n>1 

	We use a BigNum class to get the first 2000 Fibonacci numbers.

}
Cls, row
Class BigNum {
      a=stack
      Function Digits {
            =len(.a)*14-(14-len(str$(stackitem(.a,len(.a)) ,"")))
      }
      Operator "+" (n) {
            \\ we get a copy, but .a is pointer
             \\ we make a copy, and get a new pointer
            .a<=stack(.a)
           
            acc=0
            carry=0
            const d=100000000000000@
                  k=min.data(Len(.a), len(n.a))
                  i=each(.a, 1,k )
                  j=each(n.a, 1,k)
                  while  i, j {
                        acc=stackitem(i)+stackitem(j)+carry
                        carry= acc div d
                        return .a, i^+1:=acc mod d
                  } 
                  if len(.a)<len(n.a) Then  {
                        i=each(n.a, k+1, -1)
                        while i {
                              acc=stackitem(i)+carry
                              carry= acc div d
                              stack .a  {data acc mod d}
                        }
                  } ELse.if len(.a)>len(n.a) Then  {
                        i=each(.a, k+1, -1)
                        while i {
                              acc=stackitem(i)+carry
                              carry= acc div d
                              Return .a, i^+1:=acc mod d
                              if carry else exit
                        }     
                  }
                  if carry then stack .a { data carry}
      }
      Function tostring$ {
            if len(.a)=0 then ="0" : Exit
            if len(.a)=1 then =str$(Stackitem(.a),"") : Exit
            document buf$=str$(Stackitem(.a, len(.a)),"")
            for i=len(.a)-1 to  1 {
                  Stack .a {
                        buf$=str$(StackItem(i), "00000000000000")
                  }
            }
            =buf$
      }
      class:
      Module BigNum (s$) {
            s$=filter$(s$,"+-.,")
            if s$<>""  Then {
                  repeat {
                        If len(s$)<14 then Stack .a { Data  val(s$) }: Exit
                        Stack .a { Data  val(Right$(s$, 14)) }
                        S$=Left$(S$, len(S$)-14)
                  } Until S$=""
            }
      }
} 

Inventory K=0:=BigNum("0"),1:=BigNum("1")
fib=Lambda K (x as decimal)-> {
      If Exist(K, x) Then =Eval(K) :Exit
      Ret=If(x>1->Lambda(x-1)+Lambda(x-2), bignum(str$(x,"")))
      Append K, x:=Ret
      =Ret
}
Set Fast!
For i=1 to 2000 {
      N=Fib(i)
      Print i
      Print N.tostring$()
      Refresh
}
Set Fast
}
MODULE BN {Dim Mod$(0 to 99), Mul(0 to 9,0 to 9)
for j=0 to 9 : For i=0 to 9:Mod$(i+j*10)=str$(i mod 10,0): Mul(i,j)=i*j : Next i :Next j
profiler
a$="1231231231231231231231231231232132131213130989802139080120931920389"
\\ a$ x n
n1$="1234567767765675576765234324243122131213122113123120898031238910823"
Print val(n1$)*val(a$)
k=0
acc=0
a$=strrev$(a$)
inventory num
rev3$=""
n1=len(n1$)
while n1>0 
n=val(mid$(n1$,n1,1))
n1--
rev2$=string$("0", k)
rev1$=""
k++

if n>0 then
      if not exist(num, n) then
      digit=0&
      For i=1 to len(a$)
      digit+=n*val(mid$(a$,i,1))
      rev1$+=str$(digit mod 10,0)
      digit/=10&
      Next i
      if digit then rev1$+=str$(digit mod 10,0)
            Append num, n:=rev1$
      else
            rev1$=num$(n)
      End if
      rev2$+=rev1$
      if len(rev3$)=0 then
            swap rev2$, rev3$
      else
            swap rev1$, rev3$
            rev3$=""
            if rev2$<rev1$ then swap rev1$, rev2$
            digit=0
            For i=1 to len(rev1$)
            digit+=val(mid$(rev1$, i, 1))+val(mid$(rev2$, i, 1))
            rev3$+=str$(digit mod 10,0)
            digit/=10&
            next i
            if digit>0 then rev3$+=str$(digit mod 10,0)
      end  if
      End if
End While
Print strrev$(rev3$)
print timecount
}
MODULE DI {inline code libdiv
op=Pen
Def ExpStr$(x)= str$(X,"0.00000000000000E-00")
\\ using old style subs - no local variables
a$="57645834674367349573945793457359374512154545412313137868768787874738942834756234896582946937658926582565"
b$="3224241711"
Gosub calc
a$="1"
b$="3224241711"
Gosub calc
a$="23200"
b$="58"
Gosub calc
a$="1"
b$="58"
Gosub calc
a$="1"
b$="3"
Gosub calc
a$="100"
b$="30"
Gosub calc2
Gosub calc
a$="57645834674367349573945793457359374512154545412313137868768787874738942834756234896582946937658926582565"
b$="5235"
Gosub calc2
b$="17"
Gosub calc2
Gosub calc
end

calc:
      Print
      Pen 11 {
            Print "Calculation for ";
      }
      Print a$;~(12);"/";~(op);b$
      Print ExpStr$(val(a$)/val(b$))
      Print
      Print "Expanded:", ProDiv$(a$, b$, 100)
Return
calc2:
      Print
      Pen 11 {
            Print "Calculation for ";
      }
      Print a$;~(13);" div ";~(op);b$
      Print val(a$) div val(b$)
      Print
      Print "Expanded:", ProDiv$(a$, b$,0)
Return
}
MODULE HU {Module Huffman {
      comp=lambda (a, b) ->{
            =array(a, 0)<array(b, 0)
      }
      module InsertPQ (a, n, &comp) {
            if len(a)=0 then stack a {data n} : exit
            if comp(n, stackitem(a)) then stack a {push n} : exit
             stack a {
                  push n
                  t=2: b=len(a)
                   m=b
                   While t<=b {
                         t1=m
                        m=(b+t) div 2
                        if m=0 then  m=t1 : exit 
                        If comp(stackitem(m),n) then t=m+1:  continue
                        b=m-1
                        m=b
                  }
                  if m>1 then shiftback m
            }
      }
 
      a$="this is an example for huffman encoding"
 
      inventory queue freq
      For i=1 to len(a$)   {
            b$=mid$(a$,i,1)
            if exist(freq, b$) then Return freq, b$:=freq(b$)+1 : continue
            append freq, b$:=1
      }
      sort ascending freq
      b=stack
      K=each(freq)
      LenA=len(a$)
      While k {
            InsertPQ b, (Round(Eval(k)/lenA, 4), eval$(k, k^)), &comp
      }
      While len(b)>1 {
            Stack b {
                 Read m1, m2
                 InsertPQ b, (Array(m1)+Array(m2), (m1, m2) ), &comp
            }
      }
      Print  "Size of stack object (has only the Root):"; len(b)
      Print "Root probability:";Round(Array(Stackitem(b)), 3)
      inventory encode, decode
 
      Traverse(stackitem(b), "")
      message$=""
      For i=1 to len(a$)
      message$+=encode$(mid$(a$, i, 1))
      Next i
 
      Print  message$
      j=1
      check$=""
      For i=1 to len(a$)
            d=each(encode, -1,1)  ' from last to first - works  d=each(encode)  from start
            While d {
                  code$=eval$(d)
                  if mid$(message$, j, len(code$))=code$ then {
                        check$+=decode$(code$)
                        Print decode$(code$); : j+=len(code$)
                  }
            }
      Next i
      Print
      Print len(message$);" bits ", if$(a$=check$->"Encoding/decoding done", "Encoding/Decoding failed")
 
 
      Sub Traverse(a, a$)
            local b=array(a,1)      
            if type$(b)="mArray"  Else {
                  Print  @(10); quote$(array$(a, 1));" "; a$,@(20),array(a)
                  Append decode, a$ :=array$(a, 1)
                  Append encode, array$(a, 1):=a$
                  Exit Sub   
            }
            traverse(array(b), a$+"0")
            traverse(array(b,1), a$+"1")
      End Sub
}
Huffman
 
}
MODULE RE {Module CheckIt {
      declare global ObjRegEx "VBscript.RegExp"
      Function RegEx.Replace$(from$, what$) {
            Method ObjRegEx, "Replace", from$, what$ as response$
            =response$
      }
      Function RegEx.Test(what$) {
            Method ObjRegEx, "Test", what$ as response
            =response
      }
      Print Type$(ObjRegEx)
      With ObjRegEx, "Global", True, "Pattern" as pattern$
      pattern$="Mona Lisa"
      Print RegEx.Test("The Mona Lisa is in the Louvre.")=true
      Print RegEx.Replace$("The Mona Lisa is in the Louvre.", "La Gioconda")
      Pattern$ = " {2,}"
      Print "Myer Ken,  Vice President,  Sales and Services"
      \\ Removing some spaces
      Print RegEx.Replace$("Myer Ken,  Vice President,  Sales and Services", " ")
      pattern$="(\d{3})-(\d{3})-(\d{4})"
 
      Method ObjRegEx, "Execute", "555-123-4567, 555-943-6717" as MyMatches
      Print Type$(MyMatches)  ' it is a IMatchCollection2
      With MyMatches, "Count" as count, "Item" as List$()
      For i=0 to Count-1 : Print List$(i) : Next i
 
 
      Print RegEx.Replace$("555-123-4567, 555-943-6717", "($1) $2-$3")
      Pattern$ = "(\S+), (\S+)"
      Print RegEx.Replace$("Myer, Ken", "$2 $1")
      Method ObjRegEx, "Execute", "Myer, Ken" as MyMatches
      Rem : DisplayFunctions(MyMatches)
      \\ we can use Enumerator
      Print "Using _NewEnum"
      With MyMatches, "_NewEnum" as New Matches
      Rem : DisplayFunctions(Matches)
      With Matches, "Value" as New item$
      While Matches {
           Print Item$
      }
      \\ Or just using the list$()
      Print "Using Count and Item properties"
      For i=0 to Count-1 : Print List$(i) : Next i
      declare ObjRegEx Nothing
      End
      Sub DisplayFunctions(x)
            Local cc=param(x),  ec=each(cc)
            while ec {
                  Print eval$(ec)   ' print every function/property of object x
            }
      End Sub
}
Checkit
}
MODULE RE1 {Module Internal {
      what$="Mona Lisa"
      Document a$="The Mona Lisa is in the Louvre."
      Find a$, what$
      Read FindWhere
      If FindWhere<>0 then Read parNo, parlocation
      \\ replace in place
      Insert  FindWhere, Len(what$)  a$="La Gioconda"
      Report a$
 
      n$="The Mona Lisa is in the Louvre, not the Mona Lisa"
      Report Replace$("Mona Lisa", "La Gioconda", n$, 1, 1)  ' replace from start only one
      dim a$()
      a$()=Piece$("Myer, Ken",", ")
      Print a$(1)+", "+a$(0)="Ken, Myer"
}
Internal
}
MODULE CE {a$="THIS IS MY TEXT TO ENCODE WITH CAESAR CIPHER"
Function Cipher$(a$, N) {
      If Len(a$)=0 Then Exit
      a$=Ucase$(a$)
      N=N mod 25 +1
      \\ Integer in Mem is unsigned number
      Buffer Mem as Integer*Len(a$)
      Return Mem, 0:=a$
      For i=0 to Len(a$)-1 {
            If Eval(mem, i)>=65 and Eval(mem, i)<=90 then Return Mem, i:=(Eval(mem, i)-65+N) mod 26+65
       }
       =Eval$(Mem)
}
B$=Cipher$(a$, 12)
Print B$
Print Cipher$(B$,12)
}
MODULE CO {Module Check {
      \\ we use an internal object for Math functions (here for Atan2)
      Declare Math Math
      Const tau=2*Pi, Center=2
      \\ change console size,  and center it ( using ;) to current monitor      
      Window 12, 800*twipsX,600*twipsY;
      \\ actual size maybe less (so can fit text exactly)
      Double  ' Double height characters
      Report Center, "Color wheel"
      Normal  ' restore to normal
      Atan2=Lambda Math (a, b) ->{
            Method Math, "Atan2", a, b As ret
            =ret
      }
      \\ brightness=1 for this program
      hsb2rgb=Lambda (hue, sat) ->{
            If sat == 0 Then {
                = 255, 255, 255
           } Else {
                  h=frac(hue+1)*6
                  f = frac(h)  
                  p = Int((1-sat)*255 + 0.5)
                  q = Int((1-sat*f)*255 + 0.5)
                  t = Int((1-sat*(1-f))*255 + 0.5)
                  Select Case Int(h)
                  Case 1
                      = q, 255, p
                  Case 2
                      = p, 255, t
                  Case 3
                     = p, q, 255
                  Case 4
                      = t, p, 255
                  Case 5
                      = 255, p, q
                  Else Case
                      = 255, t, p
                  End Select
          }
      }
      Let OffsetX=X.twips/2-128*TwipsX, OffsetY=Y.twips/2-128*TwipsY
      \\ a pixel has a size of TwipsX x TwipsY
      OffsetX=(OffsetX div TwipsX)*TwipsX
      OffsetY=(OffsetY div TwipsY)*TwipsY
      \\ We set hsb2rgb, OffsetX, OffsetY as closures to PrintPixel
      \\ We send to stack the R G B values using Stack ! array
      \\ hsb2rgb() return an array of values
      \\ we pop these values using Number
      PrintPixel = Lambda  hsb2rgb, OffsetX, OffsetY (x,y, theta, sat)  -> {
            Stack ! hsb2rgb(theta,sat)  
            PSet Color(number, number, number), x*TwipsX+offsetX, y*TwipsY+offsetY
      }
      \\ set Atan2, tau as closures to HueCircle
      \\ we can rotate/flip the wheel by changing signs in Atan2() and
      \\ by changing order of arguments (dx,dy) or (dy,dx). 8 combinations
      HueCircle= Lambda Atan2, tau (PrintPixel) -> {
            Let  c_width=256, c_height=256
            Let  cx=c_width/2, cy=c_height/2
            Let  radius=If(cx<=cy->cx, cy)
            c_width--
            c_height--
            dy=-cy
            For y=0 To c_height {
                  dy++ : dy2=dy*dy : dx=-cx
                  For x=0 To c_width {
                        dx++ : dist=Sqrt(dx^2+dy2)
                        If dist>radius Then continue
                        Call PrintPixel(x,y, Atan2(dx, -dy)/tau, dist/radius)
                  }
            }
      }
      Call HueCircle(PrintPixel)
      Scr$=""  ' we use this string  to load an image
      Move 0,0
      \\ scale.x, scale.y are twips height and width, of current layer
      Copy scale.x, scale.y to Scr$
      Clipboard Scr$  ' save window to clipboard
}
Check
a$=KEY$
\\ CALL INFO NOW \\ DELETE THIS LINE IF INFO NOT EXIST IN MODULE'S LIST
Keyboard "info"+chr$(13)
}
MODULE SH {hide
wait 100
Desktop  ' copy desktop to background
BackGround {
	img$=""
	move 0,0
	copy scale.x, scale.y to img$
}
wait 1000
show
Title "Shift Console"
cx=pos
cy=row
Escape off
x=motion.x
y=motion.y
t=1000/25
for i=1 to 200 step 5
motion x+i*twipsy, y+i*twipsx
wait t
Next i
wait 1000
motion x, y
Escape on
Form  ' cut border
x=motion.xw
y=motion.yw
t=1000/25
for i=1 to 200 step 5
motion.w x+i*twipsy, y+i*twipsx
wait t
Next i
wait 1000
motion.w x, y
Bmp$=""
Move 0,0
Copy scale.x, scale.y to Bmp$
form ;    ' clear screan and restore border
image bmp$
refresh
cursor cx,cy
Move scale.x/2, scale.y/2
Image img$, scale.x/3
sprite img$,5 ,45,30,40
clipboard img$
Title "Shift Console.. complete"
}
MODULE GR {Report {
	Gray Code
	
}
Module GrayCode {
      Function bin$(a) {
            a$=""
            do {
                  n= a mod 2
                  a$=if$(n=1->"1", "0")+a$
                  a=a div 2
            } until a==0
            =a$
      }
      Function GrayEncode(a) {
            =binary.xor(a, binary.shift(a,-1))
      }
      Function GrayDecode(a) {
            b=0
            do {b=binary.xor(a, b) : a=binary.shift(a,-1) } until a=0
            =b
      }
      For i=0 to 32 {
            g=GrayEncode(i)
            b=GrayDecode(g)
            Print format$("{0::-2} {1:-6} {2:-6} {3:-6} {4::-2}", i, bin$(i), bin$(g), bin$(b), b)
      }
}
GrayCode
}
MODULE AC {\\ M2000 Interpreter
report {
	 Accumulator factory
	 
}
foo=lambda acc=0 (n as double=0) -> {
      if n=0 then =acc : exit 
      acc+=n
      =lambda n=acc (x) -> {
            \\ x has no type here, can be any numeric type (also can be an object too)       
            \\ accumulator is double, and is a closure (a copy of n in foo)
            n+=x
            \\ any variable in M2000 hold  first type
            \\ if x is an object then we get error, except if object use this operator
            x=n
            \\ so we return x type
            =x
      }
}
x=foo(1)
call void x(5)
call void foo(3)   ' void tell to interpreter to throw result
print x(2.3) ' prints 8.3
print foo()=4

}
MODULE TR {\\ goto no_random_mode
m=random(700,1100)/1000
mode 8, scale.x*m, scale.y*m

no_random_mode:
\\ Version 2 we make the drawing to scale based to height
let sc=scale.y/14000, yoffset=100
mode 11*scale.y/14000
Escape Off
Flush
Global alfa=60*4
\\ check for linux (there is no smooth function, we can give the command but we get not the proper results)
if not iswine then Smooth On  \\ use Gdi+
Cls 5,0
Pen 14
Gradient 5,1

\\ set refresh to 1500 msec
Refresh 1500 
\\ temporary we use double heigt characters
Double
Report 2, {Example three oscilloscopes},8000*sc
Normal
Gosub put_a_title
Gosub define_module_b
Gosub make_classes

Triangle=drw(4000*sc,2500*sc+yoffset)
Tk=Display(8000*sc,500*sc+yoffset,8000*sc,4000*sc,45, sc)
b 2000*sc,3, &Triangle.a(), 0
Hexagon=drw(4000*sc,6750*sc+yoffset)
Hk=Display(8000*sc,4750*sc+yoffset,8000*sc,4000*sc,15, sc)
b 2000*sc,6, &Hexagon.a(), 0
My_Circle=drw(4000*sc,11000*sc+yoffset)
Ck=Display(8000*sc,9000*sc+yoffset,8000*sc,4000*sc,30, sc)
b 2000*sc,alfa div 2, &My_Circle.a(), 0
flash=true
introtime=0
timeinterval=600
Dim Fcol(-1 to 0)
Fcol(-1)=#ff3322, #773300
thread {
	flash~
	introtime++
	if flash then
		timeinterval*=.9
		Thread this interval timeinterval
	else 
		Thread this interval 200
	end if
} as t1 interval timeinterval
Hold
i=0
k=1
tipstop=8000*sc
Every 10 { 
      Pen 15 {
            Refresh 1500
            Release  ' we get the background using Hold.
            if t1>0  then Print.Info(flash) : if introtime>50  then Thread t1 Erase : t1=0        

            Triangle.draw_to (i+alfa/6) mod alfa
                  Draw to tipstop, pos.y
                  Tk.tip
                       
            Hexagon.draw_to (i+alfa/12) mod alfa
                  Draw to tipstop, pos.y
                  Hk.tip
                       
            My_Circle.draw_to i
                  Draw to tipstop, pos.y
                  Ck.tip
            If keypress(1) Then
                  k++
            Else.If keypress(2) Then
                  k--
            End If
            i+=k
            i=i mod# alfa
      }
      If inkey$<>"" Then Exit
}
Threads Erase
Escape off
\\ call info again
Keyboard "info"+chr$(13)
smooth off
Exit
put_a_title:
      Move -320*sc, scale.y
      Path { 
          legend "Μ2000","Arial Black", 90*sc,pi/2,0,0,100 
      } ;
      Move -320*sc, scale.y-10000*sc
      Fill 2300*sc, 10000*sc, #221133, #AA8566,1,1
      Path { } ;
      Move -320*sc, scale.y
      Pen 0 {
            \\ transparent background color
            Color { 
                legend "Μ2000","Arial Black", 90*sc,pi/2,0,0,100 
            }
      }
Return
define_module_b:
Module b {
      Read a, n, &ar(), cir
      Dim ar(alfa,2)
      z=pi/2
      km=0
      x=pos.x
      y=pos.y
      If cir Then Circle a
      g=n/2
      kk=alfa/n
      Step Angle -(pi/2+pi/n),a
      b=(x-pos.x)*2/kk
      d=Abs(y-pos.y)
      Step Angle -(pi/2+pi/n),-a
      If cir Then If d>0 Then Circle d
      Step Angle -(pi/2+pi/n)+z,a
      Step Angle 0,0
      For i=0 to 2*pi Step pi/g
            x1=pos.x
            y1=pos.y
            For L=1 to kk
                  Move x1, y1
                  Draw Angle i+z, b*L
                  ar(km,0)=pos.x
                  ar(km,1)=pos.y
                  km++ 
                  km=km mod alfa
                  If cir Then Circle Fill 11,30,1,11
            Next L
      Next i
      Step Angle -(pi/2+pi/n)+z,-a
}
Return
make_classes:
Class drw {
      Dim a(0)
      x, y
      Module drw {
            Read .x, .y
            Move .x, .y
      }
      Module draw_to {
            If Match("N") Then
                  Read i
                  i=Abs(int(i)) mod alfa
                  Move .x,.y
                  Draw to .a(i,0), .a(i,1)
            Else
                  For i=0 to alfa-1
                        Move .x,.y
                        Draw to .a(i,0), .a(i,1)
                  Next i
            End If
      }
}
Class Display {
      x, y, wi, he, stp, tp=-1
      dscr$, counter, sc
      Module Display {
            Read .x,.y,.wi,.he, .stp, .sc
            .y-=30
            .he+=60
            .tp<=1
            x1=pos.x
            y1=pos.y
            Move .x, .y
            Fill .wi, .he, 1,7
            Move .x+100, .y+.he-100
            Pen 11 {
                  Legend "Osc 2000", "Verdana", 8,pi/2,0,0
            }
            Move x1, y1
      }
      Module Tip {
            If .tp=-1 Then Exit
            tp1=pos.y
            If .dscr$<>"" Then { copy .x+.stp, .y use .dscr$ } Else .tp=tp1
            .counter++
            If .counter mod (alfa div 4)=1 Then Move .x+.stp/2, .y : Width 1,3 { Draw 0 ,.he,14 } 
            Move .x, tp1
            Draw to .x+.stp, .tp
            .tp<=tp1
            Move .x,.y
            copy .wi-.stp/2, .he To .dscr$
            Move .x, .y+.he/2
            Pen 14 { Draw .wi }
            Move .x+.wi/2,.y+200
            Pen 12 {
                  Legend Format$("Oscilloscope: {0}sec",str$(.counter/10,"000000.0")), "Lucida Console", 11*.sc, 0, 2, 1, 20
            }
      }
}
Return
Sub Print.Info(x)
	Cursor 0,12
	Pen Fcol(x) {
		Report 2, {
			Press
			Keyboard
			any key - exit
			Mouse buttons
			left - Acc. left
			right - Acc. right
			}, 3000*sc   \\ width 
	}
End Sub
}
MODULE HT {text alfa.html {
<!doctype html>
<html>
<head>
<title>Hello There</title>
<meta name="GENERATOR" content="M2000">
<meta name="FORMATTER" content="M2000">
<meta content="this, other, that" name=keywords>
<meta content=All name=robots> 
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1253">
<meta NAME="Author" CONTENT="GEORGE KARRAS">
<style type="text/css">
body {
    overflow:hidden;
}
</style>
</head>
<body bgcolor="white" text="#000000" link="#0000ff" vlink="#800080" alink="#ff0000" >
<h2>My First JavaScript</h2>

<button type="button"
onclick="document.getElementById('demo').innerHTML = Date()">
Click me to display Date and Time.</button>

<p id="demo"></p>

</body>
}
browser "alfa.html",motion.xw+motion.x,motion.yw+motion.y, scale.x,6000
Print {click, and pres Esc, or use statement Browser ""}
}
MODULE KB {Function CallMe {
     \\  Fkey Clear  - not used
      \\ Keyboard - can play two or more notes at once
      \\ some keybards can play max 6 notes, some other max 4
            refresh 5000
      Thread.Plan Sequential
      Play 0 \\ clear music threads
          
      dim note1$(10,3), note2$(10,3)
      FillArray()
      \\Form ! 60,30      
      back$=""
      \\ hold previous screen, then draw new one, then copy to back$, then release the old one
      \\ then call FadeInScreen passing a dummy function as call back, to use the Back$
      hold
      Refresh 5000
      Move 0,0
      Pen 14
      Gradient 5,5
      Cursor 0,0
      Double
      Report 2, "Keyboard 006 - Fast Response"   
      Normal
      Report 2,{Menu
      1-Exit  3-Xylophone 4-Piano 5-Saxophone  8-Show Keys/Notes 9-Rythm Yes 0-Rythm No
      
      Space bar - set higher the volume for each note
      -- George Karras --
      
      }
      Global kb$=" ", dur=300, org=5, f=0, vol$="V90", voi(18), use(17) ' 0 ..17,
      n=1
      For i=1 to 16 { use(i)=True }
      use(10)= false \\ For drum machine
      \\ compute virtual clavie position
      mm=2*(scale.x div 14)
      mm2= mm div 2
      kk=scale.y/5
      kk1=scale.y/4
      gram=scale.y/20
      '      Scroll Split -Height/2
      DisplayNoRefresh(mm, kk, mm2, kk1)
      Move 0,0
      Copy scale.x, scale.y to back$
      start.at=scale.x*.9
      Function Dummy1 {
            move start.at, 0
            Image back$
            start.at-=scale.x/10
            if start.at<0 then start.at=0
      }
      Function Dummy0 {
            move 0, 0
            Image back$
      }
      Release
       if random(10)<6 then
            FadeInScreen2 Lazy$(&Dummy1()),1.3
      else
            FadeInScreen Lazy$(&Dummy0()),1.3
      end if
      call local Dummy0()
      refresh 5000
      Scroll Split  Height/2+1
      Cursor 0, Height/2+1
      Global Refr=True
      Module ClKey {
            Read a$, press, sel
            If press Then {
            If Instr(kb$,a$+"-")>0 Then Exit
            Next()
            voi(sel)=f
            Print a$, f
            Refr<=true
            Score f, dur, a$+vol$ : kb$<=kb$+a$+"-": Play f, org
            } else {
                  kb$<=Replace$(a$+"-","", kb$)
                  If voi(sel)>0 Then {
                  Refr<=true
                   Play voi(sel), 0 
                   use(voi(sel))~
                   voi(sel)=0
                   }
            }
            Sub Next()
            Local i
            For i=1 to 16 {
                  If use(i) Then Exit
            }
            If i<17 Then { f<=i : use(i)~ } else f<=1: use(1)=True : Print "!!!!!!!!"
            End Sub
      }
      \\ 10 for drum machine
      Thread { Score 10,400,"CV90CC  ab Cd eCC" : Play 10,1 } as L Interval 60
      Thread {
            ClKey "A#2", KeyPress(asc("A")), 1
            ClKey "B2", KeyPress(asc("Z")), 2
            ClKey "C3", KeyPress(asc("X")), 3
            ClKey "C#3", KeyPress(asc("D")), 4
            ClKey "D3", KeyPress(asc("C")), 5
            ClKey "D#3", KeyPress(asc("F")), 6
            ClKey "E3", KeyPress(asc("V")), 7
            ClKey "F3", KeyPress(asc("B")), 8
            ClKey "F#3", KeyPress(asc("H")), 9
            ClKey "G3", KeyPress(asc("N")), 10
            ClKey "G#3", KeyPress(asc("J")), 11
            ClKey "A3", KeyPress(asc("M")), 12
            ClKey "A#3", KeyPress(asc("K")), 13
            \\ https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
            ClKey "B3", KeyPress(0xBC), 14 \\ VK_OEM_COMMA
            ClKey "C4", KeyPress(0xBE), 15 \\ VK_OEM_PERIOD
            ClKey "C#4", KeyPress(0xBA), 16 \\ VK_OEM_1
            ClKey "D4", KeyPress(0xBF), 17 \\VK_OEM_2  
      } as al Interval 50
      Print "οκ"
      Threads
      Thread L Interval 6000
      Main.Task 10 {
            If Refr Then refresh 1000 : Display(mm, kk, mm2, kk1): Refr<=false
            Refresh 10: wait 1
            If KeyPress(asc("1")) Then Exit
            If KeyPress(asc("3")) Then org<=14 : dur<=100 
            If KeyPress(asc("4")) Then org<=5 : dur<=300
            If KeyPress(asc("5")) Then org<=65 : dur<=5000
            If KeyPress(asc("8")) Then n=1-n : refr<=true
            If KeyPress(asc("9")) Then Thread L Restart
            If KeyPress(asc("0")) Then Thread L Hold
            If KeyPress(32) Then { vol$ <= "V127"  } else vol$ <=if$(dur=300->"V100", "V110")
            Print "--------"
      }
      Threads Erase
      Print "End"
      \\ delete this line
      \\Keyboard "Info"+chr$(13)
      Scroll Split  0
     
      Exit
      Sub DisplayNoRefresh(p0,y0, p1, y1)
            Clavie(p0, y0, p1, y1, 0, &note1$())
            Clavie(p0-p1/2,y0,p1,y1*2/3, -1, &note2$())
      End Sub
      Sub Display(p0,y0, p1, y1)
            Clavie(p0, y0, p1, y1, 0, &note1$())
            Clavie(p0-p1/2,y0,p1,y1*2/3, -1, &note2$())
            Refresh 1000
      End Sub
      Sub Clavie(p0, y0,p1, y1, p3, &n$())
            Link n$() to n()
            p3-!
            Local k=-1, i
            For i=p0 to 9*p1+p0 step p1
            k++
            If n$(k,0)<>"" Then {
                  Move i+p3*p1/6, y0
                  If p3 Then {
                        Fill p1-p3*p1/3-15,y1-15, 7* (1-(voi(n(k,2))>0))+1, 0,1
                  } else {
                        Fill p1-15,y1-15,15,7* (1-(voi(n(k,2))=0))+1,1
                  }
                  Move i+p3*p1/6, y0
                  Fill @ p1-p3*p1/3,y1,2,1
                  Move i+p3*p1/6, y0+y1-gram
                  Pen p3*15 { Fill @ p1-p3*p1/3,gram,5,n$(k,n)}
            }
            Next i
      End Sub
      Sub FillArray()
      Local n,p, n$, k$, no
      Stack New {
            Data "A#2", "A", 1, 1, 2
            Data "B2", "Z", 2, 1, 1
            Data "C3", "X", 3, 2, 1
            Data "C#3", "D", 4, 3, 2
            Data "D3", "C", 5, 3, 1
            Data "D#3", "F", 6, 4, 2
            Data "E3", "V", 7, 4, 1
            Data "F3", "B", 8, 5, 1
            Data "F#3", "H", 9, 6, 2
            Data "G3", "N", 10, 6, 1
            Data "G#3", "J", 11, 7, 2
            Data "A3", "M", 12, 7, 1
            Data "A#3", "K", 13, 8, 2
            Data "B3", ",", 14, 8, 1
            Data "C4", ".", 15, 9, 1
            Data "C#4",";", 16 , 10, 2
            Data "D4", "/", 17, 10, 1 
            While Not Empty {
            Read n$, k$, no, n, p
                  If p=1 Then {
                      note1$(n-1,0):= n$, k$, no  \\ feed a row
                  } else {
                        note2$(n-1,0):= n$, k$, no
                  }
            }
      }
      End Sub
}
Inline code LibFade
FadeScreen Lazy$(&CallMe()), 1.7
}
MODULE AU {Declare form1 Form
Declare combo1 combobox Form form1
Declare text1 textbox Form form1
With form1,"Title" As title$
With combo1,"Edit", True,"UseOnlyTheList", false,"autocomplete", True, "listIndex" As ListIndex,"ShowAlways", True
With combo1,"label","Combo1", "ListText" As item$, "list" As list$(), "text" As combo1$
item$={alfa
            delta
            gamma
            beta
            }
With combo1,"Find" As Find()
Method combo1,"Sort"
combo1$=list$(find("gam*"))

Method combo1,"Move", 1000,1000,6000,600
Method text1, "Move", 1000,2900,6000,600

With text1, "left" As left, "text" As text1.text$ , "ShowAlways", True
Print left
Method form1, "show"
Method text1,"GetFocus"
Function form1.unload {
      Keyboard "!"
      show
}
Function combo1.dblclick {
        text1.text$=combo1$
        title$=combo1$
        If find(title$)= -1 Then {
            Method combo1,"additem",title$
            Method combo1,"Sort"
            listindex=find(title$)
      }
}
Function combo1.click {
      If listindex>=0 Then text1.text$=list$(listindex)
}
Function combo1.scroll {
      If listindex>=0 Then text1.text$=list$(listindex)
}
a$=key$
Declare Text1 nothing
Declare combo1 nothing
Declare form1 nothing
}
MODULE ICO {\\$ ..........\appdata\roaming\m2000\m2000png.png
Binary {
      iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAA+vAAAP
      1wExQtGTAAAADXRFWHRDb21tZW50ACSZhQMALhdS/QAAAUZJREFUeJzFlosNwyAM
      RNl/A2bJcK6S1MT4D5QUdCpSif04O7QFyn/nOYDK2ZjaNwVwHMclHlgkhVu/hGkA
      QIJpSS2tQpT74dIArMS12uKOeBIAeOKuDMpJr0SrigDAsbwB4KzsE9h3VVl7AFiG
      EGCXA2cCLEPKAX56zQm+NwNgufCKA14ZOgcyp9UccnsA/DJsd4ACaC6oPWCd1uoR
      D+C5KOSl1GRZS9cWUKU5NAcCNYDaB1vRHADQIOFjjr4xOgAckQNGcmxgqhBiGAB8
      AA7zKgAmxhB7AJQS0EROiD0OxKeUPWIDOLIcGAGQEDMAigMRBO2LHnoUoNNTtQiC
      VnatBNcaCgdAiJFSCAAPgt/h/C2Yh6A/CqrN8u7WADgEB7HBCEAEIffZtdauZB2C
      AWSndxNqYxOADZGu/yxAtmfS/wf+AYExPhJPvgsIMdG8AAAAAElFTkSuQmCC
} As ico
try ok {
	read com
}
if not ok then
	Print "Error"+ Error$
	Report "This module used from other modules"
	Report "ico "+"1:"
	modules ? "", "ico "+"1"
	Report "ico "+"0:"
	modules ? "", "ico "+"0"
	exit
end if
if com=1 then 
	Move 0,0
	Image ico, scale.x/width*2  ' (twips/character)
else
	push ico
end if


}
MODULE ICONS {function dummy {
	if isWine then sp=10 : r=30 else sp=40 : r=60
	Escape off
	Def a,b,c
	\\ ico is another module : write edit ico to open it
	call ico, 2
	read ico
	\\gradient 5,0
	\\ call global
	Fade 5, 0
	useM200sprites=random(1,2)=1
	move scale.x/2, scale.y/2
	legend str$(sp,0)+If$(useM200sprites->" M2000"," GDI+")+{ Sprites
	rotating,resizing
	changing opacity
	}, "Arial Black", 22,0,2,1,150
	hold
	Wait 500
	mouse.icon hide
	n=0
	p=false
	if useM200sprites then
		spr$=""
		image ico (5) to spr$    ' use 5 (magenta) as transparent color
		every 1000/r {
			release
			if p then 
			move mouse.x, mouse.y
			sprite spr$,5,n-29,200,50
			hold
			p=false
			end if
			
			For i=1 to sp {
				move Random(14000)+1000, Random(10000)+1000
				let  a=random(90), b=random(50)+150, c=random(50)-50*(random(10)=1)
				sprite spr$,5, a,b,c
			}
			move mouse.x, mouse.y
			sprite spr$,5,n,200
			n+=29
			refresh 1500
			if keypress(2) then exit
			p= keypress(1)
		}
	else
		Set Fast !
		every 1000/r {
			release
			if p then 
			move mouse.x, mouse.y
			sprite ico,,n-29,200,50
			hold
			p=false
			end if
			
			For i=1 to sp {
				move Random(14000)+1000, Random(10000)+1000
				let  a=random(90), b=random(50)+150, c=random(50)-50*(random(10)=1)
				sprite ico, , a,b,c
			}
			move mouse.x, mouse.y
			sprite ico,,n,200
			n+=29
			if keypress(2) then exit
			p= keypress(1)
			refresh 1500

		}
		Set Fast
	end if
	release
	all$=""
	move 0,0
	copy scale.x, scale.y to all$
	mouse.icon show
	Refresh 30
	If Ask("Save the file","icons","Save it","No", all$)=1 then
	Menu  ' erase menu list
	files + "screen*.bmp"
	copy "screen"+str$(menuitems+1,"000")+".bmp"
	End if
	cls,0
	
	\\ In console M2000 has no events, except for this:,  an old variant of Menu can get the finish event in a global menu.
	\\ so giving the globalmenu Menu statement open the menu end leave it there to be used in a loop or something.
	Menu
	Menu title "MOVE ME" 
	Menu fill #F377FF, 7, 0
	files + "screen*.bmp"
	if menuitems=0 then exit
	global ex=false, loadnow=0
	Module Global globalmenu {
	\\ unhide this to exit menu if get a double click
	\\	ex<=true  \\ we can use this to exit on double click or enter.
		if menu=0 then ex<=true : Print "You press Esc" else loadnow<=menu
	}
	Print @(0,0), "Select Image or End:";
	Menu @ "globalmenu" !
	wait 200
	menu1=0
	do {
		wait 100
		refresh
		if keypress(2) or ex then exit
		menu1=menu
		if menu1=0 then continue
	\\ using this line we open one if double click or press enter
	Rem	if  loadnow=0 then continue
	\\using this we get response also as we move the menu caret
	 	if loadnow=0 then loadnow<=menu1
		move 0,0
		image menu$(loadnow), scale.x
		Print @(0,0), "Image:";menu$(loadnow)
		loadnow<=0
	} always
	Menu
	Escape On
}
Inline Code LibFade
function dummy1 {
	gradient 1, 5
	a$=key$
}
FadeScreen &Dummy(), 1.7
}
MODULE COMPILER {Module CompilerExample {
	Set Fast !
	Module lexical_analyzer (a$){
		lim=Len(a$)
		LineNo=1
		ColumnNo=1
		Document Output$
		Buffer Scanner as Integer*lim
		Return Scanner, 0:=a$
		offset=0
		buffer1$=""
		flag_rem=true
		Ahead=lambda Scanner (a$, offset)->{
			=false
			Try {
				// second parameter is the offset in buffer units
				// third parameter is length in bytes
				=Eval$(Scanner, offset,2*len(a$))=a$
			}
		}
		Ahead2=lambda Scanner (a$, offset)->{
			=false
			Try {
				=Eval$(Scanner, offset,2) ~ a$
			}
		}
		const nl$=chr$(13)+chr$(10), quo$="""", er$="@", Ansi=3
		Try {
			Do
			If Ahead("/*", offset) Then {
				offset+=2 : ColumnNo+=2
				While not Ahead("*/", offset)
					If Ahead(nl$, offset) Then
						lineNo++: ColumnNo=1 : offset+=2
					Else
						offset++ : ColumnNo++
					End If
					if offset>lim then
						Error "End-of-file in comment. Closing comment characters not found"+er$
					End if
				End While
				offset+=2 : ColumnNo+=2
			} Else.if Ahead(nl$, offset) Then{
				LineNo++: ColumnNo=1
				offset+=2
			} Else.if Ahead(quo$, offset) Then {
				Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				strin=offset
				While not Ahead(quo$, offset)
					If Ahead("/", offset) Then
						offset+=2 : ColumnNo+=2
					else
						offset++ : ColumnNo++
					End if
					checkerror()
				End While
				Output$="String "+quote$(Eval$(Scanner, strin, (offset-strin)*2))+nl$
				offset++ : ColumnNo++
			} Else.if Ahead("'", offset) Then {
				Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				strin=offset
				While not Ahead("'", offset)
					If Ahead("/", offset) Then
						offset+=2 : ColumnNo+=2
					else
						offset++ : ColumnNo++
					End if
					checkerror()
				End While
				lit$=format$(Eval$(Scanner, strin, (offset-strin)*2))
				select case len(lit$)
				case 1
					Output$="Integer "+str$(asc(lit$),0)+nl$
				case >1
					{Error "Multi-character constant."+er$}
				case 0
					{Error "Empty character constant."+er$}
				end select
				offset++ : ColumnNo++
			} Else.if Ahead2("[a-z]", offset) Then {
				strin=offset
				Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				While Ahead2("[a-zA-Z0-9_]", offset)
					offset++ : ColumnNo++
				End While
				Keywords(Eval$(Scanner, strin, (offset-strin)*2))
			} Else.if Ahead2("[0-9]", offset) Then {
				strin=offset
				Output$=format$("{0::-10}{1::-10} Integer ", LineNo, ColumnNo)
				offset++ : ColumnNo++
				While Ahead2("[0-9]", offset)
					offset++ : ColumnNo++
				End While
				if Ahead2("[a-zA-Z_]", offset) then  
					{Error " Invalid number. Starts like a number, but ends in non-numeric characters."+er$}
				else
					Output$=Eval$(Scanner, strin, (offset-strin)*2)+nl$
				end if
			} Else {
				Symbols(Eval$(Scanner, Offset, 2))	      
				offset++ : ColumnNo++
			}
			Until offset>=lim
		}
		er1$=leftpart$(error$,er$)
		if er1$<>"" then
			Print
			Report "Error:"+er1$
			Output$="(Error)"+nl$+"Error:"+er1$
		else
			Output$=format$("{0::-10}{1::-10}", LineNo, ColumnNo)+" End_of_Input"+nl$
		end if
		Push Output$
		Exit
		Clipboard Output$
		Save.Doc Output$, "lex.t", Ansi
		document lex$
		Load.Doc lex$,"lex.t", Ansi
		Report lex$
 
		Sub Keywords(a$)
			select case a$
			case "if"
				a$="Keyword_if"
			case "else"
				a$="Keyword_else"
			case "while"
				a$="Keyword_while"
			case "print"
				a$="Keyword_print"
			case "putc"
				a$="Keyword_putc"
			else case
				a$="Identifier "+a$
			end select
			Output$=a$+nl$
		End sub
		Sub Symbols(a$)
			select case a$
			case " ", chr$(9)
				a$=""
			case "("
				a$="LeftParen"
			case ")"
				a$="RightParen"
			case "{"
				a$="LeftBrace"
			case "}"
				a$="RightBrace"
			case ";"
				a$="Semicolon"
			case ","
				a$="Comma"
			case "*"
				a$="Op_multiply"
			case "/"
				a$="Op_divide"
			case "+"
				a$="Op_add"
			case "-"
				a$="Op_subtract"
			case "%"
				a$="Op_mod"
			case "<"
			{	if Ahead("=", offset+1) Then
					offset++
					a$="Op_lessequal"
					ColumnNo++
				else
					a$="Op_less"
				end if
			}
			case ">"
			{	if Ahead("=", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_greaterequal"
				else
					a$="Op_greater"
				end if
			}
			case "="
			{	if Ahead("=", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_equal"
				else
					a$="Op_assign"
				end if
			}
			case "!"
			{	if Ahead("=", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_notequal"
				else
					a$="Op_not"
				end if
			}
			case "&"
			{	if Ahead("&", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_and"
				else
					a$=""
				end if
			}
			case "|"
			{	if Ahead("|", offset+1) Then
					offset++
					ColumnNo++
					a$="Op_or"
				else
					a$=""
				end if
			}
			else case
				{Error "Unrecognized character."+er$}
			end select
			if a$<>"" then
			Output$=format$("{0::-10}{1::-10} ", LineNo, ColumnNo)+a$+nl$
			end if
		End Sub
		Sub checkerror()
			if offset>lim then {
				Error "End-of-line while scanning string literal. Closing string character not found before end-of-line."+er$
			} else.if  Ahead(nl$,offset) then {
				Error "End-of-file while scanning string literal. Closing string character not found."+er$
			}
		End Sub
	}
	Module syntax_analyzer (b$){
		enum tokens {
			Op_add, Op_subtract, Op_not=5, Op_multiply=10, Op_divide, Op_mod, 
			Op_negate,  Op_less, Op_lessequal, Op_greater, Op_greaterequal,
			Op_equal, Op_notequal, Op_and, Op_or, Op_assign=100, Keyword_if=110,
			Keyword_else, Keyword_while, Keyword_print, Keyword_putc, LeftParen, RightParen,
			LeftBrace, RightBrace, Semicolon, Comma, Identifier, Integer, String, End_of_input
		}
 
		Inventory precedence=Op_multiply:=13, Op_divide:=13, Op_mod:=13, Op_add:=12, Op_subtract:=12
		Append  precedence, Op_negate:=14, Op_not:=14, Op_less:=10, Op_lessequal:=10, Op_greater:=10 
		Append  precedence, Op_greaterequal:=10, Op_equal:=9, Op_notequal:=9, Op_assign:=-1, Op_and:=5
		Append  precedence, Op_or:=4
 
		Inventory symbols=Op_multiply:="Multiply", Op_divide:="Divide", Op_mod:="Mod", Op_add:="Add"
		Append  symbols, Op_negate:="Negate", Op_not:="Not", Op_less:="Less", Op_subtract:="Subtract"
		Append  symbols, Op_lessequal:="LessEqual", Op_greater:="Greater", Op_greaterequal:="GreaterEqual"
		Append  symbols, Op_equal:="Equal", Op_notequal:="NotEqual",  Op_and:="And", Op_or:="Or" 
 
		def lineNo, ColumnNo, m, line$, a, lim, cur=-1
		const nl$=chr$(13)+chr$(10), Ansi=3
		Dim lex$()
		lex$()=piece$(b$,chr$(13)+chr$(10)) 
		lim=dimension(lex$(),1)-1
		op=End_of_input
		flush
		k=0
		Try {
			push (,)   ' Null
			getone(&op)
			repeat
			stmt(&op)
			shift 2  ' swap two top items
			push ("Sequence", array, array)
			k++
			until op=End_of_Input
		}
		er$=error$
		if er$<>"" then print er$ : flush: break
		Print "Ast"
		Document Output$
		prt_ast()
		Push Output$
		exit
		clipboard Output$
		Save.Doc Output$, "parse.t", Ansi
		document parse$
		Load.Doc parse$,"parse.t", Ansi
		Report parse$
 
		sub prt_ast(t)
			if len(t)<1 then
				Output$=";"+nl$
			else.if len(t)=3 then
				Output$=t#val$(0) +nl$
				prt_ast(t#val(1)) : prt_ast(t#val(2))
			else
				Output$=t#val$(0) +nl$
			end if
		end sub
		sub expr(p)   ' only a number
			local x=(,), prev=op
			if  op>=Identifier then
				x=(line$,)
				getone(&op)
			else.if op=LeftParen then
				paren_exp()
				x=array
			else.if op<10 then
				getone(&op)
				expr(precedence(int(Op_negate)))
				read local y
				if prev=Op_add then
					x=y
				else
					if prev=Op_subtract then prev=Op_negate
					x=(symbols(prev), y,(,))
				End if
			else
				 {error "??? "+eval$(op)}
			end if
			local prec
			while exist(precedence, int(op))
				prev=op : prec=eval(precedence)
				if prec<14 and prec>=p else exit
				getone(&op)
				expr(prec+1)  ' all operators are left associative (use prec for right a.)
				x=(symbols(int(prev)), x, array)
			End While
			Push x
		end sub
		sub paren_exp()
			expected(LeftParen)
			getone(&op)
			expr(0)
			expected(RightParen)
			getone(&op)
		end sub
		sub stmt(&op)
			local t=(,)
			if op=Identifier then
				t=(line$)
				getone(&op)
				expected(Op_assign)
				getone(&op) 
				expr(0)
				read local rightnode
				Push ("Assign",t,rightnode)
				expected(Semicolon)
				getone(&op)
			else.if op=Semicolon then
				getone(&op)
				Push (";",)
			else.if op=Keyword_print then
				getone(&op)
				expected(LeftParen)
				repeat
					getone(&op)
					if op=String then
						Push ("Prts",(line$,),(,))
						getone(&op)
					else
						expr(0)
						Push ("Prti", array,(,))
					end if
					t=("Sequence", t, array)
				until op<>Comma
				expected(RightParen)
				getone(&op)
				expected(Semicolon)
				getone(&op)
				push t
			else.if op=Keyword_while then
				getone(&op)
				paren_exp()
				stmt(&op)
				shift 2
				Push ("While",array, array)
			else.if op=Keyword_if then
				getone(&op)
				paren_exp()
				stmt(&op)
				local s2=(,)
				if op=Keyword_else then
					getone(&op)
					stmt(&op)
					read s2
				end if
				shift 2
				Push ("If",array ,("If",array,s2))
			else.if op=Keyword_putc then
				getone(&op)
				paren_exp()
				Push ("Prtc",array,t)
				expected(Semicolon)
				getone(&op)
			else.if op=LeftBrace then
				Brace()
			else
				error "Unkown Op"
			end if
		end sub
		Sub Brace()
				getone(&op)
				while op<>RightBrace and op<>End_of_input
					stmt(&op)
					t=("Sequence", t, array)
				end while
				expected(RightBrace)
				getone(&op)
				push t
		End Sub
		Sub expected(what)
			if not op=what then {Error "Expected "+eval$(what)+str$(LineNo)+","+Str$(ColumnNo)}
		End Sub
		sub getone(&op)
			op=End_of_input
			while cur<lim
			cur++
			line$=trim$(lex$(cur))
			if line$<>"" then exit
			end while
			if cur=lim then exit sub
			LineNo=Val(line$,"int",m)
			line$=mid$(line$, m)
			ColumnNo=Val(line$,"int",m)
			line$=trim$(mid$(line$, m))
			Rem : Print LineNo, ColumnNo
			m=instr(line$," ")
			if m>0 then op=Eval("."+leftpart$(line$, " ")) else op=Eval("."+line$)
		end sub
	}
	Module CodeGenerator (s$){
		Function code$(op$) {
			=format$("{0::-6} {1}", pc, op$)
			pc++
		}
		Function code2$(op$, n$) {
			=format$("{0::-6} {1} {2}", pc, op$, n$)
			pc+=5
		}
		Function code3$(op$,pc, st, ed) {
			=format$("{0::-6} {1} ({2}) {3}", pc, op$, ed-st-1, ed)
		}
 
		Enum tok {
			gneg, gnot, gmul, gdiv, gmod, gadd, gle, gsub, glt
			gle, ggt, gge, geq, gne, gand, gor, gprtc, gprti, gprts,
			gif, gwhile, gAssign, gSeq, gstring, gidentifier, gint, gnone
		}
 
		// Inventories are lists with keys, or keys/data (key must be unique)
		// there is one type more the Invetory Queue which get same keys.
		// But here not used.
		Inventory symb="Multiply":=gmul, "Divide":=gdiv, "Mod":=gmod, "Add":=gadd
		Append  symb, "Negate":=gneg, "Not":=gnot,"Less":=glt,"Subtract":=gsub
		Append  symb, "LessEqual":=gle, "Greater":=ggt, "GreaterEqual":=gge, "Sequence":=gSeq
		Append  symb, "Equal":=geq, "NotEqual":=gne,  "And":=gand, "Or":=gor, "While":=gwhile
		Append  symb, "Prtc":=gprtc,"Prti":=gprti,"Prts":=gprts, "Assign":=gAssign, "If":=gif
		Append  symb, "String":=gstring, "Identifier":=gidentifier, "Integer":=gint, ";", gnone
 
		Inventory DataSet
		// We set string as key. key maybe an empty string, a string or a number.
		// so we want eash string to saved one time only.
		Inventory Strings
 
		Const nl$=chr$(13)+chr$(10), Ansi=3
		Def z$, lim, line$, newvar_ok, i=0
		Document message$=nl$
		Global pc     // functions have own scope, so we make it global, for this module, and childs.
 
		Dim lines$()
		s$=filter$(s$,chr$(9))   // exclude tabs
		Lines$()=piece$(s$,nl$) // break to lines
		lim=len(Lines$())
		Flush ' empty stack (there is a current stack of values which we use here)
 
		Load_Ast()
		If not stack.size=1 Then Flush : Error "Ast not loaded"
		AST=array   // pop the array from stack
		Document Assembly$, Header$
 
		// all lines of assembly goes to stack. Maybe not in right order.
		// Push statement push to top, Data statement push to bottom of stack
 
		CodeGenerator(Ast)
		Data  code$("halt") ' append to end of stack
		// So now we get all data (letters) from stack
		While not empty
			Assembly$=letter$+nl$
		end while
		// So now we have to place them in order
		Sort Assembly$
 
		// Let's make the header
		Header$=format$("Datasize: {0} Strings: {1}", Len(Dataset),Len(strings))
		// we use an iterator object, str^ is the counter, readonly, but Eval$() use it from object.
		str=each(strings)    
		While str
			Header$=nl$+Eval$(str)
		End while
		Assembly$=nl$
		// insert to line 1 the Header
		Insert 1 Assembly$=Header$
		// Also we check for warnings
		If len(message$)>2 then Assembly$="Warnings: "+nl$+message$
		// So now we get a report
		// (at each 3/4 of window's lines, the printing stop and wait for user response, any key)
		Push Assembly$
		Exit
		Report Assembly$
		Clipboard Assembly$
		Save.Doc Assembly$, "code.t", Ansi
		End
		// subs have 10000 limit for recursion but can be extended to 1000000 or more.
		Sub CodeGenerator(t)
 
			If len(t)=3 then
				select case  t#val(0)
				Case gSeq
					CodeGenerator(t#val(1)) : CodeGenerator(t#val(2))
				Case gwhile
				{
					local spc=pc
					CodeGenerator(t#val(1)) 
					local pc1=pc
					pc+=5 ' room for jz
					CodeGenerator(t#val(2))
					data code3$("jz",pc1, pc1, pc+5)
					data code3$("jmp",pc,  pc, spc)
					pc+=5  ' room for jmp
				}
				Case gif
				{
					CodeGenerator(t#val(1)) 
					local pc1=pc, pc2
					pc+=5
					CodeGenerator(t#val(2)#val(1)) 
					If len(t#val(2)#val(2))>0 then
						pc2=pc
						pc+=5
						data code3$("jz",pc1, pc1, pc)
						CodeGenerator(t#val(2)#val(2))
						data code3$("jmp",pc2, pc2, pc)
					else
						data code3$("jz",pc1, pc1, pc)
					end If	  
				}
				Case gAssign
				{
					CodeGenerator(t#val(2))
					local newvar_ok=true
					CodeGenerator(t#val(1))
				}
				case gneg to gnot, gprtc to gprts
					CodeGenerator(t#val(1)) : data code$(mid$(eval$(t#val(0)),2))
				case gmul to gor
				{
					CodeGenerator(t#val(1))
					CodeGenerator(t#val(2))
					data code$(mid$(eval$(t#val(0)),2))
				}
				End select
			Else.if len(t)=2 then
				select case  t#val(0)
				Case gString
				{
					local spos
					If exist(strings,t#val$(1)) then
						spos=eval(strings!)
					else
						append strings, t#val$(1)	       
						spos=len(strings)-1
					end If
					Push code2$("push",str$(spos,0))
				}
				Case gInt
					Push code2$("push",t#val$(1), pc)
				Case gIdentifier
				{
					local ipos
					If exist(dataset,t#val$(1)) then
						ipos=Eval(dataset!)  ' return position
					else.if newvar_ok then
						Append dataset, t#val$(1)
						ipos=len(dataset)-1
					else
						message$="Variable "+t#val$(1)+" not initialized"+nl$
 
					end If
					If newvar_ok then
						Push code2$("store","["+str$(ipos, 0)+"]")
					else
						Push code2$("fetch","["+str$(ipos, 0)+"]")
					end If
				}
				end select
			End If
		End Sub
		Sub Load_Ast()
				If i>=lim then Push (,) : exit sub
				do
				line$=Trim$(lines$(i))
				I++
				tok$=piece$(line$," ")(0)
				until line$<>"" or i>=lim
				If tok$="Identifier" then
					Push (gidentifier,trim$(Mid$(line$,11)))
				else.if tok$="Integer" then
					long n=Val(Mid$(line$,8))  ' check overflow
					Push (gint, Trim$(Mid$(line$,8)))
				else.if tok$="String" then
					Push (gstring,Trim$(Mid$(line$,7)))
				else.if tok$=";" then
					Push (,)
				Else
					local otok=symb(tok$)
					Load_Ast() 
					Load_Ast()
					Shift 2
					Push (otok,array, array)
				End If
		End Sub
	}
	Module Virtual_Machine_Interpreter (a$){
		// function to extract string, replacing escape codes.
		Function GetString$(a$) {
			s=instr(a$, chr$(34))
			m=rinstr(a$,chr$(34))-s
			if m>1 then
				// process escape codes
				=format$(mid$(a$, s+1, m-1))
			else
				=""
			end if
		}
 		const nl$=chr$(13)+chr$(10)
		// we can set starting value to any number  n where 0<=n<=232
		enum op {	halt_=232, add_, sub_, mul_, div_, mod_, not_, neg_, and_, or_, lt_,
			    	gt_, le_, ge_, ne_, eq_, prts_, prti_, prtc_, store_, fetch_, push_,
				jmp_, jz_
	    	}
	     	exit_now=false
		Inventory  func=halt_:=lambda->{exit_now=true}
		Append  func, push_:=lambda->{sp--:return stack_, sp:=eval(code_, pc as long):pc+=4}
		Append  func, jz_:=lambda->{
			sp++: if eval(stack_, sp-1)=0 then pc=eval(code_, pc as long) else pc+=4
		}
		Append  func, jmp_:=lambda->{pc=eval(code_, pc as long)}
		Append  func, fetch_:=lambda->{sp--:Return stack_, sp:=eval(stack_, eval(code_, pc as long)):pc+=4}
		Append  func, store_:=lambda->{Return stack_, eval(code_, pc as long):=eval(stack_, sp):sp++:pc+=4}
		Append  func, add_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))+sint(eval(stack_, sp))):sp++}
		Append  func, sub_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))-sint(eval(stack_, sp))):sp++}
		Append  func, mul_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1))*sint(eval(stack_, sp))):sp++}
		Append  func, div_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1)) div sint(eval(stack_, sp))):sp++}
		Append  func, mod_:=lambda->{Return stack_, sp+1:=uint(sint(eval(stack_, sp+1)) mod sint(eval(stack_, sp))) :sp++}
		Append  func, not_:=lambda->{Return stack_, sp:=if(eval(stack_, sp)=0->uint(-1),0)}
		Append  func, neg_:=lambda->{Return stack_, sp:=uint(-sint(eval(stack_, sp)))}
		Append  func, and_:=lambda->{Return stack_, sp+1:=binary.and(eval(stack_, sp+1),eval(stack_, sp)):sp++	}
		Append  func, or_:=lambda->{Return stack_, sp+1:=binary.or(eval(stack_, sp+1),eval(stack_, sp)):sp++	}
		Append  func, lt_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))<sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, gt_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))>sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, le_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))<=sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, ge_:=lambda->{Return stack_, sp+1:=uint(if(sint(eval(stack_, sp+1))>=sint(eval(stack_, sp))->-1, 0)):sp++}
		Append  func, ne_:=lambda->{Return stack_, sp+1:=uint(if(eval(stack_, sp+1)<>eval(stack_, sp)->-1, 0)):sp++}
		Append  func, eq_:=lambda->{Return stack_, sp+1:=uint(if(eval(stack_, sp+1)=eval(stack_, sp)->-1, 0)):sp++}
		Append  func, prts_:=lambda->{Print #-2, strings$(eval(stack_,sp));: Refresh:sp++}
		Append  func, prti_:=lambda->{Print #-2, str$(sint(eval(stack_,sp)),0);: Refresh:sp++}
		Append  func, prtc_:=lambda->{Print #-2, chrcode$(eval(stack_,sp));: Refresh:sp++}
		Rem : Form 120, 60 ' change console width X height to run Ascii Mandlebrot example
		// change Report with Print #-2,   (report stop when scrolling 3/4 of height of console, waiting key or mouse key to continue)
		Print #-2,  "Virtual Assembly Code:"+{
		}+a$
		Print "Prepare Byte Code"
 
		// get datasize
		a$=rightpart$(a$, "Datasize:")
		m=0
		data_size=val(a$, "int", m)
		a$=mid$(a$, m)
		// make stack
		if data_size>0 then Buffer Clear stack_ as long*data_size
		// dim or redim buffer append 1000 long as is.
		Buffer stack_ as long*(1000+data_size)
		// get strings
		a$=rightpart$(a$, "Strings:")
		m=0
		strings=val(a$, "int", m)
		a$=rightpart$(a$, nl$)
 
		if strings>0 then
			Dim strings$(strings)
			for i=0 to strings-1
				strings$(i)=GetString$(leftpart$(a$, nl$))
				a$=rightpart$(a$, nl$)
			Next i
		End if
		buffer clear code_ as byte*1000
		do
			m=0
			offset=val(a$,"int", m)
			if m<0 then exit
			a$=mid$(a$,m)
			line$=trim$(leftpart$(a$,nl$))
			if line$="" then line$=trim$(a$) else a$=trim$(rightpart$(a$, nl$))
			op$=if$(instr(line$," ")>0->leftpart$(line$," "), line$)
			if not valid(eval(op$+"_")) then exit
			opc=eval(op$+"_")
			Return code_, offset:=opc
			if opc>=store_ then
				line$=rightpart$(line$," ")
				select case opc
				case store_, fetch_
					Return code_, offset+1:=val(rightpart$(leftpart$(line$,"]"),"[")) as long : offset+=4
				case push_
					Return code_, offset+1:=uint(val(line$)) as long : offset+=4
				case jz_, jmp_
					Return code_, offset+1:=val(rightpart$(line$,")")) as long : offset+=4
				end select 
			end if
		Always
		Print "Press any key" : Push key$ : Drop
		// Prepare VM
		let pc=0, sp=len(stack_) div 4
		do
			b=func(eval(code_, pc))
			pc++
			call local b()
		until exit_now
		Print "done"
	}
	Push {
	{
		/*
		This is an integer ascii Mandelbrot generator
		*/
		left_edge= -420;
		right_edge=300;
		top_edge=300;
		bottom_edge = -300;
		x_step=7;
		y_step=15;
 
		max_iter=200;
 
		y0 = top_edge;
		while (y0 > bottom_edge) {
			x0 = left_edge;
			while (x0 < right_edge) {
				y = 0;
				x = 0;
				the_char = ' ';
				i = 0;
				while (i < max_iter) {
					x_x = (x * x) / 200;
					y_y = (y * y) / 200;
					if (x_x + y_y > 800 ) {
						the_char = '0' + i;
						if (i > 9) {
							the_char = '@';
						}
						i = max_iter;
					}
					y = x * y / 100 + y0;
					x = x_x - y_y + x0;
					i = i + 1;
				}
				putc(the_char);
				x0 = x0 + x_step;
			}
			putc('\n');
			y0 = y0 - y_step;
		}
	}
	} 
 
	Form ! 120, 60
	Refresh
	Print "Lexical Analyzer" : Refresh
	lexical_analyzer
	Print "Syntax Analyzer" : Refresh
	syntax_analyzer
	Print "Code Generator" : Refresh
	CodeGenerator
	Virtual_Machine_Interpreter
	Set Fast 'restore speed setting
}
CompilerExample

}
MODULE CC {move scale.x/2, scale.y/2
legend "This is centered", "Arial", 22,pi/6,2 , 0
}
MODULE FADE {If not match("NN") then
	Print "Missing two numbers as colors"
	Exit
End If
Read X, Y
Module FadeScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.3 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      Call Paint()
      Hold
      Repeat {
            Release
            sprite Img1,,,,i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo
      } until i<1
}
Function PaintBack {
      Gradient X, Y
}

FadeScreen Lazy$(&PaintBack()), 1.7

}
MODULE LIBFADE {Module FadeScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.3 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      t$=""
      oldrow=row      
      Call Paint()
      move scale.x/2, scale.y/2
      Hold
      Repeat {
            Release
            sprite Img1,1,,,101-i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo
      } until i<1
      sprite img1
      cls ,oldrow-1
      scroll split 0  ' no split
      
}
Module FadeInScreen (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.2 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      refresh 200
      i=100
      Call Paint()
      move scale.x/2, scale.y/2
      Hold
      Repeat {
            Release
            sprite Img1,,,,i-1,1
            refresh 100
            wait (100-i) div 40
            i-=i / tempo/2
      } until i<1
}
Module FadeInScreen2 (&Paint(), tempo) {
      tempo=abs(tempo)
      move 0,0 
      if tempo==0 or tempo<1.2 then tempo=2
      Function GetBack2Buffer  {
            def b$
            def pic(x)=(x div twipsx)*twipsx
            copy pic(scale.x), pic(scale.y) to b$
            move pic(scale.x) div 2, pic(scale.y) div 2
            =image(b$)  ' return Buffer
      }
      Img1=GetBack2Buffer()
      release
      refresh 2000
      i=400
      Repeat {
            Call Paint()
            move scale.x/2, scale.y/2
            sprite Img1,,,,min.data(i-1,100),1
            refresh 1000
            wait (100-i) div 40
            i-=i / tempo/4
      } until i<1
}
}
MODULE PP {function dummy {
	ro=row
	p
	cls 5, row-1
	Pen 14
}
Inline Code LibFade
FadeScreen &Dummy(), 1.7
Set Fast
}
MODULE COMP {\\ compose lambda functions
\\ We can put closures (as copy of values, or copy of pointers if a variable is a pointer)

\\ In M2000, there are: Values, Pointers, Refereneces.  Pointers hold Objects. Values maybe objects too. References are just names with no own value or poiner, but refer to another variable
\\ We can use reference to array items, with an internal copy in copy out, method. First interpreter make a hidden variable, copy the item to that variable, then pass the variable to function or module by reference, and at return copy back the variable to the array item (checking if it can be done, maybe the array has change). We can't pass values to references, except of a string. A reference passed as week reference, a string with the a proper name for the variable, to stack of values (as a value), so a Read statement which has & before a name, search for a string, and then resolve it or not. If not raise error. We can read the string (the weakr reference) and read it any other time (a copy of it), if we know that this variable exist. Also there are "string pointer"\\Arrays can passed by reference without copy in copy out (by using a weak reference too)

X=10
k$=weak$(x)
k$.++
Print Eval(k$.)=11
Print x=11
Dim a(10)=100
k$=Weak$(a(5))
k$.++
Print Eval(k$.)=101
Print a(5)=101

Module ByRefArrItemOrVariable(&x) {
	x++
}
ByRefArrItemOrVariable &a(5)
Print a(5)=102
\\ we can add space between name and parameter list
Module ByRefArray1 (&b()) {
	b(5)++
}

ByRefArray1 &a()
Print a(5)=103


\\ we can send the pointer (array is an object)
\\ Interpreter know that we wish to use the pointer, because we choose a name without parenthesis

Module ByRefArray2 (b) {
	Return b, 5:=Array(b,5)+1
	link  b to a()
	a(5)++
}

ByRefArray2 a()
Print a(5)=105

Function ByCopyArray(b()) {
	For i=Dimension(b(), 1,0) to Dimension(b(), 1,1)
		b(i)+=1
	Next i
	=b()
}
Print Dimension(a(), 1,0), Dimension(a(), 1,1)
Dim z()
z()=ByCopyArray(a())
Print z()

\\ We can pass an expression for late evalution:
x=10 
z=3
Module DoSomething(&s()) {
	Print s()
}
DoSomething Lazy$(x**z)   'return 1000
function dummy {
	x++
	=x**z
}
DoSomething Lazy$(&dummy())   'return 1331

function dummy2 {
	Read New k
	x++
	=x**z+k
}
a$=Lazy$(&dummy2())   'return 1331
\\ so now expression is function body in a$
\\ Unremark this to see the definition of function
Rem : Report a$
Module DoSomething2(&s()) {
	Print s(100)
}
DoSomething2 a$
Print Function(a$, 200)


\\ Normally a function can be passed by reference
\\ the reference is the actual code
Def OneLine(X)=X**2+5*x+6
DoSomething2 &OnelIne()    ' 10506
\\ for groups including the reference of group
Group {
	x=100
	Function InGroup {		
	}
	
}

Module CheckFirst {
      RAD = lambda -> number/180*pi
      ASIN = lambda RAD -> {
          Read x : x=Round(x,10)
            If x>=0 and X<1 Then {
                  =RAD(abs(2*Round(ATN(x/(1+SQRT(1-x**2))))))
            } Else.if x==1 Then {
                  =RAD(90)
            } Else error "asin exit limit"
      }
      ACOS=lambda ASIN (x) -> PI/2 - ASIN(x)
      POW3 = Lambda ->number**3
      POW3INV =Lambda ->number**(1/3)
      COSRAD =lambda ->Cos(number*180/pi)
      SINRAD=lambda ->Sin(number*180/pi)
      Composed=lambda (f1, f2) -> {
            =lambda f1, f2 (x)->{
                  =f1(f2(x))
            }
      }
      Dim Base 0, A(3), B(3), C(3)
      A(0)=ACOS, ASIN, POW3INV
      B(0)=COSRAD, SINRAD, POW3
      C(0)=Composed(ACOS, COSRAD), Composed(ASIN, SINRAD), Composed(POW3INV, POW3)
      Print $("0.00")
      For i=0 To 2 {
            Print A(i)(B(i)(.5)), C(i)(.5)
      }
            Print $("")
}
CheckFirst
 
}
MODULE COMP2 {Report {in this example we pass an array A() to function b()
	but instead we have a c() or something we have m so interpreter pass the pointer of array
	we link the pointer to c() so we can use c() as a by reference (but by pointer) pass
		
		Dim A(10)=1000, Z()
		Function b(m) {
			link m to c()
			c(3)=10
			=m
		}
		Z()=b(A())
		Print Z(3), A(3)	
	
	}

Dim A(10)=1000, Z()
Function b(m) {
	link m to c()
	c(3)=10
	=m
}
Z()=b(A())
Print Z(3), A(3)
Report {
	Z() is a copy because this array interface works as a variable, we assign a new value always
	
		Z(3)++
		Print Z(3)<>A(3)
	
	}
Z(3)++
Print Z(3)<>A(3)

Report {We do the same for passing by reference. We can redefine b() at run time. When we return the c() only a pointer returned. The Z() get a copy of array from that pointer.
		
		Function b(&c()) {
			c(3)=100
			=c()
		}
		
		Z()=b(&A())
		Print Z(3), A(3)
		Z(3)++
		Print Z(3)<>A(3)
	}
Function b(&c()) {
	c(3)=100
	=c()
}

Z()=b(&A())
Print Z(3), A(3)
Z(3)++
Print Z(3)<>A(3)
Report {
	Now we do some magic. We make an empty array and put a pointer of it to m. Next we make a reference to m in Z1(). We can't change in Z1() the reference. But reference is not a pointer. Z1() reference to the place which m save the pointer. In fact the interpreter see both identifiers to share common memory for the pointer to array. Now we call the b()
		
		m=(,)
		Link m to Z1()
		m=b(&A())
		Print Z1(3), A(3)
		Z1(3)+=100
		Print Z1(3)<>A(3)
	
	}
m=(,)
Link m to Z1()
m=b(&A())
Print Z1(3), A(3)
Z1(3)+=100
Print Z1(3)<>A(3)
Report {
	 So we get false, because we get a pointer from C() which points to A(), and m now point to A() and Z1()  is a reference of m, so a reference of A(). We can check the objects using IS.
	
		Print Z1() is A(), Z() is A() 
		Print m is A() 
	
	}
Print Z1() is A(), Z() is A()  ' true false
Print m is A()  ' true
}
MODULE CL {Class zz {
      module bb {
            Superclass A {
                  unique:
                  counter
            }
            Superclass B1 {
                  unique:
                  counter
            }
            Superclass B2 {
                  unique:
                  counter
            }
            \\ We can make a group Alfa with a member, another group Beta
            \\ Group Beta can't see parent group, but can see own member groups
            \\ Group Alfa can see everything in nested groups, in any level,
            \\ but can't see inside modules/functions/operator/value/set
            Group Alfa {
                  Group Beta { }
            }
            Alfa=A
            Alfa.Beta=B1
            \\ we make 3 groups for marshaling counters
            \\ each group get a superclass
            Marshal1=A
            Marshal2=B1
            Marshal3=B2
            \\ Now we want to add functionality7
            \\ Inc module to add 1 to counter
            \\ a Value function to return counter
            \\ Without Value a group return a copy
            \\ If a group has a value then we can get copy using Group(nameofgroup)
            \\ just delete Group Marshal1 and remove Rem when we make Marshal1 using a class function
            Group Marshal1 {
                  Module Inc {
                        For SuperClass {.counter++}
                  }
                  Value {
                        For SuperClass {=.counter}
                  }
            }
            Class AnyMarshal {
                  Module Inc {
                        For SuperClass {.counter++}
                  }
                  Value {
                        For SuperClass {=.counter}
                  }
            }
            \\ here we merge groups
            Rem : Marshal1=AnyMarshal()
            Marshal2=AnyMarshal()
            Marshal3=AnyMarshal()
 
            \\ So now we see counters (three zero)
            Print Marshal1, Marshal2, Marshal3 \\ 0, 0, 0
            \\ Now we prepare Alfa and Alfa.Beta groups
            Group Alfa {
                  Group Beta {
                        Function SuperClass.Counter {
                              For SuperClass {
                                    =.counter
                              }           
                        }      
                  }
                  Module PrintData {
                        For SuperClass {
                              Print .counter, This.Beta.SuperClass.Counter()
                        }
                  }
            }
            \\ some marshaling to counters
            Marshal1.inc
            Marshal2.inc
            Marshal2.inc
            Marshal3.inc
            \\ lets print results
            Print Marshal1, Marshal2, Marshal3 \\ 1   2   1
            \\ Calling Alfa.PrintData
            Alfa.PrintData  \\ 1   2
            \\ Merging a group in a group make a change to superclass pointer inside group
            Alfa.Beta=B2 \\ change supeclass
            Alfa.PrintData  \\ 1   1
            For i=1 to 10 : Marshal3.inc : Next i
            Alfa.PrintData  \\ 1   11
            Alfa.Beta=B1 \\ change supeclass
            Alfa.PrintData  \\ 1   2
            Epsilon=Alfa
            Print Valid(@alfa as epsilon), Valid(@alfa.beta as epsilon.beta) \\ -1   -1
            Epsilon.PrintData \\ 1 2
            Alfa.Beta=B2 \\ change supeclass
            Alfa.PrintData  \\ 1   11
            Epsilon.PrintData \\ 1 2
            \\ validation being for top group superclass and all members if are same
            \\ but not for inner superclasses. This maybe change in later revisions of language.
            Print Valid(@alfa as epsilon), Valid(@alfa.beta as epsilon.beta) \\ -1  0
 
      }
}
Dim A(10)
A(3)=zz()
A(3).bb
}
MODULE OOP1 {// events without using Event objects
// We use weak reference to register events in eventhandler
// if A is a variable a &A is a string contain the actuall name of A, and this is a weak reference
// Normally when we do a Read &B the read instruction get the string as a name for  a variable  and check if exist as variable
// so Read make references from weak references
// M2000 has also the pointer. A pointer is different from the reference, because has nothing to do with name of entities
// For example  a=(1,2,3,4) set a as a pointer to array. Passing by value a we pass the object by a pointer.
// We can pass &a so if we change the array inside a module or funcion, then we get the change back
// A weak reference can be stored as string, and maybe later be invalid, if the storage, an array, passed back as return value,
// or pushed to stack of values, and the module where we defined the refered entitites, terminate, and clear all own variables.

//for this example we make "static" groups (as named the user objects in M2000).
//The word static used for static variables which stay in every call of a module or function, from the same execution object.
// (perhaps a thread which is a separate execution object call a module with specific for the thread static variables)
// Here we don't use threads. We have one loop, which call one function of the EventHandler, the observe()
// if this functions return true then the loop exit, and the program terminate


//we have three classes (they are global functions, which construct groups)
// The mouseListene and the keylistener, and the EventHandler
// Inside EventListener we have one more class (this isn't global)
// The Widdget class
// This class has the state for an event, and used from button function, a member of EventHandler
// So with this EventHandler we can make buttons, with a name. The function button() return a Group
// So for the example we make three buttons to three named groups, B1, B2 and B3
// Each widget has a weak reference to EventHandler and a name, when constructed,
// but has no listeners.
// Also the listeners have to link to EventHandler, and this is the work of EventList() function
// The Eventlist() is a member of EventHandler and get a listener class, and return a handler
// To register an event we have to use register method passing the handler and the weak reference and a  button (widget)
// So buttons and handlers are entities from EventHandler
// The actual events are not part of the EventHandler. They are inside the listeners classes.
// Each listener has a contruction member (same name as the class name),
// a register member to add more widgets to same listener,
// and the  CheckEvent(), which return true if event happen.

//The EventHandler pass &this  as own weak reference to each new wigdet.
//The Listeners added to an array inside the EventHandler with a list of weak references to widgets.
//The observe() function cehck all stored listeners, calling the CheckEcent() on listener.
// if an event happen then all subscribers (all widgets) get a call in callback()  function with the name of the event
// each widget then using the weak refrence to EventHandler do a query passig an id, an iinfo string (what$) and a reference of it
// The query method (module in M2000) use id and what$ to display information, and use reference to read the caption of widget
// perhaps the caption may change, so we can't stored this in listener's list in EventHandler.

// So from observe(), pressing 1 or 2 keys or mouse key, we can call  one or more  widget's callback(),
// which all  call back the query method, which the later read the widget caption.
// B1 listen 1 and 2 keys, B2 listen 1 key, B3 listen a mouse key (right key)



Module OOP {
	Set Fast
	cls 1, 0
	pen 14
	report 2, "Event Listener"
	report "Use keys 1, 2 and mouse left, and for exit mouse right"
	cls, 2
	class mouselistener {
	      name$="MousePress",  yourkey,  auto
	      dim ref$()
	      module mouselistener {
	            read .yourkey
	            .name$<=format$("{0}({1})",.name$,.yourkey)
	      }
	      module register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   // weak reference
	      }
	      function CheckEvent {
	            =Mouse=.yourkey
	      }
	}
	class keylistener {
	      name$="KeyPress", yourkey, auto
	      dim ref$()
	      module keylistener {
	            read .yourkey
	            .name$<=format$("{0}({1})",.name$,.yourkey)
	      }
	      module register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   // weak reference
	      }
	      function CheckEvent {
	            =keypress(.yourkey)
	      }
	}
	class EventHandler {
	      auto, autoevents, EnableEvents
	      Dim Events()
	      class widget {
	            // in classes we can define variables without value
	            ref$  // weak reference
	            id, caption$, Enabled=True
	            module linkme {
	                  read .ref$
	            }
	            module widget {  // this is used as construction function, but is a module
	                  read .id
	                  read .caption$
	            }
	            function Callback {
	                  read some$
	                  push .ref$ : read &ref  // this is the link
	                  =ref.query(.id, some$, &this)
	            }
	      }
	      function button {    // this is the button construction
	         .auto++
	         read txt$
	         makeme =.widget(.auto,txt$)  
	         makeme.linkme &this
	         =makeme   // we make a group a floating group to export
	      }
	      function EventList {
	            handle=.autoevents  // we execute some commands..
	            .autoevents++
	            dim .Events(.autoevents)
	            read .Events(handle)   // .. and then we can read function parameter
	            =handle
	      }
	      module register {
	           read handler, ref$
	            .Events(handler).register  ref$
	      }
	     function observe {
	     if not .EnableEvents then =true : exit
	           print "observe for events"
	           for i=0 to .autoevents-1 {
	                 for .Events(i) {
	                        if  .checkevent() then {
	                              for j=0 to .auto-1 {
	                                    for this {     // we use a for this {} to make temporary variables
	                                                           // because we can't relink a link.  so we make a fresh here
	//              the link statement to this:    push  .ref$(j) : read &Link
	                                          link weak .ref$(j) to &link
	                                          call link.callback(.name$)
	                                     }
	                                }
	                        }
	                 }
	           }
	     }
	      function query {
	            read id, what$, &nicesmallgroup
	            print under "Inside EventHandler";
	            print under
	            print  part "I get a query from a widget object ";id
	            print
	            print part "Say:";what$
	            print
	            for nicesmallgroup {
	                  Print part "I get the caption:";.caption$
	                  print
	                  =0
	            }
	      }
	}
	EventHandler=EventHandler()  // create handler
	B1=EventHandler.button("Button1")  // create subjects
	B2=EventHandler.button("Button2") 
	B3=EventHandler.button("Button3") 
	
	for EventHandler {
	      PressKeyOne=.Eventlist(keylistener(49))
	      .Register  PressKeyOne, &B1  //register event to subject
	      .Register  PressKeyOne, &B2 
	      .Register .Eventlist(keylistener(50)) , &B1 
	      .Register .Eventlist(Mouselistener(1)) , &B3 
	      .EnableEvents=True  
	}
	every 150 {
	      if EventHandler.observe() then exit
	      if mouse=2 then exit
	} 
}
OOP
Keyboard "info"+chr$(13)
}
MODULE OOP1GR {
Φορμα 80,40
Οθόνη 1, 0
Πένα 14
Αναφορά 2, "Χειριστής Γεγονότων"
Αναφορά "Χρησιμοποίησε πλήκρα 1, 2 και Δείκτης (ποντίκι) Αριστερά, και για έξοδο Δείκτης Δεξιά"
Οθόνη, 2
Κλάση Υπηρεσία_Δείκτη {
Ιδιωτικό:
      αθροιστής,  το_κουμπί_μου
Δημόσιο:      
      όνομα$="Πλήκτρο_Δείκτη"
      Πίνακας αναφ$()
      Τμήμα Υπηρεσία_Δείκτη {
            Διάβασε .το_κουμπί_μου
            .όνομα$<=μορφή$("{0}({1})", .όνομα$, .το_κουμπί_μου)
      }
      Τμήμα καταχώρησε {
            .αθροιστής++
            Πίνακας .αναφ$(.αθροιστής)
            Διάβασε .αναφ$(.αθροιστής-1) 
      }
      Συνάρτηση Επιβεβαίωση {
            =Δείκτης=.το_κουμπί_μου
      }
      Συνάρτηση αθροιστής {
            =.αθροιστής-1
      }
}
Κλάση Υπηρεσία_Πλήκτρου {
Ιδιωτικό:
      αθροιστής,  το_κουμπί_μου
Δημόσιο:      
      όνομα$="Πλήκτρο",
      Πίνακας αναφ$()
      Τμήμα Υπηρεσία_Πλήκτρου {
            Διάβασε .το_κουμπί_μου
            .όνομα$<=μορφή$("{0}({1})", .όνομα$, .το_κουμπί_μου)
      }
      Τμήμα καταχώρησε {
            .αθροιστής++
            Πίνακας .αναφ$(.αθροιστής)
            Διάβασε .αναφ$(.αθροιστής-1) 
      }
      Συνάρτηση Επιβεβαίωση {
            =Πατημένο(.το_κουμπί_μου)
      }
      Συνάρτηση αθροιστής {
            =.αθροιστής-1
      }
}
Κλάση Χειριστής_Γεγονότων {
Ιδιωτικό:
      αθροιστής, αθροιστής_γεγονότων
      Πίνακας Γεγονότα()      
      Κλάση Στοιχείο_Ελέγχου {
      Ιδιωτικό:
            αναφ$, 
            αναγνωριστικό, ονομασία$, Επιτρέπεται=Αληθής
       Δημόσιο:
            Τμήμα Σύνδεσε {
                  Διάβασε .αναφ$
            }
            Τμήμα Στοιχείο_Ελέγχου { 
                  Διάβασε .αναγνωριστικό
                  Διάβασε .ονομασία$
            }
            Συνάρτηση Ονομασία$ {
                  =.ονομασία$
            }
            Συνάρτηση Κάλεσε_Πίσω {
                  Διάβασε περιγραφή$
                  Ένωσε Ισχνή .αναφ$  Στη αναφ 
                  =αναφ.Ερώτημα(.αναγνωριστικό, περιγραφή$, &Αυτό)
            }
      }
Δημόσιο:     
      Επιτρέπω_Γεγονότα 
      Συνάρτηση Στοιχείο_Πλήκτρο {   
         .αθροιστής++
         Διάβασε περιγραφή$
         φτιάξε_με =.Στοιχείο_Ελέγχου(.αθροιστής,περιγραφή$)  
         φτιάξε_με.Σύνδεσε &Αυτό
         =φτιάξε_με
      }
      Συνάρτηση Λίστα_Γεγονότων {
            χειριστής=.αθροιστής_γεγονότων 
            .αθροιστής_γεγονότων++
            Πίνακας .Γεγονότα(.αθροιστής_γεγονότων)
            Διάβασε .Γεγονότα(χειριστής)
            =χειριστής
      }
      Τμήμα καταχώρησε {
           Διάβασε χειριστής, αναφ$
            .Γεγονότα(χειριστής).καταχώρησε  αναφ$
      }
     Συνάρτηση Παρατήρησε {
     Αν Δεν .Επιτρέπω_Γεγονότα Τότε =Αληθής : Έξοδος
     Τύπωσε "Παρατηρώ για Γεγονότα"
           Για ν=0 Έως .αθροιστής_γεγονότων-1 {
                 Για .Γεγονότα(ν) {
                        Αν  .Επιβεβαίωση() Τότε {
                              Για μ=0 Έως .αθροιστής() {
                                    Για Αυτό {
                                          Ένωσε Ισχνή .αναφ$(μ) στη Σύνδεση
                                          Κάλεσε Σύνδεση.Κάλεσε_Πίσω(.όνομα$)
                                     }
                                }
                        }
                 }
           }
     }
      Συνάρτηση Ερώτημα {
            Διάβασε αναγνωριστικό, περιγραφή$, &Στοιχείο_Ελέγχου
            Τύπωσε υπό "Μέσα στο Χειριστής_Γεγονότων";
            Τύπωσε υπό
            Τύπωσε  μέρος "Έλαβα ένα ερώτημα από το Στοιχείο_Ελέγχου με αριθμό "; αναγνωριστικό
            Τύπωσε
            Τύπωσε μέρος "Λέει:"; περιγραφή$
            Τύπωσε
            Για Στοιχείο_Ελέγχου {
                  Τύπωσε μέρος "Πήρα αυτή την ονομασία:";.ονομασία$()
                  Τύπωσε
                  =0
            }          
      }
}
Χειριστής_Γεγονότων=Χειριστής_Γεγονότων()  \\ δημιουργούμε τον χειριστή
β1=Χειριστής_Γεγονότων.Στοιχείο_Πλήκτρο("Πλήκτρο 1")  \\ δημιουργούμε υποκείμενα
β2=Χειριστής_Γεγονότων.Στοιχείο_Πλήκτρο("Πλήκτρο 2") 
β3=Χειριστής_Γεγονότων.Στοιχείο_Πλήκτρο("Πλήκτρο 3") 

Για Χειριστής_Γεγονότων {
      Πάτα_πλήκτρο_ένα=.Λίστα_Γεγονότων(Υπηρεσία_Πλήκτρου(49))
      .καταχώρησε  Πάτα_πλήκτρο_ένα, ισχνη$(β1)  \\καταχώρησε γεγονός στο υποκείμενο
      .καταχώρησε  Πάτα_πλήκτρο_ένα, ισχνη$(β2)
      .καταχώρησε .Λίστα_Γεγονότων(Υπηρεσία_Πλήκτρου(50)) , ισχνή$(β1) 
      .καταχώρησε  .Λίστα_Γεγονότων(Υπηρεσία_Δείκτη(1)) , ισχνη$(β3)
      .Επιτρέπω_Γεγονότα=Αληθής  
}
Κάθε 150 {
      Αν Χειριστής_Γεγονότων.Παρατήρησε() Τότε Έξοδος
      Αν Δείκτης=2 Τότε Έξοδος
} 

}
MODULE OOP2 {\\ LIKE OOP1
\\ MOUSELISENER IS A CLASS WICH USE NOW CLASS LISTENER
\\ ANY PART AFTER CLASS: IS FOR CINSTRUCTION ONLY, AND NEVER SAVED TO FINAL OBJECT
\\ SO LISTENER CONSTRUCTOR AND MOUSELISTENER CONSTRUCTOR NOT SAVED, JUS USED ONCE
\\ THE SAME HOLD FOR KEYLISTENER



Module OOP {
	Set Fast
	cls 1, 0
	pen 14
	report 2, "Event Listener"
	report "Use keys 1, 2 and mouse left, and for exit mouse right"
	cls, 2
	class listener {
	      name$,  yourkey, auto
	      dim ref$()
	      module final register {
	            .auto++
	            dim .ref$(.auto)
	            read .ref$(.auto-1)   \\ weak reference
	      }
	      function CheckEvent {
	            =false
	      }
	class:
	      module listener {
	            read .yourkey
	            .name$<=format$("{0}({1})", letter$,.yourkey)
	      }
	}
	\\ one way is to make final before adding the listener
	class mouselistener {
                  function final CheckEvent {
                                 =Mouse=.yourkey	                        
                  }
	class:
	      module mouselistener (x) {
	            this=listener(x, "MousePress")
	      }
	}
	\\ the other way is to add definitions to a group after adding listener
	\\ also ![] add stack of the call to the next call
	\\ so we didn't use x variable
	class keylistener {
	class:
	      module keylistener {
	            a=listener(![], "KeyPress")
	            group a {
	                  function final CheckEvent {
	                        =keypress(.yourkey)
	                  }
	            }
	            this=a
	      }
	}
	class EventHandler {
	      auto, autoevents, EnableEvents
	      Dim Events()
	      class widget {
	            \\ in classes we can define variables without value
	            ref$  \\ weak reference
	            id, caption$, Enabled=True
	            module linkme {
	                  read .ref$
	            }
	            module widget {  \\ this is used as construction function, but is a module
	                  read .id
	                  read .caption$
	            }
	            function Callback {
	                  read some$
	                  push .ref$ : read &ref  \\ this is the link
	                  =ref.query(.id, some$, &this)
	            }
	      }
	      function button {    \\ this is the button construction
	         .auto++
	         read txt$
	         makeme =.widget(.auto,txt$)  
	         makeme.linkme &this
	         =makeme   \\ we make a group a floating group to export
	      }
	      function EventList {
	            handle=.autoevents  \\ we execute some commands..
	            .autoevents++
	            dim .Events(.autoevents)
	            read .Events(handle)   \\ .. and then we can read function parameter
	            =handle
	      }
	      module register {
	           read handler, ref$
	            .Events(handler).register  ref$
	      }
	     function observe {
	     if not .EnableEvents then =true : exit
	           print "observe for events"
	           for i=0 to .autoevents-1 {
	                 for .Events(i) {
	                        if  .checkevent() then {
	                              for j=0 to .auto-1 {
	                                    for this {     \\ we use a for this {} to make temporary variables
	                                                           \\ because we can't relink a link.  so we make a fresh here
	\\              the link statement to this:    push  .ref$(j) : read &Link
	                                          link weak .ref$(j) to &link
	                                          call link.callback(.name$)
	                                     }
	                                }
	                        }
	                 }
	           }
	     }
	      function query {
	            read id, what$, &nicesmallgroup
	            print under "Inside EventHandler";
	            print under
	            print  part "I get a query from a widget object ";id
	            print
	            print part "Say:";what$
	            print
	            for nicesmallgroup {
	                  Print part "I get the caption:";.caption$
	                  print
	                  =0
	            }          
	      }
	}
	EventHandler=EventHandler()  \\ create handler
	B1=EventHandler.button("Button1")  \\ create subjects
	B2=EventHandler.button("Button2") 
	B3=EventHandler.button("Button3") 
	
	for EventHandler {
	      PressKeyOne=.Eventlist(keylistener(49))
	      .Register  PressKeyOne, &B1  \\register event to subject
	      .Register  PressKeyOne, &B2 
	      .Register .Eventlist(keylistener(50)) , &B1 
	      .Register .Eventlist(Mouselistener(1)) , &B3 
	      .EnableEvents=True  
	}
	every 150 {
	      if EventHandler.observe() then exit
	      if mouse=2 then exit
	} 
}
OOP
Keyboard "info"+chr$(13)
}
MODULE EM {Module Checkit {
      ' erase stack of values, so we can add data
      Flush
      Report "Top rank per group"
      Report "Find the top   N   salaries in each department,   where   N   is provided as a parameter. "
10  Input "N%=",N%
      if N%<1 then 10
      Enum Departments {D050,D101,D190,D202}

      \\ Inventroy Department need unique keys
      Inventory Department
      \\ each item in this inventory should be an inventory too
      Class Empl {
            name$, id$, salary
            Class:
            Module Empl(.name$, .id$, .salary) {}
      }
      Data "Tyler Bennett",		"E10297", 32000, D101
      Data "John Rappl",		"E21437", 47000, D050
      Data "George Woltman",	"E00127", 53500, D101
      Data "Adam Smith",		"E63535", 18000, D202
      Data "Claire Buckman",		"E39876", 27800, D202
      Data "David McClellan",		"E04242", 41500, D101
      Data "Rich Holcomb",		"E01234", 49500, D202
      Data "Nathan Adams",		"E41298", 21900, D050
      Data "Richard Potter",		"E43128", 15900, D101
      Data "David Motsinger",	"E27002", 19250, D202
      Data "Tim Sampair",		"E03033", 27000, D101
      Data "Kim Arlich",			"E10001", 57000, D190
      Data "Timothy Grove",		"E16398", 29900, D190
      Data ""
      Read name$
      While name$<>""  {
            Read id$, salary, dep
            Rem : Print name$, id$, salary, dep
            If Exist(Department, dep) Then {
                  z=Eval(Department)    ' get pointer to inventory
                  AppendOne()            
            } Else {
                  z=queue
                  AppendDep()            
                  AppendOne()
            }
            Read name$
      }
      Sort Department as number
      i=each(Department)
      \\ make depname as type of Departments
      depname=D050
      oldtab=tab
      Print $(4),
      Print over ~(1, 7),@(10), $(4,6),"Dep." ,@(16), $(4,20), "Employee Name",$(6,8), "Emp. ID", "Salary"
      Print Under
      Print $(4),
      While i {
            \\ when we pass a number to a enum variable
            \\ if the number exist, get that enum item else raise error
            depname=val(eval$(i, i^))
            \\ z is a pointer to inventory 
            z=Eval(i)
            Sort descending z as number
            k=each(z,1,N%)
            While k {
                  Empl=Eval(k)
                  For Empl {
                        \\ eval$(depname) return the name of enum variable (like D050)
'                        Print Format$("{0:6}{1:20}{2:8}{3::-8}",Eval$(depname), .name$, .id$, .salary)
			Print Part $(4,10),"", $(4,6),~(15,2), Eval$(depname),@(16), $(4,20), ~(14), .name$,$(6, 8), ~(pen,2),.id$, ~(14),.salary
			Print under
                  }
            }
      }
      Print $(4),"Done", $(0)
      Sub AppendDep()
            Append Department, dep:=z
      End Sub
      Sub AppendOne()
                  Append z, salary:=Empl(name$, id$, salary)
      End Sub
}
Checkit 
}
MODULE TRAVERSAL {Report {
          Tree traversal
                   1
                  / \
                 /   \
                /     \
               2       3
              / \     /
             4   5   6
            /       / \
           7       8   9

} 
Pen 15 {Print "Using tuple (arrays)"}
Print
Module CheckIt {
      Null=(,)
      Tree=((((Null,7,Null),4,Null),2,(Null,5,Null)),1,(((Null,8,Null),6,(Null,9,Null)),3,Null))
      
      Module preorder (T) {
            Print "preorder:    ";
            printtree(T)
            Print
            sub printtree(T)
                  Print T#val(1);" ";      
                  If len(T#val(0))>0 then printtree(T#val(0))
                  If len(T#val(2))>0 then printtree(T#val(2))
            end sub
      }
      preorder Tree
      
      Module inorder (T) {
            Print "inorder:     ";
            printtree(T)
            Print
            sub printtree(T)
                  If len(T#val(0))>0 then printtree(T#val(0))
                  Print T#val(1);" ";
                  If len(T#val(2))>0 then printtree(T#val(2))
            end sub
      }
      inorder Tree
      
      Module postorder (T) {
            Print "postorder:   ";
            printtree(T)
            Print
            sub printtree(T)
                  If len(T#val(0))>0 then printtree(T#val(0))
                  If len(T#val(2))>0 then printtree(T#val(2))
                  Print T#val(1);" ";
            end sub
      }
      postorder Tree
      
      Module level_order (T) {
            Print "level-order: ";
            Stack New {
                  printtree(T)
                  if empty then exit
                  Read T
                  Loop
            }
            Print
            sub printtree(T)
                  If Len(T)>0 then
                        Print T#val(1);" ";
                        Data T#val(0), T#val(2)
                  end if
            end sub
      }
      level_order Tree
      Print
}
CheckIt
Pen 15 {Print "Using OOP - passing objects to modules"}
Print
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      Module preorder (T) {
            Print "preorder:    ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  Print T=>x;" ";
                  printtree(T=>LeftNode)
                  printtree(T=>RightNode)
            end sub
      }
      preorder Tree
      Module inorder (T) {
            Print "inorder:     ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  printtree(T=>LeftNode)
                  Print T=>x;" ";
                  printtree(T=>RightNode)
            end sub
      }
      inorder Tree
      Module postorder (T) {
            Print "postorder:   ";
            printtree(T)
            Print
            sub printtree(T as pointer)
                  If T is Null then Exit sub
                  printtree(T=>LeftNode)
                  printtree(T=>RightNode)            
                  Print T=>x;" ";
            end sub
      }
      postorder Tree
      Module level_order (T) {
            Print "level-order: ";
            Stack New {
                  printtree(T)
                  if empty then exit
                  Read T
                  Loop
            }
            Print
            sub printtree(T as pointer)
                  If T is Null else
                        Print T=>x;" ";
                        Data T=>LeftNode, T=>RightNode
                  end if
            end sub
      }
      level_order Tree
      Print
}
OOP
Pen 15 {Print "Using OOP - modules are members of objects "}
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        call visitor(T=>x)
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        call visitor(T=>x)
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call visitor(T=>x)
                  end sub
            }
            Module level_order (visitor){
                  T->This
                  Stack New {
                        printtree(T)
                        if empty then exit
                        Read T
                        Loop
                  }
                  sub printtree(T as pointer)
                        If T is Null else
                              call visitor(T=>x)
                              Data T=>LeftNode, T=>RightNode
                        end if
                  end sub
            }
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP
Pen 15 {Print "OOP - Event object as visitor"}
Module OOP {
      \\ Class is a global function (until this module end)
      Class Null {
      }
      \\ Null is a pointer to an object returned from class Null()
      Global Null->Null()
      Class Node {
      Public:
            x, Group LeftNode, Group RightNode
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        call event visitor, T=>x
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        call event visitor, T=>x
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T as pointer)
                        If T is Null then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call event visitor, T=>x
                  end sub
            }
            Module level_order (visitor){
                  T->This
                  Stack New {
                        printtree(T)
                        if empty then exit
                        Read T
                        Loop
                  }
                  sub printtree(T as pointer)
                        If T is Null else
                              call event visitor, T=>x
                              Data T=>LeftNode, T=>RightNode
                        end if
                  end sub
            }
      Class:
            \\ after class:  anything exist one time,
            \\ not included in final object
            Module Node {
                  .LeftNode<=Null
                  .RightNode<=Null
                  Read .x
                  \\ read ? for optional values
                  Read ? .LeftNode, .RightNode
            }
      }
      \\ NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
 
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
      Event PrintAnum {
            read x
      }
      Function PrintThis(x) {
                Print x;" ";      
      }
      Event PrintAnum New PrintThis()
      printnum=lambda PrintAnum (title$) -> {
            Print
            Print title$;
            =PrintAnum
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
}
OOP
}
MODULE PERM1 {Report "A program that performs a permutation test to judge whether the treatment had a significantly stronger effect than the placebo. "
Print "Treatment group "
Print 85, 88, 75, 66, 25, 29, 83, 39, 97
Print "Control group"
Print 68, 41, 10, 49, 16, 65, 32, 92, 28, 98
Print "Please wait about 1.5 to 4.5 minutes  - Use ctrl-C to exit any time"
Refresh
Module Checkit {
      Global data(), treat=0
      data()=(85, 88, 75, 66, 25, 29, 83, 39, 97,68, 41, 10, 49, 16, 65, 32, 92, 28, 98)
      total=1
      For i=0 to 8 {treat+=data(i)}
      For i=19 to 11 {total*=i}
      For i=9 to 1 {total/=i}
      Profiler
      gt=@pick(19,9,0)
      Print "Minutes:";Timecount/1000/60
      le=total-gt
      Print Format$("<= : {0:1}% {1}", 100*le/total, le)
      Print Format$(" > : {0:1}% {1}", 100*gt/total, gt)
      End
      Function pick(at, remain, accu)
            If remain Else =If(accu>treat->1,0):Exit Function
            =@pick(at-1,remain-1,accu+data(at-1))+If(at>remain->@pick(at-1, remain, accu),0)
      End Function
}
Checkit
}
MODULE ITER {Print "Associative array/Iteration"
Module checkit {
      \\ Inventories are objects with keys and values, or keys (used as read only values)
      \\ They use hash function.
      \\ Function TwoKeys return Inventory object (as a pointer to object)
      Function TwoKeys {
            Inventory Alfa="key1":=100, "key2":=200
            =Alfa
      }
      M=TwoKeys()
      Print Type$(M)="Inventory"
      \\ Normal Use:
            \\ Inventories Keys are case sensitive
            \\ M2000 identifiers are not case sensitive
      Print M("key1"), m("key2")
      \\ numeric values can convert to strings
      Print M$("key1"), m$("key2")
      \\ Iteration
      N=Each(M)
      While N {
            Print Eval(N)  ' prints 100, 200 as number
            Print M(N^!)  ' The same using index N^
      }
      N=Each(M)
      While N {
            Print Eval$(N)  ' prints  100, 200 as strings
            Print M$(N^!)  ' The same using index N^
      }
      N=Each(M)
      While N {
            Print Eval$(N, N^)  ' Prints Keys
      }
      \\ double iteration
      Append M, "key3":=500
      N=Each(M, 1, -1)  ' start to end
      N1=Each(M, -1, 1) ' end to start
      \\ 3x3 prints
      While N {
            While N1 {
                  Print format$("{0}*{1}={2}", Eval(N1), Eval(N), Eval(N1)*Eval(N))
            }
      }
      \\ sort results from lower product to greater product (3+2+1, 6 prints only)
      N=Each(M, 1, -1)  
      While N {
            N1=Each(M, N^+1, -1) 
            While N1 {
                  Print format$("{0}*{1}={2}", Eval(N1), Eval(N), Eval(N1)*Eval(N))
            }
      }
      N=Each(M)
      N1=Each(M,-2, 1)  ' from second from end to start
      \\ print only 2 values. While block ends when one iterator finish
      While N, N1 {
            Print Eval(N1)*Eval(N)
      }         
}
Checkit
}
MODULE ST {Print "A stack object"
Module Checkit {
      a=Stack
      Stack a {
            Push 100, 200, 300
      }
      Print StackItem(a, 1)=300
      Stack a {
            Print StackItem(1)=300
            While not empty {
                  Read N
                  Print N
            }
      }
}
Checkit
}
MODULE ST1 {Print "Current Stack"
Module Checkit {
      Read a, b
      Print a, b
}
\\ add parameters in a FIFO, and this FIFO merged to current stack
Push 100
Checkit 10, 20
Print StackItem(1)=100
Module Checkit {
      Read a, b
      Print a=20, b=100
}
Checkit 20
 
Function alfa {
      k=0
      n=0
      while not empty {
            k+=number
            n++
      }
      if n=0 then Error "No parameters found"
      =k/n
}
 
Print alfa(1,2,3,4)=2.5
}
MODULE MAZE2 {back {cls 0}
Module Maze2 {
      \\ depth-first search
      While Inkey$<>"" {}  ' drop keys
      Const View as boolean=True
      Def tc

      Form 80,50
again:
      Gradient 5,6
      Cursor 0,0
      let w=random(2,6)*10, h=random(1,4)*10, slice=w*h div 30
      let  slice=if(slice=0->1, slice) : counter =1 
      Double
      \\center proportional text double size
      Report 2, Format$("Maze {0}x{1}",w,h)
      Normal
      Hold
      Refresh
      Set Fast !
      stack new {
            Profiler
            Dim maze$(1 to w+1, 1 to h+1)="#"
            Include=Lambda w,h (a,b) ->a>=1 and a<=w and b>=1 and b<=h
            Flush ' empty stack
            if random(1,2)=1 then
                  entry=(if(random(1,2)=1->2, w),Random(1, h/2)*2)
            else
                  entry=(random(1,w/2)*2,If(Random(1,2)=1->2,h))
            end if
            maze$(entry#val(0), entry#val(1))=" "
            forchoose=(,)
            Push Entry
            do
                  do
                        NewForChoose(!entry)
                        status=len(forchoose)
                        if status>0 then
                              status--
                              forchoose=forchoose#val(random(0,status))
                              Push forchoose
                              OpenDoor(!Entry, !forchoose)
                              if view then counter=if(counter=0->slice, counter-1) : if counter=0 then ShowMaze()      
                        else
                              exit
                        end if
                        entry=forchoose
                  Always
                  if empty then exit
                  Read entry
            Always
            tc= timecount/1000
      }
       ShowMaze()
      Cursor 0,Height-1
      Print Part $(6,width), ~(15,0,0),"Press a key or mouse button after any drawing of the maze to exit  - "+format$("{0:3}",tc)
      Refresh
      counter=10
      every 200 {
            counter--
            if inkey$<>"" or mouse<>0 then counter=-1 : exit
            if counter<1 then exit
      }
      if counter=0 then Release : goto again
      End
      Sub NewForChoose(x,y)
            Local x1=x-2, x2=x+2, y1=y-2, y2=y+2, arr=(,)
            Stack New {
                  if include(x1,y) then if Maze$(x1,y)<>" " Then push (x1, y) 
                  if include(x2,y) then if Maze$(x2,y)<>" " Then push (x2, y)
                  if include(x,y1) then if Maze$(x,y1)<>" " Then push (x, y1)
                  if include(x,y2) then if Maze$(x,y2)<>" " Then push (x, y2)
                  forchoose= Array([])
            }
      End Sub
      Sub OpenDoor(x1,y1, x2,y2)
            Local i
            if x1=x2 then
                  y1+=y2<=>y1
                  for i=y1 to y2 {maze$(x1, i)=" " } 
            Else
                  x1+=x2<=>x1
                  for i=x1 to x2 {maze$(i, y1)=" "}                   
            End if
      End Sub
      Sub ShowMaze()
            Refresh 5000
Rem            cls ,4  ' split screen - preserve lines form 0 to 3
            Release
            cursor 0,(height-h) div 2
            Local i, j, t=40-w div 2
            For j=1 to h+1 { Print @(t) : for i=1 to w+1 {Print maze$(i,j);}:Print}
            Print
            Refresh 100
      End Sub     
}
Maze2
Cursor 0,0
keyboard "info"+chr$(13)

}
MODULE MAZE {Module Maze {
      width% = 40
      height% = 20
      \\ we can use DIM maze$(0 to width%,0 to  height%)="#"
      \\ so we can delete the two For loops
      DIM maze$(0 to width%,0 to  height%)
      FOR x% = 0 TO width%
          FOR y% = 0 TO height%
              maze$(x%, y%) = "#"
          NEXT y%
      NEXT x%
 
      currentx% = INT(RND * (width% - 1))
      currenty% = INT(RND * (height% - 1))
 
      IF currentx% MOD 2 = 0 THEN currentx%++
      IF currenty% MOD 2 = 0 THEN currenty%++
      maze$(currentx%, currenty%) = " "
 
      done% = 0
      WHILE done% = 0 {
          FOR i% = 0 TO 99
              oldx% = currentx%
              oldy% = currenty%
              SELECT CASE INT(RND * 4)
                  CASE 0
                      IF currentx% + 2 < width% THEN currentx%+=2
                  CASE 1
                      IF currenty% + 2 < height% THEN currenty%+=2
                  CASE 2
                      IF currentx% - 2 > 0 THEN currentx%-=2
                  CASE 3
                      IF currenty% - 2 > 0 THEN currenty%-=2
              END SELECT
              IF maze$(currentx%, currenty%) = "#"  Then {
                  maze$(currentx%, currenty%) = " "
                  maze$(INT((currentx% + oldx%) / 2), ((currenty% + oldy%) / 2)) = " "
             }
          NEXT i%
          done% = 1
          FOR x% = 1 TO width% - 1 STEP 2
              FOR y% = 1 TO height% - 1 STEP 2
                  IF maze$(x%, y%) = "#" THEN done% = 0
              NEXT y%
          NEXT x%
      }
 
 
      FOR y% = 0 TO height%
          FOR x% = 0 TO width%
              PRINT maze$(x%, y%);
          NEXT x%
          PRINT
      NEXT y%
}
Maze
}
MODULE MINESWEEPER {Module Minesweeper {
      Font "Arial Black"
      Bold 0
      Form 60,40
      Refresh 1000
      Def com$, com_label$
      Def x, b_row, b_col, where, top_where
      Def rows=6, columns=8, swap_first%
      Def boolean skiptest, end_game, cheat
      Dim Board$(0 to rows+1, 0 to columns+1)="? "
      Def mines%, i%, j%, used%, acc%, n%, m%
      mines%=max.data(random(int(columns*rows*.1),int(columns*rows*.2)-1), 1)
      For i%=1 to rows:For j%=1 to columns
            Board$(i%,j%)=". "
      Next j%:Next i%
      used%=mines%
      While used%
            used%--
            Do
                  i%=random(1,rows)
                  j%=random(1, columns)
            Until right$(Board$(i%,j%),1)=" "
            Board$(i%,j%)=".*"
      End While
      used%=rows*columns-mines%
      \\ remove rem so to never loose from first open
      Rem : 
      swap_first%=used%
      \\ when mines%=0 or used%=0 then player win
      Report {Minesweeper - rosettacode task
            Commands:
            -  ? 1 2  flag/unflag 1 2
            -  1 2   open 1 2
            -  q  to quit
            You can pass multiple commands in a line, but q erase all before execute
      } 
      top_where=Row
      While not End_Game {GameLoop()}
      End
      Sub PrintBoard()
      Cls, top_where
      Print
      Print "   X  ";
      For j%=1 to columns {
            Print format$("{0::-3}  ", j%);
      }
      Print
      For i%=1 to rows {
            Print format$(" {0::-3}  ", i%);
            For j%=1 to columns {
                  Print "  ";Left$(Board$(i%,j%),1);"  ";
                  \\ rem above and unrem follow line to display mines
                  Rem: Print "  ";Board$(i%,j%)+" ";
            }
            Print
      }      
      End Sub
      Sub PrintMines()
      Cls, top_where
      Print
      Print "   X  ";
      For j%=1 to columns {
            Print format$("{0::-3}  ", j%);
      }
      Print
      For i%=1 to rows {
            Print format$(" {0::-3}  ", i%);
            For j%=1 to columns {
                  Print "  ";Right$(Board$(i%,j%),1);"  ";
            }
            Print
      }      
      End Sub
      Sub GameLoop()
            Local com$, loopagain as boolean
            PrintBoard()
            InputCommand()
            do 
                  loopagain=true
                  while not empty
                              \\ process game command
                        Read com$
                        if com$="q " Then
                              Print "Quit" : end_game=True : exit
                        Else.if com$="o " Then
                              OpenCell()
                        Else.if com$="n " Then
                              OpenCell2()
                        Else.if com$="? " Then
                              SwapCell()
                        Else.if com$="c " Then
                              Exit Sub                        
                        End if
                  End While
                  If mines%=0 or used%=0 then
                        PrintBoard(): Print "Player Win": end_game=True: Exit Sub
                  End if
                  If mines%=-1 then
                        if swap_first%=used% then
                              mines%=rows*columns-used%
                              Local n%, m%
                              While mines%
                                    Let n%=random(1,rows), m%=random(1, columns)
                                    If Board$(n%, m%)=". " then  Board$(n%, m%)=".*" : mines%=0
                              End While
                              Board$(i%, j%)=". "
                              mines%=rows*columns-used%
                              swap_first%=-100
                              Push i%, j%, "o "
                              loopagain=false
                        else
                              PrintMines(): Print "Player Loose": end_game=True : Exit Sub
                        end if
                  End If
            Until loopagain
            Flush
            Refresh if(End_Game->10,1000)
      End Sub
      Sub InputCommand()
            where=row
            While com$=""
                  cls, where
                  Print "x x | ? x x | q >";
                  Refresh 10
                  Try {
                        Input "", com$
                  }
            End While
            x=1
            Flush 
            While com$<>""
                  com_label$=""
                  ParseCommand()
                  if len(com_label$)<>2 then
                        com$="" : Print com_label$ : Flush
                        Refresh 10
                        push key$ : drop
                  else
                        Data com_label$, b_col, b_row
                  End if
            End While
            Refresh 1000
      End Sub
      Sub ParseCommand()
            com_label$="o "
            skiptest=true
            ReadColumn()
            if len(com_label$)<>2 then
                  com$=""     
            Else.if x=-1 then
                  com_label$=lcase$(Left$(com$,1))+" "
                  com$=mid$(com$, 2)
                  x=1
                  if len(com_label$)<>2 then
                        com_label$="no command found"
                  else.if com_label$="? " then
                        ReadColumn()
                        if x>-1 then ReadRow()
                  else.if com_label$="c " then
                        cheat=true  
                  else.if com_label$="q " then
                        flush
                        com$=""                  
                  else
                        com_label$="Use q or ? for commands"
                        com$=""
                  End if      
            else
                  ReadRow()
                  if x>-1 then com_label$="o "
            End if 
      End Sub
      Sub ReadRow()
            com$=mid$(com$,x)
            b_row=val(com$, "??", x)
            if x=-1 then
                  com_label$="Need a row"
            else.if b_row<1 or b_row>rows then
                  com_label$="Need a row from 1 to "+str$(rows)
                  x=-1 
            else
                  com$=mid$(com$,x+1)
                  x=1
            End if
      End Sub
      Sub ReadColumn()
            com$=mid$(com$,x)
            b_col=val(com$, "??", x)
            if x=-1 then
                  if not skiptest then com_label$="Need a column"
            else.if b_col<1 or b_col>columns then
                  com_label$="Need a column from 1 to"+str$(columns)
            else
                  com$=mid$(com$,x+1)
                  x=1
            End if
            skiptest=false
      End Sub
      Sub SwapCell()
            Read j%, i%
            If left$(Board$(i%,j%),1)="?" then
                  Board$(i%,j%) ="."+Right$(Board$(i%,j%),1)
                  If cheat Then if Right$(Board$(i%,j%),1)="*" then mines%++
            Else.If left$(Board$(i%,j%),1)="." then
                  Board$(i%,j%) ="?"+Right$(Board$(i%,j%),1)
                  If cheat Then if Right$(Board$(i%,j%),1)="*" then mines%--
            End if
      End Sub
      Sub OpenCell()
            Read j%, i%
            If left$(Board$(i%,j%),1)="." then {
                  if Right$(Board$(i%,j%),1)="*" then mines%=-1 : flush : exit
                  acc%=0
                  used%--
                  Local n%, m%
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                                If Right$(Board$(n%,m%),1)="*" then acc%++
                        }
                  }
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                             if not (n%=i% and m%=j%) then
                                   if not Right$(Board$(n%,m%),1)="*" then
                                         If left$(Board$(n%,m%),1)="." then
                                              Push n%, m%, "n "  ' reverse to stack
                                              Rem : Print stack.size : Refresh
                                         End If
                                   End If
                             End If
                        }
                  }
                  Board$(i%,j%)=if$(acc%=0->"  ",str$(acc%, "# "))
            }
      End Sub
      Sub OpenCell2()
            Read J%, i%
            If left$(Board$(i%,j%),1)="." then {
                  if Right$(Board$(i%,j%),1)="*" then exit
                  acc%=0
                  used%--
                  For n%=i%-1 to i%+1 {
                        For m%=j%-1 to j%+1 {
                                If Right$(Board$(n%,m%),1)="*" then acc%++
                        }
                  }
                  \\ if cell has no mines around then we check all
                  if acc%=0 then
                        Local n%, m%
                        For n%=i%-1 to i%+1
                              For m%=j%-1 to j%+1
                                   if not (n%=i% and m%=j%) then
                                         if not Right$(Board$(n%,m%),1)="*" then
                                               If left$(Board$(n%,m%),1)="." then
                                                    Push n%, m%, "o "  ' reverse to stack
                                                    Rem : Print stack.size : Refresh
                                               End If
                                         End If
                                   End If
                              Next m%
                        Next n%
                  End If
                  Board$(i%,j%)=if$(acc%=0->"  ",str$(acc%, "# "))
            }
      End Sub     
}
Minesweeper
Report 2, "Press a Key"
Push Key$ : Drop
Keyboard "info"+chr$(13)   ' call the info module
}
MODULE IBAN {\\ IBAN checker
Function MakeIBANfun$ {
      Inventory countrylength = "AL" := 28, "AD" := 24, "AT" := 20, "AZ" := 28, "BE" := 16, "BH" := 22, "BA" := 20, "BR" := 29
      Append  countrylength, "BG" := 22, "CR" := 21, "HR" := 21, "CY" := 28, "CZ" := 24, "DK" := 18, "DO" := 28, "EE" := 20
      Append  countrylength, "FO" := 18, "FI" := 18, "FR" := 27, "GE" := 22, "DE" := 22, "GI" := 23, "GR" := 27, "GL" := 18
      Append  countrylength, "GT" := 28, "HU" := 28, "IS" := 26, "IE" := 22, "IL" := 23, "IT" := 27, "KZ" := 20, "KW" := 30
      Append  countrylength, "LV" := 21, "LB" := 28, "LI" := 21, "LT" := 20, "LU" := 20, "MK" := 19, "MT" := 31, "MR" := 27
      Append  countrylength, "MU" := 30, "MC" := 27, "MD" := 24, "ME" := 22, "NL" := 18, "NO" := 15, "PK" := 24, "PS" := 29
      Append  countrylength, "PL" := 28, "PT" := 25, "RO" := 24, "SM" := 27, "SA" := 24, "RS" := 22, "SK" := 24, "SI" := 19
      Append  countrylength, "ES" := 24, "SE" := 24, "CH" := 21, "TN" := 24, "TR" := 26, "AE" := 23, "GB" := 22, "VG" := 24
 
     =Lambda$ countrylength (Iban0$)->{
            Iban$=Filter$(Ucase$(Iban0$), " ")
            Iban$=Filter$(Iban$, Filter$(Iban$,"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
            Def Decimal ch, c
            {            
                  If Not Exist(countrylength, Left$(Iban$,2)) Then Exit
                  length=Eval(countrylength)
                  If Not Len(Iban$)=length Then exit
                  Buffer ScanChar as Integer*length
                  Return ScanChar, 0:=Mid$(Iban$,5), length-4:=Mid$(Iban$,1,4)
 
                  For i=0 to length-1 {
                        ch=Eval(ScanChar, i)
                        if ch>=48 and ch<=57 then {
                              c = c*10+ch-48    
                        } else.if ch>=65 and ch<=90 then {
                              c = c*100+ch-55
                        } else c=-1: exit
                  }
                  c = c mod 97
            }
            =Iban0$ + If$(c=1 ->" (Valid)", " (Invalid)")
      }
}
IbanCheck$=MakeIBANfun$()
Print IbanCheck$("GB82 WEST 1234 5698 7654 32")    ' valid
Print IbanCheck$("GB82 TEST 1234 5698 7654 32")
Print IbanCheck$("SA03 8000 0000 6080 1016 7519")   ' valid
Print IbanCheck$("GR16 0110 1250 0000 0001 2300 695X")
Print IbanCheck$("MK11 2222 3333 4444 555")
}
MODULE HTTP {Module CheckIt  {
      Declare  xml "Microsoft.XMLHTTP"
      const testUrl$ = "https://news.google.com/"
      With  xml, "readyState" as ReadyState
      Method xml "Open", "Get", testUrl$, True  ' True means Async
      Method xml "send"
      \\ We set a thread to count time
      k=0
      Thread {
            k++
      }  as TimeOut interval 300   ' change thread interval to give more time to collect
      \\ In main thread we can check ReadyState and Mouse button
      Task.Main 100 {
            Report 2, Str$(ReadyState): refresh
            If ReadyState=4 then exit
            if k>20 then exit   ' 20*100= 2 sec
            if mouse then exit ' exit if mouse click
      }
      \\ So now we can read
      if ReadyState=4 then {
            With  xml, "responseText" AS AA$
            \\ break AA$ to lines
            Document BB$=AA$
            \\ using line breaks as CRLF
            Print "Press space or mouse to change page, or Esc to break report"
            Report BB$
      }
      Declare xml Nothing
}
Report 2, "Using the Microsoft.XMLHTTP with threads - see Down4 where we use an internal object for download with events. Use space bar or mouse click to advance the scroll"
CheckIt
}
MODULE CAL {\\ Calendar - for "REAL" programmers
\\ All statements in UPPERCASE
\\ Output to 132 characters console - as a line printer
\\ USE COURIER NEW  (FONT "COURIER NEW")

\\ CHANGE THE 
GLOBAL CONST PRINT_IT AS BOOLEAN=FALSE
MODULE GLOBAL SNOOPY  {
IF NOT PRINT_IT THEN CURSOR 0,ROW ELSE IF ROW>0 THEN PAGE 1 
PRINT $(,8)
PRINT #-2, {
					   XXXX
					  X    XX
					 X  ***  X		  XXXXX
					X  *****  X	       XXX     XX
				     XXXX ******* XXX	   XXXX 	 XX
				   XX	X ******  XXXXXXXXX    El@	   XX XXX
				 XX	 X ****  X			     X** X
				X	 XX    XX     X 		     X***X
			       X	 //XXXX       X 		     XXXX
			      X 	//   X				   XX
			     X	       //    X		XXXXXXXXXXXXXXXXXX/
			     X	   XXX//    X	       X
			     X	  X   X     X	      X
			     X	  X    X    X	     X
			      X   X    X    X	     X			  XX
			      X    X   X    X	     X		       XXX  XX
			       X    XXX      X	      X 	      X  X X  X
			       X	     X	       X	      XX X  XXXX
				X	      X 	XXXXXXXX\     XX   XX  X
				 XX	       XX	       X     X	 @X  XX
				   XX		 XXXX	XXXXXX/     X	  XXXX
				     XXX	     XX***	   X	 X
					XXXXXXXXXXXXX *   *	  X	X
						     *---* X	 X     X
						    *-* *   XXX X     X
						    *- *       XXX   X
						   *- *X	  XXX
						   *- *X  X	     XXX
						  *- *X    X		XX
						  *- *XX    X		  X
						 *  *X* X    X		   X
						 *  *X * X    X 	    X
						*  * X**  X   XXXX	    X
						*  * X**  XX	 X	    X
					       *  ** X** X     XX	   X
					       *  **  X*  XXX	X	  X
					      *  **    XX   XXXX       XXX
					     *	* *	 XXXX	   X	 X
					    *	* *	     X	   X	 X
			      =======*******   * *	     X	   X	  XXXXXXXX\
				     *	       * *	/XXXXX	    XXXXXXXX\	   )
				=====**********  *     X		     )	\  )
				  ====* 	*     X 	      \  \   )XXXXX
			     =========**********       XXXXXXXXXXXXXXXXXXXXXX

}
}
MODULE CALENDAR (YEAR, LOCALEID) {
      FUNCTION GETMAX(YEAR, MONTH) {
            A=DATE(STR$(YEAR)+"-"+STR$(MONTH)+"-1")
            MAX=32
            DO {
                  MAX--
                  M=VAL(STR$(CDATE(A,0,0,MAX), "M"))  
            } UNTIL M=MONTH
             =MAX+1    
      }
      FUNCTION SKIPMO(YEAR, MONTH) {
            A=DATE(STR$(YEAR)+"-"+STR$(MONTH)+"-1")
            =(VAL(STR$(A, "W"))-8) MOD 7 +7
      }
      FUNCTION TITLE$(A$) {
            =UCASE$(LEFT$(A$,1))+LCASE$(MID$(A$, 2))
      }
      LOCALE LOCALEID
      IF NOT PRINT_IT THEN CURSOR 0,HEIGHT-1  ' LAST LINE, SO EACH NEW LINE SCROLL ALL LINES UP
      SNOOPY
      
      PRINT UNDER  ' PRINT UNDERLINE
      PRINT OVER $(2), YEAR
      PRINT
      FOR J=0 TO 1 {
            PRINT
            FOR I=1 TO 6 {
                  MONTH=I+J*6
                  PRINT  PART @((I-1)*22+1), $(2,21), UCASE$(LOCALE$(55+MONTH))
            }
            PRINT
            DIM SKIP(1 TO 6), COUNT(1 TO 6), D(1 TO 6)=1
            FOR I=1 TO 6 {
                  MONTH=I+J*6
                  IF I>1 THEN PRINT " ";
                  FOR K=42 TO 48 :PRINT " ";UCASE$(LEFT$(LOCALE$(K),2));:NEXT K 
                  SKIP(I)=SKIPMO(YEAR, MONTH)
                  COUNT(I)=GETMAX(YEAR, MONTH)
            }
            PRINT
            IF PRINT_IT ELSE REFRESH 1000
            FOR I=1 TO 6 {
                      IF I>1 THEN PRINT " ";
                      FOR K=1 TO 7 {
                        SKIP(I)--
                        IF  SKIP(I)>0 THEN PRINT "   "; :CONTINUE
                        COUNT(I)--
                        PRINT FORMAT$(" {0::-2}", D(I));
                        D(I)++
                  }
            }
            PRINT
            IF PRINT_IT ELSE REFRESH 1000
            PRINT @(0)
            FOR M=1 TO 5 {
                  FOR I=1 TO 6 {
                        IF I>1 THEN PRINT " ";
                        FOR K=1 TO 7 {
                              COUNT(I)--
                              IF COUNT(I)<0 THEN PRINT "   "; : CONTINUE
                              PRINT FORMAT$(" {0::-2}", D(I));
                              D(I)++
                        }
                  }
            PRINT
            IF PRINT_IT ELSE REFRESH 1000 
            }
      }     
}
WHILE INKEY$<>"" :  END WHILE
IF PRINT_IT THEN PRINTING ON ELSE REFRESH 1000
FONT "COURIER NEW"
PEN 0
CLS 15, 0
FORM 132,68      
CALENDAR 1966, 1032 ' GREEK
GOSUB WAITKEY_OR_MOUSE
FOR I=2020 TO 2026
CALENDAR I, 1033  ' ENGLISH
GOSUB WAITKEY_OR_MOUSE
NEXT I
IF PRINT_IT THEN PRINTING OFF ELSE REFRESH 50
CLEAR  ' CLEAR VARIABLES FROM THIS MODULE
KEYBOARD "INFO"+CHR$(13)
END
WAITKEY_OR_MOUSE:
IF PRINT_IT THEN RETURN
WHILE INKEY$="" AND MOUSE=0
END WHILE
RETURN
}
MODULE LINKED_LIST {\\ This example use pointers to groups.
\\ Class Node
\\ Node type has two pointers to groups: pred and succ
\\ Class 

Module Checkit {
      Form 80, 50
      Class Null {}
      Global Null->Null()
      Class Node {
            group pred, succ
            dat=0
            Remove {
                  Print "destroyed", .dat
            }
            class: 
            module Node {
                  .pred->Null
                  .succ->Null
                  if match("N") Then Read .dat
            }
      }
      Class LList {
            Group Head, Tail
            Module PushTail(k as pointer) {
                  if .Tail is Null then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.Tail
                        .Tail<=k
                        k=>pred=n=>pred
                        n=>pred=k
                        k=>succ=n
                  }
            }
            Function RemoveTail {
                  n=.Tail
                  if n is .Head then {
                        .Head->Null
                        .Tail->Null
                  } Else { 
                        .Tail<=n=>succ
                        .Tail=>pred=n=>pred
                        n=>pred->Null
                  }
                  for n {
                        .succ->Null
                        .pred->Null
                  }
                  =n
            }
            Module PushHead(k as pointer) {
                  if .head is Null then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.head
                        .head<=k
                        k=>succ=n=>succ
                        n=>succ=k
                        k=>pred=n
                  }
            }
            Function RemoveHead {
                  n=.Head
                  if n is .Tail then {
                        .Head->Null
                        .Tail->Null
                  } Else { 
                      .Head<=n=>pred
                      .Head=>succ=n=>succ
                       n=>succ->Null    
                   }
                  for n {
                        .succ->Null
                        .pred->Null
                  }
                  =n
            }
            Module RemoveNode(k as pointer) {
                  pred=k=>pred
                  succ=k=>succ
                  if pred is succ then {
                        if .head is k else Error "Can't remove this node"
                        k=.RemoveHead()
                        clear k
                  } else {
                       pred=>succ=succ
                       succ=>pred=pred 
                  }
            }
            Module InsertAfter(k as pointer, n as pointer) {
                  pred=k=>pred
                  n=>pred=pred
                  n=>succ=k
                  pred=>succ=n
                  k=>pred=n
            }
            Function IsEmpty {
                  = .Head is null or .tail is null
            }
      class:
            Module LList {
                  .Head->Null
                  .Tail->Null
            }
      }
      m->Node(100)
 
      L=LList()
      L.PushTail m
      If not L.Head is Null then Print L.Head=>dat=100
      for i=101 to 103 {
            m->Node(i)
            L.PushTail m
            Print "ok....", i
      }
      for i=104 to 106 {
            m->Node(i)
            L.PushHead m
            Print "ok....", i
      }
 
      Print "Use Head to display from last to first"
      m=L.Head
      do {
            Print m=>dat
            m=m=>pred
      } Until m is null
      Print "ok, now find 3rd and remove it"
      m1=L.Head
      i=1 
      Index=3
      While i<Index {
            if m1 is null then exit
            m1=m1=>pred
            i++
      }
      If i<>Index then {
            Print "List has less than "; Index;" Items"
      } Else {
            Print "First add one new node"
                  newNode->Node(1000)
                  L.InsertAfter m1, newNode
                  L.RemoveNode m1
                  clear m1  ' last time m1 used here
                  newNode=Null
            Print "ok.............."
      }
      Print "Use Tail to display from first to last"
      m=L.Tail
      do {
            Print m=>dat
            m=m=>succ
      } Until m is null
 
 
      useother=True
      While not L.IsEmpty(){
            For This {
                  \\ we have to use a temporary variable name, here A
                         A=If(useother->L.RemoveTail(),L.RemoveHead())
                         ? A=>dat
                        useother~
                        \\ now we can try to perform removing
                        clear A
             }
      }
      Print "list is empty:"; L.IsEmpty()    
}
Checkit
}
MODULE LINKED_LIST1 {\\ Second Version
\\ This example use pointers to groups.
\\ One class which make Node and Null class inside
\ \ Head and Tail are private

Module Checkit {
      Form 80, 50
      Class LList {
      Private:
            Group Head, Tail
            Class Null {}
      Public:
            Property Null {Value}
            Group GetHead {
                  Value {
                        link parent Head to Head
                        ->Head
                  }
            }
            Group GetTail {
                  Value {
                        link parent Tail to Tail
                        ->Tail
                  }
            }
            Function Node {
                  Group Ret {
                        group pred, succ
                        dat=0
                        Remove {
                              Print "destroyed", .dat
                        }
                  }
                  Ret.pred->.[Null]
                  Ret.succ->.[Null]
                  if match("N") Then Read Ret.dat
                   ->(Ret)
            }
            Module PushTail(k as pointer) {
                  if .Tail is .[Null] then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.Tail
                        .Tail<=k
                        k=>pred=n=>pred
                        n=>pred=k
                        k=>succ=n
                  }
            }
            Function RemoveTail {
                  n=.Tail
                  if n is .Head then {
                        .Head->.[Null]
                        .Tail->.[Null]
                  } Else { 
                        .Tail<=n=>succ
                        .Tail=>pred=n=>pred
                        n=>pred->.[Null]
                  }
                  for n, This {
                        .succ->..[Null]
                        .pred->..[Null]
                  }
                  =n
            }
            Module PushHead(k as pointer) {
                  if .head is .[Null] then {
                        .Head<=k
                        .Tail<=k
                  } else {
                        n=.head
                        .head<=k
                        k=>succ=n=>succ
                        n=>succ=k
                        k=>pred=n
                  }
            }
            Function RemoveHead {
                  n=.Head
                  if n is .Tail then {
                        .Head->.[Null]
                        .Tail->.[Null]
                  } Else { 
                      .Head<=n=>pred
                      .Head=>succ=n=>succ
                       n=>succ->.[Null]
                   }
                  for n, This {
                        .succ->..[Null]
                        .pred->..[Null]
                  }
                  =n
            }
            Module RemoveNode(k as pointer) {
                  pred=k=>pred
                  succ=k=>succ
                  if pred is succ then {
                        if .head is k else Error "Can't remove this node"
                        k=.RemoveHead()
                        clear k
                  } else {
                       pred=>succ=succ
                       succ=>pred=pred 
                  }
            }
            Module InsertAfter(k as pointer, n as pointer) {
                  pred=k=>pred
                  n=>pred=pred
                  n=>succ=k
                  pred=>succ=n
                  k=>pred=n
            }
            Module DeleteAll {
                  While not .IsEmpty(){
                        For This {
                              A=.RemoveTail()
                              clear A
                         }
                  }                  
            }
            Remove {
                  .DeleteAll
            }
            Function IsEmpty {
                  = .Head is .[Null] or .tail is .[Null]
            }
      class:
            Module LList {
                  .[Null]->.Null()
                  .Head->.[Null]
                  .Tail->.[Null]
            }
      }

      L=LList()
      Null=L.Null
      m->L.Node(100)      
      L.PushTail m
      If not L.GetHead is Null then Print L.GetHead=>dat=100
      for i=101 to 103 {
            m->L.Node(i)
            L.PushTail m
            Print "ok....", i
      }
      for i=104 to 106 {
            m->L.Node(i)
            L.PushHead m
            Print "ok....", i
      }
 
      Print "Use Head to display from last to first"
      m=L.GetHead
      do {
            Print m=>dat
            m=m=>pred
      } Until m is Null
      Print "ok, now find 3rd and remove it"
      m1=L.GetHead
      i=1 
      Index=3
      While i<Index {
            if m1 is Null then exit
            m1=m1=>pred
            i++
      }
      If i<>Index then {
            Print "List has less than "; Index;" Items"
      } Else {
            Print "First add one new node"
                  newNode->L.Node(1000)
                  L.InsertAfter m1, newNode
                  L.RemoveNode m1
                  clear m1  ' last time m1 used here
                  newNode=Null
            Print "ok.............."
      }
      Print "Use Tail to display from first to last"
      m=L.GetTail
      do {
            Print m=>dat
            m=m=>succ
      } Until m is Null
 
      If rnd<.5 Then 
      useother=True
      While not L.IsEmpty(){
            For This {
                  \\ we have to use a temporary variable name, here A
                         A=If(useother->L.RemoveTail(),L.RemoveHead())
                         ? A=>dat
                        useother~
                        \\ now we can try to perform removing
                        clear A
             }
      }
      Else
      L.deleteAll
      End if
      Print "list is empty:"; If$(L.IsEmpty()->"Yes","No")
      mm=0
      for i=50 to 80 {
            m->L.Node(i)
            L.PushTail m
           mm++
      }
      m->Null
      Print "Added ";mm; " nodes"
      Push Pointer((L))
}
Checkit
Stack
Print "Press a key for phase 2"
Print "now Linked_list is a pointer to a group object"
Push key$ : Drop
Read Linked_List
Null=Linked_List=>Null
m=Linked_List=>GetHead
While not m is Null
	Print m=>dat
	m=m=>pred
End While
List
\\ we have to use Clear. Clear act only if the pointer is the last one.
\\ Then Linlked_List Remove do a Clear for each node. If we didn't use any extenal pointer for these we get all destroyed.
Clear Linked_list, Null, m
Print " now all variables aren't pointers. They have an empty group"
List
}
MODULE LINKED_LIST2 {
\\ Greek Version for Linked_list1
Τμήμα ΔεςΤο {
      Φόρμα 80, 50
      Κλάση Συνδεδεμένη_Λίστα {
      Ιδιωτικό:
            Ομάδα Κεφαλή, Ουρά
            Κλαση Κανένα {}
      Δημόσιο:
      ιδιότητα  Κανένα {Αξία}
            Συνάρτηση Κόμβος {
                  Ομάδα Επ {
                        Ομάδα πίσω, μπροστά
                        δεδομένο=0
                        Διαγραφή {
                              Τύπωσε "καταστράφηκε", .δεδομένο
                        }
                  }
                 επ.πίσω->.[Κανένα]
                 επ.μπροστά->.[Κανένα]
                 Αν Ταύτιση("ν") Τότε Διάβασε επ.δεδομένο
                 ->(επ)
            }
            Ομάδα Κόμβος_Κεφαλής {
                  Αξία {
                     Ένωσε γονικό Κεφαλή στη Κεφαλή
                     =Κεφαλή
                  }
            }
            Ομάδα Κόμβος_Ουράς {
                  Αξία {
                        Ένωσε γονικό Ουρά στη Ουρά
                        =Ουρά
                  }
            }
            Τμήμα ΒάλεΣτηνΟυρά (κ ως δείκτης) {
                  Αν .Ουρά Είναι .[Κανένα] Τότε {
                        .Κεφαλή<=κ
                        .Ουρά<=κ
                  } Αλλιώς {
                        ν=.Ουρά
                        .Ουρά<=κ
                        κ=>πίσω=ν=>πίσω
                        ν=>πίσω=κ
                        κ=>μπροστά=ν
                  }
            }
            Συνάρτηση ΑφαίρεσηΟυράς {
                  ν=.Ουρά
                  Κανένα=.[Κανένα]
                  Αν ν Είναι .Κεφαλή Τότε {
                        .Κεφαλή->Κανένα
                        .Ουρά->Κανένα
                  } Αλλιώς { 
                        .Ουρά<=ν=>μπροστά
                        .Ουρά=>πίσω=ν=>πίσω
                        ν=>πίσω->Κανένα
                  }
                  Για ν {
                        .μπροστά->Κανένα
                        .πίσω->Κανένα
                  }
                  =ν
            }
            Τμήμα ΒάλεΣτηΚεφαλή (κ ως δείκτης) {
                  Αν .Κεφαλή Είναι .[Κανένα] Τότε {
                        .Κεφαλή<=κ
                        .Ουρά<=κ
                  } Αλλιώς {
                        ν=.Κεφαλή
                        .Κεφαλή<=κ
                        κ=>μπροστά=ν=>μπροστά
                        ν=>μπροστά=κ
                        κ=>πίσω=ν
                  }
            }
            Συνάρτηση ΑφαίρεσηΚεφαλής {
                  ν=.Κεφαλή
                  Κανένα=.[Κανένα]
                  Αν ν Είναι .Ουρά Τότε {
                        .Κεφαλή->Κανένα
                        .Ουρά->Κανένα
                  } Αλλιώς { 
                      .Κεφαλή<=ν=>πίσω
                      .Κεφαλή=>μπροστά=ν=>μπροστά
                       ν=>μπροστά->Κανένα
                   }
                  Για ν, Αυτο {
                        .μπροστά->Κανένα
                        .πίσω->Κανένα
                  }
                  =ν
            }
            Τμήμα ΑφαίρεσηΚόμβου(κ ως δείκτης) {
                  πίσω=κ=>πίσω
                  μπροστά=κ=>μπροστά
                  Αν πίσω Είναι μπροστά Τότε {
                        Αν .Κεφαλή Είναι κ Αλλιώς Λάθος "Δεν μπορώ να διαγράψω αυτό το Κόμβο"
                        κ=.ΑφαίρεσηΚεφαλής()
                        Καθαρό κ
                  } Αλλιώς {
                       πίσω=>μπροστά=μπροστά
                       μπροστά=>πίσω=πίσω 
                  }
            }
            Τμήμα ΒάλεΕδώ (κ ως δείκτης, ν ως δείκτης) {
                  πίσω=κ=>πίσω
                  ν=>πίσω=πίσω
                  ν=>μπροστά=κ
                  πίσω=>μπροστά=ν
                  κ=>πίσω=ν
            }
            Συνάρτηση Είναι_Άδειο {
                  = .Κεφαλή Είναι .[Κανένα] ή .Ουρά Είναι .[Κανένα]
            }
            Τμήμα ΔιέγραψεΛίστα {
                   Ενώ Όχι .Είναι_Άδειο(){
                        Για Αυτό {
                               Α=.ΑφαίρεσηΚεφαλής()
                               Καθαρό Α
                        }
                  }
            }
            Διαγραφή {
                  .ΔιέγραψεΛίστα
            }
      Κλάση:
            Τμήμα Συνδεδεμένη_Λίστα {
                  .[Κανένα]->.Κανένα()
                  .Κεφαλή->.[Κανένα]
                  .Ουρά->.[Κανένα]
            }
      }
      Λ=Συνδεδεμένη_Λίστα()
      Κανένα=Λ.Κανένα
      π->Λ.Κόμβος(100)
      Λ.ΒάλεΣτηνΟυρά π
      Αν Όχι Λ.Κόμβος_Κεφαλής Είναι Κανένα Τότε Τύπωσε Λ.Κόμβος_Κεφαλής=>δεδομένο=100
      Για Ι=101 Έως 103 {
            π->Λ.Κόμβος(Ι)
            Λ.ΒάλεΣτηνΟυρά π
            Τύπωσε "Στην Ουρά.....", Ι
      }
      Για Ι=104 Έως 106 {
            π->Λ.Κόμβος(Ι)
            Λ.ΒάλεΣτηΚεφαλή π
            Τύπωσε "Στη Κεφαλή....", Ι
      }
      Τύπωσε "Χρήση του Λ.Κόμβος_Κεφαλής για να δείξουμε από τη Κεφαλή ως την Ουρά"
      π=Λ.Κόμβος_Κεφαλής
      ΜΜ=1
      Επανέλαβε {
            Τύπωσε ΜΜ, π=>δεδομένο
            ΜΜ++
            π=π=>πίσω
      } Μέχρι π Είναι Κανένα
      Τύπωσε "εντάει, τώρα βρές το τρίτο και διέγραψέ το"
      μ1=Λ.Κόμβος_Κεφαλής
      Ι=1 
      δεικτ1=3
      Ενώ Ι<δεικτ1 {
            Αν μ1 Είναι Κανένα Τότε Έξοδος
            μ1=μ1=>πίσω
            Ι++
      }
      Αν Ι<>δεικτ1 Τότε {
            Τύπωσε "Η λίστα έχει λιγότερα από "; δεικτ1;" στοιχεία"
      } Αλλιώς {
            Τύπωσε "Πρώτα θα βάλουμε ένα νέο Κόμβο"
                 Νέος_Κόμβος->Λ.Κόμβος(1000)
                  Λ.ΒάλεΕδώ μ1, Νέος_Κόμβος
                  Λ.ΑφαίρεσηΚόμβου μ1
                  Καθαρό μ1
                  Νέος_Κόμβος=Κανένα
      }
      Τύπωσε "Χρήση του Λ.Κόμβος_Κεφαλής για να δείξουμε από τη Κεφαλή ως την Ουρά"
      ΜΜ=1
      π=Λ.Κόμβος_Κεφαλής
      Επανέλαβε {
            Τύπωσε ΜΜ, π=>δεδομένο
            ΜΜ++
            π=π=>πίσω
      } Μέχρι π Είναι Κανένα
      Τύπωσε "Χρήση του Λ.Κόμβος_Ουράς για να δείξουμε από την Ουρά ως τη Κεφαλή"
      π=Λ.Κόμβος_Ουράς
      Επανέλαβε {
            ΜΜ--
            Τύπωσε ΜΜ, π=>δεδομένο
            π=π=>μπροστά
      } Μέχρι π Είναι Κανένα
      Λ.ΔιέγραψεΛίστα
      Για Ι=50 Έως 80 {
            π->Λ.Κόμβος(Ι)
            Λ.ΒάλεΣτηΚεφαλή π
      }
      Βάλε Δείκτης((Λ))
}
ΔεςΤο
Σωρός
Τύπωσε "Φάση 2, η Λίστα έχει παραδοθεί με 30 κόμβους"
Τύπωσε "Πάτα ένα πλήκτρο"
Βάλε ΚΟΜ$ : Πέτα
Διάβασε Κ
Κανένα=Κ=>Κανένα
π=Κ=>Κόμβος_Ουράς
Επανέλαβε
      Τύπωσε π=>δεδομένο
      π=π=>μπροστά
Μέχρι π Είναι Κανένα
Λίστα
Καθαρό Κ, π, Κανένα
Λίστα
Τύπωσε "Οι τρεις μεταβλητές τώρα δείχνουν μια κενή ομαδα (Group), ενώ πριν είχαν δείκτες σε ομάδες"

}
MODULE LZW {Module FastM2000 {
      plaintext$="TOBEORNOTTOBEORTOBEORNOT"
      Function encodeLZW$(i$) {
            Def long c, d, i, l, o$, w$
            Inventory dict
            For i = 0 to 255 {Append dict , Chr$(i):=i}
            l = i
            i = 1
            w$ = LEFT$(i$,1)
            Repeat{
                  d = 0
                  Repeat {
                        c = d
                        IF i > Len(i$) Then Exit
                        if exist(dict, w$) Then { 
                              d=eval(dict)
                        } Else  Append dict, w$:=l: Exit
                        if d<l Then i += 1 : w$ += Mid$(i$, i, 1)  
                  } Until d >= l
                  l += 1 : w$ = Right$(w$, 1)
                  o$ += Chr$(c Mod 256) + Chr$(c div 256)
            } Until i > Len(i$)
            = o$
      }
      encodeLZW$ = encodeLZW$(plaintext$)
      
      Document Doc$={ Lempel-Ziv-Welch (LZW) compression
      }
      For i = 1 to Len(encodeLZW$) STEP 2
              Doc$= Str$(Asc(Mid$(encodeLZW$,i)) + 256*Asc(Mid$(encodeLZW$,i+1)))
      Next i
      insert to 2,1  Doc$=""  ' remove first space
      
      Doc$={
      }+"Compression ration:"+str$((len(encodeLZW$) div 2)/len(encodeLZW$)*100, " ##")+{%
      }
      Function decodeLZW$(i$) {
            Def c, i, l, o$, t$, w$
            Inventory Dict
            For i = 0 to 255 {Append dict , i:=chr$(i)}
            l = i
            c = Asc(i$) + 256*Asc(Mid$(i$,2))
            w$ = dict$(c)
            o$ = w$
            IF Len(i$) < 4 Then = o$
            For i = 3 to Len(i$) STEP 2 {
                  c = Asc(Mid$(i$,i)) + 256*Asc(Mid$(i$,i+1))
                  IF c < l Then {
                        t$ = dict$(c)
                  } Else t$ = w$ + LEFT$(w$,1)
                  o$ += t$
                  Append dict, l:=w$ + LEFT$(t$,1)
                  l += 1 : w$ = t$
            }
            = o$
      }
      Doc$=decodeLZW$(encodeLZW$)+{
      }
      Clipboard Doc$
      Report Doc$
}
FastM2000
}
MODULE UTF8 {Module checkit {
      linespace 60
      Form ! 60,45
      Cls,0
      Report 2, "Read a file character by character/UTF8"
      \\ prepare a file
      \\ Save.Doc and Append.Doc  to file, Load.Doc and Merge.Doc from file
      Report ! 4 ' set 4 to tab size
      Report {
            	The task of this module is simple a reading one by one char, from a UTF8 encoded file. We can save and read entire files in UTF8 encoding, but here we want to  save a file as UTF8 and then read one by one all characters as UTF8 encoded, and diplay them (after converted to UTF-16LE, from a ready made function)
            	We have to read more than one byte to make it one character. But maybe we have less, so we have to stop reading, if that happen. So when we need more we try to get more, and maybe we get error. We use a Try block to get the error in the code, and do something for it.
            	We use buffers as memory area to get the data at a predefined length. So when we use:
            	Get #file_Handler, two
            	intrerpreter check that two is a buffer, get the length and try to get the same length of bytes to that buffer. Each buffer have a base structure and maybe a count value, of how many of them can be stored. The following statement say that the base structure is a byte and we have two of them
            	Buffer Two as byte*2
            	The variable Two is a reference to an object. Two(0) is the real address of offset 0, of buffer two.
            	Here we don't use address, only offsets. We can read using Eval() the byte at any offset, included in the buffer, unless we get an error. So Eval(two, 0) return the byte as an assign value (0 to 255). Also we can use the string reading, Eval$(two,0,2) which return a string with 2 bytes, from offset 0, from buffer referred by two.
            	The following statement perform a memory copy (twice, one to the string and one to the source), with control over the offsets and lengths.
            	Return Bytes, 1:=Eval$(three, 0, 3)
            	So we put from offset 1 (has base structure bytes, so is the second byte), 3 bytes from buffer referred by three.
            	Please use a proper font if you didn't see some letters (use Font "fontname",  check font with ? fontname$)
            	Also check the Choose.Font statement
            }
      document a$
      a$={First Line
            Second line 𐐷
            Third Line
            Ελληνικά Greek Letters
            Γιω̃ργος diacritic (U+303)
            1234 ברוכים הבאים abc
            yä®€
            成长汉
            }
      Save.Doc a$, "checkthis.txt", 2  ' 2 for UTF-8
      b$="*"
      final$=""
      buffer Clear bytes as byte*16
      Buffer One as byte
      Buffer Two as byte*2
      Buffer Three as byte*3
      Locale 1033
      Fall=100/FileLen("checkthis.txt")
      open "checkthis.txt" for input as #f
      seek#f, 4 ' skip BOM
      While b$<>"" {
            Print Over $(1), ~(11), seek(#f)/Fall
            GetOneUtf8Char(&b$)
            final$+=b$
      }
      Print Over $(1), ~(15), "reading done........."
      close #f
      Print
      \\ from cursor settting, Report get the 
      Cursor 20
      Report final$, width-20-8
      Print
      Rem Print #-2, final$
      Document Final$ ' upgrade
      for i=1 to doc.par(final$)
            print paragraph$(final$,i)
      next
      next
      Sub GetOneUtf8Char(&ch$)
            ch$=""
            if Eof(#f) then Exit Sub
            Get #f, One
            Return Bytes, 0:=Eval(one, 0)
            local mrk=Eval(one, 0)
            Try ok {
                  If Binary.And(mrk, 0xE0)=0xC0 then {
                        Get #f,one
                        Return Bytes, 1:=Eval$(one, 0,1) 
                        ch$=Eval$(Bytes, 0, 2)
                  } Else.if Binary.And(mrk, 0xF0)=0xE0 then {
                        Get #f,two
                        Return Bytes, 1:=Eval$(two,0,2)
                        ch$=Eval$(Bytes, 0, 3)
                  } Else.if Binary.And(mrk, 0xF8)=0xF0 then {
                        Get #f,three
                        Return Bytes, 1:=Eval$(three, 0, 3)  
                        ch$=Eval$(Bytes, 0, 4)
                  } Else ch$=Eval$(Bytes, 0, 1)
            }
            if Error or not ok then ch$="" : exit sub
            ch$=string$(ch$ as Utf8dec)
      End Sub
}
checkit
Italic 1 : Print Over "Press any key to return to Info": Italic 0
Push Key$ : Drop
Keyboard "info"+chr$(13)
}
MODULE RF {Module checkit {
      \\ prepare a file
      \\ Save.Doc and Append.Doc  to file, Load.Doc and Merge.Doc from file
      document a$
      a$={First Line
            Second line
            Third Line
            Ελληνικά Greek Letters
            }
      Save.Doc a$, "checkthis.txt", 2  ' 2 for UTF-8
 
      Buffer1=Buffer("checkthis.txt")
      Print Len(Buffer1)=Filelen("checkthis.txt")
      b$=String$(Eval$(Buffer1, 0) as UTF8Dec)
      Report b$
      openfile$=FILE$("text file","txt")
      Merge.doc a$, openfile$
      Edit.Doc a$
}
checkit
}
MODULE RFL {\\ read a file line by line
Module checkit {
      \\ prepare a file
      document a$
      a$={First Line
            Second line
            Third Line
            }
      Save.Doc a$, "checkthis.txt", 0  ' 0 for UTF-16LE
      Flush
      Open "checkthis.txt" For Wide Input as #F
      Seek #f, 3
      While not Eof(#f) {
            Data Seek(#f)
            Line Input #F, b$
            Print  b$
      }
      Close #f
      Dim  Index()
      \\ copy stack to index(), flush stack
      Index()=Array([])
      \\ change base to base 1
      Dim  Base 1, Index(len(index()))
      Open "checkthis.txt" For Wide Input as #F
            Seek#F, Index(2)
            Line Input #F, b$
            Print b$  ' print second line
      Close #f
      \\ prepare Ansi file
      Print "Ansi File"
      Save.Doc a$, "checkthis.txt",  1033  ' we use specific locale
      Flush \\ flush the stack to get indexes
      oldlocale=locale
      locale 1033
      \\ no Wide clause
      Open "checkthis.txt" For  Input as #F
      While not Eof(#f) {
            Data Seek(#f)
            Line Input #F, b$
            Print  b$
      }
      Close #f
      Dim  Index()
      \\ copy stack to index(), flush stack
      Index()=Array([])
      \\ change base to base 1
      Dim  Base 1, Index(len(index()))
      Open "checkthis.txt" For Input as #F
            Seek#F, Index(2)
            Line Input #F, b$
            Print b$  ' print second line
      Close #f
      locale oldlocale
}
checkit
}
MODULE PERMALL {Module Checkit {
      Global a$
      Document a$
      Module Permutations (s as array){
            Module Level (n, s, h)   {
                  If n=1 then {
                        m1=each(h)     
                        while m1 {
                              Print Array$(m1);" ";
                        }
                         Print Array$(S)
                         ToClipBoard()
                  } Else {
                        for i=1 to len(s) {
                              call Level n-1, cdr(s),  cons(h, car(s))
                              s=cons(cdr(s), car(s))
                        }  
                  }
                  Sub ToClipBoard()
                        local m=each(h)
                        Local b$=""
                        While m {
                              b$+=If$(Len(b$)<>0->" ","")+Array$(m)+" "
                        }
                        b$+=If$(Len(b$)<>0->" ","")+Array$(s,0)+" "+{
                        }
                        a$<=b$   ' assign to global need <=
                  End Sub
            }
            If len(s)=0 then Error "No items to make permutations"
            Head=(,)
            Call Level Len(s),  s, Head
      }
      Clear a$
      Permutations (1,2,3,4)
      Permutations (100, 200, 500)
      Permutations ("A", "B", "C","D")  
      Permutations ("DOG", "CAT", "BAT")    
      ClipBoard a$
}
Checkit
}
MODULE PERMSTEP {Module StepByStep {
    Function PermutationStep (a as array) {
          c1=lambda (&f, a) ->{
                =a
                f=true
          }
          m=len(a)
          if m=0 then Error "No items to make permutations"
          c=c1
          While m>1
                c1=lambda c2=c,p, m=(,) (&f, a, clear as boolean=false) ->{
                      if clear then m=(,)
                      if len(m)=0 then m=a
                      =cons(car(m),c2(&f, cdr(m)))
                      if f then f=false:p++:  m=cons(cdr(m), car(m)) : if p=len(m) then p=0 : m=(,):: f=true
                }
                c=c1  
                m--    
          End While
          =lambda c, a (&f, clear as boolean=false) -> {
                =c(&f, a, clear)
          }
    }
    k=false
    StepA=PermutationStep((1,2,3,4))
    while not k {
          Print StepA(&k) 
    }
    k=false
    StepA=PermutationStep((100,200,300))
    while not k {
        Print StepA(&k) 
    }
    k=false
    StepA=PermutationStep(("A", "B", "C", "D"))
    while not k {
        Print StepA(&k) 
    }
    k=false
    StepA=PermutationStep(("DOG", "CAT", "BAT"))
    while not k {
        Print StepA(&k) 
    }
    k=false
    once=true
    Print "Next Start"
    Print StepA(&k, True)
    while not k {
          Print StepA(&k)
    }
}
StepByStep
}
MODULE FACT {Cls , 0
Report {
	Factorial Task
	Definitions
               • The factorial of   0   (zero)   is defined as being   1   (unity).
               • The   Factorial Function   of a positive integer,   n,   is defined as the product of the sequence:
                                                                      n,   n-1,   n-2,   ...   1 
                                                                      
}
Cls, row
Module CheckIt {
      Locale 1033 ' ensure #,### print with comma
      Function factorial (n){
            If n<0 then Error "Factorial Error!"
            If n>27 then Error "Overflow"
 
            m=1@:While n>1 {m*=n:n--}:=m
      }
      Const Proportional=4
      Const ProportionalLeftJustification=5
      Const NonProportional=0
      Const NonProportionalLeftJustification=1
      For i=1 to 27 
      \\ we can print over (erasing line first), without new line at the end
      \\ and we can change how numbers apears, and the with of columns
      \\ numbers by default have right justification
      \\ all $() format have temporary use in this kind of print.
      Print Over $(Proportional),$("\f\a\c\t\o\r\i\a\l\(#\)\=",15), i, $(ProportionalLeftJustification), $("#,###",40), factorial(i)
      Print        \\ new line
      Next i
}
Checkit
}
MODULE TTT {Cls
Report {
      Tic Tac Toe
      Player vs Computer
      (Computer may loose. Find when)
      
}

Module Tic.Tac.Toe {
      Dim Board$(1 to 3, 1 to 3)=" "
      WinGame=False
      p=Board$()
      RandomPosition=lambda -> {
            =(random(1,3), random(1,3))
      }
 
      BoardItemEmpty=Lambda p (x, y) -> {
            =Array$(p, x, y)=" "
      }
      BoardSetItem=Lambda p (x, y, w$) -> {
            link p to a$()
            a$(x, y)=w$
      }
      T=9
      R=0
      C=0
      Repeat {
            Print "Computer Move:"
            CompMove()
            T--
            DrawBoard()
            CheckWin()
            if WinGame Then Print "Computer Win": Exit
            if T=0 then exit
            Repeat {
                  GetRowCol("Input Row", &R)
                  GetRowCol("Input Column", &C)
                  If BoardItemEmpty(R,C) then call boardsetitem(R,C,"O") : exit 
            } Always
            T--
            DrawBoard()
            CheckWin()
            if WinGame Then Print "You Win": Exit
      } until T=0 or WinGame
      Sub DrawBoard()
      Print "R/C 1 2 3"
      Print " 1) "; Board$(1,1);"|";Board$(1,2);"|";Board$(1,3)
      Print "    -+-+-"
      Print " 2) "; Board$(2,1);"|";Board$(2,2);"|";Board$(2,3)
      Print "    -+-+-"
      Print " 3) "; Board$(3,1);"|";Board$(3,2);"|";Board$(3,3)
      End Sub
      Sub CheckWin()
            WinGame=false
            local i,j,three$
            For i=1 to 3
                  three$=""
                  For j=1 to 3 : three$+=Board$(i,j) : Next j
                  CheckThree()
                  three$=""
                  For j=1 to 3 :  three$+=Board$(j,i) :Next j
                  CheckThree()
            Next i
            three$=""
            For i=1 to 3 : three$+=Board$(i,i): Next i
            CheckThree()
            three$=""
            For i=1 to 3:three$+=Board$(i,4-i): Next i
            CheckThree()
      End Sub
      Sub CheckThree()
            if instr(three$," ")=0 then  WinGame=WinGame or Filter$(three$, left$(three$,1))=""
      End Sub
      Sub CompMove()
            if T<9 and Board$(2,2)=" " then {
                  call boardsetitem(2,2,"X")
            } Else {
                  local i=3, j=3, found=false
                  if T<=6 then {
                        CompThink("X","X")
                  } 
                  let i=3, j=3
                  If Not found And T<6 then {
                        CompThink("O","X")    
                  }
                  If not found then {
                        Repeat {
                              comp=RandomPosition()
                              If BoardItemEmpty(!comp) then call boardsetitem(!comp, "X") : exit
                        } Always
                  }
            }
      End Sub
      Sub CompThink(Bad$, Good$)
                        While i>0 {
                              j=3
                              While j>0 {
                                    if Board$(i,j)=" " then {
                                          Board$(i,j)=Bad$
                                          CheckWin()
                                          if WinGame then {
                                                 Board$(i,j)=Good$:i=0:j=0: found=true
                                          } Else Board$(i,j)=" "
                                    }
                                    j--
                              }
                              i--
                        }
 
      End Sub
      Sub GetRowCol(What$, &W)
            Print What$;":";
            Repeat {
                  W=Val("0"+Key$)
            } until W>=1 and W<=3
            Print Str$(W,"")
      End Sub
}
Tic.Tac.Toe
}
MODULE GUESS {Module GuessNumber {
      Read Min, Max
      chosen = Random(Min, Max)
      print "guess a whole number between ";Min;" and ";Max
      do
                  \\ we use guess so Input get integer value
                  \\ if we press enter without a number we get error
                  do
                        \\ if we get error then we change line, checking the cursor position
                        If Pos>0 then Print
                        Try ok {
                              input "Enter your number " , guess%
                        }
                  until ok
                  Select Case guess%
                  case  min to chosen-1
                        print "Sorry, your number was too low"
                  case chosen+1 to max
                        print "Sorry, your number was too high"
                  case chosen 
                        print "Well guessed!"
                  else case
                        print "That was an invalid number"
                  end select
      until guess% = chosen
}
GuessNumber 5, 15
}
MODULE GUESS1 {Module QBASIC_Based {
      supervisor:
      GOSUB initialize
      GOSUB guessing
      GOTO continue
 
      initialize:
      \\ Not need to RANDOMIZE TIMER
      \\ we can use Random(1, 100) to get a number from 1 to 100
      n = 0: r = INT(RND * 100 + 1): g = 0: c$ = ""
      RETURN
 
      guessing:
      WHILE g <> r
                INPUT "Pick a number between 1 and 100:"; g
                IF g = r THEN
                    PRINT "You got it!"
                    n ++
                    PRINT "It took "; n; " tries to pick the right number."
                ELSE.IF g < r THEN
                    PRINT "Try a larger number."
                    n ++
                ELSE
                    PRINT "Try a smaller number."
                    n++
                END IF
      END WHILE
      RETURN
 
      continue:
      WHILE c$ <> "YES" AND c$ <> "NO"
          INPUT "Do you want to continue? (YES/NO)"; c$
          c$ = UCASE$(c$)
      END WHILE
      IF c$ = "YES" THEN GOTO supervisor
}
QBASIC_Based
}
MODULE DAY {Print "December 25 is a Sunday in:"
For Year=2008 to 2121 { 
      if  Str$(Date("25/12/"+str$(Year,"")),"w")="1" Then {
            Print Year
      }
}
\\ is the same with this:
Print "December 25 is a Sunday in:"
For Year=2008 to 2121 { 
      if  Str$(Date(str$(Year,"")+"-12-25"),"w")="1" Then {
            Print Year
      }
}
 
}
MODULE FILETIME {Module CheckIt {
      \\ without *for wide output*  we open for ANSI (1 byte per character)
      \\ but here we need it only for the creation of a file
      Open "afile" for output as #f
      Close #f
      Print file.stamp("afile")   'it is a number in VB6 date format.
      \\ day format as for Greece
      Print Str$(File.Stamp("afile"),"hh:nn:ss dd/mm/yyyy") , "utc creation time - by default"
      Print Str$(File.Stamp("afile" ,1),"hh:nn:ss dd/mm/yyyy") , "utc creation time, 1"
      Print  Str$(File.Stamp("afile" ,-1),"hh:nn:ss dd/mm/yyyy"), "local creation time, -1"
      Print Str$(File.Stamp("afile" ,2),"hh:nn:ss dd/mm/yyyy"), "utc write time, 2"
      Print  Str$(File.Stamp("afile" ,-2),"hh:nn:ss dd/mm/yyyy"), "local write time, -2"
}
Checkit
}
MODULE SPEED {Cls,0
Report {
	Time a function
	Using a timer (with the least granularity available) to time how long a function takes to execute
	
	The Test function get one type each time
	
	10000% is Integer 16bit
	
	10000& is Long 32bit
	
	10000@ is Decimal
	
	10000# is Currency
	
	10000~ is Float
	
	10000 is Double (default) 
	
}
cls,row
Module Checkit {
      Module sumtolimit (limit) {
           sum=limit-limit
           n=sum
           n++
           while limit {sum+=limit*n:limit--:n-!}
      }
      Profiler
      sumtolimit 10000%
      Print TimeCount
      Profiler
      sumtolimit 10000&
      Print TimeCount
      Profiler
      sumtolimit 10000#
      Print TimeCount
      Profiler
      sumtolimit 10000@
      Print TimeCount
      Profiler
      sumtolimit 10000~
      Print TimeCount
      Profiler
      sumtolimit 10000
      Print TimeCount
}
Print "Set Slow - more screen refresh - more time to OS"
Set Slow
Checkit
Print "Set Fast - the default"
Set Fast
Checkit
Refresh
Print "Set Fast !  - less screen refresh"
Set Fast !
Checkit
Refresh
Set Fast
}
MODULE STIME {print str$(now,"long time"), time$(now)
}
MODULE SDATE {Print str$(today, "yyyy-mm-dd")
Print str$(today, "dddd, mmm, dd, yyyy")
Print Date$(today, 1033, "dddd, MMM, dd, yyyy")
Print Date$(today, 1036, "dddd, MMM dd, yyyy")
Print Date$(today, 1047, "dddd, MMM dd, yyyy")
Print Date$(today, 1048, "dddd, MMM dd, yyyy")
Module Checkit(locale_id, Locale_out) {
      Enum zones {HAST=-10, HADT,PST, MST, CST, EST, AST, NST=-3.5, UTC=0, WET=0, GMT=0, BST=1,IST=1, CET=1, EET, MSK,MSD}
      INP$="March 7 2009 7:30pm EST"
      dim a$()
      a$()=Piece$(INP$," ")
      date1=date(leftpart$(INP$, a$(3)), locale_id)
      zone=UTC
      Try {
            zone=Eval(a#val$(4))
      }
      date0=date1+time(a$(3))
      Document doc$="Input date:"+{
      }
      doc$= Date$(date0 , Locale_out, "MMMM d, yyyy ")+" "+Lcase$(Time$(date0,1033, "hh:mmtt"))+" "+eval$(zone)+{
      }+"12 hours later:"+{
      }
      m=each(zones)
      while m {
            date2=date1+ctime(time(a$(3)),12+eval(m)-zone,frac(eval(m)-zone)*60,0)      
            doc$=Date$(date2 , Locale_out, "MMMM d, yyyy ")+Lcase$(Time$(date2,1033, "hh:mmtt"))+" "+eval$(m)+{
            }
      }
      Report Doc$
      Clipboard Doc$
}
Checkit 1033, 1036
Checkit 1033, 1032
}
MODULE ENV {Module CheckIt {
      \\ using read only variablles
      Print "Platform: ";Platform$
      Print "Computer Os: "; Os$
      Print "Type of OS: ";OsBit;" bit"
      Print "Computer Name:";  Computer$
      Print "User Name: "; User.Name$
      \\ using WScript.Shell
      Declare objShell "WScript.Shell"
      With  objShell, "Environment" set env ("Process")
      With env, "item" as Env$()
      Print Env$("PATH")
      Print Env$("HOMEPATH")
      Declare objShell Nothing
      \\ using internal Information object
      Declare OsInfo INFORMATION
      With OsInfo, "build" as build, "NtDllVersion" as NtDllVersion$
      Method OsInfo, "GetCurrentProcessSID" as PID$
      Method OsInfo, "IsProcessElevated" as isElevated
      Print "Os build number: ";build
      Print "Nr Dll version: ";NtDllVersion$
      Print "ProcessSID: ";pid$
      Print "Is Process Eleveted: ";isElevated
      Declare OsInfo Nothing
}
Checkit
}
MODULE HELLO {Module CheckIt {
      Declare Simple Form
      \\ we can define form before open
      Layer Simple {
            \\ center Window with 12pt font, 12000 twips width and 6000 twips height
            \\ ; at the end command to center the form in current screen
            Window 12, 12000, 6000;
            \\ make layer gray and split screen 0
            Cls #333333, 0
            \\   set split screen to 3rd line, like Cls ,2 without clear screen
            Scroll Split 2
            Cursor 0, 2
      }
      With Simple, "Title", "Hello Form"
      Function Simple.Click {
            Layer Simple {
                  \\ open msgbox
                  Print Ask("Hello World")
                  Refresh
            }
      }
      \\ now open as modal
      Method Simple, "Show", 1
      \\ now form deleted
      Declare Simple Nothing
}
CheckIt
}
MODULE BUTTON {Module CheckIt {
      Declare Form1  Form
      Declare Label1 Button Form Form1
      Declare Button1 Button Form Form1
      Method Label1,"move", 2000, 2000, 4000, 600
      Method Button1,"move", 2000, 3000, 4000, 600
      With Label1, "Caption" as caption$, "Locked", true, "Caption" as cap
      With Button1, "Caption", "click me", "Default", True   ' make this the default control
      caption$="There have been no clicks yet"
      m=0
      Function Button1.Click {
                  m++
                  cap=m
      }
      Method Form1, "Show",1
      Declare Form1 Nothing
}
Checkit
}
MODULE INTERACTION {Module CheckIt {
      Declare form1 form
      Declare textbox1 textbox form form1
      Declare buttonInc Button form form1
      Declare buttonRND Button form form1
      Method textbox1, "move", 2000,2000,4000,600
      Method buttonInc, "move", 2000,3000,2000,600
      Method buttonRND, "move", 4000,3000,2000,600
      With form1, "Title", "Rosetta Code: GUI component interaction"
      With textbox1,"vartext" as textbox1.value$, "Prompt", "Value:", "ShowAlways", true
      
      With buttonInc,"Caption","Increment [+]"
      Method buttonInc, "AccKey", "+", opcode:=1
      
      With buttonRND,"Caption","Random [^R]"
      Method buttonRND, "AccKey", "R", ctrl:=true, opcode:=1
      
      textbox1.value$="0"
      Function Local1(new Feed$) {
            \\ this Function can be used from other Integer 
            \\ this$ and thispos, exist just before the call of this Function
            local sgn$
            if feed$="" and this$="-" then thispos-- :  exit
            if left$(this$,1)="-" then sgn$="-": this$=mid$(this$, 2)
            if this$<>Trim$(this$)  then  this$=Feed$ :  thispos-- : exit
            If Trim$(this$)="" then this$="0" : thispos=2 : exit
            if instr(this$,"+")>0 and sgn$="-" then this$=filter$(this$, "+") : sgn$=""
            if instr(this$,"-")>0  and sgn$="" then this$=filter$(this$, "-") : sgn$="-"
            if filter$(this$,"0123456789")<>"" then this$=Feed$ :  thispos-- : exit
            if len(this$)>1 then While  left$(this$,1)="0" {this$=mid$(this$, 2)} 
            this$=sgn$+this$
            if this$="-0" then this$="-" : thispos=2
        }
      Function TextBox1.ValidString {
                  \\ this Function called direct from textbox
                  Read  New &this$, &thispos
                  Call Local local1(textbox1.value$)
      }
      Function buttonInc.Click {
               textbox1.value$=str$(val(textbox1.value$)+1, "")
      }
      Function buttonRND.Click {
            If  AsK$("Change Value with random number", "Question", "Yes", "No")="Yes" Then {
                      textbox1.value$=str$(Random(0, 10000), "")
                      After 100 {Try {Method textbox1,"GetFocus"}}
            }
      }
      \\ open modal
      Method form1, "show", 1
      Declare form1 nothing
}
Checkit
}
MODULE INTER2 {\ this is global, but call as local in events, which means with local visibility for identifiers
\\ so thispos and this$ has to exist in caller 's context

Cls, 0
Report {
	You can increment the value if is less from 10
	You can decrement the value if is higher than 0
	If value is 0 then you can write a new value
	You can use enter as click event, or a mouse clik on either button.
} 
Function Global Local1(new Feed$) {
            \\ this function can be used from other Integer 
            \\ this$ and thispos, exist just before the call of this function
            local sgn$
            if feed$="" and this$="-" then thispos-- :  exit
            if left$(this$,1)="-" then sgn$="-": this$=mid$(this$, 2)
            if this$<>Trim$(this$)  then  this$=Feed$ :  thispos-- : exit
            If Trim$(this$)="" then this$="0" : thispos=2 : exit
            if instr(this$,"+")>0 and sgn$="-" then this$=filter$(this$, "+") : sgn$=""
            if instr(this$,"-")>0  and sgn$="" then this$=filter$(this$, "-") : sgn$="-"
            if filter$(this$,"0123456789")<>"" then this$=Feed$ :  thispos-- : exit
            if len(this$)>1 then While  left$(this$,1)="0" {this$=mid$(this$, 2)} 
            this$=sgn$+this$
            if this$="-0" then this$="-" : thispos=2
        }
Module CheckIt {
      Declare form1 form
      Declare textbox1 textbox form form1
      Declare frame1 Image form form1      
      Declare buttonInc Button form form1 Image frame1
      Declare buttonDec Button form form1 Image frame1
      Method textbox1, "move", 2000,2000,4000,600
      Method frame1,  "move", 2000, 3000,4000,600
      Method buttonInc, "move", 0,0,2000,600
      Method buttonDec, "move", 2000,0,2000,600
      With textbox1,"vartext" as textbox1.value$, "Prompt", "Value:" ', "ShowAlways", True
      With buttonInc,"Caption","Increment" 
      With buttonDec,"Caption","Decrement","Locked", True
      with frame1, "visible" as frame1.visible, "tabstop", false
      textbox1.value$="0"
      oldval1=True
      oldval2=False
      
      Function controlIncDec(what$){
            if  oldval1 = not val(what$)<10 then  With buttonInc, "locked",  not val(what$)<10 : oldval1~
            if oldval2= not val(what$)>0 then With buttonDec, "locked", not val(what$)>0: oldval2~
      }
      finishEnter=false      
      Function TextBox1.ValidString {
                  \\ this function called direct from textbox
                  Read  New &this$, &thispos
                  Call Local local1(textbox1.value$)
                  Call Local controlIncDec(this$)
      }
      Function TextBox1.Enable {
            With TextBox1, "Enabled", true
            finishEnter=false
      }
      Function TextBox1.Disable {
            With TextBox1, "Enabled", false
            finishEnter=true
      }
      Function TextBox1.Enter {
            Call Local TextBox1.Disable()
      }
      Function buttonInc.Click {
                if  not finishEnter then Call Local TextBox1.Disable()
               textbox1.value$=str$(val(textbox1.value$)+1, "")
                if val(textbox1.value$)=0 then Call Local TextBox1.Enable()
      }
      function buttonDec.Click {
                if  not finishEnter then Call Local TextBox1.Disable()
                textbox1.value$=str$(val(textbox1.value$)-1, "")     
                if val(textbox1.value$)=0 then Call Local TextBox1.Enable()
      }
      function form1.click {
          frame1.visible=not frame1.visible
      }
      Call Local controlIncDec(textBox1.Value$)
      Method form1, "show", 1
      Declare form1 nothing
}
Checkit
}
MODULE PRTRY {Print "Choose a printer:"; : Printer ?
Print printername$

\\ use printer properties to set number of copies
Printer !

if ask("Is printer on","Printing Test","Yes","No")=1 then
	set slow
	\\ use PAGE 1 for new page Portrait or leave it to produce new page if more lines needed.
	\\  PAGE 0 set page to Landscape
	
	printing on
	
	\\ don't forget to set pen to black.
	Pen 0
	\\ you can define font also
	font "Courier New"
	\\ you can define characters by lines, so Mode (size of character) and Linespace produced automatic
	Form 80, 66
	For I=1 TO 85
	Print I
	Next I
	
	printing off
end if
set fast
}
MODULE ADDMUL {\\ Sum and product of an array
Module Checkit {
      a = (1,2,3,4,5,6,7,8,9,10)
      print a#sum() = 55
      sum = lambda->{push number+number}
      product = lambda->{Push number*number}
      print a#fold(lambda->{Push number*number}, 1), a#fold(lambda->{push number+number},0)
      dim a(2,2) = 5
      Print a()#sum() = 20
}
checkit
}
MODULE MULSH {Module CheckIt {
      Dim Base 1, A(12)
      Mult=lambda (n)-> {
            Flush  ' empty stack
            For i=1 to n : Data i*n : Next i
            =Array([])   ' copy stack in an array, and return a pointer
      }
      i=Each(A())
      Print "  |";
      while i {
            Print Format$("{0:0:-4}",i^+1);
            A(i^+1)=Mult(i^+1)
      }
      Print
      Print "--+"+string$("-",4*12)
      For i=1 to 12 {
            Print Format$("{0:0:-2}|",i); 
            For j=1 to 12 {
                  If len(A(j)())>=i then {
                        Print Format$("{0:0:-4}",A(j)(i-1));
                  } Else Print "    ";
            }
            Print
      }
}
CheckIt

Module CheckIt2 {
      Dim Base 1, A(12)
      Mult=lambda (n)-> {
            Flush  ' empty stack
            For i=1 to n : Data i*n : Next i
            =Array([])   ' copy stack in an array, and return a pointer
      }
      i=Each(A())
      Print "  |";
      while i {
            Print Format$("{0:0:-4}",i^+1);
            A(i^+1)=Mult(i^+1)
      }
      Print
      Print "--+"+string$("-",4*12)
      For i=1 to 12 {
            j=Each(A())
            Print Format$("{0:0:-2}|",i); 
            While j {
                  r1=A(j^+1)
                  If len(r1)>=i then {
                        Print Format$("{0:0:-4}",Array(r1,i-1));
                  } Else Print "    ";
            }
            Print
      }
}
CheckIt2
}
MODULE PA15 {Module Puzzle15 {
\\ BASIC STYLE  FROM COMMODORE BASIC
\\ http://www.rosettacode.org/wiki/15_Puzzle_Game#COMMODORE_BASIC
REM {
I make a function RND() and I set Base for arrays to 1 Also I put some semi colons to Print statement. To be actual BASIC compatible we have to set FOR NEXT like BASIC, because for M2000 the direction defined by the starting-ending values, so always we get at least one time the block between FOR NEXT. So we can use:

SET SWITCHES "+FOR"

But here we don't have to skip FOR NEXT and no STEP clause used.

Also the code is not the best, because we can move from 4 position to 5 (we can't do that with real puzzle) 
}
Escape OFF
Report 1, {
	
	
	Hold down Ctrl+C to exit any time - Escape key not used
	
	
	}
TRY {
            00 BASE 1 : DEF RND(X)=RND
            10 REM 15-PUZZLE GAME
            20 REM COMMODORE BASIC 2.0
            30 REM ********************************
            40 GOSUB 400 : REM' INTRO AND LEVEL
            50 GOSUB 510 : REM' SETUP BOARD
            60 GOSUB 210 : REM' PRINT PUZZLE
            70 PRINT "TO MOVE A PIECE, ENTER ITS NUMBER:"
            80 INPUT X
            90 GOSUB 730 : REM' CHECK IF MOVE IS VALID
            100 IF MV=0 THEN PRINT "WRONG MOVE" : GOSUB 1050 : GOTO 60
            110 D(Z)=X : D(Y)=0
            120 GOSUB 210 : REM' PRINT PUZZLE
            130 GOSUB 950 : REM' CHECK IF PUZZLE COMPLETE
            140 IF PC THEN 160
            150 GOTO 70
            160 PRINT"YOU WON!"
            170 END
            180 REM
            190 REM' *******************************
            200 REM' PRINT/DRAW THE PUZZLE
            210 FOR P=1 TO 16
            220   IF D(P)=0 THEN D$(P)="     " : GOTO 260
            230   S$=STR$(D(P))
            240   N=LEN(S$)
            250   D$(P) = LEFT$("   ",3-N)+S$+"  "
            260 NEXT
            270 PRINT "+-----+-----+-----+-----+"
            280 PRINT "!";D$(1);"!";D$(2);"!";D$(3);"!";D$(4);"!"
            290 PRINT "+-----+-----+-----+-----+"
            300 PRINT "!";D$(5);"!";D$(6);"!";D$(7);"!";D$(8);"!"
            310 PRINT "+-----+-----+-----+-----+"
            320 PRINT "!";D$(9);"!";D$(10);"!";D$(11);"!";D$(12);"!"
            330 PRINT "+-----+-----+-----+-----+"
            340 PRINT "!";D$(13);"!";D$(14);"!";D$(15);"!";D$(16);"!"
            350 PRINT "+-----+-----+-----+-----+"
            360 RETURN
            370 REM
            380 REM' *******************************
            390 REM' INTRO AND LEVEL OF DIFFICULTY
            400 REM PRINT CHR$(147)    ' NOT USED HERE
            410 DIM SH(3) : SH(1)=10 : SH(2)=50 : SH(3)=100
            420 PRINT "15 PUZZLE GAME FOR COMMODORE BASIC 2.0" : PRINT : PRINT
            430 PRINT "PLEASE ENTER LEVEL OF DIFFICULTY,"
            440 PRINT "1(EASY), 2(MEDIUM) OR 3(HARD):";
            450 INPUT V
            460 IF V<1 OR V>3 THEN 440
            470 RETURN
            480 REM
            490 REM' *******************************
            500 REM' BUILD THE BOARD
            510 DIM D(16) : DIM D$(16) : REM' BOARD PIECES
            520 REM' SET PIECES IN CORRECT ORDER FIRST
            530 FOR P=1 TO 15
            540   D(P) = P
            550 NEXT
            560 D(16) = 0 : REM' 0 = EMPTY PIECE/SLOT
            570 Z=16      : REM' Z = EMPTY POSITION
            580 PRINT: PRINT "SHUFFLING PIECES";
            590 FOR N=1 TO SH(V)
            600   PRINT".";
            610   X = INT(RND(0)*4)+1
            620   R = Z+(X=1)*4-(X=2)*4+(X=3)-(X=4)
            630   IF R<1 OR R>16 THEN 610
            640   D(Z)=D(R)
            650   Z=R
            660   D(Z)=0
            670 NEXT
            680 PRINT CHR$(147)
            690 RETURN
            700 REM
            710 REM' *******************************
            720 REM' CHECK IF MOVE IS VALID
            730 MV = 0
            740 IF X<1 OR X>15 THEN RETURN
            750 REM' FIND POSITION OF PIECE X
            760 P=1
            770 IF D(P)=X THEN Y=P : GOTO 810
            780 P=P+1 : IF P>16 THEN PRINT "UH OH!" : STOP
            790 GOTO 770
            800 REM' FIND POSITION OF EMPTY PIECE
            810 P=1
            820 IF D(P)=0 THEN Z=P : GOTO 860
            830 P=P+1 : IF P>16 THEN PRINT "UH OH!" : STOP
            840 GOTO 820
            850 PRINT Y;Z
            860 REM' CHECK IF EMPTY PIECE IS ABOVE, BELOW, LEFT OR RIGHT TO PIECE X
            870 IF Y-4=Z THEN MV=1 : RETURN
            880 IF Y+4=Z THEN MV=1 : RETURN
            890 IF Y-1=Z THEN MV=1 : RETURN
            900 IF Y+1=Z THEN MV=1 : RETURN
            910 RETURN
            920 REM
            930 REM' *******************************
            940 REM' CHECK IF PUZZLE IS COMPLETE / GAME OVER
            950 PC = 0
            960 P=1
            970 IF D(P)<>P THEN RETURN
            980 P=P+1
            990 IF P<16 THEN 970
            1000 PC = 1
            1010 RETURN
            1020 REM
            1030 REM' ******************************
            1040 REM' A SMALL DELAY
            1050 FOR T=0 TO 400
            1060 NEXT
            1070 RETURN
}
\\ SET BACK THE BASE OF ARRAYS
BASE 0
}
Puzzle15
}
MODULE CRYPTO {// https://en.wikipedia.org/wiki/RIPEMD
// The original RIPEMD function was designed in the framework of the EU project RIPE (RACE Integrity Primitives Evaluation) in 1992
// RIPEMD-160 is 160bit cryptographic hash function.

Module Checkit {
	Function Prepare_RiPeMd_160 {
		Dim Base 0,  K(5), K1(5)
		K(0)=0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E
		K1(0)=0x50A28BE6,0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000
		Dim Base 0,r(80), r1(80), s(80), s1(80)
		r(0)=0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
		r(16)=7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
		r(32)= 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
		r(48)=1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
		r(64)=4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
		k=r() : k*=4   ' k is a pointer to array. We have to multiply to make them offsets
		
		r1(0)=5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
		r1(16)=6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
		r1(32)=15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
		r1(48)=8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
		r1(64)=12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
		
		k=r1() : k*=4
		
		s(0)=11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
		s(16)=7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
		s(32)=11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
		s(48)=11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
		s(64)=9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
		
		s1(0)=8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
		s1(16)=9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
		s1(32)=9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
		s1(48)=15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
		s1(64)=8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
		
		Dim Base 0, T(5), TT(5)
		T(0)=lambda ->binary.xor(binary.xor(number,number),number)
		T(1)=lambda (B,C,D)->binary.or(binary.and(B,C), binary.and(binary.not(B), D))
		T(2)=lambda ->binary.xor(binary.or(number, binary.not(number)), number)
		T(3)=lambda (B,C,D)->binary.or(binary.and(B,D), binary.and(C,binary.not(D)))
		T(4)=lambda ->binary.xor(number, binary.or(number, binary.not(number)))
		
		// no need for variables we read form stack with number
		TT(0)=lambda ->binary.xor(number, binary.or(number, binary.not(number)))
		TT(1)=lambda (BB,CC,DD)->binary.or(binary.and(BB,DD), binary.and(CC,binary.not(DD)))	
		TT(2)=lambda ->binary.xor(binary.or(number, binary.not(number)), number)
		TT(3)=lambda (BB,CC,DD)->binary.or(binary.and(BB,CC), binary.and(binary.not(BB),DD))	
		TT(4)=lambda ->binary.xor(binary.xor(number,number),number)
		
		// return of this function is a lambda function
		// all arrays are closures to this lambda
		=lambda K(),K1(),TT(), T(),r(),r1(), s(), s1() (&message$, ansi as boolean=true, ansiid=1033)-> {
			set fast!
			def h0 = 0x67452301, h1 = 0xEFCDAB89, h2 = 0x98BADCFE
			def h3 = 0x10325476, h4 = 0xC3D2E1F0
			def i, j, l, padding, l1, blocks, acc, f64 as boolean=true, oldid
			if ansi then oldid=locale : locale ansiid
			// we use a buffer of 64 bytes
			buffer clear message as byte*64
			l=len(message$)*if(ansi->1,2 )
			if binary.and(l,63)>55 then  padding=64 
			padding+= 64 - (l Mod 64)
			l1=padding+l+1
	
			f64=binary.and(l,63)<>0
	
			blocks=l1 div 64
rem
			Print "blocks:";blocks
			// now prepare the buffer
			PrepareBuffer()
			def decimal  A, B, C, D, E, AA, BB, CC, DD, EE, T, TT
			do
			A  = h0 : B  = h1 : C  = h2 : D  = h3 : E  = h4
			AA = h0 : BB = h1 : CC = h2 : DD = h3 : EE = h4
			for J=0 to 79 {
				JJ=J DIV 16
				PUSH binary.add(Binary.Rotate(binary.add(A,T(JJ)(B,C,D),eval(message ,r(j) as long),k(jj)), s(j)), e)
				A = E : E = D : D = Binary.Rotate(C, 10) : C = B : READ B 
				PUSH binary.add(Binary.Rotate(binary.add(AA,TT(JJ)(BB,CC,DD),eval(message, r1(j) as long),k1(jj)),s1(j)),EE)
				AA = EE : EE = DD : DD = Binary.Rotate(CC, 10) : CC = BB : READ BB
			}
			push binary.add(h1, C, DD)
			h1 = binary.add(h2, D, EE)
			h2 = binary.add(h3, E, AA)
			h3 = binary.add(h4, A, BB)
			h4 = binary.add(h0, B, CC)
			Read h0
			blocks--
rem
			print over $(0,8), blocks : Refresh
			if blocks=0 then exit
			PrepareBuffer()
			always
rem
			print
			buffer ans as byte*20
			// we put ulong (long ar ulong in buffers)
			Return ans, 0:=h0 as long, 4:=h1 as long,8:=h2 as long, 12:=h3 as long, 16:=h4 as long
			=ans
			if ansi then locale oldid
			set fast
			
			Sub PrepareBuffer()
				
				if l-acc>=64 then
					LoadPart(64)
				else.if blocks=1 then
					return message, 0:=string$(chr$(0),32)
					if l-acc=0 and f64 then
						Return message, 56:=l*8 as long, 60 :=binary.shift(l,-29) as long
					else
						Return message, l-acc:=0x80, 56:=l*8 as long, 60 :=binary.shift(l,-29) as long
						if l>acc then LoadPart(l-acc)
					end if
				else
					Return message, l-acc:=0x80
					LoadPart(l-acc)
				end if
			End Sub
			sub LoadPart(many)
				// str$() convert to ansi, one byte per character
				// using 1033 as Ansi language
				if ansi then
					Return message, 0:=str$(mid$(message$,1+acc, many))
				else
					Return message, 0:=mid$(message$, 1+acc, many)
				end if
				acc+=many
			end sub
		}
	}
	Module TestHash (RIPEMD){
		Flush
		// push data to stack of values, as fifo (each entry append to end of stack)
		Data "b3be159860842cebaa7174c8fff0aa9e50a5199f","Rosetta Code"
		Data "9c1185a5c5e9fc54612808977ee8f548b2258d31",""
		Data "0bdc9d2d256b3ee9daae347be6f4dc835a467ffe","a"
		Data "8eb208f7e05d987a9b044a8e98c6b087f15a0bfc","abc"
		Data "5d0689ef49d2fae572b881b123a85ffa21595f36", "message digest"
		Data "f71c27109c692c1b56bbdceb5b9d2865b3708dbc","abcdefghijklmnopqrstuvwxyz"
		Data "b0e20b6e3116640286ed3a87a5713079b21f5189"
		Data "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
		Data "9b752e45573d4b39f4dbd3323cab82bf63326bfb", String$("1234567890",8)
rem		Data "52783243c1697bdbe16d37f97f68f08325dc1528", String$("a",1000000)
		
		While not empty
			Read check$, text$
			Print "RIPEMD160 for ";quote$(Left$(if$(len(text$)>30->left$(text$,27)+"...",  text$),30))
			// pass text$ by reference
			Display(RIPEMD(&text$))
		End While
		
		sub Display(ans)
			local answer$
			for i=0 to len(ans)-1
				answer$+=hex$(eval(ans,i),1)
			next i
			Print lcase$(answer$)
			Print lcase$(answer$)=check$
		end sub
	}
	TestHash Prepare_RiPeMd_160()	
}
Checkit
}
MODULE DIJKSTRA {Module Dijkstra`s_algorithm {
        const max_number=infinity '1.E+306
        GetArr=lambda (n, val)->{
                dim d(n)=val
                =d()
        }
        term=("",0)
        Edges=(("a", ("b",7),("c",9),("f",14)),("b",("c",10),("d",15)),("c",("d",11),("f",2)),("d",("e",6)),("e",("f", 9)),("f",term))
        Document Doc$="Graph:"+{
        }
        ShowGraph()
        Doc$="Paths"+{
        }
        Print "Paths"
        For from_here=0 to 5
                pa=GetArr(len(Edges), -1)
                d=GetArr(len(Edges), max_number)
                Inventory S=1,2,3,4,5,6
                return d, from_here:=0
                RemoveMin=Lambda S, d, max_number-> {
                        ss=each(S)
                        min=max_number
                        p=0
                        while ss
                                val=d#val(eval(S,ss^)-1)
                                if min>val then let min=val : p=ss^ 
                        end while
                        =s(p!)  ' use p as index not key
                        Delete S, eval(s,p)
                }
                Show_Distance_and_Path$=lambda$ d, pa, from_here, max_number (n) -> {
                        ret1$=chr$(from_here+asc("a"))+" to "+chr$(n+asc("a"))
                        if d#val(n) =max_number then =ret1$+ " No Path" :exit
                        let ret$="", mm=n, m=n
                        repeat
                                n=m
                                ret$+=chr$(asc("a")+n)
                                m=pa#val(n)
                        until  from_here=n 
                        =ret1$+format$("{0::-4} {1}",d#val(mm),strrev$(ret$))
                }
                while len(s)>0 
                        u=RemoveMin()
                        rem Print u, chr$(u-1+asc("a"))
                        Relaxed()
                end while
                For i=0 to len(d)-1
                        line$=Show_Distance_and_Path$(i)
                        Print line$
                        doc$=line$+{
                        }
                next
        next
        Clipboard Doc$
        End
        Sub Relaxed()
                local vertex=Edges#val(u-1), i
                local e=Len(vertex)-1, edge=(,), val
                for i=1 to e
                        edge=vertex#val(i)
                        if edge#val$(0)<>"" then \\\\\\ if not edge is term then
                                val=Asc(edge#val$(0))-Asc("a")
                                if d#val(val)>edge#val(1)+d#val(u-1) then  return d, val:=edge#val(1)+d#val(u-1) : Return Pa, val:=u-1
                        end if
                next 
        end sub
        Sub ShowGraph()
                Print "Graph"
                local i
                for i=1 to len(Edges)
                        show_edges(i)
                next
        end sub
        Sub show_edges(n)
                n--
                local vertex=Edges#val(n), line$
                local e=each(vertex 2 to end), v2=(,)
                While e 
                        v2=array(e)
                        line$=vertex#val$(0)+if$(v2#val$(0)<>""->"->"+v2#val$(0)+format$(" {0::-2}",v2#val(1)),"")
                        Print line$
                        Doc$=line$+{
                        }
                end while
        end sub
}
Dijkstra`s_algorithm

}
MODULE ANT {Flush
Set Fast !
Escape off
Esc=False
Form 120,102
Double
Print "Langton's ant"
Print "press right mouse button to draw partial image"
Print "press left mouse button to exit"
Normal
N=100
refresh
Enum CellColor {black=0,white=#FFFFFF}
Enum Direction{North=90, West=180, South=270, East=0}
Function Rotate(cd as Direction, clockwise=true) {
		cd=(cd+if(clockwise->270,90)) mod 360
		=cd  ' return a Direction Enum type
}
 
dim rect(1 to N, 1 to N)=white
cx=N div 3
cy=N div 3
cd=North
rect(cx,cy)=black
endmove=False
m=1
while not endmove
	movecell()
	if m mod 20=0 then if keypress(1) then if ask("Quit")=1 then  Esc=true : exit while
	m++ : if keypress(2) then Disp()
end while
if not Esc then
	Disp(true)
	refresh 40
	a$=key$
end if
Escape ON
Set Fast
keyboard "INFO"+chr$(13)
sub movecell()
	select case rect(cx,cy)
	case black
		cd=Rotate(cd, false) : rect(cx, cy)=white
	case white
		cd=Rotate(cd) : rect(cx, cy)=black
	end select
	select case cd
	case North
		cy--
	case West
		cx--
	case South
		cy++
	case East
		cx++
	end select
	endmove= cx<1 or cx>N or cy<1 or cy>N
end sub
sub disp(clip=false)
	Local Doc$, i, j
	Document Doc$
	for j=1 to N:for i=1 to N
		Doc$=if$(rect(i, j)=White->"_","#")
	next
	Doc$={
	}
	next
	cls
	Print #-2,Doc$
	refresh 1000
	if clip then clipboard Doc$ : Cursor 0, 100 : Print "Done", @(100),"Press any key"
end sub

}
MODULE ANON {\\ Anonymous Functions
curry=lambda (f)->{
        \\ get arguments as a stack object and store reference to s
        \\ f and s are closures to returned anonymous function
        =lambda f, s=[] -> {
                \\ pass arguments [] to f() if any
                \\ pass arguments using a copy of s
                \\ passing done using ! symbol before a stack object
                =f(![], !stack(s))
        }
}
sum=lambda -> {
        s=0   \\ number pop numbers from stack
        while not empty : s+=number:end while
        =s
}
curried=curry(sum, 5,7,9)
Print curried(1,2,3)=5+7+9+1+2+3  ' true
Print curried(10,20,30)=5+7+9+10+20+30 ' true
Print curried()=5+7+9  ' true
curried2=curry(sum)
Print curried2()=0
curried2=curry(sum, 10,20,30,40)
Print curried2(1,2,3,4)=110
\\ make a closure for a lambda function
disp=lambda title$="my title:" (that$) -> {
        Print title$;that$
}
Call disp("Anonymous Function")
Dim A(10)
A(3)=disp
ret=A(3)("Call from array")
Inventory Abc="100":=disp
ret=Abc("100")("Call from inventory")
ret=lambda title$="another tilte1:" (that$)->{Print title$;that$}("call anonymous function")
ret=lambda title$="another tilte2:" (that$)->{
        Print title$;that$
}("call anonymous function")
}
MODULE CHAIN {\\ Chain of Responsibility design pattern 
\\ a Class: part in Class Function removed from object after first copy (when copied from Class function)
\\ So constructors are not part of Logger Group (Group is the type of a user object in M2000)
Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
		}
Class Logger {
Private:
logMask=0&
Group NextLogger
Public:
	Module Final Message(msg$, severity) {
		If not Valid(.NextLogger=>Null) Then
			.NextLogger=>Message msg$, severity
		End If
		If Binary.And(.logMask ,severity)<>0 Then
			.WriteMessage msg$
		End If
	}
	Module WriteMessage (m$) {
		Print m$
	}
	Module Final SetNext ( p as pointer) {
		.NextLogger<=p
	}
	Function Final Dispose {
		x=valid(.NextLogger=>Dispose())
		Clear .NextLogger
	}
Class:
	Module Logger (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
}
Class ConsoleLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to console: " + m$
	}
Class:
	Module ConsoleLogger {
		This=Logger(![])
	}
}
Class EmailLogger {
	Module  Final WriteMessage (m$) {
		Print "Sending via email: " + m$
	}
Class:
	Module EmailLogger {
		This=Logger(![])
	}
}
Class FileLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to Log File: " + m$
	}
Class:
	Module FileLogger {
		This=Logger(![])
	}
}
A=ConsoleLogger(All)
B=EmailLogger(FunctionalMessage+FunctionalError)
C=FileLogger(Warning+Error)
C.SetNext Pointer(B)
B.SetNext Pointer(A)


C.Message "Entering function ProcessOrder().", Debug
C.Message "Order record retrieved.", Info
C.Message "Customer Address details missing in Branch DataBase.", Warning
C.Message "Customer Address details missing in Organization DataBase.", Error
C.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
C.Message "Order Dispatched.",FunctionalMessage
Call C.Dispose()  ' no need we use weak refrences (automatic created If poiner produced for named groups
}
MODULE CHAIN1 {\\ Chain of Responsibility design pattern 

Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
		}
Class Logger {
Private:
	logMask=0&
	Group NextLogger
	Module super (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
Public:
	Module Final Message(msg$, severity) {
		If not Valid(.NextLogger=>Null) Then
			.NextLogger=>Message msg$, severity
		End If
		If Binary.And(.logMask ,severity)<>0 Then
			.WriteMessage msg$
		End If
	}
	Module WriteMessage (m$) {
		Print m$
	}
	Module Final SetNext ( p as pointer) {
		.NextLogger<=p
	}
	Function Final Dispose {
		x=valid(.NextLogger=>Dispose())
		Clear .NextLogger
	}
}
Class MessageTypeHolder {
	message$="nothing yet"
	Module  Final WriteMessage (m$) {
		Print .message$+": " + m$
	}
}
Class ConsoleLogger as  MessageTypeHolder as Logger {
Class:
	Module ConsoleLogger {
		.message$<="Writing to console"
		.super
	}
}
Class EmailLogger as MessageTypeHolder  as Logger {
Class:
	Module EmailLogger {
		.message$<="Sending via email"
		.super
	}
}
Class FileLogger as MessageTypeHolder  as Logger {
Class:
	Module FileLogger {
		.message$<="Writing to Log File"
		.super
	}
}
A=ConsoleLogger(All)
B=EmailLogger(FunctionalMessage+FunctionalError)
C=FileLogger(Warning+Error)
C.SetNext Pointer(B)
B.SetNext Pointer(A)

C.Message "Entering function ProcessOrder().", Debug
C.Message "Order record retrieved.", Info
C.Message "Customer Address details missing in Branch DataBase.", Warning
C.Message "Customer Address details missing in Organization DataBase.", Error
C.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
C.Message "Order Dispatched.",FunctionalMessage
Call C.Dispose()  ' no need we use weak refrences (automatic created If poiner produced for named groups
}
MODULE CHAIN2 {\\ Chain of Responsibility design pattern  2
\\ example from https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
\\ This example use real pointers to groups
\\ so we have one group, the logger and two groups inside it in a chain
Form 80,50
Global enum LogLevel    {
		None = 0,
		Info = 1, 
		Debug = 2, 
		Warning = 4,
		Error = 8,   
		FunctionalMessage = 16, 
		FunctionalError = 32, 
		All = 63
}
Class Logger {
Private:
	logMask=0&
	Group NextLogger
Public:
	Module Final Message(msg$, severity) {
	If Binary.And(.logMask ,severity)<>0 Then
		.WriteMessage msg$
	End If
	If not Valid(.NextLogger=>Null) Then
		.NextLogger=>Message msg$, severity
	End If
}
Module WriteMessage (m$) {
	Print m$
}
 Module Final SetNext ( p as pointer) {
	If  valid(.NextLogger=>Null) Then
		.NextLogger<=p
	else
		.NextLogger=>SetNext p
	End If
}
Function Final Dispose {
	x=valid(.NextLogger=>Dispose())
	Clear .NextLlogger
}
Class:
	Module Logger (z) {
		.logMask<=z
		Class EmptyLogger {
			Null
		}
		.NextLogger<=Pointer(EmptyLogger())
	}
}
Class ConsoleLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to console: " + m$
	}
Class:
	Module ConsoleLogger {
		This=Logger(![])	'  ![] pass current stack of values to function Logger()
	}
}
Class EmailLogger {
Module  Final WriteMessage (m$) {
Print "Sending via email: " + m$
}
Class:
	Module EmailLogger {
		This=Logger(![])
	}
}
Class FileLogger {
	Module  Final WriteMessage (m$) {
		Print "Writing to Log File: " + m$
	}
Class:
	Module FileLogger {
		This=Logger(![])
	}
}
Logger->ConsoleLogger(All)


Logger=>SetNext Pointer(EmailLogger(FunctionalMessage+FunctionalError))
Logger=>SetNext Pointer(FileLogger(Warning+Error))


Logger=>Message "Entering function ProcessOrder().", Debug
\\ better to use a For object {} structure
For Logger {
	.Message "Order record retrieved.", Info
	.Message "Customer Address details missing in Branch DataBase.", Warning
	.Message "Customer Address details missing in Organization DataBase.", Error
	.Message "Unable to Process Order ORD1 Dated D1 For Customer C1.", FunctionalError
	\\ we can use Logger=>Message also
	Logger=>Message "Order Dispatched.",FunctionalMessage
	call .Dispose() 
}
Logger->0&   ' or Clear Logger
}
MODULE PYTH {MODULE Pythagoras_tree {
	CLS 5, 0  ' MAGENTA, NO SPLIT SCREEN
	PEN 14   ' YELLOW
	\\ code from zkl/Free Basic
	LET w = scale.x, h = w * 11 div 16
	LET w2 = w div 2, diff = w div 12
	LET TreeOrder = 6
	pythagoras_tree(w2 - diff, h -10, w2 + diff, h -10, 0)
 
	SUB pythagoras_tree(x1, y1, x2, y2, depth)
 
	    IF depth > TreeOrder THEN EXIT SUB
 
	    LOCAL dx = x2 - x1, dy = y1 - y2
	    LOCAL x3 = x2 - dy, y3 = y2 - dx
	    LOCAL x4 = x1 - dy, y4 = y1 - dx
	    LOCAL x5 = x4 + (dx - dy) / 2
	    LOCAL y5 = y4 - (dx + dy) / 2
	    MOVE x1, y1
	    DRAW TO x2, y2
	    DRAW TO x3, y3
	    DRAW TO x4, y4
	    DRAW TO x1, y1
	    pythagoras_tree(x4, y4, x5, y5, depth +1)
	    pythagoras_tree(x5, y5, x3, y3, depth +1)
 
	END SUB
}
Pythagoras_tree
}
MODULE PYTH1 {MODULE Pythagoras_Example{
	CLS 5, 0  	' MAGENTA, split line = 0  
	PEN 14		' YELLOW
	// Linux smoothing not work (we can use the statement but without effect)
	IF ISWINE ELSE SMOOTH ON
	\\ PYTHAGORAS TREE
	// by definition all variables ar type of a double
	GLOBAL CONST p4=PI/4, p2=PI/2, s2=SQRT(2)/2
	CONST right=1
	MODULE center_p (r, t){
		CONST p4
		MODULE pythagoras_tree (r, dx, depth) {
			CONST p4, p2,s2
			r2=r-p2
			DRAW ANGLE r, dx
			DRAW ANGLE r2, dx
			DRAW ANGLE r, -dx
			DRAW ANGLE r2, -dx
			IF depth>10 THEN EXIT
			s3=dx*s2
			depth++
			STEP ANGLE r+p4, s3*2
			CALL pythagoras_tree r-p4,  s3, depth
			STEP ANGLE r, -dx-s3
			STEP ANGLE r, s3
			STEP ANGLE r+p4, -s3
			CALL pythagoras_tree r+p4,  s3, depth
			STEP ANGLE r-p4, s3		
		}	
		MOVE SCALE.X/2, SCALE.Y/2	
		STEP ANGLE PI-p4+r, t*s2
		CALL pythagoras_tree r, t, 1
	}
	r=PI/3
	pixels=MIN.DATA(SCALE.X, SCALE.Y)/TWIPSX/8
	REFRESH 1000/25
	// FIRST TREE
	CALL center_p r, pixels*TWIPSX
	\\ SECOND TREE
	CALL center_p r+PI, pixels*TWIPSX
	REFRESH 50
	CopyDrawingToClipboard()
	REM CopyImageToClipboard()
	END
	
	SUB CopyImageToClipboard()
		LOCAL scr$=""
		MOVE 0,0
		COPY SCALE.X, SCALE.Y TO scr$
		CLIPBOARD scr$
	END SUB
	SUB CopyDrawingToClipboard()
		LOCAL scr
		DRAWING {
			PEN 0 {
				CALL center_p r, pixels*TWIPSX
				CALL center_p r+PI, pixels*TWIPSX
			}
		} AS scr
		CLIPBOARD scr
		REM LIST
		REPORT right,"A COPY  AS DRAWING TO CLIPBOARD DONE"
	END SUB
	
}
Pythagoras_Example
}
MODULE RPN {Module Rpn_Calc {  

	\\ insert a new line after rem to use hidden statements 
	Rem Form 80,60
	function rpn_calc(a$) {
		Print "Calc RPN:"+a$
		def m=0
		dim token$()
		token$()=piece$(a$," ")
		l=len(token$())
		dim type(l)=0, reg(l)
		where=-1
		for i=0 to  l-1
			c=val(token$(i),"",m)
			if m>-1 then
				where++
				reg(where)=c
			else
				reg(where-1)=eval(str$(reg(where-1))+token$(i)+str$(reg(where)))
				where--
			end if
			inf=each(reg(),1, where+1)
			while inf
				export$<=token$(i)+" ["+str$(inf^,"")+"] "+ str$(array(inf))+{
				}
				token$(i)=" "
			end while
		next i
		=reg(0)
	}
	Global export$
	document export$
	example1=rpn_calc("3 4 2 * 1 5 - 2 3 ^ ^ / +")
	example2=rpn_calc("1 2 + 3 4 + ^ 5 6 + ^")
	Print example1, example2
	Rem	Print #-2, Export$
	ClipBoard Export$
}
Rpn_Calc
}
MODULE BANKER {\\ No2
\\ First publish in Rosetta.org
\\ http://www.rosettacode.org/wiki/Banker%27s_algorithm#M2000_Interpreter
Module BankerAlgo {
      Form ! 80, 44   ' we can use Form without ! to display bigger form. 
      Cls 5
      Pen 14
      Function Request(FromWhere as Inventory, What$, Many as long)  {
            =FromWhere(What$)-FromWhere(What$+"_Request")-Many>=0
      }
      Function RequestPreset(FromWhere as Inventory, What$, Many as long)  {
            =FromWhere(What$+"_Request")-Many>=0
      }
      Function Need(FromWhere as Inventory, What$, Many) { 
            =FromWhere(What$ + "_max")-FromWhere(What$)-Many>=0
      }
      \\ code for sub can be found from parent module/function (here parent as in code, not as in call)
      Function NewProcess {
            Inventory Process
            ApplyResources(Process)   ' sub need more arguments and read from current stack
            =Process
      }
      Inventory System, Processes 
      \\ Recource, Max, Available
      ApplyResources(System, "A", 6, 3,"B", 5,1,"C", 7, 1, "D", 6, 2)
      \\ Recource, Max, Available
      Append Processes, "P1":=NewProcess("A", 3, 1, "B", 3, 2, "C", 2, 2, "D", 2,1)
      Append Processes, "P2":=NewProcess("A", 1, 1, "B", 2, 0, "C", 3, 3, "D", 4,3)
      Append Processes, "P3":=NewProcess("A", 1, 1, "B", 3, 2, "C", 5, 1, "D", 0,0)
      Status(True) ' show all process, available resource and max
      SafeState=True
      Print "Current Status"
      RequestResource() ' display Safe State
      RequestResource("P2", "D", 1) ' display Safe State
      RequestResource("P1", "A", 1, "D", 1) ' display Safe State
      RequestResource("P1", "C", 1, "D", 1) ' display Too many resources ...
      RequestResource("P2", "B", 1) ' display Unsafe State
      RequestResource("P3", "C", 1)  ' display Safe State
      Status()
      \\ Second Example
      Clear System, Processes
      ApplyResources(System, "A", 10, 3)
      Append Processes, "P1":=NewProcess("A", 9, 3)
      Append Processes, "P2":=NewProcess("A", 4, 2)
      Append Processes, "P3":=NewProcess("A", 7, 2)
      Status(True) ' show all process, available resource and max    
      Print "Current Status"
      RequestResource() ' display Safe State
      \ Third Example
      Clear System
      ApplyResources(System, "A", 10, 2)
      Return  Processes,"P1":=NewProcess("A", 9,4)
      Status(True) ' show all process, available resource and max    
      Print "Current Status"
      RequestResource() ' display UnSafe State       
      Sub Respond()
            If SafeState Then {
                  Pen 15 {Print "Safe State"}
            } Else Pen 13 {Print "Unsafe State"}
      End Sub
      Sub WaitForKey()
            Pen 11 {Print "Press a key"}
            local a$=key$
      End Sub
      Sub RequestResource(ProcessName$="" )
            SafeState=True
            If ProcessName$="" Then CheckNewState(&SafeState) : Respond() : Print : WaitForKey():Exit Sub
            Local pro=Processes(ProcessName$), ResourceName$, many as long
            ClearAllRequest(pro)
            Local skip=False
            While Match("SN") {
                  Read ResourceName$, many
                  Print  Format$("Claim {1} for type {0} resource ",ResourceName$, many)
                  If skip Then Continue
                  If Request(System, ResourceName$, many) Then {
                        If Need(pro, ResourceName$, many) Then { 
                              Return pro, ResourceName$+"_Request":=many
                              Return System, ResourceName$+"_Request":=-many
                        } Else {
                              Print "Too many Recources "+ResourceName$+" for Process "+ProcessName$  : Skip=True
                        }
                  } Else Print "Too many Recources for System" : Skip=True
                  If Skip Then exit
            } 
            If skip Else  CheckNewState(&SafeState) : Respond()
            Print  ' just a new line
            WaitForKey()
      End Sub
      Sub ApplyResources(Where as Inventory, What$, MaxValue, InitialValue)
            Repeat {
                  If Not Exist(Where, What$) Then {
                        Append Where, What$:=InitialValue, What$+"_max":=MaxValue, What$+"_Request":=0
                  }
                  If not Match("SNN") Then Exit
                  Read What$, MaxValue, InitialValue
            }  Always
      End Sub
      Sub ClearAllRequest(Where  as Inventory)
            Local M=Each(Where)
            While M {
                  If Instr(Eval$(M, M^),"_")=0 Then {
                        Return Where, Eval$(M,M^)+"_Request":=0
                  }
            }
      End Sub
      Sub PrintResources(Where  as Inventory)
            Local M=Each(Where)
            While M {
                  If Instr(Eval$(M, M^),"_")=0 Then Print Eval$(M, M^)+"="+Eval$(M),
            }
            Print
      Exit Sub
      Sub PrintMax(Where  as Inventory)
            Local M=Each(Where)
            While M {
                  If Instr(Eval$(M, M^),"_max")>0 Then Print LeftPart$(Eval$(M, M^), "_")+"="+Eval$(M),
            }
            Print
      Exit Sub
      Sub Status(Ok as boolean=False)
            Print "Total System Resources"
            PrintMax(System)
            Print "Available Resources in System"
            PrintResources(System)
            If Not Ok Then WaitForKey(): Exit Sub
            Local  M=Each(Processes)
            While M {
                  Print "Process "+Eval$(M, M^)
                  PrintResources(Processes(M^!))  ' give index M^ as Key index number (using !)
                  Print "Maximum Resources for "+Eval$(M, M^)
                  PrintMax(Processes(M^!))
            }
      End Sub
      Sub CheckNewState(&Ok)
            local M=Each(Processes), M1, count=len(Processes), alive(0 to count-1)=1
            Local Z, Recource$, safe as boolean=false
            While count {
                  safe=false
                  While M {
                        If alive(M^) Then {
                              Z=Processes(M^!)
                              M1=Each(Z) 
                              safe=True 
                              While M1 {
                                    Recource$=Eval$(M1, M1^)
                                    If Instr(Recource$,"_")=0 Then {
                                         safe=System(Recource$)+System(Recource$+"_Request") >= Z(Recource$ + "_max") - Z(Recource$)-Z(Recource$ + "_Request")
		               }
                                    If not safe Then exit
                              }
                              If safe Then {
                                    print format$("Process {0} is executing", M^+1)
                                    alive(M^)=0
                                    count--
                                    M1=Each(Z) 
                                    While M1 {
                                          Recource$=Eval$(M1, M1^)
                                          If Instr(Recource$,"_")=0 Then {
                                                Return System, Recource$+"_Request":= System(Recource$+"_Request") + Z(Recource$) + Z(Recource$+"_Request")
                                                Return Z, Recource$+"_Request":=0
                                          }
                                    }
                              }
                        }
                  }
                  If safe Else exit
            }
            Ok=safe
            ClearAllRequest(System)
      End Sub
}
BankerAlgo
keyboard "Info"+chr$(13)
}
MODULE MATMUL {// http://www.rosettacode.org/wiki/Matrix_multiplication#M2000_Interpreter
Module CheckMatMult2 {
	// Matrix Multiplication
	// pass arrays by reference
	// if we change a passed array here, to a new array then this change also the reference array.
	Function MatMul(&a(),&b()) {
		if dimension(a())<>2 or dimension(b())<>2 then Error "Need two 2D arrays "
		let a2=dimension(a(),2), b1=dimension(b(),1)
		if a2<>b1 then Error "Need columns of first array equal to rows of second array"
		let a1=dimension(a(),1), b2=dimension(b(),2)
		let aBase=dimension(a(),1,0)-1, bBase=dimension(b(),1,0)-1
		let aBase1=dimension(a(),2,0)-1, bBase1=dimension(b(),2,0)-1
		dim base 1, c(a1, b2)
		for i=1 to a1 : let ia=i+abase : for j=1 to b2 : let jb=j+bBase1 : for k=1 to a2
		c(i,j)+=a(ia,k+aBase1)*b(k+bBase,jb)
		next k : next j : next i
		// redim to base 0
		dim base 0, c(a1, b2)
		=c()
	}
	// define arrays with different base per dimension
	// res() defined as empty array
	dim a(10 to 13, 4), b(4, 2 to 5), res()
	// numbers from ADA task
	a(10,0)= 1, 1, 1, 1, 2, 4, 8, 16, 3, 9, 27, 81, 4, 16, 64, 256
	b(0,2)= 4, -3, 4/3, -1/4, -13/3, 19/4, -7/3, 11/24, 3/2, -2, 7/6, -1/4, -1/6, 1/4, -1/6, 1/24
	res()=MatMul(&a(), &b())
	for i=0 to 3 :for j=0 to 3
	Print res(i,j),
	next j : Print : next i
}
CheckMatMult2
}
MODULE MATEXP {\\http://www.rosettacode.org/wiki/Matrix-exponentiation_operator#M2000_Interpreter
Module CheckIt {
	Class cArray {
		a=(,)
		Function Power(n as integer){
			cArr=This     ' create a copy
			dim new()
			new()=cArr.a   ' get a pointer from a to new()
			Let cArr.a=new()    ' now new() return a copy
			cArr.a*=0  ' make zero all elements
			link cArr.a to v()
			for i=dimension(cArr.a,1,0) to dimension(cArr.a, 1,1) : v(i,i)=1: next i
			while n>0
				let cArr=cArr*this    ' * is the operator "*"
				n--
			end while
			=cArr
		}
		Operator "*"{
			Read cArr
			b=cArr.a
			if dimension(.a)<>2 or dimension(b)<>2 then Error "Need two 2D arrays "
			let a2=dimension(.a,2), b1=dimension(b,1)
			if a2<>b1 then Error "Need columns of first array equal to rows of second array"
			let a1=dimension(.a,1), b2=dimension(b,2)
			let aBase=dimension(.a,1,0)-1, bBase=dimension(b,1,0)-1
			let aBase1=dimension(.a,2,0)-1, bBase1=dimension(b,2,0)-1
			link .a,b to a(), b()  ' change interface for arrays
			dim base 1, c(a1, b2)
			for i=1 to a1 : let ia=i+abase : for j=1 to b2 : let jb=j+bBase1 : for k=1 to a2
			c(i,j)+=a(ia,k+aBase1)*b(k+bBase,jb)
			next k : next j : next i
			\\ redim to base 0
			dim base 0, c(a1, b2)
			.a<=c()
			}
		Module Print {
			link .a to v()
			for i=dimension(.a,1,0) to dimension(.a, 1,1) 
			for j=dimension(.a,2,0) to dimension(.a, 2,1) 
			print  v(i,j),: next j: print : next i
 
		}
	Class:
		\\ this module used as constructor, and not returned to final group (user object in M2000)
		Module cArray (r) {
			c=r
			Dim a(r,c)
			For i=0 to r-1 : For j=0 to c-1: Read a(i,j): Next j : Next i
			.a<=a()
		}
	}
	Print "matrix():"
	P=cArray(2,3,2,2,1)
	P.Print
	For i=0 to 9 
		Print "matrix()^"+str$(i,0)+"="
		K=P.Power(i)
		K.Print
	next i
}
Checkit
}
MODULE NQ {form ! 60,32
Set Fast !
Double
Print "N-Queens"
Refresh 1000
Cls,2
Module N_queens {
Const l = 9  'number of queens)
Const b = true  'print option
Dim a(0 to  l), s(0 to l), u(0 to 4 * l - 2)
Def long n, m, i, j, p, q, r, k, t
For i = 1 To l: a(i) = i: Next
For n = 1 To l
	m = 0 : i = 1:j=0:r=2*n-1
	Do
		i-- :j++:p=0:q=-r
		Do :i++ :u(p)=1:u(q+r)=1:Swap a(i), a(j):p=i-a(i)+n:q=i+a(i)-1:s(i)=j:j=i+1:Until j > n Or u(p) Or u(q + r)
		If u(p)=0 Then If u(q+r)=0 Then m++ : If b Then Disp()
		if Esc then Print"Esc" : break
		j = s(i)
		While j >= n And i <> 0
			Do :Swap a(i), a(j) :j--:Until j < i
			i--:p=i-a(i)+n :q=i+a(i)-1:j = s(i):u(p)=0:u(q+r)=0
		End While
	Until i=0
	Print Part @(0),~(15),"Queens:";~(14);n, @(tab(2)), ~(15),"Solutions:";~(14);m
	if n<l Then Print Under $(7,width),"Press a key",@(0) : Push Key$ : Drop Else Print Under
Next
Sub Disp()
	Pen 14 {Print "n="; n; "    m="; m}
	For k=1 To n  :For t=1 To n
		Print If$(a(n-k+1)=t-> "♛", ".");
	Next :Print : Next
	Refresh
	wait 1  ' this is the spot where a thread get time to run
End Sub
}
Escape Off
\\ simulate Esc key,using a thread (threads need time, so we use Wait to get it)
Global Esc=False
Thread {Esc<=keypress(27)} as M interval 100

Pen 15{N_queens}
Thread M Erase
Print
Normal
while keypress(27) : Wait 1: End While
Set Fast
Escape On
}
MODULE MOUSEPOS {Module Checkit {
	\\ works when console is the active window
	\\ pressing right mouse button exit the loop
	While mouse<>2
		Print mouse.x, mouse.y
	End While
	\\ end of part one, now we make a form with title Form1 (same name as the variable name)
	Declare Form1 Form
	Layer Form1 {
		window 16, 10000,8000  ' 16pt font at maximum 10000 twips x 8000 twips
		cls #335522,0
		cls , 2 \\ from 3rd line start the split screen (for form's layer)
		pen 15 ' white
	}
	Function Form1.MouseMove {
		Read new button, shift, x, y  ' we use new because call is local, same scope as Checkit.
		Layer Form1 {
			print
			print part x, y, button
			refresh
		}
	}
	Function Form1.MouseDown {
		Read new button, shift, x, y
		\\ when we press mouse button we print in console
		\\ but only the first time
		print x, y, button
		refresh
	}
	\\ open Form1 as modal window above console
	Method Form1, "Show", 1
	Declare Form1 Nothing
}
CheckIt
}
MODULE PRI {Module  Prime_decomposition    {
	Inventory Known1=2@, 3@
	IsPrime=lambda  Known1 (x as decimal) -> {
		=0=1
		If exist(Known1, x) Then =1=1 : Exit
		If x<=5 OR frac(x) Then {If x == 2 OR x == 3 OR x == 5 Then Append Known1, x  : =1=1
		Break}
		If frac(x/2) Else Exit
		If frac(x/3) Else Exit
		x1=sqrt(x):d = 5@
		{If  frac(x/d ) Else Exit
		d += 2: If d>x1 Then Append Known1, x : =1=1 : Exit
		If frac(x/d) Else Exit
		d += 4: If d<= x1 Else Append Known1, x :  =1=1: Exit
		Loop}
	}
	decompose=lambda IsPrime (n as decimal) -> {
	Inventory queue Factors
	k=2@
	While frac(n/k)=0:n/=k:Append Factors, k:End While
	If n=1 Then =Factors : Exit
	k++ 
	While frac(n/k)=0:n/=k: Append Factors, k:End While
	If n=1 Then =Factors : Exit
	do
		k+=2
		While not isprime(k) :k+=2:End While
		While frac(n/k)=0 :n/=k: Append Factors, k:End While
	until n=1
	=Factors
	}
	Data 10, 100, 12, 144, 496, 842,1000, 1122, 5555, 9999, 1212454, 10242048
	Data  22819637
	Back {cls #666666}
	Mode 8
	gradient #666666,#666666
	olinespace=linespace
	linespace twipsy*6
	oPen=Pen
	oBold=Bold
	Bold 1
	Pen=14
	Print $(0,width div 6-1),
	tab1=width -tab
	oBold=Bold
	bb=#123612
	cc=#16A2A8
	Cursor 0, (height-Stack.Size-4) div 2
	Scroll Split 0
	Bold 0 : Italic : double
	Print Part $(6, 6), ~(0,7),"Number", $(6, width-6+1),~(oPen,3,3), "Prime decomposition"
	Bold oBold : Italic : Normal
	Print
	Pen 15 {Print Under}
	While not empty
		Over  ' make a copy
		Print Over  ~(oPen,cc)
		Print Part $(4,12), ~(15,bb),Number,$(6,5),~(oPen),Decompose(Number) : Refresh
		Pen 15 {Print Under}
	End While
	Bold oBold
	Scroll Split 0  ' reset without clear
	Linespace olinespace
	a$=key$
	keyboard "info"+chr$(13)
}
Prime_decomposition
}
MODULE ECHELON {\\ http://www.rosettacode.org/wiki/Reduced_row_echelon_form#M2000_Interpreter
\\ Reduced row echelon form
Module base0 {
      dim base 0, A(3, 4)
      A(0, 0)= 1,    2,   -1,   -4,  2 ,   3,   -1,   -11,  -2  ,  0 ,  -3,    22
      lead=0
      rowcount=3
      columncount=4
      gosub disp()   \\ we can use gosub if an array has the same name as a sub,
      for r=0 to rowcount-1 {
            if columncount<=lead then exit
            i=r
            while A(i,lead)=0 {
                  i++
                  if rowcount=i then i=r : lead++ : if columncount<lead then exit
            }
            for c =0 to columncount-1 {
                  swap A(i, c), A(r, c)
            }
              if A(r, lead)<>0 then {
                  div1=A(r,lead)
                  For c =0 to columncount-1 {
                      A( r, c)/=div1
                  } 
            }
            for i=0 to rowcount-1 {
                  if i<>r then {
                        mult=A(i,lead)
                        for j=0 to columncount-1 {
                                 A(i,j)-=A(r,j)*mult
                        }
                  }
            } 
            lead=lead+1
      }
      Print "Solution"
      disp()
      sub disp()
            local i, j
            for i=0 to rowcount-1
                  for j=0 to columncount-1
                        Print A(i, j),
                  Next j
                  if pos>0 then print
            Next i
      End sub
}
base0
}
MODULE ERATO {Module EratosthenesSieve (x) {
      \\ Κόσκινο του Ερατοσθένη
      If x>200000 Then Exit
      Dim i(x+1)
      k=2
      k2=sqrt(x)
      While k<=k2 {
            m=k+k
            While m<=x {
                  i(m)=1
                  m+=k
            }
            {k++: if i(k)then loop
            }
      }
      For i=2 to x {
      If i(i)=0 Then Print i,
      }
      Print
}
EratosthenesSieve 1000

}
MODULE BUB {Module Bubble {
      function bubblesort {
                  dim a()    
                  \\ []  is a stack object,  interpreter pass current stack pointer, and set a new stack for current stack
                  \\ array( stackobject ) get a stack object and return an array
                  a()=array([])
                  itemcount=len(a())
                   repeat {
                        haschange=false
                        if itemcount>1 then {
                              for index=0 to itemcount-2 {
                                  if a(index)>a(index+1) then swap a(index), a(index+1) : haschange=true
                              }
                        }
                       itemcount-- 
                   } until not haschange
                   =a()
      }
      \\ function can take parameters
      Print bubblesort(5,3,2,7,6,1)
      A=(2, 10, 17, 13, 20, 14, 3, 17, 16, 16)
 
      \\ !A copy values from array A to function stack
      B=bubblesort(!A)
      Print Len(A)=10 
      Print B
      \\ Print array  in descending order
      k=each(b, -1, 1)
      While k {
            Print Array(k),
      }
      \\ sort two arrays in one
      Print BubbleSort(!A, !B)
      \\ We can use a stack object,  and values pop from object
      Z=Stack:=2, 10, 17, 13, 20, 14, 3, 17, 16, 16
      Print Len(Z)=10
      Def GetStack(x)=Stack(x)
      Z1=GetStack(BubbleSort(!Z))
      Print Type$(Z1)="mStiva"
      Print Z1
      Print Len(Z1)
      Print Len(Z)=0  ' now Z is empty
}
Bubble
}
MODULE SHELL {Module ShellSortExample {
	Module shellsort(&a()) {
		DEf h%, i%, j%, k, n%
		n%= LEN(a())
		h% = n%
		WHILE h%
			IF h% = 2  THEN h% = 1 ELSE h%= h% DIV 2.2
			FOR i% = h% TO n% - 1
				k = a(i%)
				j% = i%
				WHILE j% >= h% AND k < a(ABS(j% - h%))
					a(j%) = a(j% - h%)
					j% -= h%
				END WHILE
				a(j%) = k
			NEXT
		END WHILE
	}
	
	DIM BASE 0,  numbers(20)
	numbers(0)=4, 65, 2, -31, 0, 99, 2, 83, 782, 1, 4, 65, 2, -31, 0, 99, 2, 83, 782, 1   ' first item must be number
	REM numbers(0):=4, 65, 2, -31, 0, 99, 2, 83, 782, 1, 4, 65, 2, -31, 0, 99, 2, 83, 782, 1  ' first item can be anything (using := an operator for arrays)
	\\ Pass array by reference
	shellsort &numbers()
	\\ Print all items using columns (automatic append lines)
	PRINT numbers()
}
ShellSortExample
}
MODULE TOWERS {Module Hanoi {
      Rem HANOI TOWERS
      Print "Three disks" : Print
      move(3, 1, 2, 3)
      Print 
      Print "Four disks" : Print
      move(4, 1, 2, 3)
 
 
      Sub move(n, from, to, via)
            If n <=0 Then Exit Sub
            move(n - 1, from, via, to)
            Print "Move disk"; n; " from pole"; from; " to pole"; to
            move(n - 1, via, to, from)
      End Sub
}
Hanoi
}
MODULE VARIAD {Module CheckIt {
      \\ Works for numbers and strings (letters in M2000)
      Function Variadic {
            \\ print a letter for each type in function stack
            Print Envelope$()
            \\Check types using Match
            Print Match("NNSNNS")
            =stack.size
            While not Empty {
                  if islet then {print letter$} else print number
            }
      }
      M=Variadic(1,2,"Hello",3,4,"Bye")
      Print M
      \\ K is a poiner to Array
      K=(1,2,"Hello 2",3,4,"Bye 2")
      \\ !K pass all items to function's stack
      M=Variadic(!K)
}
Checkit
 
 
Module CheckIt2 {
      Function Variadic {
            \\ [] return a pointer to stack, and leave a new stack as function's stack
            a=[]
            \\ a is a pointer to stack
            \\ objects just leave a space, and cursor move to next column (spread on lines)
            Print a
      }
      M=Variadic(1,2,"Hello",3,4,"Bye")
      Print M
      \\ K is a poiner to Array
      K=(1,2,"Hello 2",3,4,"Bye 2")
      \\ !K pass all items to function stack
      \\ ! operator unpack the array (place copies)
      M=Variadic(!K, "another one")
      S=Stack:=1,2,"Hello 2",3,4,"Bye 3"
      \\ ! operator remove items from S and place them to function's stack
      M=Variadic(!S, "from a stack object, removing items")
      Print Len(S)=0
      S=Stack:=1,2,"Hello 2",3,4,"Bye 3"
      \\ we use Stack() to get a copy of S (can be used for a list of stack objects)
      M=Variadic(!Stack(S), "from a stack object, without removing itmes")
      Print Len(S)=6
      Stack S {Flush}  ' we can use Flush when attach the S stack as a current stack preserving the old one (which we can't use in the block)
}
Checkit2
}
MODULE CREATEWINDOW {\\ simple code to create a window - and open as modal
\\ for fun we have a thread running in the background, each 1/60 of second  (1000mSec/60)
Profiler
Thread {
	Print format$("running in the background {0::-10}, {1:2:-10}", tick, timecount)
	refresh  ' need to refresh manualy because console window has lost focus when form open
} as k interval 1000/60
Module DisplayWindow (a$){
      Declare MyForm Form
      \\ split statement from rem to see the change in form's title
      Rem With MyForm,"Title", a$
      Method MyForm,"Show",1    ' wait to close
      Print "close now"
}
DisplayWindow "Window 1"
DisplayWindow "Window 2"
DisplayWindow "Window 3"
Thread k Erase
}
MODULE KNUTH {\\ Trabb Pardo–Knuth algorithm
\\ We use stack (a collection, which we add to top or to bottom and read from top)
\\ Each call place the arguents on top of stack (this isn't the return stack, we say this as Stack of Values)
\\ A module call another module placing the same stack
\\ A User function begin with a fresh stack with any number of arguments we pass
\\ M2000 Interpreter except for Events Objects, has no use of "signature" as an automatic tool
\\ Singature can be checked before reading from stack using Match() function
\\ and that we did in Run module.
\\ If we try to Read a number but a string is on top of stack then we get error
\\ Also Interpreter has to give a value to a variable in Read statement and if nothing found raise an error.
\\ We can give a value say Read X=10 so if no value found then X get value 10
\\ For Stack of Values between Module's calls (and the same if we call a function using Call like a statement)
\\ we have to make proper pops (also we can pusj to return values). The callee has to clean the stack for a proper state.

\\ Each module has own scope (it is like  a program). Variables, Modules, Functions can be defined on the fly (at run time). So we can use an If structure to choose definition for a function.
\\ We can see Globals, but a local or a global defined in module shadow the previous global. At the return from module, any new identifier erased (including local modules and functions).


Report {ask for 11 numbers to be read into a sequence S
      reverse sequence S
      for each item in sequence S
          result := call a function to do an operation
          if result overflows
              alert user
          else
              print result
      
      The task is to implement the algorithm:
                  
            Use the function:    f(x)=|x|^{0.5}+5x^3
            The overflow condition is an answer of greater than 400.
            The 'user alert' should not stop processing of other items of the sequence.
            Print a prompt before accepting eleven, textual, numeric inputs.
            You may optionally print the item as well as its associated result, but the results must be in reverse order of input.
            The sequence   S   may be 'implied' and so not shown explicitly.
            Print and show the program in action from a typical run here. (If the output is graphical rather than text then either add a screendump or describe textually what is displayed).
            }
Module Input11 {
      Flush ' empty stack
      For I=1 to 11 {
            Do : Print : Try ok {Input "Give me a number ", a} : Until ok
            \\ using Push a we do the reverse here, but ge have to indicate somehow in module Run to not reverse again then stack
            Data a   ' add to bottom of stack, use: Push a to add to top, to get reverse order here
            Print if$(i<11->format$("need {0} more number{1}", 11-I, if$(i<10->"s","")),"ok")
      }
}
Module Run {
      Module Msg {Drop}  ' not used if we pass a decoration
      Msg  "Trabb Pardo–Knuth algorithm"
      Msg "f(x)=Sqrt(Abs(x))+5*x^3"
      if not match("NNNNNNNNN") then Error "Need 11 numbers" 
      Shiftback 1, -11 ' reverse  order 11 elements of stack of values
      Def f(x)=Sqrt(Abs(x))+5*x^3
      For i=1 to 11 {
            Read pop
            y=f(pop)
            if y>400 Then {
                  Pen Pen {Print ~(12), format$("f({0}) = Overflow!", pop)}
            }  Else {
                  Print format$("f({0}) = {1}", pop, y)
            }
      }
}
Global Counter
Module Msg (a$) {
	Pen 15 {Print a$}
	Counter++
}
\\ we can pass a module (only for modules when we call them by name, not using CALL)
\\ so we can't use an external module for recursion in module
\\ a module can't call his name, except we use Call statement
\\ The Msg is a decorator for Run 
Run 10, -1, 1, 2, 3, 4, 4.3, 4.305, 4.303, 4.302, 4.301 ; Msg
Run 1, 2, 3, -4.55,5.1111, 6, -7, 8, 9, 10, 11  ' ; Msg  ' drop first ' to use external  Msg
Input11
Run ; Msg
Print "You use Msg ";Counter;" times"
}
MODULE PONG {IF IsWine Else Smooth On
ESCAPE OFF
THREAD.PLAN SEQUENTIAL
\\ Program SoloPong
oldfont$=FontName$
Font "VERDANA"
Hard=2 \\ 3 for more
Hide
Mode 18, 8000,2400
Motion Center
Module Hit {
              Score 2, 100,"g"
              Play 2, 127
}
Gosub Functions
Background {
font "Verdana"
mode 18
cls
Refresh 5000
Dim D$()
D$()=Nu$()
Cls 5,0
Pen 14
a$=""
b$=""
b1$=""
Move 0,0
Fill 300,Scale.Y, 15
Move 0,0
Copy 300,300 To a$
Copy 300,1800 To b$
Copy 300,Scale.Y To b1$
Again:
Cls 0,0
Refresh 5000
Mouse.Icon Hide
Cls #222222,0
Print @(5,5),
Pen 7 {
      Report {Game SoloPong II
            Press P for pause
            Press space...
            ...to end the game
            }
      }
For i=0 to Scale.Y Step twipsY*2 { Move 0,i : Draw scale.X, 0, #555555 }
xk=Int(scale.X/2-150)
xk0=scale.X/2
xk03=scale.X/3
xk1=xk-300*7
xk2=xk+900
xa0=850
xa00=0
xa2=xa0+150
xa1=400
Refresh 50
xd1=scale.X-1000
xd2=xd1+600
For i=0 to scale.Y-300 Step 600 { Copy xk, i Use a$ }
Score1=0
Score2=0
Copy xk1, 900 Use D$(Score1)
Copy xk2, 900 Use D$(Score2)
yo=-900
yo1=yo-Scale.Y/4
yo2=yo1+Scale.Y/2
yb=Scale.Y+900
Yab=30
Player 1, 850,yo  Use b1$
Player 2, xd1,10000  Use b$
Player 3,  850,yb  Use b1$
y2=scale.Y-900-1000
xm=xk
ym=3000+Random(2,5)*300
Player 4, xm,ym  Use a$,1,0, 45size 2
For i=1 To 4 { Player i Show }
y3=Scale.Y-300
x3=scale.X-300
y4=Scale.Y/2
tx=120
tm=120
yp=Mouse.X
y=yp
kp=0
kw=(xd1-xk) div 2
Thread {
      if (xm<xk and kp=0) or (xm>xk and kp<>0)  then if keypress(1) then kp=-kw-kp
      yp=y : y=Mouse.Y
} As nm Interval 25
Wait 100
Refresh 50
Score=False
Thread {
      If y<1900 Then { y=1900: yp=1900   } Else.If y>y2 Then y=y2: yp=y2
      If ym<300 Then { tm-! : ym+=tm  } Else.If ym>y3 Then tm-! : ym+=tm
      If Collide(4, 80, xa1,yo+y4, xa2, yb-y4) or Score Then {
            Score=True
      } Else.If collide(4, 100, xa1,yo-y4, xa2, yo+y4) Then {
            tx-! : xm=xa2+500
            tx*=1.5
            Hit
       } Else.If collide(4, 100, xa1,yb-y4, xa2, yb+y4) Then {     
            tx-! : xm=xa2+500
            tx*=1.5
            Hit
       } Else.If collide(4, 100, xd1+kp,y-900, xd2+kp, y+900) Then {
	   if kp then hard=1: tz=2
	   tx=-Abs(tx) : xm+=tx*Hard
	   tx=min.data(-Int(Log(Abs(y-yp)+2))*45*Hard, tx/2, -120) 
	   tm=Sgn(ym-y)*Abs(Int((ym-y)/10))+Sgn(tm)*30*Hard
	   Hit
      }
      Rem 1 : Cursor 0,Height-1 : Print Over $(,8),xm, ym , Abs(y-yp), tx, tm
      Player 2,xd1+kp,y
      'Player 4, xm,ym     
      Player 4, xm,ym Use a$,1,0, xm mod 360 size (2*xk-Abs(xm-xk))/xk
      REFRESH 5000
      xm+=tx       
      ym+=tm
      } As mp Interval 10
Thread {
Pen 7 {
      Cursor 0,0 : Print Part $(6,8),@(Width -8), ~(Pen,#555555),Str$(Now,"hh:mm:ss")
}
} As tt Interval 1000
Thread {
If xm>xk0 And xa00=0 Then {
      xa00=twipsX*20
}
} As dd Interval 10000
Refresh 50
kr=True
finish=False
Main.Task 100 {
      If kr Then {
            yo+=Yab
            yb+=Yab
            If yo>yo2 Then Yab-! Else.If yo<yo1 Then Yab-!
            xa0+=xa00
            If xa0>xk03 Then {
                  If tx>0  or xk0 <xm Then {
                  Thread dd Hold
                  xa00=0 
                  }  Else xa00=-twipsX*20 : Thread dd Restart
            }
            If xa0<850 Then xa0=850 : xa00=0
            xa2=xa0+150
            Player 1,xa0,yo
            Player 3,xa0,yb
            Rem 2 : Cursor 0,Height-1 : Print Over $(,8), yo, yb, Score
      }
      If xm>x3  or xm<850  Then {
            Score=False
            tx=0
            tm=0
            If xm>x3 Then {
                  Score1++
                  Copy xk1, 900 Use D$(Score1)
            } Else {
                  Score2++
                  Copy xk2, 900 Use D$(Score2)
            }
            If Score1=10 or Score2=10 Then Break
            xm=xk
            ym=3000+Random(2,5)*150
            Player 4, xm,ym
            yp=ym
            tx=60*Random(2,5)/3+120
            tm=tx-60
            Score=False
      }
      Select Case Inkey$
      Case "p","P"
            {
                  If kr Then { 
                        Thread mp Hold
                        Layer {
                              Cls 0, 0
                              Pen 15 {
                                    Cursor 0, 0
                                    Print Over $(6),"Solo Pong II"
                                    Cursor 0, Height/2-1
                                    Print Over $(6),"Press P or p to continue.."
                                    Print Under
                                    Print Over $(6)," or press space to end the game"
                              }
                              Show
                        }
                  } Else {
                        Layer {
                              Hide
                              Cls 5
                        }
                        Thread mp Restart
                  }
                  kr~
            }
      Case " "
            {  If Not kr Then Layer {Hide }: kr~
                  Thread mp Hold
                  Mouse.icon Show
                  refresh 20
                  If Ask("Stop this game","SoloPong","Yes","No")=1 Then { 
                  Layer {Cls 5}
                        finish=True
                  } Else Mouse.icon Hide
                  Thread mp Restart
            }
      End Select
      If finish  OR keypress(27) Then Exit
}
Threads Erase
If kr Else { Layer {Hide : Cls 5} : kr~ }
Mouse.icon Show
REFRESH  20
If Ask("New Game","SoloPong","Yes","No")=1 Then Goto Again
Player 0
Cls 5
}
Font oldfont$
Form 60,30
Show
ESCAPE ON
Keyboard "Info"+chr$(13)
End
Functions:
Function Nu$ {
x=0
y=0
Zero$={_***_
                  *___*
                  *___*
                  *___*
                  *___*
                  *___*
                  _***_
                  }
One$={__*__
                  _**__
                  *_*__
                  __*__
                  __*__
                  __*__
                  *****
                  }
Two$={_***_
                  *___*
                  ____*
                  _***_
                  *____
                  *____
                  *****
                  }
Three$={_***_
                  *___*
                  ____*
                  __**_
                  ____*
                  *___*
                  _***_
                  }
Four$={___*_
                  __**_
                  _*_*_
                  *__*_
                  *****
                  ___*_
                  ___*_
                  }
Five$={*****
                  *____
                  ****_
                  ____*
                  ____*
                  *___*
                  _***_
                  }
Six$={_***_
                  *___*
                  *____
                  ****_
                  *___*
                  *___*
                  _***_
                  }
Seven$={*****
                  ____*
                  ___*_
                  __*__
                  __*__
                  __*__
                  __*__
                  }
Eight$={_***_
                  *___*
                  *___*
                  _***_
                  *___*
                  *___*
                  _***_
                  } 
Nine$={_***_
                  *___*
                  *___*
                  _****
                  ____*
                  *___*
                  _***_
                  } 
Ten$={*__*_
                  *_*_*
                  *_*_*
                  *_*_*
                  *_*_*
                  *_*_*
                  *__*_
                  }   
Dim D$(11), D1$(11)
W1=300
H1=300
D$(0)=Zero$,One$, Two$, Three$, Four$,Five$, Six$, Seven$, Eight$, Nine$, Ten$
      For D=0 to 10 {
      Cls #222222,0
      For i=0 to 7*H1 Step twipsY*2 {
      Move 0,i
      Draw scale.X, 0, #555555
      }
      L=1
      Move x,y
      For k=0 to 7 {
            For i=0 to 4 {
                       If Mid$(D$(D),L,1)="*" Then { Fill W1, H1,15 }  Else Step W1, H1
                       Step 0, -H1
                  L++
            }
            Step -5*W1, H1
            L+=2
      }
      a$=""
      Move x,y
      Copy W1*5,H1*7 To a$
      D1$(D)=a$
      }
=D1$()
}
Return
}
MODULE DI2 {inline code libDiv
'Form 80, 40
flush
def r(x, p)=int(x*10^p)/10^p
Data ProDiv$("1","580000",16, true), 1 / 580000
Data ProDiv$("1","580000000",16), 1 / 580000000
Data ProDiv$("1","5800",16), 1 / 5800
Data ProDiv$("1","58",16), 1 / 58
Data ProDiv$("632010","58",0), 632010 div 58
Data ProDiv$("2320","58",0),2320 div 58
Data ProDiv$("324200","203",16), 324200 / 203
Data ProDiv$("32420","23",16), 32420 / 23
Data ProDiv$("32420","23",15, true), 32420 / 23
Data ProDiv$("32420","23",15), 32420 / 23
Data ProDiv$("100","1",1), 100/1
Data ProDiv$("1025","2",0), 1025 div 2
Data ProDiv$("3242","23",0), 3242 div 23
Data ProDiv$("324300","23",0), 324300 div 23

Data ProDiv$("232","58",0), 232 div 58
Data ProDiv$("3243","23",0), 3243 div 23
Data ProDiv$("23200","58",0), 23200 div 58
Data ProDiv$("2320","58",0), 2320 div 58
Data ProDiv$("632010","123",16), 632010 / 123
Data ProDiv$("100","1",1), 100/1
Data ProDiv$("100","2",1), 100/2
Data ProDiv$("632010","123",16), 632010 / 123

Data ProDiv$("1000","15",16), 1000 / 15
Data ProDiv$("1500","25000",,,1), r(1500 / 25000, 1)
Data ProDiv$("1500","25000"), r(1500 / 25000, 2)
Data ProDiv$("1500","25000"), r(1500 / 25000, 3)

Data ProDiv$("1500","22000",16), r(1500 / 22000, 16)
Data ProDiv$("1500","22000",14, true), 1500 / 22000
Data ProDiv$("1500","2500",16), 1500/2500

Data ProDiv$("1500","250",,,16), 1500/250

Data ProDiv$("15000","25",,,16), 15000/25

Data ProDiv$("15000000000","25",0), 15000000000/25
Data ProDiv$("15000000000","245",14), 15000000000/245

while not empty
read a$, a
print val(a$)==a , @(12), a$,@(50), a
end while
}
MODULE LIBDIV {\\ use in console EDIT !4
\\ so tab width change to 4 characters
Function ProDiv$ {
	Read a$, b$, pp=10, rd as boolean=false, maxd=-1, dp$="."
	if pp<0 then error "decimal digits>=0 "
	if rd then pp++
	Let v$="", gg=len(b$), p=pp,  mm=0, d1=0, mm1=0, od1=-1
	if len(b$)>len(a$) then 
		gg=len(b$)-len(a$): a$+=string$("0",gg):mm1=gg :gg=1:pp++:p=pp
	else.if len(b$)=len(a$) and b$>a$ then
		a$+="0":  mm1=-1:gg=1: pp++:p=pp		
	end if
	if mm1<>0 and maxd>0 then p=min.data(maxd-1, p)-rd : maxd=0
	lz=pp
	{
		s=len(b$)
		c$=left$(a$,s)
		if c$<b$ then  s++: c$=left$(a$, s) :if s=len(b$) then exit
		d1=val(c$) div val(b$)
		r$=str$(val(c$)-val(b$)*d1,"0")
		if gg<s-1  then
			if v$="0" then
				mm=-s+gg : if p+mm<17 then  a$+=string$("0", p+mm)
				p=p-len(v$) : if p<0 then p=0
			end if
			v$+=string$("0",s-1-gg)
		end if
		v$+=str$(d1,"0")
		if d1<>0 then od1=len(v$)-1
		gg=len(r$)
		a$ =r$+mid$(a$,s+1)
		cc=false
		if len(a$)=len(b$) then
			if a$>=b$ then cc=true
		else
			cc=len(a$)>len(b$) and a$<>"0"
		end if
		
		
		if cc else if p=0 then  exit
		
		if p>0  and not cc then
			if len(a$)>gg then
				mm=len(v$)+2
			else
				mm=len(v$)+1
			end if
			a$+=string$("0", p) : p=0
		end if
		
		loop
	}
	if mm1<>0 then
		if mm1=-1 then if left$(v$,1)="0" then v$=mid$(v$,2)
		if mm1<0 then mm=mm1 : mm1=-2 else mm=2-mm
	end if
	if len(a$)>gg and len(a$)>=len(b$) then v$+=string$("0",gg)
	if maxd>0 then
		if mm=0 then mm=len(v$)+1
		v$=left$(v$,maxd+2) :if len(v$)>maxd+1 then rd=true
	end if
	if rd  then
		bb$=strrev$(v$) :v$="":cc=5
		for i=1 to len(bb$)
			if cc=0 then v$+=mid$(bb$, i) : exit for
			dd=val(mid$(bb$, i,1))+cc  
			if dd>9 then  cc=1 else  cc=0
			v$+=str$(dd mod 10, 0) 
		next i
		v$=strrev$(mid$(v$,2))
	end if
	if left$(v$,1)="0" and len(v$)>1  then v$=mid$(v$,2): mm--

	if mm=0 then  =v$ : exit
	if mm>1 then
		n$=mid$(v$,mm+1)
		if len(n$)<16 then  if val(n$)=0 then n$="" : v$=left$(v$,mm)
		if mm+pp>16 or maxd>0 then
			if od1>0 then v$=left$(v$, od1+1)
			if mm-1<16 and maxd>0 then
				=left$(v$, mm-1)
			else
				=left$(v$,1)+dp$+mid$(v$,2)+if$(mm=2->"","E+"+str$(mm-2,"00"))
			end if
		else.if  mm+pp<16 then
			if val(mid$(v$,mm))=0 then
				=left$(v$,mm-1)
			else
				if od1>0 then v$=left$(v$, od1+1)
				=left$(v$,mm-1)+dp$+mid$(v$,mm)
			end if
		else
			if od1>1 then n$=left$(v$, od1-1)
			=Left$(v$,1)+dp$+n$
		end if
	else.if mm<0  then
		if od1>0 then v$=left$(v$, od1)
		if len(v$)<=16 and mm1+mm<16 then
			if mm1=-1 then
				v$="0"+mid$(v$,-mm,1)
			else
				v$=string$( "0", mm1+1)+mid$(v$,-mm,1)
			end if
			=mid$(v$,1, 1)+dp$+Mid$(v$,2)
		else
			=mid$(v$, -mm, 1)+dp$+Mid$(v$,-mm+1)+if$(mm1+1=0 -> "","E-"+str$(abs(mm1+1),"00"))
		end if
	else
		if od1>0 then v$=left$(v$, od1)
		if maxd=0 then ="0" else =v$
	end if
}
}
MODULE ADDER4BIT {Module  FourBitAdder {
	Flush
	dim not(0 to 1),and(0 to 1, 0 to 1),or(0 to 1, 0 to 1)
	not(0)=1,0
	and(0,0)=0,0,0,1
	or(0,0)=0,1,1,1
	xor=lambda not(),and(),or() (a,b)-> or(and(a, not(b)), and(b, not(a)))
	ha=lambda xor, and() (a,b, &s, &c)->{
		s=xor(a,b)
		c=and(a,b)
	}
	fa=lambda ha, or() (a, b, c0, &s, &c1)->{
		def sa,ca,cb
		call ha(a, c0, &sa, &ca)
		call ha(sa, b, &s,&cb)
		c1=or(ca,cb)
	}
	add4=lambda fa (inpA(), inpB(), &v, &out()) ->{
		dim carry(0 to 4)=0
		carry(0)=v    \\ 0 or 1  borrow
		for i=0 to 3
			\\ mm=fa(InpA(i), inpB(i), carry(i), &out(i), &carry(i+1)) ' same as this
			Call fa(InpA(i), inpB(i), carry(i), &out(i), &carry(i+1))
		next
		v=carry(4)
	}
	dim res(0 to 3)=-1,  low()
	source=lambda->{
		shift 1, -stack.size  ' reverse stack items
		=array([])  ' convert current stack to array, empty current stack
	}
	def v, k, k_low
	Print "First Example 4-bit"
	Print "A", "", 1, 0, 1, 0
	Print "B", "", 1, 0, 0, 1
	call add4(source(1,0,1,0), source(1,0,0,1), &v, &res())
	k=each(res() end to start)  ' k is an iterator, now configure to read items in reverse
	Print "A+B",v, k    ' print 1 0 0 1 1
	Print "Second Example 4-bit"
	v-=v
	Print "A", "", 0, 1, 1, 0
	Print "B", "", 0, 1, 1, 1
	call add4(source(0,1,1,0), source(0,1,1,1), &v, &res())
	k=each(res() end to start)  ' k is an iterator, now configure to read items in reverse
	Print "A+B",v, k    ' print  0 1 1 0 1
	Print "Third Example 8-bit"
	v-=v
	Print "A ", "", 1, 0, 0, 0, 0, 1, 1, 0
	Print "B ", "", 1, 1, 1, 1, 1, 1, 1, 1
	call add4(source(0,1,1,0), source(1,1,1,1), &v, &res())
	low()=res()  ' a copy of res()
	' v passed to second adder
	dim res(0 to 3)=-1
	call add4(source(1,0,0,0), source(1,1,1,1), &v, &res())
	k_low=each(low() end to start)  ' k_low is an iterator, now configure to read items in reverse
	k=each(res() end to start)  ' k is an iterator, now configure to read items in reverse
	Print "A+B",v, k, k_low   ' print 1 1 0 0 0 0 1 0 1
}
FourBitAdder
}
MODULE BASEG {Print "Wait..."
db.provider ""
db.provider "Microsoft.Jet.OLEDB.4.0", "Jet OLEDB", "newpassword"
'db.provider "Microsoft.ACE.OLEDB.12.0","Jet OLEDB", "newpassword"
\\ remove base if exist in current directory
base "mdbfile"
\\ Make a new table and insert values (M2000 use ADOdb with a special connection string)
\\ data taken from example's of MOSH HAMEDANI for SQL, see this video
\\ https://www.youtube.com/watch?v=7S_tz1z_5bA

\\ Create table changed from original to be used here, but the schema is the same.
\\ Maybe integer definition maybe not the same with original int(11).

\\ We use 3 times execute. One return nothing, but the other two return a record set each
\\ recordset saved to stack of values (as top value each time)
\\ so we call subroutine passing just the stack of values, so we read from there.

\\ Inside each subroutine we make some local variables, using a way to link recordset with properties
\\ property fields of recordset used 3 times, to produce different items. One is the actual object, and the
\\ other two by using an index value we get field value (the default property), one as numeric and
\\ the other as string.

\\ So we have to see about NULL. A NULL can exist if table schema allow it. When a field has NULL value
\\ we get it as numeric type of NULL (we can't use it as a value in expressions, always return NULL),
\\ but if we read it as string value we get empty string. 

\\ Here we see two rows, one with a NULL phone and one with empty string (which isn't Null)
\\ To examine if we have NULL we have to check the numeric variant of field.

\\ for checking the NULL we have a string function which return "NULL" or the string value,
\\ including empty string.


execute "mdbfile", {
	CREATE TABLE customers (
		customer_id AUTOINCREMENT PRIMARY KEY,
		first_name VARCHAR(50) NOT NULL,
		last_name VARCHAR(50) NOT NULL,
		birth_date date DEFAULT NULL,
		phone VARCHAR(50) DEFAULT NULL,
		address VARCHAR(50) NOT NULL,
		city VARCHAR(50) NOT NULL,
		state char(2) NOT NULL,
		points integer NOT NULL DEFAULT 0
	);
	INSERT INTO `customers` VALUES (1,'Babara','MacCaffrey','1986-03-28','781-932-9754','0 Sage Terrace','Waltham','MA',2273);
	INSERT INTO `customers` VALUES (2,'Ines','Brushfield','1986-04-13','804-427-9456','14187 Commercial Trail','Hampton','VA',947);
	INSERT INTO `customers` VALUES (3,'Freddi','Boagey','1985-02-07','719-724-7869','251 Springs Junction','Colorado Springs','CO',2967);
	INSERT INTO `customers` VALUES (4,'Ambur','Roseburgh','1974-04-14','407-231-8017','30 Arapahoe Terrace','Orlando','FL',457);
	INSERT INTO `customers` VALUES (5,'Clemmie','Betchley','1973-11-07',NULL,'5 Spohn Circle','Arlington','TX',3675);
	INSERT INTO `customers` VALUES (6,'Elka','Twiddell','1991-09-04','312-480-8498','7 Manley Drive','Chicago','IL',3073);
	INSERT INTO `customers` VALUES (7,'Ilene','Dowson','1964-08-30','615-641-4759','50 Lillian Crossing','Nashville','TN',1672);
	INSERT INTO `customers` VALUES (8,'Thacher','Naseby','1993-07-17','941-527-3977','538 Mosinee Center','Sarasota','FL',205);
	INSERT INTO `customers` VALUES (9,'Romola','Rumgay','1992-05-23','559-181-3744','3520 Ohio Trail','Visalia','CA',1486);
	INSERT INTO `customers` VALUES (10,'Levy','Mynett','1969-10-13','','68 Lawn Avenue','Atlanta','GA',796);
}

\\ id 10 has no Null phone, has no phone (is an empty string)
\\ Null means "no information yet"
report "customers created"
\\ execute a SELECT query to get a Recordset
report "Selected customers where Points<1000 in descending order"
execute "mdbfile",{
	SELECT 	customer_id,
			last_name,
			first_name,
			phone,
			points
	FROM 	`customers`
	WHERE 	Points<1000 
	ORDER BY 	Points DESC,
			last_name,
			first_name
}
Def CheckNull$(a, a$)=If$(type$(a)="Null"->"NULL", a$)
GetListA() ' value is already in stack

report  "Select customers id where phone is null"
execute "mdbfile",{
	SELECT 	customer_id,
			phone
	FROM 	`customers`
	WHERE 	phone IS Null 
	ORDER BY 	customer_id 
}
GetIDwithNullPhone()    ' value is already in stack

close base "mdbfile"
\\ using list to check the variable names
list
\\ there are no variables in module, at this moment.
\\ All variables was local to subs, and they erased at the exit of subs
\\ we can use dots in names, like a normal variable.
\\ so rs.fields is a norma variable name. This variable is a PropReference type.
\\ This type of variable is an object which link a property to an object
\\ We can't use these variables as return values, because the use a hard link,
\\ and not a standard reference to object. So PropReference can't hold alive a linked object.
\\ So if we return the PropReference from where we make it then became invalid, and we have
\\ to use it to raise the error.


sub GetListA(RS)
if type$(RS)="Recordset" then
	with RS, "EOF" as new rs.eof, "fields" as new fields(), "fields" as new fields$(), "fields" as new rs.fields
	with rs.fields, "count" as new rs.fields.count
	print  "Test number of fields:", rs.fields.count
	while not rs.eof
		print $(6),fields(0),
		print $(9)," ";fields$(1);" ";fields$(2);@(32); CheckNull$(fields(3), fields$(3));@(42), fields(4)
		method rs, "movenext"
	end while
	print $(0),,
end if
end sub
sub GetIDwithNullPhone(RS)
if type$(RS)="Recordset" then
	with RS, "EOF" as new rs.eof, "fields" as new fields(), "fields" as new fields$(), "fields" as new rs.fields
	with rs.fields, "count" as new rs.fields.count
	print  "Test number of fields:", rs.fields.count	
	while not rs.eof
		print $(4), fields(0), $(7), CheckNull$(fields(1), fields$(1)), $(0)
		method rs, "movenext"
	end while
	print
end if
end sub
}
MODULE EN1 {Module Checkit {
      \\ need revision 15, version 9.4
      Enum Fruit  {apple, banana, cherry}
      Enum Fruit2  {apple2=10, banana2=20, cherry2=30}
      Print apple, banana, cherry
      Print apple2, banana2, cherry2
      Print Len(apple)=0
      Print Len(banana)=1
      Print Len(cherry)=2
      Print Len(cherry2)=2, Cherry2=30, Type$(Cherry2)="Fruit2"
 
      k=each(Fruit) 
      While k {
            \\ name of variable, value, length from first (0, 1, 2)
            Print Eval$(k), Eval(k), k^
      }
      m=apple
      Print Eval$(m)="apple"
      Print Eval(m)=m
      m++
      Print Eval$(m)="banana"
      Try {
            \\ error, m is an object
            m=100
      }
      report error$
      Try {
            \\ error not the same type
            m=apple2
      }
      report error$
      Try {
            \\ read only can't change
            apple2++
      }
      report error$
      m++
      Print Eval$(m)="cherry", m
      k=Each(Fruit2 end to start) 
      While k {
             Print Eval$(k), Eval(k) , k^   
             CheckByValue(Eval(k))
      }
      m2=apple2
      Print "-------------------------"
      CheckByValue(m2)
      CheckByReference(&m2)
      Print m2
 
      Sub CheckByValue(z as Fruit2)
            Print Eval$(z), z
      End Sub
 
      Sub CheckByReference(&z as Fruit2)
            z++
            Print Eval$(z), z
      End Sub
}
Checkit
}
MODULE WUMPUS {Module WumpusGame {
      Print "Game: Hunt The Wumpus"
      Arrows=5
      Dim Room(1 to 20)
      Room(1)=(2,6,5),(3,8,1),(4,10,2),(5,2,3),(1,14,4)
      Room(6)=(15,1,7),(17,6,8),(7,2,9),(18,8,10),(9,3,11)
      Room(11)=(19,10,12),(11,4,13),(20,12,14),(5,11,13), (6,16,14)
      Room(16)=(20,15,17),(16,7,18),(17,9,19),(18,11,20),(19,13,16)
      Enum Things {EmptyRoom, Bat1, Bat2, Pit1, Pit2, Wumpus}
      Dim Content(1 to 20)=EmptyRoom
      i=each(Things,2)  ' from 2 to End
      While i {
            r=random(1,20)
            if Content(r)<>EmptyRoom then restart
            Content(r)=Eval(i)
      }
      WumpusPos=r
      PlayerPos=-1
      TranspotPlayer()
      Done=False
      \\ Help is statement but here used as variable
      Help=False
      While Arrows>0 And Not Done {
            Sense()
            Print "W- Walk, T - Throw Arrow, G - Give up or H for Help"
            a$=Ucase$(Key$)
            If a$="W" Then {
                  Print "Choose Tunnel to Walk: 1, 2 or 3"
                  r=Val("0"+Key$)-1
                  if r>=0 and r<=2 then {
                        PlayerPos=Array(room(PlayerPos), r)
                        Select Case Content(PlayerPos)
                        Case Wumpus
                        Eaten()
                        Case Pit1, Pit2
                        {
                              Arrows=0
                              Print "You fall to a bottomless pit;"
                        }
                        Case Bat1, Bat2
                        {
                              Print "A giant bat takes you in another room;"
                              TranspotPlayer()
                        }
                        End Select
                  }
            } Else.if a$="T" Then {
                  Arrows--
                  Print "Choose Tunnel to Throw Arrow: 1, 2  or 3"      
                  r=Val("0"+Key$)-1
                  if r>=0 and r<=2 then {
                        i=room(PlayerPos)
                        If Content(Array(i, r))=Wumpus then {
                              Done=True
                      } Else.if random(1,4)<4 then WakeWumpus()
                  }            
            } Else.if a$="G" Then {
                   Arrows=0
            } Else.if a$="H" Then Help~
      }
      If Done then Print "You kill the Monster Wumpus; You Win.": Exit
      Print "You loose."
 
      Sub TranspotPlayer()
            local r=random(1,20)
            While Content(r)<>EmptyRoom {r=random(1,20)}
            PlayerPos=r
      End Sub
      Sub WakeWumpus()
            local j=array(room(WumpusPos),random(0,2))
            If content(j)=EmptyRoom Then {
                  swap content(j), content(WumpusPos)
                  WumpusPos=j
                  If WumpusPos=PlayerPos then Eaten()
            }
      End Sub
      Sub Eaten()
            Arrows=0
            Print "You eaten by Wumpus;"
      End Sub
      Sub Sense()
            local k=Room(PlayerPos)
            local j=each(k), Wumpus_near, bat_near, pit_near
            Print "Player Room:";PlayerPos,
            If Help then Print "Wumpus Room:";WumpusPos
            While j {
                  If Help Then Print "Tunnel:";j^+1, "Room:";Array(j), "Content:";eval$(content(array(j)))
                  Select Case content(array(j))
                  Case Bat1, Bat2
                  bat_near=True
                  Case Pit1, Pit2
                  pit_near=True
                  Case Wumpus
                  Wumpus_near=True
                  End Select
            }
            If Wumpus_near Then Print "You smell something terrible nearby."
            If bat_near Then Print "You hear a rustling."
            if pit_near Then Print "You feel a cold wind blowing from a nearby cavern."
      End Sub    
}
cls,0
WumpusGame
}
MODULE FORTH {// https://rosettacode.org/wiki/Fixed_length_records#Forth_Blocks
// A Forth block is 1024 bytes. Source code is stored as 16 lines of 64 characters each (no newline character or sequence to mark the end of a line).

Form 80,50
Print "Forth's Blocks"
// Forth Blocks
Structure Line16 {
      a`Line as byte*64
}
NewBlock=lambda Line16 -> {
      Buffer a`Block as Line16*16
      // fill spaces
      Return a`Block, 0:=str$(string$(" ",1024))
      =a`Block
}
// Events are value types, but for closures and groups are reference types
Event Doit {
      Read something$
}
Header=Doit
DisplayBlock= Lambda NewBlock, Line16, Doit, Header (Blocks`File$,Block`Number, UseLocale=1033)->{
      Page1=NewBlock()
      Open Blocks`File$ for input as #f
            Seek #f, 1024*(Block`Number-1)+1
            Get #f,Page1
      Close #f
      Document NewDoc$
      // need to convert from Ansi
      Call Event Header, "Block:"+Str$(Block`Number)
      oldlocale=locale
      locale UseLocale
      For i=0 to 15
            lineAny$=chr$(Eval$(Page1,i, Len(Line16)))
            Call Event Doit, format$("{0::-2} {1}",i,chr$(Eval$(Page1,i, Len(Line16))))
      Next i
      locale oldlocale
}
Document ForthCode$={( Large letter F) 
      : STAR    [CHAR] * EMIT ;
      : STARS   0 DO  STAR  LOOP ;
      : MARGIN  CR 30 SPACES ;
      : BLIP    MARGIN STAR ;
      : BAR     MARGIN 5 STARS ;
      : F       BAR BLIP BAR BLIP BLIP CR ;
      }
// Make Document bigger than 16 lines
// doc.par(ForthCode$)  return paragraphs (here we have no wrap)
// actuall lines per layer can be found from Report (the renderer)
// using Reportlines. layer can be the printer page.
ForthCode$=string$(ForthCode$,5)
Print "Make Block"
Page1=NewBlock()
Locale 1033
Blocks`File$="Forth Blocks"
Block`Number=1
// Apppend three times same blocks
For Pass=1 to 3
      If Doc.Len(ForthCode$)>0 then
            For i=1 to Doc.par(ForthCode$)-1
            // we give order number but Paragraph$ use unique number for paragraphs
            // if we didn't delete or insert lines, then these two are the same
                  Print Paragraph$(ForthCode$, Paragraph(ForthCode$,i))
                  // convert to Ansi using Locale
                  // offset from 0, so minus 1
                  // offset 1 is at len(Line16)
                  // Page1(0) is the real address, but here doesn't matter
                  Return Page1, (i-1) mod 16:=Str$(Paragraph$(ForthCode$, Paragraph(ForthCode$,i)))
                  if i mod 16=0 then Gosub SaveBlock
            Next i
            i--
            if Not i mod 16=0 then  Gosub SaveBlock
      End if
Next Pass
// now we read from disk
Class DocumentKeeper {
      Document Text$
      Function AppendLine(aline$) {
            // right trim$
            .Text$<=Mid$(Trim$("*"+aline$),2)+{
            }
      }
}
Function Disp(aline$) {
      Print aline$
}
DocumentKeeper=DocumentKeeper()
Event Doit New Disp()
Event Header New Disp()
For i=1 to Block`Number-1
      Call DisplayBlock(Blocks`File$, i)
      Print "Press any key"
      Push key$ : Drop
Next i
Event Doit Drop Disp()
Event Doit New DocumentKeeper.AppendLine()
Event Header Hold
For i=1 to Block`Number-1
      Call DisplayBlock(Blocks`File$, i)
Next i
Report DocumentKeeper.Text$
 
End 
SaveBlock:
      Print "Save as Number ";Block`Number
      If Exist(Blocks`File$) then 
            // check if there is space for this block
            If Not filelen(Blocks`File$) div 1024>=Block`Number-1 Then
                  Error "Wrong Block Number"
            End if
      Else
            Print "not exist"
            Open Blocks`File$ for output as #f
            Close #f
            Wait 100
            // or Error "Empty File" if we wish only read
            If Block`Number<>1 then Error "Wrong Block Number"
      End if
      Open Blocks`File$ for append as #f
      Seek #f, Block`Number*1024-1023 ' so we seek to first byte
      Put #f, Page1
      Close #f
      Block`Number++
      Page1=NewBlock()
Return
}
MODULE FIXLENGTH {Module FixedFile {
      Read fixed$
      OldLocale=Locale
      \\ chr$(string_argument$)
      \\ use Locale to convert from Ansi to Utf-16LE
      \\ Read Ansi form files also use Locale
      Locale 1032
      Try ok {
            \\ Make the file first
            Const Center=2
            Font "Courier New"
            Bold 0
            Italic 0
            Def long m, z=1, f
            Def text2read$,test3write$
            Form 100, 50  ' 100 by 60 characters
            Document txt$={Line 1...1.........2.........3.........4.........5.........6.........7.........8
                  Line 2
                  Line 3
                  Line 4
 
                  Line 6
                  Line 7
                       Indented line 8............................................................
                  Line 9                                                                 RT MARGIN
                  }
            \\ use Help Open in M2000 console for details
            \\ Method one
            Report Center,  "Make file"
            \\ for WIDE Random \\  for Utf-16
            Open fixed$ for Random Exclusive as #f len=80
            m=Paragraph(txt$, 0)
            z=1
            If forward(txt$, m) then
                  while m, z<10
                        text2write$=Paragraph$(txt$,(m))
                        Print format$("Len:{0}, Data: {1}",Len(text2write$),text2write$)
                        Put #f, text2write$ , z
                        \\ record number from 1
                        \\ if number is total records plus one
                        \\ we append a record
                        z++     
                  End while
            End If
            Print "Press any key"
            Push Key$ : Drop
            Form 80, 40
            Report Center,  "Method1"
            For z=1 to 9
                  Get #f, text2read$, z
                  text2read$=StrRev$(text2read$)
                  Put #f, text2read$, z
                  Print text2read$
            Next z
            Close #f
            Report Center,  "Method2"
            \\ Method2
            \\ Buffer Clear Line80 ... \\ to clear memory
            \\ here we write all bytes so not needed
            Buffer Line80 as byte*80
            m=filelen(fixed$)
            If m mod 80=0 Then
                  m=1
                  \\ now Get/Put read write at byte position
                  \\ we have to use seek to move to byte position
                  \\ This way used for Binary files
                  Open fixed$ for Input as #f1
                  Open fixed$ for Append as #f2
                  while not eof(#f1)
                        seek #f1, m
                        Rem Print seek(#f)
                        Get #f1, Line80
                        Return line80,0:=Str$(StrRev$(Chr$(Eval$(line80,0,80))))
                        seek #f2, m
                        Put #f2, Line80
                        seek #f1, m
                        Get #f1, Line80
                        Print Chr$(Eval$(line80,0,80))
                        m+=80
                  End While
                  Close #f1
                  Close #f2
            End if
      }
      \\ use Close with no parameters for close all files if something happen
      If error then Close: Print Error$
      Locale OldLocale    
}
FixedFile "fixed.random"
Print "Press any key to display info page"
Push Key$ : Drop
Keyboard "Info"+chr$(13)
}
MODULE EERTREE {\\ https://rosettacode.org/wiki/Eertree
\\ https://en.wikipedia.org/wiki/Trie
\\ https://en.wikipedia.org/wiki/Suffix_tree
\\ Construct an eertree for the string "eertree", then output all sub-palindromes by traversing the tree.
Class Node {
      inventory myedges
      length, suffix=0
      Function edges(s$) {
            =-1 : if exist(.myedges, s$) then =eval(.myedges)
      }
      Module edges_append (a$, where) {
            Append .myedges, a$:=where
      }
Class:
      Module Node(.length) {
            Read ? .suffix, .myedges
      }     
}
function eertree(s$) {
      Const evenRoot=0, oddRoot=1
      Inventory Tree= oddRoot:=Node(-1,1),evenRoot:=Node(0,1)
      k=0
      suffix=oddRoot
      for i=0 to len(s$)-1 {
            c$=mid$(s$,i+1,1)
            n=suffix
            Do {
                 k=tree(n).length
                 b=i-k-1
                 if b>=0 then if mid$(s$,b+1,1)=c$ Then exit
                 n =tree(n).suffix  
            } Always
            e=tree(n).edges(c$)
            if e>=0 then suffix=e :continue
            suffix=len(Tree)
 
            Append Tree, len(Tree):=Node(k+2)
            Tree(n).edges_append c$, suffix
            If tree(suffix).length=1 then tree(suffix).suffix=0 : continue
            Do {
                  n=tree(n).suffix
                  b=i-tree(n).length-1
                  if b>0 Then If  mid$(s$, b+1,1)=c$ then exit
            } Always
            e=tree(n).edges(c$)
            if e>=0 then tree(suffix).suffix=e
 
      } 
      =tree
}
children=lambda (s, tree,  n, root$="")->{
            L=Len(tree(n).myEdges)
            if L=0 then =s : exit
            L--
            For i=0 to L {
                  c=tree(n).myEdges
                  c$=Eval$(c, i)  ' read keys at position i
                  nxt=c(i!)   '  read value using position 
                  p$ = if$(n=1 -> c$, c$+root$+c$)
                  append s, (p$,)
                  \\ better use lambda() and not children()
                  \\ for recursion when we copy this lambda to other identifier.
                  s = lambda(s, tree, nxt, p$)
            }
         = s
      }
aString=Lambda ->{
          Push Quote$(Letter$)
}
aLine=Lambda ->{
      Shift 2  ' swap two top stack items
      if stackitem$()="" then  { Drop}  Else Push letter$+", "+Letter$
}
Palindromes$=Lambda$ children, aString, aLine (Tree)-> {
            ="("+children(children((,), Tree, 0), Tree, 1)#Map(aString)#Fold$(aline,"")+")"
 }
 
Print Palindromes$(eertree("eertree"))
Print Palindromes$(eertree("banana"))
}
MODULE COMMON {thread.plan sequential   ' can run as concurrent too
linespace twipsY*2
' Mode as read only value return the height of layer form in pt. Using Mode we set to the same Mode but we cut extra space (use linespace also)
Mode 12
double  
backcolor=point
oldpen=pen
Refresh 500
Print Part $(6,Width+1),~(15, 7,pen),"Greatest common divisor"
Print under
gcd=lambda (u as long, v as long) -> {
           =if(v=0&->abs(u), lambda(v, u mod v))
}
gcd_Iterative= lambda (m as long, n as long) -> {
   while m  {
       let old_m = m
       m = n mod m
       n = old_m
   }
   =abs(n)
}
Module CheckGCD (f){
      Print Over  ~(#FFCCFF);"Calc gcd for 49865, 69811 = "; f(49865, 69811)  '=9973
      Print Under
      Def ExpType$(x)=Type$(x)
      Print Over "Return type:"; ExpType$(f(49865, 69811)) '="Long"
      Print Under
}
Print Part "Using a lambda function working with ";~(#AACCFF);"recursion"
Print Under
CheckGCD gcd
Print Part  "Using a lambda function working ";~(#AACCFF);"iterative"
Print Under
CheckGCD gcd_Iterative
normal
Print
Print
Press()
Keyboard "infobasic"+chr$(13)
End  ' we can omit this
Sub title(a$)
Pen #ffeeff {
	cursor 0
	Italic 1
	a$=replace$(chr$(9),"      ", a$)
	Report a$
	Italic 0
	cursor 6, row-1
}
End Sub
Sub Press()
	wait 200
	local col=15,  col2=backcolor, threadid
	Input End  ' empty buffer too
	Print @(0,Height);
	Thread {
		Pen col {
		Print Over $(3), "Press space bar or mouse key" 
		}
		swap col, col2
	} as threadid interval 250	
	Main.Task 10 {
		if keypress(1) or keypress(32) then exit
	rem		if mouse>0 or inkey$<>"" then exit
	}
	Threads Erase
End Sub
}
MODULE CLOCK {Αν Έγκυρο(ok) Αλλιως Πληκτρολόγιο "Clock1"+χαρ$(13) : Έξοδος
Όρισε Μ Μοναδικό      ' Declare m Mutex  : Methos m, "Create", "onename" return error if can't created with ownership
\\ we can create more than one mutexs in the m, using create
\\ so now this run only one time for the user. The second time the mutex exist so exit the program early.
Κάνε Συνέχισε Ως Λογικός
Δες  {
      Μέθοδος Μ, "CREATE", "Global\CLOCK10101001"
      Συνέχισε=Αληθής     
}
Αν Συνέχισε Αλλιώς Έξοδος
Ανανέωση 5000
Φόρμα
ομαλά ναί
Παράθυρο 16, Συσκευή
Οθόνη 5,0
Πενα 14
Περιθώριο {Πένα 14}
Επιφάνεια Κρυψε
Επιφάνεια 220, 5
\\ ανοίγει με ctrl+f1
Περί ! "Μ2000 Ρολόι 12 ωρών - M2000 Clock 12 hours", κλιμαξ.χ*5/7, κλιμαξ.υ*2/3,{
      Ελληνικά
            Ξυπνητήρι από 1 λεπτό έως 12 ώρες
            Μεσαίο πλήκτρο του ποντικιού βάζει/βγάζει το ξυπνητήρι/ σταματάει το κουδούνισμα
            Αριστερό/Δεξί πλήκτρο αλλάζει το ξυπνητήρι ανά λεπτό
            Μαζί με το μεσαίο αλλαζει το ξυπνητήρι ανά 10 λεπτά
            Τα βελάκια αριστερά - δεξιά αλλάζει επίσης το ξυπνητήρι
            Μαζί με το άνω βελάκι αλλάζει το ξυπνητήρι ανά 10 λεπτά
            Το κάτω βελάκι βάζει/βγάζει το ξυπνητήρι/ σταματάει το κουδούνισμα
            Το Enter αλλάζει τους δείκτες σε εμφάνιση (ανά ολόκληρες ώρες ή αναλογικά)
            Το διάστημα κλείνει το πρόγραμμα
            
      English
            Alarm for 1 minute to 12hours
            Middle mouse button set/reset/snooze alarm
            Left/right mouse button change at step one minute alarm time
            Using midle button and any of left or right change at step ten minutes
            Ledt/right arrows on keyboard change at step one minute alarm time
            pressing up arrow and of left or right on keyboard change at step ten minutes
            Down arrow used to set/reset/snooze alarm
            Enter key change clock hour to return analog to minutes time or at hour intervals.
            Space key exit the clock
      }
κχ=χ.σημεία-4000
κυ=4000
απ1=3000
απ2=600
απ3=απ1-απ2
κυκλ=πι*2
κυκλ60=κυκλ/60
Ξυπνητήρι=0
ΞυπνητήριΟκ=Ψευδής
ΠαίξεΉχο=Ψευδής
ΟλόκληρεςΏρες=Ψευδές
Αναβοσβήνει=Ψευδής
ΑρχικόςΧρόνος=20*10 \\ 20 δευτερόπλεπτα
ΧρόνοςΜπιπ=ΑρχικόςΧρόνος
Ωρα=0
Ωρα12=0
λεπτό=υπωρα(0,0,1,0)
Θέση κχ, κυ
\\ η χρώμα { } ; φτιάχνει περιοχή μόνο για εμφάνιση
Χρώμα { Κύκλος Γέμισμα 2, απ2+απ1 } ;
Θέση κχ-απ2-απ1, κυ-απ2-απ1
Βάψε 2*(απ2+απ1),2*(απ2+απ1), 7,1,1
Θέση κχ, κυ-απ1*3/4
Τίτλος "Μ2000 Ρολόι"
Επιγραφή "Μ2000 Ρολόι","Arial Black",18,0,2
Θέση κχ, κυ
\\ με χρώμα 5 αντί για #2277ff γίνεται διάφανο
\\ έχουμε δηλώσει το 5 (ματζέντα) στην εντολή Επιφάνεια
Πένα #2277ff {Κύκλος Γέμισμα #2277ff, απ3/2}
π=2
ι=0
Για ν=0 εως 59 
      Αν ν υπολ 5 = 0 τότε {π=4} αλλιώς π=1
      Πάχος π {
            Βήμα γωνια ι, απ1
            Χάραξε γωνία ι, απ2
            Βήμα γωνια ι, -απ2-απ1
      }
            ι+=κυκλ60
Επόμενο ν
Κράτησε
Μετακίνηση=Ψευδές
Ανανέωση 1000
Μετά 200 {Άναψε : Τίτλος "Μ2000 Ρολόϊ"}
Κάθε 100  {
Αναβοσβήνει~   \\ αντιστροφή λογικής  (Αναβοσβήνει = Δεν Αναβοσβήνει)
Άφησε
Ωρα=Τώρα
Ωρα12=(τιμη(γραφη$(Ωρα,"h")) υπολ 12) *60+τιμη(γραφη$(Ωρα,"n"))
Θέση κχ, κυ+απ1/2
      Αν Ωρα12<60 τότε {
            Επιγραφή Γραφη$(υπωρα(0,12,Ωρα12,τιμη(γραφη$(Ωρα,"s"))), "hh:nn:ss"), "Verdana", 18,0,2
      } Αλλιώς {
            Επιγραφή Γραφη$(υπωρα(0,0,Ωρα12,τιμη(γραφη$(Ωρα,"s"))), "hh:nn:ss"), "Verdana", 18,0,2
      }
Πένα -ΞυπνητήριΟκ*8+4 {      
      Βήμα , +απ1/8
      Επιγραφή "+"+Γραφη$(υπωρα(0,0,(ξυπνητήρι-Ωρα12+720) υπολ 720,0), "hh:nn "), "Verdana", 18,0,2
      Βήμα , +απ1/8

      Αν ξυπνητήρι<60 τότε {
            Επιγραφή Γραφη$(υπωρα(0,12,ξυπνητήρι,0), "hh:nn"), "Verdana", 18,0,2
      } Αλλιώς {
            Επιγραφή Γραφη$(υπωρα(0,0,ξυπνητήρι,0), "hh:nn"), "Verdana", 18,0,2
      }
}
Θέση κχ, κυ
γωνία_ξυπν=-ξυπνητήρι*πι/360+πι/2
Αν  Αναβοσβήνει ή όχι ΞυπνητήριΟκ τότε {
      Πάχος 2 {
            Βήμα Γωνία γωνία_ξυπν, απ3
            Χάραξε Γωνία γωνία_ξυπν, απ2, 13
                  Βήμα Γωνία γωνία_ξυπν, -απ2
            Βήμα Γωνία γωνία_ξυπν, -απ3
      }
}
Αν ΟλόκληρεςΏρες Τότε {
       γωνια_ώρα=-(τιμη(γραφη$(Ωρα,"h")) υπολ 12)*πι/6+πι/2
} Αλλιώς  γωνια_ώρα=-(τιμη(γραφη$(Ωρα,"h")) υπολ 12+τιμη(γραφη$(Ωρα,"n"))/60)*πι/6+πι/2
Πάχος 2 {
      Χάραξε Γωνία γωνία_ώρα+πι/20, απ3/2
      Χάραξε Γωνία γωνία_ώρα-πι/20, απ3/2
      Χάραξε Γωνία γωνία_ώρα+πι/20, -απ3/2
      Χάραξε Γωνία γωνία_ώρα-πι/20, -απ3/2
}
Αν ΟλόκληρεςΏρες Τότε {
      γωνία_λεπτά=-τιμη(γραφη$(Ωρα,"n"))*πι/30+πι/2
} Αλλιώς {
      γωνία_λεπτά=-(τιμη(γραφη$(Ωρα,"n"))+τιμη(γραφη$(Ωρα,"s"))/60)*πι/30+πι/2
}
Πάχος 2 {
      Χάραξε Γωνία γωνία_λεπτά+πι/20, απ1/2
      Χάραξε Γωνία γωνία_λεπτά-πι/20, απ1/2
      Χάραξε Γωνία γωνία_λεπτά+πι/20, -απ1/2
      Χάραξε Γωνία γωνία_λεπτά-πι/20, -απ1/2
}
γωνία_δευτ=-τιμη(γραφη$(Ωρα,"s"))*πι/30+πι/2
Πάχος 2 {
      Χάραξε Γωνία γωνία_δευτ, απ3, 15
      Βήμα Γωνία γωνία_δευτ, -απ3
}

Αν Πατημένο(1) ή Πατημένο(0x25) ή μετακίνηση τότε {

Αν Πατημένο(1) και ((Απολ(δείκτης.χ-κχ)<1000 και απολ(δείκτης.υ-κυ)<1000) ή Μετακίνηση)  τότε {
	κίνηση.π κίνηση.πχ+δείκτης.χ-κχ, κίνηση.πυ+δείκτης.υ-κυ
	Δείκτη.Μορφή 5
	Μετακίνηση=Αληθές
} Αλλιώς {
	Μετακίνηση=ψευδές
	Δείκτη.Μορφή 1
	Αν Πατημένο(4) ή Πατημένο(0x26) τότε {ξυπνητήρι-=10: ΞυπνητήριΟκ=Αληθής} αλλιώς ξυπνητήρι-- 
      ξυπνητήρι=(ξυπνητήρι+720) υπολ 720
}
} Αλλιως.Αν Πατημένο(2) ή Πατημένο(0x27) τότε {
	Μετακίνηση=ψευδές
	Δείκτη.Μορφή 1

Αν Πατημένο(4)  ή Πατημένο(0x26) τότε {ξυπνητήρι+=10: ΞυπνητήριΟκ=Αληθής} αλλιώς ξυπνητήρι++ 
      ξυπνητήρι=(ξυπνητήρι+720) υπολ 720
} Αλλιώς Μετακίνηση=Ψευδές: Δείκτη.Μορφή 1
Αν Πατημένο(32) τότε Έξοδος
Ανανέωση 1000
Αν ΞυπνητήριΟκ και ΧρόνοςΜπιπ>0 Τότε {
      Αν (τιμη(γραφη$(Ωρα,"h")) υπολ 12 )*60+τιμη(γραφη$(Ωρα,"n"))=ξυπνητήρι τότε {
            ΠαίξεΉχο=Αληθής
      }
}
Αν ΞυπνητήριΟκ και όχι (Πατημένο(2) ή Πατημένο(1)) Τότε {
      Αν Πατημένο(4) ή Πατημένο(0x28) Τότε ΠαίξεΉχο=Ψευδής: ΞυπνητήριΟκ=Ψευδής : ΧρόνοςΜπιπ=ΑρχικόςΧρόνος
} Αλλιώς.Αν Πατημένο(4) ή Πατημένο(0x28) Τότε {
            ΞυπνητήριΟκ=Αληθής
            ΧρόνοςΜπιπ=ΑρχικόςΧρόνος
}
Αν ΠαίξεΉχο Τότε {
      Αν ΧρόνοςΜπιπ υπολ 3 =0 τότε Μπιπ
      ΧρόνοςΜπιπ-- 
      Αν ΧρόνοςΜπιπ=0 Τότε ΠαίξεΉχο=Ψευδής: ΞυπνητήριΟκ=Ψευδής
}

Αν Πατημένο(13) τότε ΟλόκληρεςΏρες~  \\ αντιστροφή αληθές<>ψευδές
}
Τιτλος ".....",0
Οθόνη \\ επαναφορά από το περιορισμό περιοχής της Χρώμα
Επιφάνεια 255
Επιφάνεια Κρυψε
Μέθοδος Μ, "DESTROY", "Global\CLOCK10101001"   ' Declare m, "Destroy"
Όρισε Μ Τίποτα   ' Declare m Nothing
}
MODULE BOOK {Class Book {
      \\ these are public but can get value one time
      Final title$, des$, price, pback
      \\ we use a class part, which means a part that exist only at contruction time
Class:
      Module Book (a$, b$, c as decimal, d as boolean) {
      \\ we use fresh variables to catch a missin value
            .title$<=a$
            .des$<=b$
            .price<=c
            .pback<=d
      }
}
m=Book("a","b", 10, True)
Rem z=m.price
Rem Print type$(z)="Decimal"
try ok {
      m.price++
      Print "ok"
}
Rem Print Error$
Rem Print type$(m.price)="Constant"
Class BookDB {
Private:
      countme=0
      dim base 0, p()
Public:
      module final AddBook {
            newdim =.countme+1
            dim .p(newdim)
            read .p(.countme)
            .countme++
      }
      module final ProcessPaperbackBooks (&ProcessBookDelegate) {
            if .countme<1 then break
            for i=0 to .countme-1 {  
                  if .p(i).pback then call  ProcessBookDelegate.processBook(.p(i)) 
            }

      }
}
Group PrintTitle {
      function final processBook(AnyBook) { Report format$("    {0}", AnyBook.title$)} 
}
Group PriceTotaller {
      items, total
      function final processBook(AnyBook) {.items++ :  .total+=AnyBook.price }
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for Group only
      module final zero { .total<=0 : .items<=0   }
      function final AveragePrice { if .items>0 then =.total/.items }
}
bookDB=bookDB()
Report "First Book DB"

      bookDB.AddBook Book("The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, True)
      bookDB.AddBook Book("The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, True)
      bookDB.AddBook Book("The MS-DOS Encyclopedia", "Ray Duncan", 129.95, False)
      bookDB.AddBook Book("Dogbert's Clues for the Clueless", "Scott Adams", 12.00, True)
      bookDB.ProcessPaperbackBooks &PriceTotaller
      Report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      bookDB.ProcessPaperbackBooks &PrintTitle

Report "Second Book DB"    \\Report prints text  proportionally with justifiation
PriceTotaller.zero
SecondbookDB=bookDB()

      SecondbookDB.AddBook Book("Any Big Big and Big Tilte",  "Any Author", 3.45, True)
      SecondbookDB.ProcessPaperbackBooks &PriceTotaller
      Report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      SecondbookDB.ProcessPaperbackBooks &PrintTitle
}
MODULE BOOK1 {prototype {
      local countme=0
      dim t$(), a$(), p(), pb()
      function AddBook {
            for this {
                  newdim =.countme+1
                  dim base 0, .t$(newdim), .a$(newdim), .p(newdim), .pb(newdim)      
                  read .t$(.countme), .a$(.countme), .p(.countme), .pb(.countme)
                  .countme++
            }
      }
      module ProcessPaperbackBooks {
            read &ProcessBookDelegate 
            if .countme<1 then exit
            for i=0 to .countme-1 {  
                  if .pb(i) then call  ProcessBookDelegate.processBook(&this, i) 
            }
      }
} as booktype$
group PrintTitle {
      function processBook { read &AnyBook, i : Report format$("    {0}", AnyBook.t$(i) )} 
}
group PriceTotaller {
      local items, total
      function processBook { read &AnyBook, i : for this {.items++ : for Anybook {.total+=..p(i)  } }}
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for group only
      module zero { .total<=0 : .items<=0 }  
      function  AveragePrice { if .items>0 then =.total/.items }
}
group bookDB type booktype$      
report "First Book DB"
for bookDB {
      call .AddBook("The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, true)
      call .AddBook("The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, true)
      call .AddBook("The MS-DOS Encyclopedia", "Ray Duncan", 129.95, false)
      call .AddBook("Dogbert's Clues for the Clueless", "Scott Adams", 12.00, true)
      call .ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      call .ProcessPaperbackBooks &PrintTitle
}
report "Second Book DB"    \\report prints text  proportionally with justification
PriceTotaller.zero
group SecondbookDB type booktype$
for SecondbookDB {
      call .AddBook("Any Big Big and Big Tilte",  "Any Author", 3.45, true)
      call .ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      call .ProcessPaperbackBooks &PrintTitle
}
}
MODULE BOOK2 {class BookDB {
      countme=0
      dim t$(), a$(), p(), pb()
      module AddBook {
            newdim =.countme+1
            dim base 0, .t$(newdim), .a$(newdim), .p(newdim), .pb(newdim)      
            read .t$(.countme), .a$(.countme), .p(.countme), .pb(.countme)
            .countme++
      }
      module ProcessPaperbackBooks (&ProcessBookDelegate) {
            if .countme<1 then break
            for i=0 to .countme-1 {  
                  if .pb(i) then call  ProcessBookDelegate.processBook(&this, i) 
            }

      }
}
group PrintTitle {
      function processBook (&AnyBook, i) { Report format$("    {0}", AnyBook.t$(i) )} 
}
group PriceTotaller {
      items, total
      function processBook (&AnyBook, i) {for this {.items++ : for Anybook {.total+=..p(i)  } }}
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for group only
      module zero { .total<=0 : .items<=0   }
      function  AveragePrice { if .items>0 then =.total/.items }
}
bookDB=bookDB()
report "First Book DB"

      bookDB.AddBook "The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, true
      bookDB.AddBook "The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, true
      bookDB.AddBook "The MS-DOS Encyclopedia", "Ray Duncan", 129.95, false
      bookDB.AddBook "Dogbert's Clues for the Clueless", "Scott Adams", 12.00, true
      bookDB.ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      bookDB.ProcessPaperbackBooks &PrintTitle

report "Second Book DB"    \\report prints text  proportionally with justifiation
PriceTotaller.zero
SecondbookDB=bookDB()

      SecondbookDB.AddBook "Any Big Big and Big Tilte",  "Any Author", 3.45, true
      SecondbookDB.ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      SecondbookDB.ProcessPaperbackBooks &PrintTitle
}
MODULE BOOK3 {Class Book {
      \\ read only properties -- we change value using private variables any time.
      property title$ {value}
      property des$ {value}
      property price {value} =0@	\\ a decimal value
      property pback {value} =1=1	\\ this is a boolean value, True is -1 double
      \\ we use a class part, which means a part that exist only at contruction time
Class:
      Module Book (a$, b$, c, d) {
      \\ we use fresh variables to catch a missin value
            .[title]$<=a$
            .[des]$<=b$
            .[price]<=c
            .[pback]<=d
      }
}
Class BookDB {
Private:
      p=(,)
Public:
      module final AddBook {
            \\ group return a float pointer
            \\ use of (group) inside pointer to return a real pointer, else we get error, we can't get a weak pointer from stack.
            \\ a weak pointer is a pointer to an identifier, which has to exist when we have to use it.
            \\ (1,)  is an one item array
            \\ append to an array a series of arrays. here we add an array with one item
            append .p, (pointer((group)),)
      }
      module final ProcessPaperbackBooks (&ProcessBookDelegate) {
            m=each(.p)
            \\ m is iterator for .p
            while m
                  aBook=array(m)
                  \\ aBook get a pointer to a group
                  if aBook=>pback then
                        call  ProcessBookDelegate.processBook(aBook)
                  end if
            end while
      }
}
group PrintTitle {
      function final processBook (AnyBook as pointer) { Report format$("    {0}", AnyBook=>title$)} 
}
group PriceTotaller {
      items, total
      function final processBook (AnyBook as pointer) {.items++ :  .total+=AnyBook=>price }
      \\  look the <= operator, if we use = then we define local variables. Items and total are like global but for group only
      module final zero { .total<=0 : .items<=0   }
      function final AveragePrice { if .items>0 then =.total/.items }
}
\\ bookDB is a pointer to a float group (a float group is a closed type group)
\\  -> is same as pointer()
\\ a class always return a float group
\\ from float groups we get real pointers
bookDB->bookDB()
report "First Book DB"

      For bookDB {
            \\ a non float group prepared with values from the float group
            \\ any new definition deleted after the end of a for object block
            .AddBook Book("The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, true)
            .AddBook Book("The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, true)
            .AddBook Book("The MS-DOS Encyclopedia", "Ray Duncan", 129.95, false)
            .AddBook Book("Dogbert's Clues for the Clueless", "Scott Adams", 12.00, true)
            .ProcessPaperbackBooks &PriceTotaller
            report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
            .ProcessPaperbackBooks &PrintTitle
      }

report "Second Book DB"    \\report prints text  proportionally with justifiation
PriceTotaller.zero
\\ the SecondbookDB  is a non float group.
SecondbookDB=bookDB()

      SecondbookDB.AddBook Book("Any Big Big and Big Tilte",  "Any Author", 3.45, true)
      SecondbookDB.ProcessPaperbackBooks &PriceTotaller
      report  "Average Paperback Book Price: $" + str$(PriceTotaller.AveragePrice(),"#.##")
      PointerA->SecondbookDB
      PointerA=>ProcessPaperbackBooks &PrintTitle
\\ PointerA is not a real pointer. Is a weak pointer to a non float group.
}
MODULE BOOK4 {\\ we pass a group function by reference
class booktype {
      local countme=0
      dim base 0,  t$(), a$(), p(), pb()
      module AddBook {
                  newdim =.countme+1
                  dim .t$(newdim), .a$(newdim), .p(newdim), .pb(newdim)      
                  read .t$(.countme), .a$(.countme), .p(.countme), .pb(.countme)
                  .countme++
      }
      module ProcessPaperbackBooks {
            read &AnyFunction()
            if .countme<1 then exit
            for i=0 to .countme-1 {  
                  if .pb(i) then call  AnyFunction(&this, i) 
            }
      }
}
function PrintTitle {
      read &AnyBook, i : Report format$("    {0}", AnyBook.t$(i) )
}
class PriceTotaller {
      local items, total
      function processBook { read &AnyBook, i : for this {.items++ : for Anybook {.total+=..p(i)  } }}
      module zero { .total<=0 : .items<=0 }  
      function  AveragePrice { if .items>0 then =.total/.items }
}
bookDB=booktype()
PriceTotaller1=PriceTotaller()
report "First Book DB"
for bookDB {
      .AddBook"The C Programming Language",  "Brian W. Kernighan and Dennis M. Ritchie", 19.95, true
      .AddBook"The Unicode Standard 2.0",  "The Unicode Consortium", 39.95, true
      .AddBook"The MS-DOS Encyclopedia", "Ray Duncan", 129.95, false
      .AddBook"Dogbert's Clues for the Clueless", "Scott Adams", 12.00, true
      .ProcessPaperbackBooks &PriceTotaller1.processBook()
      report  "Average Paperback Book Price: $" + str$(PriceTotaller1.AveragePrice(),"#.##")
      .ProcessPaperbackBooks &PrintTitle()
}
report "Second Book DB"   
PriceTotaller2=PriceTotaller()
SecondbookDB=booktype()
for SecondbookDB {
      .AddBook "Any Big Big and Big Tilte",  "Any Author", 3.45, true
      .ProcessPaperbackBooks &PriceTotaller2.processBook()
      report  "Average Paperback Book Price: $" + str$(PriceTotaller2.AveragePrice(),"#.##")
      .ProcessPaperbackBooks &PrintTitle()
}
}
MODULE POPUP {title "",0
Declare Form1 Form
Declare aPopUpForm Form
With Form1, "Title", "Hello There"
With aPopUpForm, "Title", "This is a PopUp Form", "Visible" as PopUpVisible
Declare Text1 TextBox Form aPopUpForm
Method Text1,"Move", 2000,2000,6000,600
With Text1,"Text" as txt$
txt$="U+10437 (𐐷) in UNICODE"
Function Text1.Enter {
      \\ If we press enter in textbox in popup form
      \\ we change title in form1
      With Form1, "Title", txt$
      With form1, "GetFocus"
}
X=1000
Function Form1.MouseDown {
\* Use STACK to see stack in console...
\* ...before you decide what to do with the values
\* Stack is cleared by you or by system, if stack isn't empty
      Rem 1 : Stack
      Read button
      If button<>2 Then Exit
      Drop  \\ drop shift
      Local X, Y : Read X, Y
      
      Method Form1, "PopUp", aPopUpForm, X, Y
}
refresh
With Form1, "visible" as visible
p=0
thread {
      if visible then print "ok" : refresh :  p=ask("test RIGHT click on form's layer ","Explain","Test now","") : thread this erase
} as k interval 100
Method Form1,"Show", 1  \\ modal  means wait to return
\\ we return focus to console
Show
Declare Form1 Nothing
Declare aPopUpForm Nothing
Print X
Title "Info"
end
}
MODULE SURROGATE {\\ pressing alt press INS or + on keypad and 10437 on keypad or number keys and release alt to get 𐐷

Print #-2, {"𐐷"}
Print hex$(chrcode("𐐷"),2.5)="10437"
Print chrcode$(0x10437)="𐐷"

keyboard "𐐷"
print inkey$
keyboard "𐐷"
Print key$
keyboard "1𐐷2"+chr$(13)
Input "surrogate=",a$
Print a$
Print $(4), "surrogate=";
Input ! a$, 30
Print a$, $(0)   ' return to normal text
if random(1,2)=1 then Print else Print Under
Report a$
}
MODULE CS {Clear // Clear all variables/objects
Flush // Empty the stack
first$={using System;
            using System.Drawing;
            using System.Windows.Forms;
             
            class CSharpPendulum
            {
                Form _form;
                Timer _timer;
             
                double _angle = Math.PI / 2, 
                       _angleAccel, 
                       _angleVelocity = 0, 
                       _dt = 0.1;
             
                int _length = 50;
             
                [STAThread]
                static void Main()
                {
                    var p = new CSharpPendulum();
                }
             
                public CSharpPendulum()
                {
                    _form = new Form() { Text = "Pendulum -  Γιώργος", Width = 400, Height = 200 };
                    _timer = new Timer() { Interval = 30 };
             
                    _timer.Tick += delegate(object sender, EventArgs e)
                    {
                        int anchorX = (_form.Width / 2) - 12,
                            anchorY = _form.Height / 4,
                            ballX = anchorX + (int)(Math.Sin(_angle) * _length),
                            ballY = anchorY + (int)(Math.Cos(_angle) * _length);
             
                        _angleAccel = -9.81 / _length * Math.Sin(_angle);
                        _angleVelocity += _angleAccel * _dt;
                        _angle += _angleVelocity * _dt;
             
                        Bitmap dblBuffer = new Bitmap(_form.Width, _form.Height);
                        Graphics g = Graphics.FromImage(dblBuffer);
                        Graphics f = Graphics.FromHwnd(_form.Handle);
             
                        g.DrawLine(Pens.Black, new Point(anchorX, anchorY), new Point(ballX, ballY));
                        g.FillEllipse(Brushes.Black, anchorX - 3, anchorY - 4, 7, 7);
                        g.FillEllipse(Brushes.DarkGoldenrod, ballX - 7, ballY - 7, 14, 14);
             
                        f.Clear(Color.White);
                        f.DrawImage(dblBuffer, new Point(0, 0));    
                    };
             
                    _timer.Start();
                    Application.Run(_form);
                }     
            }
            }
title$="C# Editor"
typ$="cs"
W$=""
path$=""
Dir User
lookpath$=dir$
Declare NotePad Form
Declare Pad EditBox Form NotePad
Declare Inform1 Button Form NotePad
With Inform1, "Caption" as Informe$
Method Inform1, "Colors", 15, #FFA000
With Inform1, "Locked", True
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Run1 Combobox Form NotePad
Declare Help1 Combobox Form NotePad
With File1,"label","File", "listtext" As list$, "list" As list$(), "Hover", true
With Edit1,"label","Edit",  "Mark", Color(255,100,0), "Hover", True
With Run1,"label","Run",  "Mark", Color(255,100,0), "Hover", True
With Help1,"label","Help",  "Mark", Color(255,100,0), "Hover", True

With NotePad, "Title" As Caption$, "Visible" As Visible, "TitleHeight" As tHeight, "Sizable", True
With NotePad, "UseIcon", True, "UseReverse", True
With Pad, "Text" As Pad.text$, "ShowAlways", True,"NoColor", True,"SelLength" as SelLength
With Pad, "ColorSet", 1, "linespace", 30, "NoCenterLineEdit", True   ' we can tongle value of  NoCenterLineEdit  using shift F9
Method Pad, "UserColorSet", false, , -#ff0000
Def TitleStr$(a$)=Ucase$(Left$(a$,1))+Mid$(a$,2)
Filename$=Dir$+"pendulum.cs"

Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
Title "",0
Method NotePad,"MakeStandardInfo", 1
Method NotePad,"move", 2000, 4000, 8000, 4000
Layer NotePad {Cls #FFA000}
With File1,"MenuStyle", True, "MenuWidth", 3000 
With Edit1,"MenuStyle", True, "MenuWidth", 3000,"menuEnabled" as Enabled() 
With Run1,"MenuStyle", True, "MenuWidth", 3000,"menuEnabled" as Comp.Enabled()
With Help1,"MenuStyle", True, "MenuWidth", 3000 
With File1, "MenuEnabled" As mEnable()
For This {
      mi$="MenuItem"  // is a temporary variable only for For This Block
      With File1, "MenuGroup","This"
      Method File1, mi$,"Open",True
      Method File1, mi$,"Save",True
      Method File1, mi$,""    //  only  a line here
      Method File1,"MenuRadio","txt files",True,False
      Method File1,"MenuRadio","cs files",True,True
      
      Method File1, mi$,""
      Method File1, mi$,"Close",True
      Method File1, mi$,""
      Method File1, mi$,"Quit",True
           
      
      With Edit1, "MenuGroup","This"
      Method Edit1, mi$,"Cut",False
      Method Edit1, mi$,"Copy",False
      Method Edit1, mi$,"Paste",True
      Method Edit1, mi$,""
      Method Edit1, mi$,"Less Indent",True
      Method Edit1, mi$,"More Indent",True  
      
      With Run1, "MenuGroup","This"
      Method Run1, mi$,"Compile test",true
      Method Run1, mi$,"Run test > out",False
      Method Run1, mi$,"Run test",False
      Method Run1, mi$,"Show Out.Txt",False
      Method Run1, mi$,""
      Method Run1, mi$,"Compile Final",true
      Method Run1, mi$,"Open Cmd.exe",true
    
      With Help1, "MenuGroup","This"
      Method Help1, mi$, "About", True
      Method Help1, mi$,""
      Method Help1, mi$,"Bright Theme",true
      Method Help1, mi$,"Dark Theme",true
}

if exist(Filename$) then
      Document BackUp$
      Load.Doc BackUp$, filename$
else
      Document BackUp$=first$
end if
Pad.text$=BackUp$
Function NotePad.Unload {
      Read New &Ok
      After 30 {Call local File1.DblClick(8) }
      Ok=True

}
Function Notepad.Resize {
      Layer NotePad { Cls Color(255, 160, 0) ,0}
      With NotePad, "Width" As NP.Width, "Height" As NP.Height, "TitleHeight" As tHeight
      tHeight1=theight*2
      Method File1,"move", twipsX*3, tHeight,  twipsX*80, tHeight
      Method Edit1,"move", twipsX*3+twipsX*80, tHeight,  twipsX*80, tHeight
      Method Run1,"move", twipsX*3+twipsX*160, tHeight,  twipsX*80, tHeight
      Method Help1,"move", twipsX*3+twipsX*240, tHeight,  twipsX*160, tHeight
      Method Inform1,"move", twipsX*3+twipsX*320, tHeight,  twipsX*240, tHeight
      If NP.height>1000 Then {
            Method Pad,"move", twipsX*3, tHeight1,  NP.Width-twipsX*6, NP.Height-tHeight1-twipsY*3
            With Pad, "NoWrap" As NoWrap
            If Not NoWrap Then Method Pad,"Resize"
      }
}
Function Edit1.OpenMenu {
            Local X
            X=SelLength>0
            Enabled(0)=X
            Enabled(1)=X
}

Function Edit1.DblClick {
      Read Local Edit1index
      Select Case Edit1index
      Case 0
            {
            Method Pad,"mn1sub"
            Method Pad,"Resize"
            }
      Case 1
            Method Pad,"mn2sub"
      Case 2
            {
                 Method Pad, "mn3sub"
                 Method Pad,"GetFocus"
                 Method Pad,"Resize"
           }
        Case 4
           {
                  Method Pad,"PressKey", 9, 1
            }
        Case 5
           {
                  Method Pad,"PressKey", 9, 0
            }
      End Select

}
Function Pad.Inform {
      Read New L, P
      Informe$=format$("{0}-{1}", L,P)
      Method Pad,"Show"
}
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}
function cs_choose{
       With Pad, "ColorCollection1", lcase$("|abstract|as|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|do|double|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|goto|if|implicit|in|int|interface|internal|is|lock|long|namespace|new|null|object|operator|out|override|params|private|protected|public|readonly|ref|return|sbyte|sealed|short|sizeof|stackalloc|static|string|struct|switch|this|throw|True|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|using|static|virtual|void|volatile|while|add|alias|ascending|async|await|by|descending|dynamic|equals|from|get|global|group|into|join|let|nameof|on|orderby|partial|remove|select|set|value|var|when|where|yield|"),"NoColor", False, "UseCase", True,"ExtraFront", "_", "LineComment2", "", "CommentSymbols","[/][/]", "ComSymbolsWidth", 2, "CommentLineLight", false, "MultiLineComment1", "/*","MultiLineComment2", "*/"
      With Pad, "WordCharLeft"," ,+-=/*^()[];<>:?", "WordCharRight"," .,+-=/*^()[];<>?:","OtherSymbols","@","UseColon",";"
      With Pad,"StartSymbols", "+-&|*=></,.1234567890()'"+chr$(34), "StringSep2","'", "EnablePairs", True, "linespace", 30
      With Pad, "SearchWords", True, "nowrap", True, "AllowInsertBrackets",  True, "SpaceIndent", 2, "HighlightParagraph", True, "Default", True
      Method Pad, "ReColor"
      Method Pad, "Show"
}

Function Dark(){  '  13619071
      With Pad, "ColorSet", 0, "linespace", 60, "SelectionColor", -#FF0000, "SelectionTextColor", -color(14), "HighLightColor", -Color(60,60,128)
       Method Pad, "Colors", -color(50,50,50),-color(14),,,-color(0)
        Method Pad, "SetBarStyle", #DD9033, -1
      Method Pad, "Show"
      
      
}
Function Bright(){
      With Pad, "ColorSet", 1, "HighLightColor", -Color(225,255,255)
      Method  Pad, "UserColorSet",0,,,,,,,,-#FF0000
      With Pad, "ColorSet", -1
      Method Pad, "SetBarStyle", color(50, 100,  200), 5, 15
      Method Pad, "ColorsReset"
      Method Pad, "ResetSelColors"
      Method Pad, "Show"
}

Function Run1Status() {
      if file.type$(filename$)="cs" then
            Comp.Enabled(0)=True
            Comp.Enabled(1)=False
            Comp.Enabled(2)=False
            Comp.Enabled(5)=True        
      else
            Comp.Enabled(0)=False
            Comp.Enabled(1)=False
            Comp.Enabled(2)=False
            Comp.Enabled(5)=False            
      end if
}
Function File1.MenuChecked {
Read New RadioIndex // 3 or 4
If RadioIndex =3 Then {
      After 30 { Static a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".txt"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="txt"
      Call local Run1Status()
      With Pad, "ColorCollection1", "","NoColor", True,  "UseCase", False
      Pad.text$=Pad.text$
      Method Pad, "Show"
      }
} Else.If RadioIndex =4 Then {
     After 30 { local a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".cs"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="cs"
      Call local cs_choose()
      Call local Run1Status()
      }      
}

}
Function File1.DblClick {
// we use functions As subs here
// each function and each module have a name (define a namespace)
// but here real module name is the File1.DblClick() host module
// this is done because is a Gui Event Service Function
// and is Call With Local tag (Call Local)
      Read New File1index
      Local cont, cont2, f$, NL$={
      }
      File1index++
      // Because we want some jumps..we use  On Goto
      // on Goto need here a block
      {
      On File1index Goto Open1, Save1, ExitNow, ExitNow, ExitNow, ExitNow, Save2, ExitNow,  Unload
Exitnow:
      Exit
Open1:
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes first?",title$, "Yes","No")=1 Then Goto Save1
      }
     Layer NotePad {
           Open.file filename$,,"Load Text ("+typ$+") File",typ$
     }
     
     Method Pad,"GetFocus"
     Read f$
     If f$<>"" Then {
           Filename$=f$
           If Exist(F$) Then {
           Clear BackUp$
           Call Local Run1Status()
           Load.Doc BackUp$, f$
           
           Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
           lookpath$=file.path$(Filename$)
           // silent means here without refresh
           With Pad, "SelStartSilent", 0, "SellengthSilent",0 
           Pad.text$=BackUp$
           } Else Pad.text$="": Clear BackUp$
           Method Pad, "ReColor"
      }
      Exit
Save1:
      Layer NotePad {
            Save.As Filename$,,"Save Text ("+typ$+") File",typ$
      }
      If Not cont2 Then Method Pad,"GetFocus"
      Read f$   ' from save.as we get a value
      If f$="" Then Exit 
      If Lcase$(File.type$(f$))<>typ$ Then f$=f$+"."+typ$
      If Exist(f$) Then  If Ask(NL$+"Overwrite"+NL$+f$,title$, "Yes","No")<>1 Then Exit
      Try ok {
        Clear BackUp$
        BackUp$=Pad.text$
        Save.Doc BackUp$, f$  ' by default 2 - Utf-8
        filename$=f$
        lookpath$=file.path$(Filename$)
        Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
      }
     If ok Else Beep
     If Not cont Then Exit
Save2:
      cont=True
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes?",title$, "Yes","No")=1 Then Goto Save1
      }
      Clear BackUp$
      Pad.text$=""
      If Cont2 Then {
            Method NotePad, "CloseNow"
      } Else {
            FileName$=Dir$+"Untitled."+typ$
            Caption$=TitleStr$(File.Name$(Filename$)) +" - C# Editor"
            Method Pad, "Resize"
      }
      Exit
Unload:
      Cont2=True : Goto Save2
      }
}
function gecsc_folder {
             dir path$(0x24)+"Microsoft.NET\Framework\"
             dir ? dir$, "Choose Framework"
             path$=dir$
             dir user
}

thread {
      informe$=if$((tick mod 4 +1) ->"|", "/","-","\")
      If not Comp.Enabled(3) then {
            if exist(dir$+"test.bat") then {
                  Informe$="ready to compile"
                  Comp.Enabled(3)=True
                  Comp.Enabled(0)=True
                  Method Pad,"Show"                  
            }
      } else.if exist(lookpath$+"test.exe") then {
             Comp.Enabled(1)=true
             Comp.Enabled(2)=true
             informe$="Compiled"
             thread this hold
      }

} as lookEXE interval 1000
thread lookEXE hold
Function Run1.DblClick {
      Read New Run1index
      select case Run1index
      case 0
      {            
            Comp.Enabled(0)=False
            Comp.Enabled(1)=False
            Comp.Enabled(2)=False
            Comp.Enabled(3)=False
            Informe$=""
            Call local gecsc_folder()
            if  path$="" then Beep:Comp.Enabled(0)=True :exit
            if not exist(path$+"csc.exe") then beep : Comp.Enabled(0)=true : exit 
            try {
                   if exist(dir$+"test.bat") then dos "del "+quote$(dir$+"test.bat");
                  if exist(dir$+"test.exe") then dos "del "+quote$(dir$+"test.exe");
            }
            local aa$
            Document aa$=Pad.text$
            dir user
            Save.doc aa$, "test.cs", 2   ' for UTF-8  see help
            
            if instr(aa$,"System.Windows.Forms")>9 then w$="win" else w$=""
            clear aa$
            aa$={setlocal
                        set PATH=}+Path$+{;
                        set LIB=%WINDIR%\Microsoft.NET\Framework\;
                        csc.exe  /target:}+w$+{exe /out:test.exe test.cs
                        endlocal
                        }
            Save.doc aa$, "test.bat", 3  ' Ansi for bat
            after 300 {
                  dir user
                  dos "cd "+dir$+" && test.bat  > out.txt";
                  after  200 {
                  
                        Thread lookEXE interval 100
                        Thread lookEXE Restart
                  }                 
                  'Method Pad,"GetFocus"
            }
           after 500 {Comp.Enabled(0)=true}
      }
      case 1
            {
                  thread lookEXE Hold
                  After 40 {
                  if w$="" then
                         dos "cd "+dir$+" && test.exe > out.txt";
                        Comp.Enabled(3)=True
                   else
                         win dir$+"test.exe"
                   end if
                  }
            }
      case 2
            {
                  thread lookEXE Hold
                  After 40 {
                  if w$="" then
                         dos "cd "+dir$+" && test.exe"
                        Comp.Enabled(3)=False
                   else
                         win dir$+"test.exe"
                   end if
                  }
            }
      case 3
        {
            try {win "out.txt"
            Thread lookEXE hold
            }
            informe$=""
      }
      case 5
      {
            local aa$
            Document aa$
            try {
                  Call local gecsc_folder()
                  if  path$="" then exit
                  if not exist(Filename$) then 
                        Call local File1.DblClick(1)
                  else
                        Load.doc aa$, Filename$
                        if aa$<>Pad.text$ then Call local File1.DblClick(1)
                        if instr(aa$,"System.Windows.Forms")>9 then w$="win" else w$=""
                        clear aa$
                  end if
                  aa$={setlocal
                        set PATH=}+Path$+{;
                        set LIB=%WINDIR%\Microsoft.NET\Framework\;
                        csc.exe  /target:}+w$+{exe /out:}+quote$(File.Name.only$(Filename$)+".exe")+" "+quote$(File.Name$(Filename$))+{
                        endlocal
                  }
                  Save.doc aa$, "final.bat", 3
                  After 40 {
                        dos "cd "+shortdir$(dir$)+" && final.bat";
                  }     
            }
      }   
      case 6
      dos "cd "+quote$(dir$)+" && cls "   
      end select
}
Function Help1.DblClick {
     rem  Read New Help1index  // we get the number without variable
      select case Number
      case 0
      {
          Local A, info$
            Info$={
                  This is an example
                  of an editor for c#
                  written for M2000 Environment
                  use F1 to change wrap
                  }
            A=Ask(info$,title$,"","")
            Method Pad, "GetFocus"
      }
      Case 2
      Call Local Bright()
      Case 3
      Call Local Dark()
      End Select

}
Function Notepad.InfoClick {
    Read New X
    If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Call Local Notepad.Resize()
// open As modal
Title "", 0
Call local cs_choose()
Call Local Bright()
Method NotePad,"Show" , 1
Declare Pad Nothing
Declare NotePad Nothing 
If Module(Info) Then
    Title "Info"
    keyboard "INFOBasic"+chr$(13)
end if
}
MODULE ΓΛΩΣΣΑ {\\ notepad for educational school language ΓΛΩΣΣΑ
Greek  ' this make the popup menu of edit boc as 
Show
Clear
Flush
first$={ΠΡΟΓΡΑΜΜΑ Κυκλική_Ουρά
ΣΤΑΘΕΡΕΣ
  ΛάθοςΕξ = "Λάθος Εξαγωγής, Η ουρά είναι άδεια"
  Εξ = "Εξαγωγή "
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Πίσω, Μπροστά, Ουρα[10], ι, Τιμή
ΑΡΧΗ
  Τιμή <- 0
  Πίσω <- 1
  Μπροστά <- 0
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 10
    Ουρα[ι] <- 0
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Προσθήκη 10 στοιχεία 1 έως 10
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 10
    ΚΑΛΕΣΕ Εισαγωγή_Στοιχείου(ι, Πίσω, Μπροστά, Ουρα) 
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Αφαίρεση 5 στοιχείων
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 5
    ΑΝ Μπροστά <> 0 ΤΟΤΕ
      ΚΑΛΕΣΕ Εξαγωγή_Στοιχείου(Τιμή, Πίσω, Μπροστά, Ουρα) 
      ΓΡΑΨΕ Εξ, Τιμή
    ΑΛΛΙΩΣ
      ΓΡΑΨΕ ΛάθοςΕξ
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Προσθήκη 5 στοιχεία 11 έως 15
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 5
    ΚΑΛΕΣΕ Εισαγωγή_Στοιχείου(ι + 10, Πίσω, Μπροστά, Ουρα) 
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Αφαίρεση 10 στοιχείων
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 10
    ΑΝ Μπροστά <> 0 ΤΟΤΕ
      ΚΑΛΕΣΕ Εξαγωγή_Στοιχείου(Τιμή, Πίσω, Μπροστά, Ουρα) 
      ΓΡΑΨΕ Εξ, Τιμή
    ΑΛΛΙΩΣ
      ΓΡΑΨΕ ΛάθοςΕξ
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Προσθήκη 2 στοιχεία 16 έως 17
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 2
    ΚΑΛΕΣΕ Εισαγωγή_Στοιχείου(ι + 15, Πίσω, Μπροστά, Ουρα) 
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
!! Αφαίρεση 3 στοιχείων
  ΓΙΑ ι ΑΠΟ 1 ΜΕΧΡΙ 3
    ΑΝ Μπροστά <> 0 ΤΟΤΕ
      ΚΑΛΕΣΕ Εξαγωγή_Στοιχείου(Τιμή, Πίσω, Μπροστά, Ουρα) 
      ΓΡΑΨΕ Εξ, Τιμή
    ΑΛΛΙΩΣ
      ΓΡΑΨΕ ΛάθοςΕξ
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
  ΚΑΛΕΣΕ Δείξε(Πίσω, Μπροστά, Ουρα) 
ΤΕΛΟΣ_ΠΡΟΓΡΑΜΜΑΤΟΣ

ΔΙΑΔΙΚΑΣΙΑ Εισαγωγή_Στοιχείου(Α, Πίσω, Μπροστά, Ουρα) 
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Α, Πίσω, Μπροστά, Ουρα[10] 
ΑΡΧΗ
  ΑΝ Πίσω = Μπροστά ΤΟΤΕ
    ΓΡΑΨΕ "Η ουρά γέμισε, δεν θα βάλω το ", Α
  ΑΛΛΙΩΣ
    ΑΝ Μπροστά = 0 ΤΟΤΕ
      Μπροστά <- Πίσω
    ΤΕΛΟΣ_ΑΝ
    Ουρα[Πίσω] <- Α
    Πίσω <- Πίσω mod 10 + 1
  ΤΕΛΟΣ_ΑΝ
ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ
ΔΙΑΔΙΚΑΣΙΑ Εξαγωγή_Στοιχείου(Α, Πίσω, Μπροστά, Ουρα) 
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Α, Πίσω, Μπροστά, Ουρα[10] 
ΑΡΧΗ
  ΑΝ Μπροστά > 0 ΤΟΤΕ
    Α <- Ουρα[Μπροστά] 
    Μπροστά <- Μπροστά mod 10 + 1
    ΑΝ Μπροστά = Πίσω ΤΟΤΕ
      Μπροστά <- 0
    ΤΕΛΟΣ_ΑΝ
  ΤΕΛΟΣ_ΑΝ
ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ
ΔΙΑΔΙΚΑΣΙΑ Δείξε(Πίσω, Μπροστά, Ουρα) 
ΜΕΤΑΒΛΗΤΕΣ
  ΑΚΕΡΑΙΕΣ: Πίσω, Μπροστά, Ουρα[10], ι
ΑΡΧΗ
  ΑΝ Μπροστά = 0 ΤΟΤΕ
    ΓΡΑΨΕ "Η ουρά είναι άδεια"
  ΑΛΛΙΩΣ
    ΓΡΑΨΕ "Αρχή Ουράς ", Μπροστά
    ΑΝ Μπροστά = Πίσω ΤΟΤΕ
      ΓΡΑΨΕ Ουρα[Μπροστά] 
      ι <- Μπροστά mod 10 + 1
    ΑΛΛΙΩΣ
      ι <- Μπροστά
    ΤΕΛΟΣ_ΑΝ
    ΟΣΟ ι <> Πίσω ΕΠΑΝΑΛΑΒΕ
      ΓΡΑΨΕ Ουρα[ι] 
      ι <- ι mod 10 + 1
    ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ
    ΓΡΑΨΕ "Τέλος ουράς ", Πίσω
  ΤΕΛΟΣ_ΑΝ
ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ
}
Title$="Πρόχειρο Γλώσσας"
Dir User
oldlinespace=linespace
linespace 60
Declare NotePad Form
linespace=oldlinespace
//Method NotePad, "TransparentTitle"
Declare Pad EditBox Form NotePad
Declare Inform1 Button Form NotePad
With Inform1, "Caption" as Informe$
Method Inform1, "Colors", 15, #aaaaee  '#FFA000
With Inform1, "Locked", True
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Help1 Combobox Form NotePad
Method NotePad, "FontAttr", "Times", 28, True
With NotePad, "UseIcon", True, "UseReverse", True
Method Pad, "FontAttr", "COURIER NEW", 14, true
identifiers$="<-|ΠΡΟΓΡΑΜΜΑ|ΜΕΤΑΒΛΗΤΕΣ|ΠΡΑΓΜΑΤΙΚΕΣ|ΑΚΕΡΑΙΕΣ|ΛΟΓΙΚΕΣ|ΧΑΡΑΚΤΗΡΕΣ|ΣΤΑΘΕΡΕΣ|ΑΡΧΗ|ΓΡΑΨΕ|ΔΙΑΒΑΣΕ|ΤΕΛΟΣ_ΠΡΟΓΡΑΜΜΑΤΟΣ|DIV|MOD|ΑΝ|ΤΟΤΕ|ΑΛΛΙΩΣ|ΑΛΛΙΩΣ_ΑΝ|ΤΕΛΟΣ_ΑΝ|ΓΙΑ|ΑΠΟ|ΜΕΧΡΙ|ΜΕ_ΒΗΜΑ|ΤΕΛΟΣ_ΕΠΑΝΑΛΗΨΗΣ|ΕΠΙΛΕΞΕ|ΠΕΡΙΠΤΩΣΗ|ΤΕΛΟΣ_ΕΠΙΛΟΓΩΝ|ΟΣΟ|ΕΠΑΝΑΛΑΒΕ|ΑΡΧΗ_ΕΠΑΝΑΛΗΨΗΣ|ΜΕΧΡΙΣ_ΟΤΟΥ|ΚΑΙ|Η|ΟΧΙ|ΑΛΗΘΗΣ|ΨΕΥΔΗΣ|ΚΑΛΕΣΕ|ΔΙΑΔΙΚΑΣΙΑ|ΤΕΛΟΣ_ΔΙΑΔΙΚΑΣΙΑΣ|Α_Μ(|Α_Τ(|Ε|ΕΦ(|ΗΜ(|ΛΟΓ(|ΣΥΝ(|Τ_Ρ(|ΣΥΝΑΡΤΗΣΗ|ΤΕΛΟΣ_ΣΥΝΑΡΤΗΣΗΣ|"
With Pad, "NoWrap", True, "ColorCollection1", identifiers$, "LineComment1", "!", "OtherSymbols","@", "CommentSymbols", "[!][!]", "ComSymbolsWidth", 2, "WordCharRight", ": ,[]+()-*/)}≤≥≠"+chr$(9), "WordCharleft", " :,[]+*/)({≤≥≠"+chr$(9), "WordCharRightButIncluded", "("
With Pad, "LineComment2",CHR$(0), "StringSep2","'", "AssignSym","<-", "SearchWords",False, "UseColon","","SplitExpr",",", "CommentLineLight", True
With Pad, "Sellength" as Pad.SelLength, "EnablePairs", True, "BracketsForArrays", True
With File1,"label","Αρχείο", "listtext" As list$, "list" As list$() '
With Edit1,"label","Επεξεργασία",  "Mark", Color(255,100,0)
With Help1,"label","Βοήθεια",  "Mark", Color(255,100,0)
With NotePad, "Title" As Caption$, "Visible" As Visible, "TitleHeight" As tHeight, "Sizable", True
With Pad, "Text" As Pad.Text$, "NoColor", False, "ShowAlways", True, "SpaceIndent", 2, "NoCenterLineEdit", true, "HighlightParagraph", True
Def TitleStr$(a$)=ucase$(left$(a$,1))+mid$(a$,2)
LastWord$=""
Filename$=Dir$+"κυκλική_ουρά.glo"
Caption$=TitleStr$(File.Name$(Filename$)) +" - ΓΛΩΣΣΑ"
Method NotePad,"MakeStandardInfo", 0
Method NotePad,"move", 2000, 4000, 12000, 8000
Layer NotePad {Cls #FFA000}
With File1,"MenuStyle", True, "MenuWidth", 3000 
With Edit1,"MenuStyle", True, "MenuWidth", 4500
	\\ Advanced programming. Handling of the real control under Edit1 (the drop down list)
	With Edit1, "GlistN" set Control1
	With Control1, "UseTab", True, "TabWidthChar", 12
With Help1,"MenuStyle", True, "MenuWidth", 3000 , "List" as Help.List$()
With Edit1, "MenuEnabled" As Edit1.Enabled()
this_line=1
For This {
      mi$="MenuItem"  \\ is a temporary variable only for For This Block
      Method File1, mi$,"Φόρτωσε",True
      Method File1, mi$,"Σώσε",True
      Method File1, mi$,""    \\  only  a line here
      Method File1, mi$,"Κλείσε",True
      Method File1, mi$,"Έξοδος",True
      With File1, "MenuGroup","This"
      Method Edit1, mi$,"Αποκοπή",True
      Method Edit1, mi$,"Αντιγραφή",True
      Method Edit1, mi$,"Επικόληση",True
      Method Edit1, mi$,"",True
      Method Edit1, mi$,"Λιγότερη εσοχή"+chr$(9)+"Ctrl Q",True
      Method Edit1, mi$,"Περισσότερη εσοχή"+chr$(9)+"Ctrl W",True
      Method Edit1, mi$,"",True
      Method Edit1, mi$,"Άνοιγμα στη Γλώσσα", exist(filename$)
      
      With Edit1, "MenuGroup","This"
      With Help1, "Mark", -#7777FF,  "MenuGroup","This"
      Method Help1, mi$,"Περί",True
      Method Help1, mi$,"Βοήθεια",True
      Method Help1, mi$,"",True
      Method Help1, mi$,"Μέγεθος",False
      Method Help1, "MenuRadio","Mεγάλο",True, False
      Method Help1, "MenuRadio","Μικρό",True, True  
}
Function Help1.MenuChecked {
      Read New RadioIndex \\ 3 or 4
      If RadioIndex =4 Then {
            'After 30
            {
                  Method Pad, "FontAttr", "COURIER NEW", 18, true
                  Method Pad, "Show"
            }
      } Else.If RadioIndex =5 Then {
            'After 30
            {
                  Method Pad, "FontAttr", "COURIER NEW", 14, true
                  Method Pad, "Show"
            }
      }
}
If exist(Filename$) then
	Document BackUp$
	Load.Doc BackUp$, filename$
else
	Document BackUp$=first$
End If
Pad.text$=BackUp$
Function NotePad.Unload {
      Read New &Ok
      After 30 {Call local File1.DblClick(4) }
      Ok=True
}
\\ called when we press ctrl+f1 and not text selected
Function Pad.About {
      Pad.SelLength=0
      Method Pad,"Show"
      call local Help1.DblClick(if(lastword$=""->0,1))
}
\\ normaly send a string, but here we drop it
Function Pad.Help {
      call local Help1.DblClick(if(lastword$=""->0,1))
}
Function Notepad.Resize {
      Layer NotePad {
//      Cls #aaaaee ,0
gradient  #aaaaee, 1
      }
      With NotePad, "Width" As NP.Width, "Height" As NP.Height, "TitleHeight" As tHeight
      
      tHeight1=theight*2
      local theight2=theight*.8, theight0=theight*1.2
      Method File1,"move", twipsX*3, theight0,  twipsX*100, tHeight2
      Method Edit1,"move", twipsX*3+twipsX*120, theight0,  twipsX*160, tHeight2
      Method Help1,"move", twipsX*3+twipsX*300, theight0,  twipsX*120, tHeight2
      Method Inform1,"move", twipsX*3+twipsX*420, theight0,  twipsX*120, tHeight2
      If NP.height>2000 Then {
            Method Pad,"move", twipsX*3, tHeight1,  NP.Width-twipsX*6, NP.Height-tHeight1-twipsY*3
            With Pad, "NoWrap" As NoWrap
            If Not NoWrap Then Method Pad,"Resize"
      }
      Method NotePad, "refreshAll"
}
Function LessI(){
      Method Pad,"SetRowColumn", This_line, 0, true
      Method Pad,"PressKey", 9, 1
}
Function MoreI(){
      Method Pad,"SetRowColumn", This_line, 0, true
      Method Pad,"PressKey", 9, 0
}
\\  ctrl+Q for less indentation (adjust also the column)
\\ (also Ctrl+Shift+Tab  - for one row we have to select a block or to have the column before letters else we get spaces)
\\  ctrl_W for more indentation () (adjust also the column)

Function Pad.KeyDown {
      Read New &kc, &Shf
      If kc=81 and shf=2 Then
            kc=0 : shf=0
            After 20{
                  Call Local LessI()
            }
      Else.if Kc=87 and shf=2 then
            kc=0 : shf=0
            After 20{
                  Call Local MoreI()
            }      
      End If
}
Function Edit1.OpenMenu{
	Local X
	X=Pad.SelLength>0
	Edit1.Enabled(0)=X
	Edit1.Enabled(1)=X

       Edit1.Enabled(7)=exist(filename$)
}
Function Edit1.DblClick {
      Read Local Edit1index
      Select Case Edit1index
      Case 0
            {
            Method Pad,"mn1sub"
            Method Pad,"Resize"
            }
      Case 1
            Method Pad,"mn2sub"
      Case 2
            {
                  Method Pad, "mn3sub"
                  Method Pad,"GetFocus"
                  Method Pad,"Resize"
           }
      Case 4
            Call Local LessI()
      Case 5
            Call Local MoreI()
      Case 7
            {
                  If Pad.Text$<>BackUp$ then
                        call local File1.DblClick(1)
                  End If
                  If exist(filename$) then Win "Γλώσσα.exe", filename$
            }
      End Select
}
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}
Function Pad.Inform {
      Read New L, P
      this_line=L
      Informe$=format$("{0}-{1}", L,P)
      Method Pad,"Show"
}
informe$="Έτοιμο"
Function File1.DblClick {
      Read New File1index
      Local cont, cont2, f$, NL$={
      }
      File1index++
      {
      On File1index Goto Open1, Save1, ExitNow, Save2, Unload
      Exitnow:
      Exit
Open1:
      If Pad.Text$<>BackUp$ Then {
            If Ask("Να σωθούν οι αλλαγές;",Title$, "ΝΑΙ", "ΟΧΙ")=1 Then Goto Save1
      }
     Layer NotePad {
           Open.file filename$,"c:\","Φόρτωσε Αρχείο","glo"
     }
     Method Pad,"GetFocus"
     Read f$
     If f$<>"" Then {
           Filename$=f$
           If exist(F$) then {
           Clear BackUp$
           Load.Doc BackUp$, f$
           Caption$=TitleStr$(File.Name$(Filename$)) +" - ΓΛΩΣΣΑ"
           Pad.Text$=BackUp$
           } else Pad.text$="": Clear BackUp$
           Method Pad, "Resize"
      }
      Exit
Save1:
      Layer NotePad {
            Save.As Filename$,"c:\","Σώσε αρχείο","glo"
      }
      If not cont2 then Method Pad,"GetFocus"
      Read f$
      If f$="" Then Exit 
      If lcase$(file.type$(f$))<>"glo" then f$=f$+".glo"
      If Exist(f$) Then  If Ask(NL$+"Να αλλάξω το αρχείο"+NL$+f$,Title$, "ΝΑΙ", "ΟΧΙ")<>1 Then Exit
      Try ok {
        Clear BackUp$
        BackUp$=Pad.Text$
        Save.Doc BackUp$, f$
        filename$=f$
        Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      }
     If ok else beep
     If not cont then Exit
Save2:
      cont=True
      If Pad.Text$<>BackUp$ Then {
            If Ask("Να σωθούν οι αλλαγές;",Title$, "ΝΑΙ", "ΟΧΙ")=1 Then Goto Save1
      }
      Clear BackUp$
      Pad.Text$=""
      If Cont2 then {
           Method NotePad, "CloseNow"
      } Else {
            FileName$=Dir$+"νεο.glo"
            Caption$=TitleStr$(File.Name$(Filename$)) +" - ΓΛΩΣΣΑ"
            Method Pad, "Resize"
      }
      Exit
Unload:
      Cont2=True : Goto Save2
      }
}
Function Help1.DblClick(new index) {
If index=0 then
      Local A, info$
      Info$={
            Πρόχειρο για συγγραφή προγραμμάτων σε ΓΛΩΣΣΑ για το μάθημα της ΑΕΠΠ.
            Η εξαγωγή στο πρόχειρο γίνεται σε Html και απλό κείμενο, ταυτόχρονα.
            }
      A=Ask(info$,Title$,"ΝΑΙ","")  ' one button only
else.if index=1 then
      if  lastword$<>"" then
            If not exist(lastword$+".txt") then local a$ : Document a$ : Save.Doc a$, lastword$+".txt"
            win "notepad", dir$+lastword$+".txt"
      else
            after 30 {local A=Ask("Επίλεξε μια λέξη και γύρνα στο μενού βοήθεια ξανά!", Title$, "Κατάλαβα","")
            }            
      end if
else.if index>2 then
      Call Local Help1.MenuChecked(index)
End If

}
Function Pad.Word(new alfa$) {
      If instr(identifiers$, "|"+alfa$+"|")>0 then
            Lastword$=alfa$	
            Help.list$(1)="Βοήθεια για "+alfa$
            With Help1,"MenuWidth", Max.data(Size.X(Help.list$(1), "Verdana",12 )+1000, 3000)
      End If
}
Function Notepad.InfoClick {
	Read New X
	If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Call Local Notepad.Resize()
With NotePad, "TitleBarColor",#88aacc, "TitleTextColor",11, "TitleIconColor",#eeeeee
Method NotePad, "transparentTitle"
Method Pad, "SetBarStyle", #88aacc, -1
Method File1, "transparent"
Method Edit1, "transparent"
Method Help1, "transparent"
Method Inform1, "transparent"

After 100 {Title "", 0}
Method NotePad,"Show" , 1

Declare Control1 Nothing 
Declare Pad Nothing
Declare NotePad Nothing 
Latin
If Module(Info) Then
	Title "Info"
	keyboard "INFOBasic"+chr$(13)
end if
}
MODULE HTMLEDITOR {\\ task for the pupil:
\\ read the meditor and found how to change the load routine, to load a big file without blocking the gui.


\\ Version 0.2
\\ default set true to Pad
\\ need some work inside interpreter code
Clear \\ Clear all variables/objects
def setagain as boolean, hidetitle as boolean=True
if file.name$("A.abc")="a.abc" then
Set switches "+CASESENSITIVE"
setagain=true
\\ we want to see and use  the actual case of a filename
End if
Global Const  CSIDL_MY_DOCUMENTS  = 0x5
if match("S") then
hidetile=false
Filename$=Dir$+letter$
document first$
load.doc first$, filename$
else
Filename$=Dir$+"floatforms.html"
first$={<!DOCTYPE html>
<html lang = "en-US">
      <head>
            <meta charset = "UTF-8">
            <title>floatForm.html</title>
            <link rel = "stylesheet"
                  type = "text/css"
                  href = "floatForm.css" />
      </head>
      <body>
            <form action = "">
                  <fieldset>
                        <label>Name</label>
                        <input type = "text"
                              id = "txtName" />
                        <label>Address</label>
                        <input type = "text"
                              id = "txtAddress" />
                        <label>Phone</label>
                        <input type = "text"
                              id = "txtPhone" />
                        <button type = "button">
                              submit request
                        </button>
                  </fieldset>
            </form>
      </body>
</html>
}
end if
Flush \\ Empty the stack
makelist()
title$="Html Editor"
typ$="html"
W$=""
path$="" 
Read hBase, identifiers$
Dir User
lookpath$=dir$
Declare NotePad Form
Declare Pad EditBox Form NotePad
Declare Inform1 Button Form NotePad
With Inform1, "Caption" as Informe$
Method Inform1, "Colors", 15, #FFA000
With Inform1, "Locked", True
Declare File1 Combobox Form NotePad
Declare Edit1 Combobox Form NotePad
Declare Tools Combobox Form NotePad
Declare Help1 Combobox Form NotePad
With File1,"label","File", "listtext" As list$, "list" As list$() '
With Edit1,"label","Edit",  "Mark", Color(255,100,0)
With Tools,"label","Tools",  "Mark", Color(255,100,0), "list" As tList$()
With Help1,"label","Help",  "Mark", Color(255,100,0)
Method Pad, "FontAttr", "VERDANA", 13.5, true
With NotePad, "Title" As Caption$, "Visible" As Visible, "TitleHeight" As tHeight, "Sizable", True
With NotePad, "UseIcon", True, "UseReverse", True
With Pad, "Text" As Pad.text$, "ShowAlways", True,"NoColor", True,"SelLength" as SelLength
With Pad, "SearchWords", False, "nowrap", False, "linespace", 30
With Pad, "ReplaceTitle" as InnerInfo$,"Default", True
Def TitleStr$(a$)=a$ '   Ucase$(Left$(a$,1))+Mid$(a$,2)


Caption$=TitleStr$(File.Name$(Filename$)) +" - HTML Editor"
Title Caption$
Method NotePad,"MakeStandardInfo", 1
Method NotePad,"move", 2000, 4000, 8000, 4000
Layer NotePad {Cls #FFA000}
With File1,"MenuStyle", True, "MenuWidth", 3000 
With Edit1,"MenuStyle", True, "MenuWidth", 3000,"menuEnabled" as Enabled() 
With Tools,"MenuStyle", True, "MenuWidth", 5400
With Help1,"MenuStyle", True, "MenuWidth", 3000 
With File1, "MenuEnabled" As mEnable()
For This {
      mi$="MenuItem"  \\ is a temporary variable only for For This Block
      With File1, "MenuGroup","This"
      Method File1, mi$,"Open",True
      Method File1, mi$,"Save",True
      Method File1, mi$,""    \\  only  a line here
      Method File1,"MenuRadio","css files",True,False
      Method File1,"MenuRadio","html files",True,True
      
      Method File1, mi$,""
      Method File1, mi$,"Close",True
      Method File1, mi$,""
      Method File1, mi$,"Quit",True
           
      
      With Edit1, "MenuGroup","This"
      Method Edit1, mi$,"Cut",False
      Method Edit1, mi$,"Copy",False
      Method Edit1, mi$,"Paste",True
      Method Edit1, mi$,""
      Method Edit1, mi$,"Less Indent",True
      Method Edit1, mi$,"More Indent",True  
      
      With Tools, "MenuGroup","This"
      Method Tools, mi$,"Open in "+piece$(file.title$("html")," ")(0),true
      Method Tools, mi$,""
      Method Tools, mi$,"Set Directory from User", true
      Method Tools, mi$,"Set Directory from My Documents",true
      
      With Help1, "MenuGroup","This"
      Method Help1, mi$, "About", True
}

if exist(Filename$) then
      Document BackUp$
      Load.Doc BackUp$, filename$
else
      Document BackUp$=first$
end if
Pad.text$=BackUp$
Function NotePad.Unload {
      Read New &Ok
      After 30 {Call local File1.DblClick(8) }
      Ok=True

}
Function Notepad.Resize {
      Layer NotePad { Cls Color(255, 160, 0) ,0}
      With NotePad, "Width" As NP.Width, "Height" As NP.Height, "TitleHeight" As tHeight
      tHeight1=theight*2
      Method File1,"move", twipsX*3, tHeight,  twipsX*80, tHeight
      Method Edit1,"move", twipsX*3+twipsX*80, tHeight,  twipsX*80, tHeight
      Method Tools,"move", twipsX*3+twipsX*160, tHeight,  twipsX*80, tHeight
      Method Help1,"move", twipsX*3+twipsX*240, tHeight,  twipsX*160, tHeight
      Method Inform1,"move", twipsX*3+twipsX*320, tHeight,  twipsX*240, tHeight
      If NP.height>1000 Then {
            Method Pad,"move", twipsX*3, tHeight1,  NP.Width-twipsX*6, NP.Height-tHeight1-twipsY*3
            With Pad, "NoWrap" As NoWrap
            If Not NoWrap Then Method Pad,"Resize"
      }
}
Function Edit1.OpenMenu {
            Local X
            X=SelLength>0
            Enabled(0)=X
            Enabled(1)=X
}

Function Edit1.DblClick {
      Read Local Edit1index
      Select Case Edit1index
      Case 0
            {
            Method Pad,"mn1sub"
            Method Pad,"Resize"
            }
      Case 1
            Method Pad,"mn2sub"
      Case 2
            {
                 Method Pad, "mn3sub"
                 Method Pad,"GetFocus"
                 Method Pad,"Resize"
           }
        Case 4
           {
                  Method Pad,"PressKey", 9, 1
            }
        Case 5
           {
                  Method Pad,"PressKey", 9, 0
            }
      End Select

}
Function Pad.Inform {
      Read New L, P
      Informe$=format$("{0}-{1}", L,P)
      Method Pad,"Show"
}
Function Pad.PopUp {
      Read Local X, Y
      Method Pad,"PopUpMenu", "",X , Y
}
function cs_choose{
      With Pad, "ColorCollection1",identifiers$,"SetHTML", true
      Method Pad, "ReColor"
      Method Pad, "Show"
}

Function File1.MenuChecked {
Read New RadioIndex \\ 3 or 4
If RadioIndex =3 Then {
      After 30 { Static a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".css"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="css"
      With Pad, "ColorCollection1", "","NoColor", True,  "UseCase", False
      Pad.text$=Pad.text$
      Method Pad, "Show"
      }
} Else.If RadioIndex =4 Then {
     After 30 { local a$="."+File.type$(Filename$), b$=File.name$(Filename$)
      Filename$=File.path$(Filename$)+Left$(b$,Len(b$)-Len(a$))+".html"
      Caption$=TitleStr$(File.Name$(Filename$)) +" - M2000 Pad"
      typ$="html"
      Call local cs_choose()
      }      
}

}
Function File1.DblClick {
\\ we use functions As subs here
\\ each function and each module have a name (define a namespace)
\\ but here real module name is the File1.DblClick() host module
\\ this is done because is a Gui Event Service Function
\\ and is Call With Local tag (Call Local)
      Read New File1index
      method Pad, "CloseTitle"
      
      Local cont, cont2, f$, NL$={
      }
      File1index++
      \\ Because we want some jumps..we use  On Goto
      \\ on Goto need here a block
      {
      On File1index Goto Open1, Save1, ExitNow, ExitNow, ExitNow, ExitNow, Save2, ExitNow,  Unload
Exitnow:
      Exit
Open1:
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes first?",title$, "Yes","No")=1 Then Goto Save1
      }
     Layer NotePad {
           Open.file filename$,,"Load Text ("+typ$+") File",typ$
     }
     
     Method Pad,"GetFocus"
     Read f$
     If f$<>"" Then {
           Filename$=f$
           If Exist(F$) Then {
           Clear BackUp$
           Load.Doc BackUp$, f$
           
           Caption$=TitleStr$(File.Name$(Filename$)) +" - Html Editor"
           lookpath$=file.path$(Filename$)
           \\ silent means here without refresh
           With Pad, "SelStartSilent", 0, "SellengthSilent",0 
           Pad.text$=BackUp$
           } Else Pad.text$="": Clear BackUp$
           Method Pad, "ReColor"
      }
      Exit
Save1:
      Layer NotePad {
            Save.As Filename$,,"Save Text ("+typ$+") File",typ$
      }
      If Not cont2 Then Method Pad,"GetFocus"
      Read f$   ' from save.as we get a value
      If f$="" Then Exit 
      If Lcase$(File.type$(f$))<>typ$ Then f$=f$+"."+typ$
      If Exist(f$) Then  If Ask(NL$+"Overwrite"+NL$+f$,title$, "Yes","No")<>1 Then Exit
      Try ok {
        Clear BackUp$
        BackUp$=Pad.text$
        Save.Doc BackUp$, f$  ' by default 2 - Utf-8
        filename$=f$
        lookpath$=file.path$(Filename$)
        Caption$=TitleStr$(File.Name$(Filename$)) +" - Html Editor"
      }
     If ok Else Beep
     If Not cont Then Exit
Save2:
      cont=True
      If Pad.text$<>BackUp$ Then {
            If Ask("Save Changes?",title$, "Yes","No")=1 Then Goto Save1
      }
      Clear BackUp$
      Pad.text$=""
      If Cont2 Then {
            Method NotePad, "CloseNow"
      } Else {
            FileName$=Dir$+"Untitled."+typ$
            Caption$=TitleStr$(File.Name$(Filename$)) +" - Html Editor"
            Method Pad, "Resize"
      }
      Exit
Unload:
      Cont2=True : Goto Save2
      }
}

Function Tools.OpenMenu {
      tlist$(0)="Open in "+piece$(file.title$("html")," ")(0)
}
Function Tools.DblClick {
      Read New Toolsindex
      select case Toolsindex
      case 0
      {
            lookpath$=file.path$(Filename$)
            local test$, ok
            document test$
            test$=pad.text$
            try ok {
                  save.doc test$, dir$+"_test_.html"
                  win dir$+"_test_.html"
            }
            if not ok then beep
      }
      case 2
      {
            dir user
            dir ? dir$, "Choose Folder"
            filename$=dir$+file.name$(filename$)
       }
      case 3
      {
             dir path$(CSIDL_MY_DOCUMENTS)
             dir ? dir$, "Choose Folder"
             filename$=dir$+file.name$(filename$)
      }
      end select

}
Function Help1.DblClick {
      Read New Help1index
      Local A, info$
      Info$={
            This is an example
            of an editor for html files
            written for M2000 Environment
            use F1 to change wrap
            }
      A=Ask(info$,title$,"","")
      Method Pad, "GetFocus"

}
Function Notepad.InfoClick {
	Read New X
	If X=0 Then Call Local Help1.DblClick(0)  ' 0 for first menu item
}
Function Pad.Word(new alfa$) {
      if exist(hBase, alfa$) then
            InnerInfo$=alfa$+" "+eval$(hbase)
      end if
}

Call Local Notepad.Resize()
\\ open As modal
if hidetitle then Title "", 0
after 200 {
	Call local cs_choose()
}
\\After 100 {Title "", 0}
Method NotePad,"Show" , 1
Declare Pad Nothing
Declare NotePad Nothing 
if setagain Then Set switches "-CASESENSITIVE"
Print "Done"
If module(Info) then Title "Info"
Dir User
Exit
Sub makelist()
Document Help$ ={
	<a>	Defines a hyperlink.
	<article> 	Defines an article.
	<aside> 	Defines some content loosely related to the page content.
	<body>	Defines the document's body.
	<br>	Produces a single line break.
	<!DOCTYPE> The type of document
	<details> 	Represents a widget from which the user can obtain additional information or controls on-demand.
	<div>	Specifies a division or a section in a document.
	<h1>		Defines HTML headings level 1.
	<h2>		Defines HTML headings level 2.
	<h3>		Defines HTML headings level 3.
	<h4>		Defines HTML headings level 4.
	<h5>		Defines HTML headings level 5.
	<h6>		Defines HTML headings level 6.
	<head>	Defines the head portion of the document that contains information about the document.
	<header> 	Represents the header of a document or a section.
	<hgroup> 	Defines a group of headings.
	<hr>	Produce a horizontal line.
	<html>	Defines the root of an HTML document.
	<footer> 	Represents the footer of a document or a section.
	<nav> 	Defines a section of navigation links.
	<p>	Defines a paragraph.
	<section> 	Defines a section of a document, such as header, footer etc.
	<span>	Defines an inline styleless section in a document.
	<summary> 	Defines a summary for the <details> element.
	<base>	Defines the base URL for all linked objects on a page.
	<basefont>	Obsolete Specifies the base font for a page.
	<link>	Defines the relationship between the current document and an external resource.
	<meta>	Provides structured metadata about the document content.
	<style>	Inserts style information (commonly CSS) into the head of a document.
	<title>	Defines a title for the document.
	<button>	Creates a clickable button.
	<datalist> 	Represents a set of pre-defined options for an <input> element.
	<fieldset>	Specifies a set of related form fields.
	<form>	Defines an HTML form for user input.
	<input>	Defines an input control.
	<keygen> 	Represents a control for generating a public-private key pair.
	<label>	Defines a label for an <input> control.
	<legend>	Defines a caption for a <fieldset> element.
	<meter> 	Represents a scalar measurement within a known range.
	<optgroup>	Defines a group of related options in a selection list.
	<option>	Defines an option in a selection list.
	<select>	Defines a selection list within a form.
	<textarea>	Defines a multi-line text input control (text area).
	<abbr>	Defines an abbreviated form of a longer word or phrase.
	<acronym>	Defines an acronym.
	<address>	Specifies the author's contact information.
	<b>	Displays text in a bold style.
	<bdi> 	Represents text that is isolated from its surrounding for the purposes of bidirectional text formatting.
	<bdo>	Overrides the current text direction.
	<big>	displays text in a large size.
	<blockquote>	Defines a long quotation.
	<center>	Obsolete Align contents in the center of the enclosing block.
	<cite>	Indicates a citation or reference to another source.
	<code>	Specifies text as computer code.
	<del>	Specifies a block of deleted text.
	<dfn>	Specifies a definition.
	<em>	Specifies emphasized text.
	<font>	Obsolete Defines font, color, and size for text.
	<i>	Displays text in an italic style.
	<ins>	Defines a block of text that has been inserted into a document.
	<kbd>	Specifies text as keyboard input.
	<mark> 	Represents text highlighted for reference purposes.
	<output> 	Represents the result of a calculation.
	<pre>	Defines a block of preformatted text.
	<progress> 	Represents the completion progress of a task.
	<q>	Defines a short inline quotation.
	<rp> 	Provides fall-back parenthesis for browsers that that don't support ruby annotations.
	<rt> 	Defines the pronunciation of character presented in a ruby annotations.
	<ruby> 	Represents a ruby annotation.
	<s>	Obsolete Displays text in strikethrough style.
	<samp>	Specifies text as sample output from a computer program.
	<small>	Displays text in a smaller size.
	<strike>	Obsolete Displays text in strikethrough style.
	<strong>	Indicate strongly emphasized text.
	<sub>	Defines subscripted text.
	<sup>	Defines superscripted text.
	<tt>	Displays text in a teletype style.
	<u>	Obsolete Displays text with an underline.
	<var>	Defines a variable.
	<wbr> 	Represents a line break opportunity.
	<dd>	Specifies a definition for a term in a definition list.
	<dir>	Obsolete Defines a directory list.
	<dl>	Defines a definition list.
	<dt>	Defines a term (an item) in a definition list.
	<li>	Defines a list item.
	<ol>	Defines an ordered list.
	<menu>	Represents a list of commands.
	<ul>	Defines an unordered list.
	<caption>	Defines the title of a table.
	<col>	Defines attribute values for one or more columns in a table.
	<colgroup>	Specifies attributes for multiple columns in a table.
	<table>	Defines a data table.
	<tbody>	Groups a set of rows defining the main body of the table data.
	<td>	Defines a cell in a table.
	<tfoot>	Groups a set of rows summarizing the columns of the table.
	<thead>	Groups a set of rows that describes the column labels of a table.
	<th>	Defines a header cell in a table.
	<tr>	Defines a row of cells in a table.
	<noscript>	Defines alternative content to display when the browser doesn't support scripting.
	<script>	Places script in the document for client-side processing.
	<applet>	Obsolete Embeds a Java applet (mini Java applications) on the page. Use the <object> element instead.
	<area>	Defines a specific area within an image map.
	<audio> 	Embeds a sound, or an audio stream in an HTML document.
	<canvas> 	Defines a region in the document, which can be used to draw graphics on the fly via scripting (usually JavaScript).
	<embed> 	Embeds external application, typically multimedia content like audio or video into an HTML document.
	<figcaption> 	Defines a caption or legend for a figure.
	<figure> 	Represents a figure illustrated as part of the document.
	<frame>	Defines a single frame within a frameset.
	<frameset>	Defines a collection of frames or other frameset.
	<iframe>	Displays a URL in an inline frame.
	<img>	Displays an inline image.
	<map>	Defines a client-side image-map.
	<noframes>	Defines an alternate content that displays in browsers that do not support frames.
	<object>	Defines an embedded object.
	<param>	Defines a parameter for an object or applet element.
	<source> 	Defines alternative media resources for the media elements like <audio> or <video>.
	<time> 	Represents a time and/or date.
	<video> 	Embeds video content in an HTML document.
}
Inventory hBase
Document final$
m=Paragraph(Help$, 0) 
If Forward(Help$,m) then {
      While m {
            a$=Paragraph$(Help$,(m))
            if a$<>"" then
                  \\ help pair to hBase
                  b$=rightpart$(a$, "<")
                  c$=trim$(filter$(rightpart$(b$,">"), chr$(9)))
                  b$=leftpart$(b$,">")
                  Append hBase,b$:=c$
                  \\ indentifiers for color syntax
                  b$=rightpart$(a$, "<")
                  b$=leftpart$(b$,">")
                  final$="|"+b$
            end if
      }
}
final$="|"
Push	final$
Push hBase
end sub
}
MODULE VALIDATOR {makelist()
read tags
a$ ={
<!DOCTYPE html>
<html lang = "en-US">
      <head>
            <meta charset = "UTF-8">
            <title>floatForm.html</title>
            <link rel = "stylesheet"
                  type = "text/css"
                  href = "floatForm.css" />
      </head>
      <!-- CSS injected by skin and extensions -->
      <body>
            <form action = "">
                  <fieldset>
                        <label>Name</label>
                        <input type = "text"
                              id = "txtName" />
                        <label>Address</label>
                        <input type = "text"
                              id = "txtAddress" />
                        <label>Phone</label>
                        <input type = "text"
                              id = "txtPhone" />
                        <button type = "button">
                              submit request
                        </button>
                  </fieldset>
            </form>
      </body>
</html>
}
document valdoc$ =filter$(a$,chr$(9))
Function count34 (a$){
	i=1 : n=0:t=len(a$)
	{
		b= chrcode(mid$(a$,i))
		if b=34 then n++
		if b>0x10000 then i+=2 else i++
		if i<=t then loop
	}
	=n
}
Function drop34 (&a$){
	i=1 : n=0:t=len(a$)
	{
		b= chrcode(mid$(a$,i))
		if b=34 then n++
		if b>0x10000 then i+=2 else i++
		if n=2 then exit
		if i<=t then loop
	}
	if n=2 then a$=mid$(a$, i) : = true
}
er$="general"
valcurline=0
valposline=0
valm=Paragraph(valdoc$, 0) 
def FindTag as boolean=True
LastTag$=""
FindEndComment=false
def i,j,k
Stack New {
      If Forward(valdoc$,valm) then {
            a$=Paragraph$(valdoc$,(valm))
            valcurline++
            a$=replace$(chr$(9)," ", a$)
            k=len(a$)+1
            valposline=1
            Print valcurline , " "+a$
            rem Stack
            a$=trim$(a$)
            valposline=K-len(a$)
            while valposline<k  {
                  if FindTag then {
                        
                        if left$(a$,1)=">" then{
                              if LastTag$="" then er$=" not tag for >" : goto exitall1
                              a$=trim$(mid$(a$,2))
                              findtag=false
                        } 
                        if LastTag$="*" then {
                        if left$(a$,2)="/>" then a$=mid$(a$,2)
                        
                              if not empty then read LastTag$ else LastTag$="" 
                              FindTag=false
                        }
                        if left$(a$,1)="<" then{
                               a$=mid$(a$,2)
                               findtag=true
                        }
                        if not findtag then exit
                        if left$(a$,3)="!--" then {
                              a$=mid$(a$,4)
                              FindEndComment=True
                              FindTag=false
                        } else.if left$(a$,1)="!" then {
                              a$=rightpart$(a$, ">")
                        } else.if left$(a$,2)="/>" then {
                              if LastTag$="" then er$="missing tag" : goto exitall
                              a$=mid$(a$,3)
                              if LastTag$<>"link" and LastTag$<>"input" then {
                                    
                                    if  empty then  er$="missing tag" : goto exitall1
                                    read LastTag1$
                                    If LastTag1$<>LastTag$ then er$=LastTag$+" no match "+LastTag1$: goto exitall
                              }
                              if not empty then Read LastTag$
                        } else.if left$(a$,1)="/" then {
                              a$=mid$(a$,2)
                              if LastTag$<>"" then {
                                    LastTag1$=leftpart$(a$," ")
                                    if LastTag1$="" then {
                                          LastTag1$=leftpart$(a$,">") 
                                          if LastTag1$="" then if len(a$)>0 then LastTag1$=a$ : a$=""
                                         
                                          if LastTag1$<>LastTag$ then er$=LastTag$ + " no match /"+LastTag1$ : goto exitall
                                          a$=trim$(rightpart$(a$,">") )
                                    } else {
                                          if LastTag1$<>LastTag$ then er$=LastTag$ + " no match /"+LastTag1$ : goto exitall
                                          a$=trim$(a$)
                                          if left$(a$,1)<>">" then er$="missing > from end tag "+LastTag$: goto exitall
                                    }
                                    if not empty then read LastTag$
                              } else {
                                    LastTag1$=leftpart$(a$," ")
                                    if LastTag1$="" then {
                                          LastTag1$=leftpart$(a$,">") 
                                          if LastTag1$="" then if len(a$)>0 then LastTag1$=a$ : a$=""
                                    } 
                                    if LastTag1$<>"" then er$="/" + LastTag1$ + " no pair" : goto exitall
                                    er$="</  without tag"
                                    goto exitall
                              }
                        } else {
                              a$=trim$(a$)
                              LastTag1$=leftpart$(a$," ")
                              if instr(LastTag1$,">")>0 then
                              LastTag1$=leftpart$(LastTag1$," ")
                              end if
                              if LastTag1$="" then {
                                    LastTag1$=leftpart$(a$,">") 
                                    if LastTag1$="" then{
                                           if len(a$)>0 then LastTag1$=a$ : a$=""
                                    } else a$=trim$(mid$(a$,len(lasttag1$)+1)) :   FindTag=true
                              } else a$=trim$(rightpart$(a$," ")) :   FindTag=false
                              if LastTag1$="" then er$="not tag found" : goto exitall
                              if LastTag1$="meta" then {
                                    if LastTag$<>"" then push LastTag$
                                 LastTag$="*"   
                                     a$=trim$(a$)
                              } else {
                                    if LastTag$<>"" then push LastTag$
                                    LastTag$=LastTag1$
                                    a$=trim$(a$)
                                    if not FindTag then FindTag=left$(a$,2)="/>" : if FindTag then a$=mid$(a$,22) : FindTag=False
                              }
                        }
                  } else.if FindEndComment then {
                        i=instr(a$,"-->")
                        if i>0 then {
                             a$=mid$(a$, i+3)
                             FindEndComment=false
                             FindTag=True
                        }
                  } else.if left$(a$,1)="<" then {
                        FindTag=true
                  } else {
                        i=count34(a$)
                        if i mod 2=1 then er$="problem with strings" : goto exitall
                        if i>0 then while drop34(&a$) {}
                        a$=trim$(a$)
                        
                        i=instr(a$,"<"): if i=0 then i=len(a$)+1
                        j=instr(a$,"/"): if j=0 then j=len(a$)+1
                        g=instr(a$,">"): if g=0 then g=len(a$)+1
                        a$=TRIM$(mid$(a$,min.data(i, j, g))): FindTag= a$<>""
                  }
                  valposline=K-len(a$)
            }
            if valm<>0 then loop
      }
      if not empty then er$=str$(stack.size,"")+" tag left" :goto exitall
}
Print "ok"
exit
exitall:
valposline=K-len(a$)
Print "Error ";er$;" at line ";valcurline; " at cursor pos ";valposline
Exit
Sub makelist()
' test "here"
Document Help$ ={
	<a>	Defines a hyperlink.
	<article> 	Defines an article.
	<aside> 	Defines some content loosely related to the page content.
	<body>	Defines the document's body.
	<br>	Produces a single line break.
	<details> 	Represents a widget from which the user can obtain additional information or controls on-demand.
	<div>	Specifies a division or a section in a document.
	<h1>		Defines HTML headings level 1.
	<h2>		Defines HTML headings level 2.
	<h3>		Defines HTML headings level 3.
	<h4>		Defines HTML headings level 4.
	<h5>		Defines HTML headings level 5.
	<h6>		Defines HTML headings level 6.
	<head>	Defines the head portion of the document that contains information about the document.
	<header> 	Represents the header of a document or a section.
	<hgroup> 	Defines a group of headings.
	<hr>	Produce a horizontal line.
	<html>	Defines the root of an HTML document.
	<footer> 	Represents the footer of a document or a section.
	<nav> 	Defines a section of navigation links.
	<p>	Defines a paragraph.
	<section> 	Defines a section of a document, such as header, footer etc.
	<span>	Defines an inline styleless section in a document.
	<summary> 	Defines a summary for the <details> element.
	<base>	Defines the base URL for all linked objects on a page.
	<basefont>	Obsolete Specifies the base font for a page.
	<link>	Defines the relationship between the current document and an external resource.
	<meta>	Provides structured metadata about the document content.
	<style>	Inserts style information (commonly CSS) into the head of a document.
	<title>	Defines a title for the document.
	<button>	Creates a clickable button.
	<datalist> 	Represents a set of pre-defined options for an <input> element.
	<fieldset>	Specifies a set of related form fields.
	<form>	Defines an HTML form for user input.
	<input>	Defines an input control.
	<keygen> 	Represents a control for generating a public-private key pair.
	<label>	Defines a label for an <input> control.
	<legend>	Defines a caption for a <fieldset> element.
	<meter> 	Represents a scalar measurement within a known range.
	<optgroup>	Defines a group of related options in a selection list.
	<option>	Defines an option in a selection list.
	<select>	Defines a selection list within a form.
	<textarea>	Defines a multi-line text input control (text area).
	<abbr>	Defines an abbreviated form of a longer word or phrase.
	<acronym>	Defines an acronym.
	<address>	Specifies the author's contact information.
	<b>	Displays text in a bold style.
	<bdi> 	Represents text that is isolated from its surrounding for the purposes of bidirectional text formatting.
	<bdo>	Overrides the current text direction.
	<big>	displays text in a large size.
	<blockquote>	Defines a long quotation.
	<center>	Obsolete Align contents in the center of the enclosing block.
	<cite>	Indicates a citation or reference to another source.
	<code>	Specifies text as computer code.
	<del>	Specifies a block of deleted text.
	<dfn>	Specifies a definition.
	<em>	Specifies emphasized text.
	<font>	Obsolete Defines font, color, and size for text.
	<i>	Displays text in an italic style.
	<ins>	Defines a block of text that has been inserted into a document.
	<kbd>	Specifies text as keyboard input.
	<mark> 	Represents text highlighted for reference purposes.
	<output> 	Represents the result of a calculation.
	<pre>	Defines a block of preformatted text.
	<progress> 	Represents the completion progress of a task.
	<q>	Defines a short inline quotation.
	<rp> 	Provides fall-back parenthesis for browsers that that don't support ruby annotations.
	<rt> 	Defines the pronunciation of character presented in a ruby annotations.
	<ruby> 	Represents a ruby annotation.
	<s>	Obsolete Displays text in strikethrough style.
	<samp>	Specifies text as sample output from a computer program.
	<small>	Displays text in a smaller size.
	<strike>	Obsolete Displays text in strikethrough style.
	<strong>	Indicate strongly emphasized text.
	<sub>	Defines subscripted text.
	<sup>	Defines superscripted text.
	<tt>	Displays text in a teletype style.
	<u>	Obsolete Displays text with an underline.
	<var>	Defines a variable.
	<wbr> 	Represents a line break opportunity.
	<dd>	Specifies a definition for a term in a definition list.
	<dir>	Obsolete Defines a directory list.
	<dl>	Defines a definition list.
	<dt>	Defines a term (an item) in a definition list.
	<li>	Defines a list item.
	<ol>	Defines an ordered list.
	<menu>	Represents a list of commands.
	<ul>	Defines an unordered list.
	<caption>	Defines the title of a table.
	<col>	Defines attribute values for one or more columns in a table.
	<colgroup>	Specifies attributes for multiple columns in a table.
	<table>	Defines a data table.
	<tbody>	Groups a set of rows defining the main body of the table data.
	<td>	Defines a cell in a table.
	<tfoot>	Groups a set of rows summarizing the columns of the table.
	<thead>	Groups a set of rows that describes the column labels of a table.
	<th>	Defines a header cell in a table.
	<tr>	Defines a row of cells in a table.
	<noscript>	Defines alternative content to display when the browser doesn't support scripting.
	<script>	Places script in the document for client-side processing.
	<applet>	Obsolete Embeds a Java applet (mini Java applications) on the page. Use the <object> element instead.
	<area>	Defines a specific area within an image map.
	<audio> 	Embeds a sound, or an audio stream in an HTML document.
	<canvas> 	Defines a region in the document, which can be used to draw graphics on the fly via scripting (usually JavaScript).
	<embed> 	Embeds external application, typically multimedia content like audio or video into an HTML document.
	<figcaption> 	Defines a caption or legend for a figure.
	<figure> 	Represents a figure illustrated as part of the document.
	<frame>	Defines a single frame within a frameset.
	<frameset>	Defines a collection of frames or other frameset.
	<iframe>	Displays a URL in an inline frame.
	<img>	Displays an inline image.
	<map>	Defines a client-side image-map.
	<noframes>	Defines an alternate content that displays in browsers that do not support frames.
	<object>	Defines an embedded object.
	<param>	Defines a parameter for an object or applet element.
	<source> 	Defines alternative media resources for the media elements like <audio> or <video>.
	<time> 	Represents a time and/or date.
	<video> 	Embeds video content in an HTML document.
}
Inventory hBase
Document final$
m=Paragraph(Help$, 0) 
If Forward(Help$,m) then {
      While m {
            a$=Paragraph$(Help$,(m))
            if a$<>"" then
                  \\ help pair to hBase
                  b$=rightpart$(a$, "<")
                  c$=trim$(filter$(rightpart$(b$,">"), chr$(9)))
                  b$=leftpart$(b$,">")
                  Append hBase,b$:=c$
                  \\ indentifiers for color syntax
                  b$=rightpart$(a$, "<")
                  b$=leftpart$(b$,">")
                  final$="|"+b$
            end if
      }
}
final$="|"
'Push	final$
Push hBase
end sub
}
MODULE EXPORTHELP {\\ prepare the groups of help database

Print "Greek or English Help File:(G/E)"
Select Case Ucase$(Key$)
case "G", "Γ"
      Gr=True : Print "Greek... Περίμενε"
case "E", "Ε"
      Gr=False : Print "English...Wait"
Else Case
      Break
End Select
Flush
if isnum or  not exist(appdir$+"HELP2000.mdb") then Error "No mdb (Access) help file found"
gosub dat
Read  myGroups
Dim No(1 to myGroups), name$(1 to myGroups)
for i=1 to myGroups
      Read No(i), name$(i)
      name$(i)=Replace$(chr$(160)," ", name$(i))
Next
 
Document GreekInfo$, EnglishInfo$, out$ 
\\ we have to read from application directory
Dir AppDir$

For i=1 To myGroups {

      EnglishInfo$=RightPart$(name$(i),", ")
      GreekInfo$= LeftPart$(name$(i),", ")
      if  GR Else Swap EnglishInfo$, GreekInfo$
      GreekInfo$={ - }+EnglishInfo$+{
      }
      Print GreekInfo$
      out$ =  If$(GR->"Ομάδα: ", "Group: ")
      out$ =  GreekInfo$ 'EnglishInfo$
      out$ = {
      }
      Retrieve "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i)),1,"",""
      Read mywords
                
      For j=1 To mywords  {
       If i=1 then
            Retrieve  "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i)) +" ORDER BY [ENGLISH]",j,"","" 
      Else
            Retrieve "HELP2000", "SELECT *FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i))+If$(GR -> ""," ORDER BY [ENGLISH]"),j,"",""
      End if
      Drop ' no need this number - is equal to mywords
      Read GreekName$, HelpText$, EnglishName$, groupnumFrom
      if  GR Else Swap  GreekName$, EnglishName$
      if i>1 then
            out$ = If$(GR->"Αναγνωριστικό: ", "identifier:  ")
            out$ =  GreekName$ + "      ["+ EnglishName$+"]"
      else
            out$ =  "  *  "+Replace$(chr$(160)," ", GreekName$ + "      ["+ EnglishName$+"]")
      end if
      out$ =  {
      }
      if i>1 then
            out$ =  If$(Gr->LeftPart$(HelpText$,"__<ENG>__"), RightPart$(HelpText$,"__<ENG>__"))
            out$ =  {
            
            }
      end if
      }
      Clear GreekInfo$
      Clear EnglishInfo$  
   
}
done:
Print "DONE"
Flush
clipboard out$
dir user
if Gr then fname$="Γενικά.doc" else fname$="General.doc"
save.doc out$, fname$
win dir$+fname$   
end
dat:
Data 24
Data 22,"ΓΕΝΙΚΑ, GENERAL"
Data 14,"ΔΙΕΡΜΗΝΕΥΤΗΣ, INTERPRETER"
Data 15,"ΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ, MODULE COMMANDS"
Data 3,"ΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ, FLOW CONTROL"
Data 9,"ΕΝΤΟΛΕΣ ΣΩΡΟΥ, STACK COMMANDS"
Data 7,"ΟΡΙΣΜΟΙ, DEFINITIONS"
Data 25,"ΕΓΓΡΑΦΑ, DOCUMENTS"
Data 11,"ΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ, FILE OPERATIONS"
Data 8,"ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ, CONSOLE COMMANDS"
Data 16,"ΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ, SCREEN AND FILES"
Data 24,"ΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ, OPERATORS IN PRINT"
Data 13,"ΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ, TARGET AND MENU"
Data 1,"ΓΡΑΦΙΚΑ 2Δ, DRAWING 2D"
Data 4,"ΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ, BITMAP COMMANDS"
Data 2,"ΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ, DATABASES"
Data 5,"ΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ, SOUNDS AND MOVIES"
Data 6,"ΕΝΤΟΛΕΣ ΔΕΙΚΤΗ, MOUSE COMMANDS"
Data 10,"ΕΝΤΟΛΕΣ ΙΣΤΟΥ, BROWSER COMMANDS"
Data 12,"ΚΟΙΝΕΣ ΦΟΡΜΕΣ, COMMON DIALOGUES"
Data 19,"ΑΡΙΘΜΗΤΙΚΑ, ARITHMETIC FUNCTIONS"
Data 20,"ΑΛΦΑΡΙΘΜΗΤΙΚΑ, STRING FUNCTIONS"
Data 21,"ΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ, VARS READ ONLY"
Data 23,"ΣΤΑΘΕΡΕΣ, CONSTANTS"
Data 17,"ΕΚΤΥΠΩΣΕΙΣ, PRINTINGS"
Print "Dat ok"
Return

}
MODULE EXPORTHELPNEW {
Print "Greek or English Help File:(G/E)"
Select Case Ucase$(Key$)
case "G", "Γ"
      Gr=True : Print "Greek... Περίμενε"
case "E", "Ε"
      Gr=False : Print "English...Wait"
Else Case
      Break
End Select
Flush
if isnum or  not exist(appdir$+"help2000utf8.dat") then Error "No help2000utf8.dat file found"


inventory GroupOrder=22,14,15,3,9,7,25,11,8,16,24,13,1,4,2,5,6,10,12,19,20,21,23,17
R=lambda GroupOrder (x)->{
	if exist(GroupOrder, x) then =eval(GroupOrder!)
}
Document aLL$, doc$
Load.doc aLL$, appdir$+"help2000utf8.dat"
A=Val(paragraph$(aLL$, 1))
B=Val(paragraph$(aLL$, 2+A))
dim Base 1, a$(B,4)
link a$() to a()

for i=1 to B
	a$(i,1)=mid$(leftpart$(paragraph$(aLL$,2+A+i+(3+GR)*B),"!"),2)
	a(i,2)=Val(rightpart$(paragraph$(aLL$,2+A+i+(3+GR)*B),"!"))
	a(i,3)=R(a(i,2))
	a(i,2)++
	a(i,4)=If(GR->i, Val(rightpart$(paragraph$(aLL$,2+A+i+3*B),"- ")))
next i
sort a(),1,B,3,0,1,0
m=0
deli$=","+chr$(160)
doc$="M2000 "+if$(GR->"Αρχείο Βοήθειας", "Help File")
grp=each(GroupOrder, 2)
doc$={
	
	}+if$(GR->"ΓΕΝΙΚΑ [GENERAL]", "GENERAL [ΓΕΝΙΚΑ]")+{
	
	}
while grp
	d$=paragraph$(aLL$, Eval(grp)+1)
	if len(d$)=0 then continue
	if GR else
		d$=piece$(d$,deli$,2)+deli$+piece$(d$,deli$,1)
	end if
	doc$=" * "+replace$(", "," [",replace$(chr$(160), " ",d$))+{]
	
	}
end while
For i=A to B
	print over
	print part i
	refresh 50
	if instr(a$(i,1),"_2")>0 then continue
	if a(i,2)<>m then
		c$={
		}+"***"+ Piece$(paragraph$(aLL$, a(i,2)), deli$)(GR+1)+{***
		
		}
		m=a(i,2)
	else
		c$={
		
		}
	end if
	f$=If$(instr(a$(i,1),"(")>0->")","")
	d$=paragraph$(aLL$,2+A+a(i,4)+B*(GR+1))
	c$+=If$(GR->"Αναγνωριστικό: ", "identifier:  ")+a$(i,1)+f$+"      ["+Mid$(leftpart$(d$, "\"),4)+f$+{]
	}+format$(mid$(d$,instr(d$,"\")))
	doc$=c$
next i
print
doc$={
}
FL$=IF$(GR->"GreekHelpFile.doc" , "EnglishHelpFile.doc")
Save.Doc doc$,FL$, 2
wait 200
Win Quote$(Dir$+FL$)
}
MODULE CHANGEHELP {if not exist(appdir$+"HELP2000.mdb") then {
      Report {You have to place in appdir$ the HELP2000.mdb
            Also you may install Access2007 runtime
            After edit the help file, use Swicth "+mdb" to use mdb file for help
      }
      break
}
Base 0  \\ for arrays
Font "Arial"
menu fill 1,11,0
menu frame
DB.Provider ""  \\ reset
Window 12, window
refresh
Bold 1 : Form 70, 32
OldDir$=Dir$  \\ keep direcory
Dir AppDir$  \\ Use helpfile from application's Dir
Selection=1
Document HelpText$   \\ this is an object, = means append
{
      Here = 0
      Cls #ffd074,0
      Pen #3c1414 \\dark sienna
      Menu
      Retrieve "HELP2000","GROUP", 1,"",""
      Read Many, NoDummy, nnDummy$
      Dim No(Many+1)  'redim
      For i=1 To Many {
      Retrieve "HELP2000","GROUP", i,"",""
      Read Many, No(i), P$
      If Instr(P$,",")=0 Then {
            Menu + "Without Description Yet  No"+Str$(No(i))
      } Else {
            Menu + Mid$(P$, Instr(P$,",")+1)
      }
}
Print "Prepare the Help Database"
Print "Select Group:";
Menu Show Selection
Selection=Menu
If Menu>0 Then {
      GroupName$=Menu$(Menu)
      If left$(GroupName$,19)="Without Description" Then  {
            Menu "Change Description","Not Now"
            If Menu=1 Then {
            Retrieve "HELP2000","GROUP", Selection,"",""
            Read Many, No(Selection), P$
            GroupName$ =Field$(P$, 50)
            Field 0,Row+1,50 As GroupName$
            Return "HELP2000","GROUP" To Selection, ,GroupName$  
            Print
            If Instr(P$,",")=0 Then {
                        GroupName$ = "Without Description Yet  No"+Str$(No(Selection))
                  } Else {
                        GroupName$ =  Mid$(P$, Instr(P$,",")+1)
                  }
            }
      }
      Print GroupName$
      Retrieve "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(Selection)),1,"",""
      Read Many
      Menu
      Print "Select identifier:";
      If Many>0 Then {
            Clear HelpText$
            Read GreekName$, HelpText$, EnglishName$, GroupNumFrom
            Menu + "<New>"
            View "HELP2000", "SELECT [ENGLISH] FROM COMMANDS WHERE GROUPNUM ="+Str$(No(Selection))+" ORDER BY [ENGLISH]",1,Many
            Sel2=Menu
            If Sel2>1 Then {
                  Print Menu$(Sel2)
                  Retrieve "HELP2000", "COMMANDS",1,"ENGLISH",Menu$(Sel2)
                  Cls #fdf5e8,3  \\ paper white
                  Pen #100c08  \\ smoky black
                  Read Many
                  If Many= 0 Then Exit
                  Clear HelpText$
                  Read GreekName$, HelpText$, EnglishName$, GroupNumFrom
                  Print "Greek:";GreekName$ 
                  Print "English:";EnglishName$
                  Report HelpText$
                  Menu
                  Print @(40);"Choose ";
                  Menu "Edit Description","Change Group","Pick another","End"
                  Cls #edca85,3
                  Pen #3c1414
                  If Menu=4 Then Exit
                  If Menu=3 Then Here = True : Exit
                  If Menu=2 Then {
                        ChangeGroup(EnglishName$)
                        Here = True
                  } Else {
                        Escape Off
                        Scroll Split Row
                        Cls #0077AA
                        Pen #66DD77
                        Edit.doc Code HelpText$
                        Return "HELP2000", "SELECT * FROM [COMMANDS] WHERE ENGLISH LIKE '"+EnglishName$ +"'", ,HelpText$
                        Escape On
                        Here=True  
                  }
            } Else.If Sel2=1 Then {
                  Print "New"
                  Escape off
                  Input "Greek:", GreekID$
                  Input "English:", EnglishID$                      
                  ''Input ! HelpText$, Width-1, Height-Row-2
                  Scroll Split Row
                  Clear HelpText$    ' we need a fresh one
                  Cls #0077AA
                  Pen #66DD77
                  Edit.doc Code HelpText$
                  Menu
                  Escape on
                  Print "Save it?"; : Menu "Yes","No"
                  If Menu =1 Then {
                        Append "HELP2000","COMMANDS",GreekID$, HelpText$, EnglishID$, No(Selection) 
                        Wait 100 
                  }
            Here =True
            }     
      } Else {
      ' If is empty delete group
            Delete "HELP2000","GROUP","GROUPNUM", No(Selection)
      }
}
If Here Then Loop
      Cls #ffd074,0
}
Print "Create General (Y/N) ?"
If Ucase$(Key$)="Y" Then CreateGeneral()
Dir OldDir$
Print "Compress (Y/N) ?"
If Ucase$(Key$)="Y" Then Compress()
End
Sub ChangeGroup(descr2match$)
      Stack New {
            Cls
            Menu
            Retrieve "HELP2000","GROUP", 1,"",""
            Read MANY, No, nn$
            For i=1 To MANY {
                  Retrieve "HELP2000","GROUP", i,"",""
                  Read MANY, No, P$
                  Print No, P$
            }
            Retrieve "HELP2000", "SELECT * FROM [COMMANDS] WHERE ENGLISH LIKE '"+descr2match$+"'",1,"",""
            
            If Not Empty Then {
                  Read MANY, GreekName$, HelpText$, EnglishName$, groupnumFrom
                  Print "ENGLISH:";EnglishName$
                  Print "No", groupnumFrom
                  Try ok {
                        Input "New No:", groupnumTo
                  }
                  If Not ok Then exit
                  If groupnumTo>0 Then {
                        return "HELP2000","SELECT * FROM [COMMANDS] WHERE ENGLISH = '"+EnglishName$+"'",,,,groupnumTo
                  }
            }
      }
End Sub
Sub Compress()
      Print Part $("#,###,###,###\ \B\y\t\e\s"),FILELEN(AppDir$+"help2000.mdb")
      Print Under
      Close Base Lcase$(AppDir$+"help2000.mdb")
      a$=Dir$
      Dir AppDir$
      compress AppDir$+"help2000.mdb"
      Dir a$
      Print PART $("#,###,###,###\ \B\y\t\e\s"),FILELEN(AppDir$+"help2000.mdb")
      Print 
      Dir User
End Sub
Sub CreateGeneral()
\\ this module exist only in until this sub exit
Module CreateGeneral {

\* For each group we get a field in General Group
\* Use module mg to create grouporder
\\ flush
Data 24
Data 22
Data 14
Data 15
Data 3
Data 9
Data 7
Data 25
Data 11
Data 8
Data 16
Data 24
Data 13
Data 1
Data 4
Data 2
Data 5
Data 6
Data 10
Data 12
Data 19
Data 20
Data 21
Data 23
Data 17
Data 24
Data 1,"ΓΡΑΦΙΚΑ 2Δ, DRAWING 2D"
Data 2,"ΒΑΣΕΙΣ ΔΕΔΟΜΕΝΩΝ, DATABASES"
Data 3,"ΡΟΗ ΠΡΟΓΡΑΜΜΑΤΟΣ, FLOW CONTROL"
Data 4,"ΕΝΤΟΛΕΣ ΕΙΚΟΝΩΝ, BITMAP COMMANDS"
Data 5,"ΗΧΟΙ ΚΑΙ ΤΑΙΝΙΕΣ, SOUNDS AND MOVIES"
Data 6,"ΕΝΤΟΛΕΣ ΔΕΙΚΤΗ, MOUSE COMMANDS"
Data 7,"ΟΡΙΣΜΟΙ, DEFINITIONS"
Data 8,"ΕΝΤΟΛΕΣ ΚΟΝΣΟΛΑΣ, CONSOLE COMMANDS"
Data 9,"ΕΝΤΟΛΕΣ ΣΩΡΟΥ, STACK COMMANDS"
Data 10,"ΕΝΤΟΛΕΣ ΙΣΤΟΥ, BROWSER COMMANDS"
Data 11,"ΧΕΙΡΙΣΜΟΣ ΑΡΧΕΙΩΝ, FILE OPERATIONS"
Data 12,"ΚΟΙΝΕΣ ΦΟΡΜΕΣ, COMMON DIALOGUES"
Data 13,"ΣΤΟΧΟΙ ΚΑΙ ΕΠΙΛΟΓΗ, TARGET AND MENU"
Data 14,"ΔΙΕΡΜΗΝΕΥΤΗΣ, INTERPRETER"
Data 15,"ΧΕΙΡΙΣΜΟΣ ΤΜΗΜΑΤΩΝ, MODULE COMMANDS"
Data 16,"ΟΘΟΝΗ ΚΑΙ ΑΡΧΕΙΑ, SCREEN AND FILES"
Data 17,"ΕΚΤΥΠΩΣΕΙΣ, PRINTINGS"
Data 19,"ΑΡΙΘΜΗΤΙΚΑ, ARITHMETIC FUNCTIONS"
Data 20,"ΑΛΦΑΡΙΘΜΗΤΙΚΑ, STRING FUNCTIONS"
Data 21,"ΜΕΤΑΒΛΗΤΕΣ ΣΥΣΤΗΜΑΤΟΣ, VARS READ ONLY"
Data 22,"ΓΕΝΙΚΑ, GENERAL"
Data 23,"ΣΤΑΘΕΡΕΣ, CONSTANTS"
Data 24,"ΧΕΙΡΙΣΤΕΣ ΤΗΣ ΤΥΠΩΣΕ, OPERATORS IN PRINT"
Data 25,"ΕΓΓΡΑΦΑ, DOCUMENTS"

            Read  myGroups
            Dim No(myGroups+1), Name$(myGroups+1) , PointTo(100)
            for i=1 to myGroups {
                  Read n
                  PointTo(n)=i
            }
           drop  ' a second 24 value
            
          for i=1 to myGroups {
                Read n
                No(PointTo(n))=n
                Read  name$(PointTo(n))           
            }  
Document GreekInfo$, EnglishInfo$, GroupInfo$, AllGreek$, AllEnglish$
Dir AppDir$
stp$=","+chrcode$(160)
Execute "HELP2000", "DELETE FROM COMMANDS WHERE GROUPNUM =22;"
\\ Retrieve "HELP2000","GROUP", 1,"",""
      For i=1 To myGroups {
           EnglishInfo$= RightPart$(name$(i),stp$)
           GreekInfo$= LeftPart$(name$(i),stp$)
           GreekInfo$={
           }
           EnglishInfo$={
           }
         
            Retrieve "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i)),1,"",""
            Read mywords
            If no(i)<>22 Then {
            For j=1 To mywords {
                  Retrieve  "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i))+" ORDER BY [ENGLISH]",j,"",""        
                  Read mywords
                  Read GreekName$, HelpText$, EnglishName$, groupnumFrom     
                  If mywords=j Then {EnglishInfo$= EnglishName$ } Else  EnglishInfo$= EnglishName$+", "
                  Retrieve  "HELP2000", "SELECT * FROM COMMANDS WHERE GROUPNUM ="+Str$(No(i))+" ORDER BY [DESCRIPTION]",j,"",""
                  Read mywords
                  Read GreekName$, HelpText$, EnglishName$, groupnumFrom     
                  If mywords=j Then {GreekInfo$= GreekName$} Else GreekInfo$= GreekName$+", "                
            }
         AllGreek$=GreekInfo$+{
         
         }
         AllEnglish$=EnglishInfo$+{
         
         }
         GroupInfo$=GreekInfo$+{
         __<ENG>__
         }+EnglishInfo$+{
         
         }
         \\  print LeftPart$(name$(i),stp$)    \\ Greek name of group
         print RightPart$(name$(i),stp$)
         Append "HELP2000",  "COMMANDS",  LeftPart$(name$(i),stp$),  GroupInfo$, RightPart$(name$(i),stp$), 22
         Clear GroupInfo$
         }
         Clear GreekInfo$
         Clear EnglishInfo$  
         
      }  
      AllGreek$={
      __<ENG>__
      } + AllEnglish$
         Append "HELP2000",  "COMMANDS",  "ΟΛΑ",  AllGreek$,"ALL", 22
         Help All
Print "DONE"
clear
Flush
Dir User

}
Stack New {
	CreateGeneral	
}

End Sub
}
MODULE MAKEHELP {
if not exist(appdir$+"HELP2000.mdb") then {
	Report {You have to place in appdir$ the HELP2000.mdb
		Also you may install Access2007 runtime
		After edit the help file, use Swicth "-mdb" to use dat file for help
		To use a new dat file you have to exit  m2000.exe, and start again, becaue the first time we use help with dat file interpreter load it.
		You can place the Help2000.mdb in USER file. Deletet appdir$+ before "HELP2000.mdb"
		Don't forget after edit this module to exit and press F1 to save info to USER directory
	}
	break
}
pen 14 : cls 5
flush
\\DIR APPDIR$ \\  from installation folder use this
Retrieve  APPDIR$+"HELP2000","GROUP", 1,"",""
Read many
Flush
Dim Labels$(1 to 25), ser(1 to many)
For i=1 to many
Retrieve  APPDIR$+"HELP2000","GROUP", i,"",""
drop
Read where, Labels$(where)
ser(i)=where
flush
next i
Retrieve  APPDIR$+"HELP2000", "SELECT * FROM COMMANDS",1,"",""
Read many
dim ALL(1 to many)
Document infoGr$, Info$, greek$, english$, no2lang$
br$={__<ENG>__
}
nl$=string$({
} as json )
p1=1
for i=1 to many
Retrieve APPDIR$+"HELP2000", "SELECT * FROM COMMANDS",i,"",""
drop
ALL(i)=Array([])
Print ALL(i)#val$(2), rightpart$(Labels$(ALL(i)#val(3)), ","+chr$(160))
Print ALL(i)#val$(0), leftpart$(Labels$(ALL(i)#val(3)), ","+chr$(160))
greek$="\"+ALL(i)#val$(0)+"!"+str$(ALL(i)#val(3),"")+{
}
english$="\"+ALL(i)#val$(2)+"!"+str$(ALL(i)#val(3),"")+"-"+Str$(i)
if i<many then
	english$={
	}
end if
if instr(ALL(i)#val$(1), br$)=0 then
infoone$="GR:"+ALL(i)#val$(0)+nl$+ALL(i)#val$(1)
info$=infoone$+{
}
infoone$="EN:"+ALL(i)#val$(2)+nl$+ALL(i)#val$(1)
infoGR$=infoone$+{
}
no2lang$=ALL(i)#val$(2)+{
}
else

infoone$="GR:"+ALL(i)#val$(0)+nl$+string$(rightpart$(ALL(i)#val$(1), br$) as json)
info$=infoone$+{
}
infoone$="EN:"+ALL(i)#val$(2)+nl$+string$(leftpart$(ALL(i)#val$(1), br$) as json)
infoGR$=infoone$+{
}
end if

next
Method english$, "SetLocaleCompare", 1033
Method english$, "SetBinaryCompare"
Sort english$
Dir User   \\ open this using Win Dir$
open "Help2000.dat" for wide output as #k
Print #k, Len(Labels$())
for i=1 to len(Labels$())
	Print #k, Labels$(i)
next i
Print #k, Many
Print #k, infoGr$;info$;greek$;english$
close #k
Print "No second language"
report no2lang$
clear
Document ALL$, all1$
Load.doc ALL$, "help2000.dat"
print filelen("help2000.dat")
save.doc all$,"help2000utf8.dat", 2   ' utf-8
print filelen("help2000utf8.dat")
Try {
	dir appdir$
	save.doc all$,"help2000utf8.dat", 2   ' utf-8
}
dir user
}
MODULE SNAKE {Αν Τοπικό=1032 ή Ελληνικά Τότε {
      Αν Ρώτα( "Κράτα πατημένο το διάστημα πριν τελειώσει το παιχνίδι για άμεσο τερματισμό","Παιχνίδι Φιδάκι","*Ξεκινάω","Όχι τώρα")<>1 τότε Διέκοψε
} Αλλιως {
      Αν Ρώτα( "Press Space to exit before the game end","snake game","*Start","Leave")<>1 τότε Διέκοψε
}
Διαφυγή Όχι
Δυαδικό {
      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
      CvwDsQToRRwHj3AAAAAASUVORK5CYII=
} Ως ΦιδάκιΕικόνα

\\ Φιδάκι!
Πένα 14
Ομαλά Ναι
Θέσε Γρήγορα !
\\Διαφυγή Όχι
Οθόνη,0
Καθαρό Α$
Κλάση Κ_5χ6 {
      μεταφορά$
      Ιδιότητα θ {Θέσε}
      Ιδιότητα Χ { 
            Αξία {
                  Ένωσε Γονικό [θ] στο θ
                  Αξία=(θ-1) υπολ 6
            }
            }
      Ιδιότητα Υ { 
            Αξία {
                  Ένωσε Γονικό [θ] στο θ
                  Αξία=(θ-1) Δια 6
            }
      }            

}
Κλάση Πιόνι {
      θέση_π, νο
      νέα_θέση
      Τμήμα Αφαίρεσε {
            .θέση_π<=0
      }
      Τμήμα Μετακίνηση {
            .θέση_π<=.νέα_θέση
            .νέα_θέση<=0
      }
}
Πάλι_εδώ:
Πίνακας Θέσεις(31)=Κ_5χ6(), Πιόνια(4)=Πιόνι(), ΣειράΝικητών(4)=0
Για ι=1 Έως 4 { Για Πιόνια(ι-1) {.θέση_π=1 : .νο=ι}}
Για ι=1 εως 30 {
      Αν ((ι-1) Υπολ 12)>5 Τότε { θέσεις(ι).θ=6*((ι-1) Δια 6)+(6-(ι-1) υπολ 6) } Αλλιώς θέσεις(ι).θ=ι
}
\\ φίδια!
Θέσεις(27).μεταφορά$="22,23,24,13,12,1"
Θέσεις(21).μεταφορά$="16,15,10,9"
Θέσεις(19).μεταφορά$="18,7"
Θέσεις(17).μεταφορά$="8,9,4"
\\ σκάλες
Θέσεις(3).μεταφορά$="10,15,22"
Θέσεις(5).μεταφορά$="8"
Θέσεις(11).μεταφορά$="14,23,26"
Θέσεις(20).μεταφορά$="29"

Γενικές χ,υ, θχ, θυ, Χρ(5)
Χρ(1)=14,11,13,12
Στοίχισε(ΦιδάκιΕικόνα, &χ,&υ,&θχ,&θυ)
Ανανεώση 5000
Φοντο 1,5
κ=υ/1200
Βάλε_Τίτλο("Snake Board Game - AutoPlay", 0, θυ*.8, 0)
Βάλε_Τίτλο("Dice", 0,θυ*.4, θυ, θχ)
ΠλαίσιοΠαικτών(0,θυ*.4, Θυ, θχ, κ)
Για ι=1 Έως 4 {
      ΠιόνιΣτοΠλαίσιο(0,θυ*.4,θυ, θχ, κ, ι)
}
Βάλε_Τίτλο("Final", θχ+χ,θυ*.4, θυ)
ΠλαίσιοΠαικτών(θχ+χ,θυ*.4,θυ,Χ.σημεία, κ)
Για ι=1 Έως 4 {
      ΠιόνιΣτοΠλαίσιο(θχ+χ,θυ*.4, θυ,Χ.σημεία, κ, ι)
}
θέση θχ, θυ
Εικόνα ΦιδάκιΕικόνα, χ
\\ το φιδάκι έχει 6 Χ 5 θέσεις
Κάνε ΜετΧ(χχ,κ)=(χ Δια 6)*χχ+(κ/30)*χ+χ/40+θχ
Κάνε ΜετΥ(υυ)=(υ Δια 5)*υυ+υ/20+θυ
Κράτησε
Οθόνη, -5
Δείξε_Όλα(-1,"")
ολα=1
Νικητές=0
Ενώ  ολα>0 και όχι πατημένο(32) {
      ολα=0
      Για ι=1 Έως 4 {
            Αν πιόνια(ι-1).θέση_π>0 Τότε {
                  ολα++
                  Ζάρι=Τυχαίος(1,6) ' για μεγάλο Ζάρι 1,10 !
                  Αν πιόνια(ι-1).θέση_π+Ζάρι >31 τότε {
                        ΠαίξεΜε(ι, Ζάρι, Αληθής, μορφή$("{0}",Ζάρι))
                  } Αλλιώς {
                        Για μ=1 Έως Ζάρι {
                              ΠαίξεΜε(ι, 1, ζαρι=μ, μορφή$("{0}",Ζάρι))
                        }     
                  }
            }
            Αν νικητές=4 Τότε Έξοδος
      }
}
Αν νικητές=4 Τότε {
      Για ι=1 Έως 4 {
            Αν πιόνια(ι-1).θέση_π>0 Τότε πιόνια(ι-1).θέση_π=0 : ΣειράΝικητών(ι-1)=4
      }
}
Δείξε_Όλα(-1,"")
Κύλιση Χώρισμα 0  ' όπως το Οθόνη,0 χωρίς να καθαρίσει την οθόνη!
Ανανέωση 25
Αν Τοπικό=1032 ή Ελληνικά Τότε {
      Αν Ρώτα( "Νέο Παιχνίδι","Παιχνίδι Φιδάκι","*Να Παίξω","Όχι τώρα")=1 τότε προς Πάλι_εδώ
} Αλλιως {
      Αν Ρώτα( "New Game","snake game","*Play","Not now")=1 τότε προς Πάλι_εδώ
}
Αν Τμημα(info) Τότε  Πληκτρολόγιο "info"+χαρ$(13)
Διαφυγή Ναι
Θέσε Γρήγορα
Τέλος
Ρουτίνα ΠαίξεΜε(Πιόνι, Ζάρι, τελικό, ζαρ$)
      Τοπική πιόνι1=-1, μεζάρι=Αληθής, πρ$, ι
      Σωρός Νέος {
            Για Πιόνια(Πιόνι-1) {
                        Αν μεζάρι Τότε {
                        Άν (Ζάρι+.θέση_π)<=30 Τότε { 
                                 .νέα_θέση=Ζάρι+.θέση_π 
                                 πιόνι1=Πιόνι
                                 Αν τελικό Τότε {
                                       πρ$=Θέσεις(.νέα_θέση).μεταφορά$
                                       Αν πρ$<>"" Τότε Σωρός πρ$
                                 }
                        } Αλλιώς.Άν (Ζάρι+.θέση_π)>31 τότε {
                              \\ Φιδάκι 2....επιστροφή!
                               .νέα_θέση= 61-Ζάρι-.θέση_π
                              πιόνι1=Πιόνι
                              Δες οκ {
                              Αν Ζάρι+.θέση_π>32 Τότε {
                                     πρ$=Θέσεις(.νέα_θέση).μεταφορά$
                                     Αν πρ$<>"" Τότε Σωρός πρ$
                                     Για ι=61-Ζάρι-.θέση_π  έως 29 {
                                          Βάλε ι 
                                     }
                               }
                              Αν .θεση_π<30 τότε {
                                    Για ι=30 έως .θέση_π+1 {
                                          Βάλε ι
                                    }
                              }      
                              }
                           Αν είναρ τότε  Διάβασε .νέα_θέση
                              αν όχι οκ τότε ανανέωση 50 : δοκιμη
                        } Αλλιώς .θέση_π=0 : νικητές++ : ΣειράΝικητών(Πιόνι-1)=νικητές
                  } Αλλιώς {
                          Διάβασε .νέα_θέση     
                  }   
            }
            Δείξε_Όλα(πιόνι1, ζαρ$) 
            μεζάρι=0
            Αν ΕινΑρ Τότε Κυκλικά
      }
Τέλος Ρουτίνας
Ρουτίνα Δείξε_Όλα(εκτός, λεζ$)
      Τοπική ι, κιν, εξ=Αληθής
      Για κιν=1 Έως 4 {
            Άφησε
            Για ι=0 Έως 3 {
                  Για Πιόνια(ι) {
                        Αν .θέση_π>0 Τότε {
                              Αν .νο<>εκτός Τότε {
                                    Για θέσεις(.θέση_π) {
                                          ΠιόνιΔείξε(..Χ,..Υ,.νο)
                                    } 
                              } Αλλιώς {
                                    ΠιόνιΚιν(Θέσεις(.θέση_π).Χ,Θέσεις(.θέση_π).Υ, Θέσεις(.νέα_θέση).Χ,Θέσεις(.νέα_θέση).Υ,κιν, .νο)
                                    εξ=Ψευδές
                                    Αν κιν=4 Τότε .μετακίνηση
                              }
                        }            
                  }
                  Αν ΣειράΝικητών(ι)>0 Τότε ΛεζάνταΣτοΠλαίσιο(θχ+χ,θυ*.4, θυ,Χ.σημεία, κ, ι+1, μορφή$("{0}",ΣειράΝικητών(ι)))
            }
            Αν εκτός>=0 Τότε {
                  ΛεζάνταΣτοΠλαίσιο(0, θυ*.4,θυ,θχ ,κ,εκτός, λεζ$)
            }
            Ανανέωση 5000
            Αν εξ Τότε Έξοδος
      }
Τέλος Ρουτίνας
Ρουτίνα Στοίχισε(εικόνα1, &χχ, &υυ, &μ_χ, &μ_υ)
      Τοπική αναλογία_εικόνας
      αναλογία_εικόνας=Εικόνα.Χ.Σημεία(εικόνα1)/Εικόνα.Υ.Σημεία(εικόνα1)
      χχ=Χ.σημεία*.7
      υυ=Υ.σημεία*.7
      Αν χχ>αναλογία_εικόνας*υυ Τότε {χχ=αναλογία_εικόνας*υυ} Αλλιώς υυ=χχ/αναλογία_εικόνας
      μ_χ=(Χ.σημεια-χχ) Δια 2
      μ_υ=(Υ.σημεια-υυ) Δια 2
Τέλος Ρουτίνας
Ρουτίνα ΠιόνιΔείξε(χ1, υ1, νο)
      Θέση ΜετΧ(χ1,νο-1),ΜετΥ(4-υ1)
      βήμα χ/120, υ*3/44
      Πάχος 3 { Πένα 0 { Κύκλος Γέμισμα Χρ(νο), υ*3/44,3 } }
Τέλος Ρουτίνας
Ρουτίνα ΠιόνιΚιν(χ1, υ1, χ2,υ2, κιν, νο)   
      Θέση ΜετΧ(χ1,νο-1)-κιν*(ΜετΧ(χ1,νο-1)-ΜετΧ(χ2,νο-1))/4,ΜετΥ(4-υ1)-κιν*(ΜετΥ(4-υ1)-ΜετΥ(4-υ2))/4
      βήμα χ/120, υ*3/44
      Πάχος 3 { Πένα 0 { Κύκλος Γέμισμα Χρ(νο), υ*3/44,3 } }
Τέλος Ρουτίνας
Ρουτίνα Βάλε_Τίτλο(τ$, χ1, μυ, υ2)
      Αν Ταύτιση("Α") Τότε { Διάβασε Τοπικά χ2 } Αλλιώς χ2=χ.σημειά
      Τοπική μ,μχ
      μ=μυ/30*ύψος.σημείου/15
      μχ=(χ2-χ1-Μέγεθος.χ(τ$, "Arial Black",μ)) Δια 2
      Αν μχ<0 Τότε  {
            μ=μεγαλο.σειράς(μ/2,6)
            μχ=(χ2-χ1-Μέγεθος.χ(τ$, "Arial Black",μ)) Δια 2
      }
      θέση μχ+χ1, υ2
      Επιγραφή τ$, "Arial Black",μ
Τέλος Ρουτίνας
Ρουτίνα ΠιόνιΣτοΠλαίσιο(χ1, μυ, υ2, χ2, ν, νο)
      Τοπική μ,μχ
      μχ=(χ2-χ1)/6
    Θέση χ1+μχ+χ/30, υ2+μυ+(υ-μυ*2)*(νο-.5)/4
    Πάχος 3 { Πένα 0 { Κύκλος Γέμισμα χρ(νο), υ*3/44,3 } }
Τέλος Ρουτίνας
Ρουτίνα ΛεζάνταΣτοΠλαίσιο(χ1, μυ, υ2, χ2, ν, νο, Λ$)
      Τοπική μ,μχ
      μχ=(χ2-χ1)/6
      Βάλε_Τίτλο(Λ$,χ1, μυ*2,υ2+(υ-μυ*2)*(νο-.5)/4, χ2) 
Τέλος Ρουτίνας
Ρουτίνα ΠλαίσιοΠαικτών(χ1, μυ, υ2, χ2, ν)
      Τοπική μ,μχ
      μχ=(χ2-χ1)/6
      Θέση χ1+μχ, υ2+μυ
      Πάχος 2 {
            Χρώμα 3 {
                  Βάψε μχ*4, υ-μυ*2
            }
      }
Τέλος Ρουτίνας

}
MODULE MAXITEM {Module TestThis {
      Print "Search a tuple type list (is an array also)"
      A=(,)
      For i=1 to Random(1,10)
      Append A, (Random(1,100),)
      Next
      Print Len(A)
      Print A
      Print A#max()
      
      Print "Search an array"
      B=lambda->Random(1,100)
      Rem Dim A(1 to Random(1,10))<<B()
      Dim A(1 to Random(1,10))<<lambda->{=Random(1,100)}()
      Print Len(A())
      Print A()
      Print A()#max()
      
      \\ #max() skip non numeric values
      Rem Print (1,"100",3)#max()=3
      
      Print "Search an inventory list"
      Inventory C
      for i=1 to Random(1,10)
            do
                  key=random(10000)
            until not exist(c, key)
            \\ we can put a number as string
            if random(1,2)=1 then Append c, key:=B() else Append c, key:=str$(B())
      Next
      
      \\ if inventory item is string with a number work fine
      Function MaxItem(a) {
            k=each(a,2)
            val=a(0!)
            while k
                  \\ using stack of values
                  \\ over -equal to over 1 - copy value from 1 to top, means double the top value
                  \\ number - pop top value
                  \\ drop -equal to drop 1 : drop top value 
                  Push a(k^!): Over : If Number>val then Read Val else drop
                  Rem If a(k^!)>Val Then Val=a(k^!)
            end while
            =val
      }
      Print Len(C)
      Print C
      Print MaxItem(C)
      
      Print "Search a stack object"
      \\ a stack object is the same as the stack of values
      \\ which always is present
      D=stack
      I=0
      J=Random(1,10)
      \\ Stack stackobjext {}
      \\ hide current stack and attach the D stack
      Stack D {
            Push B() : I++ : IF I>J Else Loop
      }
      \\ if stack item isn't numeric we get a run time error
      Function MaxItemStack(a) {
            Stack a {env$=envelope$()}
            if replace$("N","", env$)<>"" then error "only numbers allowed"
            k=each(a,2)
            val=Stackitem(a,1)
            while k
                  If Stackitem(k)>val then Val=stackitem(k)
            end while
            =val
      }
      Print Len(D)
      Print D
      Print MaxItemStack(D)     	
}
TestThis
}
MODULE INFO {keyboard "UseThis : InfoBasic : Fkey"+chr$(13)

}
MODULE CLOCK1 {''keyboard " clock %ok=1 : clear :  info "+chr$(13)
Report{
	Wait for loading another m2000.exe which load info.gsb as modules
	Click on clock and press space to close it
	Hold mouse down at the center to move the clock
	Code written in GREEK Language
	Use ctrl+F1 for help (Greek and English lanugage)
	To see the code give here: edit clock
}
win appdir$+"m2000.exe", {load modules info.gsb: ok=1: clock: end}

}
MODULE USETHIS {hide
window mode, window
back {cls 11,0}
Font "Verdana"
Bold 1
PEN 14
CLS,0
If Version<11 then Error "No proper M2000 version (must be >=11)"
If Version=11 and revision<7 then Error "No proper M2000 revision for version 11 (need revision >=7)"
Set Fast
Title "Info",1   ' open a window in task bar with name info (If  you run Demo, at the exit you get no window in task bar, so we can restore it)
dir user
Player 0  ' erase any layer

\\ Use form without ! for less border
\\ Form ! 100,66

}
MODULE DOWN4 {thread.plan concurrent 'sequential
module OpenHtml (filename$){
	\\ call m2000.exe and then load info without executing commands, and then execute htmleditor passing the filename
	\\ and last an End command to end the program
	win appdir$+"m2000.exe","{{load modules info : htmleditor {"+filename$+"}: end}}"
}
Declare form1 form
With form1, "visible" as visible
with form1, "Title", "Download Example"
layer form1 {
	window 12, 12000,6000
	cls #333333
	cursor 0,2
	report 2,"close form to exit download"
}
Method form1, "show"
cls,0
report 2, "Download 4 Files using Download object"
cls, 10
declare withevents d(3) download
w=0
m=row
Function d_Start(new con, host$,port) {
	cursor 0,m
	Print Part con, host$, port
	Print under
	m=row
	w++
}
Function d_DownloadProgress(new con, many, total) {
	cursor 0,3+con
	Print over $(4,10), con,  many;"/";total
	\\ do not use Refresh here
	cursor 0, m
	layer form1 {
		cursor 0,3+con
		Print over $(4,10), con,  many;"/";total		
	}
}
Function d_DownloadError(new con) {
	cursor 0,m
	Print "DownLoad Error"
	Print  con, number, letter$
	m=row
	layer form1 {
		cursor 0,3+con
		Print over $(4,10), con,  "failed"
	}
	w--
}
Function d_DownloadComplete(new who, a$) {
	cursor 0,3+who
	print over a$+" - complete"+str$(filelen(a$))
	layer form1 {
		cursor 0,3+who
		print over a$+" - complete	"
	}
	w--	
}
declare d() over   ' one more withevents - so now we have 4
\\ GetUrl$() function used if we wish the property url to connect on the fly, and disposed
\\ because object is naked (not in a mHandler carrier), can't used as value
\\ so we have to pass it by reference
\\ M2000 pass array items by reference using a second variable, which pass by reference
\\ and at the exit get the value from the variable and try to store it back to array to proper item
\\ no error happen if array has no item with specific item number
\\ this method is like copy in copy out
\\ VB6 lock arrays if we pass an array item by reference. M2000 never lock arrays.
Function GetUrl$(&where) {
	With where, "url" as url$
	=url$
}
Dim url$(4)
for i=0 to len(d())-1
	With d(i), "url" as url$(i)  \\ connect property url of d(i) to url$(i)
next i
Method d(0), "DownloadFile", "http://www.columbia.edu/~fdc/sample.html", dir$+"sample.html"
Method d(2), "DownloadFile", "http://www.columbia.edu/~fdc/family/hallshill.html", dir$+"hallshill.html"
Method d(1), "DownloadFile","http://www.columbia.edu/~fdc/family/frankfurt.html", dir$+"frankfurt.html"
Method d(3), "DownloadFile","http://www.columbia.edu/~fdc/family/family.html", dir$+"family.html"
cursor 0, m

for i=0 to len(d())-1
	Print Part "Read Property Url for"+str$(i)+":";~(11); url$(i)  ' GetUrl$(&d(i)) 
	Print Under
Next
Print "press left mouse to exit"
refresh
m=row
cls,m
kk=0
\\ we use a block in thread so concurrent not happen for each statement in thread but all statements in block executed in once
thread {
{
	cursor 0, m
	print kk
	kk++
	m=row

}
} as mm interval 10
While w
	cursor 0,2
	print over $(4),"live connections:";w, visible
	if keypress(2)  or not visible then exit
	bb$=inkey$
	\\ wait 0
	\\ threads need a wait or a Key$, or Inkey$ or a Main.Task or a Every, or a Modal form to be opend.
	\\ com events no need this.
End While
threads erase
wait 100
cursor 0,2
print over $(4),"live connections:";w
cursor 0,m
If exist("sample.html") then Print "sample.html - ";Filelen("sample.html")
If exist("hallshill.html") then Print "hallshill.html - ";Filelen("hallshill.html")
If exist("frankfurt.html") then Print "frankfurt.html - ";Filelen("frankfurt.html")
If exist("family.html") then Print "family.html - ";Filelen("family.html")
print "done"
declare d() nothing
declare form1 nothing
if exist("family.html") then
	if filelen("family.html")>0 then
		ok=false
		if Ask("Open family.html in htmlEdtitor, as other process?")=1 then ok=true 
		if Ask("Open family.html in console text editor?")=1 then
			if ok then After 500 {openhtml "family.html"}: Mes()
			Edit "family.html", 1
		else
			if ok then After 50 {openhtml "family.html"}: Mes()
		end if
		
	end if
end if
Sub Mes()
	Print "wait and then use ctrl+tab (or maybe not use it) to get the htmleditor window"
	Wait 100
End Sub
}
MODULE CHESSGAME {\\ George Karras, 2020
\\ Chess Example (a big one)
\\ Example Using sprites
\\ Rev. 6
\\ to add a chess engine:
\\ at m2000 console type: win dir$
\\ paste to that folder the engine.exe
\\ this engine is an executable file like stockfish_20090216_x64_modern.exe
\\ from https://stockfishchess.org/
\\ so get the proper exe file, copy to m2000 user folder (use win dir$ from m2000 console)
\\ then rename it as engine.exe

enginepath$=dir$+"engine"
blackComputer=exist(enginepath$+".exe")
gosub initengine

chessfont$="Arial Unicode MS"
Font chessfont$
if not Fontname$="Arial Unicode MS" then
	chessfont$="DejaVu Sans"
end if
Font "Verdana"
Thread.plan sequential
Set Fast
Hide
window 12, window
if random(1, 3)=1 then
window 12, scale.x*random(6,9)/10,scale.y*random(6,9)/10;
end if
form 48,34
def thismode
thismode=mode
global const  NoSound = False
Module NothingToMove {
	Layer {Print $(4)," Nothing to move",$(0);}
}
Module Proper {
	Layer {Print $(4)," Wrong color",$(0);}
}
Module Beep {
	Layer {Print $(4)," Not Possible",$(0);}
	if NoSound Else Beep
}
back {
	\\ we use a switch to alter the return code in Input ! variant, when we press Enter key
	\\ normally "-inp" return in Field  read only variable 1 when we press enter or down arrow
	\\ using "+inp" we can get 13 for enter and 1 for down arrow
	Cls 0,0
	font "Times"
	Pen 15
	Mode thismode*5
	cursor 0,height div 2
	Report 2, "Wait...."
	refresh 10000	
	Mode thismode

	set switches "+inp"
	Fkey Clear
	Escape off
	Cls #FFA000,0
	Pen 14
	bold 1
	mode thismode
	Def White$="PNBRQK", Black$="pnbrqk", WhiteDisp$="♙♘♗♖♕♔"
	Def BlackDisp$="♟♞♝♜♛♚", empty$="12345678", disp$
	disp$=WhiteDisp$+BlackDisp$ 
	Def White_♔_file, White_♔_rank, Black_♚_rank, Black_♚_file
	Def boolean White_♔_no_roke, Black_♚_no_roke
	Def boolean White_no_left_roke, Black_no_left_roke
	Def boolean White_no_right_roke, Black_no_right_roke
	Def Halfmove_clock, Fullmove_number, threat, Clip$
	Dim emptydisp$(1 to 8), BoardSq(1 to 8, 1 to 8)=(,)
	Def en_passant_rank=0, en_passant_file=0
	for i=1 to 8 :emptydisp$(i)=string$(" ",i):next i
	Def board$, status$, oldI, color1, color2, C=14
	color1=Color(209, 139, 71)
	color2=Color(255, 206,158)
	
	dim line$()
	Def flashtime=300
	Dim PastGames$(1 to 200)
	Def freeSlot=0, cur=0, ok=true, k$, condition$
	Def double ip, jp, ip1, jp1, si, sj, getone as boolean
	Def st, fig$, tr, mx, my, lx,ly, key=0, mmx,mmy, mmb
	Def movelogic as boolean=false, mvx, mvy
	sa=(,) : sb=each(sa)
	Double
	OldI=Italic
	Italic 1
	Def upperlimit
	Cursor 0,0
	Pen 15 {Report 2, "Chess Game "+if$(blackComputer->"UCI Engine", "for two")}
	Italic OldI
	Normal
	Move !      ' Move graphic cursor to character cursor  - Cursor !  the other way
	upperlimit=pos.y*1.6
	move 0, upperlimit*6/8
	Fill scale.x,scale.y-upperlimit*6/8, 3,5,1
	Set Fast !
	\\ calc based to height
	HalfWidth=(scale.y*.65) div 16
	def downlimit=0, White as boolean=True, fw
	DrawEmptyBoard((scale.x/2-HalfWidth*8),upperlimit, HalfWidth, 15)
	fw=HalfWidth*2-60
	\\ hold
	\\ set new game
	\\ -1 for no FEN
	def NoFEN(aGame$)=len(aGame$)<>len(filter$(aGame$,"/"))+7
	Inventory OnBoard
	Const NewGame$="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
	Def ThisGame$
	\\ CHECK IF A STRING IS IN STACK (SO THIS MAYBE A FEN NOTATION FOR A STARTING POSITION)
	if match("S") then
		For this {
			\\block for temporary definitions
			Local row$(),  i, nok, m
			Read ThisGame$
			row$()=piece$(ThisGame$, chr$(13)+chr$(10))
			\\ we drop lines by redim the array (dim also is a "dim preserve")
			while  len(row$())>1
				if row$(len(row$())-1)="" then dim row$(len(row$())-1) else exit
			end while
			if len(row$())>0  then
				m=each(row$())
				while m
					if NoFEN(array$(m)) Then nok=true: exit
				end while
			End if
			if nok then Push ThisGame$ : ThisGame$=NewGame$ : exit
			PastGames$()=row$()
			Dim PastGames$(1 to 200)
			freeSlot=len(row$())
			ThisGame$=PastGames$(freeSlot)
		}
	else
		ThisGame$=NewGame$
	End if
	
	SetBoard(ThisGame$)
	RedrawBoard(True)
	sx=scale.x
	sy=scale.y-downlimit
	move 0,downlimit
	fill  sx,sy, 5
	Layer {
		font "Verdanal"
		mode thismode, sx,sy
		motion center
		motion, downlimit
		Cls 5,0
		Pen 14
	}
	Refresh 60
	flush
	move$=""
	refresh
	\\ ctrl+F1 help
	About  ! "How to play", 14000,9000,{Give one or more moves in one input line.
		Each move has a letter a number a letter and  final a number
		so:
					e2e4   or  e2-e4  or e2..e4
					(symbols other than aebcdefgh and 123456789 are white space)
		move something from e2 to e4, but this
					e2e3e7e5
		give two moves (so we can paste a number of moves)
		before a move a new FEN string compiled and copied to clipboard.
		if nothing exist in e2 then we get a beep sound. If a move break a rule then no move happen and we get a beep. If King have a threat then we have to do a proper move to eliminate threat otherwise we get a beep.
		We can press enter without giving a move, so we asked for ending the game or not.
		If we press Y then a new input start to get a FEN board notation, so we can use ctrl+V to paste the string and pressing enter we get the new boad.
		* Castling work automatic. So if rules are ok wen can give a e1c1 for queen side castling for white king.
		* En passant works fine
		* A pawn at last rank turn to Queen
		You can call this module passing a FEN string as parameter.
		George Karras
		}
	Thread {
		if control$<>"MAIN" then continue
		mmb=mouse
		If mmb=0 then continue
		mmy=mouse.y : mmx=mouse.x
		if mmy>downlimit  then
			if  mmx<scale.x*.8 then
				if mmb=2  then Field New 99 : Input End
			else
				if mmb=1 then Input End
			end if
		else.if mmy<downlimit  and mmy>upperlimit then
			Field New if(mmy>((downlimit+upperlimit)/2)->1,-1)
			Input End
		end if
		
	} as Handler interval 100
	Thread Handler Hold
	Thread {
		if control$<>"MAIN" then continue
	
		if getone then
		move lx, ly
		Refresh 100
		sprite sprite$
		mx=mouse.x : my=mouse.y :mmb=mouse
		sb=each(BoardSq())
		
		St=(,)
		While sb
		sa=array(sb)
		if sa#val(3)-twipsX<=mx and sa#val(5)+twipsX>=mx and sa#val(4)-twipsY<=my and sa#val(6)+twipsY>=my then St=sa : exit
		End While
		if len(st)>0 then
			si=st#val(10) : sj=st#val(11)
			if mmb=0 then
				keyboard chr$(ip+96)+chr$(jp+48)+chr$(si+96)+chr$(sj+48)+chr$(13)
				getone=false:  refresh 100 : mouse.icon show
			else
				lx=mx : ly=my
				move lx, ly
				if st#val$(8)=" " or  (si=ip and sj=jp) then
					sprite fig$, tr
				else
					sprite fig$, tr,-10,,80
				end if
				refresh 100
			end if
		else.if mmb=0 then
			RedrawBoard(?)
			getone=false
			mouse.icon show
			Thread Sp restart
		end if
		if not getone  then Thread this hold
	} as pSp interval 1000/30
	Thread pSp hold
	Thread {
		if control$<>"MAIN" then continue
		if mouse=0 and movelogic then movelogic=false 
		if mouse.y<upperlimit then mouse.icon 15 else mouse.icon 1
		
		if not movelogic then if mouse.y<upperlimit and mouse=1 then  movelogic=true: mvx=mousea.x : mvy=mousea.y:continue
		if movelogic then if  mouse=1 then motion  motion.wx- mvx+mousea.x, motion.wy-mvy+mousea.y : continue
		
		mx=mouse.x : my=mouse.y
		if mouse=1 and my>downlimit then input end : Thread this hold
		if mouse=1 and not getone then{
		move mx, my
		if point=0 or point=#FFFFFF else exit
		sb=each(OnBoard)
		
		St=(,)
		While sb
		sa=eval(sb)
		if sa#val(3)<mx and sa#val(5)>mx and sa#val(4)<my and sa#val(6)>my then St=sa : exit
		End While
		if len(st)=0 then exit
		move st#val(3)+30, st#val(4)+30
		refresh 1000
		tr=point
		copy fw,fw to fig$
		Image fig$ to fig$,120,120
		fill fw,fw, tr
		move mx, my
		lx=mx:ly=my
		ip=st#val(10):jp=st#val(11)
		sprite fig$, tr
		mouse.icon hide
		getone=true
		Thread pSp restart
		Thread this hold
		}
	} as Sp interval 100
	mouse.icon show
	isok=true
	{
	
		{
			if white then		
				CheckThreat(white, White_♔_file, White_♔_rank, &threat)
			else
				CheckThreat(white, Black_♚_file, Black_♚_rank, &threat)
			end if
			if isok  then
				freeSlot++
				GetBoard(&Clip$)
				if freeSlot>Len(PastGames$()) then Dim PastGame$(1 to 2*Len(PastGames$()))
				PastGames$(freeSlot)=Clip$
			end if
			\\\test
			condition$=if$(White->"White move", "Black move") + if$(threat->" (check)","")+ if$(Halfmove_clock>50->"(You can draw)","")+":"
			Layer {
				Print Part $(4,5), right$(string$(chrcode$(8199), 3)+str$(Fullmove_number,""),3)+".", $(7,12),condition$,
			}
			if blackComputer then
				if not White then 	mymove$=@GetMove$(PastGames$(freeSlot)): keyboard left$(mymove$,4)+chr$(13)
			end if		
			White~
			if empty then
				Layer {
					Pen 15 {Input "",move$;}
				}
				\\\test !			
				Thread Sp hold
				Thread pSp Hold
				mouse.icon 1
				getone=false
				if move$="" then
					
					Layer {
						wait 100
						Refresh 60
						profiler
						Every 1000/60 {
							if timecount>flashtime then
								profiler
								Cls
								Pen C {Double : Report 2,"End this Game ?" : Normal}
								C=20-C
								Cursor width, Height
								Move !   \\ copy character cursor to graphic cursor
								Legend "Use Y or Left Mouse Click  to exit | Right Mouse Click or N to continue", FontName$, Mode*.7, 0,1, 1,twipsX
							end if
							k$=""
							if keypress(0x1B) then k$="Y":exit
							if keypress(0x4E) then exit
							if keypress(0x59) then  k$="Y":exit
							if keypress(1) then k$="Y": exit
							if keypress(2) then exit
							
						}
					}
					while not inkey$ ="" {Wait 1}  'drop key any
					If k$="Y" else
						\\ if stack has something then RedrawBoard mey use it (because read for optional variable)
						\\ we can be sure we set the optional value using ?
						White~ :RedrawBoard(?): Layer {Cls}
						getone=false
						Thread Sp restart
						flush ' make empty true (so stack is empty for sure)
						loop  ' set a flag for restart at end bracket of current block
					end if
				else
					move$=lcase$(move$)
					while len(move$)>0
						select case left$(move$,1)
						case "1" to "8"
							data asc(move$)-48
						case "a" to "h"
							data asc(move$)-96
						end select
						insert 1,1 move$=""
					end while
				end if
				isok=false
			end if
			if not empty then
				if stack.size mod 4 = 0 then
					try ok {
						MakeAmove(&isok)
						if not isok then flush : White~: exit
						if not empty then
						white~: refresh : wait 500 : loop
						end if
					}
					Layer {Print}
					getone=false
					if isok else RedrawBoard(?)
					
					if ok then loop : Thread Sp restart
				else
				
					flush : White~ : loop  : Thread Sp restart' loop processed at the end of the block, so only a flag raised here
				end if
			end if
			
		}
		Thread Sp Hold
		Thread pSp Hold
		cur=freeSlot
		Clip$=PastGames$(cur)
		Layer {
			if cur=0 then cur=1
			if cur>freeSlot then cur=freeSlot 
			if  Clip$<>PastGames$(cur) then
			Clip$=PastGames$(cur)
			if len(Clip$)=len(filter$(Clip$,"/"))+7  and  trim$(Clip$)<>"" then Back {SetBoard(Clip$) :RedrawBoard(?)}
			end if
			Refresh  60
			Cls
			Cursor width, Height
			Move !
			Legend "Right Mouse Click or Esc to Quit | Left Mouse Click right of the FEN to continue play | About Ctrl+F1", FontName$, Mode*.7, 0,1, 1,twipsX
			Cursor 0,0
			Report 2, "Replay the Game,(arrows u/d) or Start a new one setting a new FEN"
			Print Part $(7,7), "Board FEN: "
			Field New 13
			Thread Handler Restart
			Pen 15 {Input ! Clip$, width-7 len=100}
			Thread Handler Hold
			Report Clip$
			refresh 60
			if field=13 then exit
			if field=-1then cur-- : loop
			if field=99 then Clip$="": exit
			if field=1 then cur++ : loop
		}
		if len(Clip$)<>len(filter$(Clip$,"/"))+7  or  trim$(Clip$)="" then SaveGame():Layer {Cls} : exit
		if Clip$<>PastGames$(cur) then
			SaveGame()
			PastGames$(1)=Clip$:cur=1
		end if
		freeSlot=cur
		SetBoard(Clip$)
		RedrawBoard(?)
		Layer {Cls}
		Thread Sp restart
		Loop
	}
	Cls 0,0	
}
hide
threads erase
declare Engine nothing
wait 200
about ""
if module(info) then keyboard "info"+chr$(13)
Flush
set switches "-inp"
escape off
Window 12, window
form
form ;
About ! ""
end
Sub SaveGame()
if freeSlot=1 then exit sub
Local Out$
Document Out$     ' upgrade to Document
layer {
	Cls
	if ask("Copy the game to clipboard?","Finish","*Yes","No")=1  then
		Report "Wait..."
		for i=1 to freeSlot
			Out$+=PastGames$(i)
			if i<freeSlot then
			Out$={
			}
			end if
		next
		Clipboard Out$
		Save.Doc Out$, "LastGame.chess"
		Report "Done..."
		wait 300
	end if	
}
end sub
Sub SaveGame1()
local Out$, i
Document Out$  ' upgrate to document
layer {
}
End Sub
Sub DrawEmptyBoard(leftmargin, topmargin, squarewidth, labelcolor)
	Local a=true, z=bold : bold 0
	Local l=squarewidth, k=2*l, k1=k*.85, N1=6, N=6, M=4, B=k*8, B1
	Local d=0, im=0, jm=0
	Repeat
	N=N1
	N1+=.25
	Until K1<size.Y("A",chessfont$, N1)
	topmargin-=l
	leftmargin-=l
	move leftmargin+l,topmargin+l
	B1=(l div 300)*twipsX
	step -B1,-B1
	B+=B1*2
	Pen 0 {
	Width b1 div 2+1 {
		color color1 , 1{Polygon 0, B, 0, 0, B, -B, 0, 0, -B}
	}
	M=N*.65
	For i=1 to 9
		d=leftmargin
		move d, topmargin
		if i<9 then
			step 0, k
			Pen labelcolor{Legend str$(9-i,""), chessfont$, M,0,2}
			step 0, -k
			else
			N=M
		end if
		for j=1 to 8
			If i<9 then
				step l, l
				color  color1,1 {fill k,k, if(a->color1,color2)}
				step  -l, -l
				BoardSq(j, 9-i)=(N, pos.x, pos.y, pos.x-l+twipsX, pos.y-l+twipsX, pos.x+l-twipsX, pos.y+l-twipsX, k-twipsX*2, " ", a, j,9-i)
				a~
			else
				step k, k
				pen labelcolor {
					Legend mid$("abcdefgh",j,1), chessfont$, N, 0, 2
				}
			end If
			d+=k
			move d, topmargin
		next
		a~ : topmargin+=k
	next
	}
	bold z
	downlimit=topmargin+500
end sub
Sub MakeAmove( &ok, i, j, i1, j1)
Local z=bold, p$, p1$ : bold 0
Local t,t1, N=BoardSq(1,1)#val(0), again as boolean, playroke as boolean
ok=false
Local rule=true, threat as boolean
refresh 10000
Pen 0 {
	again=false
	t=BoardSq(i,j)
	t1=BoardSq(i1, j1)
	p$=t#val$(8)
	p1$=t1#val$(8)
	if p$=" " then NothingToMove : exit
	if t is t1 then NothingToMove : exit
	if p1$<>" " then if p1$<"♚" and p$<"♚" then Proper : exit
	if p1$<>" " then if p1$>="♚" and p$>="♚" then Proper : exit
	\\ white change logic here
	if not white and instr(WhiteDisp$, p$)=0 then Proper : exit
	if white and instr(BlackDisp$, p$)=0 then Proper :exit
	select case p$
	case "♔"
	{
		If not White_♔_no_roke  then
			CheckThreat(not white, White_♔_file, White_♔_rank, &threat)
			if not threat then
				if i1=3 and j1=1  then
					if p1$=" " and BoardSq(2,1)#val$(8)=" " and  BoardSq(4,1)#val$(8)=" " and not White_no_left_roke then
						CheckThreat(not white, 4, 1, &threat)
						if not threat then push 1, 4, 1, 1 : again=true : playroke=true
					end if
				else.if i1=7 and j1=1 then
					if p1$=" " and BoardSq(6,1)#val$(8)=" " and not White_no_right_roke then
						CheckThreat(not white, 6, 1, &threat)
						if not threat then push 1, 6, 1, 8 : again=true :  playroke=true
					end if
				end if
			end if
		end if
		if not playroke Then
			if abs(i-i1)>1 then rule=false: exit
			if abs(j-j1)>1 then rule=false: exit
			White_♔_no_roke=true
			White_no_right_roke=True
			White_no_left_roke=true
		end if
		CheckKing()
		if threat then
			rule=false
			if playroke then drop 4
		else
			White_♔_rank=j1
			White_♔_file=i1
		end if
	}
	case "♚"
	{
		If not Black_♚_no_roke  then
			CheckThreat(not white, Black_♚_file, Black_♚_rank, &threat)
			if not threat then
				if i1=3 and j1=8 then
					if p1$=" " and BoardSq(2,8)#val$(8)=" " and  BoardSq(4,8)#val$(8)=" " and not Black_no_left_roke then
						CheckThreat(not white, 4, 8, &threat)
						if not threat then push 8, 4, 8, 1 : again=true : playroke=true
					end if
				else.if i1=7 and j1=8 then
					if p1$=" " and BoardSq(6,8)#val$(8)=" " and not Black_no_right_roke then
						CheckThreat(not white, 6, 8, &threat)
						if not threat then push 8, 6, 8, 8 : again=true :  playroke=true
					end if
				end if
			end if
		end if
		if not playroke Then
			if abs(i-i1)>1 then rule=false: exit
			if abs(j-j1)>1 then rule=false: exit
			Black_♚_no_roke=true
			Black_no_right_roke=true
			Black_no_left_roke=true
		end if
		CheckKing()
		if threat then
			rule=false
			if playroke then drop 4
		else
			Black_♚_rank=j1
			Black_♚_file=i1
		end if
		}
	case "♕","♛"
	{
		if i1<>i and j1<>j then
			if abs(i1-i)<>abs(j1-j) then rule=false: exit
			jm=0
			if abs(i1-i)>1 then
				jm=j+sgn(j1-j)
				for im=i+sgn(i1-i) to i1-sgn(i1-i)
				if BoardSq(im,jm)#val$(8)<>" "  then jm=-1: exit for
				jm+=sgn(j1-j)
			next
			end if
		else
		jm=0:im=0
		if abs(i1-i)>1 then
			for im=i+sgn(i1-i) to i1-sgn(i1-i) 
				if BoardSq(im,j)#val$(8)<>" " then jm=-1: exit for
			next
		else.if abs(j1-j)>1 then
			for jm=j+sgn(j1-j) to j1-sgn(j1-j) 
				if BoardSq(i,jm)#val$(8)<>" " then im=-1 :exit for
			next
		end if
		if im=-1 or jm=-1 then rule=false:exit
		end if
		CheckIt()
	}
	case "♜"
	{
		If playroke then Black_no_right_roke=true : Black_no_left_roke=true : Black_♚_no_roke=True : exit
		if i1<>i and j1<>j then rule=false: exit
		jm=0:im=0
		if abs(i1-i)>1 then
			for im=i+sgn(i1-i) to i1-sgn(i1-i) 
				if BoardSq(im,j)#val$(8)<>" " then jm=-1: exit for
			next
		else.if abs(j1-j)>1 then
			for jm=j+sgn(j1-j) to j1-sgn(j1-j) 
				if BoardSq(i,jm)#val$(8)<>" " then im=-1 :exit for
			next
		end if
		if im=-1 or jm=-1 then rule=false:exit
		CheckIt()
		if not rule then exit
		if i=1 and j=8 then Black_no_left_roke=true
		if i=8 and j=8 then Black_no_right_roke=true
	}
	case "♖"
	{
		If playroke then White_no_right_roke=true : White_no_left_roke=true : White_♔_no_roke=True : exit
		if i1<>i and j1<>j then rule=false: exit
		jm=0:im=0
		if abs(i1-i)>1 then
			for im=i+sgn(i1-i) to i1-sgn(i1-i) 
				if BoardSq(im,j)#val$(8)<>" " then jm=-1: exit for
			next
		else.if abs(j1-j)>1 then
			for jm=j+sgn(j1-j) to j1-sgn(j1-j) 
				if BoardSq(i,jm)#val$(8)<>" " then im=-1 :exit for
			next
		end if
		if im=-1 or jm=-1 then rule=false:exit
		CheckIt()
		if not rule then exit
		if i=1 and j=1 then White_no_left_roke=true
		if i=8 and j=1 then White_no_right_roke=true
	}
	case "♗","♝"
	{
		if i1=i or j1=j then rule=false: exit
		if abs(i1-i)<>abs(j1-j) then rule=false: exit
		jm=0
		if abs(i1-i)>1 then
			jm=j+sgn(j1-j)
			for im=i+sgn(i1-i) to i1-sgn(i1-i)
				if BoardSq(im,jm)#val$(8)<>" "  then jm=-1: exit for
				jm+=sgn(j1-j)
			next
		end if
		if jm=-1 then rule=false:exit
		Checkit()
      	}
	case "♘","♞"
	{
		if abs(i1-i)=abs(j1-j) then rule=false: exit
		if abs(i1-i)=0 or abs(j1-j)=0 then rule=false: exit
		if abs(i1-i)+abs(j1-j)<>3 then rule=false: exit
		Checkit()
	}
	case "♙"
	{
		if j1<=j then rule=false:exit
		if i<>i1 then if i1<i-1 or i1>i+1 then rule=false: exit
		if j>2 then if j1>j+1 then rule=false:exit
		if j=2 and j1>j+2 then rule=false:exit
		if i=i1 and p1$<>" " then rule=false:exit
		if i<>i1 and p1$=" "and not (en_passant_file=i1 and en_passant_rank=j1-1)  then rule=false:exit
		if i<>i1 and j1>j+1 then rule=false exit
		if en_passant_file=i1 and en_passant_rank=j1-1 then
			Checkit2()
		else
			Checkit()
		End if
		en_passant_file=0
		en_passant_rank=0
		if j1=8 then p$="♕" else if j1=j+2 then en_passant_file=i1:en_passant_rank=j1
	}
	case "♟"
	{
		if j1>=j then rule=false:exit
		if i<>i1 then if i1<i-1 or i1>i+1 then rule=false: exit
		if j<7 then if j1<j-1 then rule=false:exit
		if j=7 and j1<j-2 then rule=false:exit
		if i=i1 and p1$<>" " then rule=false:exit
		if i<>i1 and p1$=" " and not (en_passant_file=i1 and en_passant_rank=j1+1) then rule=false:exit
		if i<>i1 and j1<j-1 then rule=false:exit
		if en_passant_file=i1 and en_passant_rank=j1+1 then
			Checkit2()
		else
			Checkit()
		End if
		en_passant_file=0
		en_passant_rank=0
		if j1=1 then p$="♛" else if j1=j-2 then en_passant_file=i1:en_passant_rank=j1
	}
	end select
	If not rule then beep : exit
	move t#val(3), t#val(4)
	return t, 8:=" "
	delete OnBoard, i*9+j
	if t#val(9) then fill t#val(7), t#val(7),color1 else fill t#val(7), t#val(7), color2
	
	t=t1
	move t#val(3), t#val(4)
	fill t#val(7), t#val(7),15
	if p1$<>" " then
		Halfmove_clock=0
		Return OnBoard, i1*9+j1:=t
	else
		Halfmove_clock++
		Append OnBoard, i1*9+j1:=t
	end if
	return t, 8:=p$
	move t#val(1), t#val(2): Legend p$, chessfont$, N, 0, 2,0
	move t#val(3)+twipsx*2, t#val(4)+twipsy*2
	if t#val(9) then floodfill  ,,color1 else floodfill , , color2
	if again then read  i, j, i1, j1 : Restart
	if p$<>"♙" and p$<>"♟" then en_passant_file=0 : en_passant_rank=0
	if white then Fullmove_number++
	Ok=true	
}
bold z
refresh 10000
end Sub

Sub RedrawBoard(NoRefresh as boolean=False)
Local z=bold, p$ : bold 0
Local t, N=BoardSq(1,1)#val(0)
If NoRefresh Else refresh 10000
Pen 0 {
	For j=1 to 8
		For i=1 to 8
			t=BoardSq(i,j)
			move t#val(3), t#val(4)
			fill t#val(7), t#val(7),15
			p$=t#val$(8)
			
			if p$=" " else move t#val(1), t#val(2): Legend p$, chessfont$, N, 0, 2,0
			move t#val(3)+twipsx*2, t#val(4)+twipsy*2	
			if t#val(9) then floodfill  ,,color1 else floodfill , , color2
		Next
	Next
}
bold z
If NoRefresh Else refresh 60
end Sub
Sub GetBoard(&chessboard$)
chessboard$=""
local i, j,a$, spc, line$
for j=8 to 1
line$=""
for i=1 to 8
a$=BoardSq(i,j)#val$(8)
if a$<>" " then
if spc>0 then line$+=str$(spc,""): spc=0

line$+=mid$("PNBRQKpnbrqk", instr("♙♘♗♖♕♔♟♞♝♜♛♚", a$),1)
else
spc++
end if
next
if spc>0 then line$+=str$(spc,""): spc=0
if j>1 then chessboard$+=line$+"/" else chessboard$+=line$+" "
next
if white then chessboard$+="w " else chessboard$+="b "
if  White_♔_no_roke and  Black_♚_no_roke then
	chessboard$+="-"
else
	if White_no_right_roke else chessboard$+="K"
	if White_no_left_roke else chessboard$+="Q"
	if Black_no_right_roke else chessboard$+="k"
	if Black_no_left_roke else chessboard$+="q"
end if
if not en_passant_file=0 then
	chessboard$+=" "+chr$(96+en_passant_file)+chr$(48+en_passant_rank)
else
	chessboard$+=" -"
end if
chessboard$+=str$(Halfmove_clock)
chessboard$+=str$(Fullmove_number)
End Sub
Sub SetBoard(chessboard$)
	Rem https://en.wikipedia.org/wiki/Forsyth–Edwards_Notation
	Clear OnBoard
	board$=leftpart$(chessboard$," ")
	if len(filter$(board$,"K"))<>len(board$)-1 Then  Error "Problem with White King"
	if len(filter$(board$,"k"))<>len(board$)-1 Then  Error "Problem with Black King"
	status$=ltrim$(rightpart$(chessboard$," "))
	white=left$(status$,1)="w" 
	status$=ltrim$(mid$(status$,2))
	if left$(status$,1)="-" then
		White_no_right_roke=True
		White_no_left_roke=True
		White_♔_no_roke =True
		Black_no_right_roke=True
		Black_no_left_roke=True
		Black_♚_no_roke=True
		status$=ltrim$(mid$(status$,2))
	else
		local L=len(status$)
		status$=filter$(status$,"K")
		White_no_right_roke= len(status$)=L
		L=len(status$) : status$=filter$(status$,"Q")
		White_no_left_roke= len(status$)=L
		White_♔_no_roke = White_no_right_roke and White_no_left_roke
		L=len(status$) : status$=filter$(status$,"k")
		Black_no_right_roke= len(status$)=L
		L=len(status$) : status$=filter$(status$,"q")
		Black_no_left_roke= len(status$)=L
		Black_♚_no_roke=Black_no_right_roke and Black_no_left_roke
		status$=ltrim$(status$)
		
	End if
	if left$(status$,1)="-" then
		en_passant_file=0
		en_passant_rank=0
		status$=mid$(status$,2)
	else
		en_passant_file=Asc(left$(status$,1))-96
		en_passant_rank=Asc(Mid$(status$,2,1))-48
		if en_passant_rank=3 then en_passant_rank=4 else en_passant_rank=5
		status$=mid$(status$,3)
	end if
	Local m 
	Halfmove_clock=val(status$, "int", &m)
	status$=mid$(status$,m)
	Fullmove_number=max.data(val(status$, "int", &m), 1)
	nl$={
	}
	for i=1 to 6
		board$=replace$(mid$(White$,i,1),mid$(WhiteDisp$,i,1), board$)
		board$=replace$(mid$(Black$,i,1),mid$(BlackDisp$,i,1), board$)
	next
	for j=1 to 8
		board$=replace$(str$(j,""),emptydisp$(j), board$)
	next
	line$()=piece$(board$,"/")
	local t
	dim line$(1 to 8)
	For j=1 to 8: For i=1 to 8
		t=BoardSq(i,j)
		return t, 8:=mid$(line$(9-j), i, 1)
		if t#val$(8)<>" " then Append OnBoard, i*9+j:=t
		if t#val$(8)="♔" then
			White_♔_rank=j
			White_♔_file=i
			if i<>5 and j<>1 then White_♔_no_roke=True : White_no_left_roke=true : White_no_right_roke=true
		else.if t#val$(8)="♚" then
			Black_♚_rank=j
			Black_♚_file=i
			if i<>5 and j<>8 then Black_♚_no_roke=True: Black_no_left_roke=true : Black_no_right_roke=true
		end if
	next : next
end Sub
Sub CheckIt()
		return t, 8:=" "
		return t1, 8:=p$
		if not white then		
			CheckThreat(not white, White_♔_file, White_♔_rank, &threat)
		else
			CheckThreat(not white, Black_♚_file, Black_♚_rank, &threat)
		end if
		if threat then rule=false
		return t, 8:=p$
		return t1, 8:=p1$
end Sub
Sub CheckIt2()
		return t, 8:=" "
		return t1, 8:=p$
		local t2=BoardSq(en_passant_file, en_passant_rank)
		local p2$=t2#val$(8)
		return t2, 8:=" "
		if not white then		
			CheckThreat(not white, White_♔_file, White_♔_rank, &threat)
		else
			CheckThreat(not white, Black_♚_file, Black_♚_rank, &threat)
		end if
		if threat then rule=false
		return t, 8:=p$
		return t1, 8:=p1$
		if  threat then
			return t2, 6:=p2$
		else
			move t2#val(3), t2#val(4)
			if t2#val(9) then
				fill t2#val(7), t2#val(7),color1
			else
				fill t2#val(7), t2#val(7), color2
			end if
			Halfmove_clock=-1
		end if
		
end Sub
Sub CheckKing()
		return t, 8:=" "
		return t1, 8:=p$
		CheckThreat(not white, i1, j1,&threat)
		if threat then rule=false
		return t, 8:=p$
		return t1, 8:=p1$
end Sub
Sub CheckThreat(White as boolean, c, c1, &Yes)
local i=1, i1=8, j=1, j1=8, k=c, k1=c1
if white then
	local oKin$="♚",hor$="♜♛", dia$="♝♛", Kni$="♞"
else
	local oKin$="♔",hor$="♖♕", dia$="♗♕", Kni$="♘"
end if
 
' WhiteDisp$="♙♘♗♖♕♔"
' BlackDisp$="♟♞♝♜♛♚"
Yes=false
if c1<7 and white then
	if c>1 then
		if BoardSq(c-1, c1+1)#val$(8)="♟" then Yes=True :exit sub
	end if
	if c<8 then
		if BoardSq(c+1, c1+1)#val$(8)="♟" then Yes=True :exit sub
	end If
else.if c1>1 and not white then
	if c>1 then
		if BoardSq(c-1, c1-1)#val$(8)="♙" then Yes=True :exit sub
	end if
	if c<8 then
		if BoardSq(c+1, c1-1)#val$(8)="♙" then Yes=True :exit sub
	end If
end if
for k=max.data(c-1, 1) to min.data(c+1, 8)
for k1=max.data(c1-1, 1) to min.data(c1+1, 8)
if k1=c1 and k=c else if BoardSq(k, k1)#val$(8) =oKin$ then Yes=True : Exit Sub
next
next
for k=c to i
	if Instr(hor$,BoardSq(k,c1)#val$(8))>0 then Yes=True :exit sub
	if k<>c then if Instr(disp$,BoardSq(k,c1)#val$(8))>0 then exit for
next
if c>1 and c1<8 then {
k1=c1+1
for k=c-1 to i   \\  look up left
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if k<>c then if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	K1++
	if k1>8 then exit for
next
}
for k=c to i1
	if Instr(hor$,BoardSq(k,c1)#val$(8))>0 then Yes=True :exit sub
	if k<>c then if Instr(disp$,BoardSq(k,c1)#val$(8))>0 then exit for
next
if c<i1 and c1>1 then {
k1=c1-1
for k=c+1 to i1   \\  look down right
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	K1--
	if k1<1 then exit for
next
}
for k1=c1 to j
	if Instr(hor$,BoardSq(c,k1)#val$(8))>0 then Yes=True :exit sub
	if k1<>c1 then if Instr(disp$,BoardSq(c,k1)#val$(8))>0 then exit for
next
if c1>j and c>1 then {
k=c-1
for k1=c1-1 to j   \\  look down left
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	k--
	if k<1 then exit for
next
}
for k1=c1 to j1
	if Instr(hor$,BoardSq(c,k1)#val$(8))>0 then Yes=True :exit sub
	if k1<>c1 then if Instr(disp$,BoardSq(c,k1)#val$(8))>0 then exit for
next
if c1<j1 and c<8 then {
k=c+1
for k1=c1+1 to j1   \\ look up right
	if Instr(Dia$,BoardSq(k,k1)#val$(8))>0 then Yes=True :exit sub
	if Instr(disp$,BoardSq(k,k1)#val$(8))>0 then exit for
	k++
	if k>8 then exit for
next
}
rem test "here"
for k=max.data(c-2,i) to min.data(c+2, i1)
	for k1=max.data(c1-2,j) to min.data(c1+2, j1)
		if Abs(k-c)+Abs(k1-c1)=3 then if BoardSq(k,k1)#val$(8)=Kni$ then Yes=True :exit sub
	next
next
end Sub
\\ new from revision 5
Function GetMove$(Fen$)
	local aLine$
	method Engine, "SendLine" , "position fen "+Fen$
	method Engine, "SendLine" ,"go movetime"+str$(random(50, 200))
	every 50 {
		Method Engine, "ProcessLoop"
		if not Engine.Active then exit
		while  Engine.HasLine
			method Engine, "GetLine" as aLine$
			if left$(aLine$,8)="bestmove" then exit
                     End While
		if left$(aLine$,8)="bestmove" then =piece$(aLine$," ", 2) : exit
	}		
End Function
initengine:
declare Engine SHELLPIPE
with Engine, "Active" as Engine.Active, "Hasline" as Engine.HasLine
Method Engine, "Run",  enginepath$ as OkEngine
if OkEngine=0 then  Method Engine, "SendLine", "ucinewgame"
Return
}
MODULE URLNEW {Stack New {
      Data "foo://example.com:8042/over/there?name=ferret#nose",  "urn:example:animal:ferret:nose" 
      Data "jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true",   "ftp://ftp.is.co.za/rfc/rfc1808.txt"
      Data "http://www.ietf.org/rfc/rfc2396.txt#header1",   "ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two"
      Data "mailto:John.Doe@example.com",   "news:comp.infosystems.www.servers.unix",   "tel:+1-816-555-1212"
      Data "telnet://192.0.2.16:80/",   "urn:oasis:names:specification:docbook:dtd:xml:4.1.2",  "ssh://alice@example.com"
      Data "https://bob:pass@example.com/place",   "http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64"
      data "ftp://username:password@hostname/"
      data "https://georgekarras.blogspot.com"
      a=Array([])
}
function prechar$(a$, b$) {
      if a$<>"" then {=quote$(b$+a$)} else ={""}
}
z=each(a)
document s$="["+{
}
While z {
      a$=array$(z)
      s1$={           "uri": }+quote$(a$)+{,
            "authority": }+ quote$(string$(a$ as URLAuthority))+{,
            "userInfo": }+ quote$(string$(a$ as URLUserInfo))+{,
            "username": }+ quote$(string$(a$ as URLpart 3))+{,
            "password": }+ quote$(string$(a$ as URLpart 4))+{,
            "scheme": }+quote$(string$(a$ as URLScheme))+{,
            "hostname": }+quote$(string$(a$ as UrlHost))+{,
            "Port": }+quote$(string$(a$ as UrlPort))+{,
            "pathname": }+quote$(string$(a$ as UrlPath))+{,
            "search": }+prechar$(string$(a$ as URLpart 6),"?")+{,
            "hash": }+prechar$(string$(a$ as UrlFragment),"#")+{
      } 
      s$="     {"+{
      }+s1$+"     }"
      if  z^<len(a)-1 then s$=" ,"   ' append to document
      s$={
      }
}
s$="]"
Report s$
}
MODULE COMBO1 {\\ module Au is like this with less controls

about call {
      select case about$ 
      case "is a big name here"
            about "Title: is a big name here", 8000,6000,"that [is a big name here] easy [too]"
      else
            about "Title: too", 8000,6000,"that [is a big name here] easy"+about$
      end select
}

declare form1 form
With form1, "Width" as form1.Width, "Height" as form1.Height
layer Form1 {
      window 12, 8000,6000;
      cls #202020
      max_x=scale.x
}

declare combo1 combobox form form1
declare text1 textbox form form1
declare but1 button form form1
With form1,"Title" as title$, "Sizable", True, "UseReverse", True
Method form1, "MakeStandardInfo", 1

With combo1,"Edit", True,"UseOnlyTheList", false,"autocomplete", True, "listIndex" as ListIndex,"ShowAlways", True
With combo1,"label","Combo1", "ListText" as item$, "list" as list$(), "text" as combo1$, "icon", 3
item$={alfa
            delta
            gamma
            beta
            }
With combo1,"Find" as Find()
Method combo1,"Sort"
combo1$=list$(find("gam*"))

Method combo1,"Move", 1000,1000,6000,600
Method text1, "Move", 1000,1900,6000,600
Method but1, "Move", 1000, 2800, 6000, 600
With But1, "Blink" as but1.blink, "caption" as but1.caption$
but1.caption$="press to stop"
but1.blink=300
With text1, "left" as left, "text" as text1.text$ , "ShowAlways", True , "Default", true,"icon", 3
Print left
Method form1, "show"

\\ we use mono for part structure. when a part executed the mono change to true,
\\ so no other part with same variable can executed
def boolean mono, allow=true
Function but1.Blink {
      Read New face
      if allow<>0 and face then
      part {
            print face, if$(internet$<>"127.0.0.1"->"connected to internet","not connection found")
            refresh
      } as mono
      end if
      If Face then {
            Method but1,"Colors", 15,2
      } else Method but1,"Colors", 14,7
      Method but1,"TransparentOff"
}
Function but1.click {
      part {
            if allow then but1.caption$="ok" :allow=false
            Print "click: Your ip=";lan$, "Your public ip=" ;internet$
            but1.blink=0
            refresh
      } as mono
}
function form1.resize {
      layer form1 {
          if form1.width<max_x then form1.width=max_x
          if form1.height<4000 then form1.height=4000
          move form1.Width, form1.Height  
          cls
          local oldi=italic
          italic 1
          Legend "Use Ctrl+F1 in textboxes","Courier",8,0,1
          italic oldi
    }
}
Call Local form1.resize()
function form1.unload {
      about
      Keyboard "!"
      show
}
function combo1.about {
      about show "is a big name here"
}
function text1.about {
      about show ""
}
Function combo1.dblclick {
      text1.text$=combo1$
      title$=combo1$
      if find(title$)= -1 then {
            Method combo1,"additem",title$ 
            Method combo1,"Sort"
            listindex=find(title$)
      }
      combo1$=combo1$
      Method text1,"GetFocus"
}
Function combo1.click {
      if listindex>=0 then  text1.text$=list$(listindex)
}
Function combo1.scroll {
      if listindex>=0 then  text1.text$=list$(listindex) 
}
\\ just wait for a key in console
a$=key$

declare Text1 nothing
declare combo1 nothing
declare form1 nothing
}
MODULE PROF {cls
Rem
 Set Fast!
Rem Set fast
Rem Set Slow
Report {From Version 9.9 rev 1
		Profiler	reset the current profiler (if a local exist then reset the local one)
		Profiler !	if not local profiler exist then one created else Reset the profiler
		timecount	value return from local profiler if exist, or from global
	
		For this example we use global profiler in this module and in glo() function
		Modules and functions may have local profilers if we create one using Profiler !
		Only one local profiler for each module and function.
	}
Report "First Example: Accessing both local and global profiler"
module alfa {
	def glo()=timecount
	profiler !
	for i=1 to 1000
	next
	print timecount,"", glo()
}

profiler
for i=1 to 10
alfa
next
Print @(tab(3)), timecount, "/total"
Report "Second Example: using only global profiler"
Profiler
Function Deep(N) {
	if N>1 then =Deep(N-1)
	For i=1 to 100
	Next i
	Print N, "", timecount
}
N=Deep(10)
Print @(tab(2)), timecount, "/total"
Report "Third example: using local profiler"
Function Deep(N) {
	if N>1 then =Deep(N-1)
	Profiler !
	For i=1 to 100
	Next i
	Print N, "", timecount
}
Profiler
N=Deep(10)
Print @(tab(2)), timecount, "/total"
Set Fast
}
MODULE BASIC {
\\ this is a style like BASIC
\\ we use line numbers
\\ we have two types of subroutines
\\ the sinple routine (Gosub/Return)
\\ the SUB/END SUB  (GOSUB is optional for the call)
\\ we use FOR as in BASIC SO IF A < 1 we SKIP THE FOR LOOP
\\ we use arrrays like in VB, so we get plus one ITEM (here 11 items fro 0 to 10)
\\ the gosub 200 enable these features
\\ the gosub 210 disable these features


000 GOSUB 200
010 
020 REM 
030 FORM ! 80,48
040 CONST MAX=64%   ' % for Integer
050 DEF INTEGER A1, I  :  DEF Z$
060 DIM P(MAX)
070 PRINT $(0,20)   ' SET WIDTH TO 20
080 INPUT "Give a value for variable A (try 64)=", A1
090 GOSUB ALFA(&A1)
100 IF A1<=1 THEN 170 ELSE PRINT "We have ";A1;"items with these types:"
110 PRINT $(0,10)
120 WHILE A1>0
130 PRINT FORMAT$("({0}) : {1}", A1, TYPE$(P(A1))),
140 A1-- 
150 END WHILE
160 PRINT
170 GOSUB 220
180 END


200 SET SWITCHES "+FOR +DIM"
210 RETURN
220 SET SWITCHES "-FOR -DIM"
230 RETURN


300 SUB ALFA(&A AS Integer)
310 P(0)=1~   ' we use ~ for float constant values
320 FOR I=1 TO A
330 IF I>MAX THEN A=I : EXIT
340 P(I)=P(I-1)*I
350 IF I<10 THEN F$=STR$(P(I),"") ELSE F$=STR$(P(I),"#.######E+###")
360 PRINT @(TAB((I-1) MOD 4)), "P(";STR$(I,"00");")=";F$;
370 IF (I-1) MOD 4=3 THEN PRINT
380 NEXT I
390 PRINT
400 END SUB
}
MODULE REPORTTEST {
\\ USE SHIFT TAB AT START OF PARAGRAPH TO ADD SPACES
Global B$={      Tokyo (CNN)Typhoon Hagibis weakened to a tropical depression as it continued to move across central Japan on Sunday, leaving at least 15 people dead and more than 140 injured in its wake.
      The storm made landfall just before 7 p.m. Saturday local time on the Izu Peninsula, southwest of Tokyo, bringing hurricane-force winds and heavy rains which led to widespread flooding. More than 230,000 people were evacuated ahead of the storm, with emergency orders issued for many cities around the greater Tokyo area.
      Along with the 15 deaths, Japan's Fire Disaster and Management Agency said about 140 people had been injured and nine remain missing.
      Prime Minister Shinzo Abe offered his "condolences for the people killed in the disaster and my sincere sympathy for the people affected by this disaster."
      "Now not only police, fire department and coast guard, but also 27,000 staff of the self-defense force are on rescue, search for missing and supporting evacuation," Abe said Sunday. "We are to enhance the scale of operation depending on necessity."
      Typhoon Hagibis came as the country hosts the Rugby World Cup. Two matches -- England-France and New Zealand-Italy -- had to be preemptively canceled. Sunday's Pool B match between Namibia and Canada in Kamaishi was also canceled hours before it was due to take place.
      Original:https://edition.cnn.com/2019/10/13/asia/typhoon-hagibis-japan-rugby-intl-hnk/index.html
}
Module Check {
	READ A, k
	Print @(0,5);" 199";@(pos,row,k+pos,10+row, 5, 8);
	Report 0, B$, k, 10  Line a
	Print @(23,5);" 200";@(pos,row,k+pos,10+row, 5, 8);
	Report 2, B$, k, 10  Line a+1
	Print @(0,17);" 201";@(pos,row,k+pos,10+row, 5, 8);
	Report 1, B$, k, 10  Line a
	Print @(23,17);" 202";@(pos,row,k+pos,10+row, 5, 8);
	Report 3, B$, k, 10  Line a+1
	Print
	Refresh 5000	
}
\\ set tab width
Report ! 4
KK=80
Repeat {
Refresh 5000
form KK, 32
g=20 : d=2
\\ Blocks {} handle Goto jumps
Repeat {
	Cls 5, 0
	Pen 14
	Double
	Pen 15 {Report 2, "Example of Report statement"}
	Normal
	OldItalic=Italic
	Italic 1
	Cursor 0,1
	Pen 7 {
		Report {
			Press space to Exit
			Press M to stop - press any key again to start
			Press any other key to change mode (font size)
		}
	}
	Italic OldItalic
	For f=2 to 5{
		check  f, g
		Wait 4
		If Keypress(32) Then Goto ExitLoop		
		M$=Inkey$
		If M$<>"" Then {
			If Ucase$(M$)="M" Then M$=Key$ Else Goto ContHere
		}
	}
	For f=4 to 1 {
		Check  f, g
		Wait 4
		If Keypress(32) Then Goto ExitLoop
		M$=Inkey$
		If M$<>"" Then {
			If Ucase$(M$)="M" Then M$=Key$ Else Goto ContHere
		}
	}
	g=g-d
	If g<=3 Then d=-d
	If g>18 Then d=-d
} Always
ContHere:
KK=KK-5
} Until KK<50
ExitLoop:
}
MODULE TEXTONLY {Declare Form1 Form
Layer Form1 { Cls 7
	Move scale.x/2, scale.y/2
	Pen 14 { Circle Fill 14, 100, 0.5}
	w=scale.x
 }
Declare Edit1 EditBox Form Form1
Declare Text1 TextBox Form Form1
Method Edit1, "move",1000,1000,w-2000,2000
Method Text1, "move",1000,3600,w-2000,600
With Edit1, "Text",{Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum
TextBox Handle:
Use ctrl + left or right arrow, for moving fast skipping words and spaces. You can paste text with Ctrl+V, but without merging, the old text replaced with the new one. You can't get a copy.
}, "ScrollKeyUpDown", True
With Text1, "MaxCharLength", 100
Method Edit1,"TextViewOnly"
Method Edit1, "Transparent"
Method Edit1, "Colors", 15, 15
Method Text1, "Transparent"
Method Text1, "Colors", 15,15
m=1 : s=1
Function Form1.Unload {
	read new &ok
	If mm<>0 then thread mm erase : mm=0:ok=true     
}
Layer Form1 {
	gradient 7,0
	hold
	Thread {
		{
			Release
			Pen 0 { Circle Fill 0, m*100, 0.5}
			m+=s
			If m>=60 then
				pen random(1,4)
				s-!
			Else.If m<2 then
				s-!
				pen random(1,4)
			End If
			\\		refresh 5000
			method Form1, "RefreshAll"
		}
	} as mm interval 1000/24
}
With Form1, "TitleBarColor",#aaaa88, "TitleTextColor",14, "TitleIconColor",#eeeeee
Method Form1, "TransparentTitle"
Method Form1, "Show", 1
Threads Erase
Declare Form1 Nothing
}
MODULE PRMASTER {let col=8, flip=True, oldbold=Bold
Bold 0
Refresh 1000
Form ! (100 div col)*col,32
Cls 5
Pen 14
For i=0 To Width-1 Step col {
      If flip Then {
            Print @(i,0,i+col,Height,#222222,3),
      } Else Print @(i,0,i+col,Height,5,3),
      flip~
}
  
For i=2 To Height-2
      Cursor 0, i
      Pen 2 { Print Under }
Next i
Print @(0,2),   \\ same as Cursor 0,2
For i=0 To 9 {
      Print $(i, col),145355,34.23432,34.222, ~(10,2, 2-12*(i=8)), "aaa",~(14),"bb"
      Print 145355,"A So Real Big String",34.222, "Small", 10, i
      Print $(0), 
}
Print $(";True;False;"), 0,-1, True, False, "A">" ", "*"
Print $(""), True, "*Ok"
Print Part @(Tab*2), $(6,col*2),~(10,2),"Double Column",$(4,col), ~(14), 1000
Pen 2 { Print Under }
Print Part @(Tab*2), $(6,col*3),~(10,2),"Triple Column",$(4,col),~(14), "ok"
For i=0 To 1 {
      Cursor 0,i : Print Over ~(14,7,7),
}
Cursor 0,0
Double : Bold 1
Pen 15 { Report 2, "Example with Print & Report Statements"}
Pen 2 { Print Under }
Normal : Bold
Print @(Tab(8),15, Tab(11),26,#222222, 2),
Print @(Tab(8),4, Tab(11),14,#222222, 2),
Document$={	Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.
	Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.
	Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?
	Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?
  }
Pen 7 {
      Report Document$, Tab*3, 10
      Cursor Tab(8), 16
      Report Document$, Tab*3, 14 Line 12
}
Pen 13 {
      Cursor Tab(8), 15
      Report Document$, Tab*3, 1 Line 11
     }
Cursor 0,Height-2
Bold OldBold
  k$=key$
  
}
MODULE BREAKPOINT {Test "start", test("ok"), A
For A=1 to 100 {
      Wait 1
      Print A
      if A=41 then test "ok" : test test("ok2")
      if A=81 then test "ok2": test  \\ wait for keypress
}
Test !
}
MODULE RTL {form ! 36,24
Print "Right to left display"
Double
Print "ברוכים הבאים الجامعات والكليات", "ok"
Print "ok", "ok", "ok","ok"
Normal
Report 1, "ברוכים הבאים الجامعات والكليات"
Report 2, "ברוכים הבאים الجامعات والكليات"
Report 3, "ברוכים הבאים الجامعات والكليات"
Report 2, "Word Wrap"
r=row
Cursor 4, r
Report "ברוכים הבאים الجامعات والكليات", 8
Cursor 16, r
Report 2, "ברוכים הבאים الجامعات والكليات" , 4
Cursor 22, r
Report 1, "ברוכים הבאים الجامعات والكليات" , 5
Print
}
MODULE SIMPLETXT {Παλιό.Τοπικό=Τοπικό
Τοπικό 1032
Όρισε Φόρμα1 Φόρμα
Όρισε Κειμ1 Κείμενο Φόρμα Φόρμα1
Όρισε Κειμ2 Κείμενο Φόρμα Φόρμα1
Όρισε Κειμ3 Κείμενο Φόρμα Φόρμα1
θεσηΧ=4000
Μέθοδος Κειμ1, "Move", θεσηΧ,1200,5000,400
Μέθοδος Κειμ2, "Move", θεσηΧ,1800,5000,400
Μέθοδος Κειμ3, "Move", θεσηΧ,2400,5000,400
νγ$={
}
Με Κειμ1, "ShowAlways", Αληθές, "NumberOnly", Αληθές, "Value" ως Τιμ1
Με Κειμ2, "ShowAlways", Αληθές, "NumberIntOnly",Αληθές, "Value" ως Τιμ2
Με Κειμ3, "ShowAlways", Αληθές, "UsedAsTextBox", Αληθές,"Text" ως Τιμ3$
Τιμ1=93.112
Τιμ2=1456
Τιμ3$="Μια γραμμή μόνο"
Συνάρτηση Κειμ1.About {
      Κάλεσε Τοπικά Φόρμα1.About()
}
Συνάρτηση Κειμ2.About {
      Κάλεσε Τοπικά Φόρμα1.About()
}
Συνάρτηση Κειμ3.About {
      Κάλεσε Τοπικά Φόρμα1.About()
}
Συνάρτηση Φόρμα1.About {
      Επίπεδο Φόρμα1 {
            Οθόνη  #606060
            Τύπωσε $(Τρόπος),"Κάνε κλικ εδώ ή πάτα Enter"
      }
}
Συνάρτηση Φόρμα1.Enter {
      Κάλεσε Τοπικά Φόρμα1.Click()
}
Συνάρτηση Φόρμα1.Click {
      Επίπεδο Φόρμα1 {
            Τιμ1=Τιμ1+1  \\ δεν δουλεύει το Τιμ1++ γιατί είναι αντικείμενο και όχι μεταβλητή
            Οθόνη  #606060
            Τύπωσε Τιμ1, Τιμ2, " Ctrl+F1"
            Τύπωσε Πάνω $(9), Τιμ3$
            Ανανέωση
            Μέθοδος Κειμ1, "Show"
      }
}
Τρόπος=4
Επίπεδο Φόρμα1 {
      Γραμματοσειρά "Arial Black"
      Παράθυρο 16, 10000,4500
      Πένα 15
      Οθόνη #202020
      Οθόνη #606060, Ύψος-2
      Θέση θεσηΧ, 1200+400
      Επιγραφή "Ετικέτα ", Γραμματοσειρά$, Τύπος, 0, 1
      Θέση θεσηΧ, 1800+400
      Επιγραφή "Άλλη ετικέτα ", Γραμματοσειρά$, Τύπος, 0, 1
      Θέση θεσηΧ, 2400+400
      Επιγραφή "Και άλλη ετικέτα ", Γραμματοσειρά$, Τύπος, 0, 1
      Πένα 13
      Τύπωσε $(Τρόπος),"Κάνε κλικ εδώ ή πάτα Enter"
}
Μέθοδος Φόρμα1, "Show",1
Όρισε Κειμ1 Τίποτα
Όρισε Φόρμα1 Τίποτα
Τοπικό Παλιό.Τοπικό
}
MODULE SIMPLETXTEN {OLDLOCALE=LOCALE
LOCALE 1033
Declare Form1 Form
Declare text1 editbox Form Form1
Declare text2 editbox Form Form1
Declare text3 editbox Form Form1
PositionX=4000
Method text1, "Move", PositionX,1200,5000,400
Method text2, "Move", PositionX,1800,5000,400
Method text3, "Move", PositionX,2400,5000,400
nl$={
}

With text1, "ShowAlways", True, "NumberOnly", True, "Value" As Value1
With text2, "ShowAlways", True, "NumberIntOnly", True, "Value" As Value2, "Text" As Value2$
With text3, "ShowAlways", True, "UsedAsTextBox", True,"Text" As Value3$
Value1=93.112
Value2=1456
Value3$="One line only"
Function text1.About {
      Call Local Form1.About()
}
Function text2.About {
      Call Local Form1.About()
}
Function text3.About {
      Call Local Form1.About()
}
Function Form1.About {
      Layer Form1 {
            Cls  #606060
            Print $(Way),"Press right mouse button or Enter"
      }
}
Function Form1.Enter {
      Call Local Form1.Click()
}
Function Form1.Click {
      Layer Form1 {
            Value1=Value1+1  \\  Value1++ not work becaue Value1 is an object (linked property)
            Cls  #606060
rem            Print Part $(0), Value1, Value2 , " Ctrl+F1"
rem            Print
            Print format$(" {0:3:} | {1} | Ctrl+F1", Value1, Value2)
            Print Over $(9), Value3$
            Refresh
            Method text1, "Show"
      }
}
Way=4
Layer Form1 {
      Font "Arial Black"
      Window 16, 10000,4500
      Pen 15
      Cls #202020
      Cls #606060, Height-2
      Move PositionX, 1200+400
      Legend "Label ", Fontname$, Mode, 0, 1
      Move PositionX, 1800+400
      Legend "Another Label ", Fontname$, Mode, 0, 1
      Move PositionX, 2400+400
      Legend "And another Label ", Fontname$, Mode, 0, 1
      Pen 13
      Print $(Way),"Press right mouse button or Enter"
}
Method Form1, "Show",1
Declare text1 Nothing
Declare Form1 Nothing
LOCALE OLDLOCALE
}
MODULE CONV2 {Module Checkit {
	k$=lambda$ (m, b as integer=16) -> {
		if b<2 or b>16 then error "base out of range"
		if m=0 then ="0" : exit
		z$="0123456789ABCDEF"	
		=lambda$ z$, b (m) ->{
			=if$(m=0->"", lambda$(m div b)+mid$(z$, m mod b + 1, 1))
		}(m)
	}
	k=lambda (m$, b as integer=16) -> {
		if b<2 or b>16 then error "base out of range"
		m$=trim$(m$)
		if m$="0" then =0 : exit
		z$="0123456789ABCDEF"	
		=lambda z$, b (m$) ->{
			=if(Len(m$)=0->0, lambda(mid$(m$,2))+(instr(z$, left$(m$,1))-1)*b**(len(m$)-1))
		}(m$)
	}
	Print k$(0)="0", k("0")=0
	Print k$(65535)="FFFF", k("FFFF", 16)=65535
	Print k$(0xF00F)="F00F", k("F00F", 16)=0xF00F
	Print k$(0xFFFFFFFF)="FFFFFFFF", k("FFFFFFFF", 16)=0xFFFFFFFF
	Print k$(100, 8)="144", k("144", 8)=100
	Print k$(100, 2)="1100100", k("1100100", 2)=100
}
Checkit
}
MODULE SIMPLETHREAD {m=100
thread {
	m--
	if m<1 then thread this erase
} as countdown interval 100

Main.Task 25 {
	Print m, "inside main task": Refresh
	if keypress(1) then exit
}
Threads ' just report
Print "ok"
}
MODULE PHILO {Module Dining_philosophers (whichplan) {
Form 80, 32
Const MayChangePick=Random(True, False)
Dim energy(1 to 5)=50
Document Doc$
Const nl$={
}
Print $(,12),  ' set column width to 12
Pen 14
Pen 15	{
	Doc$="Dining Philosophers"+nl$
	\\ we can change thread plan only if no threads defined
	if whichplan=1 then
		Doc$="Sequential threads - to execute exclusive one threads code"+nl$
		thread.plan sequential
		\\ need time_to_think>time_to_eat, but time_to_appear maybe the same for all
		time_to_think=150  ' one or more intervals
		time_to_eat=100 ' one interval to eat only	
		time_to_appear=(150,150,150,150,150)
		Return time_to_appear, random(0,3):=300
	else
		Doc$="Concurrent threads  - to execute a statement or a block of code"+nl$
		thread.plan concurrent 
		time_to_think=100  ' one or more intervals
		time_to_eat=50 ' one interval to eat only
		time_to_appear=(100,100,100,100,100)
		Return time_to_appear, random(1,4):=200	 
	end if
	Print #-2,Doc$
	Print @(0,2),"Press left mouse button to exit"
	Print Part $(1), time_to_appear
	Print under
}
Pen 13 {Print "Aristotle", "Kant", "Spinoza", "Marx", "Russell"}
enum philosopher {
	Aristotle, Kant, Spinoza, Marx, Russell
}
global enum forks {NoFork, Fork}
RoundTable =(Fork, Fork, Fork, Fork, Fork)
Getleft=lambda RoundTable (ph as philosopher) -> {
	where=(ph+4) mod 5
	= RoundTable#val(where)
	Return RoundTable, where:=NoFork
}
GetRight=lambda RoundTable (ph as philosopher) -> {
	where=ph mod 5
	=RoundTable#val(where)
	Return RoundTable, where:=NoFork
}
PlaceForks=lambda RoundTable (ph as philosopher) -> {
	Return RoundTable,  (ph+4) mod 5:=Fork,ph mod 5:=Fork 
}
PlaceAnyFork=lambda RoundTable (ph as philosopher, &ForkL, &ForkR) -> {
	If ForkL=Fork then Return RoundTable,  (ph+4) mod 5:=Fork : ForkL=NoFork
	If ForkR=Fork then  Return RoundTable, ph mod 5:=Fork : ForkR=NoFork
}
ShowTable=lambda RoundTable -> {
	m=each(RoundTable)
	while m
		print if$(array(m)=NoFork->"No Fork", "Fork"),
	end while
	Print
}
noforks=lambda RoundTable -> {
	k=0
	m=each(RoundTable)
	while m
		if array(m)=NoFork then k++
	end while
	=k=5
}
 
def critical as long, basetick
Document page$
m=each(philosopher)
while m {
	\\ we make 5 threads
	\\ a thread has module scope (except for own static variables, and stack of values)
	thread {
		if  energy(f)<1 then {
				call PlaceAnyFork(f, ForkL, ForkR)
				energy(f)=0
				Page$=format$("{0::-12} - ",tick-basetick)+eval$(f)+" - Die"+nl$
				thread this erase
		} else	{
				Page$=format$("{0::-12} - ",tick-basetick)+eval$(f)
				Page$=if$(ForkL=NoFork or ForkR=NoFork->" thinking",  " eating"+str$(eatcount))
				Page$=if$(R->"- R", " - L")+nl$
		}
		if not think then 
			{ \\ a block always run blocking all other threads
				energy(f)++
				eatcount--
				if eatcount>0 then exit
				Call PlaceForks(f) : ForkL=NoFork:ForkR=NoFork
				eatcount=random(4,8)
				if MayChangePick then R=random(-1,0)
				think=true :thread this interval  time_to_think*random(1,5)
			}
		else.if energy(f)>70 or critical>5 then
			{
				call PlaceAnyFork(f, &ForkL, &ForkR)
				if energy(f)>70  then energy(f)=60
			}
		else.if R then
				if ForkR=NoFork then ForkR=GetRight(f)
				if ForkR=Fork and ForkL=NoFork then ForkL=GetLeft(f)
				if ForkL=Fork then think=false:thread this interval  time_to_eat else energy(f)--
		else
				if ForkL=NoFork then ForkL=GetLeft(f)
				if ForkL=Fork and ForkR=NoFork then ForkR=GetRight(f)
				if ForkR=Fork then think=false:thread this interval  time_to_eat else energy(f)--
		end if
		
	} as a interval time_to_appear#val(m^)		
	\\ a is a variable which hold the number of thread (as returned from task manager)
	\\ so we can get 5 times a new number.
	\\ for each thread we make some static variables (only for each thread)
	\\ this statement execute a line of code in thread a
	thread a execute {
		\\ this executed on thread execution object
		static f=eval(m), think=true, ForkL=NoFork
		static ForkR=NoFork, eatcount=random(2,5)
		static R=-1
		if MayChangePick then  R=Random(-1,0)
	}
}
cls ,5  ' set split screen from fifth row
\\ Main.Task is a thread also. Normaly exit if no other threads running in background
\\ also serve a the wait loop for task manager (we can use Every 200 {} but isn't a thread, is a kind of a wait statement)
\\ tick return the counter from  task manager which used to triger threads
basetick=tick
\\ 4hz display results
MaxCritical=0
Main.Task 1000/4 {
	{ \\ a block always run blocking all other threads		
		cls
		Print Part $(1),$("####;\D\I\E;\D\I\E"),energy()
		Print Under
		Print "Table:"
		Call ShowTable()
		if noforks() then critical++  else critical=0
		MaxCritical=if(MaxCritical<critical->critical,MaxCritical)
		Print "noforks on table counter:";critical, "Max:";MaxCritical
		Print #-2,Page$
		Doc$=Page$
		Clear Page$
		refresh
	}
	if critical>40 or keypress(1) then exit
}
threads erase
thread.plan sequential
Clipboard Doc$
}
Dining_philosophers Random(1,2)
}
MODULE COLUMNSSORT {Form 80,40
Const max=36
\\ setup random generator to produse the same sequence
x=random(!12493587)
Rand$=Lambda$ labels=("LONDON","PARIS","BERLIN","ATHENS", "ROME","SOFIA") ->{
	= Field$(labels#val$(random(0,5)), 10)
}
PickNumber=Lambda (m)-> {
      dim A(1 to m)
      =lambda A(), m -> {
            if m<1 then exit
            i=random(1, m)
            =if(A(i)=0->i, A(i))
            A(i)=if(i<m->if(A(m)=0->m,A(m)),0)
            m--
            if m=0 then A()=(,) else Dim A(1 to m)
      }
}(max)

Flush
Dim A(1 to max, 1 to 3)
Link A() to A$()
Title("1. Populate Array")
R=0
refresh 5000
for i=1 to max
      A(i,1):= PickNumber(), Rand$(), Random(1,6)*100
      Gosub 100
next
Refresh 20
Gosub 240
Title("2. Sort Ascending First Column")
sort A(),1, max, 1,0
R=20
Gosub 200
Title("3. Sort Ascending Second, Third and First")
sort A(),1, max, 2,0,3,0,1,0
R=40
Gosub 200
Title("4. Sort Columns Third Descending, Second Ascending, First Ascending")
sort A(),1, max, 3,1,2,0,1,0
R=60
Gosub 200
keyboard "Info"+chr$(13)
End
100 Print Part  $(0), @(R),~(11),str$(A(i,1),"0000 "),@(R+5), ~(0, 7,7), $(6),A$(i,2),~(15), @(R+15),$(0), ~(14), format$("{0::4}",A(i,3)) : Print
110 Return
200 Refresh 5000
210 For i=1 to max
220       Gosub 100
230 Next : Refresh 50
240 T=True
250 Every 1000/8 {
260       T~
270       Print Over $(6),~(If(T->7,15)),"PRESS LEFT MOUSE BUTTON"
280       If keypress(1) then Exit
290 }
300 Print Over
310 Return
320 Sub Title(A$)
330       Cursor 0,0: Double
340       Print Over ~(15),A$
350       Print
360       Normal
370 End Sub

}
MODULE CRAWL {Escape Off
Hide
Window 12, window
oldwindow=window
Back {
Ybig=scale.Y
Window 18,0, 2000;
Motion.w Motion.wx , Ybig-2000
Refresh 5000

\\ For changing the decimal character use Locale (Locale 1033 for English, Locale 1032 fro Greek)
\\ Here we use Locale value in Time$()
\\ Locale is a statement and a read only value

\\ Greek and Latin statements used for message;s language
\\ Greek also is a read only variable to read the status for message's language
If Greek Then
      m$="Πάτα ένα πλήκτρο στο πληκτρολόγιο για τερματισμό - Πάτα τα πλήκτρα του ποντικιού για να αλλάξεις ταχύτητα στο μήνυμα - "
Else
      m$="Press a key on keyboard to end this - Press a key on mouse to change the crawl speed - "
End If
fn$="Arial Black"
sz=48
mw=Size.X(m$,fn$, sz)
m1=0
m2=mw
my=Scale.y/2-Size.Y("Α", fn$, sz)/2
ms=twipsX*3
t=2
Cls
Gradient 4, 12
if module(ico) then ico 0 : Read ico
Hold
Font Fn$
Pen 14
refresh 500
Every 1000/25{
D=Mouse
If Inkey$<>"" Then
      Exit
Else
      Release
      Cursor 0,0
      Print Part $(3,width), Time$(now, 1033+Greek, "hh:mm:ss tt")
      Move m1, my
      Pen 15 {
            Legend m$, fn$, sz
            If m2<scale.x Then
                  Move m2, my
                  Legend m$, fn$, sz
            End If
      }
      If D=4 Then t=2 Else.If D=1 Then t+=1 Else.If D=2 Then t-=Αν(t>2->1,0)
      m1-=ms*t
      m2-=ms*t
      If m2<0 Then m1=m2+mw: Swap m1, m2
      if module(ico) then
            Move  if(keypress(4)->mouse.x,  twipsX*5),0
            Image ico, scale.x/width*5  ' (twips/character)
      end if
      Refresh
End If
}
set fast
Cls 11
}
Window 12, oldwindow
\\Show
Escape On
keyboard "info"+chr$(13)
}
MODULE ZONES {zones=time()
m=each(zones)
Menu ' empty menu list
while m
      menu + eval$(m!)
End While
Print "choose a time zone:";
\\ now open the menu
Menu !

if menu then
      Pen 15 {Print menu$(menu)}
      Print "From UTC: ";zones(menu$(menu))
      Print "UTC time: ";time$(time("utc"),1033, "Long Time")
      Print menu$(menu);": ";time$(ctime(time("utc"), zones(menu$(menu)),0,0),1033, "Long Time")
      Print "Current OS system time zone: ";
      Pen 15 {Print time$()}
End If
}
MODULE WIND4 {Clear
\\ An old example, new revision.
Thread.plan sequential
Global Caption$="M2000 THREAD-INPUT-HANDLE WINDOW"
Title "WAIT", 0
puticon=false
If module(ico) Then
ico 0
read m2000
puticon=true
End If
dim label$(6)
label$(1)="Basic style Input for input a number", "Field Input - Work the INS key","One line transparent textbox, cut, copy, paste, drag/drop, no menu","Multi line textbox with menu (press esc to exit from editor)","Multi line for documents with transparent background (press Esc to exit from editor)"
Example=random(1, 5)
Global messrow
Escape Off
Global STATE=0, EXITNOW as boolean=false
module global mayexit {
	EXITNOW<=True
	Try {field new 99: input End }
	beep
}
window.size=random(7,9)
Hide  \\ prepare Window

Window 10, window  \\ center full size 10pt letters, to current monitor
global abX=scale.x/2, abY=scale.y/2,  cur$, prev$
About ! "Wind4 Module", abX, abY, {
	This is the help file
}
ABout Call {
	cur$=About$
	Select case cur$
	case "Esc"
	{ ' use block for more than one line after case	
		About "Text Editing -  Esc", abX, abY, {
			Just press the Escape key to exit editor
		}+If$(prev$<>""->"["+prev$+"]","")
		prev$<=cur$
	}
	case "shift F10"
	{ ' use block for more than one line after case
		About "Text Editing -  Shift F10", abX, abY, {
			You can use right mouse click, on editor's text area or left on header.
			Also you scroll the menu to see all options.
		}+If$(prev$<>""->"["+prev$+"]","")
		prev$<=cur$
	}	
	case "", "top"
	{
		About "Text Editing", abX, abY, {
		Use [Esc] to exit
		use [shift F10] for context menu
		Threr are some combinations with shift for:
		F2, F3, F4, F5, F9, F10, F12
		}+If$(prev$<>""->"["+prev$+"]","")
		prev$<="top"
	}
	end select
}
Window random(9,14) , scale.x*.1*window.size, scale.y*.1*(window.size-1);  \\centered - random font size
Form 60, 24
Form   
Cls 15,0      \\white bacground - no Split screen
Gradient 0,9  \\ two colors gradient
Move 0,0
Fill scale.x,scale.y/height-25,7,6,0  \\Gradient fill to Window caption
Pen #FF7766
\\ Targets are from earlier versions - but works fine
\\ This is the windows caption. We change only a variable.
\\ Targets works with globals.
Pen 14 {
      Target A,"STATE++",width-2,1,,,5,caption$
}

Print @(width-2,0);
Pen 15
Let IamOut=False
Let kk=0, MayStart=False
\\ This is a second target, the X in the right corner
\\ when we click on it system call mayexit global module
Target b, {Title caption$,0} ,1,1,6,,5,"_"
If puticon Then
	Move twipsx*2, twipsy*2
	Image m2000, scale.x/width*1.5
End If
Print @(width-1,0);
Target C, "mayexit" ,1,1,6,,5,"X"
Pen 15
Print @(4,1);  \\ like Cursor
Report {This is console as Window by software. We use targets for title and  buttons "_" and  "X" in the right top corner. You can Move the window. Console not support events for user. We can scan targets, using Scan statement. Threads run in background  when we use an input method (one of five options).
Press some keys and then the return key. Exit by clicking the X in the right up corner.}, width-6
aa$=Field$("",10)  \\ for second example - change gosub
If pos>0 Then print
Let messrow=row   \\ we can use Let instead of messrow<=row+1
Scroll Split  row+1
Pen 0
threads erase
Thread {
	scan 0.01 : thread this interval 10 
	Layer {Cursor 0,messrow : Print  Over  : Print Part ~(0),"waiting..." , kk }
} as LL
After 1000 { Thread LL interval 10}
Scroll Split 1
Thread  {   \\ this thread used for moving the Window
	Layer {
		Cursor 0,messrow+1 : Print  Over $(4), ~(0, 15), "MOVING"
		Motion.W Motion.XW-MX+Mouse.X,Motion.YW-MY+MOUSE.Y
		If Mouse=0 Then {
			Mouse.icon 1
			STATE<=0: Cursor 0,messrow+1
			Print  Over $(4), ~(0, 15), "HOLD": REFRESH
			After 30  {
			Try {Cursor 0,messrow+1 : Print  Over  $(9), ~(0,15), Label$(Example)}
			}
			Thread this hold
		}
	}
} As Moveme
Thread moveme hold  \\ not started yet
Thread moveme interval 100  \\ we set an interval
MayStart<=True

title caption$, 1
show
Refresh 40

\\ main thread here
Main.Task 10 {
	kk++
	If MayStart Then
		A$=Inkey$
		If A$<>"" Then 
			Layer {
				Cursor 0,messrow+1 : Print  Over  $(9), ~(0,15), Label$(Example)
				MayStart~: keyboard A$
			}
			Select Case Example
			Case 1
				gosub OpenField()
			Case 2
				gosub OpenField1()
			Case 3
				gosub OpenField2()
			Case 4
				gosub OpenField3()
			Else Case
				gosub OpenField4()
			End select
		End If
	End If
	If iamout Then iamout~: Cursor 0,messrow+1 :  Print  Over $(4), ~(0, 15),"You press escape..."  
	If STATE=1 Then 
		Mouse.icon 5
		Cursor 0,messrow+1 : Print  Over $(4), ~(0, 15), "START MOVING"
		MX=Mouse.X:MY=Mouse.Y   \\ setup now position
		Thread moveme restart  \\here we restart thread
		STATE++   \\ and we closed this If
	End If
	If exitnow Then exit
}
wait 1000
threads erase 
targets new
Cursor 0,messrow+1 : Print  Over $(4), ~(0, 15), "End.."
Cls #72ff77, messrow+3   \\Split screen from 7 (8th line)
Cls
Cursor 0, row-1
Print Over $(6), ~(15,0,0), "Just press  F1 to choose another input  or press F3 for info"
Fkey 1, "Wind4"
Fkey 3,  "info"
Escape On
About Call ""
About ! ""
Sub OpenField()
	After 10 {    \\ this is an automatic thread, for one time, After 10 miliseconds
		Layer {
			Cursor 10,10
			for i=1 to 4 : Print Over : Pen 15 { Print under } : next
			Cursor 10,10
			A=0
			Try {Input "Number:", A}
			If exitnow Then exit
			Cursor 0,messrow+2 : Print  Over "Field:";A
			MayStart=True 
		}
	}
End Sub
Sub OpenField1()     \\this is an alternative by using Field
	After 10 {
		Layer {
			Field 10,10,10 AS aa$
			If Field=99 Then
				IamOut=True : aa$=""
				Field New   \\ Clear feedback from Field statement.
				A$=Inkey$
			Else
				Cursor 0,messrow+2 : Print  Over "Field:";aa$ : aa$=""
			End If
			MayStart=True
			If exitnow Then exit
		}
	}
End Sub
Sub OpenField2() 
	After 10 {
		Layer {
			Cursor 10,10
			aa$=inkey$
			If aa$<" " Then aa$=""
			Pen 14 { input ! aa$, 10 len=30}
			If exitnow Then exit
			If Field<>99 Then Cursor 0,messrow+2 : Print  Over "Field:";aa$ : aa$=""
			Field New
			MayStart=True       
		}
	}
End Sub
Sub OpenField3() 
	After 10 {
		Layer {
			Cursor 10,10
			Clear aa$
			aa$=inkey$
			If asc(aa$)<32 Then aa$=""
			input ! aa$, 20, 8,"Input", len(aa$)+1
			If exitnow Then exit            
			document aa$  \\ upgrade to document
			Cursor 0,messrow+2 : Print  Over "Field:";paragraph$(aa$,1) : aa$=""
			MayStart=True       
		}
	}
End Sub
Sub OpenField4() 
	After 10 {
		Layer {
			Cursor 10,10
			Clear aa$
			Document bb$=""  \\ this is a new variable, but not for Sub, Sub ends before this thread run.
			bb$=inkey$
			If asc(bb$)<32 Then Clear bb$
			Scroll Split 10
			Pen 11 {
				Edit.Doc bb$, 2,,Pen
			}
			If exitnow Then exit
			Cursor 0,messrow+2 : Print  Over "Field:";paragraph$(bb$,1) 
			Clear bb$
			MayStart=True
		}
	}
End Sub
}
MODULE WRITEWITH {Report {
	Write With  stringsep$, decimalse$ [, [JsonFlag], Nouseofchr34]
	
	stringsep$		only one char used, if "" then we get the default ","
	decimalse$	 	only one char used, if "" then we get the default "."
	jsonflag 		if non zero means enconding string using \n and other characters like json strings
				so we can put mulrinlie text withoutbreaking the line
	Nouseofchr34	a  no zero value means no "" araound a string.
	
	so Write With "", "" reset the writing using Write
	
	The same for Input #
	We use Input With as Write With
	We can define different set so we can read with one way and write with another.
	
	We can use ANSI or UTF16LE files
	For ANSI files we have to use LOCALE to set the locale for conversion
	A Local 1032 used for greek conversion.
	
}



Pen 11{Print "Ansi first"}
Print "Export csv using tab as seperator, and dot for decimal char"
open "testnochr34.csv" for output as k
Write With chr$(9), ".", ,1
Write #k, "Hello There", "And There", 1212.12, "Bye"
Close #k
Document docA$
Load.Doc docA$, "testnochr34.csv"   ' automatic get the file type
Print "The file as a string - tabs are expanded"
Pen 15 {report DocA$}
Print "ok..."
Print "Now we use Input # programming the separator and dot"
open "testnochr34.csv" for input as k
Input With chr$(9), ".", ,1
Input #k, A$, B$, C, D$
Close #k
Print "Results"
Print A$, B$, C, D$
Pen 11{Print "For UTF16LE wide chars"}
open "testnochr34.csv" for wide output as k
Write With chr$(9), ".", ,1
Write #k, "Hello There", "surrogate 𐐷", 1212.12, "1234 ברוכים הבאים abc"
Close #k
Document docA$
Load.Doc docA$, "testnochr34.csv"
Print "The file as a string - tabs are expanded"
Pen 15 {report DocA$}
open "testnochr34.csv" for wide input as k
Input With chr$(9), ".", ,1
Input #k, A$, B$, C, D$
Close #k
Print "Results"
Print A$, B$, C, D$
}
MODULE DUTCH {Report "Dutch Flag from Dijkstra"
const center=2
enum balls {Red, White, Blue}
fillarray=lambda a=(Red, White, Blue) (size as long=10)-> {
	if size<1 then size=1
	randomitem=lambda a->a#val(random(0,2))
	dim a(size)<<randomitem()
	=a()
}
Display$=lambda$ (s as array) ->{
	Document r$=eval$(array(s))
	if len(s)>1 then
	For i=1 to len(s)-1 {
		r$=", "+eval$(array(s,i))
	}
	end if
	=r$
}
TestSort$=lambda$ (s as array)-> {
	="unsorted: "
	x=array(s)
	for i=1 to len(s)-1 {
		k=array(s,i)
		if x>k then break
		swap x, k
	}
	="sorted: "
}
Positions=lambda mid=White (a as array) ->{
	m=len(a)
	dim Base 0, b(m)=-1
	low=-1
	high=m
	m--
	i=0
	medpos=stack
	link a to a()
	for i=m to 0 {
		if a(i)<=mid then exit
		high--
		b(high)=high
	}
	for i=0 to m {
		if a(i)>=mid then exit
		low++
		b(low)=low
	}
	if high-low>1 then
	for i=low+1 to high-1 {
		select case a(i)<=>Mid
		case -1
			low++ : b(low)=i
		case 1
		{
			high-- :b(high)=i
			if High<i then swap b(high), b(i)
		}
		else case
			stack medpos {data i}
		end select
	}
	end if
	if Len(medpos)>0 then
	dim c()
	c()=array(medpos)
	stock c(0) keep len(c()), b(low+1)
	for i=low+1 to high-1
   		if b(i)>low and b(i)<high and b(i)<>i then swap b(b(i)), b(i)	
	next i
	end if
	if low>0  then
		for i=0 to low
			if b(i)<=low and b(i)<>i then swap b(b(i)), b(i)
		next 
	end if
	if High<m then
		for i=m to High
			if b(i)>=High and b(i)<>i then swap b(b(i)), b(i)
		next 
	end if
	=b()
}
InPlace=Lambda (&p(), &Final()) ->{
	def i=0, j=-1, k=-1, many=0
	for i=0 to len(p())-1
		if p(i)<>i then
			j=i
			z=final(j)
			do
				final(j)=final(p(j))
				k=j
				j=p(j)
				p(k)=k
				many++
			until j=i
			final(k)=z
		end if
	next
	=many
}


Dim final(), p(), second(), p1()
Rem final()=(White,Red,Blue,White,Red, Red, Blue)
Rem final()=(white, blue, red, blue, white)

final()=fillarray(30)
Print "Items: ";len(final())
Report TestSort$(final())+Display$(final())
\\ backup for final() for second example
second()=final()
p()=positions(final())
\\ backup p() to p1() for second example
p1()=p()


Report Center,  "InPlace"
rem Print p()   ' show array items
many=InPlace(&p(), &final())
rem print p()  ' show array items
Report TestSort$(final())+Display$(final())
print "changes: "; many

Report Center, "Using another array to make the changes"
final()=second()
\\ using a second array to place only the changes
item=each(p1())
many=0
While item {
	if item^=array(item) else final(item^)=second(array(item)) : many++
}
Report TestSort$(final())+Display$(final())
print "changes: "; many
}
MODULE KNIGHT {Function KnightTour$(StartW=1, StartH=1){
	def boolean swapH, swapV=True
	if startW<=4  then swapH=true: StartW=8+1-StartW
	if startH>4  then swapV=False: StartH=8+1-StartH
	Let final=8*8, last=final-1, HighValue=final+1
	Dim Board(1 to 8, 1 to 8), Moves(1 to 8, 1 to 8)=HighValue
	f=stack:=1,2,3,4,5,6,7,8
	if 8-StartW=2 and StartH=2 then stack f {shift 1,-8}
	Function KnightMove(x,w,h) {
		a=2:b=1:z=1:p=1
		if x mod 2=1  then swap a,b
		if x>2 then p-! : if x>4 then swap z, p : if x>6 then p-!
		w+=z*a
		h+=p*b
		if w>=1 and w<=8 and h>=1 and h<=8 then =(w, h) else =(,)
	}
	For j=1 to 8 :For i=1 to 8
	s=stack
	For k=1 to 8
		m=KnightMove(stackitem(f, k),i, j)
		if len(m)>1 then Stack s {data m} 
	Next : Board(i,j)=s : Next 
           stack f {shift 1,-8}
	Next
	For i=1 to 8 :For j=1 to 8
	s=Board(i, j)
	if len(s)>2 then
		so=queue
		For k=1 to len(s)
			m=stackitem(s, k)
			Append  so, Len(Board(m#val(0), m#val(1))) :=m
		Next
		sort ascending so as number
		s=stack
		stack s {for k=0 to len(so)-1:data so(k!):next}
		Board(i,j)=s
	end if
	Next :	Next
	s= Board(StartW, StartH)
	n=0
	BackTrack=Stack
	Moves=1
	Moves(StartW, StartH)=1
	Repeat
	n++
	While n>len(s) {
		if Len(BackTrack)=0 then Print "Break", moves : Break
		Moves--
		Stack BackTrack {Read s, n}
		m=stackitem(s, n)
		Moves(m#val(0), m#val(1))=HighValue
		n++
	}
	m=stackitem(s, n)
	w=m#val(0)
	h=m#val(1)
	if Moves(w, h)>=Moves then
		if Moves<last then
		s1=Board(w, h) :ii=-1
		for i=1 to len(s1){m1=stackitem(s1, i) :if Moves(m1#val(0),m1#val(1))>moves then ii=i-1 : exit
		}
		if ii>=0 then
			Moves++
			Moves(w,h)=Moves
			Stack BackTrack {Push n, s}
			s=s1: n=ii
		end if
		else
			Moves++
			Moves(w,h)=Moves
		end if
	end if
	until Moves=final
	Document export$
	Inventory Tour
	letters=stack:="a","b","c","d","e","f","g","h"
	f=stack:=1,2,3,4,5,6,7,8
	if swapV Else stack f {Shift 1,-8}
	if swapH then stack letters {Shift 1,-8}
	For j=1 to 8:For i=1 to 8
		Append Tour, Moves(i,j) :=stackitem$(letters, i)+str$(stackitem(f, j),"")
	Next : Next
	Sort ascending Tour as number
	one=each(Tour)
	While one {
		export$=Eval$(one)
		if  not one^=last then export$="->"
		If (one^+1) mod 8=0 then
		export$={
		}
		End if
	}
	=export$
}
Document ex$
ex$= {Knight's Tour from a1

}+ KnightTour$()+{Knight's Tour from h1

}+ KnightTour$(8, 1)+{Knight's Tour from a8

}+KnightTour$(1, 8)+{Knight's Tour from h8

}+KnightTour$(8, 8)
Clipboard ex$
Report ex$
}
MODULE KNIGHTEXP {module Experiment(StartW=1, StartH=1, &mmm){
	Global ww=8, hh=8
	def boolean swapH, swapV=True
	if startW<=ww div 2  then swapH=true: StartW=ww+1-StartW
	if startH>hh div 2  then swapV=False: StartH=hh+1-StartH
	Form 80, 32
	Let final=ww*hh, last=final-1, HighValue=final+1
	Dim Board(1 to ww, 1 to hh), Moves(1 to ww, 1 to hh)=HighValue
	f=stack:=1,2,3,4,5,6,7,8
	if ww-StartW=2 and StartH=2 then stack f {shift 1,-8}
	Function KnightMove(x,w,h) {
		a=2:b=1:z=1:p=1
		if x mod 2=1  then swap a,b
		if x>2 then p-! : if x>4 then swap z, p : if x>6 then p-!
		w+=z*a
		h+=p*b
		if w>=1 and w<=ww and h>=1 and h<=hh then
			=(w, h)
		else
			=(,)
		end if
	}
	For j=1 to hh
	For i=1 to ww
	s=stack
	For k=1 to 8
		m=KnightMove(stackitem(f, k),i, j)
		if len(m)>1 then Stack s {data m} 
	Next
	Board(i,j)=s
	Next 
           stack f {shift 1,-8}
	Next
	For i=1 to ww
	For j=1 to hh
	s=Board(i, j)
	if len(s)>2 then
	so=queue
	For k=1 to len(s)
	m=stackitem(s, k)
	Append  so, Len(Board(m#val(0), m#val(1))) :=m
	Next
	sort ascending so as number
	s=stack
	stack s {
		for k=0 to len(so)-1
			data so(k!)
		next
	}
	Board(i,j)=s
	end if
	Next
	Next
	Print "Done"
	s= Board(StartW, StartH)
	n=0
	BackTrack=Stack
	Moves=1
	Moves(StartW, StartH)=1
	mstep=10
	mm=mstep
	mmm=0
	Repeat
	n++
	While n>len(s) {
		if Len(BackTrack)=0 then Print "Break", moves : Break
		Moves--
		Stack BackTrack {Read s, n}
		m=stackitem(s, n)
		Moves(m#val(0), m#val(1))=HighValue
		n++
	}
	m=stackitem(s, n)
	w=m#val(0)
	h=m#val(1)
	if Moves(w, h)>=Moves then
		if Moves<last then
		s1=Board(w, h) :ii=-1
		for i=1 to len(s1){m1=stackitem(s1, i) :if Moves(m1#val(0),m1#val(1))>moves then ii=i-1 : exit
		}
		if ii>=0 then
			Moves++
			Moves(w,h)=Moves
			Stack BackTrack {Push n, s}
			s=s1: n=ii
			mm--
		end if
		else
			Moves++
			Moves(w,h)=Moves
			mmm+=mm
			mm=0
		end if
	end if
	if mm Else
		cls
		Print "Moves:";Moves
		sj=hh: sj1=1: if swapV then swap sj, sj1
		si=1: si1=ww: if swapH then swap si, si1
		For j=sj to sj1: Print :For i=si to si1
			Print If(Moves(i,j)<=Moves->Moves(i,j), 0),
		Next : Next
		Print
		mm=mstep
		mmm+=mm
		Print mmm
		refresh 10000
	end if
	if mmm>1000 then mmm=-1:  exit
	until Moves=final
		cls
		Print "Moves:";Moves
		sj=hh: sj1=1: if swapV then swap sj, sj1
		si=1: si1=ww: if swapH then swap si, si1
		For j=sj to sj1: Print :For i=si to si1
			Print If(Moves(i,j)<=Moves->Moves(i,j), 0),
		Next : Next
		Print
		Print mmm
		Print "DONE"
		refresh 5000
}
dim res(1 to 8, 1 to 8)=0
for j=8 to 1
for i=1 to 8
Experiment i, j, &res(i, j)
next
next
Print
for j=8 to 1
for i=1 to 8
Print  res(i, j),
next
Print
next
}
MODULE ABC {chessgame {rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1
rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e4 1 1
r1bqkbnr/pppppppp/2n5/8/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 2 2
r1bqkbnr/pppppppp/2n5/8/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 3 2
r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq e5 4 3
r1bqkbnr/pppp1ppp/2n5/4p3/2B1P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 5 3
r1bqkbnr/ppp2ppp/2n5/3pp3/2B1P3/5N2/PPPP1PPP/RNBQK2R w KQkq d5 6 4
r1bqkbnr/ppp2ppp/2n5/1B1pp3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 7 4
r1bqkbnr/1pp2ppp/p1n5/1B1pp3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 8 5
r1bqkbnr/1pp2ppp/p1B5/3pp3/4P3/5N2/PPPP1PPP/RNBQK2R b KQkq - 0 5
r1bqkbnr/2p2ppp/p1p5/3pp3/4P3/5N2/PPPP1PPP/RNBQK2R w KQkq - 0 6
r1bqkbnr/2p2ppp/p1p5/3pN3/4P3/8/PPPP1PPP/RNBQK2R b KQkq - 0 6
r1bqkbnr/2p3pp/p1p2p2/3pN3/4P3/8/PPPP1PPP/RNBQK2R w KQkq - 1 7
r1bqkbnr/2p3pp/p1N2p2/3p4/4P3/8/PPPP1PPP/RNBQK2R b KQkq - 0 7
r1b1kbnr/2pq2pp/p1N2p2/3p4/4P3/8/PPPP1PPP/RNBQK2R w KQkq - 1 8
r1b1kbnr/2pq2pp/p4p2/N2p4/4P3/8/PPPP1PPP/RNBQK2R b KQkq - 2 8
r1b1kb1r/2pqn1pp/p4p2/N2p4/4P3/8/PPPP1PPP/RNBQK2R w KQkq - 3 9
r1b1kb1r/2pqn1pp/p4p2/N2p4/4P3/8/PPPP1PPP/RNBQ1RK1 b kq - 5 9
r1b1kb1r/2p1n1pp/p4p2/Nq1p4/4P3/8/PPPP1PPP/RNBQ1RK1 w kq - 6 10
r1b1kb1r/2p1n1pp/p4p2/1q1p4/4P3/1N6/PPPP1PPP/RNBQ1RK1 b kq - 7 10
r3kb1r/1bp1n1pp/p4p2/1q1p4/4P3/1N6/PPPP1PPP/RNBQ1RK1 w kq - 8 11
r3kb1r/1bp1n1pp/p4p2/1q1p4/3PP3/1N6/PPP2PPP/RNBQ1RK1 b kq d4 9 11
r3kb1r/1bp1n1pp/p4p2/1q6/3Pp3/1N6/PPP2PPP/RNBQ1RK1 w kq - 0 12
r3kb1r/1bp1n1pp/p4p2/1q6/3Pp3/1NP5/PP3PPP/RNBQ1RK1 b kq - 1 12
r3kb1r/1bp3pp/p4p2/1q3n2/3Pp3/1NP5/PP3PPP/RNBQ1RK1 w kq - 2 13
r3kb1r/1bp3pp/p4p2/1q3n2/3Pp3/1NP5/PP3PPP/RNBQR1K1 b kq - 3 13
r3k2r/1bp1b1pp/p4p2/1q3n2/3Pp3/1NP5/PP3PPP/RNBQR1K1 w kq - 4 14
r3k2r/1bp1b1pp/p4p2/1q3n2/3Pp3/1NP2P2/PP4PP/RNBQR1K1 b kq - 5 14
r3k2r/1bp1b1pp/p4p2/1q3n2/3P4/1NP2p2/PP4PP/RNBQR1K1 w kq - 0 15
r3k2r/1bp1b1pp/p4p2/1q3n2/3P4/1NP2P2/PP5P/RNBQR1K1 b kq - 0 15
r3k2r/1bp1b1pp/p4p2/1q6/3P4/1NP2Pn1/PP5P/RNBQR1K1 w kq - 1 16
r3k2r/1bp1b1pp/p4p2/1qN5/3P4/2P2Pn1/PP5P/RNBQR1K1 b kq - 2 16
r3k2r/2p1b1pp/p4p2/1qN5/3P4/2P2bn1/PP5P/RNBQR1K1 w kq - 0 17
r3k2r/2p1b1pp/p4p2/1qN5/3P4/2P2Qn1/PP5P/RNB1R1K1 b kq - 0 17
2kr3r/2p1b1pp/p4p2/1qN5/3P4/2P2Qn1/PP5P/RNB1R1K1 w - - 2 18
2kr3r/2p1b1pp/p4p2/1qN5/3P4/2P3Q1/PP5P/RNB1R1K1 b - - 0 18
2kr3r/2p3pp/p4p2/1qb5/3P4/2P3Q1/PP5P/RNB1R1K1 w - - 0 19
2kr3r/2p3pp/p4p2/1qP5/8/2P3Q1/PP5P/RNB1R1K1 b - - 0 19
2krr3/2p3pp/p4p2/1qP5/8/2P3Q1/PP5P/RNB1R1K1 w - - 1 20
2krR3/2p3pp/p4p2/1qP5/8/2P3Q1/PP5P/RNB3K1 b - - 0 20
2krR3/2p3pp/p4p2/2q5/8/2P3Q1/PP5P/RNB3K1 w - - 0 21
2kr4/2p3pp/p4p2/2q5/8/2P1R1Q1/PP5P/RNB3K1 b - - 1 21
2k5/2p3pp/p4p2/2q5/8/2P1R1Q1/PP5P/RNBr2K1 w - - 2 22
2k5/2p3pp/p4p2/2q5/8/2P1R1Q1/PP4KP/RNBr4 b - - 3 22
2k5/2p3pp/p4p2/2q5/8/2P1R1Q1/PP4KP/RNr5 w - - 0 23
2k5/2p3pp/p4p2/2q5/8/2P1R3/PP3QKP/RNr5 b - - 1 23
2k5/2p3pp/p4p2/6q1/8/2P1R3/PP3QKP/RNr5 w - - 2 24
2k5/2p3pp/p4p2/6q1/8/2P3R1/PP3QKP/RNr5 b - - 3 24
2k5/2p3pp/p4p2/3q4/8/2P3R1/PP3QKP/RNr5 w - - 4 25
2k5/2p3pp/p4p2/3q4/8/2P2R2/PP3QKP/RNr5 b - - 5 25
1k6/2p3pp/p4p2/3q4/8/2P2R2/PP3QKP/RNr5 w - - 6 26
1k6/2p3pp/p4p2/3q4/P7/2P2R2/1P3QKP/RNr5 b - a4 7 26
1k6/2p3pp/p4p2/8/P7/2P2R2/1P3QKP/RNrq4 w - - 8 27
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P4KP/RNrq4 b - - 9 27
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P4KP/RNr4q w - - 10 28
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P3K1P/RNr4q b - - 11 28
1k6/2p3pp/p4p2/8/P2Q4/2P2R2/1P3K1q/RNr5 w - - 0 29
1k6/2p3pp/p4p2/8/P2Q4/2P1KR2/1P5q/RNr5 b - - 1 29
1k6/2p3pp/p4p2/8/P2Q4/2P1KR2/1P5q/RN2r3 w - - 2 30
1k6/2p3pp/p4p2/8/P2Q4/2PK1R2/1P5q/RN2r3 b - - 3 30
1k6/2p3pp/p4p2/8/P2Q4/2PK1R2/1P2q3/RN2r3 w - - 4 31
}
}
MODULE WORKER {Καθαρό
Οθόνη 5
Πένα 14
Φόρμα 80,60
Γενικές  Σταθερές  ειναιδενειναι$="; είναι ; δεν είναι ",  εχειδενεχει$="; έχει ; δεν έχει "
Κατάσταση ΜισθωτοιΛίστα, ΝέαΛίσταΑμκα, ΝέαΛίσταΑΦΜ, ΝέαΛίσταΕπωνΟνομα
\\ Βάση πινάκων 0
Βάση 0
\\ από δω και κάτω για το τμήμα αυτό η Κατάσταsη δεν είναι πια εντολή αλλά τμήμα

Τμημα Κατάσταση {
      Διάβασε &Α
      Για Α {
            Τύπωσε .όνομ_επών$+γραφη$(.Είναι_Άνεργος(),ειναιδενειναι$)+.Λεκτικό_Άνεργος$()
            Τύπωσε .όνομ_επών$+γραφη$(.Έχει_Προϋπηρεσία(),εχειδενεχει$)+"προϋπηρεσία"
      }
}
Τμήμα Πάτα_Διάστημα {
      Τύπωσε "<<<<<<<<<<< Πάτα Ένα Πλήκτρο >>>>>>>>>>>"
      α$=κομ$
}
Τμήμα Βιογραφικό {
      \\ τροποποίηση για να διαβάζει και με αναφορά και με τιμή
      \\ Περιμένει κάτι με υπερκλάση μισθωτός
      Αν Ταύτιση("Ο") τότε {
            Διαβασε Α
      } Αλλιώς Διάβασε &Α
      Τμήμα Εμφάνιση {
            ΑΑ$=""
            Διάβασε Α
            Διάβασε ? ΑΑ$
            Για Α {
                  Τύπωσε ΑΑ$, "Επιχείρηση με ΑΦΜ:"; .ΑφμΕργοδ$
                  Τύπωσε "","Ιδιότητα:";.ΙδιότηταΕργαζομένου$
                  Τύπωσε "","Απο ";Ημέρα$(.ΗμΠρόσλ);
                  Αν .Τελική=0 Τότε { Τύπωσε } Αλλιώς Τύπωσε " Έως ";Ημέρα$(.Τελική)
            }
      }
      Για Α {
            Πένα 15 {
                  Τύπωσε "Βιογραφικό",@(20),.όνομ_επών$
                  Τύπωσε "Φύλο",@(20),γραφη$(.Φύλο,"ΆΝΔΡΑΣ;;ΓΥΝΑΙΚΑ")
                  Τύπωσε "ΑΜΚΑ",@(20),.αμκα$
                  Τύπωσε "ΑΦΜ",@(20),.αφμ$
                  Τύπωσε "Έτη ασφάλισης",@(20),Γραφή$(.έτη_ασφ, "# ")+Γραφή$(.έτη_ασφ-1, "Χρόνια;Χρόνια;Χρόνο")
            }
            Πένα 13 {
                  Τύπωσε "Κατάσταση";
                  Αν .Είναι_Άνεργος() Τότε {
                        Τύπωσε γραφη$(.Είναι_Άνεργος(),ειναιδενειναι$)+.Λεκτικό_Άνεργος$()
                 } Αλλιώς {
                       Τύπωσε " εργάζεται"
                       Σωρός Νέος {
                             Πένα 14 {
                                   Εμφάνιση .τρέχουσα(0)
                             }
                        }
                  }
            }
            Αν .Έχει_Προϋπηρεσία() τότε {
                  Τύπωσε "Προϋπηρεσία"
                  κ=Διάσταση(.προϋπηρεσία(),1)
                  Για ι=κ-1 εως 0 {
                              Εμφάνιση .προϋπηρεσία(ι), μορφη$("{0::-3})", κ-ι)
                  }
            }
      }

}
Κλάση Εργασία {
      ΑφμΕργοδ$, ΙδιότηταΕργαζομένου$, ΗμΠρόσλ, Τελική
      Τμήμα Διακοπή_Συνεργασίας {
            Διάβασε .Τελική
            Αν .Τελική < .ΗμΠρόσλ Τότε Λάθος "Αδύνατη η διακοπή σε προηγούμενη μέρα"
      }
      Συνάρτηση Στοιχεία$ {
            =Σωρός$(.ΑφμΕργοδ$, .ΙδιότηταΕργαζομένου$, .ΗμΠρόσλ, .Τελική)
      }
      Τμήμα Στοιχεία {
            Διάβασε Α$
            Σωρός Α$
            Διάβασε .ΑφμΕργοδ$, .ΙδιότηταΕργαζομένου$, .ΗμΠρόσλ, .Τελική
      }
Κλάση:
      Τμήμα Εργασία {
            Αν όχι Κενό τότε {
                  Διάβασε .ΑφμΕργοδ$, .ΙδιότηταΕργαζομένου$, .ΗμΠρόσλ
            }
      }
}
Κλάση Μισθωτός {
      αμκα$, όνομ_επων$, φύλο, αφμ$, μισθός, έτη_ασφ, κρατήσεις
      πίνακας κλιμακα() \\ φορολογική κλίμακα
      πινακας προϋπηρεσία(), τρέχουσα()
      Θέσε {
            Διάβασε Ν
            Σωρός Νέος {
            Για Ν {
                  Σειρά .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις, .κλιμακα(), .προϋπηρεσία(), .τρέχουσα()
            }
            Διάβασε .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις, .κλιμακα(), .προϋπηρεσία(), .τρέχουσα()
            }
      }
Κλάση:
      Τμήμα Μισθωτός {
            Αν κενό τότε έξοδος
            Διάβασε .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .έτη_ασφ, .κλιμακα()
      }     

}
Κλάση ΥπερΜισθωτός {
      Τμήμα Εισαγωγή_μισθός_κρατήσεις {
            \\ κρατήσεις ως ποσοστό π.χ. 30 σημαίνει 30%
            \\ μισθός - μεικτά - μηνιαίος
            Αν .Είναι_Ανεργος() Τότε Λάθος "Δεν έχεις δώσει εργασία"
            Διάβασε .μισθός, .κρατήσεις
      }
      Συνάρτηση Είναι_Άνεργος {
            =Διάσταση(.τρεχουσα())=0
      }
      Συνάρτηση Λεκτικό_Άνεργος$ {
            Αν .Φύλο=1 Τότε { = "άνεργος" } Αλλιώς ="άνεργη"
      }
      Συνάρτηση Έχει_Προϋπηρεσία {
            =Διάσταση(.προϋπηρεσία())<>0
      }
      Τμήμα Πρόσληψη {
            Αν Δεν .Είναι_Ανεργος() Τότε Λάθος "Δεν είναι "+.Λεκτικό_Άνεργος$()
            Πίνακας .τρέχουσα(1)
            Διάβασε .τρέχουσα(0)
      }
      Τμήμα Διακοπή_Εργασίας {
            Αν .Είναι_Ανεργος() Τότε Λάθος "Είναι "+.Λεκτικό_Άνεργος$()
            \\ αφήνουμε την ημερομηνία για το άλλο τμημα:
            .τρέχουσα(0).Διακοπή_Συνεργασίας
            κ=Διάσταση(.προϋπηρεσία())
            Αν κ=0 τότε {
                  κ=1
                  Πίνακας .προϋπηρεσία(1)=Εργασια()
             } αλλιώς {
                  κ=Διάσταση(.προϋπηρεσία(),1)+1
                  Πίνακας .προϋπηρεσία(κ)
            }
            .προϋπηρεσία(κ-1)=.τρέχουσα(0)
            Πίνακας .τρέχουσα()
      }
      Συνάρτηση Στοιχεία$ {
            Εγγραφο Α$
            Α$=Σωρός$(.αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις)
            κ=Διάσταση(.κλιμακα())
            Αν κ<>2 τότε {
                  Α$=Σωρός$(0)
            } Αλλιώς {
                  Α$=Σωρός$(Διάσταση(.κλιμακα(),1))
                  Για ι=0 έως Διάσταση(.κλιμακα(),1)-1 {
                        Α$=Σωρός$(.κλιμακα(ι,0),.κλιμακα(ι,1))
                  }
            }
            κ=Διάσταση(.τρέχουσα())
            Αν κ=0 τότε {
                  Α$=Σωρός$(0)
            } αλλιώς {
                  Α$=Σωρός$(Διάσταση(.τρέχουσα(),1))
                  Για ι=0 έως Διάσταση(.τρέχουσα(),1)-1 {
                        Α$=Σωρός$(.τρέχουσα(ι).στοιχεία$())
                  }
            }
            κ=Διάσταση(.προϋπηρεσία())
            Αν κ=0 τότε {
                  Α$=Σωρός$(0)
            } αλλιώς {
                  Α$=Σωρός$(Διάσταση(.προϋπηρεσία(),1))
                  Για ι=0 έως Διάσταση(.προϋπηρεσία(),1)-1 {
                        Α$=Σωρός$(.προϋπηρεσία(ι).στοιχεία$())
                  }
            }
            =Α$
      }
      Τμήμα Στοιχεία {
            Διάβασε Α$
            Σωρός Α$
            Διάβασε .αμκα$, .όνομ_επων$, .φύλο, .αφμ$, .μισθός, .έτη_ασφ, .κρατήσεις
            Διαβασε κ
            Αν κ>0 τότε {
                  Πίνακας .κλιμακα(κ,2)
                  Για ι=0 έως κ-1 {
                  Διάβασε .κλιμακα(ι,0), .κλιμακα(ι,1)
                  }
            } Αλλιώς {
                  Πίνακας .κλιμακα()
            }
            Διάβασε κ
            Αν κ>0 τότε {
                  Πίνακας .τρέχουσα(0)
                  Πίνακας .τρέχουσα(κ)=Εργασια()
                  Για ι=0 έως κ-1 {
                        .τρέχουσα(ι).στοιχεια γράμμα$
                  }
            } Αλλιώς {
                  Πίνακας .τρέχουσα(0)
            }
            Διάβασε κ
            Αν κ>0 τότε {
                  Πίνακας .προϋπηρεσία(0)
                  Πίνακας .προϋπηρεσία(κ)=Εργασια()
                  Για ι=0 έως κ-1 {
                        .προϋπηρεσία(ι).στοιχεια γράμμα$
                  }
            } Αλλιώς {
                  Πίνακας .προϋπηρεσία(0)
            }
      }
      \\ εδώ στον κατασκευαστή ορίζουμε μια κλάση
Κλάση:
      Τμήμα ΥπερΜισθωτός {
            Αν Κενό τότε {
                  Αυτό=Μισθωτός()
            } αλλιώς {
                  Διάβασε Μισθ
                  Αυτό=Μισθ
            }
      }
}

\\\\   ΚΥΡΙΟ ΠΡΑΓΜΑ  ////

Πίνακας Φορολογία(5,2)
Φορολογία(0,0)=10000,22,10000,35,10000,50
Προσθήκη ΜισθωτοιΛίστα, 12345123451:=Μισθωτός("12345123451","ΚΥΡΙΟΣ ΧΑΡΗΣ",1,"012341234", 5, Φορολογία())
Προσθήκη ΜισθωτοιΛίστα, 32345123451:=Μισθωτός("32345123451","ΑΝΕΤΗ ΧΑΡΟΥΛΑ",0,"052341234", 1, Φορολογία())
Μισθωτοι=Μήκος(ΜισθωτοιΛίστα)


\\ Η Για αντικείμενο {} ανοίγει ομάδες για επεξεργασία και στην έξοδο τα κλείνει πάλι στη θέση του
\\ αν το πειράξουμε από αλλού, "γνωρίζει" ότι έχει ανοίξει και άμεσα δουλεύουμε με το ανοιχτό.
\\ Σε όλο το πρόγραμμα δεν δουλεύουμε με δείκτες σε ομάδες (αντικείμενα)
\\ Κάθε αντικείμενο υπάρχει σε μια θέση μόνο.

\\ Στην αρχή έχουμε στη κατάσταση  ΜισθωτοιΛίστα αντικείμενα Μισθωτός
\\ Στην πορεία βάζουμε επιπλέον μέλη, από την ΥπερΜισθωτός.
\\ Στα νέα μέλη κάνουμε ενέργειες, όπως Πρόσληψη και Διακοπή
\\ Στην πρόσληψη βάζουμε ένα αντικείμενο Εργασία.
Πένα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Πρώτη"
    Αναφορά "Βάζουμε στοιχεία εργασίας για κάθε μισθωτό"
    Οθόνη , 4
}
Για ΜισθωτοιΛίστα(12345123451) {
      Προσωρινό=ΥπερΜισθωτός(Αυτό)
      Για Προσωρινό {
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Πρόσληψη 12/10/2015" }
            ..Πρόσληψη Εργασία("912341234","Ιδ. Υπάλληλος",ημερα("12/10/2015"))
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Διακοπή 14/12/2015" }
            ..Διακοπή_Εργασίας ημερα("14/12/2015")
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Πρόσληψη 11/1/2016" }
            ..Πρόσληψη Εργασία("992341235","Ιδ. Υπάλληλος",ημερα("11/1/2016"))
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Διακοπή 1/2/2016" }
            ..Διακοπή_Εργασίας ημερα("1/2/2016")
            Κατάσταση &Προσωρινό
      }
      Αυτό=Προσωρινό
      \\ εδώ έχουμε ειδική = για να μην κάνει συγχώνευση στα πάντα!
      \\ κοίτα τη Θέσε στο Μισθωτρός()
      \\ η Προσωρινό περνάει στη Θέσε και από αυτήν φορτώνει ότι χρειάζεται το τρέχον αντικείμενο
      \\ Έτσι αντί να έχουμε τα πάντα στο ΜισθωτοίΛίστα
      \\ παίρνουμε το αντικείμενο και το βάζουμε σε ένα νέο αντικείμενο Υπερομισθωτός
      \\ και δουλεύουμε σε αυτό!
}
Για ΜισθωτοιΛίστα(32345123451) {
      Προσωρινό=ΥπερΜισθωτός(Αυτό)
      Για Προσωρινό {
            Κατάσταση &Προσωρινό
            Πένα 15 { Τύπωσε "Πρόσληψη 12/10/2015" }
            ..Πρόσληψη Εργασία("912341234","Διευθυντής",ημερα("12/10/2015"))
            Κατάσταση &Προσωρινό
      }
      Αυτό=Προσωρινό
}
Για ι=0 έως Μισθωτοι-1 {
      Για ΜισθωτοιΛίστα(ι!) {
            Προσωρινό=ΥπερΜισθωτός(Αυτό)
            Αν .αμκα$<>"" τότε Βιογραφικό &Προσωρινό
            \\ εδώ δεν αλλάζουμε τιμές οπότε δεν χρειάζεται η Αυτό=Προσωρινό
      }
}
Σημ {
    Για Αυτό {
          Προσωρινό2=ΥπερΜισθωτός(ΜισθωτοίΛίστα(12345123451))
          Βιογραφικό &Προσωρινό2
    }
}
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Δεύτερη"
    Αναφορά "Γράφουμε σε αρχείο"
    Οθόνη , 4
}
κ=1
Τύπωσε {Ανοιξε "αλφα.μισθ"  για ευρεια εξαγωγή ως κ}
Ανοιξε "αλφα.μισθ"  για ευρεια εξαγωγή ως κ
Για ι=0 έως 1 {
      Για ΜισθωτοίΛίστα(ι!) { \\ ο χαρακτήρας ! δηλώνει ότι το ι δεν είναι κλειδί αλλά αριθμός σειράς από το 0
            Προσωρινό=ΥπερΜισθωτός(Αυτό)
            Τύπωσε Μετάθεση(#κ), " - θέση του δρομέα του αρχείου που θα γραφτεί το παρακάτω"
            Βιογραφικό &Προσωρινό
            \\ Τύπωσε .στοιχεία$()
            Τύπωσε #κ, Προσωρινό.στοιχεία$()
      }
      Τύπωσε
}
Κλείσε #κ
Τύπωσε "Τέλος εγγραφής"
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Τρίτη"
    Αναφορά "Διαβάζουμε από αρχείο, με άμεση εμφάνιση, χωρίς να φορτώσουμε  μόνιμα όλο το αρχείο"
    Οθόνη , 4
}
Τύπωσε "Μήκος αρχείου:";αρχείου.μήκος("αλφα.μισθ")
Ανοιξε "αλφα.μισθ"  για ευρεια εισαγωγή ως κ
Ενώ όχι τέλος(#κ) {
     Τύπωσε Μετάθεση(#κ), " - θέση του δρομέα του αρχείου που διαβάστηκε το παρακάτω"
     Γραμμή Εισαγωγής #κ, α$
     Προσωρινό=ΥπερΜισθωτός()
     Προσωρινό.στοιχεία α$
     Βιογραφικό &Προσωρινό
}
Κλείσε #κ
Τύπωσε "Τέλος ανάγνωσης"
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Τέτσρτη"
    Αναφορά "Διαβάζουμε από αρχείο σε πίνακα, και βάζουμε  κλειδιά για άμεση αναζήτηση σε καταστάσεις (λίστες)"
    Οθόνη , 4
}
Τύπωσε "Μήκος αρχείου:";αρχείου.μήκος("αλφα.μισθ")
\\ στους πίνακες που ορίζουμε από μια κλάση
\\ καταχωρούνται οι συναρτήσεις/μέθοδοι μια φορά

Πίνακας άλλος(10)=ΥπερΜισθωτός()
Ανοιξε "αλφα.μισθ"  για ευρεια εισαγωγή ως κ
ι=0
Ενώ όχι τέλος(#κ) {
     Γραμμή Εισαγωγής #κ, α$
     Για Άλλος(ι) {
            .στοιχεία α$
           Προσθήκη ΝέαΛίσταΑμκα, .αμκα$:= ι
           Προσθήκη ΝέαΛίσταΑΦΜ, .αφμ$:= ι
           Προσθήκη ΝέαΛίσταΕπωνΟνομα .όνομ_επων$:=ι
           Βιογραφικό &Αυτό
           Τύπωσε "Καταχωρήθηκε..."
           ι++
     }
}
Κλείσε #κ
Τύπωσε "Τέλος ανάγνωσης"
Ταξινόμηση ΝέαΛίσταΕπωνΟνομα
Τύπωσε "Ταξινόμηση"
Πάτα_Διάστημα
Πενα 13 {
    Οθόνη , 0
    Αναφορά "Φάση Πέμπτη"
    Αναφορά "Αναζητήσεις στο αρχείο που έχουμε φορτώσει"
    Οθόνη , 4
}
Τύπωσε "Αναζήτηση αμκα: 12345123451"
Αν Υπάρχει(ΝέαΛίσταΑμκα, 12345123451) τότε {
      Τύπωσε "Βρέθηκε"
      Τύπωσε "Στό επώνυμο/όνομα: ";
      Πένα 11 { Τύπωσε άλλος(εκφρ(ΝέαΛίσταΑμκα)).όνομ_επων$}
}
Τύπωσε "Αναζήτηση ΑΦΜ: 052341234"
Αν Υπάρχει(ΝέαΛίσταΑΦΜ, "052341234") τότε {
      Τύπωσε "Βρέθηκε"
      Τύπωσε "Στό επώνυμο/όνομα: ";
      Πένα 11 { Τύπωσε άλλος(εκφρ(ΝέαΛίσταΑΦΜ)).όνομ_επων$}
}
Τύπωσε "Λίστα με αλφαβητική σειρά"
Πένα 15 {
      Επαναλήπτης=Κάθε(ΝέαΛίσταΕπωνΟνομα)
      Ενώ Επαναλήπτης {
            Τύπωσε Επαναλήπτης^+1, Άλλος(Εκφρ(ΝέαΛίσταΕπωνΟνομα)).όνομ_επών$            
      }
      Πένα 11 {
          Τύπωσε"",  "Με ανάποδη σειρά..."
      }
      Επαναλήπτης=Κάθε(ΝέαΛίσταΕπωνΟνομα Τέλος Εως Αρχη)
      Ενώ Επαναλήπτης {
            Τύπωσε Επαναλήπτης^+1, Άλλος(Εκφρ(ΝέαΛίσταΕπωνΟνομα)).όνομ_επών$            
      }
}
}
MODULE SUP {Super=Lambda -> {
    SuperClass A {
    Unique:
        counter
        Function Add2counter {
              .counter++
              =.counter
        }
    Private:
        Function Many  {
              For SuperClass {
                    =.counter
              }                  
        }
    Public:
        id=0
        stuff$=""
        Property Total {
              value {
                   link parent Many() to Many()
                   value=Many()
              }
        }
        Value (a$="") {
            if a$="" else
                .stuff$<=a$
                For this, SuperClass {
                    .id<=..Add2Counter()
                }
            end if
            =This
        }
        \\ without Set because we have value, the group  use as read only
        \\ but we want to get a copy.
        Set {
            Read tmp
            if tmp.id<>.id then Error "not allowed to copy this"
            \\ do not use  This=Group(tmp) or This = tmp
            \\ because you are in This=
            \\ so we use Let, because Let is a set of two statements:
            \\ A push and a Read, so Let This=tmp  is push tmp: read This
            \\ The Read This not call Set function
            Let This=tmp
        }
    }
    \\ A is superclass has all members inside
    \\ a superclass always return a group with a pointer to superclass
    =A
}()   ' auto execute using ()
A=Super("Babis")
A1=A
B=Super("George")
C=Super("Sofia")
Print A.id, A.stuff$
Print A1.id, A1.stuff$, " a copy of A"
Print B.id,  B.stuff$
Print C.id,  C.stuff$
Print "Total New Names:";A.total

Module Inner (Z) {
	Print  Z.id, Z.stuff$
	M=Z
	M=M("New Name")
	\\ So now we get: 4  New Name
	Print M.id,  M.stuff$
}
\\ We pass by value, bat superclass passed  using pointer
Inner B
\\ And at return from Inner
\\ We make another one the 5th
D=Super("Last Name")
Print D.id, D.stuff$
Print "Total New Names:"; A.total
Try ok  {
    Print "try to copy A to B"
    B=A
}
\\ If Ok is  False the error is in the level of Try block
\\ but we check Error if we have error deeper
If ok Then Print "Error not in Try at first level"
If Error Then
	Print "Error from something we call  in Try Block"
	Print "B=A";Error$
	Print "Error value now is 0. Each time we read Error change to "; Error
End if

}
MODULE REMTST {module test1 {
	Pen 15 {Print "test1: Deconstructor called automatic"}
	class alfa {
		remove {
			Print "remove"
		}
	}
	Dim A(10)<<Pointer(alfa())
	Print "delete 5"
	Dim A(5)
	Print "Now exit"
}
module test2 {
	Pen 15 {Print "test2: insert 8001 variables"}
	For i=1 to 8000
		local i 
	next i
	Print "now make a pointer to point a group"
	class alfa {
		remove {
			for i=1 to 10000
			local i
			next
			print "ok"
		}
	}
	m->alfa()
	Print "now module end and deconstructor make 10001 variables"
}
module test3 {
	Pen 15 {Print "test3: A class with a group and one inner group"}
	class alfa {
		remove {
			clear .zeta
			Print "top removed"
		}
		group zeta {
			remove {
				print "inner group zeta removed"
			}
		}
	}
	Print "We make a new stack for values for immediate use"
	Stack New {
		Push alfa()
		Print "now stack erased"
	}
	Print "The inner .zeta removed when we use Clear .zeta inside top deconstructor"
	Print "Now we make a tuple with one item of class alfa()"
	A=(alfa(),)
	Print "end module so tuple erased, and automatic deconstructor executed"
}
module test4 {
	Pen 15 {Print "test4: A class with a group and one pointer to group"}
	class beta {
		remove {
			Pen 11 {print "group class beta removed"}
		}
	}
	class alfa {
		remove {
			clear .zeta
			Print "top removed"
		}
		zeta=Pointer(Beta())
	}
	Print "we make K as named group, not a pointer"
	K=alfa()
	Print "we can execute top group remove function using Clear K"
	Print "but for the example we leave it as is"
	Print "so expected only the pointer to execute the remove function"
}
test1
test2
test3
test4
cursor 5
Report {
	   M2000 Interpreter start with a minimum of 3000 places for variables in an array of variants and a hash table for searching.
	Each time we need more than current variables capacity the variables array and hashtable doubled in size. The new limit may reduced when a module exit.
	When that happen at the reducing, if an object need to execute the Remove member (Deconstructor) then new variables added and a new reducing happen (becaue the member called as module).
	Hashtable has two arrays, an array of keys and other stuff, and the hash array. When we change the size of hash table a new rehashing happened.
	The hash algorithm produce two numbers, one depend from key, and the second depend from first number and size of hash table. Hash table has two times and some more items to avoid collisions. When a collision dedected the new item get the old item in linked list and placed first, as the hash table indicate.
	So when two times (or more) reender the reducing function, a static variable prevents except the first one to reduce the array, and only make a cleaning process. So expanding may happen but reducing happen once, for the first call.
	Old versions from 9.9 revision 28, cant did that, because of arrays locks. To prevent lock, was easy. We get the pointer in a variant as a copy, then we place nothing to array place, and then we place nothing to variant which fires the remove member. Also old versions have a bug when reducing the variables array, so the removing function had array index overflow error. Because interpreter compiled without index control to internal arrays, a hang was the result of that bug. The bug was not a problem in previous revisions, because never happen reentrance of the reducing function, and other part of code balanced the use of these arrays nice.
	}, width-10
}
MODULE OOP_GR_EX {Δρομέας 5
Αναφορά {
	Αποστολή λουλουδιών - Παράδειγμα από το σχολικό βιβλίο της 3ης Λυκείου
	
	Με χρήση γεγονότων, και διαδοχικών γεγονότων, προς τα πίσω
	Το παράδειγμα του βιβλίου δείχνει ενέργειες σε κουτάκια αναπαράστασης αντικειμένων. Αυτά τα κουτιά έχουν μια χρησιμότητα αλλά μικρή. Το ζήτημα εδώ είναι να φανεί πως τα αντικείμενα μπορούν να ξεχωρίσουν από το πως καταχωρούνται τα δεδομένα. Έτσι ενώ έχουμε κλάσεις που ομαδοποιούν στοιχεία, και έχουν ενσωματωμένη λογική σε μεθόδους, δεν έχουμε μια ιδέα για το που βρίσκονται τα αντικείμενα, που αποθηκεύονται και πως γίνεται μέσα από το αντικείμενο να συνδεόμαστε με μια αποθήκη άγνωστη σε αυτό!
	Εδώ τα αντικείμενα κάνουν κλήσεις σε γεγονότα. Αν δεν γράψουμε συναρτήσεις εξυπηρέτησης γεγονότων οι κλήσεις θα γίνονται σε "άδειες" συναρτήσεις.
	Τα ιδιαίτερα χαρακτηριστικά αυτών των συναρτήσεων είναι:
		1	Πρέπει να ορίσουμε ένα επώνυμο αντικείμενο για να στέλνει στο τμήμα που το ορίσαμε τις κλήσεις.
		2	Οι συναρτήσεις τρέχουν σαν να είναι κώδικας του τμήματος που γράφτηκαν.
		3	Για το λόγο (2) διαβάζουμε τιμές με την Διάβασε Νέο όταν θέλουμε μια μεταβλητή  να δημιουργηθεί οπωσδήποτε.
		4	Επίσης νέες μεταβλητές τις γράφουμε με το Τοπική ή Τοπικές. Ακόμα και πίνακες να κάνουμε θα γράψουμε Τοπική Α(10).
		5	Λόγω του (2) βλέπουμε ότι μεταβλητές, τμήματα και συναρτήσεις έχουμε ορίσει στο τμήμα.
		6	Αυτές οι συναρτήσεις γεγονότων δεν επιστρέφουν τιμή με το =
		7	Αν θέλουμε χρησιμοποιούμε πέρασμα με αναφορά με χρήση του & πριν το όνομα.
	
	Στο πρόγραμμα ορίζουμε σε μια μέθοδο του Ανθοπώλη ένα νέο αντικείμενο Ανθοπώλης με γεγονότα. Υπάρχει γεγονός που καλεί ο "εσωτερικός" Ανθοπώλης και η συνάρτηση εξυπηρέτησης καλεί το γεγονός του Ανθοπώλη που περιέχει τον εσωτερικό. Ο εσωτερικός διαλέγεται με γεγονός.
	
	Τα ονόματα Μαμά, Γιώργος, Τζιοβάνι, Αντόνιο, Πέπε, Αντόνιο βρίσκονται έξω από τα αντικείμενα. Όλο το πρόγραμμα είναι μια γραμμή:
	
	Παραγγελία("Μαμά", "Γιώργος", "Άννα")
	
	Η Παραγγελία() είναι ρουτίνα. Μέσα σε αυτήν κάνουμε όλη την εργασία, ενώ σε ένα σημείο μεταφέρεται εντός του Κύριου αντικειμένου, όπου εργάζεται ο συνεργάτης του αρχικού. Για να αντιληφθεί κανείς τον τρόπο που "μπαίνουν" αντικείμενα μέσα σε αντικείμενα:
	
	Δείτε αυτό:  Συνάρτηση ΑποδέχεταιΣυνεργασία(Πελάτης) που είναι μέλος της κλάσεως Ανθοπώλης. Εκεί δημιουργούμε ένα "κενό" Ανθοπώλη και καλούμε ένα γεγονός με πέρασμα του "κενού" με αναφορά. Αν υπάρχει ανθοπώλης για συνεργασία, θα μπει σε αυτό το "κενό". Έτσι με την επιστροφή από το γεγονός θα συμβαίνουν ένα από τα δύο:
		1	Να υπάρχει συνάρτηση εξυπηρέτησης οπότε θα έχουμε ένα όνομα τουλάχιστον μέσα στα μέλη του Ανθοπώλη
		2	Να μην υπάρχει κάτι οπότε θα γυρίσει κενός όπως τον στείλαμε. Ελέγχουμε το όνομα και ανάλογα πράττουμε.
	
	
	}, πλάτος-10
Τύπωσε
Κλάση Πελάτης {
      Όνομα$, Επώνυμο$, Διεύθυνση$,
      Τηλέφωνο$, Emali$
      Συνάρτηση ΚάνειΠαραγγελια  (&Ανθοπώλης, Εκει$){
            =Ανθοπώλης.ΔέχεταιΠαραγγελία(&Αυτό, Εκει$)
      }
      Τμήμα ΠαραλαμβάνειΑνθοδέσμη {
            Τύπωσε "Παραλήφθηκε"
      }
Κλάση:
	Τμήμα Πελάτης (.Όνομα$) {}
}
Κλάση Ανθοπώλης {
      Γεγονότα "ΒρεςΑνθοπώλη", "ΒρεςΑνθοδέτη"
      Γεγονότα "ΒρεςΤαχυμεταφορέα", "ΒρεςΠελάτη"
      Γεγονότα  "ΑνάθεσηΑνθοπώλη", "ΑνάθεσηΑνθοδέτη"
      Επωνυμία$,
      Όνομα$, Επώνυμο$,
      Διεύθυνση$, ΑΦΜ$,
      Τηλέφωνο$, Emali$,
      Τραπεζικός_Λογαρασμός$, Κωδ_Δικ_Συν
      Συνάρτηση ΔέχεταιΠαραγγελία (&Πελάτης, Εκει$) {
            Πελάτης=Πελάτης()
            Κάλεσε Γεγονός "ΒρεςΠελάτη", Αυτό, &Πελάτης, Εκει$
            Αν Πελάτης.Όνομα$="" Τότε Έξοδος
            \\ φτιάχνουμε ένα Ανθοπώλη εντός ενός Ανθοπώλη
            \\ με γεγονότα. Αρχικά είναι κενός-χωρίς στοιχεία
            \\ αλλά παρακάτω θα του βάλουμε στη ζήτηση συνεργασίας
            Ομάδα ΜεΓεγονότα Ανθοπώλης=Ανθοπώλης()
            Συνάρτηση Ανθοπώλης_ΒρεςΑνθοδέτη(Νέο &ποιος, &ανθοδέτης, Προορισμος$)  {
                  Τύπωσε "ο ";ποιος.ονομα$;" κοιτάει για Ανθοδέτη"
                  Κάλεσε Γεγονός "ΒρεςΑνθοδέτη", ποιος, &ανθοδέτης, Προορισμος$
                  Αν ανθοδέτης.Όνομα$="" Τότε Τύπωσε "Δεν βρέθηκε Ανθοδέτης": Έξοδος
                  Τύπωσε "Βρέθηκε Ανθοδέτης ο ";ανθοδέτης.Όνομα$
                  \\ εδώ μεσολαβεί κώδικας που δίνει πληροφορίες στον ανθοδέτη
                  \\ και αμέσως μετά τον καταχωρούμε πίσω στη βάση
                 Κάλεσε Γεγονός "ΑνάθεσηΑνθοδέτη", ποιος, &ανθοδέτης
            }
            Συνάρτηση Ανθοπώλης_ΒρεςΤαχυμεταφορέα {
                Πένα 15 {Τύπωσε "Διαδοχικό γεγονός"}
                Κάλεσε Γεγονος "ΒρεςΤαχυμεταφορέα" Διαδοχικό
                \\ μεταφετει τις παραμέτρους όπως τις λαμβάνει
                \\ στο παραπάνω αντικείμενο
            }
            .ΖητάΣυνεργασία &Ανθοπώλης, Πελάτης.Όνομα$
            Αν Ανθοπώλης.ΑποδέχεταιΣυνεργασία(Πελάτης) Τότε
                Τύπωσε "όλα καλά!"
                \\ πληρώνεται προκαταβολικά!
                =Αληθής
            Αλλιώς
                  Τύπωσε "Πρόβλημα συνεργασίας"
                  =Ψευδής
            Τέλος Αν
      }
      Τμήμα ΖητάΣυνεργασία (&Ανθοπώλης, Προορισμός$) {
                  Κάλεσε Γεγονος "ΒρεςΑνθοπώλη", Αυτό,  &Ανθοπώλης, Προορισμός$
      }
      Συνάρτηση ΑποδέχεταιΣυνεργασία(Πελάτης) {
            Αν .Ονομα$="" Τοτε Εξοδος
            Αν Πελάτης.Όνομα$="" Τότε Έξοδος
            Προορισμός$=Πελάτης.Όνομα$
            Ανθοδέτης=Ανθοδέτης()
            Κάλεσε Γεγονος "ΒρεςΑνθοδέτη", &Αυτό, &Ανθοδέτης, Προορισμός$
            Αν Ανθοδέτης.Όνομα$="" Τότε Έξοδος
            \\ Ανάθεση Ανθοδοσίας  Τζιοβάνι - Αντόνιο
            Αν .ΑναθέτειΑνθοδεσία(&Ανθοδέτης) Τότε
                Ποιος=Ταχυμεταφορέας()
                Κάλεσε Γεγονός "ΒρεςΤαχυμεταφορέα", Αυτο, &Ποιος, Προορισμός$
                Αν Ποιος.Ονομα$<>"" Τότε
                    Ενώ Ανθοδέτης.ΕτοιμάζειΑνθοδέσμη()
                             \\ αναμονή μέχρι να την φτιάξει
                             \\ περιμένουμε Ψευδής για να τερματίσει η Ενώ
                    Τέλος Ενώ
                    Τύπωσε "Έτοιμη η ανθοδέσμη από τον ";Ανθοδέτης.Όνομα$
                    .ΑναθέτειΠαράδοση &Ποιος, Προορισμός$
                    Τύπωσε "ο ";Ποιος.Όνομα$;" παραδίδει στο προορισμό ";Προορισμός$
                    Ενώ Ποιος.ΠαραδίδειΑνθοδέσμη(&Πελάτης)
                \\ γίνεται άμεσα!
                    Τέλος Ενώ
                    =Αληθής
                Αλλιώς
                    Τύπωσε "Ατυχία δεν έχω άτομο να την παραδόσω"
                Τελος Αν
            Τέλος Αν
      }
      Συνάρτηση ΑναθέτειΑνθοδεσία(&Ανθοδέτης) {
            \\ εδώ πρέπει να έχουμε ασύγχρονη λειτουργία
            \\ έστω ότι το κάνει άμεσα!
            \\ η Ενώ είναι σαν την Όσο της ΓΛΩΣΣΑΣ
            Τύπωσε "Ο ";Ανθοδέτης.Όνομα$;" ετοιμάζει την ανθοδέσμη άμεσα"
            =Αληθής
      }
      Τμήμα ΑναθέτειΠαράδοση (&Ταχυμεταφορέας, Εκει$) {
             \\ Την Αννα την βρίσκει από μια λίστα εκκρεμοτήτων.
             \\ Παράδοση Πέπε - Άννα
            
       }
Κλάση:
      Τμήμα Ανθοπώλης (.Όνομα$) {}
 }
Κλάση Ανθοδέτης {
      Επωνυμία$,
      Όνομα$, Επώνυμο$, Διεύθυνση$,
      ΑΦΜ$, Τηλέφωνο$,
      Emali$, Ειδικότητα$, Ωριαία_αμοιβή
      Συνάρτηση  ΕτοιμάζειΑνθοδέσμη {
            \\ όσο ετοιμάζει είναι αληθής
            \\ εδώ δίνουμε άμεσα ψευδής
            \\ την ετοίμασε σε χρόνο dt
            =Ψευδής
      }
Κλάση:
	Τμήμα Ανθοδέτης (.Όνομα$) {}
}
Κλάση Ταχυμεταφορέας {
      Επωνυμία$,
      Όνομα$, Επώνυμο$, Διεύθυνση$,
      ΑΦΜ$, Τηλέφωνο$,
      Emali$,   Τύπος$
      Συνάρτηση ΠαραδίδειΑνθοδέσμη (&Πελάτης){
          \\ με Αληθής ακόμα παραδίδει, με ψευδής παρέδωσε
                Πελάτης.ΠαραλαμβάνειΑνθοδέσμη
          =Ψευδής
      }
Κλάση:
      Τμήμα Ταχυμεταφορέας (.Όνομα$) {}
}
\\\ Καταστάσεις με αντικείμενα (όλες με κλειδί το όνομα)
Κατάσταση Πελάτες= "Μαμά":=Πελάτης("Μαμά"), "Άννα":=Πελάτης("Άννα")
Κατάσταση Ανθοδέτες="Αντόνιο":=Ανθοδέτης("Αντόνιο")
Κατάσταση Ταχυμεταφορείς="Πέπε":=Ταχυμεταφορέας("Πέπε")
Κατάσταση Ανθοπώλεις ="Γιώργος":=Ανθοπώλης("Γιώργος"), "Τζιοβάνι":=Ανθοπώλης("Τζιοβάνι")


\\ εδώ είναι η ρουτίνα που λέει ποιος κάνει παραγγελία, σε ποιον και για ποιον
\\ Ότι φτιάχνουμε στη ρουτίνα διαγραφεται στο τέλος
Παραγγελία("Μαμά", "Γιώργος", "Άννα")
\\ Οπότε σε αυτό το σημείο υπάρχουν ως μεταβλητές μόνο οι καταστάσεις ειδών
\\ οι οποίες είναι τοπικές, δηλαδή θεατές μόνο εδώ και στη Ρουτίνα.
\\ Από τμήμα/συναρτήσεις υπάρχουν οι ορισμοί των κλάσεων που χρησιμοποιούνται ως γενικές συναρτήσεις
\\ δηλαδή είναι θεατές παντού

Τέλος
\\ Οι ρουτίνες γράφονται στο τέλος
\\ ο προορισμός παραμένει όνομα μέχρι να το κάνει αντικείμενο ο ανθοπώλης
\\ διαβάζοντας την βάση
Ρουτίνα Παραγγελία(Πελάτης$, Ανθοπώλης$, Προορισμός$)
    Τοπική Μαμά=Πελάτες(Πελάτης$)
    Τοπική Ομάδα ΜεΓεγονότα Κύριος=Ανθοπώλεις(Ανθοπώλης$)
    \\ Συναρτήσεις εξυπηρέτησης γεγονότων, για το αντικείμενο Κύριος
    Συνάρτηση Κύριος_ΒρεςΠελάτη (Ποιος, &Πελάτης, Εκει$) {
        Τύπωσε "ο ";Ποιος.Όνομα$;" ψάχνει Πελάτη ";Εκεί$;" στη βάση"
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            Τύπωσε "Βρέθηκε"
        Τελος αν
    }
    Συνάρτηση Κύριος_ΒρεςΑνθοπώλη (Νέο Ποιος, &Ανθοπώλης, Εκει$) {
        Τύπωσε "ο ";Ποιος.Όνομα$;" ψάχνει Ανθοπώλη"
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            \\ υποτίθεται ότι γίνεται αναζήτηση βάσει διευθύνσεων
            Τύπωσε "Για πελάτη ";Πελάτης.Όνομα$;" θα χρειαστούμε τον Τζιοβάνι"
            \\ αν σκιάσουμε την παρακάτω γραμμή δεν θα βρεθεί ο Τζιοβάνι!
            \\ σκιάζω γραμμή σημαίνει βάζω \\ για να γίνει σημείωση
            Ανθοπώλης=Ανθοπώλεις("Τζιοβάνι")
        Τελος αν
    }
    Συνάρτηση Κύριος_ΒρεςΑνθοδέτη (Νέο Ποιος, &Ανθοδέτης, Εκεί$)  {
        Τύπωσε "ο ";Ποιος.Όνομα$;" ψάχνει Ανθοδέτη για προορισμό ";Εκεί$
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            \\ υποτίθεται ότι γίνεται αναζήτηση βάσει διευθύνσεων
            Τύπωσε "Για πελάτη ";Πελάτης.Όνομα$;" θα χρειαστούμε τον Αντόνιο"
            Ανθοδέτης=Ανθοδέτες("Αντόνιο")   
        Τελος αν
    }
    Συνάρτηση Κύριος_ΑνάθεσηΑνθοδέτη (Νέο Ποιος, &Ανθοδέτης)  {
        Τύπωσε "ο ";Ποιος.Όνομα$;" αναθέτει Ανθοδέτη:"; Ανθοδέτης.Όνομα$
        \\ εδώ απλά το δείχνω ότι μπορώ να γυρίζω τη τρέχουσα κατάσταση
        \\ στη βάση. αλλά δεν το κάνω αλλού! Δεν χρειάζεται για το παράδειγμα
        Επιστροφή Ανθοδέτες, Ανθοδέτης.Όνομα$:=Ανθοδέτης
    }
    \\  Νέο &ποιος, &μεταφορέας, Προορισμός$
    Συνάρτηση Κύριος_ΒρεςΤαχυμεταφορέα (Νέο Ποιος, &Ταχυμεταφορέας, Εκεί$){
        Τύπωσε "ο ";Ποιος.Όνομα$;" Ψάχνει Ταχυμεταφορέα για προορισμό ";Εκεί$
        Αν Υπάρχει(Πελάτες, Εκει$) Τότε
            Πελάτης=Εκφρ(Πελάτες)
            \\ υποτίθεται ότι γίνεται αναζήτηση βάσει διευθύνσεων
            Τύπωσε "Για πελάτη ";Πελάτης.Όνομα$;" θα χρειαστούμε τον Πέπε"
            Ταχυμεταφορέας=Ταχυμεταφορείς("Πέπε")
        Τελος αν
    }
    Αν Όχι Μαμά.ΚάνειΠαραγγελια(&Κύριος, Προορισμός$) τότε
        Τύπωσε "Δεν μπορεί να γίνει η παραγγελία"
    Τέλος Αν
Τέλος Ρουτίνας
}
MODULE FORMTARGET {\\ FROM 9.9 REVISION 29
\\ WE CAN PLACE TARGETS ON FORMS
\\ TARGETS ARE LIGHTWEIGHT OBJECTS
\\ WE MAKE IT ONCE

\\ STATEMENTS:
\\ TARGET  (2 VARIATIONS, ONE TO DEFINE AND ONE TO ENABLE/DISABLE)
\\ CHANGE  WE HAVE NAMED ARGUMENTS HERE
\\ TARGETS NEW  (WE CAN ERASE PER FORM)
\\ THEY DON'T NEED A SCAN STATEMENT (USED FOR CONSOLE ONLY)
\\ OLD VERSIONS OF M2000 AND THE LAST ONE CAN USE THE BASIC TARGETS

\\ FORM TARGETS VS BASIC TARGETS
\\ BASIC TARGETS CAN BE USED TO EXECUTE A LINE OF STATEMENST AT GLOBAL SCOPE
\\ FORM TARGETS EXECUTE CODE AT THE SAME SCOPE WHERE FORM DEFINED

\\ EACH TARGET HAS TWO FUNCTIONALITIES:
\\ BASIC TARGET:  SEND KEYS TO CONSOLE/EXECUTE CODE TO GLOBAL SCOPE
\\ FORM TARGET:  SEND EVENT TARGET/ EXECUTE CODE TO MODULE SCOPE
\\ EVENT TARGET IS COMMON FOR ALL TARGETS, SENDING THE HANDLER OF TARGET


\\ ONE PARAMETER BEFORE THE LASTING TEXT:
\\ CAN BE 1 TO 9 FOR POSITION OF TEXT, +10 TO USE "SEND" FUNCTION
\\ +100 TO USE PROPORTIONAL TEXT RENDERING.
\\ A 5 IS CENTER VERTICAL END HORIZONTAL.

\\ BASIC TARGETS CAN BE USED IN 34 LAYERS: BACKGROUND, CONSOLE, PLAYERS (32 MAX).
\\ TO SCAN FOR THEM WE USE SCAN STATEMENT USING A NUMBER FOR A TIME WINDOW.

\\ TARGETS VS BUTTONS ON FORMS
\\ A BUTTON IS A CONTROL, WITH METHODS AND PROPERTIES.
\\ TAB AND SHIFT TAB CAN CHOOSE ANY ENABLED BUTTON TO GET FOCUS
\\ TARGETS HAVE NO FOCUS. USED ONLY WITH MOUSE
\\ EACH TARGET IS AN ARRAY OF DATA TO BE USED FOR RENDERING AND SCANNING
\\ SCANNING HAPPEN AT THE MOUSE DOWN EVENT. SO TARGETS GET A CLICK ONLY
\\ BUTTONS GET DOUBLE CLICK, OR SHIFT CAPTION LEFT, OR ENTER, BUT NOT A SIMPLE CLICK

REM Title "ok11", 0

Declare form1 Form
m=false
Module zz {
	\\ target call zz to own object
	\\ so we have to use Layer {} to send to console
	Layer {
		print "ok", timecount
		refresh
		}
	change A, text "ok"
}
Function form1.MouseDown {
	Stack
	refresh
}
Function form1.Target {
	\\ normal events executed to console
	\\ so we have to use Layer to redirect to Form1 layer
	read new code
	local x,y, x1, y1
	Layer Form1 {
		(x,y)=(mouse.x, mouse.y)
		while mouse=1
			change code, back 7
			(x1,y1)=(mouse.x, mouse.y)
			if x1<>x or y1<>y then change code, back 2: break
			refresh
		end while
		Target A, m
		if m then
			change A, back 2
		else
			change A, back 0
		end if
		 change code, back 2
	}
	m~
}
Layer form1 {
	window 12, 12000, 8000
	form 32, 20
	motion.w;  ' center window
	cls #333333, 0
	cursor 4, 4
	\\ we use immediate execution, in this module
	\\ so we call zz as this module (call local pass current scope to zz)
	target A, "call local zz", 10, 2, 2,15, 105, "press me"
	cursor 4, 8
	\\ 115 means 5 center, 10 use target event, 100 proportional font rendering
	target B,"?", 10, 2, 5,15, 115, "press me too"
}
Method form1,"show",1
Declare form1 nothing
Title "ok11", 1
}
MODULE MULTIASSIGN {Dim B(10)=0
(A,B$,B(1))=(100, "Yes", 4)
Print A, B$, B(1)
\\ global X, Y
Set (X,Y)=(4, 5)
Print X, Y
\\ global shadow old global
Set (New X, Y)=(5, 6)
Push (A, B(1))
\\ Set exexute in command line, so A and B(1) isn't visible
\\ we have to place values in stack, so the Set statement get the current stack
\\ and array return the array
Set (X, Y)=Array
Print X, Y
List
\\ define a multi return value as array
Function Alfa(){
	=100, 200
}
(M, N)=Alfa()
Print M, N
Dim Z()
Z()=(1,2)
(M, N)=Z()
Print M, N
}
MODULE CLASS1 {// update with types
Form 80,50
// counters supposed we provide them from a file
global LastCustomerId=100, ReportId=80
//
class person {
Private:
	name$, address$, phone$, id
class:
	module person (.name$, .address$, .phone$) {
		LastCustomerId++
		.id<=LastCustomerId
	}	
}

class customer as person {
	Inventory sales
	Class bill {
	Private:
		day$, time$, id
	Public:
		// read only property (is a group inside group)
		Property euro {value}
		Function Key$ {
			=.day$+"/"+.time$+"#"+str$(.id,"")
		}
	class:
		Module bill (.day$, .time$, .id, .[euro]) {
		}
	}
	Module CustomerData {
		ReportId++
		Print "Report date:"; Date$(Today)
		Print "ReportId:";ReportId
		Print "Customer:";.id
		Print "Name",.name$
		Print "Address",.address$
		Print "Phone", .phone$
		Print "Transactions:";len(.sales)
		m=each(.sales)
		sum=0
		While m {
			bill=eval(m)
			sum+=bill.euro
		}
		Print "Total Euro:";sum
	}
	Module InsertBill (bill as bill) {
		try {
			Print "New bill:";bill.key$();" for customer ";.id
			Append .sales, bill.key$():=bill
		}
	}
Class:
	Module customer (Where, m as person) {
		this<=m
		append where, .id:=This
	}
}

Inventory Customers
Pen 15 {Print "Adding to Customers"}
For This {
	// this is a block for temporary definitions
	K=Customer(Customers, person("George","Athens","0912399"))
	K.CustomerData
	// after that group K deleted
}
Pen 15 {Print "Using key to customers to add bills"}
For Customers(LastCustomerId) {
	.InsertBill .bill("20200522", "18:33", 1023, 100)
	.InsertBill .bill("20200526", "09:10", 3129, 150)
	.InsertBill .bill("20200530", "13:20", 5418, 25)
	.CustomerData
}
Pen 15 {Print "Using Iterator 1 - working at original data"}
M=each(Customers)
While M {
	// we extract key using eval$(M!)
	// so we can work from original data
	For Customers(eval$(M!)) {
		.CustomerData
	}
}
Pen 15 {Print "Using Iterator 2  - working at a copy of data"}
M=each(Customers)
While M {
	// or using a copy of data
	K=Eval(M)
	For K  {
		.CustomerData
	}
}
}
MODULE JAVALIKE {\\ to bypass a function we can use this
\\ function alfa {=.beta(![])}
\\ [] is the current stack and when we read it, we get a pointer and leave an empty stack as current stack
\\ so anything we pass to alfa() passed to .beta(), the dot is This, so to This.Beta()

\\ here we use toString$() to call super.toString$() without parameters
\\ For modules is very easy because a module get the current stack
\\ so if we have a member Module alfa {.beta} calling alfa 10,20 is like calling .beta 10, 20 (and all other values the current stack have)

\\ Constructors are modules but called from functions so they get the function's stack (a new one)
\\ Also a constructor skip the erasing phase (the function which call the module do this)
\\ We need this because we can expand the This object.


Report {
	there is no super like java super in M2000 when we use inheritance through classes
	see Superclass (example SUP) which is something differnent
	}


class Shape {
private:
    super.X, super.Y
    Function super.toString$(a=10) {
        ="Shape(" + str$(.super.X,"") + ", " + str$(.super.Y,"") + ")"
    }
public:
       Module final setPosition (px, py) {
           .super.X <= px
           .super.Y <= py
       }
        Function toString$() {
        =.super.toString$()
    }
}
class MoveShape {
      Module MoveRelative(xr, yr) {
            .super.X+=xr
            .super.Y+=yr
      }
}
class Circle as MoveShape as Shape {
private:
    radius
public:
    Module setRadius (r) {
        .radius <= r
    }
    Function toString$() {
        = .super.toString$() + ": Circle(" + str$(.radius,"") + ")"
    }
}

class Rectangle as MoveShape  as Shape {
private:
    height, width
public:
      Module MoveLeftSide (p as *Rectangle) {
      \\ for same type objects private members are like public
           for This, p {
               .super.X<=..super.X+..width
               .super.Y<=..super.Y
           }
      }
    module setDimensions (h,w) {
        .height <= h
        .width <= w
    }
    Function toString$() {
       = .super.toString$() + ": Rectangle(" + str$(.height,"") + " x " + str$(.width,"") + ")"
    }
}
c =Circle()
r = Rectangle()

r.setPosition 1, 2
r.setDimensions 50, 50
c.setPosition 3, 4
c.setRadius 10
Print r.tostring$()
Print c.tostring$()
r.MoveRelative 100,100
c.MoveRelative -50,-50
Print r.tostring$()
Print c.tostring$()

Report  {
	wokring with pointers like in c++
	pointers in M2000 are objects, so null pointer (pc->0&) isn't a zero, but an empty Group (object)
	}
pc->circle()
pr->rectangle()
pr=>setPosition 1, 2
pr=>setDimensions 50, 50
pc=>setPosition 3, 4
pc=>setRadius 10
Print pr=>tostring$()
Print pc=>tostring$()
\\ we can open up to ten objects (from one to ten dots, normaly one to three)
\\ if we use nestef for object {} also we have up to ten objects in total
\\ every for object {} is an area for temporary definitions, after exit from brackets
\\ any new definition erased.
For pr, pc {
	.MoveRelative 100,100
	..MoveRelative -50,-50
	Print .tostring$()
	Print ..tostring$()
}
pr2->rectangle()
pr2=>SetDimensions 30, 30
pr2=>MoveLeftSide pr
Print pr2=>toString$()
}
MODULE ΚΛΑΣΗ1 {Κλάση Ζώο {
Ιδιωτικό:
	πόδια=0
	ήχος$="τίποτα"
Δημόσιο:
	Συνάρτηση Τελική ΠόσαΠόδια() {
		=.πόδια
	}
	Συνάρτηση ΚάνωΉχο$() {
		=.ήχος$
	}
}
Κλάση Κατοικίδιο ως Ζώο {
Ιδιωτικό:	
	όνομα$
	Μήνυμα$="Με φωνάζουν {0} και είμαι κατοικίδιο με {1} πόδια και όλη μέρα {2}"	
Δημόσιο:
	Συνάρτηση Μήνυμα$() {
		=.Μήνυμα$
	}
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$
	}
Κλάση:
	Τμήμα Κατοικίδιο {
		Διάβασε .όνομα$, .ήχος$, .πόδια
	}
}
Κλάση Σκύλος ως Κατοικίδιο {
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$+" και είμαι σκύλος"
	}
Κλάση:
	Τμήμα Σκύλος(.Όνομα$)	{
		.πόδια<=4
		.ήχος$<="γαβγίζω"
	}
}
Κλάση Γάτα ως Κατοικίδιο {
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$+" και είμαι γάτα"
	}
Κλάση:
	Τμήμα Γάτα(.Όνομα$)	{
		.πόδια<=4
		.ήχος$<="νιαουρίζω"
	}
}
Κλάση Πουλί ως Κατοικίδιο {
Ιδιωτικό:
	τύπος$="κάτι"
	Μήνυμα$="Με φωνάζουν {0} με {1} πόδια και φτερά και όλη μέρα {2}"
Δημόσιο:
	Συνάρτηση ΜεΦωνάζουν$() {
		=.όνομα$+" και είμαι "+.τύπος$
	}
Κλάση:
	Τμήμα Πουλί(.Όνομα$, .τύπος$)	{
		.πόδια<=2
		.ήχος$<="κελαηδάω"
	}	
}
Εγγραφο ΌλαΜαζι$={Τελική Αναφορά
}
Αζορ=Σκύλος("Αζόρ")
Τι(Αζορ)
Ψιψίνα=Γάτα("Ψιψίνα")
Τι(Ψιψίνα)
Φλοξ=Πουλί("Φλοξ", "καναρίνι")
Τι(Φλοξ)
ΆλλοΚατοικίδιο=Κατοικίδιο("Ντορή", "χλιμιντρίζω", 4)
Τι(ΆλλοΚατοικίδιο)
\\ στέλνουμε στο πρόχειρο την αναφορά
Πρόχειρο ΌλαΜαζι$

Τέλος
\\ Η ρουτίνα δέχεται οτιδήποτε είναι κατοικίδιο
\\ έτσι δέχεται Κατοικίδιο, Γάτα, Σκύλος, Πουλί
Ρουτίνα Τι(Α ως Κατοικίδιο)
	Τοπική Εξ$=Μορφή$(Α.Μήνυμα$(),Α.ΜεΦωνάζουν$(), Α.ΠόσαΠόδια(), Α.ΚάνωΉχο$())
	ΌλαΜαζι$=Εξ$+{
	}
	Αναφορά Εξ$
Τέλος Ρουτίνας
}
MODULE PRIVATE {\\ example for private class, and private group made from private class
class beta {
private:
	class alfa {
	private:
		m=10
		c=0
	public:
		group counter {
			value {
				link parent c to c
				=c
			}
		}
		value {
			=.m
			.c++
		}
		set {
			read .m
			.c++
		}
	}
	alfa M
	dim a()
Public:
	Module Doit {
		Print  .M, .M, .M, .M.counter=3
		Push 1,2,3
		Read .M, .M, .M
		Print .M.counter=6
		.M<=10
		Print .M
		Print .M.counter=8
		dim .a(5)=group(.M)
		For i=0 to 4:.a(i)=i:Next
		for i=0 to 4
			Print .a(i), .a(i).counter=10
		next
		z=list:= 1:=group(.M), 2:=group(.M)
		Print z(1), z(2)
		Print z(1).counter=9, z(2).counter=9
		Print type$(z,1)="Group"
		Return z, 1:=500
		Print type$(z,1)="Double"
		p->z(2)
		Print p=>counter=9
		p=>=1234
		Print p=>counter=10
		Print  eval(p)=1234
		Print p=>counter=11
		Print eval(z(2))=1234
		Print p=>counter=12
		k=.A()
		\\ k#eval(3) execute value { } from a copy of A(3)
		Print k#eval(3)=3
		\\ k#val(3) extract a copy of group
		MM=k#val(3)
		Print MM.counter=10
		Print .A(3)=3, .A(3).counter=11
		\\ pointers may change where points to
		p->.A(3)
		Print eval(p)=3, p=>counter=12, .a(3).counter=12
		\\ dot is This.
		Print This.a(3).counter=12
	}
}
Z=beta()
Z.Doit
List
Modules ?
}
MODULE PRV_STR {\\ a simple example 2 - class in class in class
\\ creating classes which return string value
class delta {
class:
private:
	class beta {
	Private:
		class z$ {
		private:
			what$
			val=counter
		public:
			value {
				=.what$+str$(.val)
			}
		class:
			\\ constructor
			module z (.what$) {
			counter++
			}
		}
		z$ k("hello"), m("yes")
	Public:
		module doit {
			print .k$, .m$
			print .k is type z, .m is type z
		}
		Function ExtractTwo {
			=(.k, .m)
		}
	}
	\\ constructor
public:
	module delta {
		global counter=500
		b=.beta()
		b.doit
		c=.beta()
		c.doit
		this=.beta()
	}
}
z=delta()
print z is type delta
print z is type beta
List
Modules ?
module check (k as beta) {
	k.doit
}

check z

module check2 (&k as beta) {
	k.doit
}

(A1, A2)=z.ExtractTwo()

Print A1$, A2$
Print A1 is type z, A2 is type z
\\ we make a group to have same type
Group Trait$ {
	type:z
	Value (a as z, b as z) {
		="two names: "+a.what$+"/"+b.what$
	}
}
Print Trait$(A1, A2)
\\ now with no type
Group Trait2 {
	Function Two$(a as z, b as z) {
		="two names: "+a.what$+"/"+b.what$
	}
}
A3=A1 with Trait2
Print A3 is type z
Print A3.Two$(A1, A2)


}
MODULE GROUPTYPES {// from revision 33 version 9.9 we have group types
Report {First Example
Theory:
	Static groups may have a type or not.
	We can add one or more types by hand, using type: Type1, Type2, ...
	If a group created by other group automatic add types from that group
	if a group merged another group  automatic add that types from that group
	The type list inside group hold uniqe names
Practice:
	Call a method passing by reference checking for type. Private variables are available as public when objects have the same type. If two objects have no type then we have no equal types by default.
	
}
Group alfa {
// we can place any number of types
type: mytype1, mytype2
private:
		x=10, y=50
		L=lambda (k)->k*2+5
public:
	module process (&m as mytype1) {
		m.x++
		m.y+=m.L(3)
	}
	module changeL(fun) {
		.L<=fun
	}
	function toString$ {
		=format$("x={0} y={1}", .x, .y)
	}
	
}
beta=alfa
beta.changeL (lambda->1)
alfa.process &beta
Print beta.tostring$()

Report {

Second Example

Theory:
	A class definition automatic add a type: classname
	A class can be extended using previously dedined classes
	When we extent a class we say that as inheritance at source
	When we merge a group from another we say that as ingeritance at object
	A class can be in module level, or as group/class member
	In module level a class is global, until the end of module/function/sub execution, or the statement  For <object> { }, where the definition executed.
	In a class/group the class definition can be public or private.
Pracite:
	We define a class with an inner class and a group defined from inner class, The inner group define operator "="  and when we place a same type group process the operator process the operator using the private variables from the other group (is a copy of the other group). If the type isn't the same return false.
	We define false as boolean, because in M2000 true is double -1, and false is double 0, but all comparisons return boolean true and false. Any identtifier from M2000 vocabulary can be used localy in variables and modules definitions, except for those identifiers which used for flow control (like If, Repeat, While)
}
class delta {
	class zeta {
	private:
		x=10, y=50
	public:
		operator "=" {
			def boolean false
			read other
			if other is type zeta then
				push .x=other.x and .y=other.y
			else
				push false
			end if
		}
	}
	zeta One, Two
}
delta=delta()
Print delta is type delta
Print delta.One=delta.Two
Print delta.one=delta

//third example using pointers and types for group pointers too
Report {

Third Example

Theory:
	We can use pointers to groups. there are two kinds of pointers (this is hidden in use, except fron one condition as describe later)
	A true pointer hold the group alive. When no pointer point to a group the group deleted. We make a group pointer from any no named Group
	A false pointer hold the weak reference of a named Group (a static object). When the object erased, the false pointer hold the weak reference and nothing happen until we want to use it. Then the weak reference can't resolved to a real reference and we get an error.
	If Alfa is a group then M->Alfa or M=Pointer(Alfa) get a false pointer.
	To get a true pointer we use Parenthesis so M->(Alfa) or M=Pointer((A)) make a copy of A (as an unamed group) and the pass an object to it
	If we have an group in an array say ata A(5) then there we have an unamed group so M->A(5) give a true pointer.
	We can interchange values to pointers from any kind true or false.
	A M->0& place a pointer to an empty Group. There isn't a Null value. We can use group.count(M) to check for number of variable/arrays member.
	
	A trait: We define a group to add it to a final group, replacing a function, without a type
	We use final to those methods (modules, functions, operators) which can't changed if further merging happen at source or object ihhertitance.
	
Pracrice:
	We make class prive with private and public members. We make class epsilon as prive extenting with operator, and two functions, plus a constructor and a deconstructor. We start make some pointers from the class. The M3 is an epsilon type with a trait. So M3 has a class of types epsilon and prive, which are inheritance in code  plus a trait (with no type) which is inheritance at object level
	 We can use the pointers to operate the equal operator. From two functions add5() and sub5() we place pointer checking the type, and return a pointer for a new defined same type object, without calling the constructor because we make it using a copy of current object, and becaue has the same type we can change private variables too.
}
class prive {
private:
	x, y
public:
	function ToString$ {
		=format$("private data: x={0}, y={1}", .x, .y)
	}
}
class epsilon as prive {
public:
	operator final "=" {
			def boolean false
			// convert other to group if not,  for sure
			read other as group
			if other is type prive then
				push .x=other.x and .y=other.y
			else
				push false
			end if
	}
	
	function final add5(other as *epsilon) {
		// we get a pointer from a copy of this
		// because m is in a same type object
		// we have access to private variables
		m->(this)
		// I add some spaces for clarity
		m=>x <= other=>x + 5
		m=>y <= other=>y + 5
		=m
	}
	
	function final sub5(other as *epsilon) {
		// we get a copy of this
		m=this
		// I add some spaces for clarity
		m.x <= other=>x - 5
		m.y <= other=>y - 5
		// now we make a pointer from a copy of m
		->(m)
		// this way we make two copies
		Print "call the remove member for a named group, only using Clear"
		clear m
	}
	
	remove {
		print "epsilon removed"
	}
class:
	module epsilon (.x, .y) {
		print "epsilon created"
	}
}
// used as mixin  - we need it as Group, with no type
Group ReplaceTostring {
	function ToString$ {
		=format$("private data: x={0}, y={1} from replaced function", .x, .y)
	}
}
M1->epsilon(10,40)   ' create one
Print M1=>ToString$()
M2->epsilon(10, 40) '  2 created until now
M3->(epsilon(30,40)  with ReplaceToString) ' 3 created until now through constructor.
Print M3 is type epsilon
Print M3=>tostring$()
Print M1=M2, M2=M3
M4=M3=>add5(M3)  ' 4 created, the 4th without constructor.
Print M4=>tostring$()
M5=M4=>sub5(M3)  
Print M5=>tostring$()
Report {
	Additional Example (to third one)
	
	A class Theta is a prive one, and can get values from any prive class (or subclass of prive). We make the  Set member to read a prive only class and from Version 10 when a class has any type common with the method's class then open the private members. We get me.X (where X is private) and place it to this.x, the same for me.Y.
	Also see that we use  constructor, no in  a class segment,  to be used as method to replace values. 
	
	Class Theta as prive {
		Set {
			Read me as prive
			.X<=me.X
			.Y<=me.Y
		}
		function final toString$ {
			=format$("Theta class: x={0} y={1}", .x, .y)
		}
		Module Theta (.X, .Y) {
		}
	}	
	
}

Class Theta as prive {
	Set {
		Read me as prive
		.X<=me.X
		.Y<=me.Y
	}
	function final toString$ {
		=format$("Theta class: x={0} y={1}", .x, .y)
	}
	Module Theta (.X, .Y) {
	}
}
M6->Theta(25, 35)
Print M6=>tostring$()
Print M4=M6
M6=>=M4
Print M6 is M4
Print M4=>tostring$()
Print M6=>tostring$()
Print M4=M6
}
MODULE TRAVERSAL2 {Report {
          Tree traversal
                   1
                  / \
                 /   \
                /     \
               2       3
              / \     /
             4   5   6
            /       / \
           7       8   9

} 
Pen 15 {Report "Using types in class Node"}
Print
Module OOP {
      Class Node {
      private:
            \\ Pointer() of Pointer(0) is the Null type pointer
            x, LeftNode=Pointer(), RightNode=Pointer()
      Public:
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        call visitor(T=>x)
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        call visitor(T=>x)
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call visitor(T=>x)
                  end sub
            }
            Module level_order (visitor){
                  M=stack:= Pointer(This)
                  \\ using M as FIFO
                  Stack M {
                        if empty then exit
                        Read T
                        if T is type Node Then
                              call visitor(T=>x)
                              Data T=>LeftNode, T=>RightNode
                        end if
                        Loop
                  }
            }
            remove {
                   print format$("node {0} destroyed", .x)
            }
      Class:
            Module Node {
                  Read .x, .LeftNode, .RightNode
            }
      }
      \\ Function NodeTree return a pointer to a new Node
      Function NodeTree {
            \\ ![] pass currrent stack to Node()
            ->Node(![])
      }
      \\ Tree is type Node

      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
 
      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP

Pen 15 {Report "Using types and  inheritance: a class Tree as a class Node, which returns a pointer to Tree object"}
Print

Module OOP {
      Class Node {
      private:
            \\ Pointer() of Pointer(0) is the Null type pointer
            x, LeftNode=Pointer(), RightNode=Pointer()
      Public:
            Module preorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        call visitor(T=>x)
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)
                  end sub
            }
            Module inorder (visitor){
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        call visitor(T=>x)
                        printtree(T=>RightNode)
                  end sub
            }
            Module postorder (visitor) {
                  T->This
                  printtree(T)
                  sub printtree(T)
                        If T is type Null Then Exit sub
                        printtree(T=>LeftNode)
                        printtree(T=>RightNode)            
                        call visitor(T=>x)
                  end sub
            }
            Module level_order (visitor){
                  M=stack:= Pointer(This)
                  \\ using M as FIFO
                  Stack M {
                        if empty then exit
                        Read T
                        if T is type Null Else
                              call visitor(T=>x)
                              Data T=>LeftNode, T=>RightNode
                        end if
                        Loop
                  }
            }
            remove {
                   print format$("node {0} destroyed", .x)
            }
      }     
     Class Tree as Node {
            value (xval) {
                  .LeftNode<=Pointer()
                  .RightNode<=Pointer()
                  Read ? .LeftNode, .RightNode
                  .x<=xval
                  ->(This) 
            }          
	
      }
      \\ now NodeTree is a static group with value which generate other trees.
      \\ Tree is type Tree 
      NodeTree=Tree()      
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))

      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP

Pen 15 {Report "Using types and inner class Node in a class Tree which returns a pointer to Node object"}
Print


Module OOP {
      Class Tree {
      Private:     
            Class Node {
            private:
                  \\ Pointer() of Pointer(0) is the Null type pointer
                  x, LeftNode=Pointer(), RightNode=Pointer()
            Public:
                  Module preorder (visitor){
                        T->This
                        printtree(T)
                        sub printtree(T)
                              If T is type Null Then Exit sub
                              call visitor(T=>x)
                              printtree(T=>LeftNode)
                              printtree(T=>RightNode)
                        end sub
                  }
                  Module inorder (visitor){
                        T->This
                        printtree(T)
                        sub printtree(T)
                              If T is type Null Then Exit sub
                              printtree(T=>LeftNode)
                              call visitor(T=>x)
                              printtree(T=>RightNode)
                        end sub
                  }
                  Module postorder (visitor) {
                        T->This
                        printtree(T)
                        sub printtree(T)
                              If T is type Null Then Exit sub
                              printtree(T=>LeftNode)
                              printtree(T=>RightNode)            
                              call visitor(T=>x)
                        end sub
                  }
                  Module level_order (visitor){
                        M=stack:= Pointer(This)
                        \\ using M as FIFO
                        Stack M {
                              if empty then exit
                              Read T
                              if T is type Node Then
                                    call visitor(T=>x)
                                    Data T=>LeftNode, T=>RightNode
                              end if
                              Loop
                        }
                  }
            remove {
                   print format$("node {0} destroyed", .x)
            }
            Class:
                  Module Node {
                        Read .x, .LeftNode, .RightNode
                  }
            }
      public:
            value (xval as double) {
                  Rem {
                        LeftNode=Pointer()
                        RightNode=Pointer()
                        Read ? LeftNode, RightNode
                        ->.Node(xval,LeftNode, RightNode)
                  }
                  ->.Node(xval,![])
            }          
	
      }
      \\ now NodeTree is a static group with a private Node class
      \\ return a pointer to a Node object
      \\ Tree is type Node
      NodeTree=Tree()      
      Tree=NodeTree(1, NodeTree(2,NodeTree(4, NodeTree(7)), NodeTree(5)), NodeTree(3, NodeTree(6, NodeTree(8), NodeTree(9))))
      
      printnum=lambda (title$) -> {
            Print
            Print title$;
            =lambda (x)-> {
                  Print x;" ";
            }
      }
      Tree=>preorder printnum("preorder:    ")
      Tree=>inorder printnum("inorder:     ")
      Tree=>postorder printnum("postorder:   ")
      Tree=>level_order printnum("level-order: ")
      Print
      Print
}
OOP
}
MODULE GRTYPES {module UsingNamedObjects {
	\\ private members used as public inside a method
	\\ for any object.
	class alfa {
	private:
		dim a()
	public:
		module changethis (&p as alfa) {
			\\ m is a pointer to array (mArray object)
			\\ p.a() not work outside an alfa type method
			m=p.a()
			\\ pointer to arrays have some operators
			m+=10
			Print type$(m)
		}
		module PrintMe {
			\\ we can use .a() or this.a()
			print this.a()
		}
		Remove {
			Print "alfa type object deleted"
		}
	class:
		module alfa (n) {
			\\ redim array
			dim .a(10)=n
		}
	}
	
	b=alfa(3)
	c=alfa(6)
	b.PrintMe
	c.PrintMe
	\\ So now we pass pointer c to b.changethis
	b.changethis &b
	b.changethis &c
	b.PrintMe
	c.PrintMe
	\\ only manual we can call the remove function for named objects
	Clear b, c
}
UsingNamedObjects

module UsingPointersToObjects {
	\\ private members used as public inside a method
	\\ for any object.
	class alfa {
	private:
		dim a()
	public:
		module changethis (p as *alfa) {
			\\ m is a pointer to array (mArray object)
			\\ p=>a() not work outside an alfa type method
			m=p=>a()
			\\ pointer to arrays have some operators
			m+=10
			Print type$(m)
		}
		module PrintMe {
			\\ we can use .a() or this.a()
			print this.a()
		}
		Remove {
			Print "alfa type object deleted"
		}
	class:
		module alfa (n) {
			\\ redim array
			dim .a(10)=n
		}
	}
	
	b->alfa(3)
	c->alfa(6)
	b=>PrintMe
	c=>PrintMe
	\\ So now we pass pointer c to b.changethis
	b=>changethis b
	b=>changethis c
	b=>PrintMe
	c=>PrintMe
	\\ now b and c erased
	\\ and because no other pointers hold the objects, destroyed.
	\\ so the remove function call automatic
}
UsingPointersToObjects
}
MODULE FIRSTWINDOW {Title "Example#1"
Pen 14
Cls 5,0
Thread.plan concurrent
Function Dec3$ { =Str$(Number/1000,"####0.000")}
Function Dec$ { =Str$(Number,"####0.000")}
Declare Form1 Form
Method Form1, "FontAttr", "Tahoma", 48
Method Form1, "CtrlFontAttr", "Tahoma", 24
Layer Form1 {
      Window 14, 12000,8000
      Font "Verdana"
      Print $(4,8) \ Proportional and  8 char width for columns
}
Declare Text1 TextBox Form Form1
Method Text1,"move", 3000, 2000, 8000, 900
With Text1, "Prompt", "Name: ", "MaxCharLength", 30+6

Declare Spinner TextBox Form Form1
Def Alone as boolean
//\ spinner values: ShowBar, MinValue , MaxValue , LargeValue.
//Range include MinValue and MaxValue
// So we have integers (sign long) but we can display it like a float

Method Spinner "Spinner", True, 0,2000,30
Method Spinner "Move", 3000, 3000, 8000, 900
With Spinner, "Prompt", "A_Value: ",  "Value" as Spi, "VarText" as  Feed$, "ThisKind"," units"
// Spinner is a textbox with some advanced performance
// We use ValidString to check every new value
// we use SpinnerValue to format the value
// Inside ValidString we use "Value" as Spi, to cut off higher or lower values.

Function Spinner.SpinnerValue {
            Read val
            Feed$=Dec3$(val)
            }

Function Spinner.ValidString {
            // this function called direct from textbox
            Read  New &this$, &thispos
            Local Alfa
            Try {     
                  // Spi is an alias for Value property      
                Alfa=val(this$)*1000 : Spi= Alfa :  Alfa=Spi
            }
            if valid(Alfa) then {
                  this$=dec3$(Alfa)
            } else {
                  thispos=1000
      }
}
Feed$=Dec$(1.34)

Declare CheckBox1 CheckBox Form Form1
Method CheckBox1 "Move", 3000, 4000, 8000, 900
With CheckBox1,"Caption", "Check alt+SPACE, ctrl+*", "Checked" as CheckGet, "CheckReset" as CheckPut
// opcodes: 0 just set focus, 1 set focus and press it, 2 press it
Method CheckBox1, "AccKey", "*", ctrl:=true, opcode:=1
Method CheckBox1, "AccKey", " ", alt:=true, opcode:= 32*2

Method Form1, "AccKey", "Q", alt:=true, opcode:= 100615*2
CheckPut=True


Declare Button1 Button Form Form1
Method Button1 "Move", 3000, 5000, 8000, 900
With Button1,"Caption", "Reset CheckButton"

Function Button1.Click {
      CheckPut= Not CheckGet
      // No Event Fired, so we make here the change
      If CheckGet Then {
            With Button1,"Caption", "Reset CheckButton"
      } Else {
            With Button1,"Caption", "Set CheckButton"
      }
}

Function CheckBox1.Changed {
      Read Val
      Layer Form1 {Print "CheckBox Value ";Val}
      If Val Then {
            With Button1,"Caption", "Reset CheckButton"
      } Else {
            With Button1,"Caption", "Set CheckButton"
      }
}
Function CheckBox1.Click {
      Read Val
      Layer Form1 {Print "CheckBox Value ";Val}    
}

With Form1, "Title", "First Window", "visible" as visible
Method Form1,"Show"
Layer Form1 {
      Cls 1,0
      Scroll Split 2  // scroll from 3rd line - same as Cls ,2
      Cursor 0, Height/2-1  
      Report 2, "Hello World"
}

With Text1, "VarText" as VarText$
Thread {
      Static work  // we use it for trash bin
      if alone then continue
           if not empty then work=ask(letter$,"Four Controls in M2000","*ThankYou","") : Flush // stack is empty now

} as worker interval 100
Function Text1.Click {
      Layer Form1 {Print "click" }
}
Function Text1.Enter {
      Layer Form1 {Print VarText$ }
}
Function Spinner.Enter {
      Layer Form1 {Pen 15 {Print Val(Feed$)}}
}
Function Form1.Click {
      // we can push values to Thread Stack for Values
      // Data push at bottom, Push push at top
      // always we pop from top we Read Variables or
      // immediate with Number/Letter$
      Document Doc$={Hello There 
      }
      Doc$="This is your name "+VarText$+{
      }
      Doc$="This is a value "+Feed$+{
      }
      Doc$="The CheckBox is "+Str$(CheckGet,{;"Checked";"No Checked";})+{
      Press Alt+Q to send Ctrl+F4
      }
      Thread worker Execute Data Doc$
      Clear Doc$
}

// some nice background tasks
kk=0
Thread {      
      kk++
      layer  {
            layer  Form1 {
                  print kk
                  part {
                      refresh 
                  } as alone
            }
            Draw To Random(Scale.x), Random(Scale.y), Random(7,15)
      }
} As Print2Form Interval 50

//  main loop
Main.Task 50 {
       if not visible then exit
}
Threads Erase
Thread.plan sequential
Declare Form1 Nothing
}
MODULE POLYGONS {module drawPolygon {
      read n, d
      s=d*3
      d4=d/4
      for i=1 to n {
            width 4 {      
                  draw angle i*pi/(n/2), s/n
            }
      }
      step -d4, -d4
      floodfill ,,5
      step d4, d4
      step d
}
module clearScreen {
    cls 5
    back {cls 5}
    window 12, 14000,10000;
    cursor 0,0
    gradient 6,1
    double
    path  {
          report 2 , "POLYGON EXAMPLE"
    };    
    normal
    gradient 4,13,0
    \* RESET THE path  (path and color is the same statement)
    move 0,0
    // old way:
    //path {
    //      polygon 0, x.twips, 0,0,y.twips,-x.twips,0,0,-y.twips
    //};
    path {};
    cursor 0,0
    double
    width 2 {
    color  {
          report 2 , "POLYGON EXAMPLE"
    }
    }
    normal
}
clearScreen
show
s=scale.x/sqrt(87.6)
top=scale.y/sqrt(8.2)
move s, top
for i = 3 to 11 {
      drawPolygon i, s
}
move s, top+s
for i = 12 to 19 {
      drawPolygon i, s
}
move s, top+2*s
for i = 19 to 12 {
      drawPolygon i, s
}
move s, top+3*s
for i = 11 to 3 {
      drawPolygon i, s
}
copy "this.bmp"    'export to bmp
A$=KEY$ ' Wait for a keypress
if module(info) then info
}
MODULE GRAPHGR {Module GraphGraph1 {
	οθόνη 1,0   \\ μπλε χρώμα, χωρίς χωριστή οθόνη
	κ=0
	ανανέωση 50
	\\ κάνουμε την αυτόματη ανανέωση πιο αργή, ανά 5 δευτερόλεπτα
	πάχος 1, 3 {  \\ αξονική γραμμή - μόνο για πάχος 1
	      θέση  χ.σημεία, υ.σημεία/2
	      χάραξε -χ.σημεία
	      θέση  χ.σημεία/2, υ.σημεία
	      χάραξε , -υ.σημεία
	      }
	για ν=3 έως 63 {
	      α=ν/2/πι
	      β=χ.σημεία/3/ν+ν*10
	      \\ απόλυτη θέση
	      θέση  χ.σημεία/2, υ.σημεία/2
	      κ+=πι/10
	      λ=1
	      για ι=1 έως ν {
	           πάχος λ {
	                 \\ πολικές συντεταγμένες: απόλυτη γωνία σε ακτίνια, σχετική απόσταση
	                 \\ η χάραξε  έχει τρεις μορφές
	                 \\ χάραξε γωνία  απόλυτη_γωνία,  απόσταση  [, χρώμα]
	                 \\ χάραξε απόσταση_κατά_χ [, απόσταση_κατά_ψ [, χρώμα]]
	                 \\ χάραξε έως απόλυτη_θέση_χ, απόλυτη_θέση_ψ [, χρώμα]
	                  χάραξε γωνία ι/α+Κ, β, χρώμα(255*ν/24, 255*ι/ν, 255-255*ι/ν)
	            }
	            λ=3-λ
	      }
	}
	\\ τώρα επαναφέρουμε την αυτόματη ανανέωση ανά 0.025 δευτερόλεπτα
	ανανέωση 25
}

function dummy {
	ro=row
	GraphGraph1
	Wait 500
	cls 5, row-1
	Pen 14
}

Inline Code LibFade
FadeScreen Lazy$(&Dummy()), 30
Set Fast
}
MODULE ΓΡΑΦΙΚΟ {θεσε γρηγορα !
Ομαλά Ναι
ζβ=πι/32 \\ αν βάλουμε 48 κάνει πιο ωραία καμπύλη
ζβ1=ζβ/2 \\ αν βάλουμε αντί για 2 μεγαλύτερο θα δούμε άλλα σχέδια
ζ=πι+ζβ*8
ζ1=ζβ1*16
\\ στο μέσον!
κχ=χ.σημεια/2
κυ=ψ.σημεια/2
μκ=Μικρό.Σειράς(χ.σημεια, ψ.σημεια)*.3
ανανεωση 2000 \\ για να μην εμφανίσει αλλαγές της οθόνης, εκτός αν θέλουμε!
διπλα
φοντο 1,5
δρομεας 0,0
αναφορα 2,"Παράδειγμα Χρήσης Γραφικών με τη Μ2000"
κανονικα
γ(μκ,κχ,κυ,πι/4)
μκ2=μκ δια 2
Άδειασε  ' αδειάζει το σωρό
κκ=ψευδες
Σχέδιο {
	πάχος 3 { \\ βάζουμε πάχος στις γραμμές μας
		δ(μκ2,0,0,0)
	}
} Ως Εσωτερική
 Rad2Deg =Lambda pidivby180=pi/180 (RadAngle)->RadAngle / pidivby180


κρατησε   \\ σώνουμε προσωρινά την εικόνα
πάχος 3 { \\ βάζουμε πάχος στις γραμμές μας
      καθε 10 {
            αφησε  \\ αντί να σβήσουμε βάζουμε ότι έχουμε σταθερό
            θεση κχ, κυ
            βήμα γωνια (πι/2+πι/4)+ζ,μκ2 \\ η θέση του εσωτερικού κύκλου
            κ(μκ2,θέση.χ, θέση.υ, -ζ1, &κκ) \\ την πρώτη φορά απλά παίρνει τα σημεία
            \\ η κ κάθε άλλη φορά θα σώνει την οθόνη χωρίς τον εσωτερικό κύκλο
'            δ(μκ2,θέση.χ,θέση.υ,-ζ1) \\ τυπώνει το κύκλο
            Εικόνα Εσωτερική,,,Rad2Deg(-ζ)
            \\ με την ανανέωση εμφανίζουμε τις αλλαγές 
            ανανεωση 2000
            αν πατημένο(1)  τοτε εξοδος
            ζ+=ζβ
            αν κκ τότε{ αν ζ>4*πι τότε κκ=ψευδής:άδειασε} αλλιώς άδειασε
            ζ1+=ζβ1*2
      }
}
Αδειασε
Θέσε Γρήγορα
Ρουτίνα δ(α, Χ, Ψ, ζ)
      παχος 2 {
            \\ άξονες  -- ενώ απ' έξω έχουμε αλλάξει το πάχος σε 2
            βημα γωνια ζ+πι/4, -α
            κυκλος α/16
            βημα γωνια ζ+πι/4, -α 
            κυκλος α/16
            Πάχος 2, 3 {χαραξε γωνια ζ+πι/4 , α*3}
            κυκλος α/16 
            Πάχος 2, 3 {χαραξε γωνια ζ+πι/4 , α}
            κυκλος α/16
            θεση Χ, Ψ
            βημα γωνια ζ-πι/4,-α*2
            κυκλος  α/16
            Πάχος 2, 3 {χαραξε γωνια ζ-πι/4,α*4}
            κυκλος α/16
      }
      θεση Χ, Ψ
      κυκλος α
Τέλος Ρουτίνας
Ρουτίνα κ(α, Χ, Ψ, ζ, &σχεδιασε)
      θεση Χ, Ψ
      βημα γωνια ζ+πι/4, -α*2
      Σειρά θέση.χ, θεση.υ
      βημα γωνια ζ+πι/4 , α*4
      Σειρά θέση.χ, θεση.υ
      θεση Χ, Ψ
      βημα γωνια ζ-πι/4,-α*2
      Σειρά θέση.χ, θεση.υ
      βημα γωνια ζ-πι/4,α*4
      Σειρά θέση.χ, θεση.υ
      Αν σχεδίασε τοτε
            Για ι=1 εως 4
                  θεση αριθμός, αριθμός
                  πάνω 8,2   ' δυο φορές το Πάνω 8
                  χαραξε εως αριθμός, αριθμός, ι+8
            Επόμενο
            κράτησε \\ σωνει την οθόνη
      Τέλος Αν
      σχεδιασε=αληθης 
      θεση Χ,Ψ
Τέλος Ρουτίνας
Ρουτίνα Γ(α, Χ, Ψ, ζ)
      θεση Χ, Ψ
      πάχος 2 {
            κυκλος α
            κυκλος α/2,1,7 
            παχος 1,3 {
                  βημα γωνια ζ+πι/4, -α*1.05
                  χαραξε γωνια ζ+πι/4 , α*2.1
                  θεση Χ, Ψ
                  βημα γωνια ζ-πι/4,-α*1.05
                  χαραξε γωνια ζ-πι/4,α*2.1
            }
      }
Τέλος Ρουτίνας
}
MODULE CLASS1EN {Class Animal {
Private:
	legs=0
	sound$="nothing"
Public:
	Function Final Legs() {
		=.legs
	}
	Function DoSound$() {
		=.sound$
	}
}
Class Pet as Animal {
Private:	
	name$
	message$="They call me {0} and I am a Pet and I have {1} legs and all day {2}"	
Public:
	Function message$() {
		=.message$
	}
	Function CallMe$() {
		=.name$
	}
Class:
	Module Pet {
		Read .name$, .sound$, .legs
	}
}
Class Dog as Pet {
	Function CallMe$() {
		=.name$+" and I am a Dog"
	}
Class:
	Module Dog(.name$)	{
		.legs<=4
		.sound$<="bark"
	}
}
Class Cat as Pet {
	Function CallMe$() {
		=.name$+" and I am a Cat"
	}
Class:
	Module Cat(.name$)	{
		.legs<=4
		.sound$<="meow"
	}
}
Class Bird as Pet {
Private:
	kind$="something"
	message$="They call me {0} and I have {1} legs and wings and all day {2}"
Public:
	Function CallMe$() {
		=.name$+" and I am a "+.kind$
	}
Class:
	Module Bird(.name$, .kind$)	{
		.legs<=2
		.sound$<="sing"
	}	
}
Document AllTogether$={Final Report
}
Azor=Dog("Azor")
What(Azor)
Minnie=Cat("Minnie")
What(Minnie)
Goldie=Bird("Goldie", "canary")
What(Goldie)
ΆλλοΚατοικίδιο=Pet("Dolly", "neigh", 4)
What(ΆλλοΚατοικίδιο)

Clipboard AllTogether$

End

Sub What(a as Pet)
	Local exp$=Format$(a.Message$(),a.CallMe$(), a.Legs(), a.DoSound$())
	AllTogether$=exp$+{
	}
	Report exp$
End Sub
}
MODULE REV48 {\\ In revision 44 Version 9.9
\\ This object may have dots before.
Class Alfa {
	x=10
	module internal {
		.x++
		Print .x
	}
}
Module DoSomething (&z as Alfa){
	z.x++
	Print z.x
	z.internal
}
Print "Using Pointers to float groups"
Dim A(1 to 2)<<Pointer(alfa())
For A(1), A(2) {
	DoSomething &.This
	DoSomething &..This	
}
A=Alfa()
DoSomething &A
Print A.x, A(1).x, A(2).x

Print "Using float groups"
Dim A(1 to 2)=alfa()
For A(1), A(2) {
	DoSomething &.This
	DoSomething &..This	
}
A=Alfa()
DoSomething &A
Print A.x, A(1).x, A(2).x


Class Beta as Alfa {
	X=9999
	module beta {
		Class Alfa {
			x=10
			module internal {
				.x++
				Print .x
			}
		}
		Module DoSomething (&z as Alfa){
			z.x++
			Print z.x
			z.internal
		}
		Print "Using Pointers to float groups"
		Dim A(1 to 2)<<Pointer(alfa())
		For This, A(1), A(2) {
			DoSomething &This
			DoSomething &..This
			DoSomething &...This	
		}
		A=Alfa()
		DoSomething &A
		Print A.x, A(1).x, A(2).x
		
		Print "Using float groups"
		Dim A(1 to 2)=alfa()
		For This, A(1), A(2) {
			DoSomething &This
			DoSomething &..This
			DoSomething &...This	
		}
		A=Alfa()
		DoSomething &A
		Print A.x, A(1).x, A(2).x
	}
}
Print "Check Beta constructor"
B=Beta()
}
MODULE VAULT {\\ Original Idea: George Karras, invetor of M2000 Interpreter.
Back {Cls 5,0}
Form 60, 30
Double
Report 2, "Unlock The Vault"
Normal
Report{
Instructions:

Attach the moving tool to unlock mechanism. Follow the known code to open it. Get some time, using S. Use mouse buttons, or Z and X. Use space for paise.

For each stage a gift (as a small  circle), flasjng and wait to pick. To pick it just center the tol and press mouse keys or Z or X. You may get time. About 29% you get ultimate gift, you pass the stage at once.

Use Esc to exit any time.

Good Luck


Press any key
}
Push Key$
Drop
Cls


Print $(, 6)
Escape Off
Mouse.Icon Hide
Dim CodeBank(), code(), course(128)
hlp=true
HiScore=30
safety=3
score=0
N=3
k=pi -PI/2
for i=0 to 127
	course(i)=k
	k+=pi/64
next i
stagetime=50000
Again:
esc1=false
Refresh 5000
CodeBank()=(Random(2,9), Random(1, 4), Random(5,9), Random(2, 6), Random(4, 7))
Pen 15
Cls 3, 0
Pen 11 {Report 2, "Game: Unlock the Vault"}
cursor 0,0
Report 1, format$("Score:{0:4}",str$(score, "0000"))
cursor 0,0
Report 3, format$("HiScore:{0:4}",str$(HiScore, "0000"))
pen 14
cls 5, 1
Print "Rotations:",
for i=0 to N-1
	Print CodeBank(i),
next
Print
cls , 2
PI2=PI*2
k=pi -PI/2
count=false
counter=0
good=false
M5000=Random(3500, scale.x-3500)
M8000=Random(7000, scale.y-3500)

flush
kk=0
Rem smooth off   ' using gdi32
smooth on  ' using gdi+
Z=timecount+stagetime
bomb=0
esc$=chr$(27)
k1=Random(0, 127)
k11=course(k1)
k2=Random(0, 127)
k22=course(k2)
cl=15
Cursor 0, 2
move !
pY=pos.Y
gift=false
giftonce=true
giftX=Random(3500, scale.x-3500)
giftY=Random(7000, scale.y-3500)
giftpulse=10
SwapKey=2
pause$=""
try  {
	safetyonce=safety>0
	Do
		if pause$="" then
		if kk<>SwapKey then
			if count then 
				if stack.size mod 2=1 then
					k2--: if k2<0 then k2=127
				else
					k2++: if k2>127 then k2=0
				end if
			else
				k2++: if k2>127 then k2=0
				k1+=Random(1, 5): if k1>127 then k1=0
				k11=course(k1)
			end if
			k22=course(k2)
		end if
		end if
		kk=0
		if count then counter++ else.if counter>0 then data counter : counter=0 : SwapKey=3-SwapKey
		if stack.size=N then exit
		(x,y)=(mouse.x, mouse.y)
		Move 0, pY
		\\ set path
		color { polygon 0, scale.x, 0, 0, scale.y-pY, -scale.x, 0, 0, -scale.y+pY};
		if gift  and giftpulse<5 then
			move giftX, giftY
			circle fill 4, 300,1, 4
		end if
		move M5000, M8000
		circle fill 11,  3000, 1, cl, 0+k11, pi/2+k11
		circle fill 13,  3000, 1, cl, pi+k11, pi+pi/2+k11

		move x, y
		circle fill 12,  3000, 1, cl, pi/2+k22, pi+k22
		circle fill 14,  3000, 1, cl, pi+pi/2+k22, pi*2+k22

		refresh 500

		Every 10 {
			if pause$=" " then
				Z+=bomb-int(z-timecount)
				pause$=inkey$
				if pause$="" then pause$=" " : counter=0: count=0
			else
			pause$=inkey$
			end if
			bomb=int(z-timecount)
			esc1=pause$=esc$
			if bomb<0  or esc1 then exit
			Cursor 0, 2
			gradient 1, 5
			giftpulse--: if giftpulse<0 then giftpulse=10
			if gift  and giftpulse<5 then
				move giftX, giftY
				circle fill 4, 300,1, 4
			end if
			Print @(width-8);Str$(Now,"hh:mm:ss")
			Cursor 0, 2
			Print "Time Left:"; bomb div 1000;if$(pause$=" "->" paused","")
			if giftonce then if bomb<Random(10000, 30000) then giftonce=false: gift=true
			if hlp then Print "Rotated:"; counter
			br=row
			Cursor 0, height-1
			if pause$=" " then
				Print " Press any key to continue";
			else
				Print " Press space for pause";
			end if
			if safetyonce then Print @(width-safety-1);string$("S", safety);
			Cursor 0, br+1
			(x,y)=(mouse.x, mouse.y)
			if pause$=" " then exit			
			count=abs(x-M5000)<twipsx*2 and abs(y-M8000)<twipsy*2 
			if count and k11<>k22 then
				if stack.size mod 2=1 then
					k1--: if k1<0 then k1=127
				else
					k1++: if k1>127 then k1=0
				end if
				k11=course(k1)
			end if
			move M5000, M8000
			circle fill 11,  3000, 1, cl, 0+k11, pi/2+k11
			circle fill 13,  3000, 1, cl, pi+k11, pi+pi/2+k11
			move x, y
			circle fill 12,  3000, 1, cl, pi/2+k22, pi+k22
			circle fill 14,  3000, 1, cl, pi+pi/2+k22, pi*2+k22
			refresh 500
			kk=mouse
			if kk=0 then
				kk=-keypress(90)
				if kk=0 then kk=-2*keypress(88)
			end if
			if safetyonce then if safety then if keypress(83) then safety-- : z+=20000 : safetyonce=false
			if kk=1 and gift then	
				if abs(x-giftX)<150 and abs(y-gifty)<150 then
					gift=false
					IF Random(5)=1 then
						flush
						for i=0 to n-1
						 	data CodeBank(i)
						next
						count=0
						kk=swapkey				
					else
						z+=20000
					end if
				end if
			end if
			if kk<>0 then exit
		}
		if kk<>0 then pause$=""
		\\ reset path
		color {};
		if bomb<0  or esc1 then break
		if kk=SwapKey and not count then exit
		if kk=SwapKey then count=0
		if score>50 then if Random(1, score div 10)>4 then restart	
		if count then {
			wait 10
			if mouse or keypress(80) or keypress(90) then restart
		}
	Always
	if counter>0 then push counter : counter=0
	code()=Array([])
	If len(code())<N then 	SwapKey=2 : restart
	good=true
	for i=0 to N-1
		If code(i)<>CodeBank(i) Then good=false: exit for
	next
	if good else Loop
}
Refresh 50
\\ using blocks here tu utilize the Goto statement.
if bomb<0 then {
	For i=1 to 1000
		Pen Random(11, 15) {
			Print @(Random(width div 12)*12,Random( 5, height-5)), "BOOOOOOOOOM"
		}
	Next i
	Score=0
	hlp=true
	safety=3
	stagetime=50000
	N=3
	if ask("Play Again", "Unlock the Vault", "*Yes", "No")=1 then Goto Again
	Cls, 0
 } Else.if not good then {
	Scroll Split 0   ' like Cls, 0 without CLS
} else {
	score+=10
	if HiScore<score then HiScore=Score
	if score>=100 then N=4 : hlp=false : stagetime=70000
	if score>=300 then N=5: : stagetime=90000: safety+=2
	Wait 400
	goto Again
}
Mouse.Icon Show
Escape on
Print "See you later..."
wait 500
keyboard "info"+chr$(13)
}
MODULE REV53 {\\ Revision 53 Version 9.9
\\ fix Array() to get a copy from a Group
Module CheckThis {
	Class Company {
		Name$="A Company"
	}
	Function At {
		Class Person {
			Name$="John Doe"
			Idempl=0
			Company=Pointer()
			Remove {
				Print "Remove:";.Idempl
			}
		Class:
			Module Person(t as *Company, &n) {
				.Company<=t
				n++
				.Idempl<=n
			}
		}
		\\ []  get s pointer from current stack settinh a new stak as current stack
		\\ ![] place the current stack as the call stack to Person(), setting current stack for At() a new stack (empty)
		=Pointer(Person(![]))
	}
	Ε1=Company()
	Idempl=0
	Dim Empl(1 to 10)<<At(Pointer(Ε1), &Idempl)
	m=Each(Empl())
	While m {
		k=Array(m)
		For k {
			Print Format$("{0::-5}|{1:25}|{2:20}", .Idempl, .Name$, .Company=>Name$)
		}
	}
	m=Each(Empl())
	While m {
		k=Array(m)
		For k {
			Print Format$("{0::-5}|{1:25}|{2:20}", .Idempl, .Name$, .Company=>Name$)
		}
	}
}
CheckThis
}
MODULE LED {\\ if you have two monitors:
\\ Window mode, 1     \\ mode is a read only variable return the size of current font
// Window mode, 2    // selecet monitor 2
cls, 0
window 6, window

Module Led_Clock{
	Escape Off
	Smooth off
	Dim D(-1 to 9)
	D(-1)=(0,0,0,0,0,0,0)
	D(0)=(1,1,1,0,1,1,1)
	D(1)=(0,0,1,0,0,1,0)
	D(2)=(1,0,1,1,1,0,1)
	D(3)=(1,0,1,1,0,1,1)
	D(4)=(0,1,1,1,0,1,0)
	D(5)=(1,1,0,1,0,1,1)
	D(6)=(1,1,0,1,1,1,1)
	D(7)=(1,0,1,0,0,1,0)
	D(8)=(1,1,1,1,1,1,1)
	D(9)=(1,1,1,1,0,1,1)
	N=240
	XX=(scale.x-N*75) div 2
	YY=scale.y-N*22
	NN=N
	BackColor=0
	CLS BackColor, 0
	Back {CLS BackColor,0}
	desktop 255, BackColor
	Forecolor=12
	C=BackColor-Forecolor
	pen BackColor
	for i=0 to 9: cc=d(i): cc*=c:next
	m=1
	move XX+N*23.2, YY+N*5.2
	polygon BackColor-C, N,-N, N,N, -N, N, -N, -N
	move XX+N*23.2,YY+N*13.2
	polygon BackColor-C, N,-N, N,N, -N, N, -N, -N
	move XX+N*49.2,YY+N*5.2
	polygon BackColor-C, N,-N, N,N, -N, N, -N, -N
	move XX+N*49.2,YY+N*13.2
	polygon BackColor-C, N,-N, N,N, -N, N, -N, -N
	dsk=True
	every 1000/2 {
		k=now
		k1=val(str$(k, "hh"))
		k2=val(str$(k, "nn"))
		k3=val(str$(k, "ss"))
		LED(XX, D(k1 div 10))
		LED(XX+N*12, D(k1 mod 10))
		LED(XX+N*26, D(k2 div 10))
		LED(XX+N*38, D(k2 mod 10))
		LED(XX+N*52, D(k3 div 10))
		LED(XX+N*64, D(k3 mod 10))
		refresh 1000
		if keypress(32) then
			dsk~
			if dsk then 	desktop 255 else desktop 255, BackColor
		end if
		if keypress(27)  or mouse=2 then exit
	} 
	desktop 255
	pen 14
	refresh 50
	mode 16
	wait 1000
	Escape On

	sub LED(XX, S())
		move XX+N*1.2, YY+NN
		\\ LED  - UPPER
		polygon BackColor-S(0), N,-N,N*6,0, N,N, -N, N,-N*6,0, -N, -N
		\\ LED | LEFT UPPER
		move XX+N*1.2-N*1.2, YY+N*1.2+NN
		polygon BackColor-S(1), N,-N,N,N,0,N*6,-N, N, -N, -N, 0, -N*6
		move XX+N*1.2+N*7.2, YY+N*1.2+NN
		\\ LED | RIGHT UPPER
		polygon BackColor-S(2), N,-N,N,N,0,N*6,-N, N, -N, -N, 0, -N*6
		move XX+N*1.2, YY+N*8.4+NN
		\\ LED - MIDDLE
		polygon BackColor-S(3), N,-N,N*6,0, N,N, -N, N,-N*6,0, -N, -N
		\\ LED | LEFT BOTTOM
		move XX+N*1.2-N*1.2, YY+N*9.6+NN
		polygon BackColor-S(4), N,-N,N,N,0,N*6,-N, N, -N, -N, 0, -N*6
		\\ LED | RIGHT BOTTOM
		move XX+N*1.2+N*7.2, YY+N*9.6+NN
		polygon BackColor-S(5), N,-N,N,N,0,N*6,-N, N, -N, -N, 0, -N*6
		\\ LED - BOTTOM
		move XX+N*1.2, YY+N*16.8+NN
		polygon BackColor-S(6), N,-N,N*6,0, N,N, -N, N,-N*6,0, -N, -N
	end sub
}
Led_Clock
}
MODULE HANDLER {escape off
Form 100, 60
Pen 15 {
	Print "Demo: Using a console program from M2000, using WScript.Shell "
	Print "Press Esc to exit, or write Exit and press enter"
}
cls, 2
Declare GetForegroundWindow Lib "user32.GetForegroundWindow"
Declare ShowWindow Lib "user32.ShowWindow" {long hwnd, long nCmdShow}
cl$=chr$(12)
al$=">"+chr$(13)
const SW_MINIMIZE = 6&
Declare objShell "WScript.Shell"
Method objShell, "Exec", "%comspec% /d /k"  as  objExecObject
With objExecObject, "StdOut" set StdOut
With objExecObject, "Stdin" set StdIn
With objExecObject, "Status" as Status
With StdOut, "AtEndOfStream" as AtEndOfStream
Method StdIn, "WriteLine" , "cd c:\"
Method StdIn, "WriteLine" , "dir"
Method StdIn, "WriteLine" ," "
wait 200
\\ we have to minimize the window
t=GetForegroundWindow()
t1=ShowWindow(t, SW_MINIMIZE)
a$=""
p$=""
Every 10 {
	Method StdOut, "ReadLine" as strText$
	p$=filter$(strText$, cl$)
	if right$(p$,2)="> " or keypress(12) then
                        	Pen 15 {
                        	      Print "(Send command)>";
                        	      Line Input a$
                        	      print
                        	}
                         	Method StdIn, "WriteLine" ,a$
                         	wait 20
                  		Method StdIn, "WriteLine" ," "
	else
		if right$(p$, len(a$)+1)=">"+a$ else
			if p$=""   else  print #-2, p$ : refresh
		end if
	end if
	if keypress(27) then exit
	if status=1 then exit
} 
print "End"
Declare objExecObject nothing
Declare objShell nothing
}
MODULE HANDLER2 {Escape Off
Form 80, 50
Pen 15 {
	Print "Demo: Using a console program from M2000, using ShellPipe internal object"
	Print "Press Esc to exit, or write Exit and press enter"
}
cls, 2
Declare withevents SP SHELLPIPE
Rem Print TYPE$(SP)
with SP, "Active" as IsActive, "Hasline" as Sp.HasLine
Method SP, "Run","cmd.exe /k" as ok
Wait 200
Show
Rem Print ok
If ok=0 then
    Method SP, "SendLine", "Dir"
    idle=timecount
    lastcomm$=""
    comm$=""
    profiler
    Function SP_DataArrival {
    	While  Sp.HasLine
    		idle=timecount
    		method Sp, "GetLine" as aLine$
    		if right$(aline$, len(lastcomm$)+1)<>">"+lastcomm$ then
    			Print #-2, aLine$
    	           	Refresh
    	           end if
              End While
    }
    Every 20 {
    	Method Sp, "ProcessLoop"
    	if not IsActive then exit
    	if keypress(27) then exit
    	if (timecount-idle)>100 then
    		Print "(child)>";
    		Pen 15 {Line Input comm$}
    		Print
    		Method SP, "SendLine", comm$
    		refresh
    		lastcomm$=comm$
    	end if
    }
end if
Declare SP nothing
}
MODULE ARDUINO {module SerialRead {
	\\ In com3 there is an Adruino Circuit which send data
	\\ we have to get them. Data send as UTF8
	\\ so we have to convert then to unicode UTF16LE
	\\ newline$ is ansi (8bit) string, A utf8 is the same as Ansi for codes below 128
	\\ str$(string) convert to ansi based on Locale (Locale 1033 or 1032 etc)
	\\ chr$(string) do the opposite, ansi to utf16le
	\\ when we send to arduino we have to place a lf (char 10) (1 byte)

	Arduino$={
		  int incomingByte = 0;
                void setup() {
                  Serial.begin(9600);
                }
                
                void loop() {
                  if (Serial.available() > 0) {
                    incomingByte = Serial.read();
                    Serial.print("I received: ");
                    Serial.println(incomingByte, DEC);
                  }
                }
	}
	Pen 15 {
			Report {You have to place this sketch -code- to Arduino Nano from Arduino IDE:
				
			}
		}
	Report Arduino$
	clipboard Arduino$
	Print "code copied to clipboard"
	const  newline$=str$(chr$(13)+chr$(10)) , send$=str$(chr$(10))
	escape off
	declare withevents com3 serialport
	Print "Try to set port to 3:";
	Menu
	for i=1 to 7
		Menu + "COM"+str$(i,"")
	next
	Menu Show "3"
	if menu=0 then port=3 else port=val(mid$(menu$(menu),4)) : Print menu$(menu)
	Print "If we get error then check cable, or change port number"
	Try ok {
		method com3, "OpenPort", port
	}
	If ok then
	PRINT "ok press A or Esc"
	\\ we use olddata$ to stack the line characters
	olddata$=""
	function com3_DataArrival (new many) {
		Method com3, "ReadBuffer" as mem
		\\ we get bytes from buffer mem to a$
		local a$=eval$(mem)
		\\ we have to scan a$ as bytes (some characters may have 4 bytes, all of them above 127)
		\\ so we scan a$ LIKE an ANSI string
		\\ info: Len(a$) may return integer pluw .5 if we have odd length ansi string
		\\ Len()) always return charaters of 2 bytes, so 2.5 means 2.5*2 bytes=5 bytes length.
		local where=instr(a$, newline$ as byte)
		if  where=0 then
			olddata$+=a$
		else
			olddata$+=Left$(a$, (where-1) as byte)
			\\ so now the line is ready
		
			Print #-2, string$(olddata$ as utf8dec)
			\\ so olddata$ get a new value
			\\ after the newline$
			olddata$=mid$(a$, where+2 as byte)
		end if
		refresh
	}
	try ok {
		every 30 {
			if keypress(65) then method com3, "writestring", string$("hello" as utf8enc)+send$
			method com3, "processloop", 30
			if keypress(27) then exit
			if error then print error$ : exit
		}
	}
	\\ last data here
	if olddata$<>"" then Print #-2, string$(olddata$ as utf8dec);
	refresh
	\\ if we remove the cable we get error
	\\ but we handle it and just print the error string
	end if
	if error or not ok then print : print "ERROR:"+error$
	\\ also this close the port
	
	declare com3 nothing
	\\ set locale
}
SerialRead
}
MODULE GCC {Prototype {
Module Global A {\\ empty the stack
\\ clear values
If not valid(mypath$) then Keyboard "All"+chr$(13) :exit
Escape off
Refresh 30
Flush : Clear
Fkey 1, {Save command$, {All:End}}
Fkey 2, {End}
Fkey 8, {Edit TestMe}
Fkey 9, {Edit c()}
Fkey 10, {Edit a}
Fkey 4, {Flush : TestMe 10000}
\\Fkey 5, {Save Command$ : Push Command$: New : Cls,0 : Load Letter$ : A}
Fkey 5, {A}
Fkey 14, {List}
\\************** need the proper path for gcc  **************//
\\																    \\
gcc$="C:\msys64\mingw32\bin\gcc"							     '>
//																     //
//**************************************************\\
If not exist(gcc$+".exe") then
Report {Error: gcc not found in proper path
	Find a path similar to C:\msys64\mingw32\bin\
	We need the 32 bit version of gcc
Get the Msys64
	from https://www.msys2.org/wiki/MSYS2-installation/
	and place it to C:\
Run mingw32.exe and run this command:
	pacman -S mingw-w64-i686-toolchain
}
Show
Print "Press any key..." : Push Key$: Drop
keyboard "Continue"+chr$(13)
break
End If
dir user
dd$=dir$
\\ Not need an exe elevation for c:\M2000test\
\\ but need for c:\ and the elevation grant from powershell call
If rnd>.5 then {
	Title "Compile Dll", 1
	NoElevation=True
	d$="c:\M2000test\"
} else {
	Title "Compile Dll", 1   \\ put 0 instead 1
	NoElevation=False
	d$="c:\"
}
If not exist.dir(d$) then
	batch$="mkdir "+d$+{
	}
	ExportBatch(batch$,,true)
End If
Pen #A7CC99
Cursor 0,0
Gradient #738493,#434453
Double
Mark : Print $(4),"  Make a dll, using gcc, load it, use it, and unload it"
Normal
      Data "F4","Run 10000","F5","Compile Again", "F1","Save as "+file.name$(command$), "F2","Exit"
      Data "F8","Edit Test M2000 code","F9","Edit C code - Press Esc then F5","F10","Edit Main code", "Shift F2","List"
      c=9
      For i=1 to 4 { Keys(c,0,"-  ") : c++}
      Cursor 0,row-4
      For i=1 to 3 { Keys(c, width/2, "-  ") : c++}
      Keys(#FF8866, width/2, "-  ")
      there=row
Cls #636473, there
\\ Scroll Split there+3
Cls #434453, there+3
\\ we have to open console If this script executed as an argument of the m2000.exe
Show
\\ a  c program is written in C()
A$= &C()
A$=mid$(A$,2,len(A$)-2)
F=1
If exist(d$+"adll3.dll") then
	batch$= "del  "+d$+"adll*.*"+{
	}+"del  "+d$+"*.a"+{
	}+"del "+temporary$+"mydir"+{
	exit
	}
	ExportBatch(batch$,,NoElevation)
	\\ alt "+" "2" "7" "1" "3" we get ✓
	\\ M2000 has unicode internal custom editor
	If Not @WaitNoFileOrEsc(d$+"adll3.dll") Then break
	keys(14, 0,"", "✓","Old files Deleted")
End If
open dd$+"adll3.c" for output as F
Print #F, A$
close #F
keys(14, 0,"", "✓","Export adll3.c")
keys(14, 0,"", "gcc path:", file.path$(gcc$))
batch$={move }+quote$(dd$+"adll3.c")+" "+quote$(d$+"adll3.c")+{
}+"cd "+d$+" && "+gcc$+" -c -DBUILD_DLL "+d$+"\adll3.c"+{
exit
}
ExportBatch(batch$,,NoElevation)

If @WaitFileOrEsc(d$+"adll3.o") then {
      keys(14, 0,"" ,"✓","Object file complete adll3.o")
      batch$="cd "+d$+" && "+gcc$+" -shared -o "+d$+"adll3.dll  "+d$+"adll3.o -Wl,--out-implib,libadll3.a"+{
      exit
      }
	ExportBatch(batch$,,NoElevation)      
} else Print"Error" :exit
If not @WaitFileOrEsc(d$+"adll3.dll") then Error "No dll error"
keys(14, 0,"" ,"✓","Linked with gcc adll3.dll")
Push row
Cursor 0,there
\\ Results
dir d$
Pen 15 {
      keys(14, 0,"" ,"Directory", Dir$)
      menu \\ clear internal menu list
      \\ ! sort by name, + not display just feed menu list
      files ! + "adll3.*"
      files ! + "libmessage.*"      
      If menuitems=0 then break 
      For i=1 to menuitems
      cursor 0,row+(i mod 2 =0)
      keys(14, 0-(width/2)*(i mod 2 =0),"" ,str$(i),menu$(i))
      Next i
      If (i mod 2) then print
}
\\ set default directory
If NoElevation then wait 2000
MyPath$<=d$
Dir User 
Cursor 0,Number 'pop row
Title "Done"
Show
Print "Perform Test (Y/N):";
Refresh
Clear Yes, No
Repeat {
      Yes=keypress(89)
      No=Keypress(78)
      wait 10
} Until Yes or No
Flush
If Yes then {TestMe} else print "N"
Pen 14
Escape on
Sub Keys(c, x,pre$)
local t=tab
            Pen c  { \\ change Pen only for here, ~(15) change again to white
                  \\ use right justify
                  Print @(x),$(7,6),letter$,
                  italic 1
                        \\ use normal left justify and restore column width
                        Print @(x+6),$(4,t),~(15), pre$+letter$
                  italic 0
            }
            If c>13 then Refresh
End Sub
Sub ExportBatch(script$, uselocale=false, bypass=false)
	declare local osinfo information
	local Elevated, userdir$
	document script$  ' upgrade to document
	push dir$ : dir user : userdir$=dir$ : dir letter$
	save.doc script$, userdir$+"my.bat", if(uselocale->locale, 3)
	wait 200
	With osinfo, "isWindowsVistaOrGreater" as VistaUp
	method osinfo,"IsProcessElevated"  as Elevated
	If bypass or not VistaUp then
		dos dir$+"my.bat", 1000;
	else.if not Elevated then
		local cmd$="powershell -WindowStyle Hidden -NoProfile -Command "
		cmd$+=quote$("Start-Process CMD -WindowStyle Hidden -ArgumentList '/k "+dir$+"my.bat' -Verb RunAs")
		dos cmd$, 3000;
	else
		dos dir$+"my.bat", 1000;
	End If
End sub
Function WaitFileOrEsc(file$)
Every 10 {
	If keypress(27) then break
	If exist(file$) then =true : break
}
End Function
Function WaitNoFileOrEsc(file$)
Every 10 {
	If keypress(27) then break
	If Not exist(file$) then =true : break
}
End Function
}
Function Global C {/* C Code for DLL 
*  from an example in M2000
*  Using gcc from http://www.mingw.org/
*  gcc -c -DBUILD_DLL adll3.c
*  gcc -shared -o adll3.dll adll3.o -Wl,--out-implib,libadll3.a
*/
long add2(long a[], long b)
{
      long i, m;
      m=a[0]+2;
      for (i=0;i<b;i++)
                  a[i]=i+m ;
         return 0;
}

long mult(long num1, long num2)
{
   long product;
   product = num1 * num2;
   return product;
}

}
Module Global TESTME {dir user
If not valid(mypath$) then Keyboard "All"+chr$(13) :exit
Print
Pen 14
Print "	Path:";mypath$
Pen #A7CC99
max%=200
Read ? max%
If not exist(mypath$+"adll3.dll") then error "dll not exist"
\\ we make a buffer
If max%<20 or max%>1000000 then exit
Print Over $(6),"Test for an array of"+str$(max%)+" numbers of type long"
Refresh
Buffer clear alfa as long*max%

\\ Feed unsign 100 to alfa[0]
Return alfa, 0:=100

\\ Now we load lib (lib loaded once)
Declare add2 lib c mypath$+"adll3.add2" {long c, long d}
Declare mult lib c mypath$+"adll3.mult" {long c, long d}

\\ We pass alfa(0) as the first long in buffer
Print mult(12,4)

\\ read from memory alfa(0)
\\ and populate array with values
\\ now we get values in buffer (we use as a Peek() this: Eval(<buffer>, index as long))
clear m, m1
Profiler
If add2(alfa(0), Max%) else {
      m=Timecount
      Print eval(alfa,Max%-1), m
}
Dim a(Max%)
Profiler
b=100+2
For i=0 to Max%-1 {
      a(i)=i+b
}
m1=TimeCount

Print a(Max%-1), m1
If m<2 then m=1
Print format$("C is by far the fastest language {0}% from M2000", m1/m*100)
Print Over $(6), "Test 20 Random Items"
Print Under
Equ$=string$("0",log(max%)+1)
Document doc$
Inventory pack
\\ choose one of two methods
If max%<100 then {
\\ use  a populated pack, remove used

for i=0 to max%-1: Append pack, i:=i: next i
            L=Lambda pack -> {
                  If len(pack)=0 then error "empty"
                  k=random(1, len(pack))-1
                  \\ return value (key as value, when no value exist) using k as index
                   =pack(k!)
                                     try {
                    Delete pack, eval$(pack, k)
                    } 
                    If error then {
                    cls
                    For i=0 to len(pack)-1
                    print i, pack(i!)
                    next i
                    test
                    a$=key$
                    }                
            }
} else {
\\ use an empty pack, store used
      L=Lambda pack, max% -> {
       repeat {
              k=random(0, max%-1)
        } until not exist(pack, k)
        \\ so now k exist, for the next time
        append pack, k
        =k
}
}
For i=1 to 20 {
      k=L()
      doc$= format$("{0}) {1}={2} ({3})",str$(k+1, equ$), eval(alfa, k), a(k), str$(eval(alfa, k)=a(k),{"Not Equal";"Equal";"Not Equal"}))
      If i<20 then {
                  \\ just a new line
                  doc$={
                  }
      }
}
for i=1 to 5 { print}
X=row-5

\\ sorting
Sort Doc$
refresh 1000
For i=1 to 4
      Print @(width*((i-1)/4),X),
      Report 2, doc$, Width/4, 5 Line 5*i-4
Next i
Print
Refresh 30
Pen 14
Remove mypath$+"adll3"
}
Module Global ALL {Set mypath$="c:\"
a
Print "Enter to Halt State - Exit using End or Continue"
halt
Print "done"
}
ALL : End ' statement to execute when script loaded
} as Export$
Document Export$
Save.Doc Export$, "dlltst.gsb"
If Exist("dlltst.gsb") then
	If ask("File saved, press run to execute it","Use gcc to make and import a dll", "*Run", "Not Now")=1 then
	Use "dlltst.gsb"
	End If
End If
}
MODULE VER10 {Escape off
Input End  // empty the input buffer
keyboard " "
prmaster
wait 1000
function dummy {
	ro=row
	ok=false
	try {
		keyboard " "
		drawing { prmaster } as A
		refresh
		move 0,0
		image A, scale.x/2, scale.y/2
		wait 300 : refresh
		move  scale.x/2,0
		image A, scale.x/2, scale.y/2
		wait 300 : refresh
		move 0,scale.y/2
		image A, scale.x/2, scale.y/2
		wait 300 : refresh
		move  scale.x/2,scale.y/2
		image A, scale.x/2, scale.y/2
		wait 300 : refresh
		cursor 0, 3
		Pen 11 {
			Double
			Path 11 {
				Print Over 
			}
			italic 1
				Print Part $(, width),~(4), "M2000 Version 10 - direct output to a Vector type drawing, inside a buffer object"
			italic 0
			normal
		}
		hold
              Again()
		release
		drawing {dd8grnew} as A
              Again()
		release
		ok=true
		100
	}
	if ok else while keypress(27) : wait 10 : end while
	cls 5, row-1
	Pen 14
	Sub WaitKey(wastetime)
	Refresh
	Profiler
	While wastetime>timecount
		if keypress(32) then exit
	End While
	End Sub
	Sub Again()
		WaitKey(3000)
		for i=0 to 179
			if keypress(27) then 100
			release
			sprite A,, i,15+i*3,50,1
			refresh 1000
		next
		for i=179 to 0
			if keypress(27) then 100
			release
			sprite A,, i,15+i*3,50,1
			refresh 1000
		next
		WaitKey(3000)
	End Sub
}
Inline Code LibFade
FadeScreen &Dummy(), 30
Set Fast
escape on

}
MODULE CONSOLE {declare info information
global Const newline$=chr$(10)+chr$(13)
Thread {
	Print "Thread running...", timecount
	Refresh
} as MMM interval 1000
back {
	gradient 0
	x=motion.x div twipsx
	y=motion.y div twipsy
	w=scale.x div twipsx
	h=scale.y div twipsy
	hform=hwnd
}
Declare SetConsoleOutputCP Lib "kernel32.SetConsoleOutputCP" {Long code}
Declare GetConsoleOutputCP Lib "kernel32.GetConsoleOutputCP" {}
Declare SetConsoleCP Lib "kernel32.SetConsoleCP" {Long code}
Declare GetConsoleCP Lib "kernel32GetConsoleCP"
declare SetCosnoleDispMode lib "Kernel32.SetConsoleDisplayMode" { long cons, long b, long opt}
declare GetConsole lib "Kernel32.AllocConsole"
declare FreeConsole lib "Kernel32.FreeConsole"
declare GetHandle lib "Kernel32.GetStdHandle"  {long a}
declare CloseHandle lib "Kernel32.CloseHandle" {long a}
\\ mo closehandle for these handles
declare ConsoleCaption lib "Kernel32.SetConsoleTitleW" { a$ }
declare global WriteCons Lib "Kernel32.WriteConsoleW" {long cons, a$,  long n, Long  p, long u}
declare ReadCons Lib "Kernel32.ReadConsoleW" {long cons, long buf,  long nbuf, Long  p, long u}
Declare GetConsoleWindow Lib "Kernel32.GetConsoleWindow"
Declare MoveWindow Lib "user32.MoveWindow" {Long hwnd, Long x, Long y , Long nWidth, Long nHeight, Long bRepaint}
Declare SetWindowPos Lib "User32.SetWindowPos" {Long hwnd, Long hWnd, Long x, Long y , Long nWidth, Long nHeight, Long uFlags}
Declare GetSystemMenu  Lib "User32.GetSystemMenu" {Long hWnd, Long bRevert}
const SC_CLOSE = 0xF060
const MF_BYCOMMAND = 0
Declare DeleteMenu Lib "User32.DeleteMenu"  {Long hMenu, Long  uPosition, Long  uFlags}

Call void GetConsole()

'Call void SetConsoleOutputCP(65001)
'Call void SetConsoleCP(65001)
Long  m=-11, m1=-10
Call void ConsoleCaption("George's Console")
m=GetHandle(m)
Global mg=m
Call void SetCosnoleDispMode(m, 0, 0)  ' 1 for fullscreen
wait 10
'Call void MoveWindow(GetConsoleWindow(), x+50, y+50, w-100, h-100, 1)
Call void SetWindowPos(GetConsoleWindow(), -1, x+50, y+50, w-100, h-100, 0x0040)
Call Void DeleteMenu(GetSystemMenu(GetConsoleWindow(), 0), SC_CLOSE, MF_BYCOMMAND)

wait 1000
m1=GetHandle(m1)
Global retvalue, back$=module$
buffer clear retvalue as long
buffer clear getchar as integer*500
Rem Title "", 0   ' minimize M2000 console/ hide title

For i=1 to 100
    PrintConsole("Καλημέρα - "+"ברוכים הבאים - الجامعات والكليات "+str$(i)+newline$)
next i
Print Eval(retvalue, 0)
Print m
Return getchar, 0:=0
refresh
Global help$={
Change Font to Courier New so you can see Greek, and RTL text (Hebrew and Arabian, reversed displayed)
Write some characters and press enter to close this console
Write first letter * to pass the line to cmd.exe
Use Echo in M2000 prompt as Print statement (list of numbers or and letters)
Any statement can be used in M2000 prompt
for i=1 to 100: echo i: next
}
PrintConsole(help$)
no_prompt=false
counter=0
Module Global Echo {
    a$=""
    while not empty
    If islet then a$+=letter$+" " else.if isnum then a$+=str$(number, "")+" "
    end while
    a$+=newline$
    Call Void WriteCons(mg, a$, Len(a$), retvalue(0), 0)
}
Do
    line$=""
    PrintConsole("M2000>")
    do
    Do
          Return retvalue, 0:=0
          call void ReadCons(m1, getchar(0), 1, retvalue(0),0)
          if eval(retvalue, 0)>0 then
              If  Eval(getchar, 0)>31 then  line$+=chrcode$(Eval(getchar, 0))
          end if
          wait 10
    Until Eval(getchar, 0)=13 or Eval(getchar, 0)=10
 until not (line$="" and  Eval(getchar, 0)=10 )
    if left$(line$,1)="*" then
        PrintConsole("write Exit + press enter to exits"+newline$)
        if mid$(line$,2)<>"" then  dos mid$(line$,2) else dos
        do
            Method info ,"IsRunning", dos as ZZ
            wait 100
        until not zz
    else.if lcase$(line$)="exit" then
    	line$=""
    else    
       push line$
       module privatename
       Try  {
           inline letter$
       }
       module back$       
        er$=error$       
	if er$<>"" then echo(er$)
    end if
    wait 1
Until line$=""
Print len(line$)
wait 1000
Call void CloseHandle(m)
Call void CloseHandle(m1)
Call  void FreeConsole()
' reset the original title
Title "My Console"
Sub Echo(a$)
	a$+=newline$
      Call Void WriteCons(m, a$, Len(a$), retvalue(0), 0)
end sub
Sub PrintConsole(a$)
      Call Void WriteCons(m, a$, Len(a$), retvalue(0), 0)
End Sub
}
MODULE CONS1 {Print "This used to close console if you do experiments with console module"
declare FreeConsole lib "Kernel32.FreeConsole"
call void FreeConsole()
}
MODULE TST {Report "This is tha way to change the name of a module for using another set of variables"
print "name of module now:"; module$
global back$=module$, X=500
Print X=500
X=300  ' shadow the global X
Print X
Print back$
// chane module name to private
module private
print "name of module now:"; module$
Print X=500
X=1000
Print X
// return to standard
module back$
print "name of module now:"; module$
print module$
Print X=300
List
}
MODULE PHONE {Δυαδικό {
      UklGRpYUAABXQVZFZm10IB4AAABVAAIAwF0AAFgbAAABAAAADAABAAIAAACoAAEA
      cQVmYWN0BAAAAMBFAABkYXRhWBQAAP/zdFQAD03U4fahjAEAqAIAr0AAAAAVtCd3
      iISFv6IjmgAI3fc4ibvucRN33OIld9ziJu+5xE3fc4hbvucQt33OIW4uAZoACKHF
      m5oiVxZucQq7m5xCrvucRKHFm5oiUOLNzRCocWbmiFXfc0RKHFm5oiUOLNzRCru9
      OJuHfc0RKBgZuaIVDizuibhxZwQL//4AOBFDYlEolAAA/RkiQZkdqiO7AbE4Yv/z
      dHQWEzDdUNzN0AEBIAKgr4AAAGEkxaZwJGAIGfmJgatgOVhYjfAYJAGkQzQYgCYs
      AkD4c8DDjw3QFhwLjgArgGHKgEh/jQBsgFE4BggDODAMgAAxYsDDSQMKIAZkfg5k
      DbAAoADcQWkHAGgYJDwHDg+gNjYCBH9VSmoKZ6SX/trdSzewyD39Pen//5Or9m//
      +QuDH+yU////gACgN/ipJEKMANtyIf/zdHQLEpGvWH/MKAEBIAKwr4AAAMQQSUFa
      lDjaUeMBXCWEO4G2mRYY880Kc6eFIqE4tCkZgoGIrgVlESGYlC0TDw8TiApc4Xkj
      FDS7ziFY+JnQ2Y6Kee2pplDTppqWPPcxWNpzyYlOKl2jAiJChjiyYeYhRiyF2f//
      ////5qsm6pN6qlus4/3syO1EO2VHqYqHFTnwkwYbCjvggldf////gAAAAPsJSv/z
      dHQFD42JU/vpoAGAqAKkr8AAAJgGGCyo6MqBw2HHEaK+JSM5ZIx5y2+u9A9vk9bg
      R1xsWqB8fjgsuT8cc/zF/OYtSe4i4u0RHKzEJV3+56lKZ7K8CCHAcwOTr6/////+
      diucf/ekd1cyvezSb21Lzpc6i28b3Xym9hxYcf44toBY82Pltj/5zVda3///AAG5
      gABw3QEqIOzbgKyXe/rcxGMv3csSHv/zdHQZEQ2TWfxhhV8AqAKwrgAAAPLfMwVs
      5kbsd7VV7a14+m+dCk3ykuqrEBateL4M7lREkiK7y/2+/Ntjd4+vF4fQfXU6cxmI
      HCuLg6wOLnUOArsBBpGOi1///+3Qizvnsrq5BRUIykVzKqMpj6uiFQqo6uV0EDuZ
      ZOMIi775lKZgp////wAAeUAhucwbZKDOUJdw5SPiCIOJjBQDb+T96TPs/c1fLP/z
      dHQhEGDhV/xhZk6AwAKsrgAAAPSN38PfarGaLpaamhQRBmHgkDcSSeWFtnFsvJqC
      jExAgQipBWxCF+rhinowCSU6rhjJZZeqEZ7//////8V2ecukhlbrKsDhJtDyY/8M
      2ujlZNrBrsfv9MZ/TK/Bnc1kFzFf////AAB9AKb/WbdR4F7rIU1JdZaUHYdTHK1z
      79pv7RItIKSXWFeWPQmheTUcg4cwmP/zdHQuD+XdW/xhA16AuAK0rgAAABaDQQRd
      atDUxxpcMeNPoRRgAwut3dmKQyYhShAJ0DFvGMm773//Xy///8v3nFaE6N2ZmTlZ
      nVfeP7F6r87rf86MSanLVzXl1K31JvsPp04M0////wAAvABpsv7OiOK978FjgQUd
      l7wAECOsn3dq7z/Hmfd8Rt7L1WSmY1VCdHMRLmHxFoSONGnBgW4Ogt6tPBeJjv/z
      dHQ/EAlhV/xgwn6AsAKsrgAAANIaKh0HMyd6bPeLuSNas6wb5JUFVbf9tq///2rN
      QzHnNLM+lKtdUKpgYmh0xDRSNeVh8UZp11M7Db/IY05W6TrHf///AAF8Htbwjw4c
      ndhBLTVUQx0sfbbAXE7u2H15Io/qj9NbVBTLqSLTa0pFRQCIHUDYOgsaI7Meo8VU
      yBGEWoYcfq2Lz4NcoQMmBgdhqHK8Yf/zdHRPD213U/thA14AqAKkrgAAAILNDy5/
      //M///n/PNrKVVvkucamWUpLZFzaLXGsl2S1TZAnBFgHFRCLLZJp////AALmLvJh
      ByEKeythyj0tEutvfn+DWDWaNGQpoOqPumIpxh9KEKqSbkUXuQlXh0t/ip7YcXFN
      S039JXmO9bnhioomA4razI7PtR9qS8i3Mifn+9T+xF2CCBgAQMADABVBBS28Rf/z
      dHRkEKnPUfo8w3+AsAKgrgAAAOe98+u6o/UcXAOBIidJ3PIQlJ3f2NjEGbTpKGNE
      GEsWr////xgjKbGMeBMHHUUJAQU55NqbVvCr8NSdfLNmVpGHgAWUHhIF6IHkA8NC
      UelqItULoo9eYfs9UnkmLopiUdS5toaIBsTQqICkGMrkkJZtUlRS3dwNGXDNEVET
      1rctdDXIsdN9OTWhS3S2tzS/NI/xz//zdHRvEUnZRiFgyB6AsAKMrgAAAAZMTcV3
      F/W8esZ1PV13dPcLNcc/P96u1DFzZ////4AYECSSiQgipJYtIS95IeSeivrxS9w3
      KhBfIVd5MsILjZJBdLiMhgwlBdbrXqvvLl3ua9K2rsMRq03O9yc92Pw66azW5acH
      XFFdwnD5HsKM099JUIzpxEUQQRpo8Ka33//Y3hHMRnM95Sb0zOFq5AnMGDakGP/z
      dHR1EDWtRLUkI/CA2AaIrggAAE4RU6Oqte/82H7Hh3v//9eDCIPLNuK+6kr7r7OL
      DNdLdKayxLtU97Hp4WmYo3YsUsPNpHyspcGP0U9c0Fh0hquTtF8eX9PpxcoakzVb
      dPWSmcyocbkJNuY1NjbG7lhdJARwLqf/ma3qVA3acNifxX0p//1W7DcExsqoZtRq
      j4pigIkFEkTOaLKtEQKCmQnREPHGk//zdHSDEGG1RGUww6gAwAaIrggAAH//+hgV
      HwnEV8kyshrzirG1ULUJ7CgW3/TOob/ClOBTNfgYnDCVP17m7q5NImDmirlCjD5k
      1udUJW30olNCi68zzkvN/1/+cChL5byRz/XzzxRQ/NSyY6Xfv9EqhqApSM0OGpef
      CJj/7YdJVFBQIqbCmm7mwEgoKN/FXJ6A7Lvgu7hXgvv//9fyI9GFBjVSz9kis//z
      dHSQEDVrRfY8w4yA2AaIrggAAAM1hu5pDiUpgtnuSbARnrmWWq90aOvXtLCNQh9B
      IzR20lWvwRJ5VLIRFl9Vr9MzYskoUSVzmcr/e9jIjq+kLYSv5VFuELOmJdPTLf3d
      HF3////8/PNb/PszziQ+nzKHo8hGVM6k9DLRBdKeRtvPsHAHtOzq+vff99H4ADku
      R1g9SGIdJQQxayS7YEvM0oIZ5Gh2EP/zdHSeEHGHO/VrIxyBYAJ0rgAAAJSLdF8h
      5hf1qw32OL4MVqxAKhTcXmlm2uzGmLXrfSzI+W7KlBGjgAnSxu09CbahsQIeII+t
      WVmFXOlhjmpGx3gLDm2HFsSbwuQoVaW/wsol6aK8lBw1N2/zNSHnhszxuO6bPWW4
      LwvgfHfn6DdN5NQfH//7l0/P6SaAGAnAtpKBgQAC4AGTAkCtqYoVAAGLhigILP/z
      dHSoEMFFPApvIyqBQAJ4rgAAADz/VY1rHBpbiz9VYV5KRjSfVFQS+ok+yVbGcWyF
      Q1TOUUOGtQ7t4MaKMuyF27QV/+Oet8i0/kSHSCk6oPwlL9UTOeti5ozXX55nkRTf
      YyhNhqDgqgRsRJMlTobY66nLQZW6dLHhh4q4r4///cUpAAALUECjkte44wXHgaPk
      hsZQCupOGLiQkQ5QS41v5v+ZNIRbR//zdHSwEMVrOgZso4YBOAJ0rgAAAKOIlcSH
      fa2135Fdmo36bjdpXWSvo15CJDkYH6tvJMLqvYr0Jk0H21HwiUEt6AxmQdFDPfq2
      lVIrIa5inc6EPZaczsuyLfK21Q3Hwvd6JiMJ376FxkkbBULJWCMkoBef//3JkCAZ
      ilbgc99nUEJAMnuqpSIVJEYBQcGAigBKK/O7qQH3F4IOtPQ1C5jfut4i8TzVX//z
      dHS4EGW5O/xtImwA+AJ0rgAAAH3w87mpeHbVNUVmNuv/iVOCSfuHfhX/Mvp+/YOj
      t5rLMUKrExZf9lIo3aZ0mjByaqCNqRNUsn6FT3Ze5JQCxbT6ffxvf6t7txnJMzzM
      N/n3fT//+5FEJf5eZvlm77mpVFHPF4LMqK041MRAIGCgtNimXl8FiwVL5lZ6UEwQ
      ATY71NHZuiRa7JHjcHqWWlRjX3GMh//zdHTEEEFrP/Zow4iBAAJ8rgAAAIl0dHRJ
      ffowQVMB4GwtLHZT0xsU9VK+9T1djFh3R2KU7mIdW009ZbUeZW2p9FavZSXMpaPc
      Kouwieb7H6+/KPZ6IuB5iaiTQv//sWXx//+NLUfkLU43AyecZJB4hCwcvQqVCpQz
      bBlwQVXqYKUxKDUf2D5Dw3LBBt5lpNl6SZyWOfXqKTaimlpFlRA9tRhG2yFDT//z
      dHTREVFvNAFtAoyBYAporhAAAJdeU9V4lsbIzNN+I1osaNcfSVMIuZTTFxSVURdn
      R1/HP3Fp9xtXxpC97JVvUH9lDzAnF6OEKkvt4j7+uWtpiG4iXoZL6wt8bY0Kjcv/
      P//7sQAwA/FdVUR45EIvsQkKS1NDLQ0gbr0tQzysvblcS7f2q0coDZ+1HaLPVLnm
      JiXx1Y9M+a82cfsDGhEHIrVNLMKVRf/zdHTUEcHHOfVt6EYBAAJwrgAAAQDjSyRT
      n7h/G8PCvKclt9Hc09UIyyPHXcINZJuZ+a+Nfpo4Weoi9uJi9Jtqa5j4ZaibMYZ7
      iBfDpkf17fD7NNUh3rRO5HWWsmOsv7R///GqfRpKK5hUQGKb6AADBQTOw4nS03Fp
      T+3M5iK51Htk8Yglbj8hhwjx+rpyoyubKMKzpO7X35LWlSivgIVB5DZMlu5rof/z
      dHTVEb2lNfhsyIaBCAporhAAAKhpEIVou35/u6W+47MWEztXea7FO1UlsmnXmobm
      3v3Oztfd/dnmIIIApuVOPdRVedrxtu7P87z7V4TuTpeYenJf/LMDfhyvZojmBqZj
      CTV8JfP//4ZXChcC9wQFOQCUyX9MudJpZffuabHlvsNcu226yJWZyHBbqsZ2rVyW
      bD5ctKSpUVnh9abDvm7CckLYkCB9bP/zdHTWEpGBL/RtJnqBIApcrigAABKIxiLr
      vhBITloQhe1c7Ehl8pMx9WXrxDIjwlR6tdiucJQZk4QQTxDct8WZZzzMqhbfa2Nt
      pqOGcZ1ikC+/VK6jE+D0x24oXOdZsR6/D//+HU8rhseewjEGIGRwxEKCGHejrYnF
      uZ2t7t3nFfRdq2n7lAahyUeaXMq2pdPiyRTkfn7dt/7tmKpTLYdjM+B1iAeDQ//z
      dHTQEUlZKAJpI4aBMApQrjgAAKgYnc7J9WuChQ3dstZu3msz+v37bv6m1virbHr+
      Zfw/rvJm0mQZI+rL83hamD0lwnyTGHu/1IOll1Ss+tN9nvLt5m//+wX8spzCHXB4
      hf//4MUED8lykBJnKxoXAbXDcWH4udxNyTtK2hEkqoWHbutNspVIA4OzR4fh8TDb
      Q98YdB8LCoqIIXNBSafTV8x1xDDRUf/zdHTUEdkxJgFhhniBEApMrjgAAI0NcxK8
      /NRUO7UlDBjzC/cqiKNWFrR+ZMsmhxQkPUWIEiQbDNGYXDdeiW/J4chz+M19Ys02
      JOXfVzp1su3PXVF2t6XwlPHKPBauP//8NyGQMI5gN2AhFjN5hJ4plzB+rT+Yby5W
      laaq/3jgVxYJICkmMQsocbmeA2GdWRvfLGqyl10ZKAosIyFIkfiyFm1NLjE6h//z
      dHTUEWXNLfc9A46A+AZYrjAAACDwOFEujjLV8+ps6nN0MlyjF0RHImmX6ysxgIEF
      2CrLCBlJ2GVvfbP8npGXM1NCEkZZmpA022VYpz/5+fB58hjBigV+m0b///CPEp4A
      6BvxFWpQvMSLht9o/VceFsPil7URoaYeAnAOLUj5mSoV3edoUbNC0bIcTvZLDXO7
      S7lyETCMX7oyuZbWKtnUzJyEuCFUHf/zdHTYEV1/JAFlI3iBCAZIrkgAAFFUYSQ7
      kHj1waaO6ohmhVVhe+tTJO1yiXk2vCwRsxgzp8m7d8zJFPr2ru0Tmk3OntaxWzGK
      PD0tov2vmuKuZht4U36B//w4v9Ui6DFhRdsWsRPbEl40fsunIHdWJxXGmvY77RMy
      nKsQs2oWi0wN5G2UCoZZmy9p2T+bOApKNIpJqtbLZpzUDgkI6siGsQ7JYOoWGf/z
      dHTcEYWRIgRlg06BeApErlAAANPYslpBi1PZjRFxTbLd/YyWVyOQsyslv/ye6lL3
      OSnxgaMSlJ72HHhC/ERFzJXkX3OJ5MRkDN/2fRICmxQ/w4cuu/+v///6f////6NF
      YwsI8Los0NFkBgcaQhSSc9zHHFhLKg1kgUlNJYSltkg/UgKZgjaZsteedjcJ1WXH
      jmiVJdpmT2urahhnQEYYKyspgxnGFv/zdHTdEQm5IgFpI3iDcApEBlAAACTj2XI1
      MkcIOjgnjVlDWRxRUELKw9iZQzMUP2CpTZdTVl/XXXyMmhoaw/nw26VhlbNjY/hw
      ypK0pMZGVpUqWy2bLlUEzBQrIUst+AAFaVBl5pxHJxJTYP8wO0hTIQ0jSOBmMWpK
      W/807OUVcblScWJBYWFhcRmQEEhXqmgKFRZv1Cwqz6xUW/izNTf9n//2f4v/WP/z
      dHTaEi3FHABpgz6CaA44HkgAAKfwIcJZHOSDtIUyENI0jgZjA6kjWb+adnKKuNyp
      OLLgWFhYXImQEEhVmpBoGQqLC3uULCpxPrFRb+LCupvW3WKf//FP8X/rFP//////
      ////////////////////////////////////////////////////////////////
      ///////////////////////////////zdFTSCBBJBAA9hgQRoJoIBnsMCP//////
      ////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////w==

} Ως τηλέφωνο
Ηχος τηλέφωνο
Τύπωσε "Δεξιά"
Ένταση 100, 0 ' δεξιά
Αναμονή 1200
Ηχος τηλέφωνο
Τύπωσε "Αριστερά"
Ένταση 100, 100 ' αριστερά
Αναμονή 1200
Ηχος τηλέφωνο
Ένταση 100  // 100, 50
Τύπωσε "Μέσον"
}
MODULE RING {Δυαδικό {
      UklGRiInAABXQVZFZm10IBAAAAABAAEAESsAABErAAABAAgAZGF0Yf0mAAB7MGWN
      hryadlM8enqcvmp0blCLkJqPdZx1gZ9WdYd4sKGQbEd6cZzVioNqPnaKqqV6hk1d
      mW+PlGyQg4yAW4BiesGNj3pBZXimupSaUkSLdJyyfYJmc39rmnZrpXaDi1drZYem
      jKRhPHVhkr2UjFhcb2uwlHSXX3CMc4hzhZV7qXtTgF+Gt6CgZVxlXbCtjaNYW3p5
      oIqNiF2QfmSSZnibjaF1aWdLl6iSsmdTammhoaWZUnl2ZqqKgpB2j3h9glGKl4Gz
      eVprXIKPpqNgdVxaqYuDfl1+eY2UWHhzbLiSeHlVc3alwXqMZz6LjJGge4NnfZdg
      iodfo5eMimBzYoW8g5ZzL3B9lryXj1VXh2aZoWaUdnOKa4Fqeal/mohDc2+HvKGj
      YERvW6DDiJJgUHF0poqAnl+ClF+GdXmcjKFnSXNMjMKVoWZHW2Clo5KhTV+BYJuU
      g5J1lHlhikmBvYyWdoVrW5J4ucRsZHV1cKHLhX+VS3GVdaq4l2llgFtzq4eUj2+D
      gW5YdZt/foZIUmV0q6mGW0xhWoizhYN1YXp5h4J6moCRoGVscXmlsKp9VWRTe8Gm
      nINaYm6SmYycdG6QcHWFfo2NmYBaaVVpqZ6bi1xVVYCalKhzWnZmgpyLin2HgGaG
      a2mckJmWaVxTep6evYdWalh7qaSWb2xrYJWNdZZ+g5B4cVtzjYayklxpVWygq7CC
      cWpRjKGKpoVxfXOGfYubfaCXaXpkZYqVqYdzaj11mYyujGVgWnt+kZ5qgntihXpr
      jaScjHhuUXCfhbCkYG5nc5WgqH1zf1uGl2+Pg4KLeINaYJuFpalhZFNmjZq3f2J5
      Unagg5aCeX9viGxmkX+SoHNvYGqNkK+Vbnlaa5aRmoV1cFuFgnafenmQcHhuc4N9
      po9sg1FflIylkn5rTYOIg7mIeYxrgYWQl3qkkG6Ua2mVi6GZi3hHdoB2vJVreExs
      kJWSeIh1VYZ1a4+Dh350g1h7inCjknZ9VnWHjaiCiHVWiIWHpoGCc2uPb4iQZ5WK
      epJ1dnGCpXqPf0d6gIKukopvZoNwlKFmhXhii3qFeXSVc4+bXHt/dKSVkXFbfmCK
      snmGeFh+gpmLeZViep9shYZnh4WPf2J7V3mqf5J/V25ujJGClV1ij2qRl3aFcYV9
      bJFha551jZBndGaQmYutbl+DYouukJJuf4N6r4h+nG+ClnuBa4CHeq6AYoJbfZyG
      nH17Yj2Zh4GlbnZ1dZZ/no1mn25fmXOPlYGMZ4N7aauDf7SIi3pmgG+alG+VXVqX
      hpWNeHpVfX5dkmlhlHR/emp5ZJqhe6FpU4p/l5uIgVJ4iG+tkG+UcHuDfopkipRr
      mXhXh3iLkoiITnF/YaSVb4hkanWAm3CUj1qVhW6UfoeIh5JdfYVfpaCClm5xdIeu
      g5qPToOBcZyBg3h2jGB9hleRknOLZmlldKF6kpBJdX5woJKRe3CQZoulb5qbepV+
      gnh6uIOUklWNfXiSh6BzboZag5RwlX1udGR/XH2laoV/UXh5g5eQl2R2kF2MmnaV
      hn1/eY1vj7BzjItXeIGMlYuWXWSMXYuhdYd6dG9vkmx9pGZ+iFp1fYeLh5pfYYZf
      jKuCjHt0cXWkfoehZXqIZ4CFkIyDnGFiiF2HpoiLdW9pdKqDiKNhcYJuh4iVhnmZ
      ZWmVboyojYx0dmlppYeGo2Jmf3OIl5uCZn9hYp9+i41/cF9zaXOqjH2RWFh9fZuU
      o3lTgWZ5uZuUjWxsZ42RhbKDbIhaZYWPpZacekd2ZHOwkYN1XFxfkpmDrnpYgFpw
      j5SagI1qSX9zgb+Ri4VhdXabq4updUl+cYOon55reXhVko+BqYp2eGl1bJKcb5Zr
      S35xhaCUhl9pZVCXknugdWlrb4B5m5Vrj3BQgXWGl5SSW3WAYpqmh5d4amlwjXih
      rXSLgG+PhZeah5JdbHtcmptrmZdsbFx6h5yqXYd6M4ybiKSFcFhplXqtpUmDc2CN
      gY11fauBmYA4f4eUt5KKTFOWg7izZX5ia5mMpHFrlFyGiEh1c4GojJRRSI1wr8Z0
      fVVQgZC8jWyLSXWldJaAdYZ+nG5djFuIuH2LZFV0ericfpA+VpB7qZd9fmSXgXam
      ZH2me5J7ZXBpq6GIpENQhnmvsI9xR3p0e75vcItchoqAfl2Lg3WoWk52WJSgmoZE
      amVpwZB7i1Bvf42bb5V7Za19dpdujJqfnl99ZlO0nJKgXGBuh66Io3pCjG54oXR9
      cX+Qa5FzTaCIi6RpZld1oIqziEuBZ3aylJVxb4BioZJkm3t5pYWCaXGQdbOcV4BW
      YaSepH9pcEyVo3WlcF2DdYp4eYhflZpgkWdbj4yoi312PoKegLmFYHZnj4qVmlWG
      iGShf2eGeZuKio1Ce4t2uZZvcFh+gpu0YYF7UZyRg4xwhXGDn1V/hV+mlX59WHVu
      jbhvgnY/h4+MnHR6Wm+bZo+MVYyKf49uf2J6rXWShkZ6g42pjY9bZJlupKZig3l5
      lICXeGuadJGcZH1zjZqNjFhihnCfqGl6aWuMhaNzb4ZVkaZ6jHNwgICkdmuLWouj
      eopqZXiAr4d2jEh6nICceGxsbJ6DgZRVdpF2lXpzbmKZfn6VTmmHdpyPe25flIGP
      rVxvemmXlIp6XIh2hbNsf4Nql5WXhWaMdIK4eIWCYpGPn5JkgmJsq36CgGyKeH2X
      l5RhS4eMgZJggXprsIuHfVyGdnuriotqSYV7nJpummBnvaGjeFF2bJqUZI9SXbmb
      mm9TZFKcpnOHOjqWhaiPYmZHkauLrmRQkH2ml3B0RoyrkblsUoh4r7iPgz91lYfJ
      hWaCW4yej49QeIVst4BffVaIm5uXUG90ZsGfeoJEcICUrWV7a0ymlH6PUXB9ja9n
      emFCoZaMkUdaXYC5gZRsMIeAi6ZnblhupHmXf0GRhZGzdHpfc7KRsJRCf3GFwpqc
      aWmWda2oYI9vc6aDlGlmjW+qm0N4amKfiIxnVX5HlbdfnnFaloOUfWmPYZyuU41q
      Za+esIBgh1eZvXCkbFCMeKaSdptYgqRdlnNaknWcgFuDRHqvcah9UH5kmpp7oEtz
      lFufgmuQbpaHbJ9QeKZrq4hielySlIe4WmaISZuWf5Rgg3Bqq2J9nFicjXGLWIqD
      erxnc4ZJkZqQqmqDaViwc4W1WoKLapJ6mXNxq2BpgEyDj4+fYnBWTKt9kK1YeGlv
      noatgWGcXHOpbpyZipdljWpbsIebvXCAZ26fh76QV4c/a7KNqYdpcEuPgmCpZW6W
      WnhlYYhsqpJSikRdq5S0kWVpPYakgMZ4X4pgkJCHnGqZlmChaV+fgqqWdHg4dpl7
      x4VTcUR4jI+mW354Rp6Ab6BzioJzjEJ4jGK8mW+CTXCMnMt5gngykpWLtHqCeHao
      a4ubWKuXdI1Ra3OHxH2GeCZ5iIe9fnlTTJFnmqpVi39nnHaDdYDCbnmXZIZ7ZKqp
      knZXkWmI2ouMiE5ucIWXl7haQoJJfq+Lo3FqgHqcV1eaYYeaWnlfe7OuwWdNdj2D
      xpKeX1Nva7OQe55Wdqh4kWtqh3S8h1uAPWm4obN+XFtBoaSHsFFVh3GfkIiMXJeG
      YpZMXJqAqIZuYjWGlofHcVV1UpahoJZOf3NdsH5xmW6Xj4iFP4GLesyUZnlMf5qr
      t1t2ZUKmmoafZ3l0fZxbhYdarpJzg1FvfpXBdYJuOaWblKmPkFFvgnGwpnGPlHSB
      kIZulpJghm9aipJ9g4Z0WHl/YoyUe4t6UVdvgH2UkWJ2e26UmoN/gHpsg41shpd/
      lY9wZXuNja2mcG54aY+okoB2c119lnmCkW92inlveIt5j6Fubn5peqCbg3pzV3Ge
      h5GXbGZ/gHuNl3aCl3l7f2t4iJGPgoJdX5SFkaFzYG+BgI+hcWmKcXGSemp7ioiH
      lWpbg3qGpYZmanFxgaGDaoJvcZaNe4KLf4CbfmWHeX2jnoV7gnV9q56BkHNihZGK
      h4txZ5GHc4x+boiUgXR2YVyNj3WIb1J4iICPlHZmi4B1koZseYiBgo9+aoqQgZ6K
      Z3R/f4ObjGuIh3OXlnmBh394i39ce4BulZl1dX95eJeWbnt2WnuNfYKMgnSGjXCD
      j3SFkXlueHZsh5t5gIVgdI+Gh41+YnOAaYCRcX+KeHaDgXOLmnl/h2Rxi4WIlIpr
      dYd2jKiHfodzb32MeoWPW4WXe3Fdj4ODkmmAXV2bkZqLboNVbrCSso9XenCAkJWl
      W3mph6iCXXt9kZWMjTVVoIq1o2lhUHiSobBXWoJVkKF2eF9/i5CvWl2LaqG1hW5G
      ZHmZ0INzf0iDtKSedHpudrN+fZFWgqWRi11qYGzBkH+BL1WFlKqFgVhImYCLqFtr
      e3mSeodmVaaNi6lVW3aFtKSkajV7cYXEgm9qXYOCpIhSiGlsqHFnbGKMi6mKRnVa
      Z76ej3pVamqmsHSebFOfj5SVe4Zwm6NijGdTpp6fkWZnUIuwg6lvOXFsj59/e1+A
      hmWMgV2PioKkeG5idZ+PrZZTa3uGt6SRb2SCcKCraYeNgZyGf2JmlXucqFJkb2uW
      n6FwV3lVg7N1h4FfeHuLdnCVb4WpZHp9ZYqPpIZpfk5vsIufl2FqZoyLgaFma5Rn
      gpBufnmPhm6LUleUeZehbGVTdYqIun9hhl1+noyNdoWCbKR6YqB7iKB6g2pxg4O3
      jV9/XGWfnplxc3RVmpZxmXlrg4GWe36IZ5aRcZJsapGNo4d9fkyFoY20h2l1cJGQ
      m5dSeohroY1weXGNgIeIS3CFbqONZmdYeYCWoFZseVqZoYeFaX12iKpqeoVdkZqK
      hmt/doy9gYCGU4WakpFvdV9so32Dj1Bzf3+Nc35kZpp5g5VXc4GCnH+FYVaMe4yo
      aW50dZyQn3pYjXaDrnl1fXaUjKWCU4hxe7SDdW5geYClkFiCZmWmioN6anFvo5FV
      aX6DoYpXeH90iqS+bmmaYZa1gY92WoKkvnplhlaIt42WZliCo8F5YnZBeLOVqnhS
      e4aphX2KP2abgJt0WnRupJV1ij5Wnoqoj1thUpWejbBYUIZ0nKR/eFKBi36yaVyN
      eZumjH1NdIN5uXlXeVaBo5uXXXF0YbCRa5BfdJWLkWBzfV2tnmuLWGSVlql0cHBH
      lqqBo25be3qcfXuARIWZcZlwWn17o4Z9gjxwlXqpiGJsX4+Qla1deI9qoJl7hWyM
      iIuuZ3WWc6mphn9aeICIunpvgE6Cm4+Xa3ZsZaF6cJFbepKFkWZ2dGyzkXqQUmaP
      kK6Lh3RQlZKIsnlvgniZhYiFWJKSe6BuXXh4npKMfj5wfnOuimtwWHp6iplcgYFb
      lYBugXCIgYubWHOBYKijhYticW+Fs4GIi0uBi3+egId1c55vfZBaipqFl3FxZ2uo
      i4+cTmV9daWWlHpbjHSArXOBjXWUgIJ5YJuGgqhgZHRnlpSXhVB4ZGarg4KHYHVz
      g41pkH9noHpvgmmIi5ecYnlvW6ackZpndGuCoXuXi12QfnORdouFh5xme31WlJWH
      mm5wYm+hgJuZV3t2cJaFkIB2lml+kV2NlIObenhpZpyDlKhdc3RlkoyXhWqHYWya
      Z4aRcYt1enBgkXp/qGdseFyHi5uUaYJdX559jZtxgG99h2yagXGjdnWHZ4GFlJ9w
      h2lRlYKRpnZ9aW+MdqGUaZZxcJB2ioOHnHGKgFKPh4irgoFpZIt4n6hrjHNhjH6V
      in2UZXmNW4iPeZyDg3NgiG+Kr3ODeVV+fpWXe5JhZZFmipZ0jHl+e2GNc3urdoKA
      W3l5kZt7lmZYj2uMpH6Lc3l/bJuAdKZ0f41mf3uMm4CedVaLboWthopxbntpnpJz
      oXNrjXCCf4KVcJGAU4pxdKOIi3RneVySm3Cbc12Bb4aGgpZpgoZWjHtwm4CIemmA
      X4agdZ59W35phZCGm2V0hleQi3SXfYV9bItigKRxmYtffmyGlYilbG+LWoucgJt/
      gH5ql3Z+qHCLkWmBdIORf6h5Z4tXfp6Dm355dV2VgHqqb3uMaYN6gpF2oIBikGF1
      noObgnl5V5CLeq94b4ZkgoCFkmqRflyRa26afpSFdn1Sho90roNqhWV+h4ygcIyD
      VZR/dJ6BjIJ4iFyFlWumjWyDYnmAh6h0gYBJhoV5n32AdWqLZX6XZ5mRbIhqeIKB
      q36Ai01/j3umioN6YYxwgKZsiIxmhnN6hXWge3SUVW6LdpyNgXtWgXN1rnl/i2J/
      e4KRdJl/Z5dnc5R5lo+Iil+CeW6uioKPYHV1g597lX9akHV0mniHgn2MZH9/YaCQ
      fpZnbnR6oYKVilGCeW+jh4eCcYxpgJFilpF0lXRxdnGbgY2XU3Z7Z5uNioJngWV4
      nGuPj2qLeHh+b5Z7g59fdX9ilpKSjWmAZXCme5GVZYN2e412mXt2nGd5imWMiouW
      boNlYp+AkJ9ndm50lH6egWWSaXSXcYiFgJJuiHZal4CFpXN4a2qPfp+UYohnZ5qA
      kod4imWFh2GWf3ifdoBzaYx0maBqiGxdlIOZknmHXH2Sbp6KcJJ1gIFzkXCMoGuN
      eVuIf5KZfopYao9rnppvhmx1g3qadXqZZIaIYYV9ipV/kmRhjWyVpniGamuBeKOF
      dJRheJJujH99jXWUdGCLaoWofotwZHpvoZR4lF1mjXWVjHuGZ4qAZpZvdZx7jH1q
      e2WSmnqfa1uDcJKXhotdeoFnn4VxlHOFhXaIZoaWdJ+AX4JriJmMnGZuf2Camn2W
      b3V/dpp1gZJnkYppiGx7j4KfcWx/Vo2eg5xxa3Nsm4GGl12CimyUfX+HeZt5dIxX
      gJp/n390cWSXh4umZnOCZpKKiopskHZzmml7lXiWhnt6XIuBga50cH5dh4yRlmqD
      bGKbdYGUbIZ+foZmin5zqXl4g1x9gpGfdIVrVpaAiqFwfnN5jXGSg2abfXaRaX5+
      hZ52i3VOiH2CqH1+ameIc5uXZ4xzbJR6h394lXONi1iIe32miItzZINwl6VxkG9h
      jX+UinuKZICQZY9+b5WAjH1qgGKGpHmRdlZ9dZSVgo9cb41rlZBviHSDg3OPZnqf
      dpWKZHtxjZuIn2ZkiGmWoYCLbHiAdp55dJZqiJFxgm6BjYGjdGSFX4ijh5RsbnNr
      oYh+l2B1i3aReoGDb5x7bo9geZmGmnlzb1uZjIOjZWd7b5KKjYZfjHtsnnF2i3qS
      gYB/WIqMfa17bnlni42XmWJ9dmKhiICNboN5gY9ihYNso4N1f2CAgZGja31vVZWR
      i5lveGx4mnSQiGCUhX2NcH95g6V1h4BQh4uMoX97YmeWepaaXYB4dZSBi3ZxlXOF
      lFt+gHuchopuXYd0japxfnNiioOZim6IZ3iedIaDboyAj4Fihml+qX6IfV99fZmb
      eZBhZJd6kpV0gHOGjXOVcWqce4uManhuipp+mW5ViHSNn36AYnaGcZ6FZY1we5J5
      hmx7kHSbhl2Cb3ufi5Fsan5nnJt2j2tqi4KWfnmGYZCRbo1wb4+Hl35wfViLnn2a
      dGJ6eZeNh41aeo9xnIZzgniRhYCNXHiWeJ+Ka3VmjI+PoGJqgmmXm4CGZ4B+faFv
      dYtqj5J6gmZ/g4GqdW9/W4abjZRuc3BspIGAj1x9iICPdX54bKGAeI1aeI2LnHt9
      a12XioihZm97dpeDj31fj355nnB0gniXgYp9U4aAf6h9b3RkioaXll+Ac2qfh4CC
      a4J6ipRhh3tsoYiBf2V+e5GlcIVxWJWMkpRxemmAn3iRglyQg4aRcYBqgqR6kH5T
      goKMn36AW2qUdpmSX3pzdpKAjGppkGyNkmF6dXqXiJBqXYhslaZ0gWtrioigg2yI
      YYGjeI96dIqCn4NvimWBqoKSeWV7eaSUfo9YbJeAnIxxemqUiH2ZX3CSe5WHb3Rl
      kY+Anl1hgnOZl4F5WH1/eKl0aoJmio+FgmB/gHWpe2aAYoiXkpBgdHNsq5J6i192
      iIycc4F2YpyMeZBpdoiLoHZ/dFialoiba2d1f6OHkYFRiIaBo311dXiXgIyGUoWH
      f6V+cGlqkYWVllNzdWqhj4Z2YoBzip9men5lmYuFemGDdI2obHZ0WpCWlY1memJ7
      qn+Mg1yBhoyRc4ZpeKZ5i4NbgIeWm3uDXWejg56ZYnZxh5mKmWtkknWPm2p9cYKU
      gpRpW4t2kKZzeGJuioOme19+X3mjgYdvaX9xnIFihWR4oYaIb2J7caWZb4dYZZaN
      nIZxdWCRmXqba2eQgZmIeXtikJ5+nGxbhn+gmod/UnqUgKuIYn9sjJKMkV17jXSg
      imV+bIiVjZVYaoBro6B4f2FuhYqmcXF+V42XfYpscX+AoXVsgFOKoIWPa2ZweqqM
      gIhNdZGCn4B4bmqXhYGVW3SSgJ+CeGximY+PoF1igHWgmYt5VoJ+g6t2cIFrj5CK
      gluFf4Cue255ZYqZmpRddG5qrZCBhV9zgY2ccH91XJ6Lfohhc3+QoHR6bFCWloya
      ZGZmfaOGkoBQgoWAoXl5bnibfZGDUoCKhamFdWRll4agnlpxc3Cjlo15Yod0kKVp
      f3tvmZKMel+Ddo+0c3twW4uWoJBpeV9zroGMhlt7gJGQcYJkbKh/hYJTdX2XnHmC
      VleWhZWeZG5nfpeCm25bjXaHnnB0b36ag5xxUYV4j7CFeGFmiIGrkV+BZHShjIt2
      boN1m5Vgg2xxo5SRdWJ4b56ueItmVo2NoI92eVuBn3qWelyIgpaKc3tYgaSCl3lO
      dHmZnoaHTWeNeKGUZ3ZsgZCDlF9skHGbkmlzaoKXkaBlXH9kmquDgWJsfoWrgnCK
      X4OegYtwdX+BpoNpgVh7qJCXcGVnaaSXg5FaYoyCnIh9dGGVin2WYmeNiJ6KeGxV
      kZaMqWpcdHSXm5KBVn5+eKt+cX1viIuMgVd7gXivhmpwX4GQoJthbmtdo5mDiGR0
      eIyfc4B7YpmVfohldHuQq3qAb06ImpGgdmpkcaCFlYxXfoaBmoF5b3Ofgo2LUHWF
      iKaNe2BcjIOapmRzcGyVkpJ4ZoVzhaNseXtvlpGUdlt9cIq1gntwV4CLo5Vvf1xs
      oYWIh2V7fpKQa4Nlb6SKi4JcbHaVpICMXFKLgZeedXBke5B/mnZfj3qNlnVzZYGZ
      iqB2Un1zj62Nglxqf3uplGuDanWZio9vdoZ0oJFnfWp1oJeacWV0Yp+og41mXYCH
      nop6f1iHlniRcWeCh5uFdHZRgKCGoHZaaXCXlpGMU2qGdaOQdHlsjIaKkF1zjH2k
      lG9vYIiQm6hlZnRklqWNhmV1dYCoeXuFZYqWhYJndnuCr4B0eFN/mpybdGxhZaOQ
      jJFacH+Fln6Bb2qbhoCMWG6CjKOFgF9Si4uVqG5na2+Wj5x9XYV0gqF5dnh1lIiU
      elJ/doqvh3hnYIGKqJtnfWJqn4+Qf256dZKVbIVwbKCPjXticW+ZqYCIZVKKjJ+a
      eHVafZaAmX5ghYCNkXh9YIGegpp4VXR6lKWPg1Vlh3qpl294Z3qPjJJqb4dumpFp
      eGd/lJSZZl91ZZuqgoVgZXiGqYV6f1p/mYCQdXF+f6OAdX5Yf6OQmnZiaWylmY+Q
      U2eFgp+QfXRkj4eCl2JxioKci3lrX42RkahmYnNum56Xflt4dH+rfnZ+ZYeIjIBf
      f3iBqn9uc1uBkp6WZHFgaaWVjIhhb3qLnHmIc2aZiIaKZ3R/kaR/g2dSkpGaoXFp
      YXicjZ6BVoB4g559fWt7lIGVflaAf4qqhntdZYiDqZpldWVsnpKVdml+apSXboFw
      b5aNjXNgemuXqXmBYlqCkKORc3hXeZ+BmX5lfX2SjHmCYnmhgpZ9W3R4m56KhlVg
      jIGlm290YYCMi5xrbIh1lJVzemmFkoufZmB7bpaoh35daX2Br4Z0f1t+lYqNcHR6
      dqOCb4FcgJuSlGxpamymm4WNVmaCiKOIgXFfjYuCmmxuhYCbgn9xWo2RjaBqX3Bx
      nJaVflB5eIGqg3V2aoeIkItdgH59qIN1cGeHkJ+ZYXNqZ6iXj4BhcXOQoXmFdWCW
      jIiGaXp1kaR6gG5Wj5WXmWxuXXqhiJl/Vnl9h5uAgGd0lXqUgVp7foqfg3tdYpCB
      pJlhcWZ4mpWWcWaAbpSfcYJwdpCLlXBmgG+Upnp/ZWSGjamHb3ZYe6GIlXtlenaZ
      jHmGYXmbhpF9ZHZ2n5uBiFVljYejknFuYIORh59qZ4J0lZB6eGWDkIWea11+cJqf
      iHtXcH+Fr4Zuel+DlZCRaXl5dqGFc4BlgZWQlGVvcG6ol4ODW2qDjaaCfnNYkI+I
      lm5wfYKcgX54WI2Ui5prZm55n5KPgFB1gYGog3huaYqDkI9feX94oYV4b2WMh5qX
      X29wb6OZjXpceXGRpnWAcWKNjYyFaX5xiKV1gHFgjJSakGtxYXapipSAV3Z7kJuA
      gmZqmYCQi2B7e4ybgYNiYpSHmZtlb2p9nI+bcF+AcYyjen5vc4+Dmnlkg3CMpX97
      aWeIiKiLZXpceqOPkXhneHOalXSIZXOXh5F6a3hxmZt6iF9ikIihjXRwXIWZh5xz
      YIB2lJF/f2CAkYCaeGB9dZWbg4FVb4d/qIxqdWR+lI2WZ3B/a5uQdX9pe42Ll2tq
      e2ecnICAX2t/iqaBc3lWg5eGlHBvdnqchnqDXX+Xhpl1bHFzoJKIi1dqioKkjXlx
      YIyKjJxqbIJ2l49+eWCIioihbGZ5cJabjIFbdnt/q4J2emKCj5CPaXp5c6WGeYBi
      gI2Ulmtzb2ejloaKXW99i6OBgXZcjI+Fl290eoCegoN7W4eRip91bG9xm4ySh1d0
      fn6kiHpzZYyBj5JgeH14nIp9c2GGgpGgZXNwapmVkH9heHGDpnmAeGGKiJCGantv
      fqV+f3lagYqWlXB4YmqgioyKXHN5h5p+iG5klIWIlWl1e4OegotvW4yGkKV2cW9x
      l4uchVyAdYCkg351bIuCloxfgHR7pIiAcGSBf5qbaX1nZpmNkYBpdmyKnHWHdGGQ
      h4+GbHlqhqF/inRXg4aWmXl9YHSZg5eKYH15hpmAiGlvlH6SkGR4eIKeiI9qYIh4
      lqN0eWxvkIqbfmWDa4Wfe4FzcIqFmoNkgGqApYWIcWV6e5yVc4NiapeDkoFseG6P
      kXaKamWUg5GHa3VlipuBlHBagn6Um35/YHiQfpyFZIF2hZmBhmdzkH2ejGR6cH+e
      j5FsZ4Fvm551gmxvi4iXe26DaYycdoVvboeIm4FsfmGBo4OSdmV4eJmQfYdib5R+
      lIVuenGRj32KZGmRgZePbnVlh5WHm29hgXSPmn+AZXqIfZ57aYNzh5mBgWVzh3uj
      h2l9ZnuZkJJwbnpqmpV4iGpzioeUeXN+aZKWdohna4aHnIF1dluDl4KZdmZ4dZSI
      goZfeo97l4Bre3SUjYWIW3CLfp+PcHVlhY2Mn2twgW+SlX+Ba3+FgpxwcYJukZmD
      gWZ0gIKognV+X4CSjZJ0dnRwm4Z7i2R9jIeSdnZ1bpuQgIxhboOFn4aBc12IioWe
      dG99dZSGh4Fhhod/mnZreXOUjYyGWnh/e6SLeXlngYWPmWt9e26ViX+AboCBiZdt
      d3tplZOHhGl1d4ShgIB/X4SKh453fHV6ln6AgmSAioWRd3lucpaGiIpicn+Al4aE
      dGiGfoSUcniAeI6EhHtpiICFmHZzenKNjI6EZ392fZuBgH5vgICKiXCBeHWUgH9/
      b4CBjZB0fnNskoiJh3F5dYWSf4h7bIiBhIt4f3iBkH2FfGmFhYeRfHtxeI2Bjohs
      fHt9kYSEeXSHeoiKcYB9fY6EhHdyhX2Mk3Z9dnWIiI2BdYBzgJN9hX92g4GKgXeC
      d4CTf4N9cYCAjYp8gW90jYGKhnV8d4OHfoh2dYh+g4Z2fXiDin+Id2+Df4aPf350
      eoWAj4J0gnh/i4CCe3yFfYuDc4F6f42Fg3l1gHqMjXuDdnaFg4mAfYB2g4l7hX15
      hYGHgHt/dIOMgId7cn9+iYeAgnJ7hX2Jg3mAfIODgIV2fYd+iIN3fXqDh4OJdnaA
      eoeJgIB5fYCAi358g3iChn6Aen6BgIt/eIB1gIqDhXt7fHuKhICGdnyEgIaAgIB6
      iIJ9hHh8hYKIgH18dYWEgYl6eH99hoOCgHaBgH2IfnyBfoSCgYB3gYKAi4B7fnqB
      hIaHeX9/eYmDgIJ7gH+BhXqAgHqHg36AeX+Ag4l9f351g4WChn1+e36Hf4KDeIGC
      gIR+gH5/iICBgXaAgoGHgIB7eYSAg4d6f399hIGCgHyDfoCFen+AfoWCgn55gH6B
      in+AfnqAgIWCfIF8fYZ/gIB8gYCDgXuBfH+IgICAen9/hIV/gnx6goCChH+AfoCC
      foN/e4OAgIJ9f32AhICEf3iAf4GGgIB8fYF+hIJ8gX9/g4CAfn+Cf4SCeoB+f4WC
      gn59gHyChX+CfnyAgIKAf4F7gYN9gX99goGDgH6Ae4CFgIOAfH9/goKAgnx/gn6D
      gX+Af4KAf4J8f4OAg4F+f32AgoGEfn2AfYKDgIF+gIB/hH9/gn6Bgn+AfoCAgIWA
      foB8gIOBgn9/fn2DgICCfn+BgIF/gIB+g4B/gX1/gYCDgIB+fIGAgIR+f4B/gYCB
      gH2BgH+Cf3+AgIKAgIB8gICAhIB/gH6AgIKCfoCAfoKAgIB/gICAgX2AgH6DgYCA
      fYB/gYN/gH98gICAgYCAfn+BfoCAfoGAgIB/gH+Ag4CBgHyAgICCgIB+foF/gYJ/
      gICAgYCBgICCf4CCfoCAgIKAgX9+gH+Ag4CAgH+AgIKAf4F+gIJ/gICAgICBgH6A
      foCDgICAfoB/gYGAgX9+gX+AgICAf4CAf4F/f4GAgIB/gH6AgYCCf36Af4CBgIB/
      gIB/goB/gYCAgICAf4CBgIKAf4B/gIGAgX+AgH6BgYCBgICAgICAgIB/gYB/gH+A
      gICBgICAfoCBgIGAf4B/gYCAgX+AgH+AgICAgIGAgIB+gIGAgYCAgH+AgICCf4CA
      f4CAgICAgICAgX+AgICBgICAf4CAgIKAgIB/gICAgICAgH+BgICBgICAgIB/gICA
      goCAgH+AgICBgICAf4CAgIGAgICAgICAgH+BgICAf4CAgICAgIB/gICAgYCAgICA
      gIGAgIGAgICAgICAgICAgH+AgICBgICAgICAgIGAgIB/gICAgICAgICAf4CAgIGA
      gICAgH+AgYCAgH+AgICAgIB/gIB/gICAgICAgICAgICBgICAf4CAgICAgICAgH+A
      gICAgICAgICAgICAgICAgICAgICAgICAf4CAgICAgICAgICAgYCAgICAgICAgICA
      gICAgICAgICAgICAgICBgICAgICAgICAgICAgICAgICAgICAgHt5gXsA
} Ως κουδούνι
Ήχος κουδούνι
}
MODULE SPRITES {Binary {
      iVBORw0KGgoAAAANSUhEUgAAAoQAAALuCAYAAAA32AdzAAAACXBIWXMAAAsTAAAL
      EwEAmpwYAAAKOWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanZZ3VFTXFofP
      vXd6oc0wAlKG3rvAANJ7k15FYZgZYCgDDjM0sSGiAhFFRJoiSFDEgNFQJFZEsRAU
      VLAHJAgoMRhFVCxvRtaLrqy89/Ly++Osb+2z97n77L3PWhcAkqcvl5cGSwGQyhPw
      gzyc6RGRUXTsAIABHmCAKQBMVka6X7B7CBDJy82FniFyAl8EAfB6WLwCcNPQM4BO
      B/+fpFnpfIHomAARm7M5GSwRF4g4JUuQLrbPipgalyxmGCVmvihBEcuJOWGRDT77
      LLKjmNmpPLaIxTmns1PZYu4V8bZMIUfEiK+ICzO5nCwR3xKxRoowlSviN+LYVA4z
      AwAUSWwXcFiJIjYRMYkfEuQi4uUA4EgJX3HcVyzgZAvEl3JJS8/hcxMSBXQdli7d
      1NqaQffkZKVwBALDACYrmcln013SUtOZvBwAFu/8WTLi2tJFRbY0tba0NDQzMv2q
      UP91829K3NtFehn4uWcQrf+L7a/80hoAYMyJarPziy2uCoDOLQDI3fti0zgAgKSo
      bx3Xv7oPTTwviQJBuo2xcVZWlhGXwzISF/QP/U+Hv6GvvmckPu6P8tBdOfFMYYqA
      Lq4bKy0lTcinZ6QzWRy64Z+H+B8H/nUeBkGceA6fwxNFhImmjMtLELWbx+YKuGk8
      Opf3n5r4D8P+pMW5FonS+BFQY4yA1HUqQH7tBygKESDR+8Vd/6NvvvgwIH554SqT
      i3P/7zf9Z8Gl4iWDm/A5ziUohM4S8jMX98TPEqABAUgCKpAHykAd6ABDYAasgC1w
      BG7AG/iDEBAJVgMWSASpgA+yQB7YBApBMdgJ9oBqUAcaQTNoBcdBJzgFzoNL4Bq4
      AW6D+2AUTIBnYBa8BgsQBGEhMkSB5CEVSBPSh8wgBmQPuUG+UBAUCcVCCRAPEkJ5
      0GaoGCqDqqF6qBn6HjoJnYeuQIPQXWgMmoZ+h97BCEyCqbASrAUbwwzYCfaBQ+BV
      cAK8Bs6FC+AdcCXcAB+FO+Dz8DX4NjwKP4PnEIAQERqiihgiDMQF8UeikHiEj6xH
      ipAKpAFpRbqRPuQmMorMIG9RGBQFRUcZomxRnqhQFAu1BrUeVYKqRh1GdaB6UTdR
      Y6hZ1Ec0Ga2I1kfboL3QEegEdBa6EF2BbkK3oy+ib6Mn0K8xGAwNo42xwnhiIjFJ
      mLWYEsw+TBvmHGYQM46Zw2Kx8lh9rB3WH8vECrCF2CrsUexZ7BB2AvsGR8Sp4Mxw
      7rgoHA+Xj6vAHcGdwQ3hJnELeCm8Jt4G749n43PwpfhGfDf+On4Cv0CQJmgT7Agh
      hCTCJkIloZVwkfCA8JJIJKoRrYmBRC5xI7GSeIx4mThGfEuSIemRXEjRJCFpB+kQ
      6RzpLuklmUzWIjuSo8gC8g5yM/kC+RH5jQRFwkjCS4ItsUGiRqJDYkjiuSReUlPS
      SXK1ZK5kheQJyeuSM1J4KS0pFymm1HqpGqmTUiNSc9IUaVNpf+lU6RLpI9JXpKdk
      sDJaMm4ybJkCmYMyF2TGKQhFneJCYVE2UxopFykTVAxVm+pFTaIWU7+jDlBnZWVk
      l8mGyWbL1sielh2lITQtmhcthVZKO04bpr1borTEaQlnyfYlrUuGlszLLZVzlOPI
      Fcm1yd2WeydPl3eTT5bfJd8p/1ABpaCnEKiQpbBf4aLCzFLqUtulrKVFS48vvacI
      K+opBimuVTyo2K84p6Ss5KGUrlSldEFpRpmm7KicpFyufEZ5WoWiYq/CVSlXOavy
      lC5Ld6Kn0CvpvfRZVUVVT1Whar3qgOqCmrZaqFq+WpvaQ3WCOkM9Xr1cvUd9VkNF
      w08jT6NF454mXpOhmai5V7NPc15LWytca6tWp9aUtpy2l3audov2Ax2yjoPOGp0G
      nVu6GF2GbrLuPt0berCehV6iXo3edX1Y31Kfq79Pf9AAbWBtwDNoMBgxJBk6GWYa
      thiOGdGMfI3yjTqNnhtrGEcZ7zLuM/5oYmGSYtJoct9UxtTbNN+02/R3Mz0zllmN
      2S1zsrm7+QbzLvMXy/SXcZbtX3bHgmLhZ7HVosfig6WVJd+y1XLaSsMq1qrWaoRB
      ZQQwShiXrdHWztYbrE9Zv7WxtBHYHLf5zdbQNtn2iO3Ucu3lnOWNy8ft1OyYdvV2
      o/Z0+1j7A/ajDqoOTIcGh8eO6o5sxybHSSddpySno07PnU2c+c7tzvMuNi7rXM65
      Iq4erkWuA24ybqFu1W6P3NXcE9xb3Gc9LDzWepzzRHv6eO7yHPFS8mJ5NXvNelt5
      r/Pu9SH5BPtU+zz21fPl+3b7wX7efrv9HqzQXMFb0ekP/L38d/s/DNAOWBPwYyAm
      MCCwJvBJkGlQXlBfMCU4JvhI8OsQ55DSkPuhOqHC0J4wybDosOaw+XDX8LLw0Qjj
      iHUR1yIVIrmRXVHYqLCopqi5lW4r96yciLaILoweXqW9KnvVldUKq1NWn46RjGHG
      nIhFx4bHHol9z/RnNjDn4rziauNmWS6svaxnbEd2OXuaY8cp40zG28WXxU8l2CXs
      TphOdEisSJzhunCruS+SPJPqkuaT/ZMPJX9KCU9pS8Wlxqae5Mnwknm9acpp2WmD
      6frphemja2zW7Fkzy/fhN2VAGasyugRU0c9Uv1BHuEU4lmmfWZP5Jiss60S2dDYv
      uz9HL2d7zmSue+63a1FrWWt78lTzNuWNrXNaV78eWh+3vmeD+oaCDRMbPTYe3kTY
      lLzpp3yT/LL8V5vDN3cXKBVsLBjf4rGlpVCikF84stV2a9021DbutoHt5turtn8s
      YhddLTYprih+X8IqufqN6TeV33zaEb9joNSydP9OzE7ezuFdDrsOl0mX5ZaN7/bb
      3VFOLy8qf7UnZs+VimUVdXsJe4V7Ryt9K7uqNKp2Vr2vTqy+XeNc01arWLu9dn4f
      e9/Qfsf9rXVKdcV17w5wD9yp96jvaNBqqDiIOZh58EljWGPft4xvm5sUmoqbPhzi
      HRo9HHS4t9mqufmI4pHSFrhF2DJ9NProje9cv+tqNWytb6O1FR8Dx4THnn4f+/3w
      cZ/jPScYJ1p/0Pyhtp3SXtQBdeR0zHYmdo52RXYNnvQ+2dNt293+o9GPh06pnqo5
      LXu69AzhTMGZT2dzz86dSz83cz7h/HhPTM/9CxEXbvUG9g5c9Ll4+ZL7pQt9Tn1n
      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
      IAAQYAAEQHD6aI2LdwAAAABJRU5ErkJggg==
} as Walrus
\\$ c:\users\person\appdata\roaming\m2000\hand.png
Binary {
      iVBORw0KGgoAAAANSUhEUgAAAyAAAAMgCAQAAABxec7jAAAAAmJLR0QA/4ePzL8A
      AEgGSURBVHja7d13nBRFwv/x7y4rrLjCgisCrhwiIpJERFQMhygopwImFHOOp2eW
      MyfMnunUM+fzDIg554CKioAkSQZydMmwwPbzh8iDuNvV02Gmq+bz3tfv+Z1btT3d
      NTXzpbu6qyQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASFYBTQDErFjN1VhFkuqqtpZr
      tmZqtpbTMHANAQJEV6R26qht1UrN1Exl1dZZqMkapxEapqGqoMngAgIECK+p9tBO
      6qJOKs7o7yZqqF7Wa1pKEwJAvmmnS/SVvEg/S/SM+qqIxgSA/NBCN2lSxOhY92eC
      jiNEAMBtRTpI72p1jOHx+88kQgQAXFWqqzUjgehY90zkKBXS0ADgklJdrQWJhsfv
      P5+rDc0NAG6opyv0a1bC47efFfo7jQ4AtivRJZqXxfD4/eeZDG8KBgCkyjGak4Pw
      +O3nU5XyBgCAjdrp05yFx28/XxMhAGCbEt2ilTmOj98ipB5vBgDYYw/9nILw+O3n
      KyIEAOxQqKsTeUww/M/7PBkCAOnXLOfjHtX93Mkbg/RiNl5AknrrUTWMupFCba2t
      1UxbqLE2WvO7Ik3XHM3SGA3T4jAb7aNXeHsAIK0GRDtPKPZ6eQO997wKz88qb6R3
      k9cp063Pq2F9EQBAjhXp4fDRsYl3jDfIW+RlYrx3rdc8k1d5lDcJANKnVO+Hi47a
      3mHeu94qL5wV3v3eZsFfrRNvFACkS3ONDhMeW3k3ebO8qOZ7xwZ9xdd5qwAgTVpo
      Subhsav3plflxeUpryTY6+7M2wUAaREiPnby3vbi9p3XNMhrv80bBgDpkHF8lHmP
      xnjmsa4J3qacgwCAJZpnNmFJoXeKN89LzidebfNePMnbBgC5lmF8bOd96SXtxiBL
      TTXkrQOAXGqmH4OHR4F3gVfpJW+11828Nyfx5gFA7pRpQvD42Mx7y8uWsebLWAyk
      A0DO1NaHweOjhzfDy6a/m/ZoGUvdAkCuPB780tV13movu37wCkz71Z23EAByIfCU
      icXe814uGMdBLuNNBIDs6xs0Php5Q7zcuM+0b4N4GwEg29poSbD4aONN9nJlplfo
      v3eTeCMBILtqa0TQma7me7m0nWkPS3gzkR6suIx8cJM6BKnWVW+oQU531DhK3oY3
      E+lBgMB9PXVOkGq76A3Vy/Gu7mSq0JK3E+lBgMB1jfR4kGrt9abq53xntzZVaMYb
      ivQgQOC6h9XYXKmx3khBfATIh815Q5EeBAjcdrj2N1eqq5dUnordLTNVYEJFpAgB
      ApeV6DZzpQI9ah57yBrDeVCuB2mAdRAgcNnVamqudL36pWiX60UqBrKJAIG72uls
      c6V+ujhVO13AJxbWoDvCXfeoyFSluR4wfWUDqAEBAlcdpT1MVWrpqVTce7WuSv/i
      xbyxSA8CBG6qrYHmSpdp19Tt+EL/4qW8tUgPAgRuOsn8SEVXXZ663V5pSoiFvLVI
      DwIELirWpaYq9fS0aqVux+ebKhAgSBECBC46wXz77o1qnsIdn2uqUMGbi/QgQOCe
      2ubzj846JZW7PttUYRZvL9KDAIF7TjKdfxTqnhRevpKkeaYKs1O528hTBAhcE+D8
      42R1SenOzzFVmJ/SHUdeIkDgGuP5R1mQO3xzxBggc1O768hDBAjcEuD84wZtktrd
      5xIWbEKAwC19TecfrXVCinffeILBJSykCAECt5xqqnB5qju94RLWQtNMJ0A2ESBw
      SSt196+wjQ5P9QEYLmFxAQupQoDAJcbzjytS3uUNCcEFLKQKAQJ3FOs4/wotU37+
      YRwD4QwEqUKAwB2HmFYMPy3lHX6JlvtX4CZepAoBAncYLmDV0bEpPwDjPCVcwkKq
      ECBwRXPt5l/hEJWl/BCM+cBMWEgVAgSuOMRU4bTUH4LxMUIuYSFVCBC44jD/4ram
      E5QUMJ5gECBIFQIEbmihzv4VTrXgIJjIBHYhQOCG/f2Li3W0BQcxN3IFIJsIELhh
      P//iXiq14CCMJxjchYVUIUDgghJ186/Qz4rDMFzCWkWAIF0IELigm2r7FdfVAVYc
      hiFAiA+kDAECF+zlX7yPNrLiMAyXsBgBQcoQIHCBYQ7ePpYcBnPxwi4ECOxXpnb+
      nbyXFYdRZQoQzkCQMgQI7Lebfz/eUY2sOIx5qvKvQIAgZQgQ2G8X/+IelhwGE5nA
      NgQI7Gd4Br27JYdhvMlqDm810oUAgf19uItfcbHpBCU1KkwVuI0XqfvwAXZroxK/
      4l1UbMmB/GqqQIAgZQgQ2M5wAWt3aw6kInIFILsIENhue//ina05EOMZSAVvNtKF
      AIHt2vkX72jNgVRErgBkFwEC23XwK2yW+mVs/19F5ApAdhEgsFtj/4Rob9GhVPgX
      V2opbzfShQCB3QwXsBwKkArebKQNAQK7tfQvJkCA5BAgsNtW/sWtLDqUikjFQPYR
      ILCb4QxkK4sOpSJSMZB9BAjs1sKvsIEaWHQoFZGKgewjQGC3cr/ClhYdyBKt9q9Q
      wZuNtCFAYLPaauhX3MyiQ1lsqlDB2420IUBgs/JIxaliDJBFvN1IGwIENmvsX9zE
      okNZHLkCkG0ECGzmUIAYTzAIEKQOAQKblfoXb27RoSw0VSBAkDoECGxWGqk4VYz5
      sNCig0GeIEBgswaRilOFAIF9CBDYrKF/calFh8IgOuxDgMBm9fyLSy06FAIE9iFA
      4Gz/LbGqe3MXFhz7AAIpV+pXWMuqQ+EuLNiHAIGzSqzaWy5hwT4ECGzmOwZi1xlI
      pX8xy9kihQgQ0LlTwTAGUsn7CT5jQNZUWbW3hoTgKRCkEAECpMIy/2LOQJBCBAiQ
      Ckv8i5fTQkgfAgRIhZX+xQyiI4UIENjM98LOSqsOZWGEIwVygwCBzZaGLkwdBtFh
      HwIENvP9Wl1g1aEwiA77ECCwmeHp7GUWHcrSSMVALhAgsJlD37qGERvuwkIKESCw
      meFrdYk1B2K83MYlLKQQAQKbGb53HRp5ZhAdKUSAwGaGMRB7LmEZz5XsmpcFeYIA
      gc0MCWHPIPoq3ktYiACBzQwB4tASGnbdk4w8QYDAZgsjFacIq0XBRgQIbDbfv3iO
      NQeymvcSFiJAYLP5kYptUsGbjfQhQGCzuf7F86w5kEW8l7AQAQKbzfe/vXW2NQfC
      XbqwEQECu80PXWgXHiREChEgsJvvRSx7LmGRD7ARAQK7+QaIPXdheaYKXONCChEg
      sJsjZyBGnKIghQgQ2M13mGOZNbNh2TNvMPD/CBDYzXAjry0XsZgLCzYiQGC3Wf7F
      9oyCAPYhQGC3mf7F02khIDEECOxmSIgZtBCQGAIEdpseqdgeDJIghQgQ2M2QEFNd
      OU57FldEHiFAYLfF/ktpcAkLSA4BAttND12YIjxoDhsRILCd71UqWwKE6dxhIwIE
      tvPNiDmqpIWAhBAgsF2+3IcFpA4BAttN8y8mQICkECCwHY8SAjlCgMB2+fIkCJA6
      BAhsxxkIkCMECGzHIDqQIwQIbFfpvyYIAQIkpYgmgPWmq6zmwmluHGOxpEZqrHI1
      Urnqq1SlKlU9FUmqp0JJFZKkClVooSo0T1M1XVM1lcVwkRwCBPabrg5+hTYwXgp4
      V5WqHWrTczVeE/WDxmmMJjKrL+JEgMB+vhmxUEu0UeoPYWNzldohN12mMnVd87+X
      a5SG6zsN0Uim30J0BAjsZzjJmKZWtNFvitVZnSVJCzVEn+odDSNIEB6D6LDftEjF
      +ame9tVAfa1ZelqHqx4NgjAIENiPJ0HCK9MRekZz9LKOIUaQKQIE9uNJkKhqq7ce
      1yw9rj1oDARHgMB+htlKbAiQijTsRLGO0ceaoHM4F0EwBAjsN9t/INiGMZAx6dmV
      lrpd03SnmtOxYEKAwH5VmulXbEOAbJCu3SnR2ZqgR9WSzgU/BAhcYP266CXp26Ui
      HaexepIQQc0IELjA+nXRy9O5W0U6SmP1cFp3D7lGgMAFvhmxQrNTfwB/Se+uFekE
      TdBABtbxZwQIXDDFvzj95yApvIS1rmJdokk6jo6GPyJA4AKeBElemR7Vp2pHQ+D/
      MRcWXGB9gGR+F9ZGKlUdlWgDScVaLklaqBVaoAXJ7eZu+k7X6nrm9MVvCBC4YGqk
      4hSoayhvqrZqqa3UWFtoM5Wpvs9H11OF5mqGpmimpmiCJmiyVsf3jXG1DtTRGkWn
      AwECNxjn47Xds9otcN0CNVADbb3ObxZrpIZrqD7V5Dh2pqO+1vm6l24HxkDggoVa
      7Fec/ktYtRLdeom66gw9pkmarmd1UvS7cot1j57nviwQIHCDb0ak/wzEdBfWophe
      p4n66UFN0UjdrK4qiLKpQ/S1WtPx8hsBAjdY/yihv7hXfWqvC/W5ftEd2iX8Rlrp
      K+1L18tnBAjc4JsRc7TC8g/iykRetVz/0BCN1QVqFG4D9fS6/k7ny18ECNxguNEq
      7RexTGuiL03wtVvrFk3VM9o5zB8X6m5dS/fLVwQI3GBIiLRfxNoox6+/gQ7XF/pS
      h4b5SrhM9/NNkp942+EGyx8lLFKxb/nirOzFTnpOo3Rw5oPrp+hBvkvyEW863GD5
      JSzTfVirs7Yf2+oFDcn8ctYJREg+4i2HGwynGOl/Ft1/FCS7c4fsrCF6TGWZ/dEJ
      epBumG8IELhhpv+drrbPx7sky3tToGP1g07O7GLWCXqYjphfCBC4YZX/oh/pv4RV
      37d0SQ72qKEe0NvaIpM/OUG30BXzCQECV1j+KKH/JaxFOdqrHvpeR2fyBxdoAF0x
      fxAgcIXlk5ls6lu6OGf7VV9P6PFMFry6QYfTGfMFAQJX+J6BLNfclO/+Jr6li3K6
      b8foa7UNXv1hdaI75gcCBK6w/FHChr6li3K8d631pfoErVxXL4edGwV2IUDgCssf
      JfT/xs11gEglelH/DHpXVrme4bslH/AmwxWWP0rofwlrQQr2sFDX68GgK5d0ZzA9
      HxAgcMVs/+KZKd99/0tYi1OylyfqBcOkK2tdq650StcRIHCFISHmpHz3m/iW5v4S
      1u/66g3jCu6SpEI9Gawi7EWAwBVz/Z9FT/sZyOa+pekJEGlPvaTaQSq20A10S7cR
      IHBFlf+dumk/A9nYd4nxFapM0b720CPBhtP/Hm6REdiCAIE7ZoYuTIWmvqVpGQX5
      zZG6Pki1Qt3Nd4zLeHPhDt9h9LSfgdh0EUuSBuiYINU66yQ6prsIELjDN0DmZnlK
      9MyV+5YuTN3+PqCdglQb6HttDlYjQOAO3wDxUj+Zif8ZyK+p2986GhRkzZAynU/X
      dBUBAnfM8C9O+yhIS9/SNMbf5nosyGD6eUxs4ioCBO4wPEqY9lGQlhbu/X46x1yp
      RBfTOd1EgMAdlj+LvlWUg8uZG4LM03uGGtM9XUSAwB2Wn4E09V11Y15K97qOHjHP
      j1Wsf9I9XUSAwB0zIxWnQAufslmp3esuOs9c6QTDZF+wEgECdxjOQNJ+F5bUytK9
      v8JwB5mkEp1BB3UPAQJ3VGqpX3H6boRdXxufsjQHSIluNlf6R7AJtGATAgQuqfAr
      TH+AtPcpS+8lLEnqr11NVco0QEV0UbcU0ARwyPdqV3NhW41K+e7/oNY1ltXWilTv
      +2fa3VxplX7RZI3XaI3XeP1Ch7UdAQKXfKw9ai5smvpVCVdrYy2rsfRXlaZ67/fU
      R5n9wUIN0zB9rWEaT9e1E6eUcMl8v8L0X8KqpfYaWmPpnJQHyEWZBkg9dVM3SVKF
      PtP7ei/1p4hYD2MgcIlvgCzT8tQfgN8oSNrvItvX5wKcQan21+36XjP0tI4LMsEW
      0oEAgUsq/IvTfw6yvU9ZuofRpQKdEnUTjXWEHtUMvamjfJ+qREoQIHCJ4XHt9AfI
      zuEPLgWOMT+THkSR9tWTmqPntT/fUOnG2wOXzI9UnALbqW6NZdNTv/ebxDnlVbEO
      0auapAtSPvST1wgQuMT6ACnyWaTJhrteD497g811i6boJiaETycCBC6p8C9O/yUs
      aZcaS2wIkEuTeDKgRBfpR93G4Hr6ECBwifVnIH6jIDYESANtncyG6+o8/aiBDK2n
      CwECl1T4F9txBlLTh9KOB7cvTW7TJbpEP+oMnl5LDwIELjGcYlRYcAhlNd7Ku9SC
      +YSlI3xuA4ilee7Rt+pCV08HAgQuWepfnP4HCSWpR40lNpyDFOmYpF+ig77QPVzM
      SgMCBC4xJMQSKw7C7gCRjkz+JQp1hkb4PjSDrCBA4JaFfoWLrDiEXWu8CDTFkv3/
      SzZepoU+1dV8g+UWzQ+3+F7EsuMSVh39tYYSO85ACtQ/Oy9UpCv0Oo8Z5hIBArf4
      ZsQySw5inxp+b8sCGkf4lg7WQzpbu2qjOF5qX33rtwYMkkWAwC2L/QoXWnIQfWt4
      HM+WAGnvO6twXZ2oO/WZFmiUHtVRahLtxVroc3Wn4+cGAQK3OHAJS/qLOlf7e3uW
      8DvMp2z0mv+/ltrqOD2p6RqlO7V3+IkY6+nN+OdQQRAECNziGyC2XMKSDq72tzNV
      acn+9/eZ0mT0n37TVmfrXU3RHT4zgfmqrWd0Bp0/+wgQuMU3QGy5hCUdVO1vqzTV
      kv1v4XOP7Zgaft9E/9CXmqRrVB7mJe/R3+n+2UaAwC2+YyD2nIFsre2q/b09i4fX
      PJDuv25tC12uH/W8dsv8Je/mLCTbCBC4xXeYo1JV1hzIodX+dqI1+3+YatdQssg4
      llOkQ/SpPsr8ScF7dBofgWwiQOAWw2QmdjxKKElHV/vh/MGa/d9UvWosGx1oC3/V
      EA3K9KHE+3QSH4LsIUDgFsMwhx2TmUhSM+1dzW/tuYQlHV9jyeiAWyjQQRql8zOb
      fvd+9eZjkC0ECNxiuFN3lUWHUt0XsD1nINLfalxGcHQGWynRrfpabYP/QaGeYbbe
      bCFA4BZ7xsmN+qrBn343xZpnWaQNapzSZEyGW+qob3RO8LUO6+p1teSjkA0ECPKK
      PYPoUnE1dzJVaYJFR1DTRawx8jJui9v1uhoGrV6mwckuS4LfECDIK/YMokuqdjz4
      e4v2f7saFsdarJ9DbK2Xvq7h5uZqtNPD9PbkESBAanVUtz/9boxVR3BsDb8fHWpr
      LTSkhmf0q3G4zqYHJY0AAVLsnD/9xqYzEOlIFVf7+1Eht1dXz+msoJVvUUd6ULII
      ECDFDvjTaLBdAVKmQ6r9/ejQWyzUXbox2IB6bT1dQ34hJgQIkOoP6PrXYX6ybByn
      +kfDo12Iu1i3B4uQNrqBPpRs/wRcstS1Azp+vSX3vNCXf3Jj12rXBhkb8X64f+j6
      YBXP1h58KJJDgMAttsx3HljJn675j7DsCKo7B1mqHyNudYCODFKtUPfXOCkXIiNA
      gJQ7d71zkG8s2/+jVFLNb0dH3u4jwRYibK0L6ENJIUCQV+waP/hNA537h//+2rL9
      r1ftuUL025Fr60VtHaTipWpOz08GAYK8YtOT6P/vnD88gz3GuoGe6i5ixXE3WX0N
      CvLAeV3dSc9PBgECpF49nb/Of62ybhSkYzUj2fE8ENleDwap1jvM+lQwI0AAC5yt
      Tdf5L9suYknn/ek347Q6li0foVOCVLuFPpQEAgR5pZal+12iy9f5L/sC5AC1We83
      y2NbXfE2bWWutLP60vvjR4DALYa1h0qsPbDT1W7t//7Uur0vrGZSlrhm9SrRE0H+
      YXBDZutSIdj7CrjE3oQwKFpnJPhn46ri6XOsmqz3m9GxbburLjJXal3N7PiIiABB
      XtnI4n3vvs5VmE+s2/vaOnO938T5RP0VQW7ovZJzkLgRIHDLxv7Fdn+D/Gvt3ID2
      BYh05nqnh3FOC1msu82VWuhwPiDxIkCQVz3a1kH032y59qFqGwOkVCf/4b/Hx7r+
      8D7qZ670Tz4gWf24AZZxdhD9N5euuVTzg2ZauPcD/nCCuCrGURBJ+pf53W2j3nxE
      4kSAwC2G7xDb59Ur1iNrPrRvW7j3jdablGV4rFvf/A+PW9aAc5BYESBwi2+AFGhD
      6w9wN50uSXrdyr0/X2Xr/NeI2LfeyFRl52pWCUZoBAjc4hsg9Zw4xBv1F0nvaKWF
      +17vD6cAw2Pe+sa6zFzpTD4k8SFA4BbfufVsvon3/5XoARVogb60cu/P0BZr//cI
      eTFv/SQ1NlXpa66CoAgQuCUPAkTqqRMlvWHlvhfryrX/e5Emx7z1Dat54n09RTqJ
      j0lcCBC4xfcqVV1nDvMOtdZgS/f92HXmxfou9q2ftt7yW9U4lQcK40KAwC2+YyAb
      O3OYG+l/+knfWrnvRfr32v/9Rexbr28+wSjX3/igxIMAgVvyJECk7XSrnrF03/dc
      Oy3VFwls/Qzz19rRfFDiQYDALQ39CsucOtQztczSFRalW1VfkvStlse+7S21r6nK
      /o7ckJdzBAhcUuJ/dbuBUwdboGv0o6X73kT/kiRValgCWz/dVKFYh/BhiQMBApcY
      TjHcChBpkyBLKaXUCeolSYncjPw3/cVU5Ug+LHEgQOCShpGKkVUPqYGSGQUpXG/a
      xmp0UznvQBwtDbij1L/YtTMQuzXVYyrQx4mM4/RXgX+FQpa4jQMBApcYTjE2oYVS
      pbfO1xx9k8CWW6irqUof2j86AgQuKYtUjKy7XnsmNK+wcZCjG3diRUeAwCVN/IuZ
      BCltNtCzidyHJR1qmrq/yHy3L0wIELikqX8xAZI+m+oWTUtgu2Xax1SFi1iRESBw
      iW9CbGL9clJuaqnNE9nugaYK+/P9FxUNCJc0Dl0I5+xn+nqrpy60UjQECFxCgGCt
      RtrFVKU7rRQNAQKX+GZEE9onz/Q2VdiLNoqGAIE7GvnPhNWUFsozxgDpqmJaKQoW
      VsnX972RytVYzVRXRaovqbYqtUCLtVgLNVM/abqFE702j1QM57TWVprkV6FYXfUB
      7RQeAZJP73UbddT2aqNWamY891ylqfpFEzVWYzRc0604wuaRiuGgvf0DRNqLAImC
      AHFfqbprH3VWu4zuYi1SczXXHmv+a66Ga5i+0yepjpLmkYrhoO6637/CHrRRFAU0
      gcPaqa/2U5dYR7rG6yN9qI80M4XHe59O8yteqg3pE3lmrhrJ86uwXPVVSTuFRYC4
      qZGO0LHqmOArDNNgvaRRqTrqN/0mp2isGfSLPNRRI/wr7KShtFJY3IXlnj00WNN0
      e6LxIXXStfpek3Sbdk7NkTcPXQhnGe/U5WHCCAgQt+yvz/Wx+mZtbKuFztMXGqsB
      apaCvtzcr3hLekde2s1UYSfaKMqHDq68k/00Qq+al0FIQGvdoB/1ro7I6WRTzfzv
      6d+GPpKXdo5cATUjQNxwkEboWXXIaU/aW09rmgbmbKnQ1v7FBEh+amLqkC1ZJibK
      xx6266APNUjtUrEvZbpEP2qQuuXgtQ0Bsi09JU8ZTzEYBQmNALFbqe7Rtzn5uq5Z
      kQ7Sh/pafbPcu7bx7+it6C15yjilYod8aIVkECA2O0YTdEZKHwbtrMEarWOyuHe+
      XwPNeAYkbxnPQNrTRmERILZqqOf1eMqv3rbW45qkM7IytF7oHyBcwMpf25m+5jgD
      ifCxg416arQOsWJPm+keTdBJiZ+JtFCJXzFD6PlrI7Xwr9CaKZ3CIkDsU6Q79bZV
      qyM104Maq8MT7W0d/Ytb02/yWHvTJ6oNbRQOAWKbMr2rsy3c75Z6Rt9p/8S2v4N/
      Md8Q+cw4yMFFrJCYC8su7fSy6XzcpEit1UFbqbHKtZnKVKAibSxplRapQou1WDP1
      s37Sz/ohiRkTv9S5+jKBlvGdB0v6VaX0nrz1gg41VeGbMBSazSa99bT/lX4/Reqq
      HtpLHTO4H2mmhus7faZPtSjO4/ifLtYvMbfNLDWquXBLTab35LEfzJcw+SYMhWaz
      xym6L9wlx/o6VPtpT9UP/dKr9K0+0gf6VMviOZbl+pdu0OLY2qZcU/yKD9Ig+k8e
      W60NtdKvwhDtSiuFwRiILc7R/Zm/W4XaW09phh5U3wjxIRVpJ12stzVXg3SMGkY/
      mmJdogk6LrbWMcyY15H+k9dqmR4jzf1UoJYiQOxwmW7P9E/qaYB+1Ls6MsZH6Orq
      ID2uWXpfZ0aPkcZ6VJ/HNAWL4WHjjvSgPLeFqS9yI28oBIgNbtK1mf1Bma7Tz7oh
      oX9YFam7/q3pGqw+2iDaprrqO90WflxnLcMZyPb0oTzXzNSlbbotPkUIkPS7XRdl
      Ur1IZ2isLk38rqM66quXNF13RXvGokjnaawOirQrdf1vw9w0ZxMEIy22MFXgIlYo
      BEja3a5zMqneTUN1TxZnOCnTWRqjd9VXtcJvpFyDNDjCvwE7+1+AYMUgGPOBf2OE
      QoCk27WZxMdG+o8+yMHlmgLtrcGaqIvUIPxG+mps6EF1wwWsXYR8ZzwD4RJWKARI
      mp2my4JX3knf6dQc3pfdXDfpZ92sJmE3UKpH9Xaopcv/6l/cVch3xgApyYdWiB8B
      kl4H6Z6gVYt0lT7T1jnf5Y11oX7UfeEflu+p73Vahn9TW3v4tw3rBcGYDxvTRmEQ
      IGnVXc8EfXca6SNdmZr7EOvoNP2gB8OOSpboPr2tphn8xW7+a6Fvp7r0prxnDJBS
      2igMAiSd2mlw0FU0Ourr1D1GW6STNF53+M0u4qenvle/wLV7+BfziDECBAj/ygiF
      AEmjUg1WvWBVD9ZnKb0DsY7+oUm6NNxjjA31rJ4O+K/Cvf2LGUKHJNNMDIyBhEKA
      pPE9eUYtg1W9Us9roxQfSomu0zj1Dze0f4S+D7Dae0N18isu0J70KMiYEARIKARI
      +lzrPzH57wr0b11lwWyYzfRfDTGvS12dcr2vaw2DO939+3B7bUaPggiQZBAgaXOQ
      LglSrZYe1pnWHNTOGqLHtWmY/nmZPva9RneA/wb2pkdBkkxDivXyoxXiRoCkS2s9
      HqRaLT2l4606sAIdox90apgO11UjapzqpNC0xiEBgkBW0QRhECBpUjvoglF363AL
      D6+B/qMvwjwpX6pBur/am3X38J8UuI7/IyLA7xbTBGEQIGlytf+A8O+u0+nWHmIX
      DdWdYS44n6LPq3lKvY//H+2c6lsMANsRIOmxR7BZd0/XpVYfZpHO1vfqmfkfdtJ3
      6rve73r7/0kPehXWWEgTJIAASYt6ejLIu9FHdztwsM31lh7J/OHfUg3WLevcldXO
      NGdKb/oV1vBoggQQIGlxT5DnAdvrv1GmTU+RAh2v0X86oQjgAn24dqITwyoiLdSe
      fgUkiABJh946ylypgQY7NeNCUw3WU5lPAb+bvl0zwW5//4p96FcIqoomCIMASYOS
      IPPu1tIz2sq5Qz9SIzK/1baxPtRx6mRaCpELWPh/htusGCIJhQBJg4FB1kMbqH2c
      PPgt9I7uzHTGrNp6VN/6V9lEu9OzsNbCSMWoHgGSe530d3OlQzNbGN0qBTpb36pz
      zFvd35HRIsRhqelJwQraKAwCJPfvwIPmd6GZHrBg1qsottUQXRxrdzyQvoW1Fpgq
      cAYSCgGSa2ebHx4s1GN5sN7NBrpRb8W2NHVD9aJvYS1jPizIh1aIHwGSW+W61lzp
      /LyZkryHRgSbitjokKDrcSEvLIxcAdUhQHLrdvOsHh11XR41SCO9oVu1QeTtHEHf
      wjoIkGQQILnUVYeYqmyop/Ps39IFOl9DIq6y+BcmUcQfGK9QVdBGYRAguXSbucq1
      apOHDdNZw7RfhL/v7/gtB8jUDFOFmbRRGARI7hxiXqZve52Tp42ziV7VwNA34nIB
      C380M3IFVIcAyZXauslUpZYeyONnGQp0id4NdVfW9syBhfVwBpIMAiRXzjDNJCud
      GfvDdbbZU8O0S8Z/dQq9C+sx5MNsViQMh0vFudFQk0yPdpRrjDampbRCp+vRDOqX
      aEaYBavgtM7+M9+M4qQ1HM5AcuPv5icD7yA+JEl19IjuXGcREJOjiA/8yTT/Yi5g
      hUSA5EKxzjJV2V0H005rna23tEnAuqfSXFjPCs32rzCVNgqHAMmFE1TmX6EgyB2+
      eWUvDQ10lWEndaSxsJ6fTMt9cAYSEgGSizY/11TlcO1IO62nhYYEmCCxKw2FP/nR
      VGFGPrRCEgiQ7PubWvpXKNYNtFI1SjRIVxnu+xhAM+FPjAHyE20UDgGSff1NFc7S
      X2ilahXoSg3yGST/rxrRSPgTAiQpBEi2FWl//wplupRW8nGgvqjhEZpLzdmMvGQM
      kMm0UTgESLbtoXr+FS5SfVrJVzt9rTPWu7F3I92YV7MWIxOGfJhvWjAdNSFAss0w
      R2Apz1EH0FD3aISOVRvV1sbaURdqki6mWVADQ4BMpIXCKqIJsqydf/FJnH8E1EaP
      SVpFF4bBLNNc7T/RRmFxBpJthtnZT6SFMkJ8wGSsqQIjIKERINlVonK/4m3UmjYC
      YmUMkB/zoRWSQYBkVyv/4v1pISBm40wVxtBGYREg2WU4wehJCwExGxe5AmpCgGRX
      uX9xS1oIiJnhEtZ8zaWNwiJAUtXeDAkD8VqsKf4VuIAVAQECwGHGfOACVgQESKqs
      pgmAWI0wVRibD62QFAIku6b7F3M/IRCvkaYKnIFEQIBk13j/4tdpISBWxjOQUbRR
      eAU0QVaV6le/4i15KBaI+SO3wK+4Qg1oo/A4A8muCv/FM3/UMNoIiM1P/vER4AoX
      /BAg2Wa44vovWgiIzcjIFeCHAMm24f7F/9WntBEQk+8iV4AfAiTbXvYv9nSSltNK
      QCy+NVXgDCQSBtGzrVCzVOZf5WzdSTsBMWikOX7FVdqIf69FwRlItlXpRVOVu/Qo
      7QRE9pN/fEjjiY9oCJDsu01Vpiqn6QvaCYjoK1OFobRRNARI9o3Xc6YqlerD801A
      RMZ8+CofWiFJBEguDDSfg8zRX/UxLQVEwBlI0giQXBilF8yV5msfPUVbASGtMt2j
      u5x7sKLiLqzcaK3vgyz+UaABuoZVQhCjmRqlcSpWG3VQidNH+q06+1cYqp3oD9Fw
      BpIb43RrkGqeblB3TaO9EIufdKK2UA+dpZO1q7bQNVro8NF+Y6rwJT0iKgIkV642
      zcz7u0/VUa/RXojsI7XVI1q19r8rdKV20FRnj9eYDwyhR0aA5MpyHa/KYFXn6gAd
      5z+NL2DwmfbT0j/9dqL29J/f0+ojNmAIPTICJHeG6NzglR9XG/MTiEANqnRGNfEh
      SRN1tZNHPFUT/SvMN1WAGQGSS/fqgeCVZ+pgHUCfRyjP6fsayx7Rzw4esfEmeM4/
      YkCA5NZZeiOT6q+prS7QItoNGfIbRat0cgZoY4Aw7XUMCJDcqtSBeiuzP7hN2+ju
      oMMngCTpad/SuQ4e8YemCh/RK6IjQHKtUgfqncz+ZIbOVivdrxW0HgJZZiif59wR
      G0dAlnIJKw4ESO4tV59MI0T6WadpS93i9H38iMtkQ3mFc0f8ianCZ+vcz4zQCJA0
      WK4+mY2F/GaGLlIznaUxtCB8TTKUb+HcEX9kqsBEc7EgQNJhuQ7QvWH+cIH+rbba
      U89qJa2IGpju3dvKuSNmBCQ7CJC0qNKZOtc8S29Nn4bD1UyXaQrtiGqYzkBaOna8
      vzACkiUESJrcoV6aHfaPZ2qgtlRfvcLgOtZjGgNx7QzkdVOFIYyAxIMASZd3tF2U
      k+vVell91EQn6QOtpjWxxgTf0s2cm5XXGCAfOnbAOcN07ulTqIt0tWpH3UwT9VN/
      5quGVmlD339w72qeNcoqK9TAdOPyrhpCv4gDZyDpU6UbtX30qaZn6E7trK10mb6V
      R6vmsV8M12taOHa8H5viYzEjIHEhQNJpjHbVuVocfUOTNVCdVa5T9VoNk+nBdRMM
      5Vs7drzGC1jvMQISFwIkrap0h7bWY/FsbLoe0AHaVL31gKbTtnnGdA+Wa2cgr0eu
      gKAIkDSbqeO1S3zrpi3VqzpV5eqsAXqX85G8kV/3YI0zBmbm8z6gJgRI2n2pXdRH
      o+LboKdvdZN6qqH21HXcz5gH8usSlnFKh1H6hT4RFwLEBq9oOx1t/IdkhlboI12u
      XdVQ++tWDeHpEWf5d5z62sSpozVObs360DHiNl57FOkYXa7mSW2+jnbQLtpVu6gx
      be0QTxv53pXUSd86dLTz1MQ0qc/ujt21nFMEiF2KdJQuVutkX6SZdlAnddIO2owW
      t95Uw1SJh+l/Dh3tQzrZv8J8bRp2wiD8WRFNYJVVekxPqLf+qS7Jvcgv+kWDJUmb
      awd1VDu109Z0FUuZrny6dQ/W86YK7xEfceJbwT5VekkvqYtO1+EqTvalpmmaXpEk
      1VZrtVE7baOWaunc1Bcuy6eZeOea5yjhFt5YESC2GqqhOl/H6fTsTKVaqZEaufa/
      GmtrbaNO6qztos+5gkSZAsSlmXhfMo1/VGW2gDRMGAOxX0+drt65up+ujrroEPVj
      4D21DtezvuVTVO7QR+Fd/wofaU96RJwIEDeU6zgdmfTges1qaW9dqL14HzI0R09r
      tCapkdqoj7ZL5DU6+95lVaylznwJzFUT01NNp+s/9Lo4ESAu6agj1U/NcvXyO+oS
      9aFLBbRCV+vudaY7K9DBullbxv46DXxXPG8b5zOqOWa8A6tKTcKvt4Pq8Gl3z27q
      r34qy82Ld9JVOoD3wGiF+lZzOb5cH8T8XPh8w2OCvfWyM23aQ+/5V/iAk+S4ESBu
      KtLeOlj752ZooofuUBveA1/9arjhtFzfqzTG1/nacL/3ufpXjK82VB/rBy3Tttpe
      vbI8LDdL5VzAAmLVWVfrO3nZ/inyzvYWe6jJFz5td1msr/SM4Z36d2yv9J237x+2
      3N57JatterOpV65WI74QgMyV6zS9qWXZDZEtvY9Iihrs79Nu9bxFMb7SQMO79EZM
      r/OxV/dP2y7w7spim25r6pHv80UQPyZTzAdT9R/10ibqpVs1LFtP4v6o7jqPKRqr
      9YVP2UKNifGVTFObx/MY4Qj1qmZ5AE//0BNZatEhGmuq8rwQO8ZA8k9Dddde6q5W
      2XixznougTuL7DbbMMfYEzo6ttfqpo99SmtpaSwPgv5Nb9ZQ0lQTtWEW2vRkPeRf
      oUqbaS59L26cgeSf+XpBp2sbba5j9R+NTPaM5Bt1cug+n3jMMpRPi/G1/M9Atogl
      Pl6oMT6k6XowCy26xPCwpKR3iI8kECD5a7qe0OnaTvXVQ1fqLS1M5mUqdKCukEd7
      58ByQxjFcwHLf3AhG3OnP69FpiqP0huSwFxYWKz39J6kQrVRV+2kTmoXb7/wdK3G
      6HFtRFtn2WRDcMcRIKv1om/52CwcpzEd5uslekMSCBD8rkqjNEoPSKqtDuqkHdRJ
      HeKaK3GQftTLDs26ZIdsTOX+keHh7srEj3KCPjVVeSoLu5GXCBBU95n/Rt+s6R+t
      1Ebt1Ubt1DJabxmmnfWW2tG6Sc/Bv45sBMhzhvK2iR/lo+YLpA/T65JBgMDPKo3R
      GL0gSaqtVmqpFtpaLdUxzFQp07S7XtJf875R62TtlZKfyn3VmqXHatY+4WNcZh6m
      H7bOSgSIFQGCoCo1ap2Z9xppX/XX3pn1oArtqyd1CG2ZJaanQKKfgXykOYYa+yd8
      jE+Zb6/i/CMx3IWFcGbrCfXS5rrOd7LXP1muw/UYrZcl/pewylQ/8iuYns7bUp0T
      PsY7zV3uv/SEpBAgiGK2LtfWeiCTZ0lW6wTdT8tlQZUhQFrG8AqvGGocmvCzyh9p
      tKnKS5n9EweZIEAQ1Vydqh0zWVbC0+m6g3ar0aKYtjPVcOtR9AtYX2mmocahCbdV
      gH6UjScZ8xYBgjgM0w66Ofh5iKdzdROtVoO4pgZI/h6sl4yvkOwFrIl61VRljD6g
      RyWHAEE8KnWxdtcvwf9ggK6h1RKV/D1YLxnKkz7/uMsctrfTD5JEgCA+Q7S93ghe
      /Ur9kzZLUNJnIGM13lAj2fvtFutxU5W5eop+kCQCBHGar/10efBrMDfqPGbJSswE
      Q3nUADE9AVKuHRI9vkfM07f9R8vpB0kiQBC363SAFgetfLvOJUISMs63tK42j7j9
      lwzlfRK9A2uFbjZVWcXtfkkjQBC/N7STfgpa+U6dS4slYLXhAlPU84+pa2a7qVnf
      RI/vEfO09y9qKv0gWQQIkjBGO2pI0Mp36mJaLHaTDTfxbhNx+4MNZ46liU5aUxnk
      Lj4G0BNHgCAZc7VX8Cm0b9bVtFjMxhnKt424fdObu582SPDoHtPPpipf6kt6QdII
      ECRluQ7WA0ErX2W+ou2MjbPyKqaV1aMFyHx9YqjRN8FjW6UbzZU4/8gCAgTJqdKp
      ujJo5Yt1Fx+6GJnOQFpH2vorWuVbXqx9Ezy2J/Wjqcr4NXNIw4G+jPx1jc4PWvUc
      Zp2IkX+AFEQcAzF9O/dUSWJHtkoDzZWuje2BfvggQJC0f+nMYBU9naYnaK+Y+C8l
      2yzSAsPz9Y6hRt8Ej+wh4zT1mqj/0QOygQBB8u7VycH+PVilE4wThCOI6VrgW94m
      0tYHa6VveS0dkNiRLdJV5koDDVfYEBMCBNnwkI4NFiGrdZReo70iM42ARLuA9ayh
      fPcwC1YGdLNmmar8xAQm2UKAIDueUv9g/yqs1GH6NK+bKo6L96Z7sKIMoc82TnB7
      UGJtM1X/Mlfi/CNrCBBky3M6zPBs2xpLdYBG5HFDxbEeyPeG8iiXsAZptW95oQ5O
      rG2u0FJTlV8YSMseAgTZ86KODPbP6wXqYZyMHH5GGsqjPAXytKF8DzVN7KgeN1e6
      Idg/UxAHAgTZ9IKODxYhc7QXExmFVmU4A2kcYYxivHGOmn6JHdf55s4zVY/w/mcP
      AYLsekKnBqv4i3pqTl42UfQ5bCdriW95+wjbftQwB1ZRYhew3tJ75krXcv6RTQQI
      su0h/SNYxbHa33Azqp1WG8rrRX6F4Yby7UJveZXxItKeapRIqy3X2eZKk/UYH7Bs
      IkCQfXfpwmAVh+ogB1cEWpz4K5iG0DuE3vJbmmGocVhCx3S9cYEsSRdz/pFdBAhy
      4dagc2R9oMOM/2J3Te3IWzDdwxY+QB42lNdJ6BbecUEm2/yS+a+yjQBBblyjW4NV
      fEXHO7ZmoemcasPIr+B/D9YGoW/ina3XDTX6qEECLebpdK0wVztfyDICBLlyoR4K
      VvFJnePUga9IePsLDctBbht6pY4nDFOYSCckckRP6CNzpReDL2GGuBAgyJ1T9WKw
      infpmjxqlqjz2I40nLGFHUKvMi4x3kw9EmiPebrAXGkVy1rmAgGC3KlSf+OsGGtc
      qXucOWzTk+a1Im7f9BBh2Jt43zA+3HlsIl8oF2quudK9PHmaCwQIcqlSB2hosKpn
      GZ+AtoXppoA6Ebc/3FDeMeR2/20oL9TxCbTWx0HuzK3QtXyYcoEAQW4tVS+NClLR
      0/F6xYlDXmgorxtx+8MM5eHOQMYY1wDppi1jb6slOiXILRQDg5ykIH4ECHJtvvYJ
      dvlhpfrrQwcOeImhPNqa6csNl7A2U+NQ273P+EV+YgJtdaHGmyuNz5vVkFOHAEHu
      TVcvTQ9ScakO1LfWH65pPtlog+gjDHdKhRtCrzBeSCrTgbG31Jv6T5Bqp/L4YK4Q
      IEiDidpHFUEqLlAv41oXaWc6A4l2Ccs0pLRjqK0+anx+/rQYnl/5o3k6Mcjlq0D3
      +CIZBAjSYZT2MS/1IElztI8mW32opruwNoq09W8M5Z1DbLNK9xpqFAWdIzMDpxqn
      TZE0n8cHc4kAQVoMVZ9glyKmah9Ns/hATf+Wj3YJy3QG0iXENgcZB6kOUnnMrfSE
      BgWpdj7D57lEgCA93gu64NRE9bJ4qnfTiVaUQfSFhkHnpiEWe/J0g7HOPxSvn4PM
      vSt9wuy7uUWAIE1eCHol5HvtZ+1U70nexvuNIYHDnH+8pe8MNbZX11hbqErHBXl3
      KxO4boaMECBIl4eCTknxtfoEGzRJnV99S+tEepAwiREQ8/nHOTG30I3BxsVv1Tg+
      MAD+6AZ5wX7+5q3w7NPN95gaR9r2IYYWeyfjLX5qfBfKvOWxts+7Xq0g7/5YFfNR
      yTXOQJA+/9QDwSq+oaMtXC1kvm9pw0jb/tq3tEA7ZLzFG401Tos8+cq6puiIIO/p
      Kh3t4Fpj1iFAkEan67lgFZ/TydatFuJ/29AmEbY8Wz/7lm+VcTyN0BuGGrV1Roxt
      U6l+wW6PuNp4tQ5ZQIAgjap0tPGba41Hg82WlCL+YyBRzkC+NpRn/hDhjca2PUpN
      Ymyb8/RlkGpf6no+JGlAgCCdKnWoPglW9SH93aIIWaZlvuVRAsS0olKmATJRzxtq
      FMa6DMfTwSbtX6qjg93ujaQRIEirpTog6GWKe3WeNYf1q6E8ypKwnxvKMw2Qm4yj
      EQerVWwt871OCVbxXNb+AGBWpu+D3pF1gSX3YI00HMd1obe8wqvru+Va3pKMtjfZ
      28DY6t/G1i4VXqtg7/TrfCzSgzMQpNlc9Qr6r81bdaklh+Qv/CD6MMNzMe0yfETx
      WuMK6PuqU0ytslpHB5m4XZqbyKzxCIkAQbpN1T6aGqzq9braggOabSgPPwZiuoCV
      2dPi4/Wksc4/Y2uVs/RqsIonaiYfivQgQJB2k7VP0AnzrtLA1B+OaYbZstBbNgXI
      rhlt7SqtMm5vj5ja5EbdF6zizY4sSgkgizppQdCxkEtSPgZysWH/x4Te8qaGLf+U
      wba+9wqNLf1aTC3ycrAnzz29zz94AYSxm5YEjZBzvaoUB8hxhr2fF3K74wzbLc9o
      awcbW7lDTK38pWHof+3PNDXiY5A2JDrs8Jn2Czp34u06PcWPCfiv3Vsn9BiI6QLW
      bhls6zu9aKwzQAUxtMZkHRDsba3UocbhI2QdAQJbfKQ+QWc/ul/Hp3aOrFm+pY1D
      bzfOEZArjA9mbqN+MbTFAvUNuq7LhcanJAHA175aEfRCVr+UztS7me9edwm9XdNT
      FMMCb+mLAK37TAwtscLrHvC91DN0fQDR7R88Qg6IeZrxOKw0DE73Dbnd2Ya2qOet
      CrytHsaWbe+tjtwSlV6foPExOtIaW0gQl7Bgl9fU33h/6RqvBr2+nkVzDaMzm4Xc
      7meG8p1VK+CWPtG7xjrXRP7iWK2j9XLQJrN15bA8QIDANi8GXTldelc9jXNPZdc0
      Q3nYMZD4RkAuN9bYQX0itoKnk/VssKqVOpSZr9KLAIF9ngs+G+vn2k1TUrTrpslB
      wk6NHtc9WJ8HmAL5moj3X3k6S48GrXx8sNVtASC447Q66FjIFt7o1IyBTDbs614h
      t7uh71aLAk+jeKqxNXeJ3AYXBB378DSAjg4gCScEj5CG3qcpCZAVhj2dGWqrMwxb
      3THwlnY1tuV7EVvgyuDx8TSdHEBSMoiQDb3nUxIhW/vsZbOQ2/zVcPTnBN6SaTqU
      bhGP/tLg8fG+atPFASTnCK0M+oVU4F2figB50Gcf/xN6q018j/2FwNtpbWjFKGdy
      Vd5ZwePje9WjewNIVt/gz4XIO8mrzHmArPTa1rB3rSM8+nigz1GXePMDb6evb/vt
      E+G4V3lHB4+POWpJ1waQvH21LHiE7JXBl2lSpnnbVLNnW3tTImzzW68glvmJ7/c9
      h/sq9P6t8I249X7mqR3dGkB2dNOi4BHSKsKE6fFFSL8/PJFe4B3qTY24zaNqON7N
      M5rfd4W3ZY0td3DofVvi9QweHwvUhS4NIHu6Bl8vRN7G3ks5jxDPG+ld7PX2Oni9
      vQu9ETFsb0W1U4Ns7v2Q4XZe82pX22rNvWkh96zC2y14fCzJaNpgAIhBJ80LHiEF
      3lWpXjMkbIRc6dX/w1Ee4k0KsZ0XqomQ5hktR/XHs63tg8fHMu1NV7ZJAU0AR7TT
      +5ksOdRbj6vUuUaYr/9qtCapTG11gDqE3MpIXaFX1k7pXqIzdUHIpXaH64CgS9pL
      lTpYr9GRbUKAwB2t9L7Kg1ffUs+pM61WgwkarnHaSG3UOfQ67a/qCC0OWrlKh+kF
      2h1ArpRrdPALWfLqeHc7dyErPf4VdK3z336OofvahzMQuKWhXtfOmfzBoXpQ9Wm3
      mK3WWbovkz84UY/QavYhQOCaunpGvTP5g7/oMXWj3WK0SIfpzUz+4GQ9RKvZiACB
      e+pqlkoy+YNCnavrVEzLxeIX7a/vg1ev0rF6ilazE+uBwD0nZRYfUpVu044aQcvF
      4EN1ySQ+KnUw8WGvWjQBHFOsFzINEEmarUe0UruoiBYMzdPNOl6Lgv/BUvXR67Sb
      vTgDgWuOCrsubKWu1XYsgBdahQ7SgKAL1v/2Bz30Du1mM8ZA4Jpv1SnaR+J43aKG
      tGOGhme6ePls7aPhtJvdOAOBWzpEiw/J0yPaRvdm8i9p6DHtkll8TNVfiQ/7ESBw
      y4lxbGSuztR2XJwPaLlO1vFansmfTNbuGkfL2Y9LWHDLrEzmwzLppmu0O23qa6L6
      6bvM/uRL9dFsWs4FnIHAJe3ijA/pI+2h7vqAdq2Bp/u0Xabx8T/tSXy4ggCBS/aI
      f5Mfai910H+CTwqYNyaqh87Q0sz+6Dr1z+xqFwBkx7P+E/Z180oymd7vDz/1vbO8
      0cyQuMav3vk1LDzl87NCR9FF3cIYCFwySS38ij9XQ/WPdPPPduqnw7RVXjfyTN2l
      e7Qw0z+brwP1CV0UQDoVa7Xfv4DL16zbNyCzacar+ensXed94a3Ku/OOKu9971Bv
      gzBtNkEt6aAA0qud/5fYEWu/CD/ztooYIb9d1Orr3e2NzZPw+MG7ytsmbFt9yJOZ
      ANJtX/+vsQfW+Tpc6J3sFcQQIvLkbe4d4d3pfektdzQ6Rns3eZ2itNBtTDAGIO1O
      8f8iG7LeF+OHXquYIuS3n9reTt5Z3lPeeEeCY5H3pneW1yJaqyzRQXRMdzGIDndc
      q8v8in/RFuv9Zrmu102qjH1H6qmt2qu92qqDNrGuGRfoC32ij/R1HNO5fKK/0jHd
      RYDAHbfrHL/iimqXrh2jMxOdgbex2mlbba0WaqktVTu1jferxmqEvtJQjZMX54a3
      ZdISd3FtEu4I9YBaG32owboos6kAMzBTM/Xemv9dqC3UUltpc22hJirX5mqQw+Za
      pRn6UWM0RmM1RtOTeplTdS5d01WcgcAdN2iAX/EUlddYVqm7dZ0qsr7LG6pcTbSF
      NlOZNlVDbbLmJ+4zlSr9qgrN1FRN0y9r/u9MVWXjEOdrc549dxVnIHCH4ZL9ap+y
      2jpfx+pm3ZPp1BwRLdMETajm9yXaRJuoRHVUqg1VrFIVq67qq/AP5ywbr/0AL1Gl
      PFVIWq5lkhZouSr069r/t1A501CHsGgtgLQz3IX1WYA7j2Z653l1Y703ix+9S9d0
      FZMpwh3j/YtHBdjEZrpNP+qiMIuqoya7pfjeAURCgMAdhnHw9wNuppFu0k+6hIen
      41KsnWkENxEgcMd0/wGMDzMYNN5EAzVVD2sHWjWADU0VetBGbiJA4I4q/3OQuRqW
      0eY21An6Rl/pWG1M29aoq17VjeZKAJByT/sP554RclKPpd4grx+D6+v9FHq9vI88
      z/O8WaZ5xabQNQGk3Wn+X3kNvKUR5oZa7D3rnej9hejw5DXyBniT12mb9qa/4K4E
      ACnXyvTF93QMkwxO8O7zDvEa5ml0bOT1917508zD/zD9XRs6J4C0m2JaCqoqprlq
      V3vfeHd5R3lb5010NPSO9P7nLam2Nf5r+uuedE0X8SQ63PKaTvMr/kaDY5pfvFA7
      rLlHa76+0lcaqqGa52STFmkHdVcvdVWtGuuUmzZS7lSTYA3mwoJbuugr/wrlGq16
      Cb34VI3WSI3WKI3RMuubckPtoF3UTbsHuAtttNr5V/in+VYt2IczELhlqEb5f5dN
      1SX6d0IvXq5y7SNJWq3JGqmxGq8Jmqi5FjVgA7VVG22nndUhg6+HlaYKSy1qAgRG
      gMA1D+t2/wr36UjtkvBO1NLW2nrtfy3URE3SJE3UZE3U1HjX24hBmdqptdqordqo
      cagtLI5cATbiEhZcU6KfTbOQtNC3Ks3ZDq7QVE3XVM3QFM3QVE3TDK3IchNtoXJt
      rmbaQttoW5VF3uLz6udfob/+R9d0D2cgcM1i3aIb/KtM1nEanLN/PdXRVtpqvd/N
      0TzN17y1P3M1TxVapCVargWhX6lUpWqwzv/bTOXaQuUJhKfxGf9f6Jgu4gwE7inR
      JDUyVbpZF1pzQMu0XL9qhZZqwZr5vLw/LX5Vog1UqPqSNlSxpAYqzeLHu71pruNN
      NJ+O6R4CBC66QLeYqhTpbXWnpWIxXNv7V5ipJrSSi5hMES66VzNNVVapt+mOXwT0
      uKnCN7SRmwgQuGipBporLdEBpiVEEMBcPWKq8jWt5CYCBG66N8jc7XPUQ5Npq4gu
      NK+4zhmIoxgDgas66usgdxlurvfUmtYK7QUdaqqyUJtpOS3lIs5A4KrhuiNItWna
      XZ/SWiFN06nmSs8RH64iQOCuKzUySLW52luP0lohLNXBQe7Ofdz9lshXBAjctVSH
      mi/PS1KlTtBFGayYDkmqUv8g97EN02e0lasIELhsvE4MWvUW/U1zaLHAPJ2rV4JU
      vJy2clctmgBOG6Ni7Ras6iQ9qe3VgjYLYLVO031BKn6pAbSWuwgQuO59tVL7YFUX
      6ymt1B6cmBss0MF6NljVI/Uz7eUubuOF+2rrzUxmLemsh9WBVqvRBPXWuGBV31Iv
      2stl/FML7qvUgRoevPo36qzLszzBuj1e1U5B46PSovkqAaBGDfWdvEx+Wnnve/ij
      Zd6ZXkHwNjyPbgfADRlHiLwDvQmkxlojvXaZtN77dDkA7ijVF5lGSJF3rDeW7PBW
      eFd5tTNpuSlqSocD4JISfZxphMgr9Hp6g7zKPI6Pz722mbXZArWjswFwTV29mXmE
      yJPX1LvC+yUPw2O6d1wm4x6ePK1gpS4AbirSPeEiRF4tbz/vMW9+3oTHMu96ryTT
      VlqtfnQyAO46QyvDhoi8Dbye3v3eLMfDY5X3iNcs89ZZSXwAcF1P/Ro+Qn47G9nT
      +7c3ydH4GOy1CdMqK9SXrgXAfc30ebQI+e1nS+9k73/ebGeiY6X3X69juLZYon3p
      VgDyQ5Fu0Oo4QkRegdfRO99701todXhM9a7xmodtg3nagy6Vb5gLC/ltbz2pxvFt
      rlDbqot20k5qF2Q93dSYrcF6QR9qddgNjFEfTaQ75RsCBPmuVLfruPg3W1ed1EVd
      1FFbpThKqjRc7+gtfRY+OiTpDfUPtnQX3EKAANLeelDNk9p4HW2rNmqvtmqrLVPy
      kVulERqiIXo/+iJaq3SlbmQ5x/xEgACSVFcDdXbys1MXq4W2XPPTQluqXlYPcr4m
      a6SG6zsN09J4NjlZ/TWU7pOvCBDgdx10U7bvI9pEzdREjdRUjbSZmmpTNVFpTNte
      pbmap9mapEmarEmarF/j3v1HdC6XrvIZAQKsq6eu1s653YViNdTG2lilqqeNtbHq
      qZ5KVaBibbimRr21S4kuUaUqtUSeKiQt0jLN1TzN01zN0YJkd3OyTtYHdBgAWFfP
      MFMu5tXPSt2iunQUAKhOFz2jFURFtT+fqyMdBAD8NNIATSIw/vDzsw6nYwBAEIXq
      qcFxPa9u+c8SDeTCFQBkpqn+ro/zOkZW6r44n9gHgPzSSKfp3SgTwVv6s1rPqiVv
      PwBE1VDHaVDUyeCt+Vmhh9WaNx3V4zkQIIxCddLe6qGuKnb2GKfrMd2j6bzZqAkB
      AkRRrN20l7qpk2o7dFRVek0P6w2t4g2GHwIEiEOROqqLdlIXyy/4rNIHGqSXNJu3
      FGYECBCvetpZXbS92qmFVUuCTNU7elvvqIK3EEERIEBSaquN2qi92qmNWqR2L8dp
      iD7XEI3jDUOmCBAgG+qqjVprW7VUc7VQWY73plJjNFLfabiGc8aB8AgQIPtK1Fwt
      1EJbqoWaq5EaJf6KSzVZkzVRkzRZ4/UTC0AhDgQIkHuFaqTGaqxGaqrN1EiNVE8l
      qqeSEIuDVGm+5mrumv87S3M1WRM1k0ZG/AgQIN3Wj5K6a28YLlWFpMVapeVaqiot
      lFSh+TQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
      AAAAAABw0v8B+e/muoA1uVQAAAASdEVYdEVYSUY6T3JpZW50YXRpb24AMYRY7O8A
      AAAASUVORK5CYII=
} as Hand

Escape Off
finale=false
Spot$=""
Image Hand  (#333333) to Spot$, 50
Hide
Back 12 {
Cls 5,0
// Refresh 5000
//Player 0
Pen 14,255

Dim a$(1 to 2)
// Walrus=Buffer("walrus.png")
Pen 14,255
after 300 {

Gradient 1,5
Cursor 0, 1
Report {
	Πάτα Esc πλήκτρο για έξοδο.
	Πάτα Αριστερό πλήκτρο ποντικιού για επιλογή και μετακίνηση
	Πάτα Δεξιό πλήκτρο ποντικιού κρατημένο αλλάζει μέγεθος και γωνία
	Πάτα Διάστημα για να αλλάξεις φορά στο πρόσωπο
	}
Pen , 50
Gradient 1,5 : Gradient 1,5
Pen , 255
move scale.x*.8, scale.y*.8
Image Walrus, scale.x,,0

}
FlipXImage=image(Walrus,#333333,,,4)
image Walrus (#333333) to a$(1)
image FlipXImage (#333333) to a$(2)
range=2

player 1, 5000,7000 use a$(1),#333333,range, 30 size .5
player 2, 9000,7000 use a$(1),#333333,range, 30 size .5
player 3, 13000,7000 use a$(2),#333333,range, 30 size .5
Player 4, mousea.x,mousea.y use Spot$,#333333,10,45, -800,-1000 
Dim Col(1 to 3), S(1 to 3)=.5, R(1 to 3)=30, Px(1 to 3), Py(1 to 3)=7000
Dim Images(1 to 3)
Col(1):=1, 2, 5
Px(1):=5000, 9000, 13000
Images(1)=1,1,2
Dim PlayersOrder(1 to 3)
PlayersOrder(1):=1,2,3
Inventory Names = 1:="Μπλεδούλης", 2:="Πρασινούλης", 5:="Ροζούλης"
Layer 1 {
	Pen, 100: gradient Col(1), 0
	move scale.x/2, scale.y/2
	Pen 14
	legend Names$(Col(1)), "Arial New", 12, 0,2
}
Layer 2 {
	Pen, 100
	gradient Col(2), 0
	move scale.x/2, scale.y/2
	Pen 14
	legend Names$(Col(2)), "Arial New", 12, 0,2
}
Layer 3 {
	Pen, 100
	gradient Col(3), 0
	move scale.x/2, scale.y/2
	Pen 14
	legend Names$(Col(3)), "Arial New", 12, 0,2
}
Player 1 show
Player 2 show
Player 3 show
Player 4 Show
x=scale.x
x2=x/2
deg=180/x
IsHide=False
HiddenSpot=4
TopPlayer=3
Semaphore=False
(xx, yy)=(mousea.x, mousea.y)
Thread {
		Part {
			cursor 0,0
			Print Over $(5,10), Names$(Col(TopPlayer)), @WhoisThere2(), Px(TopPlayer), Py(TopPlayer), $("0.00"), R(TopPlayer), S(TopPlayer)
			Print  Under
	} as Semaphore
} as Informe interval 1000/25
every 1000/25{
	if keypress(27) then exit
	(xx1, yy1)=(xx, yy)
	(xx, yy)=(mousea.x, mousea.y)
	player HiddenSpot, xx, yy
	if mouse=2 then
		Part {
			refresh 5000
			HideAllicon()
			S(TopPlayer)=abs(mouse.y/scale.y)+.4
			R(TopPlayer)=30-(mouse.x-x2)*deg
			if keypress(32) then
				Images(TopPlayer)=3-Images(TopPlayer)
			end if
			ShowPlayer()
			refresh 5000
		} as Semaphore
	else.if mouse= 1 then
		Part {
		HideAllIcon()
		Which=@WhoisThere2() 
		if Which>0 and Which<3  then
			TopPlayer=PlayersOrder(which)
			Player Which over 3
			RotateValues(&PlayersOrder(), Which)
			for i=1 to 5
				player 3 hide
				refresh 
				wait 20
				player 3 show
				wait 20
				refresh 
			next
		else.if which=3 then	
			HideAllIcon()
			Px(TopPlayer)+=xx-xx1
			Py(TopPlayer)+=yy-yy1
			player 3 ,Px(TopPlayer), Py(TopPlayer) : wait 3
		end if
		} as Semaphore
	else.if keypress(32) then
		Images(TopPlayer)=3-Images(TopPlayer)
		ShowPlayer()
	else
		ShowAllicon()
	end if
rem	cursor 0,height-1
rem	Print Over $(4, 6),  TopPlayer, PlayersOrder()
	
	wait 1
}
Thread Informe Erase
Player 4 hide
Pen , 30
move scale.x/2, scale.y/2
mv=30
TopPlayer=3
For i=1 to 50
	if i<25 then Gradient 0 else gradient 1, 5
	for k=1 to 3
		px(k)+=if(px(k)<=pos.x ->-mv, mv )
		py(k)+=if(py(k)<=pos.y ->-mv, mv )
	next
	for k=1 to 3
		j=PlayersOrder(k)
		Player k, px(j), py(j)
		next
	refresh
	mv*=1.3
	wait 10
Next
Pen ,255
}
finale=True
ShowAllicon()
Show
back {cls 11,0 : refresh 50}
wait 200
if IsHide then ShowAllicon()
Player 1 hide
Player 2 hide
Player 3 hide
//Player 0
Mouse.icon 1

Sub ShowAllicon()
If not IsHide then exit sub
IsHide=false
if finale else exit sub
Layer 1 {mouse.icon show}
Layer 2 {mouse.icon Show}
Layer 3 {mouse.icon show}
Layer 4 {mouse.icon show}
mouse.icon show
End Sub
Sub HideAllIcon()
If IsHide then exit sub
IsHide=True
Layer 1 {mouse.icon hide}
Layer 2 {mouse.icon hide}
Layer 3 {mouse.icon hide}
Layer 4 {mouse.icon hide}
mouse.icon hide
End Sub
Sub ShowPlayer()
Player 3 use a$(Images(TopPlayer)), #333333,range, R(TopPlayer) size S(TopPlayer)
Layer 3 {
	Pen , 100
	gradient Col(TopPlayer), 0
	move scale.x/2, scale.y/2
	Pen 14
	legend Names$(Col(TopPlayer)), "Arial New", 12, 0,2
}
Player 1 show
End Sub
Function WhoisThere2()
	local i
	for i=3 to 1
	layer i {
		move mouse.x, mouse.y
		if point=0x7FFFFFFF then exit
		if point=#333333 then exit
		local hit=i
	}
	if valid(hit) then = i : exit for
	next i
End Function
Function WhoisThere()
	local m=Binary.AND(Collide(4,10), 7)
	if m=0 then exit function
	if Binary.AND(m,4) then
		=3
	else.if Binary.AND(m,2) then
		=2
	else
		=1
	end if
End Function
Sub  RotateValues(&a(), N)
	Local Z=Dimension(a(),1,1)
	Local V=a(N)
	Stock a(N+1) keep Z-N, a(N)
	a(Z)=V
End Sub
}
MODULE CODEPAGES {MM=LOCALE
Charset 0
FONT "Tahoma"
m$=fontname$
Form ! 80, 40
page=-1
Print "Font:";fontname$
old=locale
for i=1023 to 1170
	try ok {
	 	locale i
		// uncomment the next line
	 //	charset 0
	 }
	If ok then gosub 100
next i
Locale Old
Print Part "Done - Press a Key"
Gosub 200
wait 100
While  (inkey(10)=-1 and mouse=0) {wait 10}
cls
LOCALE MM
keyboard "info"+chr$(13)
end
100 Bold 0
	m=tab
	x=0
	y=row
	Pen 11 {
		Print Part $(6, m*2),locale$(4),$(0, m), @(tab(3)), locale$(3), Locale, codepage,charset,
		Pen 15+2*(m$=fontname$) {Print "-->";fontname$}
	}
	gosub 200
	Y++
	for i=33 to 255
		if x=width then x=0 : page-- : if y>height-2 then gosub 200 else y++
		print part @(x, y), chr$(i)
		x++
	next
	gosub 200
	gosub 200
	Bold 1
Return
200	Refresh
	page--
	if y=height-1 then
		if page<=0 then
			While (keypress(1) or keypress(32)) {wait 10}
			While not (keypress(1) or keypress(32)) {wait 10}
			// This is the page control, so each next stop for key happen after
			// printing 3/4 of rows (height is the number of text rows)
			// page here is a variable
			page=height*3/4
		End if
		scroll up
	Else
		Print
	End if
Return
}
MODULE LIBEPIG {Τμήμα ΦέρεΑπόΔεξιά(Α, Β,  βήμα_ολίσθησης=60, ΣκίασηΦόντου=0,  Συνεχόμενη=0, φ1=1, φ2=5, μεγ=1) {
	Αν βήμα_ολίσθησης<15 Τότε Έξοδος
	πολλ=1
	ΜεΣκιά=Ψευδές
	ι=Κλίμαξ.χ*1.5 
	Όριο=Κλίμαξ.χ/2
	υ=κλίμαξ.ψ/2
	ΜεΣκιά=Τύπος$(Β)="Buffer"
	Αν ΣκίασηΦόντου>0 Τότε Πένα, ΣκίασηΦόντου : Φοντο φ1, φ2
	Ν=0
	Πένα , 255
	Κράτησε
	Ανανέωση 5000
	Επανάλαβε
		ι-=βήμα_ολίσθησης*πολλ
		αν ι<=Όριο τότε έξοδος
		Άφησε
		Αν Συνεχόμενη Τότε
			Αν ΣκίασηΦόντου>0  και Ν=0 και ΣκίασηΦόντου<255  Τότε
				Πένα, ΣκίασηΦόντου : φόντο φ1, φ2
				Αν Συνεχόμενη Τότε
					Κράτησε
					ΣκίασηΦόντου*=1.04
					Αν ΣκίασηΦόντου>255 Τότε ΣκίασηΦόντου=255
				Τέλος Αν
				Ν=Συνεχόμενη
			Τέλος Αν
			Ν--
		Τέλος Αν
		Αν ΜεΣκιά Τότε Θέση ι+πλάτος.σημείου*2, υ+ύψος.σημείου*3: Εικόνα Β, κλίμαξ.χ,,0
		Θέση ι, υ
		Εικόνα Α, κλίμαξ.χ*μεγ,,0
		Ανανέωση 5000
		Αναμονή 20
		Αν πατημένο(32) τότε πολλ*=1.08:Συνεχόμενη/=2
		Αν πατημένο(27) τότε Έξοδος
	Πάντα
	Άφησε
	Πένα , 255	
	Αν ΣκίασηΦόντου>0 Τότε φόντο φ1, φ2
	Αν ΜεΣκιά Τότε Θέση Κλίμαξ.χ/2+πλάτος.σημείου*2, υ+ύψος.σημείου*3: Εικόνα Β, κλίμαξ.χ,,0
	Θέση Κλίμαξ.χ/2, υ
	Εικόνα Α, κλίμαξ.χ*μεγ,,0
	Ανανέωση 50
}
Τμήμα ΦέρεΑπόΚάτω(Α, Β, βήμα_ολίσθησης=60, ΣκίασηΦόντου=0, Συνεχόμενη=0, φ1=1, φ2=5, μεγ=1) {
	Αν βήμα_ολίσθησης<15 Τότε Έξοδος
	πολλ=1
	ΜεΣκιά=Ψευδές
	ι=Κλίμαξ.ψ*1.5 
	Όριο=Κλίμαξ.ψ/2
	π=κλίμαξ.χ/2
	ΜεΣκιά=Τύπος$(Β)="Buffer"
	Αν ΣκίασηΦόντου>0 Τότε Πένα, ΣκίασηΦόντου : Φοντο φ1, φ2
	Ν=0
	Πένα , 255
	Κράτησε
	Ανανέωση 5000
	Επανάλαβε
		ι-=βήμα_ολίσθησης*πολλ
		αν ι<=Όριο τότε έξοδος
		Άφησε
		Αν Συνεχόμενη Τότε
			Αν ΣκίασηΦόντου>0  και Ν=0 και ΣκίασηΦόντου<255  Τότε
				Πένα, ΣκίασηΦόντου : φόντο φ1, φ2
				Αν Συνεχόμενη Τότε
					Κράτησε
					ΣκίασηΦόντου*=1.04
					Αν ΣκίασηΦόντου>255 Τότε ΣκίασηΦόντου=255
				Τέλος Αν
				Ν=Συνεχόμενη
			Τέλος Αν
			Ν--
		Τέλος Αν
		Αν ΜεΣκιά Τότε Θέση π+πλάτος.σημείου*2, ι+ύψος.σημείου*3: Εικόνα Β, κλίμαξ.χ,,0
		Θέση π, ι
		Εικόνα Α, κλίμαξ.χ*μεγ,,0
		Ανανέωση 5000
		Αναμονή 20
		Αν πατημένο(32) τότε πολλ*=1.08: Συνεχόμενη/=2
		Αν πατημένο(27) τότε Έξοδος
	Πάντα
	Άφησε
	Πένα , 255
	Αν ΣκίασηΦόντου>0 Τότε φόντο φ1, φ2
	Αν ΜεΣκιά Τότε Θέση π+πλάτος.σημείου*2, Κλίμαξ.ψ/2+ύψος.σημείου*3: Εικόνα Β, κλίμαξ.χ,,0
	Θέση π, Κλίμαξ.ψ/2
	Εικόνα Α, κλίμαξ.χ*μεγ,,0
	Ανανέωση 50
}
Τμήμα ΠερίμενεΚουμπί(ΧαμένοςΧρόνος) {
	Ανανέωση
	Αναλυτής
	Ενώ ΧαμένοςΧρόνος>Φόρτος
		Αν πατημένο(32) Τότε Έξοδος
		Αναμονή 1
	Τέλος Ενώ
	Ενώ πατημένο(32)
		Αναμονή 1
	Τέλος Ενώ
}
Συνάρτηση Επιγραφή(Χρώμα_Επιγραφής) {
	Τοπική Α, A1
	Σχέδιο 8000, 2000 {
		Πένα Χρώμα_Επιγραφής, 255
		Αναφορά 2, "https://georgekarras.blogspot.com"
		Δρομέας 0, 3
		Αναφορά 2, "https://github.com/M2000Interpreter"
	} ως Α
	Σχέδιο 14000, 14000{
		Θέση 6500,7000
		Εικόνα Α, 12000,,0
	} ως Α1
	=Α1
}
Συνάρτηση Επιγραφή1(Χρώμα_Επιγραφής) {
	Τοπική Α
	Σχέδιο {
		Πένα Χρώμα_Επιγραφής, 255
		
		Φορμα 40, 28
		Διάστιχο 120
		Φορμα 40
		Διπλά
		Πλάγια
		Αναφορά 2, "Προγραμματιστικά Υποδείγματα"
		Πλάγια
		Κανονικά
		Δρομέας 0, γραμμή-1
		Τύπωσε Υπό
		Τύπωσε "○  ";
		Αναφορά 3, {Μη Δομημένος Προγραμματισμός (GOTO ή ΠΡΟΣ και αριθμούς γραμμών)}
		Τύπωσε @(0), "○  ";
		Αναφορά 3, {Δομημένος (Structural) Προγραμματισμός (Δομές Επανάληψης και Επιλογής)}
		Τύπωσε @(0), "○  ";
		Αναφορά 3, {Διαδικαστικός (Procedural) Προγραμματισμός (Στατικές Ρουτίνες και Συναρτήσεις)}
		Τύπωσε @(0), "○  ";
		Αναφορά 3, {Τμηματικός (Modular) Προγραμματισμός (Τμήματα και Συναρτήσεις ως ανεξάρτητες μονάδες, που δύναται να περιέχουν ή να φορτώνουν άλλες μονάδες ως εξωτερικές βιβλιοθήκες)}
		Τύπωσε @(0), "○  ";
		Αναφορά 3, {Συναρτησιακός (Functional) Προγραμματισμός. (Λάμδα συναρτήσεις ως πολίτες πρώτης τάξης)}
		Τύπωσε @(0), "○  ";
		Αναφορά 3, {Αντικειμενοστραφής Προγραμματισμός. (Κλάσεις και Αντικείμενα)}
		Τύπωσε @(0), "○  ";
		Αναφορά 3, {Προγραμματισμός με Γεγονότα (Event-driven). (Συνδυάζεται με Αντικείμενα, όπως με φόρμες χρήστη και στοιχεία ελέγχου γραφικής διεπαφής)}
		Τύπωσε @(0), "○  ";
		Αναφορά 3, {Παράλληλος (Concurrent) Προγραμματισμός. (Νήματα σε έναν επεξεργαστή)}
	} ως Α1
	Σχέδιο 10000,10000{
		Θέση 5000, 4500
		Εικόνα Α1, 8000,,0
	} ως Α
	=Α
}
Συνάρτηση Επιγραφή2(Χρώμα_Επιγραφής) {
	Τοπική Α
	Σχέδιο {
		Πένα Χρώμα_Επιγραφής, 255
		Διάστιχο 120
		Φόρμα 40, 40
		Διπλά
		Αναφορά 2, {
		Το Προγραμματιστικό Περιβάλλον Μ2000 στη Πρωτοβάθμια και Δευτεροβάθμια Εκπαίδευση
		
		}
		Αναφορά 2, {Γιώργος Καρράς
		}
		Κανονικά
		Αναφορά 2, {
		Δημιουργός της Μ2000, Πτ. Τεχνολόγος Πετρελαίων ΤΕΙ Καβάλας
		
		}
		Κανονικά
		Πένα Αν(Χρώμα_Επιγραφής=0->0, 7) {
			Αναφορά 2, {georgekarras@freemail.gr}
		}
		Πλάγια
		Αναφορά 2, {
		Η παρουσίαση γίνεται μέσα από το περιβάλλον της Μ2000!
		}
		
	} ως Α1
	Σχέδιο 14000, 14000{
		Θέση 6500,7000
		Εικόνα Α1, 12000,,0
	} ως Α
	// Σχέδιο 6000, 4000{
	//	θέση 3000,2000
	//	Εικόνα Α1, 5800,,0
	// } ως Α
	=Α
}
}
MODULE DEMOEPIG {window 10, 18000, 14000;
Αναφορά {Οδηγίες
	Για να δοκιμάσεις την παρουσίαση (μέρος της από τη πραγμαιτκή που έγινε 18-10-2020 στο συνέδριο 12o CIE 2020), μπορείς να κάνεις τα εξής:
		Με το διάστημα επιταχύνουμε την ολίσθηση, με το Esc την τερματίζουμε
		Στην εφαρμογή sprites, υπάρχουν οδηγίες, με Esc την τερματίζουμε
		Επάνω δεξιά φαίνεται και το ρολόι λεπτών για να συτονίζει κανείς το χρόνο της παρουσίασης.
		Το ρολόι δουλεύει σε δικό του νήμα και χρησιμοποιεί δικό του sprite, το 32 το οποίο είναι πάντα πάνω από όλα τα άλλα!
}
// Τα πραγματικά νούμερα των παικτών (sprites) δεν γίνονται ποτέ φανερά, αυτά που χειριζόμαστε είναι οι προτεραιότητές τους, έτσι πάντα το 32 θα είναι πάνω από τα άλλα, όσα και αν υπάρχουν, γιατί στην αρχή δεν υπάρχουν φορτωμένοι παίκτης. Μπορεί να αλλάξει νούμερο ένας παίκτης με έναν άλλο, αλλάζοντας προτεραιότητες (θα μπει ο μπροστινός παίκτης πίσω από τον άλλο, και όσοι είναι ενδιάμεσα θα παραμείνουν ως έχει), έτσι αν έχουμε δυο μεταβλητές με τις προτεραιότητες απλά τις αλλάζουμε μεταξύ τους τιμές. Η μπορεί να αλλάξει ένας παίκτης προτεραιόττηα κατά απόλυτη τιμή  αλλάζοντας τις προτεραιότητες των αλλων. Στη τελευταία περίπτωση πρέπει να κρατάμε λογαριασμό σε ένα πίνακα, δείτε στο τμήμα sprites, τη ρουτίνα RotateValues() που περιστρέφει τις τιμές σε ένα πίνακα (με γρήγορη εντολή).
// Οι προτεραιότητες χρησιμεύουν και για τον έλεγχο σύγκρουσης, ο οποίος γίνεται για νούμερα κάτω από το νούμερο προτεραιότητας του παίκτη. Συνήθως μας ενδιαφέρει ένας παίκτης να ελέγχεται για σύγκρουση με άλλους παίκτες.
Βάλε Κομ$: Πέτα

Κάνε UseTimer
Ένθεση Κώδικα LibTimer
Οθόνη 5, 0
Γραμματοσειρά "Verdana"
Φόρμα ! 60, 32
Αδειασε
Ένθεση Κώδικα LibEpig
Πένα 14, 255
Διαφυγή Όχι
Δρομέας 0,0
Φόντο 1, 5
// οι επιγραφές είναι στη βιβλιοθήκη (στο τμήμα LibEpig)
ΦέρεΑπόΚάτω Επιγραφή2(15),0, 60, 16, 2
ΠερίμενεΚουμπί 6000
ΦέρεΑπόΔεξιά Επιγραφή2(15),Επιγραφή2(0), 60, 16, 2
ΠερίμενεΚουμπί 6000
ΦέρεΑπόΚάτω Επιγραφή1(15),Επιγραφή1(#003366), 60, 8, 2
ΠερίμενεΚουμπί 6000
ΦέρεΑπόΔεξιά Επιγραφή1(15),Επιγραφή1(0), 60, 8, 2
ΠερίμενεΚουμπί 6000
Ανανέωση 5000
Περιθώριο {Ανανέωση 5000}
σβησε
Πένα , 220
Φόντο 1, 5
sprites
Πένα , 255
ΦέρεΑπόΔεξιά Επιγραφή(11),Επιγραφή(0), 90
ΠερίμενεΚουμπί 10000
Πένα Πένα, 255
Αν Έγκυρο(UseTimer) Τότε Παίκτης 32 Κρύψε
Ρουτίνα Τίτλος(Α$, Β$="", Πένα1=0, Πένα2=0)
	Δρομέας 0, 3
	Διπλά
	Πένα Πένα1 {Αναφορά 2,α$}
	Κανονικά
	Αν Β$<>"" Τότε Πένα Πένα2 {Αναφορά 2, Β$}
Τέλος Ρουτίνας
}
MODULE LIBTIMER {if Valid(UseTimer) Then
	UseTimer=Int(UseTimer)
	If UseTimer<1 then UseTimer=1
	timer_spr$=""
	timer_counter=1
	Drawing 1000,1000 {
		move 500,500
		circle Fill 2, 450,,2
		Pen 15
		legend str$(timer_counter,"00"), "Impact", 24,0,2
	} as timer_image
	image  timer_image  to timer_spr$ (5), 100
	Back {
		Cls 0, 0
		Player 32,  SCALE.X-1000, 1000 use timer_spr$, 5, 10,0   size 1
		PLAYER 32 SHOW
		Layer 32 {Refresh}
		Thread {
		{	timer_counter++
			if timer_counter=100 then Player 32 hide : Exit
			if  timer_counter>=100 Then Exit
			Drawing 1000,1000 {
			move 500,500
			circle Fill 2, 450,,2
			Pen 15
			legend str$(timer_counter,"00"), "Impact", 24,0,2
		} as timer_image
		image  timer_image  to timer_spr$ (5), 100
		Player 32,  SCALE.X-1000, 1000 use timer_spr$, 5, 10,0   size 1}
	} as  timer_id interval if(UseTimer-> 60000, 30000, 1000)
	}
Else
	Report  {LibTimer Version 2, George Karras
	To use this library:
		Def UseTimer
		Inline code LibTimer
	You can use:
		default value for UseTimer:
		 0 or 1, for 60 seconds per counting
		2, for 30 seconds per counting
		3, for 1 second per counting
	By default the timer hide when reach 100 coutings
		using timer_counter we can read or write new value
		the thread has to execute, so to add one to this value, to show this
	Stop The Timer: 
		1. By setting timer_counter to 100  (expecting a lag time, max the thread  interval)
		2. Holding the thread:
			Thread timer_id Hold
			to restart we have to execute Thread timer_id Restart
	Hide the timer:
		Player 32 hide
	Hide the timer:
		Player 32 hide
	}
End If
}
MODULE TSTTIMER {// Erase all threads
Threads Erase
// Erase all players
Player 0
Def UseTimer=3
Inline code LibTimer
Print "Timer start"
Profiler
Every 1000/50 {
	Print Over $(0,10), Timecount div 1000 + 1, timer_counter
	if keypress(32) or timer_counter>99 then exit
}
Thread  timer_id hold
Print
Print "Start Again in 15 seconds"
wait 15000
Thread  timer_id Restart
Every 1000/50 {
	Print Over $(0,10), Timecount div 1000 + 1, timer_counter
	if keypress(32) or timer_counter>99 then exit
}
Print
Print "Finished"
Player 0
}
MODULE LIBSTOPTIMER {if Valid(UseStopTimer) Then
	UseStopTimer=Int(UseStopTimer)
	If UseStopTimer<1 then UseStopTimer=1
	stimer_spr$=""
	if Valid(UseStopTimer_Start_Value) Then
		stimer_counter=UseStopTimer_Start_Value
	else
		stimer_counter=99
	end if
	Drawing 1000,1000 {
		move 500,500
		circle Fill 12, 450,,12
		Pen 15
		legend str$(stimer_counter,""), "Arial Black", 24,0,2
	} as stimer_image
	image  stimer_image  to stimer_spr$ (5), 200
	Back {
		Cls 0, 0
		Player 32,  2000, 2000 use stimer_spr$, 5, 10,0   size 1
		PLAYER 32 SHOW
		Layer 32 {Refresh}
		Thread {
		{	stimer_counter--
			if stimer_counter=-1 then
				Player 32 hide
				if valid(Use_Ring) then ring
			End if
			if  stimer_counter<0 Then Exit
			Drawing 1000,1000 {
			move 500,500
			circle Fill 12, 450,,12
			Pen 15
			legend str$(stimer_counter,""), "Arial Black", 24,0,2
		} as stimer_image
		image  stimer_image  to stimer_spr$ (5), 200
		Player 32,  2000, 2000 use stimer_spr$, 5, 10,0   size 1}
	} as  stop_timer_id interval if(UseStopTimer-> 60000, 30000, 1000)
	}
	Thread {
			// if stimer_counter<10 then thread this hold : exit
			player 32 hide
			after 50 {
				player 32 show
				after 50 {
					player 32 hide
					after 50 {
						player 32 show
					}
				}
			}
	} as stimer_pulse interval 500
	thread stimer_pulse hold
Else
	Report  {LibStopTimer Version 1, George Karras
	Need the ring module to play the ring tone
	To use this library:
		Def UseStopTimer, UseStopTimer_Start_Value=30
		Inline code LibStopTimer
	Optional: add the Use_Ring in the def statement to play the ring tone
	You can use:
		default value for UseStopTimer:
		 0 or 1, for 60 seconds per counting
		2, for 30 seconds per counting
		3, for 1 second per counting
	By default the timer hide when rich ZERO
		using stimer_counter we can read or write new value
		the thread has to execute, so to add one to this value, to show this
	Stop The Timer: 
		1. By setting stimer_counter to 100  (expecting a lag time, max the thread  interval)
		2. Holding the thread:
			Thread stop_timer_id Hold
			to restart we have to execute Thread stop_timer_id Restart
	Use the stimer_pulse thread
	Make the spriter flash
		Thread stimer_pulse restart
	Hold the flashing
		Thread stimer_pulse hold
	Hide the timer view:
		Player 32 hide
	Hide the timer view:
		Player 32 hide
	}
End If
}
MODULE TSTSTOPTIMER {// Erase all threads
Threads Erase
// Erase all players
Player 0
Def UseStopTimer=3, UseStopTimer_Start_Value=20, use_ring
Inline code LibStopTimer
Print "Stop Timer start"
Profiler
task()
if stimer_counter>0 then
	Thread  stop_timer_id hold
	Print
	Print "Start Again in 15 seconds"
	wait 15000
	Thread  stop_timer_id Restart
	task()
end if
Print
Print "Finished"
Player 0
sub task()
Every 1000/50 {
	if keypress(32) or stimer_counter<0 then exit
		if (3, 10)#have(stimer_counter) then
			Thread stimer_pulse restart
		Else.if (2, 9)#have(stimer_counter) then
			thread stimer_pulse Hold
		End if
	Print Over $(0,10), Timecount div 1000 + 1, stimer_counter
}
end sub
}
MODULE FINALE {διαφυγή Όχι
Συνάρτηση Γενική Όλα {
	Πένα 14, 255
	Ωρα$=""
	Σχέδιο{
	Διάστιχο 15
	Φαρδιά 0
	Γραμματοσειρά "courier new"
	Τύπος 8
	Πένα 15, 255
	Εγγραφο β$=&Όλα()
	Αναφορά β$,9000, Εγγράφου.Παρ(β$)-2 Γραμμή 2
	} Ως Τρία
	cls,0
	Σχέδιο {
		Βάψε 8000, 6000, 1, 2,0
		Τύπος 23
		Πένα 15
		Τύπωσε "Μ2000"
	} Ως β
	Σχέδιο {
		Δρομέας 0,0
		Τύπωσε Πάνω $(6), "Επίδειξη χρήσης σχεδίων"
	} Ως Επικεφαλίδα
	Φόντο 1, 5
	Κράτησε
	γωνία_όλου=0
	μεγ=1
	ολίσθηση=υ.σημεία*1.5
	Ν=2.3
	Για ι=0 Έως 270*3-90 ανά Ν
		Άφησε
		Σχέδιο {
			Θέση 4000, 4000
			Εικόνα  β,4000,,ι,-2000, 1500
			Κύκλος 600
			Κύκλος Γέμισμα 2, 45, 1, 2
			Θέση 12000, 4000
			Εικόνα  β,4000,,ι,2000, 1500
			Κύκλος 600
			Κύκλος Γέμισμα 2, 45, 1, 2
			Θέση 12000, 10000
			Εικόνα  β,4000,,ι,2000, -1500
			Κύκλος 600
			Κύκλος Γέμισμα 2, 45, 1, 2
			Θέση 4000, 10000
			Εικόνα  β,4000,,ι,-2000, -1500
			Κύκλος 600
			Κύκλος Γέμισμα 2, 45, 1, 2
			Θέση 8000, 7000
			Εικόνα  β,4000,,ι
			Κύκλος 600
			Κύκλος Γέμισμα 2, 45, 1, 2
		} Ως Όλα0
		Θέση 3000+ι*25*Ν, ολίσθηση
		Εικόνα Τρία, 10000,,0
		Θέση ι*25*Ν-7000, ολίσθηση+6000
		Εικόνα Τρία, 10000,,0
		Θέση 0,0
		Εικόνα Επικεφαλίδα
		ν=0.8
		χ=Εικόνα.Χ(Όλα0)*ν
		ψ=Εικόνα.Υ(Όλα0)*ν
		Αν Ωρα$<>Γραφή$(Τώρα,"hh:nn:ss") τοτε
		Ωρα$=Γραφή$(Τώρα, "hh:nn:ss")
		Σχέδιο {
			Χρώμα ! {Επιγραφή Ωρα$, "Courier New", 64,0, 2};
			Θέση -4000, -2000
			Βάψε 8000, 4000, 14, 10, 1
			Βήμα -8000, -2600
			Βάψε 8000, 600, 13, 15, 1
			Χρώμα {};
		} ως Ώρα
		τέλος αν
		Σχέδιο χ*1.2,ψ*1.2{
			Θέση χ.σημεία/2, υ.σημεία/2
			Εικόνα Όλα0,χ*ν,,0
			Βήμα 0, 2000
			Εικόνα Ώρα,3000,,0
			Βήμα 0, -4000
			Εικόνα Ώρα,3000,,180
		} Ως Όλα
		Θέση χ.σημεία/2, υ.σημεία/2
		Εικόνα Όλα,,, γωνία_όλου, 3000/μεγ
		Θεση χ.σημεία-6000-ι*πλάτος.σημείου, Εικόνα.ψ(Επικεφαλίδα)
		Σχέδιο χ*1.2,ψ*1.2{
		Εικόνα Ώρα '
		} ως Ώ
		Εικόνα Ώ 
		γωνία_όλου+=2.5*Ν
		μεγ+=.1245*Ν
		ολίσθηση-=45*Ν*3
		Ανανέωση 5000
		Αν Πατημένο(27) τότε Έξοδος Για

	Επόμενο ι
	
	Πένα , 5
	Σχέδιο {
		Πενα 15
		Επιγραφή "Τέλος Παρουσίασης", "Arial Black", 22
	} Ως Μήνυμα
	Πλάτος_Μηνύματος=χ.σημεία*.8/2
	θέση_μηνύματος=χ.σημεία
	Κράτησε
	Για ι=1 Έως 40
		αναμονή 20
		Θέση χ.σημεία/2, υ.σημεία/2
		Πένα , 90+ι*4
		Αφησε
		Φόντο 1,5
		Βήμα (150-300*Τυχαίος)/2, (150-300*Τυχαίος)/2
		Εικόνα Μήνυμα,Πλάτος_Μηνύματος*ι/20,,0
		θέση_μηνύματος/=4
		Ανανέωση 2000
	Επόμενο ι
	Αναμονή 400
	Ανανέωση 5000
	Πένα , 140
	ιι=ι-1
	Για ι=1 Έως 20
		αναμονή 50
		Φόντο 1, 5
		ανανεωση 100
	Επόμενο ι
	Πένα 15, 255
}
Κάλεσε Όλα()
Διαφυγή Ναι
Δείκτη.Μορφή Δείξε
}
MODULE JUKEBOX {fkey clear
' press ctrl+end  or shift F1\\$ c:\users\person\appdata\roaming\m2000\music2l.zip
Binary {
      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
      NGnnci0mp+ntXqilKZUm7d/lVP08Z1Ilbt+lSjoOwzWKzwepMmZ7E650Ux+viEZ8
      V8CvUvWx4WlL47LKJSlNb7dz0+T+oV6ajFvapunjlY5pMl7pnibjlb5woVcfKfcF
      ZgyaJuPkB+B8R10agT1dCWNqmszpLEmT+eItMEfx2YvGH83RNJmXvgD3KdeXTzr1
      wvQp6TIHlgsfVXwapMtcWFt4R4TVLnn6Jev/V/RztNFNsbOVtu9TNOloOlekT4HH
      YVxhGHItpyttcGCazDn1SJU+bE2Kuy22n+EW6wueT/sfY56KRfuUZRWL+l0tZj9t
      9rMrcQuvIOOWGaZ9jpF985UccSvIoH1T8uiFDHmuFZBJeHC08Oa1f+gmaPdBlmY7
      HA+3wscL02z93WsYtuZVOM7iWK8+tmYHHOOh4vNxhowZjsGG8AJMUXx8M/mFJhEe
      N/+vAL6v1OvmmXKf1QXOhAPhSK8+UgY90EzNlLm+ubCR4vN8pvTRL8LKbup9tEez
      JFP66PmZ+thxJpp/opmYKWPUYXCs4tM3U/6fwF1wC2wCP1d88jJlrJgAg0y5mLgq
      5XM+Q9q1b+Eg+CGc4qh/e7BnOOz3sJ9yjvky9HmidzJk3LjbaC3OcoTxjttWnvmh
      mYPmdTjXqq9ztbnODPl/HhvgM3Ctm0r5Zkhf8WyG9BVz4QLF53FL85DF3rfgc5ul
      ybPilGziqo0brTwoa+VX2VvIN48m2GLyLZRXnqVpYZV1rwy9n3www/of13AqnA2f
      VHwWZsg89lL4BFwNJyo+a632cq3VTq43bV9hXRJ7nMPecAvtpycMmzeHOaGE5/ND
      Kskaj5qOvcMRSt9xFU00mglZXKfQle3ub+11QBn6Xr7QDNmfOIb+72H4DX1aV0cf
      1jqjaL94MqPk/vXRHOqh49wtsoquJ+iFvcthx2UXtaeSlnuUPUlBaJLRjKctOhsj
      74152xHXloRZxRGH+tiZ4Up5oclDE038a4d70nFz+qaj8/G6bsjWzIJl4Qy3bcdn
      pvm71zA8vsIyHio+s9GUjrI5J1vfS/JStvwPjB3ZsrZpH1ylzdllS3t+KVvGXv45
      +rqHxByZk8+HkbAx/I/S99yJ5hSanjnyvGwQ/EDxGY7mtQgpvy0eevWxNSPh63AI
      /EjrS3NkfNs1R9YA3Q7LaGM7NOXN2A7WgvGwk3avg2a4uS/Kljb9WLY+d/YxmgPm
      /i9b9h8tg0GO+rckGzrsxdjhxewIpd4sQhOF5jkYCZ81LAyjmF2oV57toolB87Sh
      VX9jvfrItRWHZorFiTBe8XkUTQKah2B5ONBNZT0ZmkQ0rSzWNVR8kq1wfa04/ZGl
      p+dHNNFojsIoN/V8E434RprzuKnUK3f5SBzDrfSEefWRtIei6QKD4QAYqPgMRROA
      ZhT0h+Ohr+LzhKV5wmo3J8NyhXVJ7DIO+8lbaE+fdIdh8X+E6VNCfxZbhedtSt8R
      U0XWF/6dK/NmfeBgbe1OZfoXztcSto+m/c3h3Eof3cS0mWgOmjYgVup+tThlfwqa
      u+I4TFsNc9xUno1amotZ8jzyJGyn+DybJc+za8OdcA999OhYxzPJYv386mL2XZXN
      XmnbbordW8n3C2gmoJmTa9aCFJaVvX8Me6HjPqAz9kyH3QZ7mnKOTyrzC81O4vsm
      Tpcz+exYd7wbe5vDfsv9vTJOtjQbLK66BZ+xGaLpWpHxEazD/dl+x3lrVigaj67p
      Re162EeVc/ydxnMLs0Y5TdZwToGnFZ8BqfLu8C4pXDfkU6dkcy9qn7c99nFHPJYn
      eWz7eWyqUga9E+V+rhcFWws+nMD9g+McQxKKhvlOfFH7AexWXs8h/0/on2bdKXW2
      Izxq1kA5znEMO8th52OXd9hXo8kD5Ry/WZoTFr+6BZ9aliY5ylDmy1s7zvsHdgOH
      3Q+7UqEt8xaNlHPcGS73vp3DZM5paSjpdeTfEuyPHXYw9nqHHeS2lbnjEK69MNkX
      0Q9OCNHfH2r2rF4Mlb2q82AAR/lQpZ/m+8/QPxwqezy7wMYhylq2UHkP4EaOuzkm
      BfKc07EfZxh2tsMeiF1Few+m+T9uaP7jJ++2nOHLHxWfXnx5zqzlLyP/y+uj0u7/
      m2XvzcGeV2jLzzJHvO7h+KSY3UV7Z3Mp4hgi76JfAhcT74NKHs8OkP8PMB7+CQfC
      YKUs3yL818Pkf9WPD5f3pDdU7rHvQtMsQt411wq2h3doa7/95P0KCYGy9isznmtE
      GU/ekUpeo7mQSV8eL+/x+q28d58R2fLc/KtsWZ8SkkNZKT6foblK+PlVqNPRhbT3
      0mD/S0nfUDQpaJ6A74XbfVx9676loanPJfhmuF9j4Q57Qpb1uRRHCEeUQ/8n/yD+
      v1BLAQI/ABQAAAAIAGgZY1G+ZBl/CC0AAPilAAALACQAAAAAAAAAIAAAAAAAAABt
      dXNpYzJsLmVtZgoAIAAAAAAAAQAYANkEzTl+sdYBbKc4q3qz1gEcrwyTerHWAVBL
      BQYAAAAAAQABAF0AAAAxLQAAAAA=
} as music1
declare zip compressor
method zip,"OpenZipBuf", music1
method zip, "ExtractOneToBuffer", "music2l.emf" as musicemf

Set Fast !
if version<10 then exit
If version=10 and revision<5 then exit
global state=0
tongle=True
dir user
user$=dir$
fault=false
playall=false
line$=""
hs$="#"
loop$=""
openloop=false
sortbyname=false
ns$=chrcode$(0x2007)
ns3$=string$(ns$, 3)
v=volume
oldv=v
current=1
tw=0
z=50
p=false
dim a$(), v()
a$=""
wait 200
if exist("lastmusic.dat") and not keypress(32) then
	if filelen("lastmusic.dat")>0 then
		k=buffer("lastmusic.dat")
		try ok {
			dir eval$(k)
		}
		if not ok or error then dir ? "", "Folder for Mp3"
	end if
else
	dir ? "", "Folder for Mp3"
end if
k$=""
escape off
profiler

While not @Lookmp3()
	If Ask("no mp3 found", "Jukebox","*choose folder", "exit")=2  then goto 0 ' terminate module
	dir ? "", "Folder for Mp3"
End While

dir1$=dir$

if not exist("lastmusic.dat") then
		open user$+"lastmusic.dat" for wide output as #f
			print #f, dir1$;
		close #f
end if

100
if valid(Maximize) then
	linespace 30
	if tongle then
		window 8, 12000, 8000;
		Back {Cls 0,0}
	else
		Window 8, Window
		wait 100
		Back {Cls 0,0}
	end if
else
	linespace 30
	window 8, 12000, 8000;
	Back {Cls 0,0}
end if

Bold 0
font "Tahoma"
if valid(Maximize) and not tongle then
	form !  64, 28
else
	form 64, 28
end if
Print $(,4),
Cls 333333, 0
bold 1
double
Print Over ~(15), "Jukebox Non Stop Music - M2000 demo program"
normal
cursor 0,0
Target A,"state++",width-2,2,,,5,""
cursor 0, 2
cls #111133, 2
Volume volume, 50
//if exist(user$+"music.emf") then b=buffer(user$+"music.emf"): cursor 0,3:  move ! : move scale.x*3/4, pos.y: image b, scale.x/4:
cursor 0,3:  move ! : move scale.x*3/4, pos.y: image musicemf, scale.x/4:
cursor 0,2
dir1$=dir$
Items=0
print  $(4), "Folder:"; dir$
Pen 7 {
	print "Random playing or pick next from play list, use space to pause/restart music"
	print "Use R to select next song manual, use - or + to move inside song"
	print "Use A to play in order, or Shift R to play next in order once, use O to sort/unsort list"
	print "Use arrows to change volume and balance, B to change specific song volume"
	print "Use numbers to insert a song number to play list and press enter or backspace "
	Print "Use [ and ] for loop, press U unload hiden part of loop. Press [+ Enter+ ] for current song in loop"	
	Print "Use F to change folder. You can move the window, and for maximize/restore F10, press Esc to exit"
	Print
}
zz=row
cls 0, row
ChangeFolder()
mx=0
my=0
if valid(Maximize) then  goto jump1
again:
GetRandom()
disp()
wait 3000
jump1:
while not keypress(27) and not fault
scan 0.1
if state>1 then
	Motion.W Motion.XW-mx+Mouse.X,Motion.YW-my+MOUSE.Y
	if mouse=0 then
	Mouse.icon 1
	state<=0
	end if
else.if state=1 then
	Mouse.icon 5
	mx=Mouse.X:my=Mouse.Y
	state++
end if
for i=48 to 57: if keypress(i) then line$+=chr$(i): next i
for i=96 to 105: if keypress(i) then line$+=chr$(i-48): next i
if keypress(66) then
	if v(current)<>-1 then v(current)=-1 : v=oldv  else oldv=v: v(current)=volume
	setvol()
end if
if keypress(8) then if len(line$)>0 then line$=left$(line$, len(line$)-1)
if keypress(86) then
	if keypress(162) or keypress(163) then
		cc$=clipboard$:  cc$=filter$(cc$, filter$(cc$,"0123456789#[]"))  :if cc$<>"" then line$+=cc$
	end if
end if
if keypress(219) then line$+="["
if keypress(221) then line$+="]"
if keypress(85) then openloop=false : line$=loop$:loop$="" : if line$<>"" then if left$(line$,1)<>"[" then line$="["+line$
if keypress(79) Then sortbyname~: showsort()
if keypress(65) then playall~
if keypress(13) then line$+=hs$
if keypress(38) then up(&v) : setvol()
if keypress(37) then up(&z) :setvol()
if keypress(40) then down(&v):setvol()
if keypress(39) then down(&z):setvol()
if keypress(70)  then GetFolder() : if fault then goto 0
if keypress(121) then Maximize=1: tongle~: goto 100
if keypress(107) or keypress(187) then
if music.counter<duration-20 then music to music.counter+20 else 1000
end if
if keypress(109) or keypress(189) then
if music.counter>20 then music to music.counter-20 else 1000
end if
if keypress(82) then GetRandom()
if keypress(32) then
	if p then music restart : wait 300 else music pause : wait 300: profiler
	p~
end if
wait 100
disp()
if not p then if not music then exit
end while

if fault or  keypress(27) then music : print : dir user : goto normalexit
1000 p=false
if music then {
	music to 0
	music restart
} else music a$
goto again
normalexit:
if module(info) then keyboard "info"+chr$(13)
sub setvol()
	volume   v, z
	if v(current)<>-1 then v(current)=v else oldv=v
	if p then p=false : music restart
end sub
sub disp()
	if not music and not p then
		cursor 0, zz
		Print over "No file found"
		Print
		Print over " time:";time$(now)
	else
		info()
		cursor 0, zz+1
		if p  then
			Print over "Pause ";timecount div 1000;" sec, time:";time$(now)
		else
			Print Over if$(sortbyname->"S", "Uns")+"orted List [O], "+if$(v(current)=-1->"volume [B]", "song volume [B]: ");volume;"%, balance: ";str$(z-50);" time:";time$(now)  ';" ";oldv
		end if
	end if
	cursor 0,zz+2
	Print Over  "Pick ";if$(playall->"Next", "Random");" or from list: ";~(#ee6622);if$(line$=""->if$(openloop->"Pushed to Open Loop, press ] to close it","Empty"), line$)
end sub
sub up(&x)
	x=max.data(min.data(100, x+1), 0)
end sub
sub down(&x)
	x=max.data(min.data(100, x-1), 0)
end sub
sub info()
cursor 0, zz
if current>=1 and current<=items then
	print over "listen now: [";str$(current,"");"]- ";a$(current);".mp3, at position:"; @Rep$(music.counter);" sec,  total duration:"; @Rep$(duration);" sec"
else
	print over "Problem"
end if
end sub
function Rep$(n)
	local i=int(n)
	local k=int(frac(n)*1000)
	=right$(ns3$+str$(i,""),4)+":"+str$(k,"000")
end function
sub GetFolder()
	local esc1=false, f
	after 50 {
		dir ? "", "Folder for Mp3"
		esc1=true 
	}
	main.task 300 {
		disp()
		if  esc1 then exit
		if not music then GetRandom()
	}
	if music and dir1$=dir$ then exit sub
	if @Lookmp3()  then
		ChangeFolder()
		line$=""
		loop$=""
		openloop=false
		open user$+"lastmusic.dat" for wide output as #f
			print #f, dir1$;
		close #f
		if not fault then GetRandom()
	end if
end sub
sub showsort()
	if fault then exit sub
	local c$=a$(current)
	if @Lookmp3()  then
		local i, k=queue
		for i=1 to items
			append k, a$(i):=v(i)
		next i
		ChangeFolder()
		line$=""
		loop$=""
		openloop=false
		local p=a$()
		current=p#pos(c$)+1
		for i=1 to items
			v(i)=k(a$(i))
		next i
	end if
end sub
function Lookmp3()
	menu
	if sortbyname then files ! + "mp3" else files + "mp3"
	=menuitems<>0
end function
Sub ChangeFolder()
	dir1$=dir$
	cursor 0,2
	print over ~(Pen, #111133, #111133 ), "Folder:"; dir1$
	cls #111111, zz+3
	a$()=menu$()
	items= len(a$())
	dim a$(1 to items), v(1 to items)=-1
	openloop=false
	loop$=""
	local i, m$,  k
	Pen #444400 {
		for i=1 to items
			m$=str$(i,"")+":"
			k=size.X( m$+a$(i), fontname$, mode)
			move !
			if pos.x+k>scale.x  and  not k>scale.x then print
			print ~(7); m$; ~(#444400);a$(i),
		next i	
	}
end sub
Sub GetRandom()
	if fault  or items=0 then exit sub
	v=oldv
	p=false
	local check=true
	while left$(line$,1)="]"
		line$=mid$(line$,2)
		if loop$<>"" then line$=loop$+"]" : loop$=""
		openloop=false
	end while
	While left$(line$,1)="[" :  loop$="[": openloop=true: line$=mid$(line$,2) :End While
	if len(line$)>0  then
		if instr(line$, hs$)>0 then
			local m
			local c=val(line$,"int", m)
			if m=-1 then m=1 : c=current
			current=c
			 line$=mid$(line$, m+1)
			check=current<1 or current>items
		end if
	else.if keypress(16) or keypress(161) or playall then
		if current<items then current++  else current=1
		check=false
	end if
	if check then current=random(1, items)
	if  exist(dir1$+a$(current)+".mp3") then
		a$=dir1$+a$(current)+".mp3": music a$
	else
		 music : fault=true: exit sub
	end if
	if movie.error$<>""  or fault = true then
		cls
		pen 15 {
			print movie.error$
			Print fault, items
		}
		fault=false
		a$(current)=a$(items) : items--
		if items>0 then dim a$(1 to items), v(1 to Items)=-1 : GetRandom() else fault=true
	else
		if v(current)<>-1 then v=v(current) else v=oldv
		if openloop then loop$+=str$(current,"")+"#"
		if line$="]" and openloop then line$=loop$+"]" :loop$=""
		setvol()
	end if
End sub
}
MODULE ZIPWORK {Cls, 0
Declare zip compressor
Print type$(zip)
a$={
	hello there
	Γιώργος Καρράς
	and there
}
Dim c$(10)
Document c$(3)
c$(3)=a$
// new variation for save.doc
// writting as utf8 no bom (2 with bom)
//with bom: 12 using unix linefeed, 22 using macintosh linefeed
// -12, -22 without bom
// use b$=c$(3) to get utf-16LE without BOM
// save.doc c$(3) as b$  ' for utf-16le with bom
// save.doc c$(3), -7 as b$  ' for utf-16le without bom ' -17, -26 (line feed unix, macintosh)

Save.doc c$(3), -2 as b$
Print len(b$)*2, len(A$)*2
Method zip, "AddFromMemory",b$, "simple.txt" as ok
Save.doc c$(3), 2 as b$
Print len(b$)*2, len(A$)*2
Method zip, "AddFromMemory",b$, "simpleBOM.txt" as ok
Save.doc c$(3), -12 as b$ ' unix no BOM
Print len(b$)*2, len(A$)*2
Method zip, "AddFromMemory",b$, "simpleUnix.txt" as ok
Drawing {
	Print "This is a drawing"
} as Dr
Method zip, "AddFromMemory", DR, "mydraw.emf" as ok
Method zip, "CreateZipFile", dir$+"simple.zip"

Method zip, "openZip", dir$+"simple.zip"
With Zip, "FileCount" as Zip.Count
With Zip,  "FileInfo" as M()
Print Zip.Count
dim buf$(Zip.Count)
for i=0 to Zip.Count-1
	Pen 15 {Print "File:", M(i)#val$(0), M(i)#val(3),  M(i)#val(4)}
	Method zip, "ExtractOneToBuffer", M(i)#val$(0) as Buf
	' We can check for bom
	if  M(i)#val$(0)="simple.txt" then
		Buf$(i)=String$(Eval$(Buf) as UTF8Dec)   ' this include bom if included...
		report Buf$(i)
	else.if  M(i)#val$(0)="simpleBOM.txt" then
		Hex binary.and(Eval(buf, 0 as long), 0xFFFFFF)  ' this is the three byte BOM ' cast to long
		Hex Eval(buf, 1 as Integer), Eval(buf, 0)  ' low byte right   ' cast to integer
		Buf$(i)=String$(Eval$(Buf,3) as UTF8Dec)
		// buffer buf has byte as item but we can cast to integer (unsigned) or long (unsigned), as we see above
		// addresses are in bytes. so we know that data starts from 4th byte at offset 3 (buf base+3)
		// original base for buffer is buf(0), this is also the handler for the block allocated from memory heap
		Report Buf$(i)
	else.if  M(i)#val$(0)="simpleUnix.txt" then
		document Buf$(i)
		// we can check if we have UTF8 without reading BOM
		Method Buf$(i), "ContainsUTF8", Eval$(Buf) as yes
		if yes then
		// using textDoc, we get paragraphs, dropping any type of line feed.
		With Buf$(i), "textDoc", String$(Eval$(Buf) as UTF8Dec)
		Report Buf$(i)
		end if
	else.if M(i)#val$(0)="mydraw.emf" then
		move 6000,6000
		Image buf, 12000,,45
	end if
Next
// make a new folder and extract all  files
Method zip, "ExtractToPath", dir$+"alfa\"
// open explorer
win dir$+"alfa\"


declare zip nothing

}
MODULE XML {form 80, 48
declare xml xmlData
With xml, "LastChild" as Child
with xml, "xml" as doc$, "beautify" as beautify
with xml, "childcount" as xml.count, "anychild" as xml.child()

print type$(xml)="XmlMono"  ' true
method xml, "PrepareNodeSimple", "xml" as ProcessInstructions
// nodes are not xmlmono types
print type$(ProcessInstructions)="XmlNode"

method xml, "PlaceAttributeToNode", ProcessInstructions, "version", "1.0"
method xml, "PlaceAttributeToNode", ProcessInstructions, "encoding", "UTF16"

// the first node we build used for the processinstructions
method xml, "PlaceProcessingInstructions", ProcessInstructions

method xml, "PrepareNode", "names" as Node
method xml, "InsertNode", Node
// so now our xml has a name "names"

// now we make a new one, pace an attribute and place it as a child
method xml, "PrepareNode", "element" as Node1
method xml, "PlaceAttributeToNode", Node1, "Id", "69"
method xml, "AppendChild", Node1
// we can get the XmlMono from that list child

Print type$(Child)="XmlMono"
// our child hasn't a node, so we have to make one and then insert to it
method xml, "PrepareNode", "codename","VB6" as Node
method Child, "AppendChild", Node
// we can append a child to this child
method xml, "PrepareNode", "sold","2" as Node1
method Child, "AppendChild", Node1     ' see we call AppendChild to Child object

with child, "tag" as child.tag$, "attr" as child.attr$(), "text" as child.text$, "xml" as child.doc$, "anychild" as child.child()
with child,"childcount" as child.count
Print child.tag$
Print child.attr$("Id")
Print child.text$
Print child.doc$
declare anychild xmldata
with anychild, "text" as anychild.text$, "tag" as anychild.tag$
	for i=0 to child.count-1
		anychild=child.child(i)
		Print anychild.tag$;"=";anychild.text$
	next


// we repeat the element here

method xml, "PrepareNode", "element" as Node1
method xml, "PlaceAttributeToNode", Node1, "Id", "70"
// we can place additional attribudes
method xml, "PlaceAttributeToNode", Node1, "Nobel", "yes"
method xml, "AppendChild", Node1
// we can get the XmlMono from that list child

Print type$(Child)="XmlMono"
// our child hasn't a node, so we have to make one and then insert to it
method xml, "PrepareNode", "codename","C++" as Node
method Child, "AppendChild", Node
// we can append a child to this child
method xml, "PrepareNode", "sold","3" as Node1
method Child, "AppendChild", Node1     ' see we call AppendChild to Child object

	for i=0 to child.count-1
		anychild=child.child(i)
		Print anychild.tag$;"=";anychild.text$
	next



// we repeat the element here
method xml, "PrepareNode", "element" as Node1
method xml, "PlaceAttributeToNode", Node1, "Id", "71"
method xml, "AppendChild", Node1
// we can get the XmlMono from that list child
Print type$(Child)="XmlMono"
// our child hasn't a node, so we have to make one and then insert to it
method xml, "PrepareNode", "codename","M2000" as Node
method Child, "AppendChild", Node
// we can append a child to this child
method xml, "PrepareNode", "sold","10" as Node1
method Child, "AppendChild", Node1     ' see we call AppendChild to Child object


	for i=0 to child.count-1
		anychild=child.child(i)
		Print anychild.tag$;"=";anychild.text$
	next

// part2
// we make same new xmlData object
declare Child1 xmlData

declare nChild xmlData
With nChild, "Attr" as nChild.Attr$()

for i=0 to xml.count-1
	nchild=xml.child(i)
	Print nChild.Attr$("Id")
next

function getnextchild(xml, &xmlmono) {
	method xml, "EndOffChilds", &xmlmono as ok
	= ok
}



// Here we get the result from LastChild, if we use AS and not Set we get the property
// but here we need the original pointer
// so when we change the pointer the connected propeties made them with With statement,
// these follows the object ponter.
// (when we use AS we connect the properties with a property of another object, so when we change that object, the other properties follow)
// (you see that in the For Next blocks after each element append to xml)
With xml, "LastChild" set Child1
with child1, "tag" as child1.tag$, "attr" as child1.attr$(), "text" as child1.text$, "xml" as child1.doc$, "anychild" as child1.child()
declare inner xmlData
with inner, "tag" as inner.tag$, "text" as inner.text$


method xml, "ResetChildPointer"
// here we pass a xmlData object and we get another
While getnextchild(xml, &child1)
	method child1, "ResetChildPointer"
	Print child1.attr$("Id"), child1.tag$, 
	While getnextchild(child1, &inner)
	Print inner.tag$, inner.text$
	end while
end While

''''''''''''''''''''''aaaaa
Pen 15 {Print "Using negative beautify, we set identation to 0 for first level"}

beautify=-4
Print #-2, doc$
Print "Press a key"
Push key$: Drop
cls
Pen 15 {Print "Using positive beautify, we set identation same for all levels"}
beautify=4
Print #-2, doc$
declare L xmlData
with L, "xml" as L.doc$,"childcount" as childrens
L.doc$=doc$
Pen 15 {Print "By default beautify=0 so we get all text in a row"}
Report 3, L.doc$
Print childrens=3
child1=xml.child(2)  ' 3rd
child1=child.child(1) ' 2nd

Print child1.doc$
child1.text$=str$(val( child.text$)+1, "")
Print child1.doc$
method xml, "GetListByTag", "codename" as list_in_a_stack_object
Print "Found: ";Len(list_in_a_stack_object)
For i=1 to Len(list_in_a_stack_object)
	child1=stackitem(list_in_a_stack_object, i)
	Print "codename:";child1.text$
next
// another way
one=each(list_in_a_stack_object)
while one
	child1=stackitem(one)
	Print "codename:"; child1.text$
end while

method xml, "GetListByTag", "element" as list_in_a_stack_object
one=each(list_in_a_stack_object)
with child1, "textFromChild" as child1.child.text$()
while one
	child1=stackitem(one)
	nobel$=""
	Try{nobel$=child.attr$("Nobel")}
	Print "Id="+child1.attr$("Id") ',  if$(nobel$=""-> "","Nobel="+nobel$)
	Print "codename:"; child1.child.text$("codename"), "sold: ";child1.child.text$("sold")
end while

declare xml nothing
}
MODULE XML2 {pen 14
Cls 5,0
Print $(4),
declare databank xmldata
with databank, "xml" as doc$, "beautify" as beautify, "status" as status$
doc$={<?xml?>
<table id="1">
<schema><schema:fields row="element">2</schema:fields>
<schema:fieldname type="s">Country</schema:fieldname>
<schema:fieldname  type="s">Continent</schema:fieldname>
</schema><element><Country   >Greece</Country><Continent>Europe</Continent>
</element><element><Country>Germany</Country><Continent>Europe</Continent>
</element><element><Country>Australia</Country><Continent>Australia</Continent>
</element><element><Country>India</Country><Continent>Asia</Continent>
</element>
</table>
}

beautify=-4
Report 3, doc$
With Databank, "Attr" as Attr$()
Print status$
Print

// Show structure
fieldnames=list
rowlist=list
Method databank, "GetListByTag", "schema:fields", 1 as Result
If len(Result)=1 then
	Stack Result {Read fieldsNo}
	With fieldsNo, "Text" as No$, "Attr" as fieldsno.tag$()
	elementname$=fieldsno.tag$("row")
	Print "There are two fields: "; val(No$)
	Print "Each row has this name: ";elementname$
	Print "Scanning the schema:fieldname"
	Method databank, "GetListByTag", "schema:fieldname" as Result
	declare m xmldata
	oldvalue=m
	with m, "text" as m.value$, "attr" as m.attr$()
	k=each(Result)
	while k
		m=stackitem(k)
		Print k^+1,m.value$, "Type: ";m.attr$("type")
		append fieldnames, m.value$:=m.attr$("type")
	end while
       Print "Press a key"; : Push Key$ : Drop: Print
	// now we have the fields in a list, where key is the name of field, and value is the type
	pen 11 {Print "Scanning the fieldnames list, produced from previous scanning"}
	z=each(fieldnames)
	while z
		Print z^+1, eval$(z!), eval$(z)
	end while
	pen 11 {Print "Scanning all rows with tag: ";elementname$}
	Method databank, "GetListByTag", elementname$ as Result
	Print "Found ";Len(Result);" records or rows"
	With m, "textFromChild" as child.value$(), "xml" as m.doc$
	k=each(Result)
	z=each(fieldnames)
	while z
		pen 13 {Print eval$(z!),}
	end while
	Print
	while k
		m=stackitem(k)
		z=each(fieldnames)
		while z
			if z^=0 then append rowlist, child.value$(eval$(z!)):=m
			if eval$(z)="s" then Print child.value$(eval$(z!)), 
		end while
		Print
	end while
	Print "Scanning sorted rows  (descening on country) from rowlist, prepared before"
		sort descending rowlist
		swap m, oldvalue
		k=each(rowlist)
		while k
			m=eval(rowlist)
			z=each(fieldnames)
			while z
				if eval$(z)="s" then Print child.value$(eval$(z!)), 
			end while
			Print
		end while
end if

with databank, "lastchild" as last, "firstchild" as first, "nextchild" as nextchild
pen 15  {Print "The xml not alter the children - yet"}
pen 13 {
	beautify=-4
	Report 3, doc$
}

pen 11 {
	Report "Now we rearrange the children. We remove all children and add them, the schema and the the elements from the list.  We handle the pointers, the object's pointers. So when we remove all childrens the actual xmlData (children) kept by pointers in other places."
}
Print
Method databank, "GetListByTag", "schema", 1 as schema_stack
Method databank, "RemoveChildren"
stack schema_stack {Read the_schema}
Method databank, "AppendChildObj", the_schema
k=each(rowlist)
while k
	m=eval(rowlist)
	Method databank, "AppendChildObj", m
End While
beautify=-4
Report 3, doc$

with databank, "lastchild" as last, "firstchild" as first, "nextchild" as nextchild
pen 11 {
	Report "Now we remove specific childs, we remove 2 childs from third, we start from first child, then we move two times to nextchild and perform two times RemoveChild method. Also we can change the value of id Attribute of table"
}
Attr$("id")="2"
Print "New attribute value for id:";Attr$("id")

dd=first
//with dd, "xml" as dd.text$
dd=nextchild
dd=nextchild
method databank, "RemoveChild"
method databank, "RemoveChild"
beautify=-4
Report 3, doc$
Print status$
}
MODULE JSON1 {function KeyList (json) {
	flush
	with json, "index" as json.index, "count" as json.count ,"KeyToStringPos" as keyName$()
	if json.count=0 then =(,): exit
	for i=0 to json.count-1:data keyname$(i):next
	=array([])
}
declare Json JsonObject
json$={
{
    "description":"A person",
    "type":"object",
    "properties":
        {
            "name":
                {
                    "type":"string"
                },
            "age":
                {
                    "type":"integer",
                    "maximum":125
                }
        }
}
}
method json, "parser", json$ as json
with json, "json" as json.format$(), "item" as json(), "item" as json$()
with json, "itempath" as json.path(), "itempath" as json.path$()

Report json.format$(4)
Print json$("description")
Print json$("type")
Print json.path$("properties.name.type")
Print json.path$("properties|age|type", "|")  ' define different seperator
Print json.path("properties.age.maximum")
method json, "assignpath", "properties.age.maximum", 80
Report json.format$(4)
Print json.format$(0)

list1=Keylist(json.path("properties"))
Print format$("Found {0} properties:", len(list1))
nl$={
}+"	- "
Print #-2,  "	- "+list1#sort()#str$(nl$)
// New in revision 2 version 11 deletekey
Report json.format$(0)
//Method json, "deletekey", "type"
Method json, "deletekey", "properties"
Report json.format$(0)
}
MODULE MACHINECODE {\\ THIS RUN WITH OR WITHOUT DEP (Data Execution Prevention) ON FOR ALL PROGRAMS.
\\ we make a buffer to use for DATA
Buffer BinaryData as Long*10
Return BinaryData, 1:=500
Buffer code alfa as byte*1024
\\ use https://defuse.ca/online-x86-assembler.htm
\\ to find opcodes
Pc=0
\\ x86 Machine Code
OpLong(0xb8, 5100) ' mov eax, 5100    ' 5100 to eax
OpByteByte(0x83, 0xC0 ,5) ' add  eax,0x5   ' add 5 to eax
OpByteLong(0x3,0x5, BinaryData(1)) 'add eax, [BinaryData(1)]  ' add eax 500 from second long on BinaryData
OpLong(0xa3, BinaryData(0)) ' mov [BinaryData(0)], eax
rem : OpByte(0x31, 0xC0) ' now eax=0  ' without this we get 5605 in M
Ret() ' return
\\ end of code
Try Ok {
      Execute Code alfa, 0
}
M=Uint(Error)
Hex M
Print M
Print Error, ok
Print Eval(BinaryData, 0) ' 5605

Sub Ret()
      Return alfa, pc:=0xC3
      pc++
End Sub
Sub OpByteByte()
      Return alfa, pc:=number, pc+1:=number, pc+2:=number
      pc+=3
End Sub
Sub OpByte()
      Return alfa, pc:=number, pc+1:=number
      pc+=2
End Sub
Sub OpLong()
      Return alfa, pc:=number, pc+1:=number as long
      pc+=5
End Sub
Sub OpByteLong()
      Return alfa, pc:=number, pc+1:=number, pc+2:=number as Long
      pc+=6
End Sub
}
MODULE DOWNANY {FileFromDrive$="http://drive.google.com/uc?export=download&id="
//Const ERROR_SUCCESS = 0x0&
Const BINDF_GETNEWESTVERSION = 0x10&
//Const INTERNET_FLAG_RELOAD = 0x80000000&
//Const FILE_ATTRIBUTE_TEMPORARY = 0x100&
Print "Download M2000paper.pdf"
if internet then
	If exist("M2000paper.pdf") then Try {dos "del "+quote$(dir$+"M2000paper.pdf");} : Wait 200
	Declare URLDownloadToFile lib "urlmon.URLDownloadToFileW" {long pCaller, szUrl$, sxFilename$, long dwReserved, long callback}
	dir user
	if URLDownloadToFile(0,FileFromDrive$+"1pHBjLVeaGkyMhyyfvXyvh42cJ3njY7wa", dir$+"M2000paper.pdf",BINDF_GETNEWESTVERSION,0)==0 then
		Print "Ok"
	Else
		Print "Try Again"
	end if
else
	Print "Not Internet, Try Again"
end if


}
MODULE FUNNY {Clear \\ clear static too
FKey 1, "Cls, 0 : Edit "+module$
FKey 5, module$
Font "Verdana"
Form 70,35
Cls 3
Pen 14
Double
Report 2, "Funny Loops.."
Normal
Cls 5,2
old_italic=Italic
Italic 1
Pen 15 {Report 1, {Look how we can mix proportional font with same font  as monospace font} }
Italic old_italic ' restore italic to old value
\\ iterator
ForEach=lambda (x, x1) -> {
      st=1 \\ this is optional
      read ? st
      =lambda x ,x1, st (&n) -> {
            =true
            if x<=x1 then {
                  n=x : x+=st
            }  else =false
      }
}
\\ execution of a lambda function by iterator
\\ get more parameters, from stack (using call statement)
Lcode=lambda i (&m) -> {
\\ choose to use  a lambda by value
\\ or any function by reference, using islet (is letter)
\\ check head of stack if is string (function references in M2000 are strings)
      If islet then { read &cd() } else read cd
      =false
      if m(&i) then {
            Try ok {
                  call cd(i)
            }
            if not ok then exit
            =true
       }
}
Z=Foreach(60,80,2)
CodeW=lambda (i) -> {
      Let limit=1 \\ this is optional
      Read ? limit
      Print i, limit
      if i>limit then =i ' error
}
\\ print prints with transparent background for fonts
\\ Print Over erase a line before, and set all line one field (temporary)
Print Over "Try iterate code using an iterator and  a secondary limit, if limit break then recalibrate iteration using other data, here other limit"
\ \ but Print Over leave one line, so we can fill this line with Print Unter (also change line)
Print Under
\\ Print Over, Print Part and Print Under can be used for making columns with diffrent width
\\ Here is the first loop (empty block)
While Lcode(&z, CodeW,75) {}
n=error
If n>75 then {
      Print "out of scope...recalibrate"
      while Lcode(&z, CodeW,100 ) {}
}
Print Under
Print Over "Example of step by step execution"
Print Under
Z=Foreach(10,15)
n=0
\\ Pen { } change temporary pen to black
\\ using loop we mark block for loop at the end of block execution
\\ Calling a function with Call return error if function return non zero value.
\\ so here we get Error and if is not zero then we do next loop
Pen 0 {
     Print Over ~(0,7,14),$(0,8), "Step"+str$( n+1),@(tab),
     \\ also here we have an empty block
      while Lcode(&z, CodeW,n) {}
      n=error
      if n<>0 then loop
}
\\ here is the lambda with static variable
\\ static variables are per execution object (attached to parent object), no per function (as code)
\\ so if this lambda ...moved to another execution object, passing as parameter
\\ then static i get 1 and start new count.
CodeW=lambda -> {
      Static i=1
      Print Over ~(14,8),$(4,8),"just run, no need iteration number ", i
      i++
}
Z=Foreach(1,5)
Print Over "Simple iteration , using static counter inside code"
\\ Here we have a repeat {} until block
Repeat {Print Under} Until Not Lcode(&Z,Codew)
Print Over "Iteration using group's function, passing by reference, altering group member counter"
Print Under \\ print underline and change line too
Group Alfa {
      counter
     Function M {
            .counter++
      }
}
Z=Foreach(200,499)
y=row
\\ we use a$ for image holder
a$=""
Mouse.icon Hide
Print $("0.00%"),
\\ and here is the "game"
While Lcode(&Z, &Alfa.M()) {
    FeedBack(y, Alfa.counter/300, "  press space to exit early")
    Move 0, 0
    copy scale.x,scale.y to a$
    Move mouse.x, mouse.y
    Sprite A$,, Alfa.counter,40,80 \\ leaving 2nd parameter, to automatic  match the paper color for 100% transparent
    If keypress(32) then exit
    Refresh 5000 \\ rfefresh now and reset counter for next refresh  5 sec later (never happen)
    Sprite Sprite$ \\ when Sprite write, altered background saved to Sprite$, so now sprite erased
    \\ Hold take all screen, and Release restore screen to that we take with Hold. But here we use Sprite Sprite (we have only one)
    Wait 5+Random(1,11-Alfa.counter/30)*2
}
Print
Print $(""),
Print "Counter:";Alfa.counter


Mouse.Icon Show
Sub FeedBack(y, val, msg$)
     local N
     Pen 15 {
          Cursor 0, y
          N=round(val*100,0)
          Print Over $(0,8), val, @(tab),$(4), ~(7);string$("[]",50);msg$;@(tab), ~(11),string$("[]", N div 2)+string$("[", N mod 2);
    }
End Sub
}
MODULE RECSOUND {Volume 100
soundrec new dir$+"alfa.wav"
print over $(1), string$("*", soundrec.level)
soundrec volume 100
profiler
Print "Start Recording"
soundrec insert
do
	print over $(1), string$("|", soundrec.level)
	Print Part  $(3, width), timecount div 1000
	refresh 100
	if keypress(32) then exit
	wait 1
always
m=timecount
soundrec stop
print over  
Print "record stop - now play"
profiler
soundrec test
do
	wait 1
until timecount>m
Print "record play stop"
soundrec save
Print "record saved"
soundrec end
}
MODULE REV34VER10 {module testA {
	Print @FunctionReturnGroup()=>GroupMember
	Print @FunctionReturnGroup()=>Name()=>v$()="Ok"
	Print @FunctionReturnGroup()=>Name()=>val()=1234
	Print @FunctionReturnGroup()=>Name()=>prop=500
	Print @FunctionReturnGroup()=>Name()=>strProp$="yes"
	Print @FunctionReturnGroup()=>Name()=>strProp.key=1000
	function FunctionReturnGroup()
		local Z=random(1, 500)
		local group a {
			Property GroupMember {value}=Z
			Function Name {
				GROUP alfa {
					function v$ {="Ok"}
					function val {=1234}
					property prop {value}=500
					property strProp$ {value}="yes"
					group strProp {
						key=1000
					}
				}
				=alfa
			}
		}
		=a
	end function
}
module testB {
	function FunctionReturnGroup() {
		Z=random(1, 500)
		group a {
			Property GroupMember {value}=Z
			Function Name {
				GROUP alfa {
					function v$ {="Ok"}
					function val {=1234}
					property prop {value}=500
					property strProp$ {value}="yes"
					group strProp {
						key=1000
					}
				}
				=alfa
			}
		}
		=a
	}
	Print FunctionReturnGroup()=>GroupMember
	Print FunctionReturnGroup()=>Name()=>v$()="Ok"
	Print FunctionReturnGroup()=>Name()=>val()=1234
	Print FunctionReturnGroup()=>Name()=>prop=500
	Print FunctionReturnGroup()=>Name()=>strProp$="yes"
	Print FunctionReturnGroup()=>Name()=>strProp.key=1000
}
module testC {
	function FunctionReturnGroup() {
		Z=random(1, 500)
		group a {
			Property GroupMember {value}=Z
			Function Name {
				GROUP alfa {
					function v$ {="Ok"}
					function val {=1234}
					property prop {value}=500
					property strProp$ {value}="yes"
					group strProp {
						key=1000
					}
				}
				=alfa
			}
		}
		=a
	}
	Print FunctionReturnGroup()=>GroupMember
	KK=FunctionReturnGroup()
	for kk {
		 Print .Name()=>v$()="Ok"
		 Print .Name()=>val()=1234
		 Print .Name()=>prop=500
		 Print .Name()=>strProp$="yes"
		 Print .Name()=>strProp.key=1000
	}
	LL=FunctionReturnGroup()=>Name()
	for LL {
		 Print .v$()="Ok"
		 Print .val()=1234
		 Print .prop=500
		 Print .strProp$="yes"
		 Print .strProp.key=1000
	}
}
module testD {
	Print @FunctionReturnGroup()=>GroupMember
	KK=@FunctionReturnGroup()
	for kk {
		 Print .Name()=>v$()="Ok"
		 Print .Name()=>val()=1234
		 Print .Name()=>prop=500
		 Print .Name()=>strProp$="yes"
		 Print .Name()=>strProp.key=1000
	}
	LL=@FunctionReturnGroup()=>Name()
	for LL {
		 Print .v$()="Ok"
		 Print .val()=1234
		 Print .prop=500
		 Print .strProp$="yes"
		 Print .strProp.key=1000
	}
	function FunctionReturnGroup()
		local Z=random(1, 500)
		local group a {
			Property GroupMember {value}=Z
			Function Name {
				GROUP alfa {
					function v$ {="Ok"}
					function val {=1234}
					property prop {value}=500
					property strProp$ {value}="yes"
					group strProp {
						key=1000
					}
				}
				=alfa
			}
		}
		=a
	end function
	
}
testA
testB
testC
testD
}
MODULE REGISTRY {declare CR WINDOWS.REGISTRY
const    HKEY_CLASSES_ROOT = 0x80000000&
const   HKEY_CURRENT_USER = 0x80000001&
const    HKEY_LOCAL_MACHINE = 0x80000002&
const    HKEY_USERS = 0x80000003&
Enum ERegistryValueTypes {
    REG_NONE = 0&					'No value type
    REG_SZ =1&						'Unicode nul terminated string
    REG_EXPAND_SZ = 2&				'Unicode nul terminated string w/environment var
    REG_BINARY = 3& 					'Free form binary
    REG_DWORD = 4&					'32-bit number
    REG_DWORD_LITTLE_ENDIAN = 4&		'32-bit number (same as REG_DWORD)
    REG_DWORD_BIG_ENDIAN = 5&			'32-bit number
    REG_LINK = 6&					'Symbolic Link (unicode)
    REG_MULTI_SZ = 7&					'Multiple Unicode strings
    REG_RESOURCE_LIST = 8&				'Resource list in the resource map
    REG_FULL_RESOURCE_DESCRIPTOR = 9&	'Resource list in the hardware description
    REG_RESOURCE_REQUIREMENTS_LIST = 10&
}
// looking for the default font in M2000
// from console SETTINGS open the dialog for default values.
with CR, "ClassKey",  HKEY_CURRENT_USER 
with CR, "SectionKey", "Software\m2000v5\"
with CR, "ValueType",REG_SZ , "ValueKey", "FONT", "KeyExists" as CR.Exist, "Value" as Cr.Ret$
If  CR.Exist then Print Cr.Ret$

with CR, "ClassKey",  HKEY_LOCAL_MACHINE
with CR, "SectionKey", "SYSTEM\ControlSet001\Control\Keyboard Layout\DosKeybCodes"
with CR, "ValueType", REG_SZ, "ValueKey" as valueName$, "KeyExists" as cr.exist, "Value" as cr.ret$
dim a$()
Long many=0  ' or many=0&
Method CR, "EnumerateValues", &a$(), &many as ok
document export$
for i=0 to many-1
	with CR, "SectionKey", "SYSTEM\ControlSet001\Control\Keyboard Layouts\"+a$(i)
	valueName$="Layout Text"
	export$=a$(i)+" "+If$(cr.exist->cr.ret$,"not exist")+{
	}
	REM Print a$(i), cr.ret$
next
if  height-row<11  then
cls, -11
else
cls, -height+row
end if
Print "Keyboard Codes (press space bar)"
cls, -height+row
Report export$
Print {Keyboard load "00000408"   ' load greek keyboard}
Scroll Split 0
declare CR nothing  ' optional, CR erased at the exit of this module
}
MODULE HOOKEVENT {REM { This is an old program from March 2016;

Using a Hook Event in a form we can get messages before sending them. There are some messages which bypass this system, like the one to close the form, or for validating input in textboxes. These messages need to get answer (if we implement them).

We send mesages to thread's stack so we can delay the execution. Also we can observe messages. We use Part { } as Variable, to bypass code if another Part which use the same Variable executed the same time. The Part structure automatic change the value of control Variable.

Look  lazy$(&CallBack()) at the line

	Event Hello New lazy$(&CallBack())
	
We place a new function in Event Hello, which is a list of functions. But the new function passed from a Lazy$() function which make it like a code in the module. So the code on this function has the same lexical Scope as the module.

We can use any function as code in "parent" module, if we call using Call Local. Version 10 has also static functions which are in same scope as the module, but these functions can't be passed by reference. Acctually a &CallBack() is a string containing the code of the function in a block. Check this:
	
	? function("{read x:=x**2}",2)=4
	
The window manager exclude some messages from execution, if there is no service function, using a black list. The black list erased each time a user form get focus (from a previous lost focus, including the first time we showing the form), and build the list quickly again.

Experiment:
Change NoEventHook to true and try tp stop the clock on the top window, pressing the button messagebox on the lower form, if you are like you can see an event happen before the main.task threadswitch task to oher threads.

So when the event raised in the main.task thread may stop the clock refresh in the form's caption. This is a little chance to happen, but happens. We can include the message box in an After 100 { code here}, which is a thread for one execution only after 100 ms. 
}
// by default the Sequential part used
// so Sequential means that a thread has to finish, for changing thread. A thread start at interval bounds, but finish when actually can.
// so Concurrent means that the threads changed in each statement, if there are threads which has to run in parallel. Code in blocks trait are one statement.
// Events from Gui or other objects (which we can Declare them WithEvents), have to find idle time to actually start to run, and in refreshing. Main Task give the idle time.

REM:
	Thread.Plan Sequential
REM:	Thread.Plan Concurrent


NoEventHook=false

Title "M2000-Demo"   \\  , 0     \\ use ,0 to minimize
\\ M2000  - Form and Button and TextBox (limited to 50 chars)
If Not NoEventHook Then
	Declare Form1 Form Event Hello
else
	Event Hello {
	}
	Declare Form1 Form
end if
Declare Form1Button1(2) Button Form Form1
Declare Form1Text1(2) TextBox Form Form1


Method Form1,"move", 2000,7000,10500,3000
Method Form1Text1(0),"move", 500,900,4500,500
Method Form1Text1(1),"move", 5500,900,4500,500
With Form1Text1(0), "Text","Όλα Καλά"
Method Form1Button1(0),"move", 500,2000,4500,500
Method Form1Button1(1),"move", 5500,2000,4500,500
With Form1Button1(0), "Caption","MessageBox"


If Not NoEventHook Then
	Declare Form2 Form Event Hello
else
	Declare Form2 Form
end if
Declare Form2Button2 Button Form Form2
Method Form2,"move", 0,0,8000,3000
Method Form2Button2,"move", 1000,2000,6000,500

Again=True

\\ using Call Local we Call code in function but in This name space

Function Form1Text1.Click {
      Read Who
      Print "Form1Text1 ";Who
}
Function Form1Text1.Keydown {
\\ This is used without use of soft callback function
\\ because we have to return immediate
\\ we can alter keys here!
Read New index
Read New &keycode, &Shft, &obj
      If keycode=13 Then {

            With Form1Text1(index),  "Text" As Form1Text1$

            Print Form1Text1$
            Form1Text1$=""
      }
}
Function Form1Text1.ValidString {
\\ This is used without use of soft callback function
     Read New index
     Read New &A$, &B
  A$=Ucase$(A$)
}
Function Form1Button1.Click {
     \\ This is a message box
     \\ This use the soft callback (or async)
     Read index
     If index=0 Then
           Rem :
           Print ask("ok","This is an example for M2000 Gui")
           // hide previous line / unhide the next line
           Rem : After 300 {Print ask("ok","This is an example for M2000 Gui")}
           
     Else
        With Form1Text1(0),  "Text",""
        Cls
     End if
}
Function Form2Button2.Click {
            If Again Then With Form2, "Title", "Press Again"
            Again~
} 
Let busy1=0, busy2=0
Thread {
      If Not Empty Then
            Part {
                Try { Call Local Letter$}
           } As busy1
      end if
} As ExecuteThis1 Interval 50

Thread {
      If Not Empty Then
            Part {
                Try { Call Local Letter$}
           } As busy2
      end if
} As ExecuteThis2 Interval 50


Function Callback {
    \\ This function used If we don't have references to gui objects
    \\ and we can use threads for async service
    Read msg$, &frm
    For This {
            With frm, "Title" As Caption$
            {
                  Part {
                        Print msg$, Caption$
                         \\ Data command send to bottom, Push send to top
                        Thread ExecuteThis1 Execute Data msg$
                        msg$=""
                  } As busy1
                  Part {
                        Print msg$, Caption$
                        Thread ExecuteThis2 Execute Data msg$
                        msg$=""
                  } As busy2
                  \\ using copy we can push back the mesage again
                  \\ New messages are coming
                  If msg$<>""  Then loop \\ just mark block for looping once
                  Refresh
            }
      }
}
Event Hello New lazy$(&CallBack())

With Form1, "Title" As Form1.Caption$, "Visible" As Form1.Visible
With Form2, "Title" As Form2.Caption$, "Visible" As Form2.Visible, "top", 3000, "left", 3000

REM {
	// WE CAN CONTROL THE UNLOAD EVENT
	Function Form1.Unload {
		Read New &Cancel
		Cancel=Form1.visible
		Form1.visible=False
	
	}
	Function Form2.Unload {
		Read New &Cancel
		Cancel=Form2.visible
		Form2.visible=False	
	}
}


With Form2Button2, "Caption","Press This Please"
Form1.Caption$="Hello There"
Form2.Caption$="Hello There 2"

Method Form1,"Show"
Method Form2,"Show"
Refresh
cc=0
With Form1Text1(1), "Text" As counter$
Thread {
      cc++
      If form1.visible Then counter$=Format$("{0}", cc)
} As counter Interval 100
Main.Task 50 {
      If Again Then If form2.visible Then form2.caption$="Hello There 2 ["+str$(now,"hh:mm:ss")+"]"
  
      If form1.visible Or form2.visible Else Exit
      Print "WAIT........"
      Refresh
}
Threads Erase
Try {
	Thread.Plan Sequential
}
\\ we can dereference these here
Dim Form1Button2(), Form1Text1()
Declare Form2Button2 Nothing
Declare Form1 Nothing
Declare Form2 Nothing
\\ change title and show the console
Title "Back Again"
Show  \\ get focus back
Threads Erase
}
MODULE NEWASSERT {mode 22
Double
Pen 11 {
	Report 2, {Assert Statement
	}
}
Normal
Pen 15 {
	Print " ";
	Report {Assert statement check a list of conditions. All condtitions evaluated. Errors in expressions accumulated. If error(s) or false result from condition(s) found, then an error raised.
	
	Escape Off   (Esc key disabled for execution stop), make Asserts to ignore the list of coditions.
	
	For this test we have three condition to check.
	The second condition has an error, n variable didn't exit.
	
	We use Stop statement to change values, and to insert a new variable n at the execution point. So accept Stop in the following message box, and follow the help messages, typing the displayed statements.
	Press a key now
	}, width-2
}
Push Key$: Drop
Report {Start execution....................
}
Escape off
Assert x=10, n=5
Escape on
x=10
REM n=5
b$="beta"
While not @checkit() 
	List !
	Stop
End While

Print "Done"
Print "Press F3"

Function checkit()
	local ok, resp$
	Try ok {
		Assert x=10 , n=5 , b$="alfa"
	}
	if not ok then
	Report "Error "+Error$
	if not valid(n) then
		rep$={type: n=10
		}
	else.if n<>5 then
		rep$={type: n=5
		}
	else
		rep$=""
	end if
	if not b$="alfa" then
		rep$+={type: b$="alfa"
		}
	end if
	Report rep$+{type: exit
		}
	end if
	=ok
end function

}
MODULE ΑΘΡΟΙΣΜΑ {\\ ετοιμασία οθόνης
Οθόνη 5 : Φορμα 80,50 : Πένα 14
\\ ετοιμασία πίνακα
μεγ=10
μεγ1=μεγ-1
Πίνακας Α(μεγ)
'Α(0) = 1, 1, 1, 3, 3, 3, 4, 5, 1, 2
Α(0) =1, 3, 4, 6, 5, 4,12, 13, 7,8
\\ μεταβλητές

Τοπικές σκοπός=25, συνολο, μισό=μεγ Δια 2
\\Ετοιμασία Εξαγωγής
Κάνε φόρμα4$(Χ)=Δεξι$("    "+Γραφή$(Χ,"##0"),4)
αα=Α()
Έγγραφο Α$={Αποτελέσματα:
Σύνολο: }+αα#γραφη$(",")+{
Σκοπός:}+γραφη$(Σκοπός)+{
}
\\ κύρια επανάληψη
Για κ=0 Έως μεγ1 {
      Αν α(κ)<σκοπός Τότε {
            Για τόσα=1 Έως μεγ1 { \\ δοκίμασε με τόσα=2
                        πάρε_ένα(κ, σκοπός, τόσα)
                 }
       }
}
Διόρθωσε Α$ \\ ανοίγει τον διορθωτή Για να συμπληρώσουμε κάτι
Πρόχειρο Α$ \\ εξαγωγή στο πρόχειρο
Σώσε.Έγγραφο Α$, "Αποτελέσματα.txt"
Αναφορά Α$ \\ στην οθόνη
\\ εδώ τερματίζει ο διερμηνευτής.
Ρουτίνα πάρε_ένα(χ, ν, άσε_τόσα)
      Τοπικές κ=1, σουμα, κκ, μμ, προχ$
      \\ αναβαθμίζουμε σε Έγγραφο την τοπική
      Έγγραφο προχ$=""
      μμ=χ
      Σωρός Νέος {
            \\ ανοίγουμε ένα σωρό τιμών
            \\ βάζουμε τιμές με την βάλε και τις δαβάζουμε με την Διάβασε
            \\ καθαρίζει στο πέρας του μπλοκ    
            Ενώ ν>0 {
                        χ=(μεγ+χ ) Υπολ μεγ
                        Αν Α(χ)<=ν Τότε ν-=Α(χ) : σουμα+=Α(χ) : Βαλε Α(χ )
                        Αν κ+άσε_τόσα >μεγ1 Τότε άσε_τόσα=1
                        κ+=άσε_τόσα
                        Αν κ>μεγ1 Τότε Έξοδος
                        χ=μμ+κ
            }
            Αν σούμα=σκοπός Τότε {
                  Αν όχι κενό Τότε ταξινόμηση(1,Μέγεθος.Σωρού)
                  Προχ$="."
                  Ενώ όχι κενό {
                        Διάβασε κκ
                        Αν Εγγράφου.Μήκος(Προχ$)>1 Τότε Προχ$ = ","
                        Προχ$ = φόρμα4$(κκ)
                  }
                  Προχ$ = {
                  }
                  Εύρεση Α$, Προχ$
                  Αν Αριθμός=0 Τότε {
                        συνολο++
                        Α$ =Γραφή$(σύνολο, "000")+Προχ$
                  }
            }  
      }
Τέλος Ρουτίνας
Ρουτίνα ταξινόμηση(αρχικό, τελικό)
      Τοπικές πράγμα, ι=αρχικό, όριο=τελικό+1
      Αν όριο >2 Τότε Φέρε (όριο+ι) Δια 2
      Διάβασε πράγμα
      όριο--
      Ενώ ι<όριο {
            Αν πράγμα<ΤιμήΣωρού(ι) Τότε {
                  όριο--
                  Αν ι>1 Τότε Φέρε ι
                  ΦέρεΠίσω όριο
            }  Αλλιώς ι++
      }
      Αν ι>όριο Τότε ι=όριο
      Βάλε πράγμα : ΦέρεΠίσω ι
      Αν ι>αρχικό Τότε ταξινόμηση(αρχικό,ι-1)
      Αν τελικό>ι Τότε ταξινόμηση(ι,τελικό)
Τέλος Ρουτίνας
}
MODULE PHONEBOOTH {Form 80, 50
Module CheckIt {
      Thread.Plan Concurrent
      Class mutex {
            mylock as boolean=True
            Function Lock {
                  if not .mylock then exit
                   .mylock<=False
                   =True
            }
            Module Unlock {
                  .mylock<=True
            }
      }
      Group PhoneBooth {
            NowUser$
            module UseIt (a$, x){
                  .NowUser$<=a$
                  Print a$+" phone home ",Int(x*100);"%"
            }
            module leave {
                  .NowUser$<=""
            }
      }
      m=mutex()
      Flush
      Data "Bob", "John","Tom"
      For i=1 to 3 {
            Thread {
                  \\ we use N$, C and Max as stack variables for each thread
                  \\ all other variables are shared for module
                  If C=0 Then if not m.lock() then Print N$+" waiting...................................":  refresh 20: Continue
                  C++
                  if c=1 then thread this interval 20
                  PhoneBooth.UseIt N$,C/Max
                  iF C<Max  Then Continue
                  PhoneBooth.leave
                  m.Unlock
                  Thread This Erase
            } as K 
            Read M$
            Thread K Execute Static N$=M$,  C=0, Max=RANDOM(5,8)
            Thread K interval Random(300, 2000)
      }
      \\ Start we lock Phone Booth for service
      Service=m.lock()
      Main.Task 50 {
                  If Service Then if Keypress(32) then m.unlock: Service=false: Continue
                  If not Service then if Keypress(32)  Then if m.lock() then Service=true : Continue
                  if PhoneBooth.NowUser$<>"" Then  {
                        Print "Phone:";PhoneBooth.NowUser$: Refresh
                  } Else.if Service then Print "Service Time": Refresh
      }
}
Report {PhoneBooth Simulation using Mutex class
Bob, Jhon and Tom need to call using PhoneBooth.
Also sometimes you decide to suspend the service, for cleaning mostly. This can be done using space bar.
}
Cls ,Row+1
CheckIt
Report{
	Press any key
	}
While not inkey$="" : wait 10: End While
Push key$: Drop
Cls,0
}
MODULE VER11 {declare form1 form
declare image1 Image form form1
declare text1 TextBox form form1
Method Form1, "AccKey", "Q", alt:=true, opcode:= 100615*2
// METHOD Form1,"move", 1000,1000, 8000, 6000
With Form1, "Height", 6000, "Width", 8000
METHOD image1,"move", 1000,1000, 6000, 3300
METHOD Text1,"move", 1000, 5000
With image1,"KeyEvent", true, "Enabled" as enabled, "tabstop", true, "showcaret" as caret, "default", true
With Text1, "ShowAlways", true, "text" as text1.text$, "MoveOnEnter", false
Method Image1, "AccKey", "D", alt:=true, opcode:= 1
Method Text1, "AccKey", "T", alt:=true, opcode:= 0
enabled=true
caret=true
layer image1 {
	form 20, 10
	motion 1000,1000
	CLS 4,0 : PEN 15
	DOUBLE
	REPORT 2, "Example"
	NORMAL
	CLS  #336633, 2
	REFRESH 10
}
function text1.enter {
	keyboard text1.text$ + chr$(13)
	text1.text$=""
	call local image1.gotfocus()
	call local image1.keypress()
	call local image1.lostfocus()
}
function form1.click {
	enabled= not enabled
	if enabled then method image1, "GetFocus"
}
bufall=stack
buf$=""
function getline$() {
	if stack.size=0 then exit
	shift 1,-stack.size
	exp$=""
	while not empty
	exp$+=letter$
	end while
	=exp$
}
function image1.lostfocus {
	layer image1 {
		cursor 0, row:print over $(0), getline$(buf$, ! stack(bufall))
	}
}
function image1.gotfocus {
	layer image1 {
		cursor 0, row:print over  $(0),  buf$;
	}
}
function image1.keydown {
	read new &k, &s
	if s<>2 then exit
	if k=86  then
		local clip$=clipboard$
		if clip$<>"" then keyboard clip$
		k=0:s=0
	else.if k=67 then
		local clip$=getline$(buf$, ! stack(bufall))
		if clip$<>"" then clipboard clip$
		k=0:s=0
	end if
}
Def CheckSurrogateLead(w as integer)=uint(w)>0xD7FF and uint(w)<0xDC00
// HERE WE USE THE TAIL WHEN WE DELETE CHARS (SO WE CAN DELETE DOUBLE WORD CHARACTERS)
Def CheckSurrogateTrail(w as integer)=uint(w)>0xDBFF and uint(w)<0xE000
buf1$=""
function image1.keypress {
       if not caret then caret=true
	layer image1 {
		LOCAL a$, onemore as boolean
		a$=KEY$
		DO
			if a$=chr$(8) then
				onemore=false
				if len(buf$)>0 then
					local w=chrcode(right$(buf$,1))
					do
						onemore=false
						if CheckSurrogateTrail(w) then onemore=true
						buf$=left$(buf$, len(buf$)-1)
					until not onemore or len(buf$)=0
					end if
				if len(buf$)=0 and len(bufall)>0 then
					stack bufall {read buf$}
					if onemore then
						buf$=left$(buf$, len(buf$)-1)
					end if
					cursor 0, row:print over $(0),buf$;
				else		
					if pos>0 then cursor 0, row:print over $(0),buf$;
				end if
			else.if len.disp(a$)=0  and chrcode(a$)>32 or chrcode(a$)<0 then
				// THIS IS FOR COMBINING_DIACRITICAL_MARKS LIKE CHRCODE$(0x301)
				// COMBINING ACUTE ACCENT
				// hold Alt press + 3 0 1 release Alt
				buf$+=a$
				cursor 0, row:print over  $(0),  buf$;
			else.iF a$=CHR$(13) then
				buf$=getline$(buf$, !bufall)
				layer {print buf$:refresh}
				cursor 0, row:print over $(0),buf$
				print: buf$=""
			else.if a$>=" " then
				if len.disp(buf$)=width-1 then
					stack bufall {push buf$}:buf$="": cursor 0, row:print over
				end if
				print a$; : buf$+=a$
			end if
			a$=KEY$
		UNTIL a$=""
		refresh
	}
}
Keyboard {This is for
** Image Control **
Check:
Alt + D
Alt + T
Alt + Q to quit
}
call local image1.keypress()
METHOD form1 "SHOW", 1

declare form1 NOTHING
}
MODULE XML3 {// New method NumericCharactersEntities
// use this to convert numeric entitites when you read ATTR OR TEXT
// BUT NOT USED WHEN WE WRITE BACK.
// See the &#x00C9; as É (201 or 0xC9)
pen 14 : Cls 5,0 :Print $(4),
declare databank xmldata
method databank, "NumericCharactersEntities", true
with databank, "xml" as doc$, "beautify" as beautify, "status" as status$
doc$={<?xml?>
<Students>
	<Student Name="April" Gender="F" DateOfBirth="1989-01-02" />
	<Student Name="Bob" Gender="M"  DateOfBirth="1990-03-04" />
	<Student Name="Chad" Gender="M"  DateOfBirth="1991-05-06" />
	<Student Name="Dave" Gender="M"  DateOfBirth="1992-07-08">
		<Pet Type="dog" Name="Rover" />
	</Student>
	<Student DateOfBirth="1993-09-10" Gender="F" Name="&#x00C9;mily" />
</Students>
}
beautify=-4
Report 3, doc$
//With Databank, "Attr" as Attr$()
Print status$=""
Method databank, "GetListByTag", "Student", -1 as Result
Print type$(Result), len(Result)
c=1
If len(Result)>0 then
	Stack Result {
		Read fieldsNo : if c=1 then With fieldsNo, "Attr" as fieldsno.tag$()
		Print c, " "+fieldsno.tag$("Name")
		c++
		if empty else LOOP  // Loop raise a flag for this block, which interpreter read at the end of block, and then cleat it
	}
end if
// If you change value, this value not saved with escaped numeric character edities
// only the xml special characters escaped:
//	quot	"
//	amp	&
//	apos	'
//	lt	<
//	gt	>
rem 1:
fieldsno.tag$("Name")=@conv$("Émily")
beautify=-4
Report 3, doc$
declare databank Nothing

Function Conv$(a$)
	if len(a$)=0 then exit function
	local b$, c$, k
	for i=1 to len(a$)
		c$=mid$(a$, i,1)
		k=uint(chrcode(c$))
	Rem 2:if k>127 then b$+="&#"+str$(k,"")+";" else b$+=c$   // this place decimal value
		if k>127 then b$+="&#x"+hex$(k,2)+";" else b$+=c$ // this place hexadecimal value
	next
	=b$
End Function
}
MODULE OBSERVER {Class Subject {
Private:
      registry=list
Public:
      Module registerObserver (observer as *Observer) {
            \\ this type of pointer is a reference one
            \\ ->(this) is a hard pointer, but ->this is a weak reference
            observer=>subject->this
            append .registry, observer=>name$:=observer
      }
      Module notify(name$){
             Print "Incoming Event from ";name$
      }
      Module Observe {
            m=each(.registry)
            While m {
                  n=eval(m)
                  n=>dosomething
rem                  Print n=>name$
            }
            Print "Observe"
            Wait 20
            If inkey$<>" " Then Loop
      }
}
Class AnyClick {
      Function readit {
            Error "Abstract"
      }
}
Class KeyClick As AnyClick {
      num=0
      Function Final readit {
            If keypress(.num) Then
                  =True
            End If
      }
      Remove {
            Print "Deleted KeyClick ";.num
      }
class:
      Module KeyClick (.num) {
      }
}
Class MouseClick as AnyClick {
      num=0
      Function Final readit {
            If Binary.And(mouse, .num)=.num Then
                  =True
            End If
      }
      Remove {
            Print "Deleted MouseClick ";.num
      }
class:
      Module MouseClick (.num) {
      }
}
Class Observer {
      subject=Pointer(), name$
      click=list, func$
      Remove {
            .click<=list
            Print "Deleted ";.name$
      }
      Module dosomething {
            m=each(.click)
            While m
                  k=eval(m)
                  If k=>readit() Then
                        .subject=>notify .name$
                        Print "Raise from ";.name$
                        call .func$
                        break
                  End If
            End While
      }
class:
      Module Observer(.name$, .func$, aClick as *AnyClick) {
            Append .click, len(.click):=aClick
            While not empty
                  Read aClick
                  If not aClick is type AnyClick Then Error "not proper type"
                  Append .click, len(.click):=aClick
            End While
      }
}
Function Button1 {
      Print "Button 1"
}
Function Button2 {
      Print "Button 2"
}
Function Middle {
      Print "Middle"
}
CallBack1$=Lazy$(&Button1())
CallBack2$=Lazy$(&Button2())
CallBack3$=Lazy$(&Middle())
M=Subject()
M.registerObserver Pointer(Observer("Button1", CallBack1$, Pointer(KeyClick(Asc("A"))), Pointer(MouseClick(1))))
M.registerObserver Pointer(Observer("Button2", CallBack2$, Pointer(MouseClick(2))))
M.registerObserver Pointer(Observer("Middle", CallBack3$, Pointer(MouseClick(4))))
Escape Off
cls
Print "Press space to exit"
cls ,row
M.observe
Clear
Escape On
Print "Press F3"
}
MODULE FORMTARGET2 {// Now targets are in Image control (see also FormTarget module)
declare Form1 form
declare Image1 image form Form1
Method Form1, "move", 1000, 1000, 10000, 8000
Method Image1, "move", 1000, 1000, 6000, 4000
With Form1, "Title" as Form1.Title$
With Image1, "Visible" as Visible, "Locked" as Locked, "Enabled" as Enabled
Form1.Title$="Click on Form1"
Enabled=true
Layer Form1 {
	Gradient 1, 5
		move 0,0
	draw to  scale.x/2, scale.y/2
	circle 1500
	move 0,0
}
m=false
Module zz {
	Form1.Title$="You Click on Top Target"
	Layer {
		print "ok", timecount
		refresh
	}
	change A, text "ok"
}
Function form1.MouseDown {
	Form1.Title$="You Click on Form1"
	Stack
	refresh
}
Function Image1.MouseDown {
	Form1.Title$="You Click on Image1"
	Stack
	refresh
}
Function Image1.Target {
	Print "target:", number, A
	Refresh
	Form1.Title$="You Click on Bottom Target"
	Layer Image1 {
	Target A, m
	if m then
		change A, back 2
	else
		change A, back 0
	end if
}
m~
}
Layer Image1 {
	window 16, 8000, 6000;
	form 32, 20
	cls #333333, 0
	cursor 4, 4
	target A, "call local zz", 10, 2, 2,15, 105, "press me"
	cursor 4, 8
	target B,"z", 10, 2, 5,15, 115, "press me too"
}
k=true
function form1.click {
	if locked then locked=false
	k~
	if k then
		method Image1, "CopyBack"
		layer image1{
			change a, border 15
			change b, border 15		
		}
	end if
	visible=k
}
Thread {
	layer Form1 {
//		Refresh 1000
		move random(3000), random(3000)
		draw random(8000), random(8000), random(11,15)
		method Image1, "CopyBack"
		layer image1{
			change a, border 15
			change b, border 15		
		}
		method form1, "RefreshAll"
//		refresh
	}
	Layer {
		print timecount
		refresh
	}
} as AA interval 100
locked=true
k=false
method Form1, "show", 1
Threads Erase
declare Form1 nothing
}
MODULE REV7VER11 {Global a(100)
Class Alfa {
	dim a(3)=19
	Group z {
		Dim a(100)=21
	}
	Module Redim {
		Dim .a(2), .z.a(3)
	}
	Module Redim.a (N) {
		Dim .a(N)	
	}
}
M=Alfa()
Global N=Alfa()
? ">>>>>>>>>>>>>>"
list
M.Redim
N.Redim
? ">>>>>>>>>>>>>>"
List
? ">>>>>>>>>>>>>>"
Dim M.a(8)
List
Global K->Alfa()
? ">>>>>>>>>>>>>>"
List
For K {
	Print Len(.a()), Len(.z.a())
	.Redim
	Print Len(.a()), Len(.z.a())
}
For K {
	Print Len(.a()), Len(.z.a())
	.Redim.a 20
	dim .z.a(10)
}
For K {
	Print Len(.a()), Len(.z.a())
}
Print M.a(0)=19, M.z.a(0)=21
Print N.a(0)=19, N.z.a(0)=21
Print k=>a(0)=19, K=>z.a(0)=21
}
MODULE CRC {Module CheckApi {
      Declare CRC32 LIB c "ntdll.RtlComputeCrc32" {Long Zero, a$, long s}
      a$=Str$("The quick brown fox jumps over the lazy dog")
      // a len of 3.5 is 7 bytes. Len is a double which return number of words
      // so a 0.5 word is a byte
      // because we get a long (singed) we convert it to unsigned 32 bit (using same bits)
      Hex Uint(CRC32(sint(0x0),a$,len(a$)*2))
}
CheckApi
Module CheckApi {
      Declare CRC32 LIB "ntdll.RtlComputeCrc32" {Long Zero, a$, long s}
      a$=Str$("The quick brown fox")
      b$=Str$(" jumps over the lazy dog")
      Hex Uint(CRC32(CRC32(0,a$,len(a$)*2),b$,len(b$)*2))
}
CheckApi
Module CheckIt {

	Function PrepareTable {
		Dim Base 0, table(256)
		For i = 0 To 255
			k = i
			For j = 0 To 7
				If binary.and(k,1)=1 Then
					k =binary.Xor(binary.shift(k, -1) ,  0xEDB88320)
				Else
					k=binary.shift(k, -1)
				End If
			Next
			table(i) = k
		Next
		=table()
	}
	crc32= lambda  ' we can break the lambda definition in parts
		crct()=PrepareTable() ' this is a closure
		(crc, buf$)  ' this is the input paremeter
		-> { ' this is the function body of lambda
			if len(buf$) Else exit
			// we make a buffer of bytes and place string there
			// Eval(buf, 0) read the first byte as unsigned number (0 to 255)
			// buf and buf$ can coexist, they are different variables
			buffer buf as byte*len(buf$)*2
			return buf, 0:=buf$
			crc =0xFFFFFFFF-crc
			For i = 0 To Len(buf) -1
				crc = binary.xor(binary.shift(crc, -8), crct(binary.xor(binary.and(crc, 0xff), Eval(buf, i))))
			Next
			=0xFFFFFFFF-crc
		}
	// str$() convert Utf16LE to ANSI 8bit
	// Hex is like Print but conver unsigned numbers to hex
	Hex crc32(0@, Str$("The quick brown fox jumps over the lazy dog")) ' return 0x414fa339
	Hex crc32(crc32(0@, str$("The quick brown fox")), str$(" jumps over the lazy dog")) ' return 0x414fa339
}
CheckIt
}
MODULE VBCOLLECTION {Module GetC {
      declare c collection
      def decimal aDecimal=3000032131231231312312
      Document doc$
      Print type$(c)
      \\ we get an inventory list of all methods/properties of a com Object
      m=param(c)
      IF LEN(m)>1 THEN {
      For i=0 to len(m)-1
            \\  use index, not key so i! is index
            Doc$=m$(i!)+{
            }  ' we use this block for new line
      Next i
      }
      Report Doc$
      Clipboard Doc$
      \\ so now we have to use it, using Methid to call Add
      Method c, "Add", 100, "Hello"
      Method c, "Add", 2000, "There"
      \\ add a decimal number
 
      Method c, "Add", aDecimal, "Zero"
      Method c, "count" as count
      Print count =3  ' we have three members
      Method C, "_NewEnum" as Item
      Method c, "Item", "Zero" as ZeroItem  ' we get the decimal number
      Print ZeroItem
      Print type$(Item)="Nothing"  ' we have numbers
      k=0
      While Item {
            k++
            print k, eval(item)
      }
      c.item=lambda c (akey$) ->{
            try ok {
                  method c, "item", akey$ as ret
            }
            If type$(Ret)="Empty" Then Error "Key not used"
            =ret
      }
      Print c.item("Hello")
      Try {
            val=c.item("Hello12")
      }
      Print Error$
      Push c
      \\ normaly we can use this line
      \\ but if we omit this, Interpreter do this for us
      Declare c Nothing
}
GetC
Read a
Print type$(a)="Collection"
}
MODULE XML4 {Module CheckIt {
	Flush
	Data "April", {Bubbly: I'm > Tam and <= Émily}
	Data "Tam O'Shanter", {Burns: "When chapman billies leave the street ..."}
	Data "Émily", {Short & shrift}
	
	declare xml xmlData
	
	// This put only <?xml?>
	//    method xml, "PrepareNodeSimple", "xml" as ProcessInstructions
	//    Putting these two lines we make this:  <?xml version="1.0" encoding="UTF16"?>
	//    method xml, "PlaceAttributeToNode", ProcessInstructions, "version", "1.0"
	//    method xml, "PlaceAttributeToNode", ProcessInstructions, "encoding", "UTF16" 
	//  method xml, "PlaceProcessingInstructions", ProcessInstructions
	
	with xml, "xml" as doc$, "beautify" as beautify
	
	method xml, "PrepareNode", "CharacterRemarks" as Node
	method xml, "InsertNode", Node
	while not empty
		read name$, text$
		method xml, "PrepareNode", "Character", text$ as Node1
		method xml, "PlaceAttributeToNode", Node1, "name", name$
		method xml, "AppendChild", Node1
	end while
	beautify=-4
	Report 3, doc$
	beautify=-4
	clipboard doc$
	Method xml, "GetListByTag", "Character", -1 as Result
	c=1
	If len(Result)>0 then
		Stack Result {
			Read fieldsNo : if c=1 then With fieldsNo, "Attr" as fieldsno.tag$(), "text" as child1.text$
			Print format$("{0:-4}|{1:20}|{2}", c, fieldsno.tag$("Name"), child1.text$)
			c++
			if empty else LOOP  // Loop raise a flag for this block, which interpreter read at the end of block, and then cleat it
		}
	end if
}
CheckIt
}
UseThis : InfoBasic : Fkey : Pen 15 {Print "Press F3 now"}