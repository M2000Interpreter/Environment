Attribute VB_Name = "Module1"
' Author: George Karras, Kallithea Attikis, Greece
' Some code are work of others, and included using info when possible.
' Licensed under the GNU GENERAL PUBLIC LICENSE,  Version 3, 29 June 2007
' Before loading the code in VB6 IDE, change editor's text to a Greek font.
' Also to run greek commands from IDE you have to turn suFunction Mypport for Non Unicode Programs to Greek Language
' Local References: File idispatch.tlb
' First run this, and then you have to execute M2000.exe to call it, using a second IDE with the mexe.vbp, or just run M2000.exe
' In 9.3 rev >2 Asc() and Chr$() in M2000 use Locale. In previous versions these functions works for greek ascii.
' In version 10 additional symbols for remarks: //

Option Explicit


Private timestamp As Long
Global skiperror As Boolean
Global maxlonglong, limitlonglong, plan As Long, lastpanel As Long
Global OsInfo As New clsOSInfo, Zero64, One64, stoponerror As Boolean
Global HaltLevel As Long, errbag As ErrorBag
Global startaddress As Long, stacksize As Long, findstack As Long
Private Const mProp = "PropReference"
Private Const mHdlr = "mHandler"
Private Const mGroup = "Group"
Const a123 = "={-"
Const b123 = vbCr + "'\/"
Const b1234 = vbCr + "'\/:"
Const b12345 = vbCr + "'\/:}"
Const RemChar = "'\/"
Private Const myArray = "mArray"
Const thislabel$ = "[!" + vbCr + "'\//]"
Public rndbase As rndvars, GDILines As Boolean
Public LastUse As Long
Private funcno As Long, ua As Double, UB As Double
Private simplestack1 As rndvars
Private Declare Function ShowCursor Lib "user32" (ByVal bShow As Long) As Long
Private Const lCID_INSTALLED = 1
Private Declare Function timeGetTime Lib "winmm.dll" () As Long
Private Declare Function timeGetTime1 Lib "kernel32.dll" Alias "GetTickCount" () As Long
Public Declare Function IsValidCodePage Lib "kernel32" (ByVal CodePage As Long) As Long
Private Declare Sub GetMem1 Lib "msvbvm60" (ByVal Addr As Long, retval As Byte)
Public Declare Sub GetMem2 Lib "msvbvm60" (ByVal Addr As Long, retval As Integer)
Private Declare Sub GetMem4 Lib "msvbvm60" (ByVal Addr As Long, retval As Long)
Private Declare Sub GetMemS Lib "msvbvm60" Alias "GetMem4" (ByVal Addr As Long, retval As Single)
Private Declare Sub GetMem8 Lib "msvbvm60" (ByVal Addr As Long, retval As Double)
Private Declare Sub PutMem1 Lib "msvbvm60" (ByVal Addr As Long, ByVal NewVal As Byte)
Public Declare Sub PutMem2 Lib "msvbvm60" (ByVal Addr As Long, ByVal NewVal As Integer)
Private Declare Sub PutMem4 Lib "msvbvm60" (ByVal Addr As Long, ByVal NewVal As Long)
Private Declare Sub PutMemS Lib "msvbvm60" Alias "PutMem4" (ByVal Addr As Long, ByVal NewVal As Single)
Private Declare Sub PutMem8 Lib "msvbvm60" (ByVal Addr As Long, ByVal NewVal As Double)
Private Declare Function CopyBytes Lib "msvbvm60.dll" Alias "__vbaCopyBytes" (ByVal ByteLen As Long, ByVal Destination As Long, ByVal Source As Long) As Long
Private Declare Function ObjSetAddRef Lib "msvbvm60.dll" Alias "__vbaObjSetAddref" (ByRef objDest As Object, ByVal pObject As Long) As Long
Public Declare Function IsBadCodePtr Lib "kernel32" (ByVal lpfn As Long) As Long
Private Declare Function GetStringTypeExW Lib "kernel32.dll" (ByVal Locale As Long, ByVal dwInfoType As Long, ByVal lpSrcStr As Long, ByVal cchSrc As Long, ByRef lpCharType As Integer) As Long
Private Declare Function CompareString Lib "kernel32" Alias "CompareStringW" (ByVal Locale As Long, ByVal dwCmpFlags As Long, ByVal lpString1 As Long, ByVal cchCount1 As Long, ByVal lpString2 As Long, ByVal cchCount2 As Long) As Long
Private Declare Function CallWindowProc _
 Lib "user32.dll" Alias "CallWindowProcW" ( _
 ByVal lpPrevWndFunc As Long, _
 ByVal hWnd As Long, _
 ByVal Msg As Long, _
 ByVal wParam As Long, _
 ByVal lParam As Long) As Long
Public NullGroup As New Group
Public Okk As Boolean
Private Declare Sub DisableProcessWindowsGhosting Lib "user32" ()
Public Interrupted As Boolean
Public NoOptimum As Boolean
Dim zero As basket
 Public Type GenItem
 Key As String
 nDx As String
 firsthash As Long
 lastpos As Long
 Pleft As Long  ' a list
 End Type
' 1 to 32 for layers
' 0 for DIS
Public NowDec$, NowThou$, DefaultDec$
Public ShowBooleanAsString As Boolean, DefBooleanString As String
Public ForLikeBasic As Boolean, DimLikeBasic As Boolean, SecureNames As Boolean
Public UseTabInForm1Text1 As Boolean
Public priorityOr As Boolean, NoUseDec As Boolean, mNoUseDec As Boolean, UseIntDiv As Boolean
Public mTextCompare As Boolean
Public csvsep$, csvDec$, csvuseescape As Boolean, cleanstrings As Boolean
Public inpcsvsep$, inpcsvDec$, inpcsvuseescape As Boolean, inpcleanstrings As Boolean
Public Const DisForm = 0
Public Const BackForm = -1
Public Const PrinterPage = -2
Public players(-2 To 1032) As basket  ' tag number not actual number of dsprite()
Public Prefresh(-2 To 1032) As Counters

Private Declare Function GdiFlush Lib "gdi32" () As Long
Public m_bInIDE As Boolean
Public UKEY$
Public TestShowCode As Boolean, TestShowSub As String, TestShowStart As Long, WaitShow As Long
Public TestShowBypass As Boolean, TestShowSubLast As String
Public feedback$, FeedbackExec$, feednow$ ' for about$
Global Const VerMajor = 12
Global Const VerMinor = 0
Global Const Revision = 68
Private Const doc = "Document"
Public UserCodePage As Long, DefCodePage As Long
Public cLine As String  ' it was public in form1
Public casesensitive As Boolean  ' for filesf
Public userfiles As String
Public TweakLang As Long
Public notweak As Boolean
Public extreme As Boolean
Public taskmainonly As Boolean
Public TaskMain As Boolean

' Directory separator character
Public HelpStack As New basetask ' from 6.5.1

Public REFRESHRATE As Currency
Public RRCOUNTER As Currency
Public BLOCKkey As Boolean
Public Const novalidstr = "+-/*!?_()[]&$#@;" + """"

Public tempList2delete As String
Public nnn$, basickey$, homepage$
Public shortlang As Boolean
Public LEVCOLMENU As Long

Public Alphabet As String

Public taskid As Long, kill2$, para$

Public sRec As Object
Public defFontname As String
Public pnum As Long
Public my_system As Enum_OperatingPlatform
Public Declare Function Beeper Lib "kernel32" Alias "Beep" _
  (ByVal dwFreq As Long, ByVal dwDuration As Long) As Long
Public oprinter As New cDIBSection
Public Const MAX_FILENAME_LEN As Long = 260 * 2 - 1
Public beeperBEAT As Long
Public funcdeep As Variant
Public deep As Variant
Private mys As String
Public needset As Boolean
Public cnt As Boolean
Public exWnd As Long

Private Declare Function GetForegroundWindow Lib "user32" () As Long
Public expl As Long

Public l_complete As Boolean
Public s_complete As Boolean
Public ThereIsAPrinter As Boolean
Public MOUT As Boolean
Public DXP As Long
Public DYP As Long
Public SLOW As Boolean
Public pname As String
Public Port As String
Global elevatestatus As Long
Global elevatestatus2 As Long
Public Fkey As Long
Public FK$(1 To 24)
Public strTemp As String
Public STEXIT As Boolean
Public STbyST As Boolean
Public STq As Boolean, bypassST As Boolean
Public pagio$, pagiohtml$
Public subHash As New sbHash
Public varhash As New Hash
Public comhash As New sbHash, numid As New idHash, numidbackup As New idHash, funid As New idHash, funidbackup As New idHash
Public zones As New FastCollection
Public strid  As New idHash, stridbackup As New idHash, strfunid As New idHash, strfunidbackup As New idHash
Public Clid As Long 'current id for app id
Public lastAboutHTitle As String, LastAboutText As String
''
Public Basestack1 As New basetask ' this is the global stack
Public EventStaticCollection As New FastCollection
Public BookMarks As New FastCollection
Public sb2used As Long
Public Type modfun
    Extern As Long
    sb As String
    sbc As Long
    sbgroup As String
    tpointer As Long
    subs As FastCollection
    locked As Boolean
    goodname As String
    Changed As Boolean
    IamAClass As Boolean
End Type
Public sbf() As modfun
Public var2used As Long
Public var() As Variant
Public globalstack As New mStiva

Public IERUN As Boolean
Public IEX As Long
Public IEY As Long
Public IESizeX As Long
Public IESizeY As Long
Public AVIRUN As Boolean
Public AVIUP As Boolean
Public aviX As Long
Public aviY As Long
Public UseAviXY As Boolean
Public UseAviSize As Boolean
Public AviSizeX As Long
Public AviSizeY As Long
Public mycoder As New coder
' play music
Public voices$(0 To 15), BEATS(0 To 15) As Double



Const GFSR_SYSTEMRESOURCES = 0
Const GFSR_GDIRESOURCES = 1
Const GFSR_USERRESOURCES = 2


Declare Function SetLocaleInfo Lib "kernel32" Alias "SetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String) As Long
Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, lpLCData As String, ByVal cchData As Long) As Long
Public Declare Function GetWindowsDirectory Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal lpBuffer As String, ByVal nSize As Long) As Long


Private Const LOCALE_USER_DEFAULT = 0&


Public trace As Boolean, tracecounter As Long, bypasstrace As Boolean




Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Public Declare Function SetTimer Lib "user32" _
       (ByVal hWnd As Long, ByVal nIDEvent As Long, _
        ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long

Public Declare Sub KillTimer Lib "user32" _
       (ByVal hWnd As Long, ByVal nIDEvent As Long)
'Public Type tagInitCommonControlsEx
 ' lngSize As Long
  ' lngICC As Long
'End Type
'Public Declare Function InitCommonControlsEx Lib "comctl32.dll" (iccex As tagInitCommonControlsEx) As Boolean
'Public Const ICC_USEREX_CLASSES = &H200
' APPLICATION TASK MASTER
Public MasterTimer As Currency, tickTimer As Double
Public TaskMaster As TaskMaster
Public hmidi As Long
Public mute As Boolean
Public beat As Long
Public baseNote As Long
Public Prof As New clsProfiler
Public Declare Function GetACP Lib "kernel32" () As Long  ' 1253 in my computer


Public OverideDec As Boolean
'Valid dwCmpFlags
Public Declare Function LCMapStringW Lib "kernel32.dll" (ByVal Locale As Long, ByVal dwMapFlags As Long, ByVal lpSrcStr As Long, ByVal cchSrc As Long, Optional ByVal lpDestStr As Long, Optional ByVal cchDest As Long) As Long
Private Declare Function SysReAllocStringLen Lib "OleAut32.dll" (ByVal pBSTR As Long, Optional ByVal pszStrPtr As Long, Optional ByVal Length As Long) As Long
Public Modalid As Double
Public Function aheadstatus(A$, Optional srink As Boolean = True, Optional Pos As Long = 1) As String 'ok
Dim b$, part$, W$, pos2 As Long
If A$ = vbNullString Then Exit Function
Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If V1 = 2 Then
        If part$ <> "" Then
            b$ = b$ + part$
        End If
            part$ = "S"
            Pos = Pos + CLng("&H" + Mid$(A$, Pos + 1, 8)) + 8
            W$ = """"
        ElseIf Abs(V1) > 8 Then
            If part$ = vbNullString And W$ = "0" Then
                If Pos + 2 <= Len(A$) Then
                    If LCase(Mid$(A$, Pos, 2)) Like "0[xВ]" Then
                        'hexadecimal literal number....
jumphere1:
                        Pos = Pos + 2
                        Do While Pos <= Len(A$)
                            If Not Mid$(A$, Pos, 1) Like "[0-9a-fA-F]" Then Exit Do
                            Pos = Pos + 1
                        Loop
                        If Mid$(A$, Pos, 1) = "&" Then
                            If Mid$(A$, Pos + 1, 1) = "&" Then Pos = Pos + 2 Else Pos = Pos + 1
                        End If
                        b$ = b$ + "N"
                        If Pos <= Len(A$) Then
                            W$ = Mid$(A$, Pos, 1)
                        Else
                            Exit Do
                        End If
                    End If
            End If
        End If
        If W$ = """" Then
            If part$ <> "" Then
                b$ = b$ + part$
            End If
            part$ = "S"
            Pos = Pos + 1
            Do While Pos <= Len(A$)
                If Mid$(A$, Pos, 1) = """" Then Exit Do
                    If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
                    Pos = Pos + 1
                Loop
            ElseIf W$ = "[" Then
        Pos = Pos + 1
        If Not BlockParam2s(A$, Pos) Then Exit Do
            ElseIf W$ = "(" Then
again:
                If part$ <> "" Then
                    If part$ = "S" Then
                        If Mid$(A$, Pos + 1, 1) = ")" Then Pos = Pos + 2: GoTo conthere
                    End If
                ElseIf Right$(b$, 1) = "a" Then
                    b$ = Left$(b$, Len(b$) - 1)
                    part$ = vbNullString
                Else
                    part$ = "N"
                End If
again22:
                Pos = Pos + 1
                If Not BlockParam2p(A$, Pos) Then Exit Do
                    If Mid$(A$, Pos + 1, 2) = "=>" Then
                        part$ = ""
                        Pos = Pos + 3
                        GoTo conthere
                    ElseIf Mid$(A$, Pos + 1, 1) = "#" Then
                        'b$ = vbNullString
                        part$ = ""
                        Pos = Pos + 2
                        GoTo conthere
                    ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
                        Pos = Pos + 1: GoTo again22
                    End If
                    If Mid$(A$, Pos + 1, 1) <> "." And Mid$(A$, Pos + 1, 2) <> "=>" Then
                        b$ = b$ + part$
                    End If
                    part$ = vbNullString
                   ElseIf W$ = "[" Then
                        Pos = Pos + 1
                        If Not BlockParam2s(A$, Pos) Then Exit Do
                        If part$ = "N" Then
                        ElseIf part$ = "S" Then
                        Else
                        b$ = b$ + part$
                        part$ = "N"
                        End If
                ElseIf W$ = "{" Then
                    Select Case Left$(Right$(b$, 2), 1)
                    Case "l"
                        Exit Do
                    Case "o"
                        If Right$(b$, 1) = "N" Then Exit Do
                    Case "S"
                        If Right$(b$, 1) = "a" Then
                            Select Case Left$(Right$(b$, 3), 1)
                            Case "l"
                                Exit Do
                            Case "o"
                                Exit Do
                            End Select
                            If Left$(Right$(b$, 3), 1) = "l" Then Exit Do
                        End If
                End Select
                If part$ <> "" Then
                    b$ = b$ + part$
                End If
                part$ = "S"
                If Pos <= Len(A$) Then
                    pos2 = Pos
                    If Not blockStringAhead(A$, Pos) Then Exit Do
                    If Right$(b$, 1) = "N" Then
                        If Not MaybeIsSymbol3lot(A$, "+<>=~", (Pos + 1)) Then
                        Pos = pos2
                        Exit Do
                    End If
                End If
            End If
        Else
            Select Case W$
            Case ","  ' bye bye
                Exit Do
            Case "%"
            Case "$"
                If part$ = vbNullString Then
                    If b$ = vbNullString Then
                        part$ = "N"
                    ElseIf Right$(b$, 1) = "o" Then
                        part$ = "N"
                    Else
                        aheadstatus = b$
                        Exit Function
                    End If
                ElseIf part$ = "N" Then
                        b$ = b$ + "Sa"
                        If Mid$(A$, Pos + 1, 1) = "." Then Pos = Pos + 1
                        part$ = vbNullString
                End If
            Case "+", "-" ',"|"
                b$ = b$ + part$
                If Len(b$) > 0& Then
                    part$ = "o"
                End If
            Case "/"
                If Mid$(A$, Pos + 1, 1) = "/" Then Exit Do
                If part$ <> "o" Then b$ = b$ + part$
                part$ = "o"
            Case "*", "^"
                If part$ <> "o" Then b$ = b$ + part$
                part$ = "o"
            Case " ", ChrW(160), vbTab
                If Len(part$) > 0 Then
                    b$ = b$ + part$
                    part$ = vbNullString
                End If
            Case "0" To "9", "."
                If part$ = "N" Then
                    If Len(A$) < Pos Then
                        If Mid$(A$, Pos + 1, 1) Like "[@#%~]" Then
                            Pos = Pos + 1
                        ElseIf Mid$(A$, Pos + 1, 1) = "&" Then
                            If Mid$(A$, Pos + 2, 1) = "&" Then Pos = Pos + 2 Else Pos = Pos + 1
                        End If
                    End If
                ElseIf part$ = "S" Then
                Else
                    b$ = b$ + part$
                    part$ = "N"
                End If
            Case "&"
                If LCase$(Mid$(A$, Pos + 1, 1)) = "h" Then
                    If Mid$(A$, Pos + 2, 1) Like "[0-9a-fA-F]" Then
                        GoTo jumphere1
                    End If
                End If
                If part$ = vbNullString Then
                    part$ = "S"
                ElseIf part$ = "N" Then
                    b$ = b$ + part$
                    part$ = vbNullString
                Else
                    b$ = part$
                    part$ = "S"
                End If
            Case "e", "E", "Е", "е"
                If part$ = "N" Then
                ElseIf part$ = "S" Then
                Else
                    b$ = b$ + part$
                    part$ = "N"
                End If
            Case "~"
                GoTo there1
            Case ">", "<"
                If Len(A$) > Pos Then
                    If Mid$(A$, Pos + 1, 1) = "=" Then
                        b$ = b$ + part$
                         If Len(b$) > 1 Then
                            part$ = "o"
                            If Mid$(A$, Pos, 3) = "<=>" Then
                                Pos = Pos + 2
                            Else
                                Pos = Pos + 1
                            End If
                        End If
                    ElseIf Mid$(A$, Pos, 2) = "<>" Then
                        b$ = b$ + part$
                        If Len(b$) > 1 Then
                            part$ = "o"
                            Pos = Pos + 1
                        End If
                    ElseIf W$ = ">" And Pos > 1 Then
                        If Mid$(A$, Pos - 1, 2) = "->" Then ' "->"
                            If Right$(b$, 1) = "S" Then
                                b$ = b$ + part$
                                part$ = "N"
                            End If
                        End If
                    End If
                    
                End If
                GoTo there1
            Case "="
                If Len(A$) > Pos Then
                    If InStr(">=", Mid$(A$, Pos + 1, 1)) > 0 Then
                        Pos = Pos + 2
                        GoTo conthere
                    End If
                End If
            
there1:
                If b$ + part$ <> "" Then
                    W$ = Replace(b$ + part$, "a", "")
                    part$ = vbNullString
                    If srink Then
                        Do
                            b$ = W$
                            W$ = Replace(b$, "NN", "N")
                        Loop While W$ <> b$
                        Do
                            b$ = W$
                            W$ = Replace(b$, "SlS", "N")
                        Loop While W$ <> b$
                        Do
                            b$ = W$
                            W$ = Replace(b$, "NlN", "N")
                        Loop While W$ <> b$
                        Do
                            b$ = W$
                            W$ = Replace(b$, "NoN", "N")
                        Loop While W$ <> b$
                        Do
                            b$ = W$
                            W$ = Replace(b$, "SoS", "S")
                        Loop While W$ <> b$
                    Else
                        b$ = W$
                    End If
                    If Left$(b$, Len(b$) - 1) <> "l" Then part$ = "l"
                Else
                    Exit Do
                End If
            Case ")", "}", Is < " ", ":", ";", "'", "\"
                Exit Do
            Case Else
                If part$ = "N" Then
                ElseIf part$ = "S" Then
                Else
                    b$ = b$ + part$
                    part$ = "N"
                End If
            End Select
        End If
    End If
    Pos = Pos + 1
conthere:
Loop

W$ = Replace(b$ + part$, "a", "")

b$ = W$
If srink Then
         Do
  b$ = W$

    W$ = Replace(b$, "SlS", "N")
    Loop While W$ <> b$
      Do
    b$ = W$
    W$ = Replace(b$, "NlN", "N")
    Loop While W$ <> b$
    
    Do
    b$ = W$
    W$ = Replace(b$, "NoN", "N")
    Loop While W$ <> b$
    
    Do
    b$ = W$
    W$ = Replace(b$, "SoS", "S")
    Loop While W$ <> b$
End If
    aheadstatus = b$

End Function
Public Function aheadstatusStr(A$) As Long 'ok
Dim W$, pos2 As Long, Pos As Long
If A$ = vbNullString Then Exit Function
Dim V1 As Integer
 Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    
    If V1 = 2 Then
    If pos2 = 0 Then aheadstatusStr = True
    Exit Function
    
    ElseIf Abs(V1) > 8 Then
    
    If V1 = 34 Then
        If pos2 = 0 Then aheadstatusStr = True
        Exit Function
    ElseIf W$ = "[" Then
        Pos = Pos + 1
        If Not BlockParam2s(A$, Pos) Then Exit Do
    ElseIf W$ = "(" Then
        
again22:
        Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
       If Mid$(A$, Pos + 1, 1) <> "." And Mid$(A$, Pos + 1, 2) <> "=>" Then
       
       End If
       
        
    ElseIf W$ = "{" Then
         
        aheadstatusStr = True
        Exit Function
    Else
        Select Case W$
        Case " ", ChrW(160), vbTab
        If pos2 > 0 Then Exit Function
        Case "%"
            If Not Mid$(A$, Pos + 1, 1) = "(" Then Exit Function
        Case "$"
            aheadstatusStr = True
            Exit Function
        Case "="
            If Not Mid$(A$, Pos + 1, 1) = ">" Then Exit Function
            Pos = Pos + 1
        Case "-"
            If Not Mid$(A$, Pos + 1, 1) = ">" Then Exit Function
            Pos = Pos + 1
        Case "."
         pos2 = pos2 + 1
        Case "0" To "9"
        If pos2 = 0 Then Exit Function
        Case "&"
        If pos2 = 0 Then aheadstatusStr = True: Exit Function
       
         Case Is < " ", ")", "}", ":", ";", "'", "\", "<", "~", ",", ">", "+", "*", "/", "'", "~", "|"
         Exit Function
        Exit Do
        Case Else
        pos2 = pos2 + 1
        End Select
        End If
End If
        Pos = Pos + 1
        
conthere:
  
Loop



End Function
Public Function aheadstatusFast(A$) As String 'ok
Dim b$, part$, W$, pos2 As Long, Pos As Long

If A$ = vbNullString Then Exit Function
Dim V1 As Integer
Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If V1 = 2 Then
        If part$ <> "" Then
        b$ = b$ + part$
        End If
        part$ = "S"
        Pos = Pos + CLng("&H" + Mid$(A$, Pos + 1, 8)) + 8
        W$ = """"
   
    
    ElseIf Abs(V1) > 8 Then
    If part$ = vbNullString And W$ = "0" Then
        If Pos + 2 <= Len(A$) Then
            If LCase(Mid$(A$, Pos, 2)) Like "0[xВ]" Then
            'hexadecimal literal number....
jumphere1:
                Pos = Pos + 2
                Do While Pos <= Len(A$)
                    If Not Mid$(A$, Pos, 1) Like "[0-9a-fA-F]" Then Exit Do
                    Pos = Pos + 1
                    While Mid$(A$, Pos, 1) = "_": Pos = Pos + 1: Wend
                Loop
                Select Case Mid$(A$, Pos, 1)
                Case "&"
                If Mid$(A$, Pos + 1, 1) = "&" Then Pos = Pos + 2 Else Pos = Pos + 1
                Case "%"
                    Pos = Pos + 1
                Case "u", "U"
                If Len(Mid$(A$, Pos + 1, 1)) > 0 Then
                If InStr("BbDd", Mid$(A$, Pos + 1, 1)) > 0 Then
                    Pos = Pos + 2
                End If
                End If
                End Select
                If CheckFree(Mid$(A$, Pos, 1)) Then
                b$ = b$ + "N"
                Else
                If part$ = vbNullString Then
                    part$ = "S"
                    ElseIf part$ = "N" Then
                    b$ = b$ + part$
                    part$ = vbNullString
                    Else
                    b$ = part$
                    part$ = "S"
                    End If
                End If
                If Pos <= Len(A$) Then
                    W$ = Mid$(A$, Pos, 1)
                Else
                    Exit Do
                End If
            End If
        End If
    End If

    If W$ = """" Then
        If part$ <> "" Then
        b$ = b$ + part$
        End If
        part$ = "S"
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
    If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
   
        Pos = Pos + 1
        Loop

    ElseIf W$ = "(" Then
        If part$ <> "" Then
            ' after
            If part$ = "S" Then
                If Mid$(A$, Pos + 1, 1) = ")" Then Pos = Pos + 2: GoTo conthere
            End If
        ElseIf Right$(b$, 1) = "a" Then
            b$ = Left$(b$, Len(b$) - 1)
            part$ = vbNullString
        Else
            part$ = "N"
        End If
again22:
        Pos = Pos + 1
        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 2) = "=>" Then
        'part$ = ""
        Pos = Pos + 3
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 2
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
       If Mid$(A$, Pos + 1, 1) <> "." And Mid$(A$, Pos + 1, 2) <> "=>" Then
       b$ = b$ + part$
       End If
        part$ = vbNullString
    ElseIf W$ = "[" Then
        Pos = Pos + 1
        If Not BlockParam2s(A$, Pos) Then Exit Do
        If part$ = "N" Then
        ElseIf part$ = "S" Then
        Else
        b$ = b$ + part$
        part$ = "N"
        End If
    ElseIf W$ = "{" Then
Select Case Left$(Right$(b$, 2), 1)
    Case "l"
       Exit Do
    Case "o"
    If Right$(b$, 1) = "N" Then Exit Do
    Case "S"
    If Right$(b$, 1) = "a" Then
    Select Case Left$(Right$(b$, 3), 1)
    Case "l"
        Exit Do
    Case "o"
    Exit Do

    End Select
    
       If Left$(Right$(b$, 3), 1) = "l" Then Exit Do
    End If
    End Select
         
    If part$ <> "" Then
        b$ = b$ + part$
        End If
        part$ = "S"
        
If Pos <= Len(A$) Then
            pos2 = Pos
        If Not blockStringAhead(A$, Pos) Then Exit Do
        If Right$(b$, 1) = "N" Then
        If Not MaybeIsSymbol3lot(A$, "+<>=~", (Pos + 1)) Then
        Pos = pos2
        Exit Do
        End If
        End If
        End If
      

    Else
        Select Case W$
        Case ","  ' bye bye
        Exit Do
        Case "%"
            If part$ = vbNullString Then
            End If
        Case "$"
            If part$ = vbNullString Then
                If b$ = vbNullString Then
                    part$ = "N"
                ElseIf Right$(b$, 1) = "o" Then
                    part$ = "N"
                Else
                    aheadstatusFast = b$
                    Exit Function
                End If
            ElseIf part$ = "N" Then
                    b$ = b$ + "Sa"
                    If Mid$(A$, Pos + 1, 1) = "." Then Pos = Pos + 1
                    part$ = vbNullString
            End If
        Case "+", "-"  ' ,"|"
                    b$ = b$ + part$
                    If b$ = vbNullString Then
                    Else
                    
                part$ = "o"
                End If
         Case "/"
            If Mid$(A$, Pos + 1, 1) = "/" Then Exit Do
            If part$ <> "o" Then
            b$ = b$ + part$
            End If
            part$ = "o"
        Case "*", "^"
            If part$ <> "o" Then
            b$ = b$ + part$
            End If
            part$ = "o"
        Case " ", ChrW(160), vbTab
            If part$ <> "" Then
            b$ = b$ + part$
            part$ = vbNullString
            Else
            'skip
            End If
        
        Case "0" To "9", "."
            If part$ = "N" Then
            If Len(A$) < Pos Then
                If Mid$(A$, Pos + 1, 1) Like "[@#%~]" Then
                    Pos = Pos + 1
                ElseIf Mid$(A$, Pos + 1, 1) = "&" Then
                    If Mid$(A$, Pos + 2, 1) = "&" Then Pos = Pos + 2 Else Pos = Pos + 1
                End If
            End If
            
            ElseIf part$ = "S" Then
            
            Else
            
            b$ = b$ + part$
            part$ = "N"
            End If
        Case "&"
        If LCase$(Mid$(A$, Pos + 1, 1)) = "h" Then
            If Mid$(A$, Pos + 2, 1) Like "[0-9a-fA-F]" Then
                GoTo jumphere1
            End If
        End If
        If part$ = vbNullString Then
        part$ = "S"
        ElseIf part$ = "N" Then
        b$ = b$ + part$
        part$ = vbNullString
        Else
        b$ = part$
        part$ = "S"
        End If
        Case "e", "E", "Е", "е"
            If part$ = "N" Then
            ElseIf part$ = "S" Then
            Else
            b$ = b$ + part$
            part$ = "N"
            End If
        Case "~"
        GoTo there1
         Case ">", "<"
            If Len(A$) > Pos Then
                If Mid$(A$, Pos + 1, 1) = "=" Then
                    b$ = b$ + part$
                     If Len(b$) > 1 Then
                        part$ = "o"
                        If Mid$(A$, Pos, 3) = "<=>" Then
                            Pos = Pos + 2
                        Else
                            Pos = Pos + 1
                        End If
                    End If
                ElseIf Mid$(A$, Pos, 2) = "<>" Then
                    b$ = b$ + part$
                    If Len(b$) > 1 Then
                        part$ = "o"
                        Pos = Pos + 1
                    End If
                ElseIf W$ = ">" And Pos > 1 Then
                    If Mid$(A$, Pos - 1, 2) = "->" Then ' "->"
                        If Right$(b$, 1) = "S" Then
                            b$ = b$ + part$
                            part$ = "N"
                        End If
                    End If
                End If
            End If
            GoTo there1
         Case "="
            If Len(A$) > Pos Then
                If InStr(">=", Mid$(A$, Pos + 1, 1)) > 0 Then
                    Pos = Pos + 2
                    GoTo conthere
                End If
            End If
there1:
                If b$ + part$ <> "" Then
               
               b$ = Replace(b$ + part$, "a", "")
                part$ = vbNullString
               
                If Left$(b$, Len(b$) - 1) <> "l" Then part$ = "l": Exit Do
                
                Else
                Exit Do
                End If

        Case ")", "}", Is < " ", ":", ";", "'", "\"
        Exit Do
        Case Else
CONT1212:
        If part$ = "N" Then
        ElseIf part$ = "S" Then
        Else
        
     b$ = b$ + part$
     part$ = "N"

            End If
        End Select
        End If
End If
        Pos = Pos + 1
        
conthere:
  
Loop
aheadstatusFast = b$ + part$
End Function
'
Public Sub aheadstatusNew(A$, Pos As Long, flag As Boolean)
Dim b$, part$, W$, pos2 As Long
flag = False
If A$ = vbNullString Then Exit Sub

Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    If part$ = vbNullString And W$ = "0" Then
        If Pos + 2 <= Len(A$) Then
            If LCase(Mid$(A$, Pos, 2)) Like "0[xВ]" Then
                Pos = Pos + 2
jumphere1:
                Do While Pos <= Len(A$)
                    If Not Mid$(A$, Pos, 1) Like "[0-9a-fA-F]" Then Exit Do
                    Pos = Pos + 1
                    While Mid$(A$, Pos, 1) = "_": Pos = Pos + 1: Wend
                Loop
                If Mid$(A$, Pos, 1) = "&" Then
                If Mid$(A$, Pos + 1, 1) = "&" Then Pos = Pos + 2 Else Pos = Pos + 1
                ElseIf Mid$(A$, Pos, 1) = "%" Then
                    Pos = Pos + 1
                End If
                If CheckFree(Mid$(A$, Pos, 1)) Then
                b$ = b$ + "N"
                Else
                If part$ = vbNullString Then
                    part$ = "S"
                    ElseIf part$ = "N" Then
                    b$ = b$ + part$
                    part$ = vbNullString
                    Else
                    b$ = part$
                    part$ = "S"
                    End If
                End If
                If Pos <= Len(A$) Then
                    W$ = Mid$(A$, Pos, 1)
                Else
                    Exit Do
                End If
            End If
        End If
    End If

    If W$ = """" Then
        If part$ <> "" Then
        b$ = b$ + part$
        End If
        part$ = "S"
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
    If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
   
        Pos = Pos + 1
        Loop

    ElseIf W$ = "(" Then
again:
        If part$ <> "" Then
            ' after
            If part$ = "S" Then
            '
             If Mid$(A$, Pos + 1, 1) = ")" Then Pos = Pos + 2: GoTo conthere
             
            End If
            ElseIf Right$(b$, 1) = "a" Then
            b$ = Left$(b$, Len(b$) - 1)
            part$ = vbNullString
            Else
            part$ = "N"
              
        End If
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        b$ = vbNullString
        part$ = "N"
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
       If Mid$(A$, Pos + 1, 1) <> "." And Mid$(A$, Pos + 1, 2) <> "=>" Then
       b$ = b$ + part$
       End If
        part$ = vbNullString
        ElseIf W$ = "[" Then
            Pos = Pos + 1
            If Not BlockParam2s(A$, Pos) Then Exit Do
            If part$ = "N" Then
            ElseIf part$ = "S" Then
            Else
            b$ = b$ + part$
            part$ = "N"
            End If
    ElseIf W$ = "{" Then

Select Case Left$(Right$(b$, 2), 1)
    Case "l"
        Exit Do
    Case "o"
    If Right$(b$, 1) = "N" Then Exit Do
    Case "S"
    If Right$(b$, 1) = "a" Then
    Select Case Left$(Right$(b$, 3), 1)
    Case "l"
         Exit Do
    Case "o"
   Exit Do

    End Select
    
       If Left$(Right$(b$, 3), 1) = "l" Then Exit Do
    End If
    End Select
    If part$ <> "" Then
        b$ = b$ + part$
        End If
        part$ = "S"
        
        
            If Pos <= Len(A$) Then
            pos2 = Pos
        If Not blockStringAhead(A$, Pos) Then Exit Do
        If Right$(b$, 1) = "N" Then
        If Not MaybeIsSymbol3lot(A$, "+<>=~", (Pos + 1)) Then
        Pos = pos2
        Exit Do
        End If
        End If
        End If
      

      

    Else
        Select Case W$
        Case ","  ' bye bye
        Exit Do
        Case "%"
            If part$ = vbNullString Then
            End If
        Case "$"
            If part$ = vbNullString Then
                If b$ = vbNullString Then
                    part$ = "N"
                ElseIf Right$(b$, 1) = "o" Then
                    part$ = "N"
                Else
                    flag = Len(b$) > 0
                    Exit Sub
                End If
            ElseIf part$ = "N" Then
                    b$ = b$ + "Sa"
                    If Mid$(A$, Pos + 1, 1) = "." Then Pos = Pos + 1
                    part$ = vbNullString
            End If
        Case "+", "-" ', "|"
                    b$ = b$ + part$
                    If b$ = vbNullString Then
                    Else
                    
                part$ = "o"
                End If
        Case "*", "/", "^"
            If part$ <> "o" Then
            b$ = b$ + part$
            End If
            part$ = "o"
        Case " ", ChrW(160), vbTab
            If part$ <> "" Then
            b$ = b$ + part$
            part$ = vbNullString
            Else
            'skip
            End If
        Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        Case "0" To "9", "."
            If part$ = "N" Then
            If Len(A$) < Pos Then
                If Mid$(A$, Pos + 1, 1) Like "[@#%~]" Then
                    Pos = Pos + 1
                ElseIf Mid$(A$, Pos + 1, 1) = "&" Then
                    If Mid$(A$, Pos + 2, 1) = "&" Then Pos = Pos + 2 Else Pos = Pos + 1
                End If
            End If
            
            ElseIf part$ = "S" Then
            
            Else
            
            b$ = b$ + part$
            part$ = "N"
            End If
        Case "&"
        If LCase$(Mid$(A$, Pos + 1, 1)) = "h" Then
            If Mid$(A$, Pos + 2, 1) Like "[0-9a-fA-F]" Then
                GoTo jumphere1
            End If
        End If
        If part$ = vbNullString Then
        part$ = "S"
        ElseIf part$ = "N" Then
        b$ = b$ + part$
        part$ = vbNullString
        Else
        b$ = part$
        part$ = "S"
        End If
        Case "e", "E", "Е", "е"
            If part$ = "N" Then

            ElseIf part$ = "S" Then
            
            
            Else
            b$ = b$ + part$
            part$ = "N"
            End If
             Case "~"
        GoTo there1
         Case ">", "<"
            If Len(A$) > Pos Then
                If Mid$(A$, Pos + 1, 1) = "=" Then
                    b$ = b$ + part$
                    If Len(b$) > 1 Then
                        part$ = "o"
                        If Mid$(A$, Pos, 3) = "<=>" Then
                            Pos = Pos + 2
                        Else
                            Pos = Pos + 1
                        End If
                    End If
                ElseIf Mid$(A$, Pos, 2) = "<>" Then
                    b$ = b$ + part$
                    If Len(b$) > 1 Then
                        part$ = "o"
                        Pos = Pos + 1
                    End If
                ElseIf W$ = ">" And Pos > 1 Then
                    If Mid$(A$, Pos - 1, 2) = "->" Then ' "->"
                        If Right$(b$, 1) = "S" Then
                            b$ = b$ + part$
                            part$ = "N"
                        End If
                    End If
                End If
            End If
            GoTo there1
         Case "="
            If Len(A$) > Pos Then
                If InStr(">=", Mid$(A$, Pos + 1, 1)) > 0 Then
                    Pos = Pos + 2
                    GoTo conthere
                End If
            End If
there1:
                If b$ + part$ <> "" Then
               
                W$ = Replace(b$ + part$, "a", "")
            part$ = vbNullString
               
               If Len(b$) > 1 Then If Left$(b$, Len(b$) - 1) <> "l" Then part$ = "l"
                Else
                Exit Do
                End If

        Case ")", "}", Is < " ", ":", ";", "'", "\"
        Exit Do
        Case Else
        If part$ = "N" Then
        ElseIf part$ = "S" Then
        Else
        
     b$ = b$ + part$
     part$ = "N"

            End If
        End Select
        End If
End If
        Pos = Pos + 1
        
conthere:
  
Loop


    flag = Len(b$) <> 0




End Sub

Public Sub aheadstatusDO(A$, Pos As Long, Lang As Long, flag As Boolean)
Dim pos2 As Long, what$, W$, lenA As Long, level2 As Integer
Const second1$ = "епамекабе", len1 = 9
Const second11$ = "епамакабе", len11 = 9
Const second2$ = "DO", len2 = 2
Const second22$ = "REPEAT", len22 = 6
flag = False
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(A$)
Do While Pos <= lenA
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
                Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case W$
        Case "%", "$", "0" To "9", vbLf
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbCr, vbTab
            If Len(what$) > 1 Then
                If Lang = 0 Then
                    V1 = Len(what$)
                    If V1 = 5 Or V1 = 3 Or V1 = len1 Then
                        what$ = myUcase(what$)
                        If what$ = "левяи" Or what$ = "памта" Or what$ = "осо" Then
                                
                                If level2 = 0 Then
                                    Pos = Pos - V1
                                    flag = True
                                    Exit Sub
                                Else
                                    If Left$(what$, 1) <> "п" Then aheadstatusSkipParam A$, Pos
                                    level2 = level2 - 1
                                End If
                        ElseIf what$ = second1$ Or what$ = second11$ Then
                            If MaybeIsSymbol3(A$, "{", Pos) Then
                                aheadstatusSTRUCT A$, Pos
                            Else
                                level2 = level2 + 1
                            End If
                        Else
                            aheadstatusSkipParam A$, Pos
                        End If
                    Else
                        aheadstatusSkipParam A$, Pos
                    End If
                Else
                    V1 = Len(what$)
                    If V1 = 4 Or V1 = 5 Or V1 = len2 Or V1 = len22 Then
                        what$ = UCase(what$)
                        If what$ = "UNTIL" Or what$ = "ALWAYS" Or what$ = "WHEN" Then
                            If level2 = 0 Then
                                Pos = Pos - V1
                                flag = True
                                Exit Sub
                            Else
                                If Left$(what$, 1) <> "A" Then aheadstatusSkipParam A$, Pos
                                level2 = level2 - 1
                            End If
                        ElseIf what$ = second2$ Or what$ = second22$ Then
                            If MaybeIsSymbol3(A$, "{", Pos) Then
                                aheadstatusSTRUCT A$, Pos
                          Else
                                level2 = level2 + 1
                            End If
                        Else
                            aheadstatusSkipParam A$, Pos
                        End If
                    Else
                        aheadstatusSkipParam A$, Pos
                    End If
                End If
          Else
          If Len(what$) > 0 Then aheadstatusSkipParam A$, Pos
          End If
                  Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbCr, vbLf, vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1

                what$ = vbNullString
        Case "/"
            If Mid$(A$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
        
        Case ")", "}", Is < " " ', "'", "\"
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        
        what$ = what$ + W$
        
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
If flag = False Then
If Len(what$) > 0 Then
If level2 = 0 Then
    If Lang = 0 Then
    what$ = myUcase(what$)
        If what$ = "памта" Then
        Pos = Pos - Len(what$)
            flag = True
            Exit Sub
        End If
    Else
    what$ = UCase(what$)
    If what$ = "ALWAYS" Then
        Pos = Pos - Len(what$)
        flag = True
        Exit Sub
    End If
    End If
End If
End If
End If
Pos = lenA + 2

End Sub
Public Sub aheadstatusSTRUCT(A$, Pos As Long)
Dim pos2 As Long, W$, lenA As Long
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
lenA = Len(A$)
If Pos = 0 Then Pos = 1
Do While Pos <= lenA
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    If W$ = """" Then
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "[" Then
        Pos = Pos + 1
        If Not BlockParam2s(A$, Pos) Then Exit Do
    ElseIf W$ = "(" Then
again22:
      Pos = Pos + 1
        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        If MaybeIsSymbol3(A$, ":", Pos) Then Pos = Pos + 1: Exit Do
        End If
    Else
        Select Case W$
        Case "/"
        If Mid$(A$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
' skip line
    Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf

End Sub
Public Sub aheadstatusIFthen(A$, Pos As Long, Lang As Long, W$)
Dim pos2 As Long, what$

If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case W$
        Case ",", ":"
        Exit Do
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbCr, "{", vbTab
                If Len(what$) > 3 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                             If what$ = "тоте" Or what$ = "аккиыс" Then
                             
                                    If lookB123(A$, Pos) Then
                                        W$ = what$
                                        Exit Sub
                                    Else
                                        aheadstatusSkipParam A$, Pos
                                    End If
                                    Exit Do
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                    If lookB123(A$, Pos) Then
                                        W$ = what$
                                        Exit Sub
                                    Else
                                        aheadstatusSkipParam A$, Pos
                                    End If
                                    Exit Do
                            End If
                        End If
                    End If
                    End If
                    If W$ = vbCr Then Exit Do
                    what$ = vbNullString
            If W$ = "{" Then
                     If Pos <= Len(A$) Then
                    Pos = blockLen2(A$, Pos + 1)
                    If Pos = 0 Then Pos = Len(A$): Exit Do
                    End If
            Else
            Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        End If
        Case "/"
        If Mid$(A$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        
        what$ = what$ + W$
        
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
W$ = vbNullString
If Len(what$) > 0 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
         If what$ = "тоте" Or what$ = "аккиыс" Then
            W$ = what$
        ElseIf what$ = "THEN" Or what$ = "ELSE" Then
            W$ = what$
        End If
      End If
        
End If
End Sub

Public Sub aheadstatusIF(A$, Pos As Long, Lang As Long, W$)
Dim pos2 As Long, what$

If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case W$
        Case ",", ":"
        Exit Do
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), "{", vbTab
                If Len(what$) > 3 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                             If what$ = "тоте" Or what$ = "аккиыс" Then
                                W$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                W$ = what$
                                Exit Sub
                            End If
                        End If
                    End If
                    End If
                    what$ = vbNullString
                    If W$ = "{" Then
                     If Pos <= Len(A$) Then
                    Pos = blockLen2(A$, Pos + 1)
                    If Pos = 0 Then Pos = Len(A$): Exit Do
                    End If
                    Else
                 Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        End If
        Case "/"
        If Mid$(A$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        
        what$ = what$ + W$
        
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
W$ = vbNullString
If Len(what$) > 0 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
         If what$ = "тоте" Or what$ = "аккиыс" Then
            W$ = what$
        ElseIf what$ = "THEN" Or what$ = "ELSE" Then
            W$ = what$
        End If
      End If
        
End If
End Sub
Public Sub aheadstatusELSE(A$, Pos As Long, Lang As Long, W$)
Dim pos2 As Long, what$
' in a line like if true then ?"ok" else ?"else"
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case W$
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case vbTab, " ", ChrW(160), "0" To "9", "{"
                If Len(what$) > 1 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                        If what$ = "ам" Or what$ = "аккиыс" Or what$ = "аккиыс.ам" Then 'Or what$ = "тоте"
                            W$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "IF" Or what$ = "ELSE" Or what$ = "ELSE.IF" Then  'Or what$ = "THEN"
                                W$ = what$
                                Exit Sub
                            End If
                        End If
                    End If
                    End If
                    what$ = vbNullString
       
                 If W$ = "{" Then
                     If Pos <= Len(A$) Then
                    Pos = blockLen2(A$, Pos + 1)
                    If Pos = 0 Then Pos = Len(A$): Exit Do
                    End If
                 Else
                Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        End If
        Case "/"
        If Mid$(A$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        If W$ = ":" Then
        what$ = ""
        Else
        what$ = what$ + W$
        End If
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
W$ = vbNullString
If Len(what$) > 1 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
                        If what$ = "ам" Or what$ = "тоте" Or what$ = "аккиыс" Or what$ = "аккиыс.ам" Then
                            W$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "IF" Or what$ = "THEN" Or what$ = "ELSE" Or what$ = "ELSE.IF" Then
                                W$ = what$
                                Exit Sub
                            End If
                        End If
        
End If
End Sub


Public Sub aheadstatusThen(A$, Pos As Long, Lang As Long, W$)
Dim pos2 As Long, what$

If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= Len(A$) Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = Len(A$): Exit Do
        End If
    Else
        Select Case W$
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), "0" To "9", vbTab
                If Len(what$) > 1 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                        If what$ = "тоте" Or what$ = "аккиыс" Then
                            W$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                W$ = what$
                                Exit Sub
                            End If
                        End If
                    End If
                    End If
                    what$ = vbNullString
                 Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        Case "/"
        If Mid$(A$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        
        what$ = what$ + W$
        
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
W$ = vbNullString
If Len(what$) > 1 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
                        If what$ = "тоте" Or what$ = "аккиыс" Then
                            W$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                W$ = what$
                                Exit Sub
                            End If
                        End If
        
End If
End Sub
Public Sub aheadstatusSkipParam2(A$, Pos As Long)
' no block  ' for for next
Dim pos2 As Long, W$
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    If W$ = """" Then
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "[" Then
        Pos = Pos + 1
        If Not BlockParam2s(A$, Pos) Then Exit Do
    ElseIf W$ = "(" Then
again22:
      Pos = Pos + 1
        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case W$
        Case "/"
            If Mid$(A$, Pos + 1, 1) = "/" Then GoTo jump1
        Case "'", "\"
        If Pos > 1 Then Pos = Pos - 1
        Exit Do
        Case ":", ")", "{", "}", Is < " ", vbLf
        Exit Do
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Exit Sub
jump1:
If Pos > 1 Then Pos = Pos - 1
End Sub

Public Sub aheadstatusSkipParam(A$, Pos As Long)
Dim pos2 As Long, W$
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    If W$ = """" Then
        Pos = Pos + 1
        Do While Pos <= Len(A$)
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
again22:
      Pos = Pos + 1
        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "[" Then
        Pos = Pos + 1
        If Not BlockParam2s(A$, Pos) Then Exit Do
    ElseIf W$ = "{" Then
       If Pos <= Len(A$) Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = Len(A$): Exit Do
        End If
    Else
        Select Case W$
        Case "/"
        If Mid$(A$, Pos + 1, 1) = "/" Then
        If Pos > 1 Then Pos = Pos - 1
        Exit Do
        End If
        Case "'", "\"
        If Pos > 1 Then Pos = Pos - 1
        Exit Do
        Case ":", ")", "}", Is < " ", vbLf
        Exit Do
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop

End Sub


Public Sub aheadstatusNext(A$, Pos As Long, Lang As Long, flag As Boolean)
Dim pos2 As Long, what$, W$, lenA As Long, level2 As Integer, CM As Integer
CM = 1
Const second1$ = "циа", len1 = 3
Const second2$ = "FOR", len2 = 3
flag = False
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(A$)
Do While Pos <= lenA
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
    
        Select Case W$
        Case vbLf
        CM = 0
        If Len(what$) > 0 Then what$ = vbNullString
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbCr, ":", vbTab
again:
            If Len(what$) > 2 Then
                If Lang = 0 Then
                    If Len(what$) = 7 Or Len(what$) = len1 Then
                        what$ = myUcase(what$)
                        If what$ = "еполемо" Then
                               If MyTrim$(W$) = "" Then aheadstatusSkipParam A$, Pos
                                If level2 = 0 Then
                                    flag = True
                                    Exit Sub
                                Else
                                    level2 = level2 - 1
                                End If
                        ElseIf what$ = second1$ Then
                            aheadstatusSkipParam2 A$, Pos
                            If MaybeIsSymbol3(A$, "{", Pos) Then
                                Pos = blockLen2(A$, Pos + 1)
                                If Pos = 0 Then Pos = Len(A$): Exit Sub
                            ElseIf MaybeIsSymbol3lot(A$, b1234, Pos) Then
                                level2 = level2 + 1
                            End If
                        Else
                            aheadstatusSkipParam A$, Pos
                        End If
                    Else
                        aheadstatusSkipParam A$, Pos
                    End If
                Else
                    If Len(what$) = 4 Or Len(what$) = len2 Then
                        what$ = myUcase(what$)
                        If what$ = "NEXT" Then
                            If MyTrim$(W$) = "" Then aheadstatusSkipParam A$, Pos
                            If level2 = 0 Then
                                flag = True
                                Exit Sub
                            Else
                                level2 = level2 - 1
                            End If
                        ElseIf what$ = second2$ Then
                            aheadstatusSkipParam2 A$, Pos
                            If MaybeIsSymbol3(A$, "{", Pos) Then
                                Pos = blockLen2(A$, Pos + 1)
                                If Pos = 0 Then Pos = Len(A$): Exit Sub
                            ElseIf MaybeIsSymbol3lot(A$, b1234, Pos) Then
                                level2 = level2 + 1
            
                              
                            End If
                        Else
                            aheadstatusSkipParam A$, Pos
                        End If
                    Else
                        aheadstatusSkipParam A$, Pos
                    End If
                End If
          Else
          
          If Len(what$) > 0 Then
          ' If EXPR THEN FOR (NOW WORKS FOR INNER FOR NEXT)
          ' PREVIOUS: IF EXPR THEN : FOR (WORK WITH :, OR A BLOCK { })
          
            Select Case myUcase(what$)
            Case "IF", "ам"
                aheadstatusThen A$, Pos, 0, what$
            Case Else
                aheadstatusSkipParam A$, Pos
            End Select
          End If
          End If
                what$ = vbNullString
                
        Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        Case "/"
            If CM = 0 Or Mid$(A$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        CM = 1
        what$ = what$ + W$
        
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
If Len(what$) > 2 Then GoTo again
Pos = lenA + 2

End Sub


Public Sub aheadstatusELSEIF(A$, Pos As Long, Lang As Long, jump As Boolean, IFCTRL As Long, flag As Boolean)
Dim what$, W$, lenA As Long, level2 As Integer, CM As Integer, pos3 As Long
CM = 1
Const second1$ = "ам", len1 = 2
Const second2$ = "IF", len2 = 2
flag = True
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(A$)
Do While Pos <= lenA
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case W$
        Case "%", "$", "0" To "9", vbLf
            If Len(what$) > 0 Then what$ = vbNullString
        Case vbLf
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 0
        Case " ", ChrW(160), vbCr, vbTab ',  Check Else and IF
                If Len(what$) > 1 Then
                        
                        If Lang = 0 Then
                        
                        
                            what$ = myUcase(what$)
                            If what$ = "аккиыс" Then
                                
                                If lookB123(A$, Pos) Then
                                    If level2 = 0 Then Pos = Pos - 6: Exit Sub
                                Else
                                    aheadstatusSkipParam A$, Pos
                                End If
                            ElseIf what$ = "текос" Then
                                    
                                If FastSymbolAt(Pos, A$, second1$, len1) Then
                                    If level2 = 0 Then IFCTRL = 0: Exit Sub
                                    level2 = level2 - 1
                                Else
                                    aheadstatusSkipParam A$, Pos
                                End If
                            ElseIf what$ = "аккиыс.ам" Then
                                    If (Not jump) Or IFCTRL = 2 Then
                                        aheadstatusSkipParam A$, Pos
                                    Else
                                    
                                    If level2 = 0 Then
                                    Pos = Pos - 9: Exit Sub
                                    Else
                                        aheadstatusSkipParam A$, Pos
                                    End If
                                    End If
                            ElseIf what$ = second1$ Then  ' skip any nested IF
                                aheadstatusThen A$, Pos, 0, what$
                                If what$ <> vbNullString Then
                                    If MaybeIsSymbol3(A$, "{", Pos) Then
                                    aheadstatusSTRUCT A$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(A$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                            Else
                            aheadstatusSkipParam A$, Pos
                            End If
                          
                        Else
                                what$ = UCase(what$)
                                If what$ = "ELSE" Then
                                    If lookB123(A$, Pos) Then
                                        If level2 = 0 Then Pos = Pos - 4: Exit Sub
                                    Else
                                        aheadstatusSkipParam A$, Pos
                                    End If
                                ElseIf what$ = "END" Then
                            
                                    If FastSymbolAt(Pos, A$, second2$, len2) Then
                                        If level2 = 0 Then IFCTRL = 0: Exit Sub
                                        level2 = level2 - 1
                                    Else
                                        aheadstatusSkipParam A$, Pos
                                    End If
                                ElseIf what$ = "ELSE.IF" Then
                                    If (Not jump) Or IFCTRL = 2 Then
                                        aheadstatusSkipParam A$, Pos
                                    Else
                                    
                                    If level2 = 0 Then
                                    Pos = Pos - 7: Exit Sub
                                    Else
                                        aheadstatusSkipParam A$, Pos
                                    End If
                                    End If
                                ElseIf what$ = second2$ Then
                                aheadstatusThen A$, Pos, 1, what$
                                If what$ <> vbNullString Then
                                    If MaybeIsSymbol3(A$, "{", Pos) Then
                                    aheadstatusSTRUCT A$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(A$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                                
                                Else
                                aheadstatusSkipParam A$, Pos
                                End If
                            
                        End If
                    End If
                    what$ = vbNullString
                            Pos = Pos + 1
        Do
        pos3 = Pos + 1
        Select Case Mid$(A$, Pos, 1)
        Case " ", Chr$(160), vbCr, vbLf, vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos3 > Pos
        Pos = Pos - 1

        Case "/"
            If CM = 0 Or Mid$(A$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
         Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        CM = 1
        what$ = what$ + W$
        
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 1
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Sub
'
'
Public Sub aheadstatusENDIF(A$, Pos As Long, Lang As Long, flag As Boolean)
Dim pos2 As Long, what$, W$, lenA As Long, level2 As Integer, CM As Integer
CM = 1
Const second1$ = "ам", len1 = 2
Const second2$ = "IF", len2 = 2
flag = True
If A$ = vbNullString Then Exit Sub
Dim V1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(A$)
Do While Pos <= lenA
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case W$
        Case vbCr, vbLf
            CM = 0
            If Len(what$) > 0 Then what$ = vbNullString
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbTab
                If Len(what$) > 1 Then
                        
                        If Lang = 0 Then
                        If Len(what$) = 5 Or Len(what$) = len1 Then
                            what$ = myUcase(what$)
                            If what$ = "текос" Then
                                    
                                If FastSymbolAt(Pos, A$, second1$, len1) Then
                                If level2 = 0 Then Exit Sub
                                level2 = level2 - 1
                                Else
                                aheadstatusSkipParam A$, Pos
                                End If
                            ElseIf what$ = second1$ Then
                                aheadstatusThen A$, Pos, 0, what$
                                If what$ <> vbNullString Then
                                  If MaybeIsSymbol3(A$, "{", Pos) Then
                                    aheadstatusSTRUCT A$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(A$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                            Else
                            aheadstatusSkipParam A$, Pos
                            End If
                            Else
                            aheadstatusSkipParam A$, Pos
                            End If
                          
                        Else
                            If Len(what$) = 3 Or Len(what$) = len2 Then
                                what$ = UCase(what$)
                                If what$ = "END" Then
                            
                                If FastSymbolAt(Pos, A$, second2$, len2) Then
                                    If level2 = 0 Then Exit Sub
                                    level2 = level2 - 1
                                 Else
                                 aheadstatusSkipParam A$, Pos
                                End If
                                ElseIf what$ = second2$ Then
                                aheadstatusThen A$, Pos, 1, what$
                                If what$ <> vbNullString Then
                                    If MaybeIsSymbol3(A$, "{", Pos) Then
                                    aheadstatusSTRUCT A$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(A$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                                
                                Else
                                aheadstatusSkipParam A$, Pos
                                End If
                            Else
                            aheadstatusSkipParam A$, Pos
                            
                            End If
                            
                        End If
                    End If
                    what$ = vbNullString
                        Pos = Pos + 1
                        Do
                        pos2 = Pos + 1
                        Select Case Mid$(A$, Pos, 1)
                        Case " ", Chr$(160), vbTab
                            Pos = Pos + 1
                        End Select
                        Loop Until pos2 > Pos
                        Pos = Pos - 1

        Case "/"
            If CM = 0 Or Mid$(A$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        
        what$ = what$ + W$
        CM = 1
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 1
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Sub

Public Function aheadstatusENDSUBorFUN(A$, Pos As Long, Lang As Long, func As Boolean) As Boolean
Dim pos2 As Long, what$, W$, lenA As Long, level2 As Integer, CM As Integer
CM = 1
Const second1$ = "сумаятгсгс", len1 = 10
Const second2$ = "FUNCTION", len2 = 8
Const second11$ = "яоутимас", len11 = 8
Const second22$ = "SUB", len22 = 3
If A$ = vbNullString Then Exit Function
Dim V1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(A$)
Do While Pos <= lenA
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case W$
            Case vbCr, vbLf
                CM = 0
                If Len(what$) > 0 Then what$ = vbNullString
            Case "%", "$", "0" To "9"
                If Len(what$) > 0 Then what$ = vbNullString
            Case " ", ChrW(160), vbTab
                If Len(what$) > 1 Then
                    If Lang = 0 Then
                        If Len(what$) = 5 Then
                            what$ = myUcase(what$)
                            If what$ = "текос" Then
                                If func Then
                                    If FastSymbolAt(Pos, A$, second1$, len1) Then aheadstatusENDSUBorFUN = True: Exit Function
                                Else
                                    If FastSymbolAt(Pos, A$, second11$, len11) Then aheadstatusENDSUBorFUN = True: Exit Function
                                End If
                            End If
                        End If
                    Else
                        If Len(what$) = 3 Then
                            what$ = UCase(what$)
                            If what$ = "END" Then
                                If func Then
                                    If FastSymbolAt(Pos, A$, second2$, len2) Then aheadstatusENDSUBorFUN = True: Exit Function
                                Else
                                    If FastSymbolAt(Pos, A$, second22$, len22) Then aheadstatusENDSUBorFUN = True: Exit Function
                                End If
                            End If
                        End If
                    End If
                aheadstatusSkipParam A$, Pos
                what$ = vbNullString
                End If
                
                
                    Pos = Pos + 1
                    Do
                    pos2 = Pos + 1
                    Select Case Mid$(A$, Pos, 1)
                    Case " ", Chr$(160), vbTab
                        Pos = Pos + 1
                    End Select
                    Loop Until pos2 > Pos
                    Pos = Pos - 1

        Case "/"
            If CM = 0 Or Mid$(A$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        
        what$ = what$ + W$
        CM = 1
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 1
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Function
Public Sub aheadstatusENDWHILE(A$, Pos As Long, Lang As Long, flag As Boolean, V1 As Long)
Dim pos2 As Long, what$, W$, lenA As Long, level2 As Integer, CM As Integer
Const second1$ = "емы"
Const len1 As Long = 3
Const second2$ = "WHILE"
Const len2 As Long = 5
flag = False
CM = 1
If A$ = vbNullString Then Exit Sub
If Pos = 0 Then Pos = 1
lenA = Len(A$)
Do While Pos <= lenA
    W$ = Mid$(A$, Pos, 1)
    V1 = AscW(W$)
    If Abs(V1) > 8 Then
    
    If W$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(A$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(A$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf W$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf W$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        Pos = blockLen2(A$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case W$
            Case vbLf
                If Len(what$) > 0 Then what$ = vbNullString
                CM = 0
            Case "%", "$", "0" To "9", vbCr
                If Len(what$) > 0 Then what$ = vbNullString
            Case " ", ChrW(160), vbTab
                If Len(what$) > 1 Then
                    If Lang = 0 Then
                        If Len(what$) = 5 Or Len(what$) = len1 Then
                            what$ = myUcase(what$)
                            If what$ = "текос" Then
                                V1 = Pos - 5
                                If FastSymbolAt(Pos, A$, second1$, len1) Then
                                    If level2 = 0 Then flag = True: Exit Sub
                                    level2 = level2 - 1
                                Else
                                    aheadstatusSkipParam A$, Pos
                                End If
                            ElseIf what$ = second1$ Then
                                Pos = Pos - 1
                                Do
                                Do
                                    Pos = Pos + 1
                                    pos2 = Pos
                                    aheadstatusNew A$, Pos, flag
                                Loop While flag And MaybeIsSymbol3(A$, ",", Pos)
                                Loop Until Not MaybeIsSymbol3(A$, ",", Pos)
                                If MaybeIsSymbol3(A$, "{", Pos) Then
                                    aheadstatusSTRUCT A$, Pos
                                ElseIf MaybeIsSymbol3lot(A$, b1234, Pos) Then
                                    level2 = level2 + 1
                                    Pos = Pos + 1
                                End If
                            Else
                                aheadstatusSkipParam A$, Pos
                            End If
                        Else
                            aheadstatusSkipParam A$, Pos
                        End If
                    Else
                        If Len(what$) = 3 Or Len(what$) = len2 Then
                            what$ = UCase(what$)
                            If what$ = "END" Then
                                V1 = Pos - 3
                                If FastSymbolAt(Pos, A$, second2$, len2) Then
                                    If level2 = 0 Then flag = True: Exit Sub
                                    level2 = level2 - 1
                                Else
                                    aheadstatusSkipParam A$, Pos
                                End If
                            ElseIf what$ = second2$ Then
                                Pos = Pos - 1
                                Do
                                Do
                                    Pos = Pos + 1
                                    pos2 = Pos
                                    aheadstatusNew A$, Pos, flag
                                Loop While flag And MaybeIsSymbol3(A$, ",", Pos)
                                Loop Until Not MaybeIsSymbol3(A$, ",", Pos)
                                If MaybeIsSymbol3(A$, "{", Pos) Then
                                    aheadstatusSTRUCT A$, Pos
                                ElseIf MaybeIsSymbol3lot(A$, b1234, Pos) Then
                                    level2 = level2 + 1
                                    Pos = Pos + 1
                                End If
                            Else
                                aheadstatusSkipParam A$, Pos
                            End If
                        Else
                            aheadstatusSkipParam A$, Pos
                        End If
                    End If
                End If
                what$ = vbNullString
                Pos = Pos + 1
                Do
                    pos2 = Pos + 1
                    Select Case Mid$(A$, Pos, 1)
                        Case " ", Chr$(160), vbTab
                        Pos = Pos + 1
                    End Select
                Loop Until pos2 > Pos
                Pos = Pos - 1
            Case "/"
                If CM = 0 Or Mid$(A$, Pos, 2) = "//" Then
                   GoTo skip1
                End If
            Case "'", "\"
skip1:
                If Len(what$) > 0 Then what$ = vbNullString
                Do
                Pos = Pos + 1
                Loop While Pos < lenA And Not Mid$(A$, Pos, 1) = vbLf
                CM = 0
            Case ")", "}", Is < " "
                Exit Do
            Case "A" To "Z", "a" To "z", Is >= "╒"
                CM = 1
                what$ = what$ + W$
            Case Else
                If Len(what$) > 0 Then what$ = vbNullString
                CM = 1
            End Select
        End If
    End If
    Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Sub
Function ChangeValuesMem(bstack As basetask, rest$, Lang As Long) As Boolean
Dim aa As mHandler, ah As String, p As Variant, s$, Addr As Long, pp As Variant, what$, r As Double
Dim bb1 As MemBlock, w2 As Variant, rs As Single, itisSingle As Boolean, itisInt64 As Boolean, itisCur As Boolean
Set aa = bstack.lastobj
Set bstack.lastobj = Nothing
Set bb1 = aa.objref

    Do While FastSymbol(rest$, ",")
    
        ChangeValuesMem = False
        pp = bb1.ItemSize
        ah = aheadstatus(rest$, False) + " "
        If InStr(ah, "l") Then
                FoundLogicalExpr
        Else
                If Left$(ah, 1) = "N" Then
                    If Not IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
                        GoTo there
                    End If
                   
                    If FastSymbol(rest$, "!") Then
                    
                    
                    If FastPureLabel(rest$, what$) Then
                        If bb1.UseStruct Then
                                If bb1.structref.Find(myUcase(what$, True)) Then
                                    pp = bb1.structref.sValue
                                    itisSingle = bb1.structref.KeyTypeValue = vbSingle
                                    itisInt64 = bb1.structref.KeyTypeValue = 20
                                    itisCur = bb1.structref.KeyTypeValue = vbCurrency
                                    If FastSymbol(rest$, "!") Then
                                        If Not IsExp(bstack, rest$, r, , True) Then
                                                 GoTo there
                                        ElseIf r >= 0 Then
                                                 p = bb1.GetPtr(p) + bb1.structref.StructOffset + Int(r) * Abs(pp)
                                        Else
                                                 NegativeIndex1
                                                GoTo there
                                        End If
                                    Else
                                    
                                    p = bb1.GetPtr(p) + bb1.structref.StructOffset
                                    End If
                                    
                                Else
                                rest$ = what$ + rest$
                                If IsExp(bstack, rest$, r, , True) Then
                                        p = bb1.GetPtr(p) + r
                                        
                                    Else
                                    MyErMacro rest$, "Unknown Offset " + what$, "╒ЦМЫСТГ лЕТэХЕСГ " + what$
                                    GoTo there
                                End If
                           End If
                        Else
                                If IsExp(bstack, what$, r, , True) Then
                                    p = bb1.GetPtr(p) + r
                                Else
                                    GoTo there
                                End If
                        End If
                        Else
                        p = bb1.GetBytePtr(p)
                        End If
                        
          
                    Else
                                                
                        p = bb1.GetPtr(p)
                        itisSingle = bb1.WhatIsBasicItem = vbSingle
                        itisInt64 = bb1.WhatIsBasicItem = 20
                        itisCur = bb1.WhatIsBasicItem = vbCurrency
                        If bb1.WhatIsBasicItem = 0 Then
                        If Not bb1.structref Is Nothing Then
                            bb1.structref.ToStart
                            pp = bb1.structref.sValue
                            itisSingle = bb1.structref.KeyTypeValue = vbSingle
                            itisInt64 = bb1.structref.KeyTypeValue = 20
                            itisCur = bb1.structref.KeyTypeValue = vbCurrency
                        End If
                        End If
                    End If
                    If p = 0 Then
                        
                          GoTo err30
                    End If
                    Addr = CLng(Fix(p))
                
                    
                Else

                        MyEr "No Offset found", "дЕМ БЯщХГЙЕ дИЕЩХУМСГ"
                          GoTo there
                
                End If
                If FastSymbol(rest$, ":=", , 2) Then
                    ah = aheadstatus(rest$, False) + " "
                    If Left$(ah, 1) = "N" Or InStr(ah, "l") > 0 Then
                        If Not IsExp(bstack, rest$, p, , True) Then
                            GoTo there
                        End If
                         If MemInt(VarPtr(p)) = vbString Then
                            s$ = p
                            GoTo q1239877
                        End If
                        If Addr = 0 Then
                            
                
                            GoTo err30
                        Else
                                ' this ia a part to poke some data to buffer
                            If Addr = 0 Then
                                
                        
                                GoTo err30
                            Else
                                ' here is the part where we copy a string to memblock
                                If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                                    If IsLabelSymbolNew(rest$, "ьгжио", "BYTE", Lang) Then
                                        pp = 1
                                    ElseIf IsLabelSymbolNew(rest$, "айеяаиос", "INTEGER", Lang) Then
                                    pp = 2
                                    ElseIf IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang) Then
                                    If IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang) Then
                                        pp = -8
                                        itisInt64 = True
                                    Else
                                        pp = 4
                                    End If
                                    ElseIf IsLabelSymbolNew(rest$, "коцистийос", "CURRENCY", Lang) Then
                                        pp = 8
                                        itisCur = True
                                    ElseIf IsLabelSymbolNew(rest$, "апкос", "SINGLE", Lang) Then
                                        pp = 4
                                        itisSingle = True
                                    ElseIf IsLabelSymbolNew(rest$, "дипкос", "DOUBLE", Lang) Then
                                        pp = 8
                                    Else
                                        SyntaxError
                                        GoTo there
                                    End If
                               End If
                                Err.Clear
                                On Error Resume Next
                                Select Case Abs(pp)
                                Case 1
                                    ChangeValuesMem = True
                                    PutMem1 Addr, CByte(LowWord(signlong(p)) And &HFF)
                               Case 2
                                   If bb1.ValidArea(Addr, 2) Then
                                        ChangeValuesMem = True
                                        PutMem2 Addr, cUint(LowWord(signlong(p)))
                                    Else
                                        GoTo err10
                                        
                                    End If
                                Case 4
                                    If bb1.ValidArea(Addr, 4) Then
                                        ChangeValuesMem = True
                                        If itisSingle Then
                                            rs = CSng(p)
                                            PutMemS Addr, rs
                                        Else
                                            PutMem4 Addr, signlong(p)
                                        End If
                                    Else
                                        GoTo err10
                                        
                                   End If
                                Case 8
                                   If bb1.ValidArea(Addr, 8) Then
                                        ChangeValuesMem = True
                                        If itisCur Then
                                        MemCur(Addr) = CCur(p)
                                        ElseIf itisInt64 Or pp < 0 Then
                                        p = cInt64(p)
                                        CopyMemory ByVal Addr, ByVal VarPtr(p) + 8, 8
                                        Else
                                        PutMem8 Addr, p
                                        End If
                                   Else
                                        GoTo err10
                                        
                                   End If
                                End Select
                                If Err <> 0 Then
                                    GoTo err20
                                End If
                            End If
                        End If
                    ElseIf Left$(ah, 1) = "S" Then
                        If Not IsStrExp(bstack, rest$, s$, False) Then
                            GoTo there
                        End If
q1239877:
                        If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                                If IsLabelSymbolNew(rest$, "цяалла", "STRING", Lang) Then
                                    pp = -4
                                Else
                                    SyntaxError
                 
                                   GoTo there
                                End If
                                                          
                            End If
                        
                        If Not bstack.lastobj Is Nothing Then
                        
                         MyEr "No objects for buffer", "╪ВИ АМТИЙЕъЛЕМА ЦИА дИэЯХЯЫСГ"
                            GoTo there
                            
                        Else
                                If Addr = 0 Then
                                    
                                    GoTo err30
                                Else
                            ' here is the part where we copy a string to memblock
                            Err.Clear
                            On Error Resume Next
                          If pp < 0 Or bb1.WhatIsBasicItem = vbString Then
                          If bb1.ValidArea(Addr, 4) Then
                          ChangeValuesMem = True
                            PutMem4 Addr, CLng(bb1.PutStringAtOffset(Addr, s$))
                          End If
                          Else
                      
                           If bb1.ValidArea(Addr, LenB(s$)) Then
                           ChangeValuesMem = True
                           CopyBytes LenB(s$), Addr, StrPtr(s$)
                     
                           Else
                            GoTo err10
                           
                           End If
                        End If
                           If Err <> 0 Then
                           ChangeValuesMem = False
                           GoTo err20
                           
                           End If
                            
                            End If
                        
                        End If
                Else
                        MyEr "No Data found", "дЕМ БЯщХГЙАМ СТОИВЕъА"
                       GoTo there
                End If
                End If
        End If
    Loop


there:

Set bb1 = Nothing
Set aa = Nothing
Exit Function
err10:
MyEr "Buffer is small", "г дИэЯХЯЫСГ ЕъМАИ ЛИЙЯч"
GoTo there
err20:
MyEr "Overflow. Problem in Buffer", "уПЕЯВЕъКИСГ. пЯЭБКГЛА СТГ дИэЯХЯЫСГ"
GoTo there
err30:
MyEr "оffset Null or not for buffer", "дИЕЩХУМСГ 0 ч ЕЙТЭР дИэЯХЯЫСГР"
GoTo there
End Function


Public Function CopyArray(A As Object) As Variant
 Dim pppp1 As mArray
     Set pppp1 = New mArray
     A.CopyArray pppp1
     Set A = Nothing
     Set CopyArray = pppp1
     Set pppp1 = Nothing
End Function

Function IsHalfLogic(bstack As basetask, aa$, po As Variant) As Boolean
Dim r As Variant, I As Long
Dim that As BigInteger, thatone As BigInteger
If MemInt(VarPtr(po)) = vbObject Then
Set thatone = po
po = 0
End If
If Len(aa$) > 0 Then
I = MyTrimL(aa$)
    If Mid$(aa$, I, 3) = "<=>" Then MyEr "<=> not supported in case", "О ТЕКЕСТчР <=> ДЕМ УПОСТГЯъФЕТАИ СТГ лЕ": Exit Function
Else
Exit Function
End If
If MemInt(VarPtr(po)) = vbString Then
    IsHalfLogic = True
    If Not logicalSelect(bstack, aa$, po, True) Then
        IsHalfLogic = False
        Exit Function
    End If
ElseIf FastSymbol1(aa$, "=") Then
    IsHalfLogic = True
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If IsExpA(bstack, aa$, r, 0, False) Then
            If Not bstack.lastobj Is Nothing Then
                GoTo CONT1234
            Else
                If MemInt(VarPtr(r)) = vbBoolean Then
                    po = r
                Else
                    If r = 0 Then
                        If po = 0 Then
                            po = True
                        Else
                            po = MyRound(po, 13) = 0
                        End If
                    Else
                        po = MyRound(((po - r) / r), 10) = 0
                    End If
                End If
            End If
        Else
            IsHalfLogic = False
            Exit Function
        End If
    ElseIf IsExpA(bstack, aa$, r, 0, False) Then
            If Not bstack.lastobj Is Nothing Then
CONT1234:
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set that = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    If Not thatone Is Nothing Then
                        po = that.compare(thatone) = 0
                    Else
                        If MemInt(VarPtr(po)) = vbString Then
                            po = that.compare(Module13.CreateBigInteger(CStr(po))) = 0
                        Else
                            po = that.compare(Module13.CreateBigInteger(CStr(Int(po)))) = 0
                        End If
                    End If
                ElseIf Not thatone Is Nothing Then
                    If MemInt(VarPtr(r)) = vbString Then
                        po = thatone.compare(Module13.CreateBigInteger(CStr(r))) = 0
                    Else
                        po = thatone.compare(Module13.CreateBigInteger(CStr(Int(r)))) = 0
                    End If
                
                Else
                    GoTo conterr
                End If
            Else
                If MemInt(VarPtr(r)) = vbBoolean Then
                    po = r
                Else
                    po = CBool(po = r)
                End If
            End If
    Else
        MissNumExpr
        IsHalfLogic = False
        Exit Function
    End If
ElseIf FastSymbol1(aa$, "<") Then
    IsHalfLogic = True
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If IsExpA(bstack, aa$, r, 0, False) Then
            If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set that = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    If Not thatone Is Nothing Then
                        po = that.compare(thatone) > -1
                    Else
                        If MemInt(VarPtr(po)) = vbString Then
                            po = that.compare(Module13.CreateBigInteger(CStr(po))) > -1
                        Else
                            po = that.compare(Module13.CreateBigInteger(CStr(Int(po)))) > -1
                        End If
                    End If
                Else
                    GoTo conterr
                End If
            ElseIf Not thatone Is Nothing Then
                If MemInt(VarPtr(r)) = vbString Then
                    po = thatone.compare(Module13.CreateBigInteger(CStr(r))) < 1
                Else
                    po = thatone.compare(Module13.CreateBigInteger(CStr(Int(r)))) < 1
                End If
            Else
                If MemInt(VarPtr(r)) = vbBoolean Then
                    po = r
                Else
                    po = po <= r
                End If
            End If
        Else
            MissNumExpr
            IsHalfLogic = False
            Exit Function
        End If
    ElseIf Left$(aa$, 1) = ">" Then
        Mid$(aa$, 1, 1) = " "
        If IsExpA(bstack, aa$, r, 0, False) Then
            If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set that = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    If Not thatone Is Nothing Then
                    po = that.compare(thatone) <> 0
                    Else
                        If MemInt(VarPtr(po)) = vbString Then
                            po = that.compare(Module13.CreateBigInteger(CStr(po))) <> 0
                        Else
                            po = that.compare(Module13.CreateBigInteger(CStr(Int(po)))) <> 0
                        End If
                    End If
                Else
                    GoTo conterr
                End If
            ElseIf Not thatone Is Nothing Then
                If MemInt(VarPtr(r)) = vbString Then
                    po = thatone.compare(Module13.CreateBigInteger(CStr(r))) <> 0
                Else
                    po = thatone.compare(Module13.CreateBigInteger(CStr(Int(r)))) <> 0
                End If

            Else
                If MemInt(VarPtr(r)) = vbBoolean Then
                    po = r
                Else
                    po = po <> r
                End If
            End If
        Else
            MissNumExpr
            IsHalfLogic = False
            Exit Function
        End If
    ElseIf IsExpA(bstack, aa$, r, 0, False) Then
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is BigInteger Then
                Set that = bstack.lastobj
                Set bstack.lastobj = Nothing
                If Not thatone Is Nothing Then
                    po = that.compare(thatone) = 1
                Else
                    If MemInt(VarPtr(po)) = vbString Then
                        po = that.compare(Module13.CreateBigInteger(CStr(po))) = 1
                    Else
                        po = that.compare(Module13.CreateBigInteger(CStr(Int(po)))) = 1
                    End If
                End If
            ElseIf Not thatone Is Nothing Then
                If MemInt(VarPtr(r)) = vbString Then
                    po = thatone.compare(Module13.CreateBigInteger(CStr(r))) = -1
                Else
                    po = thatone.compare(Module13.CreateBigInteger(CStr(Int(r)))) = -1
                End If

            Else
                GoTo conterr
            End If
        Else
            If MemInt(VarPtr(r)) = vbBoolean Then
                po = r
            Else
                po = po < r
            End If
        End If
    Else
        MissNumExpr
        IsHalfLogic = False
        Exit Function
    End If
'///////////////////////////////////////////////////////////
ElseIf FastSymbol1(aa$, ">") Then
    IsHalfLogic = True
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If IsExpA(bstack, aa$, r, 0, False) Then
            If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set that = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    If Not thatone Is Nothing Then
                        po = that.compare(thatone) < 1
                    Else
                        If MemInt(VarPtr(po)) = vbString Then
                            po = that.compare(Module13.CreateBigInteger(CStr(po))) < 1
                        Else
                            po = that.compare(Module13.CreateBigInteger(CStr(Int(po)))) < 1
                        End If
                    End If
                Else
                    GoTo conterr
                End If
            ElseIf Not thatone Is Nothing Then
                If MemInt(VarPtr(r)) = vbString Then
                    po = thatone.compare(Module13.CreateBigInteger(CStr(r))) > -1
                Else
                    po = thatone.compare(Module13.CreateBigInteger(CStr(Int(r)))) > -1
                End If
            Else
                If MemInt(VarPtr(r)) = vbBoolean Then
                    po = r
                Else
                    po = po >= r
                End If
            End If
        Else
            MissNumExpr
            IsHalfLogic = False
            Exit Function
        End If
    ElseIf IsExpA(bstack, aa$, r, 0, False) Then    ' true, true
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is BigInteger Then
                Set that = bstack.lastobj
                Set bstack.lastobj = Nothing
                If Not thatone Is Nothing Then
                    po = that.compare(thatone) = -1
                Else
                    If MemInt(VarPtr(po)) = vbString Then
                        po = that.compare(Module13.CreateBigInteger(CStr(po))) = -1
                    Else
                        po = that.compare(Module13.CreateBigInteger(CStr(Int(po)))) = -1
                    End If
                End If
            ElseIf Not thatone Is Nothing Then
                If MemInt(VarPtr(r)) = vbString Then
                    po = thatone.compare(Module13.CreateBigInteger(CStr(r))) = 1
                Else
                    po = thatone.compare(Module13.CreateBigInteger(CStr(Int(r)))) = 1
                End If

            Else
                GoTo conterr
            End If
        Else
            If MemInt(VarPtr(r)) = vbBoolean Then
                po = r
            Else
                po = po > r
            End If
        End If
    Else
conterr:
        MissNumExpr
        IsHalfLogic = False
        Exit Function
    End If
Else
    IsHalfLogic = False
    Exit Function
End If
again2:
If Fast2Label(aa$, "OR", 2, "г", 1, 2) Then
        If priorityOr Then
            If IsExp(bstack, aa$, r, , True) Then
                If po <> 0 Then po = -1
                If r <> 0 Then r = -1
                po = po Or r
                GoTo again2
            Else
                MissLogicalExpr
                IsHalfLogic = False
                Exit Function
            End If
        Else
            If IsExp(bstack, aa$, r, False, True) Then
                If po <> 0 Then po = -1
                If r <> 0 Then r = -1
                po = po Or r
                GoTo again2
            Else
                MissLogicalExpr
                IsHalfLogic = False
                Exit Function
            End If
        End If
 ElseIf Fast2Label(aa$, "AND", 3, "йаи", 3, 3) Then
        If IsExp(bstack, aa$, r, False, True) Then
            If po <> 0 Then po = -1
            If r <> 0 Then r = -1
            po = po And r
            GoTo again2
        Else
            MissLogicalExpr
            IsHalfLogic = False
            Exit Function
        End If
End If

End Function

Public Function kUpper(A$, p As Variant) As String
'idea from Bonnie West, FROM VBFORUMS
Dim nSize As Long
    nSize = Len(A$)
    If nSize Then SysReAllocStringLen VarPtr(kUpper), , nSize Else Exit Function
    Const LCMAP_UPPERCASE = &H200&
Dim mLid As Long
If p = 0 Then
mLid = Clid
Else
mLid = p
End If
If p = 1032 Then
If osnum >= System_Windows_Vista Then A$ = Replace(A$, "Р", "с")
Dim I As Long
For I = 1 To Len(A$)
Select Case AscW(Mid$(A$, I, 1))
Case 902
Mid$(A$, I, 1) = ChrW(913)
Case 904
Mid$(A$, I, 1) = ChrW(917)
Case 906
Mid$(A$, I, 1) = ChrW(921)
Case 912
Mid$(A$, I, 1) = ChrW(921)
Case 905
Mid$(A$, I, 1) = ChrW(919)
Case 908
Mid$(A$, I, 1) = ChrW(927)
Case 911
Mid$(A$, I, 1) = ChrW(937)
Case 910
Mid$(A$, I, 1) = ChrW(933)
Case 940
Mid$(A$, I, 1) = ChrW(913)
Case 941
Mid$(A$, I, 1) = ChrW(917)
Case 943
Mid$(A$, I, 1) = ChrW(921)
Case 942
Mid$(A$, I, 1) = ChrW(919)
Case 972
Mid$(A$, I, 1) = ChrW(927)
Case 974
Mid$(A$, I, 1) = ChrW(937)
Case 973
Mid$(A$, I, 1) = ChrW(933)
Case 962
If osnum >= System_Windows_Vista Then
Mid$(A$, I, 1) = ChrW(963)
Else
Mid$(A$, I, 1) = ChrW(931)
End If
End Select

Next I
End If
    nSize = LCMapStringW(mLid, LCMAP_UPPERCASE, StrPtr(A$), nSize, StrPtr(kUpper), nSize)
End Function

Public Function kUpper2(A$, p As Variant) As String
'idea from Bonnie West, FROM VBFORUMS
Dim nSize As Long
    nSize = Len(A$)
    If nSize Then SysReAllocStringLen VarPtr(kUpper2), , nSize Else Exit Function
    Const LCMAP_UPPERCASE = &H200&
Dim mLid As Long
If p = 0 Then
mLid = Clid
Else
mLid = p
End If
If p = 1032 Then
''If osnum >= System_Windows_Vista Then a$ = Replace(a$, "Р", "с")
Dim I As Long
For I = 1 To Len(A$)
 Select Case AscW(Mid$(A$, I, 1))
Case 902
Mid$(A$, I, 1) = ChrW(913)
Case 904
Mid$(A$, I, 1) = ChrW(917)
Case 906
Mid$(A$, I, 1) = ChrW(921)
Case 912
Mid$(A$, I, 1) = ChrW(921)
Case 905
Mid$(A$, I, 1) = ChrW(919)
Case 908
Mid$(A$, I, 1) = ChrW(927)
Case 911
Mid$(A$, I, 1) = ChrW(937)
Case 910
Mid$(A$, I, 1) = ChrW(933)
Case 940
Mid$(A$, I, 1) = ChrW(913)
Case 941
Mid$(A$, I, 1) = ChrW(917)
Case 943
Mid$(A$, I, 1) = ChrW(921)
Case 942
Mid$(A$, I, 1) = ChrW(919)
Case 972
Mid$(A$, I, 1) = ChrW(927)
Case 974
Mid$(A$, I, 1) = ChrW(937)
Case 973
Mid$(A$, I, 1) = ChrW(933)
Case 962
Mid$(A$, I, 1) = ChrW(931)
End Select
Next I


End If
    nSize = LCMapStringW(mLid, LCMAP_UPPERCASE, StrPtr(A$), nSize, StrPtr(kUpper2), nSize)
End Function
Public Function klower(A$, p As Variant) As String
Const LCMAP_LOWERCASE As Long = &H100
Dim nSize As Long
    nSize = Len(A$)
    If nSize Then SysReAllocStringLen VarPtr(klower), , nSize Else Exit Function

Dim mLid As Long
If p = 0 Then
mLid = Clid
Else
mLid = p
End If
nSize = LCMapStringW(mLid, LCMAP_LOWERCASE, StrPtr(A$), nSize, StrPtr(klower), nSize)
A$ = klower
If p = 1032 Then
A$ = A$ + Chr(0)
A$ = Replace(A$, "С" + Chr(0), "Р")
A$ = Replace(A$, Chr(0), "")
A$ = Replace(A$, "С ", "Р ")
A$ = Replace(A$, "С$", "Р$")
A$ = Replace(A$, "С&", "Р&")
A$ = Replace(A$, "С.", "Р.")
A$ = Replace(A$, "С(", "Р(")
A$ = Replace(A$, "С_", "Р_")
A$ = Replace(A$, "С/", "Р/")
A$ = Replace(A$, "С\", "Р\")
A$ = Replace(A$, "С-", "Р-")
A$ = Replace(A$, "С+", "Р+")
A$ = Replace(A$, "С*", "Р*")
A$ = Replace(A$, "С" + vbCr, "Р" + vbCr)
A$ = Replace(A$, "С" + vbLf, "Р" + vbLf)
End If
klower = A$
End Function




Sub processAcAndPo(ac, po)
    On Error GoTo 100
    If TypeOf ac Is cxComplex Then
        If MemInt(VarPtr(po)) = 36 Then
            If Not TypeOf po Is cxComplex Then Exit Sub
            ac = cxStabTwo("cxAdd", ac, po)
        ElseIf myVarType(po, vbString) Then
            ac = fixthis(ac) + po
        Else
            ac = cxStabTwo("cxAddREAL", ac, po)
        End If
    ElseIf ac = 0 Then
        If myVarType(po, vbString) Then
            SwapVariant ac, po
        Else
            ac = po
        End If
    Else
        ac = ac + po
    End If
    Exit Sub
100
     On Error GoTo 200
     If Err.Number = 6 Then
        Err.Clear
        ac = CDbl(ac) + CDbl(po)
        Err.Clear
    End If
200
End Sub
Sub processNegateNonZero(acpor)
    If TypeOf acpor Is cxComplex Then
        If acpor.r = 0 And acpor.r = 0 Then
            acpor = -True
        Else
            acpor = False
        End If
    ElseIf acpor <> 0 Then
        acpor = True
    Else
        acpor = False
    End If
End Sub
Sub processAcAndPoSimple(ac, po)
    If TypeOf ac Is cxComplex Then
        If MemInt(VarPtr(po)) = 36 Then
            If Not TypeOf po Is cxComplex Then Exit Sub
            po = cxStabTwo("cxAdd", ac, po)
        ElseIf myVarType(po, vbString) Then
            po = fixthis(ac) + po
        Else
            po = cxStabTwo("cxAddREAL", ac, po)
        End If
    ElseIf ac <> 0 Then
        If myVarType(po, vbString) Then
            If myVarType(ac, vbString) Then
                po = ac + po
            Else
                po = fixthis(ac) + po
            End If
        Else
            po = ac + po
        End If
    End If
    ac = 0
End Sub
Public Sub PushStage(basestack As basetask, dummy As Boolean)
' FROM 5 TO 3 REDUCE STACK USAGE
        With basestack.RetStack
               basestack.SubLevel = basestack.SubLevel + 1
                If dummy Then
                        .Push2long 0&, 0&
                        .Push2long 0&, 0&
                        .PushLong -2&
                        
                Else
                        .Push2long varhash.count, subHash.count
                        .Push2long var2used, sb2used
                        .PushLong -1&
                        numid.pushtop
                        funid.pushtop
                        strfunid.pushtop
                        funid.pushtop
                        basestack.ErrVars = var2used
                        basestack.SetSkip
                End If
        End With
       
End Sub
Public Sub PopStage(basestack As basetask)
        Dim one As Long
        With basestack.RetStack
        If .LookTopVal = -1 Then
        basestack.SubLevel = basestack.SubLevel - 1
           .drop 1
            var2used = .Pop2Long(sb2used)
            basestack.ErrVars = var2used
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            numid.poptop
            funid.poptop
            strfunid.poptop
            strid.poptop
        ElseIf .LookTopVal = -2 Then
        basestack.SubLevel = basestack.SubLevel - 1
        .drop 3  ' not 5
        End If
        End With
End Sub
Public Sub PushErrStage(basestack As basetask)
        With basestack.RetStack
            .Push2long varhash.count, subHash.count
            .Push2long basestack.SubLevel, sb2used
            .PushVal var2used
            .PushVal -4  ' from 6 to 4 entries
             basestack.ErrVars = var2used
        End With
End Sub
Public Sub PopErrStage(basestack As basetask)
Dim nok As Boolean, one As Long
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
            basestack.SubLevel = .Pop2Long(sb2used)
            var2used = basestack.ErrVars
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            Else
            .drop 2  ' not 4
            End If
        Else

        While basestack.RetStackTotal > 0
        Select Case .LookTopVal
        Case -1
            nok = True
        .drop 5  ' 7-2 reduced
        basestack.ResetSkip
        Case -2
            nok = True
            .drop 3 ' 5 - 2 reduced ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
         .drop 2  ' string in topval (gosub to label)
             nok = True
        End Select
        Wend
        End If
        End With
End Sub
Public Sub PopStagePartContinue(basestack As basetask, Parts As Long)
' drop until find a If
Dim nok As Boolean, target As Long, one As Long
        target = basestack.RetStackTotal - Parts
        If target < 0 Then target = 0
        While basestack.RetStackTotal > target
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
            basestack.SubLevel = .Pop2Long(sb2used)
            var2used = basestack.ErrVars
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            Else
            .drop 2 ' not 4
            End If
        Else

        While basestack.RetStackTotal > target
        Select Case .LookTopVal
        Case -1
            nok = True
        .drop 5 ' 7-2 reduced
        basestack.ResetSkip
        Case -2
            nok = True
            .drop 3 '5-2 reduced  ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
            Exit Sub
        End Select
        Wend
        End If
        End With
        Wend
End Sub
Public Sub PopStagePartContinue2(basestack As basetask, Parts As Long)
' drop until find a If
Dim nok As Boolean, target As Long, one As Long
        target = basestack.RetStackTotal - Parts
        If target < 0 Then target = 0
        While basestack.RetStackTotal > target
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
            basestack.SubLevel = .Pop2Long(sb2used)
            var2used = basestack.ErrVars
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            basestack.ResetSkip
            Else
            .drop 2
            End If
        Else

        While basestack.RetStackTotal > target
        Select Case .LookTopVal
        Case -1
            Exit Sub
        Case -2
            nok = True
            .drop 3  ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
            Exit Sub
        End Select
        Wend
        End If
        End With
        Wend
End Sub

Public Sub PopStagePart(basestack As basetask, Parts As Long)
Dim nok As Boolean, target As Long
        target = basestack.RetStackTotal - Parts
        If target < 0 Then target = 0
        While basestack.RetStackTotal > target
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
           basestack.SubLevel = CLng(.PopVal)
            var2used = basestack.ErrVars
            sb2used = CLng(.PopVal)
            varhash.ReduceHash CLng(.PopVal), var()
            subHash.ReduceHash CLng(.PopVal), sbf()
            Else
            .drop 4
            End If
        Else

        While basestack.RetStackTotal > target
        Select Case .LookTopVal
        Case -1
            nok = True
        .drop 7
        Case -2
            nok = True
            .drop 5  ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
         .drop 2  ' string in topval (gosub to label)
             nok = True
        End Select
        Wend
        End If
        End With
        Wend
End Sub


Public Function GetNextLineNoTrim(c$) As String
Dim I, j$
I = InStr(c$, vbCrLf)
If I = 0 Then GetNextLineNoTrim = c$: c$ = vbNullString Else GetNextLineNoTrim = Left$(c$, I - 1): c$ = Mid$(c$, I)
End Function

Function expanddot(bstack As basetask, W$) As Boolean
Dim I As Integer, j As Long
For I = 1 To Len(W$)
If Mid$(W$, I, 1) = "." Then
    j = j + 1
Else
    Exit For
End If
Next I
W$ = Mid$(W$, j + 1)
If bstack.GetDotNew(W$, j) Then
If Len(here$) > 0 Then
'If j = 1 Then
If Len(W$) > Len(here$) Then
    If Left$(W$, Len(here$) + 1) = here$ + "." Then W$ = Mid$(W$, Len(here$) + 2)
  
End If
'End If
End If
expanddot = True
End If

End Function


Public Sub ProcessOper(bstack As basetask, first As Object, oper$, r As Variant, Lang As Long, Optional skip As Boolean = False)
Dim where As Long, W$, ok As Boolean
Dim soroslen As Long, flag As Boolean, backup As Object, oldkillvars As Boolean
flag = Not first Is Nothing
'Dim buser As String
oldkillvars = bstack.nokillvars
If oper$ = "''" Then
'buser = bstack.UseGroupname
'bstack.UseGroupname = ""
bstack.nokillvars = True
End If
If Not oldkillvars Then PushStage bstack, False

soroslen = bstack.soros.Total
If soroslen < 0 Then SyntaxError: Exit Sub
' if flag Then bstack.soros.PushObj first
' change in Version 9.2 revision 3
 If flag Then
 Set bstack.lastpointer = Nothing ' this was a very difficult bug
 Set backup = bstack.lastobj
 bstack.soros.PushObj bstack.lastobj
 Set bstack.lastobj = first
 End If
where = AllocVar()  '' var(where)
W$ = ChrW(&H1FFF) & (where)
If here$ <> "" Then
varhash.ItemCreator here$ + "." + bstack.GroupName + W$, where
UnFloatGroup bstack, W$, where, bstack.lastobj, , True
Else
varhash.ItemCreator (W$), where
UnFloatGroup bstack, W$, where, bstack.lastobj, True, True
End If
var(where).FloatGroupName = W$
 If oper$ = "''" Then
    ok = MyRead(1, bstack, (W$), Lang)
 Else
    NeoCall2 bstack, W$ + "." + ChrW(&H1FFF) + oper$ + "()", ok
End If
If soroslen < bstack.soros.Total Then
    If soroslen + 1 = bstack.soros.Total And flag Then
    r = bstack.soros.PopVal
   If ok Or skip Then
   Set bstack.lastobj = Nothing
   ElseIf flag Then
   ' when we add two groups which we don't define operator now set result as the last group
       Set bstack.lastobj = backup
   End If
    bstack.DropNdot 2
    bstack.nokillvars = oldkillvars
    If Not oldkillvars Then PopStage bstack ': bstack.UseGroupname = buser
    Exit Sub
    End If
End If
If ok And Not skip Then Set bstack.lastobj = CopyGroupObj(var(where)) Else Set bstack.lastobj = Nothing
bstack.DropNdot 2
bstack.nokillvars = oldkillvars
If Not oldkillvars Then
PopStage bstack ': bstack.UseGroupname = buser
End If
End Sub
Public Sub ProcessOperRemove(first As Group)
Dim where As Long, W$, ok As Boolean
Dim soroslen As Long, flag As Boolean, backup As Object
Dim bstack As New basetask, ohere$
SwapStrings ohere$, here$
Set bstack.Sorosref = New mStiva
Set bstack.Owner = Form1.DIS
PushStage bstack, False
where = AllocVar()  '' var(where)
W$ = ChrW(&H1FFF) & (where)
'If here$ <> "" Then
'varhash.ItemCreator here$ + "." + w$, where
'UnFloatGroup bstack, w$, where, bstack.lastobj, , True
'Else
varhash.ItemCreator (W$), where, , True
Set bstack.lastobj = first
UnFloatGroup bstack, W$, where, bstack.lastobj, True, True
'End If
var(where).FloatGroupName = W$
NeoCall2 bstack, W$ + "." + ChrW(&H1FFF) + "_%()", ok
PopStage bstack
SwapStrings ohere$, here$
End Sub


Function SizeY(bstack As basetask, A$, s$, s1$, r As Variant) As Boolean
Dim R2 As Variant, R3 As Variant, R4 As Variant
    R3 = 0
    R4 = 0
    If IsStrExp(bstack, A$, s$, False) Then
    If Not FastSymbol(A$, ",") Then: MissParam A$: SizeY = False: Exit Function
    If Not IsStrExp(bstack, A$, s1$, False) Then: MissParam A$: SizeY = False: Exit Function
    If Not FastSymbol(A$, ",") Then: MissParam A$: SizeY = False: Exit Function
    If Not IsExp(bstack, A$, R2, , True) Then: MissParam A$: SizeY = False: Exit Function
    If FastSymbol(A$, ",") Then
        If Not IsExp(bstack, A$, R3, , True) Then
             MissParam A$: SizeY = False: Exit Function
        End If
            If FastSymbol(A$, ",") Then
                If Not IsExp(bstack, A$, R4, , True) Then
                    MissParam A$: SizeY = False: Exit Function
                End If
                R4 = Abs(Int(R4))
            End If
        End If
    On Error Resume Next
    r = nTextY(bstack, s$, s1$, CSng(R2), R3, R4)
    If Err.Number > 0 Then r = 0
    On Error GoTo 0
    SizeY = FastSymbol(A$, ")", True)
    End If
End Function

Function SizeX(bstack As basetask, A$, s$, s1$, r As Variant) As Boolean
Dim R2 As Variant, R3 As Variant, R4 As Variant
    R3 = 0
    R4 = 0
    If IsStrExp(bstack, A$, s$, False) Then
    If Not FastSymbol(A$, ",") Then SizeX = False: Exit Function
    If Not IsStrExp(bstack, A$, s1$, False) Then SizeX = False: Exit Function
    If Not FastSymbol(A$, ",") Then SizeX = False: Exit Function
    If Not IsExp(bstack, A$, R2, , True) Then SizeX = False: Exit Function
    If FastSymbol(A$, ",") Then
        If Not IsExp(bstack, A$, R3, , True) Then
           MissParam A$: SizeX = False: Exit Function
        End If
            If FastSymbol(A$, ",") Then
                If Not IsExp(bstack, A$, R4, , True) Then
                    MissParam A$: SizeX = False: Exit Function
                End If
                R4 = Abs(Int(R4))
            End If
    End If
    On Error Resume Next
    r = nText(bstack, s$, s1$, CSng(R2), R3, R4)
    If Err.Number > 0 Then r = 0
    On Error GoTo 0
    SizeX = FastSymbol(A$, ")", True)
    End If

End Function

Public Function SpeedGroup(bstack As basetask, pppp As iBoxArray, Prefix$, ByVal W$, b$, v As Long) As Long
Dim Vars As Long, Vname As Long, y1 As Long, subs As Long, snames As Long, I As Long, ec$, ohere$, p As Long
Dim depth As Long, loopthis As Boolean, v100 As Boolean, RetStackSize As Long, S3 As Long, rest1$
Dim safegroup As Group
Dim oldjump As Long, oldifctrl As Long, olduseofif As Long
Dim kolpo As Boolean, bb$, once As Boolean, subsfc As FastCollection
Dim Lang As Long, ok As Boolean, rv As Variant
Dim small$, sbi As Long
bstack.SetSkip
Vars = var2used: Vname = varhash.count
subs = sb2used: snames = subHash.count
numid.pushtop
funid.pushtop
strfunid.pushtop
funid.pushtop
Dim mm As mStiva2, tempRef As Object
If Prefix = "VAL" Then
' we stand as right value...
    If pppp Is Nothing Then GoTo fastexit
    ec$ = W$ + ")"
    If v >= 0 Then
        W$ = pppp.CodeName & (v)
    Else
        W$ = pppp.CodeName & (Abs(v))
    End If
    If Len(pppp.item(v).LastOpen) > 0 Then
        If GetVar(bstack, pppp.item(v).LastOpen, I) Then
jmp1995:
            Set safegroup = var(I)
            If safegroup.lasthere = here$ Then
                W$ = safegroup.GroupName
                W$ = Left$(W$, Len(W$) - 1)
            Else
                LinkGroup bstack, W$, var(I)
                makegroup bstack, W$, I
            End If
            bstack.tmpstr = W$ + Left$(b$, 1)
            BackPort b$
            If IsNumberNew(bstack, b$, rv, False) Then
                bstack.LastValue = rv
                SpeedGroup = 1
            End If
            GoTo fastexit
        End If
    End If
    
    If Not MyIsObject(pppp.item(v)) Then
        GoTo fastexit
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
    If safegroup.IamApointer Then
        If Len(safegroup.lasthere) > 0 And Len(safegroup.GroupName) > 0 Then
            W$ = safegroup.lasthere + "." + safegroup.GroupName
            bstack.tmpstr = W$ + Left$(b$, 1)
            BackPort b$
            If Not IsNumberNew(bstack, b$, rv, False) Then SpeedGroup = 0: GoTo fastexit1
            bstack.LastValue = rv
            SpeedGroup = 1
            GoTo fastexit
        End If
        If safegroup.link.LastOpen <> vbNullString Then
            If GetVar(bstack, safegroup.link.LastOpen, I) Then GoTo jmp1995
        ElseIf safegroup.LastOpen <> vbNullString Then
            If GetVar(bstack, (safegroup.LastOpen), y1, True) Then
                If safegroup.lasthere$ = here$ Then
                    W$ = safegroup.LastOpen
                Else
                    If safegroup.lasthere$ = vbNullString Then
                        W$ = safegroup.LastOpen
                    Else
                        W$ = safegroup.lasthere$ + "." + safegroup.LastOpen
                    End If
                End If
                Set safegroup = safegroup.link
                GoTo cont3030
            Else
                safegroup.lasthere = vbNullString
                safegroup.LastOpen = vbNullString
            End If
        End If
        y1 = globalvarGroup(W$, 0#, , here$ = vbNullString)
        Set safegroup = safegroup.link
        UnFloatGroup bstack, W$, y1, safegroup, , True
        globalvarGroup W$, y1, True, True
cont3030:
    Else
        If Len(safegroup.LastOpen) > 0 Then
            If Not GetVar(bstack, safegroup.LastOpen, y1, True) Then
                GoTo fastexit
            End If
            GoTo conthere0001
        End If
        y1 = globalvarGroup(W$, 0#, , here$ = vbNullString)
        If Not safegroup.IamFloatGroup Then
            Set safegroup = CopyGroupObj(safegroup)
        ElseIf safegroup.IamApointer Then
            Set safegroup = CopyGroupObj(safegroup.link)
        End If
        UnFloatGroup bstack, W$, y1, safegroup, , True
        var(y1).FloatGroupName = ec$
        globalvarGroup W$, y1, True, True
    End If
    Set safegroup = pppp.item(v)
conthere0001:
    If Left$(b$, 1) <> "." And Left$(b$, 1) <> "(" And var(y1).HasParameters Then
        bstack.tmpstr = W$ + "(" + Left$(b$, 1)
    Else
        bstack.tmpstr = W$ + Left$(b$, 1)
    End If
    BackPort b$
    If IsNumberNew(bstack, b$, rv, False) Then
        SpeedGroup = 1
        If pppp.Arr Then
            If safegroup.IamApointer Then
                Set tempRef = pppp.GroupRef
                safegroup.link.ToDelete = True
                Set safegroup.LinkRef = CopyGroupObj(var(y1))
                Set safegroup.link.LinkRef = pppp.GroupRef
            Else
                Set tempRef = pppp.GroupRef   'pppp.item(v).Link
                pppp.item(v).ToDelete = True
                Set pppp.item(v) = CopyGroupObj(var(y1))
                If TypeOf pppp.itemObject(v) Is Group Then Set pppp.item(v).LinkRef = pppp.GroupRef
            End If
        Else
            If safegroup.IamApointer Then
                CopyGroup1 var(y1), safegroup.link
                If v >= 0 Then
                    Set bstack.lastpointer = safegroup
                    Set bstack.lastobj = safegroup.link
                End If
            Else
                CopyGroup1 var(y1), safegroup
            End If
        End If
        If bstack.lastobj Is Nothing Then
            bstack.LastValue = rv
        Else
            bstack.LastValue = 0#
            GoTo fastexit
        End If
    Else
    SpeedGroup = -1
    MyEr "No Property/member found", "дЕМ БЯчЙА ИДИЭТГТА/ЛЕКОР"
    End If
    Set bstack.lastobj = Nothing
    GoTo fastexit
ElseIf Prefix = "VAL$" Then
    ec$ = W$ + ")"
    If v >= 0 Then
        W$ = pppp.CodeName & (v)
    Else
        W$ = pppp.CodeName & (Abs(v))
    End If
    If Len(pppp.item(v).LastOpen) > 0 Then
        If GetVar(bstack, pppp.item(v).LastOpen, I) Then
jmp2000:
            Set safegroup = var(I)
            If safegroup.lasthere = here$ Then
                W$ = safegroup.GroupName
                W$ = Left$(W$, Len(W$) - 1)
            Else
                LinkGroup bstack, W$, var(I)
                makegroup bstack, W$, I
            End If
            bstack.tmpstr = W$ + Left$(b$, 1)
            BackPort b$
            If IsStr1(bstack, b$, bb$) Then
                bstack.LastValue = bb$
                SpeedGroup = 1
            End If
            GoTo fastexit
        End If
    End If
    If Not MyIsObject(pppp.item(v)) Then
        GoTo fastexit
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
    If safegroup.IamApointer Then
        If Len(safegroup.lasthere) > 0 And Len(safegroup.GroupName) > 0 Then
            W$ = safegroup.lasthere + "." + safegroup.GroupName
            bstack.tmpstr = W$ + Left$(b$, 1)
            BackPort b$
            If Not IsStr1(bstack, b$, bb$) Then SpeedGroup = 0: GoTo fastexit1
            bstack.LastValue = bb$
            SpeedGroup = 1
            GoTo fastexit
        End If
        If safegroup.link.LastOpen <> vbNullString Then
            If GetVar(bstack, safegroup.link.LastOpen, I) Then GoTo jmp2000
        ElseIf safegroup.LastOpen <> vbNullString Then
            If GetVar(bstack, (safegroup.LastOpen), y1, True) Then
                If safegroup.lasthere$ = here$ Then
                    W$ = safegroup.LastOpen
                Else
                    If safegroup.lasthere$ = vbNullString Then
                        W$ = safegroup.LastOpen
                    Else
                        W$ = safegroup.lasthere$ + "." + safegroup.LastOpen
                    End If
                End If
                Set safegroup = safegroup.link  '' ADDED rev 6 ver 9.8
                GoTo cont5050
            Else
                safegroup.lasthere = vbNullString '' ADDED rev 6 ver 9.8
                safegroup.LastOpen = vbNullString
            End If
        End If
        y1 = globalvarGroup(W$, 0#, , here$ = vbNullString) '' fix it rev 6 ver 9.8
        Set safegroup = safegroup.link
        UnFloatGroup bstack, W$, y1, safegroup, , True
        var(y1).FloatGroupName = W$
        globalvarGroup W$, y1, True, True
cont5050:
    Else
        If Len(safegroup.LastOpen) > 0 Then
            If Not GetVar(bstack, safegroup.LastOpen, y1, True) Then
                GoTo fastexit
            End If
            GoTo conthere000
        End If
        y1 = globalvarGroup(W$, 0#, , here$ = vbNullString)
        If Not safegroup.IamFloatGroup Then
            Set safegroup = CopyGroupObj(safegroup)
        ElseIf safegroup.IamApointer Then
            Set safegroup = CopyGroupObj(safegroup.link)
        End If
        UnFloatGroup bstack, W$, y1, safegroup, , True
        var(y1).FloatGroupName = ec$
        globalvarGroup W$, y1, True, True
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
conthere000:
    If Left$(b$, 1) = "." Then
        bstack.tmpstr = W$ + Left$(b$, 1)
        BackPort b$
        Set bstack.lastpointer = Nothing
        If IsStr1(bstack, b$, bb$) Then GoTo conthere
    ElseIf var(y1).HasValue Then
        If var(y1).HasParameters Then
            If pppp.Arr Then
                If Left$(b$, 1) = "(" Then
                     bstack.tmpstr = W$ + "$" + Left$(b$, 1)
                Else
                    bstack.tmpstr = W$ + "$(" + Left$(b$, 1)
                End If
                BackPort b$
                Set bstack.lastpointer = Nothing
                If IsStr1(bstack, b$, bb$) Then GoTo conthere
            ElseIf FastSymbol(b$, ")(", , 2) Then
                bstack.tmpstr = W$ + "(" + Left$(b$, 1)
                BackPort b$
                 Set bstack.lastpointer = Nothing
                If IsStr1(bstack, b$, bb$) Then GoTo conthere
            Else
                ec$ = W$ + "(" + BlockParam(b$) + ")"
                b$ = Mid$(b$, 2)
                If IsNumber(bstack, ec$, rv) Then GoTo conthere
            End If
        Else
            If IsStr1(bstack, W$ + "$", bb$) Then
            End If
        End If
conthere:
        If pppp.Arr Then
            If safegroup.IamApointer Then
                Set tempRef = pppp.GroupRef   'pppp.item(v).Link
                safegroup.link.ToDelete = True
                Set safegroup.LinkRef = CopyGroupObj(var(y1))
                Set safegroup.link.LinkRef = pppp.GroupRef
            Else
                Set tempRef = pppp.GroupRef   'pppp.item(v).Link
                pppp.item(v).ToDelete = True
                Set pppp.item(v) = CopyGroupObj(var(y1))
                If TypeOf pppp.itemObject(v) Is Group Then Set pppp.item(v).LinkRef = pppp.GroupRef
            End If
        Else
            If safegroup.IamApointer Then
                CopyGroup1 var(y1), safegroup.link
                If v >= 0 Then
                    Set bstack.lastpointer = safegroup
                    Set bstack.lastobj = safegroup.link
                End If
            Else
                CopyGroup1 var(y1), safegroup
            End If
        End If
    End If
    SpeedGroup = 1
    Set bstack.lastobj = Nothing
    If bstack.lastobj Is Nothing Then
        bstack.LastValue = bb$
    Else
        bstack.LastValue = vbNullString
    End If
    GoTo fastexit
ElseIf Prefix = "FOR" Then
        Set mm = New mStiva2
        oldjump = bstack.jump: oldifctrl = bstack.IFCTRL: olduseofif = bstack.UseofIf
        RetStackSize = bstack.RetStackTotal
        If v = -1 Then
            y1 = 0
            If W$ = "THIS" Or W$ = "ауто" Then
                W$ = "THIS"  ' look this other time..
            ElseIf Len(W$) > 5 Then
                If Len(bstack.UseGroupname) > 0 Then
                    If W$ = "SUPERCLASS" Or W$ = "упеяйкасг" Then
                        Set pppp = New ppppLight: pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
                        v = 0
                        W$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
                        If Right$(here$, 2) = "()" Then
                            If Right$(here$, 3) = ChrW(&H1FFD) + "()" Then
                                If GetVar3(bstack, bstack.fHere + "." + W$, y1) Then
                                    If TypeOf var(y1) Is Group Then
                                        If Not var(y1).SuperClassList Is Nothing Then
                                            Set pppp.item(v) = var(y1).SuperClassList
                                            v100 = True
                                            GoTo CONT104010
                                        End If
                                    End If
                                End If
                            ElseIf GetVar(bstack, bstack.Parent.originalname + "." + W$, y1) Then
                                If TypeOf var(y1) Is Group Then
                                    If Not var(y1).SuperClassList Is Nothing Then
                                        Set pppp.item(v) = var(y1).SuperClassList
                                        v100 = True
                                        GoTo CONT104010
                                    End If
                                End If
                            End If
                        End If
                        If GetVar3(bstack, W$, y1) Then
                            If TypeOf var(y1) Is Group Then
                                If Not var(y1).SuperClassList Is Nothing Then
                                    Set pppp.item(v) = var(y1).SuperClassList
                                    v100 = True
                                    GoTo CONT104010
                                End If
                            End If
                        ElseIf GetVar(bstack, bstack.originalname + "." + W$, y1) Then
                            If TypeOf var(y1) Is Group Then
                                If Not var(y1).SuperClassList Is Nothing Then
                                    Set pppp.item(v) = var(y1).SuperClassList
                                    v100 = True
                                    GoTo CONT104010
                                End If
                            End If
                        Else
                            MyEr "Double use of SuperClass", "дИПКч ВЯчСГ ТГР уПЕЯЙКэСГР"
                            GoTo fastexit
                        End If
                    End If
                End If
            End If
            If GetVar3(bstack, W$, y1) Then
                If TypeOf var(y1) Is Group Then
                    If var(y1).IamApointer Then
                        If Len(var(y1).link.LastOpen) > 0 Then
                            If GetVar(bstack, var(y1).link.LastOpen, I) Then GoTo jmp1998
                        End If
                        Set safegroup = var(y1)
                        If safegroup.link.IamFloatGroup Then
                            v = 0
                            Do While safegroup.link.IamApointer
                                Set safegroup = safegroup.link
                                If safegroup.link Is Nothing Then GoTo fastexit
                            Loop
                            Set pppp = BoxGroupVar(safegroup.link)
                            Set pppp.refgroup = safegroup
                            safegroup.link.PointerPtr = ObjPtr(safegroup)
                            safegroup.PointerPtr = ObjPtr(safegroup)
                            W$ = pppp.CodeName & (Abs(v))
                            GoTo CONT1040102
                        Else
                            If Len(var(y1).lasthere) = 0 Then
                                If var(y1).IamGlobal Then
                                    bstack.MoveNameDot "*" + var(y1).GroupName
                                Else
                                    bstack.MoveNameDot var(y1).GroupName
                                End If
                            Else
                                bstack.MoveNameDot var(y1).lasthere + "." + var(y1).GroupName
                            End If
                            v = -1
                        End If
                    Else
                        If var(y1).IamGlobal Then
                            bstack.MoveNameDot "*" + W$
                        Else
                       ' If Len(var(y1).Patch) = 0 Then
                       '     bstack.MoveNameDot w$
                       ' Else
                            bstack.MoveNameDot var(y1).Patch
                        '    End If
                        End If
                    End If
                Else
                    MissingGroup
                    GoTo fastexit
                End If
            Else
                If W$ = "THIS" Then
                    bstack.MoveNameDot W$
                Else
                    MissingGroup
                    GoTo fastexit
                End If
            End If
        Else
            If pppp Is Nothing Then SpeedGroup = 0: Exit Function
            If pppp.Arr Then
                If pppp.item(v).IamApointer Then
                    Set safegroup = pppp.item(v)
                    If Not safegroup.link.IamFloatGroup Then
                        If Len(safegroup.lasthere) = 0 Then
                            If safegroup.IamGlobal Then
                                bstack.MoveNameDot "*" + safegroup.GroupName
                            Else
                                bstack.MoveNameDot safegroup.GroupName
                            End If
                        Else
                            bstack.MoveNameDot safegroup.lasthere + "." + safegroup.GroupName
                        End If
                        v = -1
                        GoTo contheretoo1
                    End If
                End If
            Else
                Set safegroup = pppp.item(v)
            End If
CONT104010:
            If pppp.refgroup Is Nothing Then
                If v >= 0 Then
                    W$ = pppp.CodeName & (v)
                Else
                    W$ = pppp.CodeName & (Abs(v))
                End If
                If Len(pppp.item(v).LastOpen) > 0 Then
                    If GetVar(bstack, pppp.item(v).LastOpen, I) Then
jmp1998:
                        Set safegroup = var(I)
                        If safegroup.lasthere = here$ Then
                            W$ = safegroup.GroupName
                            W$ = Left$(W$, Len(W$) - 1)
                        Else
                            LinkGroup bstack, W$, var(I)
                            makegroup bstack, W$, I
                        End If
                        y1 = -1
                        Set safegroup = var(I)
                        GoTo conthere145
                    End If
                Else
                    If Not safegroup Is Nothing Then
                        If Not safegroup.link Is Nothing Then
                            If Len(safegroup.link.LastOpen) > 0 Then
                                W$ = safegroup.link.LastOpen
                            End If
                        End If
                    End If
                End If
            Else
                If Not pppp.refgroup.LastOpen = vbNullString Then
                    If pppp.refgroup.lasthere$ = here$ Then
                        W$ = pppp.refgroup.LastOpen
                    Else
                        W$ = pppp.refgroup.lasthere$ + "." + pppp.refgroup.LastOpen
                    End If
                End If
            End If
            If Not MyIsObject(pppp.item(v)) Then GoTo fastexit
            If Not safegroup Is Nothing Then
                Set safegroup = pppp.item(v)
                If safegroup Is Nothing Then GoTo fastexit
                If safegroup.IamApointer Then
                    If safegroup.link.IamFloatGroup Then
                        Set pppp = BoxGroupVar(safegroup.link)
                        Set pppp.refgroup = safegroup
                        safegroup.LastOpen = W$
                        safegroup.lasthere = here$
                        Set safegroup = Nothing
                        v = 0
                    Else
                        bstack.MoveNameDot safegroup.GroupName
                        v = -1
                        GoTo contheretoo1
                    End If
                End If
            End If
CONT1040102:
            On Error Resume Next
    ' check for iamglobal ??
            If Not GetVar3(bstack, W$, y1) Then
                y1 = globalvarGroup(W$, CVar(New Group))
                If pppp.item(v).IamApointer Then
                    UnFloatGroup bstack, W$, y1, pppp.item(v).link, , True
                Else
                    UnFloatGroup bstack, W$, y1, pppp.item(v), , True
                End If
      '          globalvarGroup w$, y1, True, True
                Set safegroup = pppp.item(v)
                
                safegroup.LastOpen = W$
                var(y1).lasthere = here$
                var(y1).LastOpen = W$
                var(y1).PointerPtr = safegroup.PointerPtr
            End If
            If Err.Number > 0 Then
mer123:
                MyEr "This For can't be done", " аУТч Г цИА ДЕМ ЛПОЯЕъ МА ЦъМЕИ"
                Err.Clear
                GoTo fastexit
            End If
           
           
           
           
conthere145:
            If y1 = -1 Then
            If Not safegroup Is Nothing Then
                If safegroup.IamGlobal Then
                    bstack.MoveNameDot "*" + var(I).Patch
                Else
                    bstack.MoveNameDot var(I).Patch
                End If
            Else
                bstack.MoveNameDot var(I).Patch
            End If
            Else
            If Not safegroup Is Nothing Then
                If safegroup.IamGlobal Then
                    bstack.MoveNameDot "*" + var(y1).Patch
                Else
                    bstack.MoveNameDot var(y1).Patch
                End If
            Else
                bstack.MoveNameDot var(y1).Patch
            End If
            
            End If
        '  depth = depth + 1
        End If
contheretoo1:
        mm.DataVal CDbl(y1)
        If v100 Then v = -100: v100 = False
        mm.DataVal CDbl(v)
        mm.DataObj pppp
        Do While FastSymbol(b$, ",")
            y1 = -1
            If Len(b$) < 129 Then
                I = IsLabelDot(vbNullString, b$, W$, y1)
            Else
                rest1$ = Left$(b$, 128)
                I = IsLabelDot(vbNullString, rest1$, W$, y1)
                If Len(rest1$) = 0 Then
                    I = IsLabelDot(vbNullString, b$, W$, y1)
                Else
                    b$ = Mid$(b$, 129 - Len(rest1$))
                End If
            End If
            If y1 > 0 Then
                If Left$(W$, 2) = ".." Then
                    I = -bstack.GetDotNew(W$, y1) * I
                End If
            Else
                y1 = 0
            End If
            If I > 4 And I < 8 Then
                Set safegroup = Nothing
                If neoGetArray(bstack, W$, pppp) Then
                    If NeoGetArrayItem(pppp, bstack, W$, v, b$) Then
                        If pppp.ItemType(v) = mGroup Then
                            If Left$(b$, 1) = "." Then
                                If SpeedGroup(bstack, pppp, "VAL", "", b$, v) = 1 Then
                                    If Typename(bstack.lastobj) = mGroup Then
                                        Set pppp = New ppppLight
                                        pppp.Arr = False
                                        Set pppp.GroupRef = bstack.lastobj
                                        v = -2
                                    Else
                                        MissingGroup
                                        GoTo fastexit
                                    End If
                                Else
                                GoTo fastexit
                            End If
                        End If
contheretoo:
                        W$ = pppp.CodeName & (Abs(v))
                        If pppp.item(v).IamApointer Then
                            If Len(pppp.item(v).link.LastOpen) > 0 Then
                                If GetVar(bstack, pppp.item(v).link.LastOpen, I) Then
                                    GoTo jmp1998
                                End If
                            End If
                            If pppp.item(v).link.IamFloatGroup Then
                                Set safegroup = pppp.item(v)
                                Set pppp = BoxGroupObj(safegroup.link)
                                Set pppp.refgroup = safegroup
                                v = 0
                            Else
                                W$ = pppp.item(v).GroupName
                                GoTo conthere3
                            End If
                        End If
                        If safegroup Is Nothing Then
                            Set safegroup = pppp.item(v)
                        Else
                            If Not pppp.item(v).IamApointer Then
                            If pppp.refgroup Is Nothing Then
                                Set safegroup = pppp.item(v)
                            End If
                            pppp.item(v).PointerPtr = ObjPtr(safegroup)
                        End If
                    End If
                    If safegroup.LastOpen <> vbNullString Then
                        If GetVar(bstack, safegroup.LastOpen, y1, , , True) Then
                            W$ = safegroup.LastOpen
                            y1 = globalvarGroup(W$, (y1), True)
                            GoTo cont1010
                        Else
                            safegroup.LastOpen = vbNullString
                        End If
                    End If
contheretoo123:
                    y1 = globalvarGroup(W$, CVar(New Group))
                    UnFloatGroup bstack, W$, y1, pppp.item(v), , True
                    'globalvarGroup w$, y1, True, True
                    var(y1).LastOpen = W$
                    var(y1).lasthere = here$
                    safegroup.LastOpen = W$
                    safegroup.lasthere = here$
                    var(y1).PointerPtr = pppp.item(v).PointerPtr
cont1010:
        ' where look for global???
                    bstack.MoveNameDot var(y1).Patch  ' w$ 'myUcase(w$)
                    depth = depth + 1
                    mm.DataVal CDbl(y1)
                    If v100 Then v = -100: v100 = False
                    mm.DataVal CDbl(v)
                    mm.DataObj pppp
                Else
                    MissingGroup
                    GoTo normalexit
                End If
            Else
                SyntaxError
                GoTo normalexit
            End If
        Else
            NotExistArray
            GoTo normalexit
        End If
    ElseIf I = 8 Then
        bstack.tmpstr = W$ + "[" + Left$(b$, 1)
        BackPort b$
        If IsNumberNew(bstack, b$, v, False) Then
            If bstack.lastobj Is Nothing Then
er66876:
                MyErMacro b$, "Not group found at array " + W$, "ДЕМ БЯчЙА ОЛэДА СТО ПъМАЙА " + W$
                GoTo fastexit
            ElseIf Not TypeOf bstack.lastobj Is Group Then
                Set bstack.lastobj = Nothing
                GoTo er66876
            End If
            Set pppp = New ppppLight
            pppp.Arr = False
            Set pppp.GroupRef = bstack.lastobj
            v = -2
                        'Set bstack.lastobj = Nothing
                        'Set bstack.lastpointer = Nothing
        Else
            GoTo er66876
        End If
         GoTo contheretoo
    ElseIf I = 1 Then
        If W$ = "THIS" Or W$ = "ауто" Then
            W$ = "THIS"
            If bstack.GroupName = vbNullString Then W$ = vbNullString
        Else 'If Len(w$) > 5 Then
            If Len(bstack.UseGroupname) > 0 Then
                If W$ = "SUPERCLASS" Or W$ = "упеяйкасг" Then
                    Set pppp = New ppppLight: pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
                    v = 0
                    W$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
jumpthere:
                    y1 = 0
                    If GetVar3(bstack, (W$), y1, , , , W$) Then
                        If TypeOf var(y1) Is Group Then
                            If var(y1).IamApointer Then GoTo contpointer
                            If Not var(y1).SuperClassList Is Nothing Then
                                Set pppp.item(v) = var(y1).SuperClassList
                                v100 = True
                                GoTo contheretoo
                            End If
                        End If
                    Else
                        If W$ = "SUPERCLASS" Or W$ = "упеяйкасг" Then
                            MyEr "Double use of SuperClass", "дИПКч ВЯчСГ ТГР уПЕЯЙКэСГР"
                        Else
                            MissVarName
                        End If
                        GoTo fastexit1
                    End If
                Else
                    GoTo jumpthere
                End If
            End If
                If y1 = 0 Then
contpointer:
                    If GetPointer(bstack, (W$)) Then
                        If bstack.lastpointer.link.IamFloatGroup Then
                            Set safegroup = bstack.lastpointer
                            Do While safegroup.link.IamApointer
                                Set safegroup = safegroup.link
                                If safegroup.link Is Nothing Then GoTo fastexit
                            Loop
                            Set pppp = BoxGroupObj(safegroup.link)
                            Set pppp.refgroup = safegroup
                            I = 5
                            v = 0
                            Set bstack.lastobj = Nothing
                            Set bstack.lastpointer = Nothing
                            W$ = pppp.CodeName & (Abs(v))
                            If Len(safegroup.link.LastOpen) > 0 Then
                                If GetVar(bstack, safegroup.link.LastOpen, I) Then GoTo jmp1998
                            End If
                            Set pppp.item(v) = safegroup.link
                            pppp.item(v).PointerPtr = ObjPtr(safegroup)
                            Set pppp.refgroup = safegroup
                            GoTo contheretoo123
                        Else
                            If bstack.lastpointer.lasthere = vbNullString Then
                                W$ = "*" + bstack.lastpointer.GroupName
                            Else
                            W$ = bstack.lastpointer.lasthere + "." + bstack.lastpointer.GroupName
                            If GetVar3(bstack, W$, I) Then
                                If var(I).IamGlobal Then
                                    W$ = "*" + bstack.lastpointer.GroupName
                                End If
                            End If
                            End If
                            Set bstack.lastobj = Nothing
                            Set bstack.lastpointer = Nothing
                        End If
                    End If
                End If
            End If
conthere3:
            mm.DataVal 0#
            mm.DataVal CDbl(-1)
            mm.DataObj pppp
            bstack.MoveNameDot W$
            depth = depth + 1
        ElseIf I = 3 Then
        '' ????
            If IsStrExp(bstack, (W$), W$) Then
            End If
        ElseIf I = 6 Then
            bstack.tmpstr = W$ + Left$(b$, 1)
            BackPort b$
            ' ??????
            If IsStr1(bstack, b$, W$) Then
            End If
        Else
            SyntaxError
            GoTo normalexit
        End If
    Loop

   
    If FastSymbol(b$, "{") Then
    ec$ = block(b$)
    Dim nd&
    Dim oldLL As Long
    TraceStore bstack, nd&, b$, 0
    oldLL = bstack.addlen
    ' delete true here
    If True Then
        SpeedGroup = 1
        kolpo = False
        once = True
        I = 1
        ohere$ = here$
        Do
            bstack.addlen = oldLL
            bb$ = Mid$(ec$, I)
subsentry10:
            kolpo = False
            Select Case Execute(bstack, bb$, kolpo, False, loopthis)   ' this is a major point
            Case 0
faultback:
thh:
            If bstack.RetStackTotal - RetStackSize > 0 Then
                bstack.UseofIf = olduseofif
                bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
            End If
                bstack.addlen = nd&
                If bstack.ErrorOriginal <> 0 Then
                b$ = bb$
                Else
                b$ = bb$ + b$
                
                End If
                SpeedGroup = -1
                Set bstack.lastobj = Nothing
                GoTo normalexit
            Case 1
                bstack.addlen = nd&
                S3 = bstack.OriginalCode
              
                If S3 < 0 Then
                    TestShowSub = var(-S3).code
                Else
                    TestShowSub = sbf(S3).sb
                End If
                TestShowBypass = False
                If LastErNum <> 0 Then b$ = vbNullString
                If FastSymbol(b$, "}") Then
                    If once Then Exit Do
                Else
                    If Len(bb$) > 0 Then b$ = Right$(ec$, Len(bb$)) + b$
                End If
                here$ = ohere$
                Exit Do
            Case 2
                bstack.addlen = 0
                If Not kolpo Then
                    I = 1
                    If bb$ <> "" Then
                        If bb$ = ChrW$(0) Then
                            'If RetStackSize = bstack.RetStackTotal And bstack.RetStackLookTopVal < 0 Then
                                ' this is a return form other block
                            If RetStackSize >= bstack.RetStackTotal Then
                                If bstack.IsDecimal Then
                                SpeedGroup = 2
                                SwapStrings b$, bb$
                                bstack.addlen = nd&
                                GoTo fastexit
                                End If
                            End If
                            'If bstack.IsInRetStackNumberLong(p) Then
                                'If LastErNum = -1 Then
                                 '   bstack.RetStack.PushLong p
                                 '   SpeedGroup = 0
                                 '   bstack.addlen = nd&
                                 '   GoTo fastexit
                                'End If
                                If Not bstack.IsInRetStackString(small$) Then
                                If LastErNum = -1 Then
                                    SpeedGroup = 0
                                    bstack.addlen = nd&
                                    GoTo fastexit
                                End If
                                    p = bstack.isPop3Long(S3, sbi)
                                    If p > 0 Then
                                        If S3 > 0 Then
                                            bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                        ElseIf S3 = 0 Then
                                            bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                        Else
                                            bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                        End If
                                        If trace Then
                                            TestShowBypass = True
                                            If TestShowBypass Then
                                                If S3 < 0 Then
                                                    TestShowSub = var(-S3).code
                                                ElseIf S3 = 0 Then
                                                    TestShowSub = ec$ + b$
                                                    sbi = Len(b$)
                                                Else
                                                    TestShowSub = sbf(S3).sb
                                                End If
                                            End If
                                            bstack.addlen = sbi
                                        End If
                                        PopStage bstack
                                        GoTo subsentry10
                                    Else
fulty:
                                        MyEr "Fault in Return", "кэХОР СТГМ еПИСТЯОЖч"
                                        bstack.Flush
                                        Exit Do
                                    End If
                                Else
                                    If InStr(small$, " ") > 0 Then
                                        bstack.PushSecondThird S3, sbi
                                        If searchsub(bstack.OriginalCode, small$, I, S3, bb$) Then
                                            If Len(small$) <> 0 Then If Not MyRead(7, bstack, small$, 1) Then GoTo thh
                                            GoTo contSub
                                        ElseIf bstack.IamChild Then
                                            If searchsub(FindPrevOriginal(bstack), small$, I, S3, bb$) Then
                                                If Len(small$) <> 0 Then If Not MyRead(7, bstack, small$, 1) Then GoTo thh
contSub:
                                                If Len(bb$) = 0 Then
                                                    If S3 < 0 Then
                                                        bb$ = Mid$(var(-S3).code, I)
                                                    Else
                                                        bb$ = Mid$(sbf(S3).sb, I)
                                                    End If
                                                    sbi = 0
                                                Else
                                                    If S3 < 0 Then
                                                        sbi = Len(var(-S3).code) - I - Len(bb$)
                                                    Else
                                                        sbi = Len(sbf(S3).sb) - I - Len(bb$)
                                                    End If
                                                End If
                                                If trace Then
                                                    TestShowBypass = True
                                                    If TestShowBypass Then
                                                        If S3 < 0 Then
                                                            TestShowSub = var(-S3).code
                                                        Else
                                                            TestShowSub = sbf(S3).sb
                                                        End If
                                                    End If
                                                    bstack.addlen = Len(TestShowSub) - I + 1 - Len(bb$)
                                                End If
                                                GoTo subsentry10
                                            Else
jumpbad:
                                                badSubNotFound
                                                If bstack.IsDecimal Then
                                                    p = bstack.Pop3Long(S3, sbi)
                                                    If S3 > 0 Then
                                                       bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                                    ElseIf S3 = 0 Then
                                                      bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                                    Else
                                                       bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                                    End If
                                                End If
                                                bstack.RetStackDrop 3 ' 5
                                                GoTo thh
                                            End If
                                        Else
                                            'If small$ <> "" Then badSubNotFound
                                            GoTo jumpbad
                                        End If
                                End If
                            End If
                        ElseIf bb$ = "BREAK" Then
                                SpeedGroup = 2
                                GoTo breakexit
                        Else
                            If subsfc Is Nothing Then Set subsfc = New FastCollection
                            If subsfc.ExistKey(bb$) Then
                                I = subsfc.Value
                                If subsfc.sValue = 0 Then
                                    If I = 0 Or I > Len(ec$) Then
                                        SwapStrings b$, bb$
                                        SpeedGroup = 2
                                        bstack.addlen = nd&
                                        Exit Do
                                    Else
                                        bb$ = Mid$(ec$, I)
                                    End If
                                Else
                                    S3 = subsfc.sValue
                                    If S3 < 0 Then
                                        If I = 0 Or I > Len(var(-S3).code$) Then
                                            SwapStrings b$, bb$
                                            SpeedGroup = 2
                                            bstack.addlen = nd&
                                            Exit Do
                                        Else
                                            GoTo AGAINGOTOLAMBDA
                                        End If
                                    Else
                                        If I = 0 Or I > Len(sbf(S3).sb) Then
                                            SwapStrings b$, bb$
                                            SpeedGroup = 2
                                            bstack.addlen = nd&
                                            Exit Do
                                        End If
                                        GoTo AGAINGOTO
                                    End If
                                End If
                               
                                GoTo subsentry10
                            Else
                                If S3 = 0 Then
                                    I = PosLabel(bb$, ec$)
                                    If I = 0 Or I > Len(ec$) Then
                                        GoTo checkother
                                    Else
                                        subsfc.ItemCreator2 bb$, I, 0
                                        bb$ = Mid$(ec$, I)
                                        GoTo subsentry10
                                    End If
                                End If
checkother:
                                If S3 < 0 Then
                                    I = PosLabel(bb$, var(-S3).code$)
                                    If I = 0 Or I > Len(var(-S3).code$) Then
                                        SwapStrings b$, bb$
                                        SpeedGroup = 2
                                        bstack.addlen = nd&
                                        Exit Do
                                    End If
                                    subsfc.ItemCreator2 bb$, I, S3
AGAINGOTOLAMBDA:
                                    If bstack.SubLevel > 0 Then
                                                If Len(var(-S3).code$) - I > sbi Then
                                                    bb$ = Mid$(var(-S3).code$, I, Len(var(-S3).code$) - I - sbi)
                                                Else
                                                    bb$ = Mid$(var(-S3).code$, I)
                                                    sbi = 0
                                                End If
                                            Else
                                                bb$ = Mid$(var(-S3).code$, I)
                                                sbi = 0
                                            End If
                    
                                Else
                                    I = PosLabel(bb$, sbf(S3).sb)
                                    If I = 0 Or I > Len(sbf(S3).sb) Then
                                        SwapStrings b$, bb$
                                        SpeedGroup = 2
                                        bstack.addlen = nd&
                                        Exit Do
                                    End If
                                    subsfc.ItemCreator2 bb$, I, S3
AGAINGOTO:
                                    If bstack.SubLevel > 0 Then
                                                If Len(sbf(S3).sb) - I > sbi Then
                                                    bb$ = Mid$(sbf(S3).sb, I, Len(sbf(S3).sb) - I - sbi)
                                                Else
                                                    bb$ = Mid$(sbf(S3).sb, I)
                                                    sbi = 0
                                                End If
                                            Else
                                                bb$ = Mid$(sbf(S3).sb, I)
                                                sbi = 0
                                            End If
                                End If
                                
                                GoTo subsentry10
                            End If
                        End If
                    Else
                        loopthis = False
                    End If
                Else
                    If kolpo Then b$ = "BREAK"
                    once = kolpo
                    SpeedGroup = 2: Set bstack.lastobj = Nothing
                    bstack.addlen = nd&
                    GoTo breakexit
                End If
            Case Else
                If FastSymbol(b$, "}") Then
                    If once Then bstack.addlen = nd&: Exit Do
                Else
                    If Len(bb$) > 0 Then b$ = Right$(ec$, Len(bb$)) + b$
                End If
                here$ = ohere$
                bstack.addlen = nd&
                Exit Do
            End Select
            here$ = ohere$
           ' If checkbreakEsc(bstack) Then SpeedGroup = 1:  bstack.addlen = nd&: Exit Do
        Loop
            Else
            SpeedGroup = Abs(FastSymbol(b$, "}"))
        End If
    End If
breakexit:
    Set bstack.lastobj = Nothing
    While mm.Total > 0
        y1 = mm.PopVal
        v = mm.PopVal
        Set pppp = mm.PopObj
        If y1 < 0 Then
        ElseIf v <> -1 Then
            If v <> -100 Then
                If Not MyIsObject(pppp.item(v)) Then
                    pppp.item(v).ToDelete = True
                    Set pppp.item(v) = CopyGroupObj(var(y1), pppp.IhaveClass)
                Else
                    If Not pppp.refgroup Is Nothing Then
                        Set safegroup = pppp.refgroup
                        safegroup.link.ToDelete = True
                        Set safegroup.LinkRef = CopyGroupObj(var(y1))
                        safegroup.link.PointerPtr = ObjPtr(safegroup)
                       ' pppp.item(v).ToDelete = True
                        safegroup.LastOpen = vbNullString
                        safegroup.lasthere = vbNullString
                        Set safegroup = Nothing
                    Else
                        pppp.item(v).ToDelete = True
                        Set pppp.item(v) = CopyGroupObj(var(y1), Not pppp.item(v).link Is Nothing)
                    End If
                End If
            Else
                If pppp.Arr Then
                    v = 0
                    If Not MyIsObject(pppp.item(v)) Then
                    Set pppp.item(v) = CopyGroupObj(var(y1))
                    Else
                    Set pppp.item(v) = CopyGroup1(var(y1), pppp.item(v))
                    End If
                Else
                    pppp.item(v).ToDelete = True
                    Set pppp.item(v) = CopyGroupObj(var(y1))
                End If
            End If
            Set tempRef = pppp.GroupRef  '  pppp.item(v).Link
            If Not pppp.IsEmpty Then
                If Not tempRef Is Nothing Then If TypeOf pppp.itemObject(v) Is Group Then Set pppp.item(v).LinkRef = tempRef
            End If
        End If
    Wend
normalexit:
    bstack.DropNdot depth + 1
' new
    If SpeedGroup > 1 Then
        If bstack.RetStackTotal - RetStackSize > 0 Then
            bstack.UseofIf = olduseofif
            bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
        End If
    End If
    bstack.jump = oldjump
    bstack.IFCTRL = oldifctrl
Else
    I = W$ = "."
    If v >= 0 Then
        W$ = pppp.CodeName & (v)
    Else
        W$ = pppp.CodeName & (Abs(v))
    End If
    If Len(pppp.item(v).LastOpen) > 0 Then
        If GetVar(bstack, pppp.item(v).LastOpen, I) Then
jump1991:
            Set safegroup = var(I)
            If safegroup.lasthere = here$ Then
                W$ = safegroup.GroupName
                W$ = Left$(W$, Len(W$) - 1)
            Else
                LinkGroup bstack, W$, var(I)
                makegroup bstack, W$, I
            End If
            Set safegroup = Nothing
            GoTo cont2020
        End If
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
    If safegroup.IamApointer Then
        If safegroup.link.IamFloatGroup Then
            If Len(safegroup.link.LastOpen) > 0 Then
                If GetVar(bstack, safegroup.link.LastOpen, I) Then GoTo jump1991
            End If
            Set pppp = BoxGroupVar(safegroup.link)
            pppp.item(0).PointerPtr = ObjPtr(safegroup)
            v = 0
        Else
            If Left$(Prefix$, 1) = "@" Then
                W$ = safegroup.lasthere + "." + safegroup.GroupName
                GoTo cont2020
            Else
                bstack.MoveNameDot safegroup.lasthere + "." + safegroup.GroupName
                v = 0
                GoTo contheretoo1
            End If
        End If
    Else
        y1 = globalvarGroup(W$, CVar(New Group))
    End If
    If safegroup.LastOpen <> vbNullString Then
        If GetVar(bstack, (safegroup.LastOpen), y1, True) Then
            If safegroup.lasthere$ = here$ Then
                W$ = safegroup.LastOpen
            Else
                If safegroup.lasthere$ = vbNullString Then
                    W$ = safegroup.LastOpen
                Else
                    W$ = safegroup.lasthere$ + "." + safegroup.LastOpen
                End If
            End If
            GoTo cont2020
        Else
            If safegroup.link Is Nothing Then
            If safegroup.IamFloatGroup Then
                safegroup.LastOpen = vbNullString
                safegroup.lasthere$ = vbNullString
            End If
            Else
            If safegroup.link.IamFloatGroup Then
                safegroup.LastOpen = vbNullString
                safegroup.lasthere$ = vbNullString
            End If
            End If
        End If
        UnFloatGroup bstack, W$, y1, pppp.item(v), , True
        globalvarGroup W$, y1, True, True
    Else
        If y1 = 0 Then y1 = globalvarGroup(W$, y1)
        UnFloatGroup bstack, W$, y1, pppp.item(v), , True
        globalvarGroup W$, y1, True, True
        var(y1).PointerPtr = pppp.item(v).PointerPtr
        pppp.item(v).lasthere = here
        pppp.item(v).LastOpen = W$
        var(y1).lasthere = here
        var(y1).LastOpen = W$
    End If
cont2020:
    If Len(Prefix) > 0 Then
        If Prefix = "@READ2" Then
            NeoCall2 bstack, W$ + "." + ChrW(&H1FFF) + ":=()", ok
            SpeedGroup = Abs(ok)
            GoTo CONTlastEtnum
        ElseIf Prefix = "@READ" Then
            If I Then
                bstack.tmpstr = W$ + "." + Left$(b$, 1)
                BackPort b$
                SpeedGroup = Abs(MyRead(1, bstack, b$, 1))
                GoTo CONTlastEtnum
            Else
                If var(y1).HasStrValue Then
                    SpeedGroup = Abs(MyRead(1, bstack, W$ + "$", 1))
                    GoTo CONTlastEtnum
                Else
                   SpeedGroup = Abs(MyRead(1, bstack, (W$), 1))
                    GoTo CONTlastEtnum
                End If
            End If
        Else
            If I Then
                bstack.tmpstr = vbCrLf + Prefix + " " + W$ + "." + Left$(b$, 1)
                BackPort b$
            Else
                If var(y1).HasStrValue Then
                    bstack.tmpstr = vbCrLf + Prefix + " " + W$ + "$ " + Left$(b$, 1)
                    BackPort b$
                Else
                    bstack.tmpstr = vbCrLf + Prefix + " " + W$ + " " + Left$(b$, 1)
                    BackPort b$
                End If
            End If
        End If
    Else
        If Left$(b$, 2) = Chr$(3) + "(" Then
           If var(y1).HasStrValue Then
               bstack.tmpstr = W$ + "$( "
               Mid$(b$, 1, 2) = "  "
               BackPort b$
           Else
               bstack.tmpstr = W$ + "( " ''+ Left$(b$, 1)
               Mid$(b$, 1, 2) = "  "
               BackPort b$
           End If
        Else
            If Left$(b$, 1) = Chr$(3) Then Mid$(b$, 1, 1) = " "
            If MaybeIsSymbol(b$, "/*-+=~^&|<>") Then
                bstack.tmpstr = W$ + Left$(b$, 1)
                BackPort b$
            Else
                bstack.tmpstr = W$ + "." + Left$(b$, 1)
                BackPort b$
            End If
        End If
    End If
    SpeedGroup = Execute(bstack, b$, True, , , , , True)
        
CONTlastEtnum:
    If LastErNum <> 0 Then
        If FK$(13) = vbNullString Then FK$(13) = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))
    End If
    If safegroup Is Nothing Then
    ' DO NOTHING
    ElseIf safegroup.IamApointer Then
        If safegroup.LastOpen = vbNullString Then
            If Len(safegroup.lasthere) = 0 Then
                safegroup.link.lasthere = vbNullString
                safegroup.link.LastOpen = vbNullString
                Set tempRef = pppp.GroupRef
                safegroup.link.ToDelete = True
                Set safegroup.LinkRef = CopyGroupObj(var(y1))
                Set safegroup.link.LinkRef = pppp.GroupRef
            End If
        End If
    ElseIf Vars < y1 Then
        Set safegroup.LinkRef = Nothing
        Set tempRef = pppp.GroupRef
        pppp.item(v).ToDelete = True
        Set pppp.item(v) = CopyGroupObj(var(y1))
        Set safegroup.LinkRef = tempRef
        var(y1) = 0&
    End If
End If

fastexit:
If SpeedGroup <= 0 Then SpeedGroup = SpeedGroup + 1

fastexit1:
bstack.ResetSkip
var2used = Vars
varhash.ReduceHash Vname, var()
sb2used = subs
subHash.ReduceHash snames, sbf()
numid.poptop
funid.poptop
strfunid.poptop
strid.poptop

End Function



Public Sub Thing(W$, v$)
'' from w$ input this value V$...
'' general input
On Error Resume Next
Dim it As Long, pppp As mArray
If Len(W$) < 2 Then Exit Sub

If AscW(W$) = 65 Then
On Error Resume Next
Err.Clear
Set pppp = var(Split(Mid$(W$, 2))(0)) ''  "A...16charRef....ItemNo"
If Err.Number > 0 Then Exit Sub
it = val(Split(Mid$(W$, 2))(1))
If pppp.ItemType(it) = doc Then
pppp.item(it).textDoc = v$  ' no checked yet
Else
pppp.item(it) = pppp.item(it) + v$
End If
ElseIf AscW(W$) = 86 Then
it = val("0" + Mid$(W$, 2))          ''"VItemNo"
If CheckInt64(var(it)) Then
' never
ElseIf VarTypeName(var(it)) = doc Then
var(it).textDoc = v$    ' no checked yet
Else
var(it) = var(it) + v$
End If
Else
' CAN'T READ
End If
End Sub
Function rinstr(A As String, b As String, Optional ByVal fr As Long) As Long
Dim I
I = Len(A)
fr = I - fr
If fr < 0 Or fr > I Then fr = I + 1
If fr > 0 Then rinstr = InStrRev(A, b, fr)
End Function
Function rinstrb(A As String, b As String, Optional ByVal fr As Long) As Long
'
Dim I As Long, j As Long
fr = fr - LenB(b) + 1
If fr < 0 Then fr = LenB(A) + 1
Do
j = I
I = InStrB(j + 1, A, b)

Loop Until I = 0 Or I > fr

rinstrb = j
End Function



Function RMAX(ByVal q As Single, ByVal W As Single) As Single
If q > W Then
RMAX = q
Else
RMAX = W
End If
End Function

Function RMIN(ByVal q As Single, ByVal W As Single) As Single
If q < W Then
RMIN = q
Else
RMIN = W
End If
End Function



Public Function GetTaskId() As Long
taskid = taskid + 1
If taskid = 10000 Then taskid = 1
GetTaskId = taskid

End Function
Sub Dispose()
'use strtemp
On Error Resume Next
Dim r$
While ISSTRINGA(kill2$, r$)
KillFile strTemp + r$
Wend
End Sub
Public Sub NeoSubMain()
' need to read registry form sub main
On Error Resume Next
maxlonglong = CDec("18446744073709551616")
limitlonglong = CDec("9223372036854775808")
Dim I As Long
For I = 0 To 32
    Pow2(I) = CCur(2 ^ I)
    Pow2minusOne(I) = Pow2(I) - 1
Next I
Alphabet = StrConv("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", vbFromUnicode)
'' From 9.6 by default we have no round to 13d for double
One64 = CopyCur64(0.0001@)
Zero64 = CopyCur64(0@)
EditTabWidth = 4
tParam.cbSize = LenB(tParam)
tParam.iTabLength = 4
ReportTabWidth = 8
RoundDouble = False
SetUp64 ' for Encoder64/Decoder64
AskCancelGR = "айуяо"
AskOkGR = "емтанеи"
LoadFileCaptionGR = "жЭЯТЫСЕ аЯВЕъО"
SaveFileCaptionGR = "сЧСЕ аЯВЕъО"
SelectFolderCaptionGR = "еПИКОЦч жАЙщКОУ"
SelectFolderButtonGR = "*СЩЯЕ ДЕНИэ ЦИА ЕПИКОЦч*"
FontSelectorGr = "цЯАЛЛАТОСЕИЯэ"
ColorSelectorGr = "вЯЫЛАТОКЭЦИО"
SetUpGR = "яУХЛъСЕИР"
AskCancelEn = "CANCEL"
AskOkEn = "OK"
SetUpEn = "Set Up"
LoadFileCaptionEn = "Load File"
SaveFileCaptionEn = "Save File"
SelectFolderCaptionEn = "Select Folder"
SelectFolderButtonEn = "*slide right to select*"
FontSelectorEn = "Font Selector"
ColorSelectorEn = "Color Selector"

BigPi = CDec("31415926535897932384626433832") * 1E-28
INK$ = vbNullString
'UINK$ = VbNullString
MINK$ = vbNullString
MKEY$ = vbNullString
RandomizeIt rndbase, 0
ClearCatalog
SetLibHdls
LCID_DEF = LCID_def1() Mod &H10000
DefCodePage = GetCodePage(OsInfo.LangNonUnicodeCode)
UserCodePage = DefCodePage
UseTabInForm1Text1 = True
ShowBooleanAsString = True
Clid = LCID_DEF
If Clid = 1032 Then
    DefBooleanString = ";аКГХщР;ьЕУДщР"
Else
    DefBooleanString = ";\T\r\u\e;\F\a\l\s\e"
End If
    NowDec$ = GetlocaleString(LOCALE_SDECIMAL)
    NowThou$ = GetlocaleString(LOCALE_STHOUSAND)
If dv15 <> 0 Then
l_complete = False
s_complete = False
DisableProcessWindowsGhosting
Set HelpStack = New basetask
Set oprinter = New cDIBSection
Set Basestack1.Sorosref = globalstack
Set subHash = New sbHash
Set varhash = New Hash
Set comhash = New sbHash
Set numid = New idHash
Set funid = New idHash
Set strid = New idHash
Set strfunid = New idHash
GoTo there
End If
dv15 = 1440 / DpiScrX

GetMonitorsNow
DisableProcessWindowsGhosting
With ScrInfo(Console)
If IsWine Then
players(0).MAXXGRAPH = .Width - 1
players(0).MAXYGRAPH = .Height - 1
End If
End With
'' BY DEAFULT IS FALSE
priorityOr = False  '  TRUE OR FALSE AND FALSE GIVE -1 BECAUSE OR AND XOR PROCESS LEFT FIRST TRUE OR ( FALSE AND FALSE)
'' WITH priorityOr = FALSE WE HAVE FLAT SYSTEM.........TRUE OR FALSE AND FALSE GIVE 0
OperatingSystem
dv20 = 24.5
Call GetSystemTimeAsFileTime(basictimer)
Randomize basictimer
JetPrefixUser = JetPrefixHelp
JetPostfixUser = JetPostfixHelp
JetPostfix = JetPostfixHelp
JetPrefix = JetPrefixHelp
basickey = "Software\M2000v" & VerMajor & "\" + Mid$(App.path, rinstr(App.path, "\") + 1) + "\" + App.EXENAME + "\"
' by default
'AddTwipsTop = 4 * Screen.TwipsPerPixelY
casesensitive = False
pagio$ = "LATIN"
pagiohtml$ = "DARK"
REFRESHRATE = 40
SizeDialog = 1
helpSizeDialog = 1
Settings = "time,normal,push"
With ScrInfo(Console)
selectorLastX = .Height / 4 + .Left
selectorLastY = .Width / 4 + .top
AskLastX = .Height / 4 + .Left
AskLastY = .Width / 4 + .top
End With
sb2used = 0
ReDim sbf(500) As modfun
var2used = 0
ReDim var(3000) As Variant
   StartingRes
   'Dim iccex As tagInitCommonControlsEx
   'With iccex
     ' .lngSize = LenB(iccex)
    '  .lngICC = ICC_USEREX_CLASSES
   'End With
   'InitCommonControlsEx iccex

clickMe2 = -1


''Dim soros As New mStiva
Dim t As Long
ReDim q(0) As target

Set Basestack1.Sorosref = globalstack

taskid = 999
DisableMidi
beat = 400 ' beat of 1/16
baseNote = 23
octava = 4
NOTA = 0
ENTASI = 127   '' volume
voices(0) = "CC#"
there:
Randomize
allcommands comhash
NumberId numid, funid, numidbackup, funidbackup
StringId strid, strfunid, stridbackup, strfunidbackup
TimeZones zones
Set TaskMaster = New TaskMaster
TaskMaster.Interval = 5
beeperBEAT = 300
MediaPlayer1.FileName = vbNullString
defFontname = "Verdana"
my_system = OperatingPlatform
vol = 50
MediaPlayer1.setLeftVolume vol * 10
MediaPlayer1.setRightVolume vol * 10
deep = 10000

ReDim MyDM(1 To 1) As Byte
DXP = Screen.TwipsPerPixelX
DYP = Screen.TwipsPerPixelY
Load Form5

If Not l_complete Then

Exit Sub

Else
Form1.something

End If

End Sub
Sub TerminateM2000()
NoAction = False
DelTemp
'Set DisStack.Owner = Nothing

Set Basestack1.Owner = Nothing
Set LastGlist = Nothing
Set LastGlist2 = Nothing
If form5iamloaded Then
   If IsWine Then
   Form5.BackPort
   Else
   Unload Form5
   End If
End If
End Sub
Public Sub terminatefinal()
RemoveAllFonts
Set globalstack = Nothing
Set Basestack1 = Nothing
CloseAllConnections  ' new for ADO we keep objects not the connections
CleanupLibHandles
Set globalstack = Nothing
Set mycoder = Nothing
Set subHash = Nothing
Set comhash = Nothing
Set numid = Nothing
Set funid = Nothing
Set strid = Nothing
Set strfunid = Nothing
Set Prof = Nothing
Set MediaPlayer1 = Nothing
Set MediaBack1 = Nothing
On Error Resume Next
Erase sbf()
Erase var()
s_complete = False
l_complete = False
ResetTokenFinal  ' sure for GDI release token
End Sub
Function GetArr(bstack As basetask, b$, p As Variant, s$, skip As Long, lookCompOrTuple As Boolean) As Boolean
    Dim pppp As mArray, x1 As Long, usehandler As mHandler, r, that As BigInteger
    Dim obj1 As Object, val1 As Variant
    x1 = 1
    If skip <> 0 Then
        FastSymbol b$, ","
        If FastSymbol(b$, ")") Then
            Set pppp = New mArray: pppp.myarrbase = 0: pppp.PushDim (1&): pppp.PushEnd: pppp.Arr = True
            If bstack.lastobj Is Nothing Then
                pppp.item(0&) = p
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(0&) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
            Set bstack.lastobj = pppp
            p = 0
            GetArr = True
            Exit Function
        End If
contSecond:
        Set obj1 = bstack.lastobj
        SwapVariant p, val1
        p = 0

        If IsExp(bstack, b$, p) Then
            x1 = 3
            
            If LCase(Left$(b$, 2)) = "i)" Then
                lookCompOrTuple = True
                If Not bstack.lastobj Is Nothing Then
                    p = 0
                    If TypeOf bstack.lastobj Is BigInteger Then
                        Set that = bstack.lastobj
                        p = CDbl(StrConv(that.Value, vbUnicode))
                    End If
                    Set bstack.lastobj = Nothing
                End If
                ' so p is the imaginary pert
                If Not obj1 Is Nothing Then
                        val1 = 0
                    If TypeOf obj1 Is BigInteger Then
                        Set that = obj1
                        val1 = CDbl(StrConv(that.Value, vbUnicode))
                    End If
                    Set obj1 = Nothing
                    
                End If
                p = nMath2.cxNew(CDbl(val1), CDbl(p))
                Mid$(b$, 1, 2) = "  "
                GetArr = True
                Exit Function
            Else
                Set pppp = New mArray: pppp.myarrbase = 0: pppp.PushDim (2&): pppp.PushEnd: pppp.Arr = True
            End If
            ' feed item 0
            If Not obj1 Is Nothing Then
                Set pppp.item(0) = obj1
            Else
                pppp.item(0) = val1
            End If
            ' feed item 1
            If bstack.lastobj Is Nothing Then
                pppp.item(1&) = p
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(1&) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
        ElseIf IsStrExp(bstack, b$, s$, False) Then
            x1 = 3
            Set pppp = New mArray: pppp.myarrbase = 0: pppp.PushDim (2&): pppp.PushEnd: pppp.Arr = True
            ' feed 0
            If Not obj1 Is Nothing Then
                Set pppp.item(0&) = obj1
            Else
                pppp.item(0&) = val1
            End If
            If bstack.lastobj Is Nothing Then
                pppp.item(1&) = CVar(s$)
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(1&) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
        End If
        val1 = 0
        Set obj1 = Nothing
    Else
        If FastSymbol(b$, ",") Then  ' means empty
            GetArr = FastSymbol(b$, ")")
            Set pppp = New mArray: pppp.myarrbase = 0:: pppp.Arr = True 'pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
            If GetArr Then Set bstack.lastobj = pppp Else bstack.lastobj = Nothing
            p = 0
        Exit Function
        Else
            If IsExp(bstack, b$, p) Then
                If Not bstack.lastobj Is Nothing Then
                    If TypeOf bstack.lastobj Is Group Then
                        bstack.lastobj.ToDelete = False
                    End If
                End If
            ElseIf IsStrExp(bstack, b$, s$, False) Then
                If bstack.lastobj Is Nothing Then
                   p = ""
                   SwapString2Variant s$, p
                Else
                    If TypeOf bstack.lastobj Is Group Then
                        bstack.lastobj.ToDelete = False
                    End If
                End If
            End If
            If FastSymbol(b$, ",") Then GoTo contSecond
            lookCompOrTuple = True
            GetArr = FastSymbol(b$, ")")
            Exit Function
        End If
    End If
    Do While MaybeIsSymbol(b$, ",)")
        IsSymbol b$, ","
        If lookOne(b$, ")") Then
            pppp.SerialItem 0, x1 - 1, 10
            Exit Do
        ElseIf IsExp(bstack, b$, p) Then
            x1 = x1 + 1
            pppp.SerialItem 0, x1, 10
            If bstack.lastobj Is Nothing Then
                pppp.item(x1 - 2) = p
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(x1 - 2) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
        ElseIf IsStrExp(bstack, b$, s$, False) Then
            x1 = x1 + 1
            pppp.SerialItem 0, x1, 10
            If bstack.lastobj Is Nothing Then
                pppp.item(x1 - 2) = s$
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(x1 - 2) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
        End If
    Loop
    p = 0
    Set usehandler = New mHandler
    Set bstack.lastobj = usehandler
    usehandler.T1 = 3
    Set usehandler.objref = pppp
    Set usehandler = Nothing
    If FastSymbol(b$, ")#", , 2) Then
        GetArr = ExpMatrix(bstack, b$, p)
        If GetArr Then
            lookCompOrTuple = True
        End If
    Else
        GetArr = FastSymbol(b$, ")")
    End If
End Function
Function IsExpBig(basestack As basetask, A$, r As Variant, Optional ByVal noand1 As Boolean = True, Optional flatobject As Boolean = False, Optional Comp As Boolean = True, Optional nostring As Boolean) As Boolean
Dim par As Long, parin As Long, conthere As Boolean
If LastErNum = -2 Then LastErNum = 0
If A$ = vbNullString Then Exit Function
If Left$(A$, 2) = vbCrLf Then Exit Function
IsExpBig = IsExpA(basestack, A$, r, par, noand1, (Comp), , nostring)
again:
If par > 0 Then
    If lookOne(A$, ",") Then
        IsExpBig = GetArr(basestack, A$, r, "", 1, conthere)
        If LastErNum = -2 Then IsExpBig = False
        If IsExpBig Then
            par = par - 1
                If conthere Then
                If Len(A$) > 0 Then
                
                    IsExpBig = IsExpA(basestack, A$, r, par, noand1, Comp, conthere)
                End If
                End If
            If par > 0 Then
                GoTo again
            End If
        End If
    End If
End If
If Not IsExpBig Then
    If basestack.usestack Then
        IsExpBig = IsNumber(basestack, A$, r)
    End If
End If
If LastErNum = -2 Then IsExpBig = False
    While par > 0
        IsExpBig = FastSymbol(A$, ")")
        par = par - 1
    Wend
    If flatobject Then basestack.flatobject
End Function
Function IsExp(basestack As basetask, A$, r As Variant, Optional ByVal noand1 As Boolean = True, Optional flatobject As Boolean = False, Optional Comp As Boolean = True, Optional nostring As Boolean) As Boolean
Dim par As Long, parin As Long, conthere As Boolean
If LastErNum = -2 Then LastErNum = 0
If A$ = vbNullString Then Exit Function
If Left$(A$, 2) = vbCrLf Then Exit Function
IsExp = IsExpA(basestack, A$, r, par, noand1, (Comp), (0), nostring)
again:
If par > 0 Then
    If lookOne(A$, ",") Then
        IsExp = GetArr(basestack, A$, r, "", 1, conthere)
        If LastErNum = -2 Then IsExp = False
        If IsExp Then
            par = par - 1
                If conthere Then
                If Len(A$) > 0 Then
                
                    IsExp = IsExpA(basestack, A$, r, par, noand1, Comp, conthere)
                End If
                End If
            If par > 0 Then
                GoTo again
            End If
        End If
    End If
End If
If Not IsExp Then
    If basestack.usestack Then
        IsExp = IsNumber(basestack, A$, r)
    End If
End If
If LastErNum = -2 Then IsExp = False
While par > 0
    IsExp = FastSymbol(A$, ")")
    par = par - 1
Wend
If flatobject Then
    If IsExp Then
        IsExp = CheckBigInteger(basestack, r)
    Else
        Set basestack.lastobj = Nothing
    End If
End If
End Function
Function rightoperator(bstack As basetask, aa$, po As Variant, Optional onlyexp As Boolean) As Boolean
Dim r As Variant, ac As Variant, MUL As Long, r1 As Variant, IntVal As Integer, IntVal2 As Integer, BI As BigInteger
Dim cur As Long, park As Object, back As Object, rr, getcom As Boolean
r1 = 1
MUL = 0
''onlyexp = False
''second  loop Logic...
secodlooplogic:
Do
    If Fast2Symbol(aa$, "**", 2, "^", 1) Then
        ' get from right number or expression
        Set bstack.lastobj = Nothing
        IntVal2 = 1
        If IsNumber(bstack, aa$, r, True, IntVal2) Then
            If Not CheckBigInteger(bstack, r) Then
                rightoperator = False
                WrongType
                Exit Function
            End If
CONTaaabbcc:
            If IntVal2 = 2 Or IntVal2 = -1 Then
                If IntVal2 = 2 Then r = -r
                If Not rightoperator(bstack, aa$, r, True) Then
                  rightoperator = False
                  Exit Function
                End If
                If IntVal2 = 2 Then r = -r
            End If
            If TypeOf r Is cxComplex Then
            If IntVal2 = -1 Then
                r.r = -r.r
                r.I = -r.I
                IntVal2 = 0
            End If
            If TypeOf po Is cxComplex Then
                po = cxStabTwo("cxPow", po, r)
                rightoperator = True
                Exit Function
            Else
                po = cxStabTwo("cxPowRealComp", po, r)
                rightoperator = True
                Exit Function
            End If
            ElseIf TypeOf po Is cxComplex Then
                po = cxStabTwo("cxPowReal", po, r)
                rightoperator = True
                Exit Function
            End If
                               
            If r >= 1 And IntVal2 = 1 Then
                If IntVal = 2 Then
                r = -r
                If Not rightoperator(bstack, aa$, r, True) Then
                    MissNumExpr
                    rightoperator = False
                    Exit Function
                End If
                r = -r
            End If
                Select Case VarType(po)
                Case vbInteger
                    r = CInt(r)
                    If Err Then OverflowValue 100: Exit Function
                    po = IntExp(po, r, 1)
                    If po = 0.5 Or Not myVarType(po, vbInteger) Then OverflowValue vbInteger: Exit Function
                Case vbLong
                    r = CInt(r)
                    If Err Then OverflowValue 100: Exit Function
                    po = IntExp(po, CLng(r), 1&)
                    If po = 0.5 Or Not myVarType(po, vbLong) Then OverflowValue vbLong: Exit Function
                Case 20
                    r = CInt(r)
                    If Err Then OverflowValue 100: Exit Function
                    po = IntExp(po, cInt64(r), One64)
                    If po = 0.5 Or Not myVarType(po, 20) Then OverflowValue 20: Exit Function
                Case Else
                    po = po ^ r
                End Select
            Else
                    If (r >= -1 And r <= 1) And Sgn(po) < 0 Then
                        If IntVal = -1 Then
                            MyEr "Negative Number", "аЯМГТИЙч бэСГ"
                            rightoperator = False
                            Exit Function
                            End If
                        po = -po
                    End If
                    If IntVal2 < 0 Then
                        po = po ^ -r
                    Else
                        po = po ^ r
                    End If
            End If
                If lookTwoSame(aa$, "*") Then
                    GoTo secodlooplogic
                 ElseIf lookOne(aa$, "^") Then
                    GoTo secodlooplogic
                 End If
                If IntVal = 2 Then
                    If po > 0 Then po = -po
                ElseIf IntVal < 0 Then
                    po = -po
                End If
            IntVal = 0
            MUL = 1
            If Err.Number Then
                If r1 < 0 And IntVal = 0 Then
                    po = -Infinity()
                Else
                    po = Infinity()
                End If
            End If
        ElseIf lookOne(aa$, "(") Then
            getcom = False
            If logical(bstack, aa$, r, -1, True, getcom, , True) Then
            
                If Not CheckBigInteger(bstack, r) Then
                    rightoperator = False
                    WrongType
                    Exit Function
                End If
                If Not getcom Then
                If Not FastSymbol1(aa$, ")") Then
                    SyntaxError
                    rightoperator = False
                    Exit Function
                End If
                End If
                GoTo CONTaaabbcc
                'not used
                If r >= 1 And IntVal2 = 1 Then
                    po = po ^ r
                Else
                    If (r >= -1 And r <= 1) And Sgn(po) < 0 Then
                        po = -po
                    End If
                    If IntVal2 < 0 Then
                        po = po ^ -r
                    Else
                        po = po ^ r
                    End If
                End If
                If IntVal = 2 Then
                    If po > 0 Then po = -po
                ElseIf IntVal < 0 Then
                    po = -po
                End If
                IntVal = 0
                MUL = 1
                If Err.Number Then
                    po = Infinity()
                End If
            Else
                MissNumExpr
                rightoperator = False
            Exit Function
            End If
        Else
            MissNumExpr
            rightoperator = False
            Exit Function
        End If
    ElseIf MUL > 0 Then
            ' do it before we find next / or *
            Select Case MUL
            Case 500
            bstack.soros.DataVal r1
             r1 = 1
            Case 1
                If IntVal < 0 Then r1 = -r1
                IntVal = 0
                po = r1 * po
                If Err.Number = 6 Then
                    po = CDbl(r1) * CDbl(po)
                    Err.Clear
                End If
            
            Case 2
                If po = 0 Then
                    'DIVISION BY ZERO
                
                    DevZeroMacro aa$
                    rightoperator = False
                    Exit Function
                Else
                    po = r1 / po
                    If Err.Number = 6 Then
                        po = CDbl(r1) / CDbl(po)
                    End If
                End If
            Case 1000
                Set BI = BI.multiply(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
              '  Set bstack.lastobj = BI
                rightoperator = True
            Case 1010
                Set BI = BI.divide(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
              '  Set bstack.lastobj = BI
                rightoperator = True
            Case 1020
            Set BI = BI.Modulus(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
               ' Set bstack.lastobj = BI
                rightoperator = True

            End Select
            r1 = po
            MUL = 0
    ElseIf Not onlyexp Then
            If FastSymbol1(aa$, "*") Then
            
                If MUL = 0 Then
                    If IntVal < 0 Then po = -po
                End If
                cur = 1
                Do
                    If FastSymbol23(aa$, "-", cur, 1) Then
                        IntVal = -IntVal
                    ElseIf Not FastSymbol23(aa$, "+", cur, 1) Then
                        Exit Do
                    End If
                Loop
                If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set BI = bstack.lastobj
                End If
                Set bstack.lastobj = Nothing
                End If
                If logical(bstack, aa$, r, , , , IntVal) Then
                If TypeOf r Is cxComplex Then
                        WrongType
                        rightoperator = False
                        Exit Function
                End If
                If Not BI Is Nothing Then
jumpmult1:
                    If bstack.lastobj Is Nothing Then
                        Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
                        r = 0
                    End If
                    If Not bstack.lastobj Is Nothing Then
    
                        If TypeOf bstack.lastobj Is BigInteger Then
                            Set back = park
                            Set park = BI
jumpmult2:
                            If IntVal < 0 Then
                                Set BI = CopyBigInteger(bstack.lastobj)
                                BI.negate
                                IntVal = 1
                            Else
                                Set BI = bstack.lastobj
                            End If
                            MUL = 1000
                        
                        End If
                    End If
                Set bstack.lastobj = Nothing
                
                Else
                If r = 0 Then
                If Not bstack.lastobj Is Nothing Then
                If Not park Is Nothing Then
                Set back = park
                ElseIf ac <> 0 Then
                Set back = Module13.CreateBigInteger(CStr(Int(ac)))
                End If
                Set park = Module13.CreateBigInteger(CStr(Int(po)))
                    GoTo jumpmult2
                End If
                End If
                MUL = 1
                End If
                r1 = po
                po = r
                ElseIf FastSymbol1(aa$, "(") Then
                 If IntVal < 0 Then po = -po: IntVal = 0
                    If IsExp(bstack, aa$, r, , True) Then
                        MUL = 1
                        r1 = po
                        po = r
                        If Not FastSymbol1(aa$, ")") Then
                            rightoperator = False
                            Exit Function
                        End If
                        If Not BI Is Nothing Then GoTo jumpmult1
                        Set bstack.lastobj = Nothing
                    Else
                        rightoperator = False
                        Exit Function
                    End If
                Else
                    rightoperator = False
                    Exit Function
                End If
    
        ElseIf lookTwoSame(aa$, "/") Then
              rightoperator = True
             Exit Do
        ElseIf FastSymbol1(aa$, "/") Then
                    If MUL = 0 Then
                    If IntVal < 0 Then po = -po
                End If
                IntVal = 1
                cur = 1
                Do
                    If FastSymbol23(aa$, "-", cur, 1) Then
                        IntVal = -IntVal
                    ElseIf Not FastSymbol23(aa$, "+", cur, 1) Then
                        Exit Do
                    End If
                Loop
                If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set BI = bstack.lastobj
                End If
                Set bstack.lastobj = Nothing
                End If
                If logical(bstack, aa$, r, , , , IntVal) Then
                If Not BI Is Nothing Then

jumpdiv1:
                If bstack.lastobj Is Nothing Then
                    Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
                    r = 0
                End If
                If Not bstack.lastobj Is Nothing Then

                    If TypeOf bstack.lastobj Is BigInteger Then
                    If MemInt(VarPtr(back)) = vbObject Then
                    
                    ' add
                    End If
                    Set back = park
                    Set park = BI
jumpdiv2:
                    If IntVal < 0 Then
                    Set BI = CopyBigInteger(bstack.lastobj)
                    BI.negate
                    IntVal = 1
                    Else
                    Set BI = CopyBigInteger(bstack.lastobj)
                    End If
                    Set rr = BI
                    Set BI = park
                    Set park = rr
                    Set rr = Nothing
                    If Not MUL = 1020 Then MUL = 1010
                    
                    Else
                        Set bstack.lastobj = Nothing
                    End If
                Else
                    Set bstack.lastobj = Nothing
                End If
                Else
                If r = 0 Then
                If Not bstack.lastobj Is Nothing Then
                If Not park Is Nothing Then
                Set back = park
                ElseIf ac <> 0 Then
                Set back = Module13.CreateBigInteger(CStr(Int(ac)))
                End If
                Set park = Module13.CreateBigInteger(CStr(Int(po)))
                    GoTo jumpdiv2
                End If
                End If
                MUL = 2
                End If
                r1 = po
                po = r

                   ' IntVal = 0
                ElseIf FastSymbol1(aa$, "(") Then
                If IntVal < 0 Then po = -po: IntVal = 0
                    If IsExp(bstack, aa$, r, , True) Then
                        MUL = 2
                        r1 = po
                        po = r
                        If Not FastSymbol1(aa$, ")") Then
                            rightoperator = False
                            Exit Function
                        End If
                    Else
                        rightoperator = False
                        Exit Function
                    End If
                Else
                    rightoperator = False
                    Exit Function
                End If
            Else
                rightoperator = True
                Exit Do
            End If
        Else
            rightoperator = True
            Exit Do
        End If
Loop
If Not BI Is Nothing Then
    If Not park Is Nothing Then
        If TypeOf park Is BigInteger Then
            Set BI = BI.Add(park)
            po = 0
        Else
            WrongType
            rightoperator = False
            Exit Function
        End If
    End If

Set bstack.lastobj = BI
End If
End Function
'

Function IsExpA(bstack As basetask, aa$, rr As Variant, parenthesis As Long, Optional ByVal noand As Boolean = True, Optional ByVal Comp As Boolean = True, Optional ByPass As Boolean = False, Optional nostring As Boolean) As Boolean
    Dim r As Variant, ac As Variant, po As Variant, MUL As Long, r1 As Variant, ut$, back As Variant
    Dim logic As Boolean, IntVal As Integer, IntVal2 As Integer, park As Object, objlist As mStiva2, rightlevel As Long, usehandler As mHandler
    Dim cur As Long, BI As BigInteger, getcom As Boolean
    Const leavespace = 1
    On Error Resume Next
    IsExpA = False
    If Len(aa$) = 0 Then Exit Function
    If ByPass Then
        SwapVariant rr, r
        rr = 0
        cur = 1
        IntVal = 1
        GoTo again2
    End If
    rr = 0
    cur = 1
    Do While FastSymbol23(aa$, "(", cur, leavespace): parenthesis = parenthesis + 1: Loop
    If parenthesis > 0 Then Comp = True: noand = True
    po = CDbl(1) '1#
    ac = 0#
' sign
    r1 = 1
    cur = 1
        Do
        If FastSymbol23(aa$, "-", cur, leavespace) Then
            po = -po
        ElseIf FastSymbol23(aa$, "+", cur, leavespace) Then
            If Abs(po) < 10 Then
            If po < 0 Then po = -10 Else po = 10
            End If
        ElseIf FastSymbol23(aa$, "(", cur, leavespace) Then
                If Not GetArr(bstack, aa$, r, "", 0, getcom) Then
        
                
                IsExpA = False: Exit Function
                End If
              
                'If Not IsExpA(bstack, aa$, r, 0, noand, Comp, ByPass, nostring) Then
                 '   IsExpA = False
                 '   Exit Function
                'End If
                'If Not FastSymbol1(aa$, ")") Then IsExpA = False: Exit Function
                cur = 1
                IntVal = po
                GoTo cont456
                
        Else
            Exit Do
        End If
    Loop
    If cur > 1 Then GoTo cont123
    Do
enteragain:
    cur = 1
        Do
        If FastSymbol23(aa$, "-", cur, leavespace) Then
            po = -po
        ElseIf Not FastSymbol23(aa$, "+", cur, leavespace) Then
            Exit Do
        Else
            If Abs(po) < 10 Then
            If po < 0 Then po = -10 Else po = 10
            End If
        End If
    Loop
cont123:
    IntVal = po ' if we have number literal we give the sign to string to binary function
    If logical(bstack, aa$, r, parenthesis, , ByPass, IntVal, nostring) Then
    ' R positive or negative for Variables, sign has to be preserved
    ' R maybe negative for numbers, sign has to be preserved except for power which not included
cont456:
    If IntVal = 2 Then
    po = 1#
    'IntVal =1
    Else
    po = 0#
    End If
 
 '   po = IntVal ' now we pass the changed/or not changed sign to po
again2:
        If Not bstack.lastobj Is Nothing Then
            If IntVal = -1 Then po = -1: IntVal = 0
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                If usehandler.T1 = 4 Then
                    If myVarType(usehandler.index_cursor, vbString) Then
                        If nostring Then
                            MissNumExpr
                            IsExpA = False
                            Exit Function
                        Else
                            r = usehandler.index_cursor: Set bstack.LastEnum = usehandler.objref
                        End If
                    Else
                        r = usehandler.index_cursor * usehandler.sign: Set bstack.LastEnum = usehandler.objref
                        If po < 0 Then r = -r: po = -po: usehandler.sign = -usehandler.sign
                End If
                    
                End If
                GoTo cont111333
            ElseIf TypeOf bstack.lastobj Is refArray Then
                GoTo cont111333
            ElseIf lookTwoSame(aa$, "/") Then
            ElseIf MaybeIsSymbol(aa$, "/*-+=~^&|<>?") Then
            '' get operator
                Dim ss$, ss1$
                If TypeOf bstack.lastobj Is Group Then
                    If Not bstack.lastpointer Is Nothing Then
                        If bstack.lastpointer.IamFloatGroup Then
                            Set bstack.lastobj = bstack.lastpointer
                        Else
                            With bstack.lastobj
                                ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                            End With
                            IsNumber bstack, ut$, r
                        End If
                        Set bstack.lastpointer = Nothing
                    End If
                    MUL = MyTrimL(aa$)
                    If Mid$(aa$, MUL, 1) Like "[<>]" Then
                        If MaybeIsSymbol(Mid$(aa$, MUL + 1, 1), "=>") Then
                            ss$ = Mid$(aa$, MUL, 2)
                            Mid$(aa$, 1, MUL + 1) = space(MUL + 1)
                        Else
                            ss$ = Mid$(aa$, MUL, 1)
                            Mid$(aa$, 1, MUL) = space(MUL)
                        End If
                    Else
                        If MaybeIsSymbol(Mid$(aa$, MUL + 1, 1), "[^|!~=*/]") Then
                            ss$ = Mid$(aa$, MUL, 2)
                            Mid$(aa$, 1, MUL + 1) = space(MUL + 1)
                        Else
                            If Mid$(aa$, MUL, 2) = "->" Then MUL = 0: GoTo LeaveIt
                            ss$ = Mid$(aa$, MUL, 1)
                            Mid$(aa$, 1, MUL) = space(MUL)
                        End If
                    End If
                    If po = -1 Then
                        'Set park = Nothing
                        If bstack.lastobj.HasUnary Then ProcessOper bstack, Nothing, "-:", r, (0)
                        po = -po
                    End If
                    IntVal = 0
withoper:
                    Set park = bstack.lastobj
                    Set bstack.lastobj = Nothing
againoper:
                    If ss$ Like "[<>=]*" Then
                    
                        If IsExpBig(bstack, aa$, r, False) Then
                            If bstack.lastobj Is Nothing Then
                                If Not park Is Nothing Then
                                    If TypeOf park Is Group Then
                                        ProcessOper bstack, park, ss$, r, 1
                                        MUL = 1  ' why: used from MID$()
                                        GoTo cont4567
                                    Else
                                        MissingGroup
                                    End If
                                Else
                                    MissingGroup
                                End If
                            Else
                                If (TypeOf bstack.lastobj Is Group) And (TypeOf park Is Group) Then
                                    ProcessOper bstack, park, ss$, r, 1
                                    MUL = 0 ' not used  old: 1  ' why: used from MID$()
                                    GoTo cont4567
                                Else
                                    MissingGroup
                                End If
                            End If
                        Else
                            MissNumExpr
                        End If
                        IsExpA = False
                        Exit Function
                    End If
                    
                    Do While MaybeIsSymbol(aa$, "+-")
                        If FastSymbol1(aa$, "-") Then po = -po
                        FastSymbol1 aa$, "+"
                    Loop
                    If Not IsSymbol(aa$, "(") Then
getnextnum:
                        If IsNumber(bstack, aa$, r) Then
                        ' check if we have group
                        If bstack.lastobj Is Nothing Then MissingGroup: IsExpA = False: Exit Function
                        If Not TypeOf bstack.lastobj Is Group Then MissingGroup: IsExpA = False: Exit Function
                        If Not bstack.lastpointer Is Nothing Then
                            If bstack.lastpointer.IamFloatGroup Then
                                If bstack.lastpointer Is NullGroup Then
                                    Set bstack.lastobj = New Group
                                    bstack.lastobj.BeginFloat 0
                                    bstack.lastobj.EndFloat
                                Else
                                    Set bstack.lastobj = bstack.lastpointer
                                End If
                            Else
                                With bstack.lastobj
                                    ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                                End With
                                IsNumber bstack, ut$, r
                            End If
                            Set bstack.lastpointer = Nothing
                        End If
                        ' process unary if we have one
                        If po = -1 Then
                            If bstack.lastobj.HasUnary Then ProcessOper bstack, Nothing, "-:", r, (0)
                            po = -po
                        End If
processobjlist:
                    If Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is Group Then
                            If Not bstack.lastpointer Is Nothing Then
                                If bstack.lastpointer.IamFloatGroup Then
                                    Set bstack.lastobj = bstack.lastpointer
                                Else
                                    With bstack.lastobj
                                    ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                                End With
                                IsNumber bstack, ut$, r
                            End If
                            Set bstack.lastpointer = Nothing
                        End If
                        MUL = MyTrimL(aa$)
                        If lookTwoSame(aa$, "/") Then
                        ElseIf MaybeIsSymbol(Mid$(aa$, MUL, 1), "/*-+=~^&|<>?") Then
                            If MaybeIsSymbol(Mid$(aa$, MUL, 2), ">=") Then
                                GoTo groupoperation
                            ElseIf InStr(bstack.lastobj.highpriorityoper, "[R" + Mid$(aa$, MUL, 2) + "]") Then
                                ss1$ = Mid$(aa$, MUL, 2)
                                Mid$(aa$, 1, MUL + Len(ss1$) - 1) = space(MUL + Len(ss1$) - 1)
                                If objlist Is Nothing Then Set objlist = New mStiva2
                                objlist.PushObj park
                                objlist.PushStr ss$
                                Set park = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                ss$ = ss1$
                                rightlevel = rightlevel + 1
                                GoTo againoper
                            Else
                                If rightlevel > 0 Then
                                    rightlevel = rightlevel - 1
                                    GoTo comehere
                            End If
                            ss1$ = Mid$(aa$, MUL, 1)
                        End If
                        If Mid$(aa$, MUL, 2) = "->" Then GoTo groupoperation
                        If InStr(bstack.lastobj.highpriorityoper, "[" + ss1$ + "]") Then
                            Mid$(aa$, 1, MUL + Len(ss1$) - 1) = space(MUL + Len(ss1$) - 1)
                            If InStr(bstack.lastobj.highpriorityoper, "[" + ss$ + "]") Then
                                ProcessOper bstack, park, ss$, r, 1
                                MUL = 1
                                If objlist Is Nothing Then Set objlist = New mStiva2
                                Set park = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                ss$ = ss1$
                                GoTo againoper
                            Else
                                If objlist Is Nothing Then Set objlist = New mStiva2
                                objlist.PushObj park
                                objlist.PushStr ss$
                                Set park = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                ss$ = ss1$
                                GoTo againoper
                            End If
                        Else
                            ' why
                            If objlist Is Nothing Then Set objlist = New mStiva2
                            If objlist.IsEmpty Then
                                ProcessOper bstack, park, ss$, r, 1
                                MUL = 1
                                GoTo again2
                            Else
comehere:
                                ProcessOper bstack, park, ss$, r, 1
                                MUL = 1
                                Set park = bstack.lastobj
                                If Not objlist Is Nothing Then
                                    If Not objlist.IsEmpty Then
                                        ss$ = objlist.PopStr
                                        Set park = objlist.PopObj
                                        ProcessOper bstack, park, ss$, r, 1
                                        GoTo again2
                                    End If
                                End If
                                GoTo again2
                            End If
                        End If
                    Else
                        If objlist Is Nothing Then
                            ProcessOper bstack, park, ss$, r, 1
                            Set objlist = New mStiva2
                            If ss1$ <> "" Then
                                objlist.PushObj park
                                objlist.PushStr ss$
                                Set park = bstack.lastobj
                                ss$ = ss1$
                                GoTo againoper
                                MUL = 1
                            End If
                            GoTo again2
                        Else
                            If objlist.IsEmpty Then
                                ProcessOper bstack, park, ss$, r, 1
                                MUL = 1
                                GoTo again2
                            Else
                                ProcessOper bstack, park, ss$, r, 1
                                MUL = 1
                                ss$ = objlist.PopStr
                                Set park = objlist.PopObj
                                GoTo groupoperation
                            End If
                        End If
                    End If
                End If
                If InStr(bstack.lastobj.highpriorityoper, "[" + ss$ + "]") Then
                    ProcessOper bstack, park, ss$, r, 1
                    ss$ = ss1$
                    MUL = 1
                    Set park = bstack.lastobj
                    GoTo getnextnum
                Else
                    If objlist Is Nothing Then Set objlist = New mStiva2
                    objlist.PushObj park
                    objlist.PushStr ss$
                    Set park = bstack.lastobj
                    ss$ = ss1$
                    ss1 = vbNullString
                    GoTo getnextnum
                End If
            End If
            GoTo groupoperation
        Else
            MissObject aa$
            IsExpA = False
            Exit Function
        End If
        
    ElseIf IsExpBig(bstack, aa$, r, False) Then
        If Not ss$ Like "[<>=]*" Then FastSymbol1 aa$, ")"
groupoperation:
            If Not (bstack.lastobj Is Nothing) And Not (park Is Nothing) Then
                If (TypeOf bstack.lastobj Is Group) And (TypeOf park Is Group) Then
                    ProcessOper bstack, park, ss$, r, 1
                    MUL = 1  ' why
                    If Not objlist Is Nothing Then
                        If Not objlist.IsEmpty Then
                            ss$ = objlist.PopStr
                            Set park = objlist.PopObj
                            GoTo processobjlist
                        Else
                            Set park = bstack.lastobj
                        End If
                    Else
                        Set park = bstack.lastobj
                    End If
                            
cont4567:
                            
                    If lookOne(aa$, ")") Then
   
                                If parenthesis > 0 Then
                                FastSymbol1 aa$, ")"
                                    parenthesis = parenthesis - 1
                                    processAcAndPoSimple ac, po
                                Else
                                    If po = 1 Then
                                        po = r
                                    ElseIf po = -1 Then
                                        po = -r
                                    Else
                                    po = po * r
                                    End If
                                    If ac = 0 Then
                                    rr = po
                                    Else
                                        rr = ac
                                        rr = rr + po
                                        If Err.Number = 6 Then
                                            rr = CDbl(rr) + CDbl(po)
                                            Err.Clear
                                        End If
                                    End If
                                    IsExpA = True
                                     Set park = Nothing
                                    Exit Function
                                End If
                                ' maybe here a MUL=0
                            End If
                            po = 1
                            If Not bstack.lastobj Is Nothing Then GoTo again2
                            'Set park = Nothing
                        Else
                             MyEr "Wrong Operator", "кэХОР тЕКЕСТчР"
                             IsExpA = False
                             Exit Function
                        End If
                        
                    Else
                        Set park = Nothing
                        If (MUL + Len(ss$) - 1) > 0 Then
                            If aa$ = vbNullString Then
                                aa$ = ss$
                            Else
                             '   Mid$(aa$, 1, MUL + Len(ss$) - 1) = ss$
                            End If
                        End If
                        MUL = 0
                    End If
                End If
                ElseIf TypeOf bstack.lastobj Is BigInteger Then
                    
addmore:
                    Set BI = bstack.lastobj
                    If po = -1 Then
                      If IntVal <> 0 Then
                            IntVal = -IntVal
                            po = 0
                        Else
                            Set BI = Nothing
                            Set BI = CopyBigInteger(bstack.lastobj)
                            BI.negate
                         '   Set bstack.lastobj = BI
                            po = 0
                        End If
                    End If
                    Set bstack.lastobj = Nothing
                    IsExpA = True
                    If FastSymbol(aa$, "+") Then
                        GoTo jumpplus
                    ElseIf FastSymbol(aa$, "-") Then
                        If IntVal <> 0 Then
                        IntVal = -IntVal
                        Else
                        IntVal = -1
                        End If
                        po = 0
                        GoTo jumpplus
                    ElseIf FastSymbol(aa$, "**", , 2) Then
                        GoTo jumppow
                    ElseIf FastSymbol(aa$, "*") Then
                        GoTo jumpmult
                    ElseIf FastSymbol(aa$, "/") Then
                        GoTo jumpdiv
                    ElseIf FastSymbol(aa$, "=") Then
                        GoTo jumpequ
                    ElseIf FastSymbol(aa$, "<") Then ' <=>, <>, <=, <
                        GoTo jumpmax
                    ElseIf FastSymbol(aa$, ">") Then ' >, >=
                        GoTo jumpmin
                    ElseIf FastSymbol(aa$, "^") Then
                        GoTo jumppow
                    End If
                    
                    Exit Function
                ' maybe is an error or not ???
                End If
            ElseIf po = -1 And TypeOf bstack.lastobj Is Group Then
                If Not bstack.lastpointer Is Nothing Then
                    If bstack.lastpointer.IamFloatGroup Then
                Set bstack.lastobj = bstack.lastpointer
                Else
                With bstack.lastobj
                    ss$ = "Group(" + .lasthere + "." + .GroupName + ")"
                End With
                 IsNumber bstack, ss$, r
                End If
                Set bstack.lastpointer = Nothing
                End If
                    po = -po
                    Set park = Nothing
                    If bstack.lastobj.HasUnary Then ProcessOper bstack, park, "-:", r, (0)
again3:

                    If Not objlist Is Nothing Then
                    If Not objlist.IsEmpty Then
                    Set park = objlist.PopObj
                    ss$ = objlist.PopStr
                    ProcessOper bstack, park, ss$, r, 1
                    MUL = 1
                    ElseIf Len(aa$) > 0 Then
                    If Fast2LabelNoNum(aa$, "WITH", 4, "ле", 2, 5) Then GoTo a1290456
                    End If
                    
                    ElseIf Len(aa$) > 0 Then
                        If Fast2LabelNoNum(aa$, "WITH", 4, "ле", 2, 5) Then
a1290456:
                            If TypeOf bstack.lastobj Is Group Then
                                If Not bstack.lastpointer Is Nothing Then
                                    If bstack.lastpointer.IamFloatGroup Then
                                      If bstack.lastpointer Is NullGroup Then
                                            Set bstack.lastobj = New Group
                                            bstack.lastobj.BeginFloat 0
                                            bstack.lastobj.EndFloat
                                        Else
                                        Set bstack.lastobj = bstack.lastpointer
                                        End If
                                    Else
                                        With bstack.lastobj
                                            ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                                        End With
                                        IsNumber bstack, ut$, r
                                    End If
                                    Set bstack.lastpointer = Nothing
                                End If
                            End If
                             ss$ = "''"
                             GoTo withoper
                        End If
                    End If
                        If lookOne(aa$, ")") Then
                     
                                If parenthesis > 0 Then
                                FastSymbol1 aa$, ")"
                                    parenthesis = parenthesis - 1
                                    processAcAndPoSimple ac, po
                                    GoTo again2
                                Else
                                    If po = 1 Then
                                        po = r
                                    ElseIf po = -1 Then
                                        po = -r
                                    Else
                                    po = po * r
                                    End If
                                    If ac = 0 Then
                                    rr = po
                                    Else
                                    rr = ac + po
                                        rr = ac
                                        rr = rr + po
                                        If Err.Number = 6 Then
                                            rr = CDbl(rr) + CDbl(po)
                                            Err.Clear
                                        End If
                                    End If
                                    IsExpA = True
                                     Set park = Nothing
                                    Exit Function
                                End If
                End If
                MUL = 0
            ElseIf TypeOf bstack.lastobj Is BigInteger Then
                Set BI = CopyBigInteger(bstack.lastobj)
                If po < 0 Then BI.negate
                Set bstack.lastobj = Nothing
                'Set BI = Nothing
                po = 0
            Else
                If TypeOf bstack.lastobj Is Group Then GoTo again3
            End If
      
            'MUL = 0
cont111333:
        If MaybeIsSymbol(aa$, "IiеЕ") Then
            If Fast2LabelNoNum(aa$, "IS", 2, "еимаи", 5, 5) Then
                Set r1 = bstack.lastobj
                If r1 Is Nothing Then
                    NoObjectFound
                    IsExpA = False
                    Exit Function
                Else
                    IntVal = 0
                    If TypeOf r1 Is Group Then
                        If r1.IamApointer Then
                            If r1.link.IamFloatGroup Then
                                Set r1 = r1.link
                            Else
                                If GetVar(bstack, r1.lasthere + "." + r1.GroupName, rightlevel) Then
                                    Set r1 = var(rightlevel)
                                    rightlevel = 0
                                Else
                                    Set r1 = New Group
                                End If
                            End If
                        Else
                            IntVal = 1
                        End If
                    End If
                    Set bstack.lastobj = Nothing
                    Set bstack.lastpointer = Nothing
                    
                    If TypeOf r1 Is Group Then
                        If Fast2LabelNoNum(aa$, "TYPE", 4, "тупос", 5, 5) Then
                            If FastPureLabel(aa$, ut$, , True) Then
                                IsExpA = True
                                ac = 0
                                r = r1.TypeGroup(ut$)
                                r1 = 1
                                MUL = 0
                                GoTo LeaveIt
                            Else
syner:
                                SyntaxError
                                IsExpA = False
                                Exit Function
                            End If
                        ElseIf GetPointer(bstack, aa$) Then
                            Set r = bstack.lastpointer
                            Set bstack.lastpointer = Nothing
                            Set bstack.lastobj = Nothing
                        Else
                            Set bstack.lastobj = Nothing
                            NoObjectFound
                            IsExpA = False
                            Exit Function
                        End If
                        If TypeOf r Is Group Then
                            If r.IamApointer Then
                                If r.link.IamFloatGroup Then
                                    Set r = r.link
                                Else
                                    If GetVar(bstack, r.lasthere + "." + r.GroupName, rightlevel) Then
                                        Set r = var(rightlevel)
                                        rightlevel = 0
                                    Else
                                        Set r1 = New Group
                                    End If
                                End If
                            End If
                        End If
                    ElseIf TypeOf r1 Is mHandler Then
                    Set usehandler = r1
                    If usehandler.T1 = 2 Then
                    If Fast2LabelNoNum(aa$, "TYPE", 4, "тупос", 5, 5) Then
                            If FastPureLabel(aa$, ut$, , True, , , , True) Then
                            If usehandler.objref.UseStruct Then
                           
                            If usehandler.objref.structref.Tag = ut$ Then
                                Set usehandler = Nothing
                                IsExpA = True
                                ac = 0
                                r = True
                                r1 = 1
                                MUL = 0
                                GoTo LeaveIt
                            End If
                            End If
                            End If
                        GoTo syner
                    End If
                    End If
                    If FastSymbol(aa$, "(") Then
                    If IsExp(bstack, aa$, r, , , False) Then
                    If FastSymbol(aa$, ")") Then GoTo contHereHandler
                    End If
                    Else
                    If IsNumber(bstack, aa$, r) Then GoTo contHereHandler
                    If IsExp(bstack, aa$, r, , , False) Then GoTo contHereHandler
                    End If
                    IsExpA = False
                    Exit Function
                    
                    ElseIf Fast2LabelNoNum(aa$, "NOTHING", 7, "типота", 6, 7) Then
                        If TypeOf r1 Is mHandler Then
                            If CheckLastHandlerVariant(r1) Then
                                Set usehandler = r1
                                If usehandler.indirect > 0 Then
                                    Set r1 = var(usehandler.indirect)
                                Else
                                    Set r1 = usehandler.objref
                                End If
                            End If
                        End If
                        Set r = Nothing
                        Set usehandler = Nothing
                    ElseIf IsNumber(bstack, aa$, r) Then
contHereHandler:
                        Set bstack.lastpointer = Nothing
                        If bstack.lastobj Is Nothing Then
                            NoObjectFound
                            IsExpA = False
                            Exit Function
                        End If
                        Set r = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            If TypeOf r1 Is mHandler Then
                                If CheckLastHandlerVariant(r1) Then
                                    Set usehandler = r1
                                    If usehandler.indirect > 0 Then
                                        Set r1 = var(usehandler.indirect)
                                    Else
                                        Set r1 = usehandler.objref
                                    End If
                                End If
                            End If
                            If TypeOf r Is mHandler Then
                                If CheckLastHandlerVariant(r) Then
                                    Set usehandler = r
                                    If usehandler.indirect > 0 Then
                                        Set r = var(usehandler.indirect)
                                    Else
                                        Set r = usehandler.objref
                                    End If
                                End If
                            End If
                        Set usehandler = Nothing
                    End If
                    IsExpA = True
                    ac = 0
                    If IntVal Then
                        If r1.PointerPtr <> 0 Then
                            r = CBool(r1.PointerPtr = ObjPtr(r))
                        Else
                            r = CBool(r1 Is r)
                        End If
                    Else
                        r = CBool(r1 Is r)
                    End If
                    r1 = 1
                End If
            End If
        End If
        If MUL <> 0 Then
    If po = 1 Then
        rr = r
    ElseIf po < 0 Then
        rr = -r
    Else
        rr = po * r
    End If
        
        IsExpA = True
        Exit Function
        End If
    End If

LeaveIt:
    IsExpA = True
    r1 = 1
    'IntVal = 0
    
   
    If po = 1 Then
        po = r
    ElseIf po < 0 Then
        po = -r
    ElseIf myVarType(r, vbString) Then
        SwapVariant po, r
        r = 1
    Else
        po = r
    End If
    GoTo secodlooplogic
ElseIf LastErNum1 < 0 Then
    Exit Function
ElseIf parenthesis = 1 Then
    Dim s$
    If IsStrExp(bstack, aa$, s$, False) Then
        IsExpA = GetArr(bstack, aa$, r, s$, 2, getcom)
        If IsExpA Then parenthesis = 0
        po = 0
    End If
    ElseIf FastSymbol1(aa$, "(") Then
        po = IntVal
        
        If IsExpBig(bstack, aa$, r) Then
            IsExpA = True
            If po = -1 Then
                If Not bstack.lastobj Is Nothing Then
                    If Typename(bstack.lastobj) = mGroup Then
                        po = r
                        Set park = Nothing
                        ProcessOper bstack, park, "-:", r, (0)
                        IntVal = 1
                        r1 = 1
                        MUL = 0
                        GoTo secodlooplogic
                    End If
                Else
            '        po = -R
                    po = r
                End If
            Else
             '   po = po * R
             po = r
            End If
            If Not FastSymbol1(aa$, ")") Then
                SyntaxError
                IsExpA = False
                Exit Function
            End If
           
            r1 = 1
            'IntVal = 0
            MUL = 0
            GoTo secodlooplogic
        Else
            IsExpA = False
            Exit Function
        End If
    Else
          ' NEVER RAISE ERROR HERE (THROUGH MissNumExpr)
          
        If cur = 1 Then
        Exit Function
        Else
        IsExpA = False
        End If
            Exit Function
    End If
    
    
   If IntVal < 0 Then r1 = -r1
        MUL = 0
        ''second  loop Logic...
secodlooplogic:
        Do
        
        If Fast2Symbol(aa$, "**", 2, "^", 1) Then
jumppow:
            If Not BI Is Nothing Then
                If BI.Length < 27 Then
                    po = CDec(BI.ToString)
                    Set BI = Nothing
                Else
                    GoTo wrong
                End If
            End If
            Set bstack.lastobj = Nothing
            ' get from right number or expression
                If MemInt(VarPtr(po)) = 36 Then
                    If Not TypeOf po Is cxComplex Then Exit Function
                    If IntVal = -1 Then
                     r1 = -1
                    End If
                        IntVal = 0
                        IntVal2 = 1
                        cur = 1
                        getcom = False
                        Do
                            If FastSymbol23(aa$, "-", cur, 1) Then
                                IntVal2 = -IntVal2
                            ElseIf Not FastSymbol23(aa$, "+", cur, 1) Then
                                Exit Do
                            End If
                            getcom = True
                        Loop
                        If Not getcom Then
                            IntVal2 = 0
                        End If
                        getcom = False
                        If FastSymbol1(aa$, "(") Then
                            If IsExpBig(bstack, aa$, r, , False, False) Then
                                If FastSymbol(aa$, ",") Then
                                    If IsExpBig(bstack, aa$, back, , False, False) Then
                                        If LCase(Left$(aa$, 2)) = "i)" Then
                                            Mid$(aa$, 1, 1) = " "
                                            r = nMath2.cxNew(r, back)
                                        End If
                                    End If
                                End If
                                If Not FastSymbol(aa$, ")") Then Exit Function
                                    GoTo cont1122
                                Else
                                    Exit Function
                                End If
                        ElseIf IsNumber(bstack, aa$, r) Then
cont1122:
                        If IntVal2 <> 0 Then
                            If Not rightoperator(bstack, aa$, r, True) Then
                              IsExpA = False
                              Exit Function
                              End If
                              If IntVal2 = -1 Or IntVal2 = 2 Then
                              If TypeOf r Is cxComplex Then
                                r.r = -r.r
                                r.u = -r.I
                                
                              Else
                                r = -r
                              End If
                              IntVal2 = 0
                              End If
                    End If
                        
                    

                    If Not CheckBigInteger(bstack, r) Then
                        GoTo wrong
                    End If
CONT1234:
                    If Not TypeOf r Is cxComplex Then
                        po = cxStabTwo("cxPowReal", po, r)
                    ElseIf Not TypeOf po Is cxComplex Then
                        If IntVal = 2 Then po = -po
                        If po < 0 Then
                        ' problem
                        End If
                        po = cxStabTwo("cxPowRealComp", po, r)
                        If IntVal = 2 Then
                        IntVal = 0
                        r1 = -1
                        End If
                    Else
                        po = cxStabTwo("cxPow", po, r)
                    End If
                    MUL = 1
                    GoTo contpow2
                End If
            Else
            If IntVal = 0 And po < 0 Then
                po = Abs(po)
                IntVal = 2
            ElseIf IntVal2 = -1 Then
                IntVal = 0
            End If
            End If
            IntVal2 = 1
            
            

            If IsNumber(bstack, aa$, r, False, IntVal2) Then
                If Not CheckBigInteger(bstack, r) Then
                    GoTo wrong
                End If
conta123b:
                
                If IntVal2 = 2 Or IntVal2 = -1 Then
                   If IntVal2 = 2 Then r = -r
                    If Not rightoperator(bstack, aa$, r, True) Then
                      IsExpA = False
                      Exit Function
                    End If
                    If IntVal2 = 2 Then r = -r
                ElseIf IntVal2 = 10 Then
                    If Not rightoperator(bstack, aa$, r, True) Then
                      IsExpA = False
                      Exit Function
                    End If
                End If
                If TypeOf r Is cxComplex Then
                    If IntVal2 = -1 Or IntVal2 = 2 Then
                        r.r = -r.r
                        r.I = -r.I
                        IntVal2 = 0
                    End If
                    GoTo CONT1234
                ElseIf r < 0 Then
                    If Not rightoperator(bstack, aa$, r, True) Then
                      IsExpA = False
                      Exit Function
                      End If
                End If
               
                If r >= 1 And IntVal2 = 1 Then
                    Select Case VarType(po)
                    Case vbInteger
                        r = CInt(r)
                        If Err Then OverflowValue 100: Exit Function
                        po = IntExp(po, r, 1)
                        If po = 0.5 Or Not myVarType(po, vbInteger) Then OverflowValue vbInteger: Exit Function
                    Case vbLong
                        r = CInt(r)
                        If Err Then OverflowValue 100: Exit Function
                        po = IntExp(po, CLng(r), 1&)
                        If po = 0.5 Or Not myVarType(po, vbLong) Then OverflowValue vbLong: Exit Function
                    Case 20
                        r = CInt(r)
                        If Err Then OverflowValue 100: Exit Function
                        po = IntExp(po, cInt64(r), One64)
                        If po = 0.5 Or Not myVarType(po, 20) Then OverflowValue 20: Exit Function
                    Case Else
                        po = po ^ r
                    End Select
                Else
                        If (r >= -1 And r <= 1) And Sgn(po) < 0 Then
                        
                            
                            If IntVal = -1 Then
                            MyEr "Negative Number", "аЯМГТИЙч бэСГ"
                            IsExpA = False
                            Exit Function
                            End If
                            po = -po
                        End If
                    
                        If IntVal2 < 0 Then
                            po = po ^ -r
                        Else
                            po = po ^ r
                        End If
                End If
                 If lookTwoSame(aa$, "*") Then
                    GoTo secodlooplogic
                 ElseIf lookOne(aa$, "^") Then
                    GoTo secodlooplogic
                 End If
              
                
                If IntVal = 2 Then
                    If po > 0 Then
                    GoTo aa123
                    End If
                ElseIf IntVal < 0 Then
aa123:
                    If TypeOf po Is cxComplex Then
                        po.r = -po.r
                        po.I = -po.I
                    Else
                        po = -po
                    End If
                End If
                IntVal = 0
                If MUL = 0 Then MUL = 1
contpow2:
                If Err.Number Then
                    If r1 < 0 And IntVal = 0 Then
                        po = -Infinity()
                    Else
                        po = Infinity()
                    End If
                    Set park = Nothing
                Else
                    If Not park Is Nothing Then
                        If TypeOf park Is BigInteger Then
                            Set BI = park
                            Set BI = BI.Add(Module13.CreateBigInteger(CStr(Int(po))))
                            Set park = Nothing
                        End If
                    End If
                End If
            ElseIf lookOne(aa$, "(") Then
            getcom = False
                If logical(bstack, aa$, r, -1, True, getcom, , True) Then
                    If IntVal2 < 0 Then
                        GoTo conta123b
                    End If
                    If TypeOf r Is cxComplex Then
                        po = cxStabTwo("cxPowRealComp", po, r)
                        r = 1
                        IntVal = 1
                    ElseIf r >= 1 And IntVal2 = 1 Then
                        po = po ^ r
                    Else
                        If (r >= -1 And r <= 1) And Sgn(po) < 0 Then
                            po = -po
                        End If
                        If IntVal2 < 0 Then
                            po = po ^ -r
                        Else
                            po = po ^ r
                            
                        End If
                    End If
                    If IntVal = 2 Then
                        If po > 0 Then po = -po
                    ElseIf IntVal < 0 Then
                        po = -po
                        IntVal = 1
                    Else
                        IntVal = 1
                    End If
                    
                    If MUL = 0 Then MUL = 1
                    If Err.Number Then
                        po = Infinity()
                    End If
                    If Not getcom Then
                        If Not FastSymbol1(aa$, ")") Then
                            SyntaxError
                            IsExpA = False
                            Exit Function
                        End If
                    End If
                Else
                    MissNumExpr
                    IsExpA = False
                    Exit Function
                End If
            Else
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
           
        ElseIf MUL > 0 Then
            ' do it before we find next / or *
            Set bstack.lastobj = Nothing
            Select Case MUL
            Case 500
                bstack.soros.DataVal r1
                r1 = 1
            Case 1
                If MemInt(VarPtr(po)) = 36 Then
                If Not TypeOf po Is cxComplex Then Exit Function
                    If TypeOf r1 Is cxComplex Then
                    
                        If IntVal < 0 Then r1.r = -r1.r: r1.I = -r1.I
                        IntVal = 0
                        po = cxStabTwo("cxMul", po, r1)
                        r1 = 1
                    Else
                        If IntVal < 0 Then r1 = -r1
                        IntVal = 0
                        If r1 <> 1 Then
                        po = cxStabTwo("cxMulReal", po, r1)
                        End If
                    End If
                ElseIf TypeOf r1 Is cxComplex Then
                    If IntVal < 0 Then r1.r = -r1.r: r1.I = -r1.I
                        IntVal = 0
                        po = cxStabTwo("cxMulReal", r1, po)
                Else
                If IntVal < 0 Then r1 = -r1
                IntVal = 0
                po = r1 * po
                If Err.Number = 6 Then
                    po = CDbl(r1) * CDbl(po)
                    Err.Clear
                End If
                End If
            Case 2
                If MemInt(VarPtr(po)) = 36 Then
                If Not TypeOf po Is cxComplex Then Exit Function
                    If TypeOf r1 Is cxComplex Then
                        
                        po = cxStabTwo("cxDiv", r1, po)
                        If LastErNum <> 0 Then
                        IsExpA = False
                        Exit Function
                        End If
                    Else
                    po = cxStabTwo("cxDivReal", po, r1)
                        If LastErNum <> 0 Then
                        IsExpA = False
                        Exit Function
                        End If
                    End If
                ElseIf TypeOf r1 Is cxComplex Then
                    po = cxStabTwo("cxRealDiv", po, r1)
                        If LastErNum <> 0 Then
                        IsExpA = False
                        Exit Function
                        End If
                Else
                    If po = 0 Then
divzero:
                        'DIVISION BY ZERO
                        DevZeroMacro aa$
                        IsExpA = False
                        Exit Function
                    Else
                        po = r1 / po
                        If Err.Number = 6 Then
                        po = CDbl(r1) / CDbl(po)
                        End If
                    End If
                End If
            Case 3
               ' po = r1 * po
                po = CBool(CBool(r1) And CBool(po))
            Case 4, 44
                '' check for **, ^, /, *

                If MUL = 4 Then
jumpDiv4:
                  '  po = Fix(R1 / po)
                    Select Case VarType(po)
                    Case vbCurrency
                        Select Case VarType(r1)
                        Case vbLong, vbInteger, 20, vbCurrency
                        po = Fix(r1 / po + 0@)
                        Case Else
                        po = Fix(r1 / po)
                        End Select
                    Case vbLong, vbInteger, 20
                    Select Case VarType(r1)
                    Case vbLong, vbInteger, 20
                        po = r1 \ po
                    Case Else
                        po = Fix(r1 / po)
                    End Select
                    Case Else
                        po = Fix(r1 / po)
                        
                    End Select
                    If Err.Number = 11 Then
                        Err.Clear
                        DevZeroMacro aa$
                        IsExpA = False
                        Exit Function
                    End If
                Else
jumpdiv44:
                    If po < 0 Then
                        Select Case VarType(po)
                        Case vbLong, vbInteger, 20
                            Select Case VarType(r1)
                            Case vbLong, vbInteger, 20
                                 po = (r1 - Abs(r1 - Abs(po) * (r1 \ Abs(po)))) \ po
                            Case Else
                                po = Int((r1 - Abs(r1 - Abs(po) * Int(r1 / Abs(po)))) \ po)
                            End Select
                        Case Else
                             po = Int((r1 - Abs(r1 - Abs(po) * Int(r1 / Abs(po)))) / po)
                        End Select
                    Else
                        Select Case VarType(po)
                        Case vbLong, vbInteger, 20
                            Select Case VarType(r1)
                            Case vbLong, vbInteger, 20
                                 If r1 < 0 Then po = r1 \ po - 1 Else po = r1 \ po
                            Case Else
                                po = Int(r1 / po)
                            End Select
                        Case Else
                             po = Int(r1 / po)
                        End Select
                    End If
                    If Err.Number = 11 Then
                        Err.Clear
                        DevZeroMacro aa$
                        IsExpA = False
                        Exit Function
                    End If
                End If
            Case 40 ' version use switches "+DIV"   from version 12 this is the default
jumpDiv40:
                    Select Case VarType(po)
                    Case vbCurrency
                        Select Case VarType(r1)
                        Case vbLong, vbInteger, 20, vbCurrency
                        po = Int(r1 / po + 0@)
                        Case Else
                        po = Int(r1 / po)
                        End Select
                    Case vbLong, vbInteger, 20
                    Select Case VarType(r1)
                    Case vbLong, vbInteger, 20
                        If Sgn(r1) * Sgn(po) < 0 Then
                            po = r1 \ po - 1   ' SIMULATE int()
                        Else
                            po = r1 \ po
                        End If
                    Case Else
                        po = Int(r1 / po)
                    End Select
                    Case Else
                        po = Int(r1 / po)
                    End Select
                    If Err.Number = 11 Then
                        Err.Clear
                        DevZeroMacro aa$
                        IsExpA = False
                        Exit Function
                    End If

            Case 5, 55
                If MUL = 5 Then
jumpmod5:
                    Select Case VarType(po)
                    Case vbLong, vbInteger, 20
                        Select Case VarType(r1)
                        Case vbLong, vbInteger, 20
                            back = r1 - po * (r1 \ po)
                        Case Else
                            back = r1 - Fix(r1 / po) * po
                        End Select
                    Case Else
                        back = r1 - Fix(r1 / po) * po
                    End Select
                    If Err.Number = 11 Then
                        Err.Clear
                        DevZeroMacro aa$
                        IsExpA = False
                        Exit Function
                    End If
                    If Abs(back) >= Abs(po) Then back = back - back
                    po = back
                Else
                    Select Case VarType(po)
                    Case vbLong, vbInteger, 20
                        Select Case VarType(r1)
                        Case vbLong, vbInteger, 20
                        If Abs(r1) < Abs(po) And Sgn(r1) < 0 Then
                            back = Abs(r1 - Abs(po) * Sgn(r1))
                        ElseIf Sgn(r1) < 0 Then
                            back = Abs(r1 - Abs(po) * (r1 \ Abs(po) - 1))
                        Else
                            back = Abs(r1 - Abs(po) * (r1 \ Abs(po)))
                        End If
                            
                        Case Else
                           back = Abs(r1 - Abs(po) * Int(r1 / Abs(po)))
                        End Select
                    Case Else
                        back = Abs(r1 - Abs(po) * Int(r1 / Abs(po)))
                    End Select
                    If Err.Number = 11 Then
                        Err.Clear
                        DevZeroMacro aa$
                        IsExpA = False
                        Exit Function
                    End If
                    If Abs(back) >= Abs(po) Then back = back - back
                    po = back
                End If
                
            Case 50 ' version use switches "+DIV"
jumpmod50:
                Select Case VarType(po)
                    Case vbLong, vbInteger, 20
                        Select Case VarType(r1)
                        Case vbLong, vbInteger, 20
                            back = r1 - Abs(po) * (r1 \ Abs(po))
                        Case Else
                           back = r1 - Int(r1 / po) * po
                        End Select
                    Case Else
                        back = r1 - Int(r1 / po) * po
                    End Select
                    If Err.Number = 11 Then
                        Err.Clear
                        DevZeroMacro aa$
                        IsExpA = False
                        Exit Function
                    End If
                    If Abs(back) >= Abs(po) Then back = back - back
                    po = back
            Case 600
                po = cxStabTwo("cxAdd", po, r)
                IsExpA = True
            Case 1000
                Set BI = BI.multiply(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
              '  Set bstack.lastobj = BI
                IsExpA = True
            Case 1010
                Set BI = BI.divide(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
              '  Set bstack.lastobj = BI
                IsExpA = True
            Case 1110
                Set BI = BI.divideE(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
              '  Set bstack.lastobj = BI
                IsExpA = True
            Case 1120
                Set BI = BI.ModulusE(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
               ' Set bstack.lastobj = BI
                IsExpA = True
            Case 1020
                Set BI = BI.Modulus(park)
                If Typename(back) = Typename(park) Then
                Set park = back
                Set back = Nothing
                Else
                Set park = Nothing
                End If
               ' Set bstack.lastobj = BI
                IsExpA = True
            End Select
            r1 = 1
            MUL = 0
            
        ElseIf FastSymbol1(aa$, "*") Then
            If MUL = 0 Then
                If IntVal < 0 Then po = -po
            End If
jumpmult:
            IntVal = 1
            cur = 1
            Do
                If FastSymbol23(aa$, "-", cur, 1) Then
                    IntVal = -IntVal
                ElseIf Not FastSymbol23(aa$, "+", cur, 1) Then
                    Exit Do
                End If
            Loop
            If logical(bstack, aa$, r, , True, , IntVal) Then
    
                If Not BI Is Nothing Then

jumpmult1:
                    If bstack.lastobj Is Nothing Then
                        Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
                        r = 0
                    End If
                    If Not bstack.lastobj Is Nothing Then
    
                        If TypeOf bstack.lastobj Is BigInteger Then
                            Set back = park
                            Set park = BI
jumpmult2:
                            If IntVal < 0 Then
                                Set BI = CopyBigInteger(bstack.lastobj)
                                BI.negate
                                IntVal = 1
                            Else
                                Set BI = bstack.lastobj
                            End If
                            MUL = 1000
                        
                        End If
                    End If
                Set bstack.lastobj = Nothing
                
                Else
                If r = 0 Then
                If Not bstack.lastobj Is Nothing Then
                If Not park Is Nothing Then
                Set back = park
                ElseIf ac <> 0 Then
                Set back = Module13.CreateBigInteger(CStr(Int(ac)))
                End If
                Set park = Module13.CreateBigInteger(CStr(Int(po)))
                    GoTo jumpmult2
                End If
                End If
                MUL = 1
                End If
                r1 = po
                po = r
            ElseIf lookOne(aa$, "(") Then
                 If IntVal < 0 Then
                    If TypeOf po Is cxComplex Then
                        po.r = -po.r
                        po.I = -po.I
                    Else
                        po = -po
                    End If
                    IntVal = 0
                End If
                getcom = False
                If logical(bstack, aa$, r, -1, True, getcom) Then
                    MUL = 1
                    r1 = po
                    po = r
                    If Not getcom Then
                    If Not FastSymbol1(aa$, ")") Then
                        IsExpA = False
                        Exit Function
                    End If
                    
                    If Not BI Is Nothing Then GoTo jumpmult1
                    End If
                    Set bstack.lastobj = Nothing
                    Else
                    IsExpA = False
                    Exit Function
                End If
            Else
                IsExpA = False
                Exit Function
            End If
        ElseIf lookTwoSame(aa$, "/") Then
            logic = True
            Exit Do
        ElseIf FastSymbol1(aa$, "/") Then
jumpdiv0:
            If MUL = 0 Then
                If IntVal < 0 Then
                If TypeOf po Is cxComplex Then
                    po.r = -po.r
                    po.I = -po.I
                Else
                    po = -po
                End If
                End If
            End If
jumpdiv:
            IntVal = 1
            cur = 1
            Do
                If FastSymbol23(aa$, "-", cur, 1) Then
                    IntVal = -IntVal
                ElseIf Not FastSymbol23(aa$, "+", cur, 1) Then
                    Exit Do
                End If
            Loop
             If logical(bstack, aa$, r, , True, , IntVal) Then
                If Not BI Is Nothing Then

jumpdiv1:
                If bstack.lastobj Is Nothing Then
                    Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
                    r = 0
                End If
                If Not bstack.lastobj Is Nothing Then

                    If TypeOf bstack.lastobj Is BigInteger Then
                    If MemInt(VarPtr(back)) = vbObject Then
                    
                    ' add
                    End If
                    Set back = park
                    Set park = BI
jumpdiv2:
                    If IntVal < 0 Then
                    Set BI = CopyBigInteger(bstack.lastobj)
                    BI.negate
                    IntVal = 1
                    Else
                    Set BI = CopyBigInteger(bstack.lastobj)
                    End If
                    Set rr = BI
                    Set BI = park
                    Set park = rr
                    Set rr = Nothing
                    MUL = 1010
                    
                    Else
                        Set bstack.lastobj = Nothing
                    End If
                Else
                    Set bstack.lastobj = Nothing
                End If
                Else
                If r = 0 Then
                If Not bstack.lastobj Is Nothing Then
                If Not park Is Nothing Then
                Set back = park
                ElseIf ac <> 0 Then
                Set back = Module13.CreateBigInteger(CStr(Int(ac)))
                End If
                Set park = Module13.CreateBigInteger(CStr(Int(po)))
                    GoTo jumpdiv2
                End If
                End If
                MUL = 2
                End If
                r1 = po
                po = r
               ' IntVal = 0
            ElseIf lookOne(aa$, "(") Then
                If IntVal < 0 Then
                    If TypeOf po Is cxComplex Then
                        po.r = -po.r
                        po.I = -po.I
                    Else
                        po = -po
                    End If
                    IntVal = 0
                End If
                getcom = False
                If logical(bstack, aa$, r, -1, True, getcom) Then
                    MUL = 2
                    r1 = po
                    po = r
                    If Not getcom Then
                    If Not FastSymbol1(aa$, ")") Then
                        IsExpA = False
                        Exit Function
                    End If
                    End If
                    If Not BI Is Nothing Then GoTo jumpdiv1
                    Set bstack.lastobj = Nothing
                Else
                    IsExpA = False
                    Exit Function
                End If
            Else
                IsExpA = False
                Exit Function
            End If
        ElseIf MaybeIsSymbol(aa$, "DMдуdmДУ") Then
            If Fast2Label(aa$, "DIV", 3, "диа", 3, 4) Then
                If FastSymbol1(aa$, "(") Then
                    If IsExpBig(bstack, aa$, r, , True, , True) Then
                        If Not FastSymbol1(aa$, ")") Then
                            IsExpA = False
                            Exit Function
                        End If
                        GoTo adffjfj
                    Else
                        IsExpA = False
                        Exit Function
                    End If
                ElseIf logical(bstack, aa$, r, , True) Then
adffjfj:
                    If TypeOf r Is cxComplex Then
                        WrongType
                        IsExpA = False
                        Exit Function
                    End If
                    If UseIntDiv Then  ' also 10 DIV 2*3 now is (10 DIV 2)*3
                        If Not bstack.lastobj Is Nothing Then
                            MUL = 1010
m23ds2:
                            If TypeOf bstack.lastobj Is BigInteger Then
                            If BI Is Nothing Then
                            Set park = bstack.lastobj
                            Set BI = Module13.CreateBigInteger(CStr(Int(po)))
                            End If
                            Set park = bstack.lastobj
                            
                            GoTo aaaa1221
                            Else
                            Set bstack.lastobj = Nothing
                            End If
                        ElseIf Not BI Is Nothing Then
                            MUL = 1010  ' DIV
                            Set park = Module13.CreateBigInteger(CStr(Int(r)))
                            GoTo aaaa1221
                        End If
                        'MUL = 40
                        r1 = po
                        po = r
                        GoTo jumpDiv40
aaaa1221:
                        
                    Else
                        MUL = 4
                        r1 = po
                        If Not rightoperator(bstack, aa$, r) Then ' 10 DIV 2*3 now is 10 DIV (2*3)
                            IsExpA = False
                            Exit Function
                        End If
                        If Not bstack.lastobj Is Nothing Then
                            MUL = 1010
abdhdh5353:
                            
                            If TypeOf bstack.lastobj Is BigInteger Then
                            If BI Is Nothing Then
                            Set park = bstack.lastobj
                            Set BI = Module13.CreateBigInteger(CStr(Int(po)))
                            
                            End If
                            Set park = bstack.lastobj
                            
                            GoTo aaaa1221
                            Else
                            Set bstack.lastobj = Nothing
                            End If
                        ElseIf Not BI Is Nothing Then
                            MUL = 1010
                            Set park = Module13.CreateBigInteger(CStr(Int(r)))
                            GoTo aaaa1221
                        End If
                        po = r
                        GoTo jumpDiv4
                    End If
                Else
                    IsExpA = False
                    Exit Function
                End If
            ElseIf Fast2Label(aa$, "DIV#", 4, "диа#", 4, 5) Then
             Set bstack.lastobj = Nothing
                If FastSymbol1(aa$, "(") Then
                    If IsExpBig(bstack, aa$, r, , True, , True) Then
                        If Not FastSymbol1(aa$, ")") Then
                            IsExpA = False
                            Exit Function
                        End If
                        GoTo a99449:
                    Else
                        IsExpA = False
                        Exit Function
                    End If
                ElseIf logical(bstack, aa$, r, , True) Then
a99449:
                    If UseIntDiv Then  ' also 10 DIV 2*3 now is (10 DIV 2)*3
                        If Not bstack.lastobj Is Nothing Then
                            MUL = 1110
                            GoTo m23ds2
                        ElseIf Not BI Is Nothing Then
                            MUL = 1110
                            Set park = Module13.CreateBigInteger(CStr(Int(r)))
                            GoTo aaaa1221
                        End If

                        r1 = po
                        po = r
                        GoTo jumpdiv44
                    Else
                        MUL = 4
                        ' right operator * / ^ **
                        r1 = po
                        If Not rightoperator(bstack, aa$, r) Then ' 10 DIV 2*3 now is 10 DIV (2*3)
                            IsExpA = False
                            Exit Function
                        End If
                        If Not bstack.lastobj Is Nothing Then
                            MUL = 1110
                            GoTo m23ds2
                        ElseIf Not BI Is Nothing Then
                            MUL = 1110
                            Set park = Module13.CreateBigInteger(CStr(Int(r)))
                            GoTo aaaa1221
                        End If
                        po = r
                        GoTo jumpdiv44
                    End If
                Else
                    IsExpA = False
                    Exit Function
                End If

    ElseIf Fast3Label(aa$, "MOD", 3, "упокоипо", 8, "упок", 4, 9) Then

       
        If FastSymbol1(aa$, "(") Then
            If IsExpBig(bstack, aa$, r, , True, , True) Then
                If Not FastSymbol1(aa$, ")") Then
                    IsExpA = False
                    Exit Function
                End If
                GoTo n3843
                
            Else
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
        ElseIf logical(bstack, aa$, r, , True) Then
n3843:
            If UseIntDiv Then
                If Not bstack.lastobj Is Nothing Then
                    MUL = 1020
                    GoTo m23ds2
                ElseIf Not BI Is Nothing Then
                    MUL = 1020
                    Set park = Module13.CreateBigInteger(CStr(Int(r)))
                    GoTo aaaa1221
                End If
                MUL = 50
                r1 = po
                po = r
                GoTo jumpmod50
            Else
                MUL = 5
                r1 = po
                If Not rightoperator(bstack, aa$, r) Then
                    IsExpA = False
                    Exit Function
                End If
                If Not bstack.lastobj Is Nothing Then
                    MUL = 1020
                    GoTo abdhdh5353
                ElseIf Not BI Is Nothing Then
                    MUL = 1020
                    Set park = Module13.CreateBigInteger(CStr(Int(r)))
                    GoTo aaaa1221
                End If
                po = r
                GoTo jumpmod5
            End If
        Else
            MissNumExpr
            IsExpA = False
            Exit Function
        End If
    ElseIf Fast3Label(aa$, "MOD#", 4, "упок#", 5, "упокоипо#", 9, 10) Then
        If FastSymbol1(aa$, "(") Then
            If IsExpBig(bstack, aa$, r, , True, , True) Then
                MUL = 55
                r1 = po
                If Not FastSymbol1(aa$, ")") Then
                    MissNumExpr
                    IsExpA = False
                    Exit Function
                End If
                If Not rightoperator(bstack, aa$, r) Then
                    MissNumExpr
                    IsExpA = False
                    Exit Function
                End If
                If Not bstack.lastobj Is Nothing Then
                    MUL = 1120
                    GoTo m23ds2
                ElseIf Not BI Is Nothing Then
                    MUL = 1120
                    Set park = Module13.CreateBigInteger(CStr(Int(r)))
                    GoTo aaaa1221
                End If
                po = r

            Else
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
        ElseIf logical(bstack, aa$, r, , True) Then
            If Not bstack.lastobj Is Nothing Then
                MUL = 1120
                GoTo m23ds2
            ElseIf Not BI Is Nothing Then
                MUL = 1120
                Set park = Module13.CreateBigInteger(CStr(Int(r)))
                GoTo aaaa1221
            End If
            MUL = 55
            r1 = po
            If Not rightoperator(bstack, aa$, r) Then
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
            po = r
        Else
            MissNumExpr
            IsExpA = False
            Exit Function
        End If
    Else
        logic = True
        Exit Do
    End If
ElseIf MaybeIsSymbol(aa$, "AаXйгOАaxЙГoч╧") And noand Then
    If Fast2Label(aa$, "XOR", 3, "апо", 3, 4) Then
        Set bstack.lastobj = Nothing
    '  good
      MUL = 3
        If priorityOr Then
           If IsExpBig(bstack, aa$, r, , True, , True) Then
                processAcAndPoSimple ac, po
                processNegateNonZero po
                processNegateNonZero r
                po = po Xor r
            Else
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
        Else
        If IsExpBig(bstack, aa$, r, False, True, , True) Then
                processAcAndPoSimple ac, po
                processNegateNonZero po
                processNegateNonZero r
                po = po Xor r
            Else
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
        End If
    ElseIf Fast2Label(aa$, "OR", 2, "г", 1, 2) Then
        Set bstack.lastobj = Nothing
    '  good
        MUL = 3
        If priorityOr Then
            If IsExpBig(bstack, aa$, r, , True, , True) Then
                processAcAndPoSimple ac, po
                processNegateNonZero po
                processNegateNonZero r
                po = po Or r
            Else
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
        Else
            If IsExpBig(bstack, aa$, r, False, True, , True) Then
                processAcAndPoSimple ac, po
                processNegateNonZero po
                processNegateNonZero r
                po = po Or r
            Else
                MissNumExpr
                IsExpA = False
                Exit Function
            End If
        End If
    ElseIf Fast2Label(aa$, "AND", 3, "йаи", 3, 3) Then
        Set bstack.lastobj = Nothing
'  good
        MUL = 3
        If IsExpBig(bstack, aa$, r, False, True, , True) Then
            processAcAndPoSimple ac, po
            processNegateNonZero po
            processNegateNonZero r
            po = po And r
        Else
            MissNumExpr
            IsExpA = False
            Exit Function
        End If
    Else
        logic = True
        Exit Do
    End If
ElseIf lookOne(aa$, ")") And parenthesis > 0 Then

Do While FastSymbol1(aa$, ")")
'If IntVal < 2 Then IntVal = 0
parenthesis = parenthesis - 1

If parenthesis = 0 Then
    If IntVal < 0 Then
        If TypeOf po Is cxComplex Then
            po.r = -po.r
            po.I = -po.I
        Else
            po = -po
        End If
    End If
    IntVal = 1
    Exit Do
End If
Loop
MUL = 0
If IntVal < 0 Then
    If TypeOf po Is cxComplex Then
        po.r = -po.r
        po.I = -po.I
    Else
        po = -po
    End If
    IntVal = 0
End If
processAcAndPoSimple ac, po
           
ElseIf MaybeIsTwoSymbol(aa$, "->", 2) Then
logic = True
Exit Do
ElseIf FastSymbol1(aa$, "-") Then
            If Not BI Is Nothing Then
                If IntVal <> 0 Then IntVal = -IntVal Else IntVal = -1
                GoTo jumpplus
            End If
            Set bstack.lastobj = Nothing
            If MUL = 0 Then
                If IntVal < 0 Then
                If TypeOf po Is cxComplex Then
                    po.r = -po.r
                    po.I = -po.I
                Else
                    po = -po
                End If
                End If
            End If
            IntVal = -1
            cur = 1
            Do
                If FastSymbol23(aa$, "-", cur, 1) Then
                    IntVal = -IntVal
                ElseIf Not FastSymbol23(aa$, "+", cur, 1) Then
                    Exit Do
                End If
            Loop
If logical(bstack, aa$, r, , True, , IntVal) Then
    If TypeOf r Is cxComplex Then
    r1 = 1
    Else
    If r = 0 Then
        If Not BI Is Nothing Then
            If bstack.lastobj Is Nothing Then
                Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
            End If
            GoTo cont33333434
        ElseIf Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is BigInteger Then
cont33333434:
                Set park = Module13.CreateBigInteger(CStr(Int(ac + po)))
                Set BI = CopyBigInteger(bstack.lastobj)
                Set bstack.lastobj = Nothing
                If IntVal < 0 Then
                    BI.negate
                    IntVal = 1
                End If
                MUL = 0
                IsExpA = True
                GoTo cont11233
            Else
                Set bstack.lastobj = Nothing
            End If
        End If
        r1 = 1
    End If
    End If
    
 
    processAcAndPo ac, po
    po = r
    MUL = 1
cont11233:
 ElseIf lookOne(aa$, "(") Then
    If IntVal < 0 Then r1 = -r1: IntVal = 1
    'If IsExpBig(bstack, aa$, r, , True, , True) Then
    getcom = False
    If logical(bstack, aa$, r, -1, True, getcom, , True) Then
        MUL = 1
        processAcAndPo ac, po
        po = r
        If Not BI Is Nothing Then
            If bstack.lastobj Is Nothing Then
                If TypeOf r Is cxComplex Then
                    ' what we can do here ???
                    WrongType
                    IsExpA = False
                    Exit Function
                Else
                    Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
                End If
            End If
            GoTo cont9494949
        ElseIf TypeOf r Is cxComplex Then
        ' do nothting here
        ElseIf r = 0 Then
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is BigInteger Then
cont9494949:
                If Not park Is Nothing Then
                    Set back = park
                End If
                Set park = Module13.CreateBigInteger(CStr(Int(ac)))
                ac = 0
            Set BI = CopyBigInteger(bstack.lastobj)
                If r1 < 0 Then
                    r1 = 1
                    BI.negate
                End If
                Set bstack.lastobj = Nothing
                MUL = 0
                GoTo cont2342324
        Else
            Set bstack.lastobj = Nothing
        End If
    End If
    End If
    
cont2342324:
        If Not getcom Then
            If Not FastSymbol1(aa$, ")") Then
                IsExpA = False
                Exit Function
                End If
            End If
        End If
    Else
        MissNumExpr
        IsExpA = False
        Exit Function
    End If

ElseIf FastSymbol1(aa$, "+") Then
If MUL = 0 Then
    If IntVal < 0 Then
        If TypeOf po Is cxComplex Then
            po.r = -po.r
            po.I = -po.I
        Else
            po = -po
        End If
    End If
End If
IntVal = 1
jumpplus:
Set bstack.lastobj = Nothing
cur = 1
Do
    If FastSymbol23(aa$, "-", cur, 1) Then
        IntVal = -IntVal
    ElseIf Not FastSymbol23(aa$, "+", cur, 1) Then
        Exit Do
    End If
Loop

If logical(bstack, aa$, r, , True, , IntVal, nostring) Then
    
    If Not BI Is Nothing Then

    If bstack.lastobj Is Nothing Then
        Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
        r = 0
    End If
jumpplus1:
    If TypeOf bstack.lastobj Is BigInteger Then
    If Not BI Is Nothing Then
        If Not park Is Nothing Then
        If TypeOf park Is BigInteger Then
            Set BI = BI.Add(park)
        Else
wrong:
                IsExpA = False
                WrongType
                Exit Function
        End If
        End If
        Set park = BI
        Set BI = CopyBigInteger(bstack.lastobj)
        
        If IntVal < 0 Then
            BI.negate
            IntVal = 1
        End If
        Set bstack.lastobj = Nothing
        IsExpA = True
        MUL = 0
    Else
    Set bstack.lastobj = Nothing
    End If
    Else
    Set bstack.lastobj = Nothing
    End If
    ElseIf myVarType(po, vbString) Then
    ' convert to string
    
    If myVarType(r, vbString) Then
    
        po = po + r
    Else

                If CheckInt64(r) Then
                   po = po + CStr(r)
                ElseIf myVarType(r, vbBoolean) Then
                    po = po + Format$(r, DefBooleanString)
                Else
                    po = po + fixthis(r)
                End If
    End If
        MUL = 0
    ElseIf myVarType(r, vbString) Then
        If CheckInt64(po) Then
            po = CStr(po) + r
        ElseIf myVarType(po, vbBoolean) Then
            po = Format(po, DefBooleanString) + r
        Else
            po = fixthis(po) + r
        End If
        MUL = 0
    
    Else
           If TypeOf r Is cxComplex Then
           r1 = 1
           ElseIf r = 0 Then
            If Not bstack.lastobj Is Nothing Then
                If park Is Nothing Then
                    Set park = Module13.CreateBigInteger(CStr(Int(po)))
                End If
            Set BI = CopyBigInteger(bstack.lastobj)
            If IntVal < 0 Then
                BI.negate
                IntVal = 1
            End If
            MUL = 0
            Set bstack.lastobj = Nothing
            GoTo cont484848
            
            End If
            
            End If
    
    
        MUL = 0 ' from 3
        processAcAndPo ac, po
        po = r
cont484848:
    End If
    ElseIf lookOne(aa$, "(") Then
    getcom = False
    If logical(bstack, aa$, r, -1, True, getcom, , True) Then
    If Not BI Is Nothing Then
        If bstack.lastobj Is Nothing Then
            Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(r)))
        End If
        
        If Not FastSymbol1(aa$, ")") Then
            IsExpA = False
            Exit Function
        End If
        GoTo jumpplus1
    End If
    MUL = 0 '1 ' from 3
    processAcAndPo ac, po
    If IntVal < 0 Then
        If TypeOf r Is cxComplex Then
            r.r = -r.r
            r.I = -r.I
        Else
            r = -r
        End If
        IntVal = 0
    End If
    po = r
    If Not getcom Then
    If Not FastSymbol1(aa$, ")") Then
        IsExpA = False
        Exit Function
    End If
    End If
    End If
ElseIf Not nostring Then

            
    Select Case MemInt(VarPtr(po))
    Case vbString
        If IsStrExp(bstack, aa$, ut$) Then
            po = po + CVar(ut$)
        Else
            MissStringExpr
            IsExpA = False
            Exit Function
        End If
    Case vbBoolean
        If IsStrExp(bstack, aa$, ut$) Then
            po = Format(po, DefBooleanString) + CVar(ut$)
        Else
            MissStringExpr
            IsExpA = False
            Exit Function
        End If
    Case 20
        If IsStrExp(bstack, aa$, ut$) Then
            po = CVar(CStr(po) + ut$)
        Else
            MissNumExpr
            IsExpA = False
            Exit Function
        End If
    Case Else
        po = fixthis(po)
        If IsStrExp(bstack, aa$, ut$) Then
            po = po + ut$
        Else
            MissNumExpr
            IsExpA = False
            Exit Function
        End If
    End Select
Else
    MissNumExpr
    IsExpA = False
    Exit Function

End If

ElseIf FastSymbol2(aa$, "<<") Then
' NOT FOR COMPLEX???
            Set bstack.lastobj = Nothing
            If logical(bstack, aa$, r) Then
                MUL = 500
                r1 = po
                po = r
            ElseIf FastSymbol1(aa$, "(") Then
                If IsExpBig(bstack, aa$, r) Then
                    MUL = 1
                    r1 = po
                    po = r
                    If Not FastSymbol1(aa$, ")") Then
                        IsExpA = False
                        Exit Function
                    End If
                End If
            Else
                IsExpA = False
                Exit Function
            End If
            
'**********************************************************************
ElseIf Comp And MaybeIsSymbol(aa$, "<=>") Then
Set bstack.lastobj = Nothing
If IntVal < 0 Then
    If TypeOf po Is cxComplex Then
        po.r = -po.r
        po.I = -po.I
    Else
        po = -po
    End If
IntVal = 1
End If
If FastSymbol1(aa$, "=") Then
jumpequ:
    MUL = 3
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If IsExpBig(bstack, aa$, r, False, True, False, True) Then  ' check string ==
            If Not BI Is Nothing Then
                GoTo jumpequ1
            ElseIf Not bstack.lastobj Is Nothing Then
                GoTo jumpequ2
            ElseIf MemInt(VarPtr(po)) = 36 Then
                If Not TypeOf po Is cxComplex Then WrongType: IsExpA = False: Exit Function
                If MemInt(VarPtr(r)) = 36 Then
                If Not TypeOf r Is cxComplex Then WrongType: IsExpA = False: Exit Function
ju12:
                    If ac = 0 Then
                        po = cxStabThree("cxEq", po, r, 10)
                    Else
                        po = cxStabThree("cxEq", cxStabTwo("cxAdd", ac, po), r, 10) '(ac + po) = r
                        ac = 0
                    End If
                Else
                    r = nMath2.cxNew(r, 0)
                    GoTo ju12
                End If
            ElseIf r = 0 Then
                If ac <> 0 Then po = (ac + po)
                If po = 0 Then
                    po = True
                Else
                    po = MyRound(po, 13) = 0
                End If
            Else
                po = MyRound((((ac + po) - r) / r), 10) = 0
            End If
            ac = 0
        Else
            IsExpA = False
            Exit Function
        End If
   ' ElseIf lookOne(aa$, "(") Then
   '     getcom = False
   '     If logical(bstack, aa$, r, -1, True, getcom, , True) Then      ' check string
   '         GoTo jumpeq10
   '     Else
   '         GoTo expMisNum
   '     End If
    ElseIf IsExpBig(bstack, aa$, r, False, True, False, True) Then    ' check string
jumpeq10:
        If Not BI Is Nothing Then
jumpequ1:
            If Not park Is Nothing Then

                If TypeOf park Is BigInteger Then
                    Set BI = BI.Add(park)
                Else
                    GoTo wrong
                End If
            End If
            IsExpA = True
            If bstack.lastobj Is Nothing Then
                po = BI.compare(Module13.CreateBigInteger(CStr(Int(r)))) = 0
            ElseIf TypeOf bstack.lastobj Is BigInteger Then
                po = BI.compare(CopyBigInteger(bstack.lastobj)) = 0
                Set bstack.lastobj = Nothing
            Else
                Set bstack.lastobj = Nothing
            End If
            Set BI = Nothing
            ac = 0
        ElseIf Not bstack.lastobj Is Nothing Then
jumpequ2:
            If TypeOf bstack.lastobj Is BigInteger Then
                Set BI = bstack.lastobj
                If ac = 0 Then
                    po = BI.compare(Module13.CreateBigInteger(CStr(Int(po)))) = 0
                Else ' now r is the bi
                    po = BI.compare(Module13.CreateBigInteger(CStr(Int(ac + po)))) = 0
                    ac = 0
                End If
            Else
                Set bstack.lastobj = Nothing
            End If
            Set BI = Nothing
            Set bstack.lastobj = Nothing
        Else
            If MemInt(VarPtr(po)) = 36 Then
            If Not TypeOf po Is cxComplex Then Exit Function
                If MemInt(VarPtr(r)) = 36 Then
                    If Not TypeOf r Is cxComplex Then Exit Function
                    If TypeOf ac Is cxComplex Then
                        po = cxStabTwo("cxEq", cxStabTwo("cxAdd", ac, po), r)
                    ElseIf ac = 0 Then
                        po = cxStabTwo("cxEq", po, r)
                    ElseIf Not TypeOf ac Is cxComplex Then
                        po = cxStabTwo("cxEq", cxStabTwo("cxAdd", nMath2.cxNew(CDbl(ac), 0#), po), r)
                    End If
                    ac = 0
                Else
                    If ac = 0 Then
                        po = cxStabTwo("cxEq", po, nMath2.cxNew(r, 0))
                    ElseIf Not TypeOf ac Is cxComplex Then
                        po = cxStabTwo("cxEq", cxStabTwo("cxAdd", nMath2.cxNew(CDbl(ac), 0#), po), nMath2.cxNew(r, 0))
                    Else
                        po = cxStabTwo("cxEq", cxStabTwo("cxAdd", ac, po), nMath2.cxNew(r, 0))
                    End If
                    ac = 0
                End If
            ElseIf ac = 0 Then
                po = CBool(po = r)
            Else
                po = (ac + po) = r
                ac = 0
            End If
        End If
        
    Else
expMisNum:
        MissNumExpr
        IsExpA = False
        Exit Function
    End If
ElseIf FastSymbol1(aa$, "<") Then
jumpmax:
    MUL = 3
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If Left$(aa$, 2) = " >" Then
            Mid$(aa$, 2, 1) = " "
            MUL = 1  ' from 3
            If IsExpBig(bstack, aa$, r, False, True, False, True) Then
                If Not BI Is Nothing Then
                     If Not park Is Nothing Then
                         If TypeOf park Is BigInteger Then
                             Set BI = BI.Add(park)
                         Else
                             GoTo wrong
                         End If
                     End If
                     IsExpA = True
                     If bstack.lastobj Is Nothing Then
                         po = BI.compare(Module13.CreateBigInteger(CStr(Int(ac + r))))
                     ElseIf TypeOf bstack.lastobj Is BigInteger Then
                         po = BI.compare(CopyBigInteger(bstack.lastobj))
                     Else
                     Set bstack.lastobj = Nothing
                     End If
                     Set BI = Nothing
                     Set bstack.lastobj = Nothing
                     ac = 0
                     r = 0
                 ElseIf Not bstack.lastobj Is Nothing Then
                     If TypeOf bstack.lastobj Is BigInteger Then
                         Set BI = bstack.lastobj
                       If ac = 0 Then
                             po = -BI.compare(Module13.CreateBigInteger(CStr(Int(po))))
                         Else ' now r is the bi
                             po = -BI.compare(Module13.CreateBigInteger(CStr(Int(ac + po))))
                             ac = 0
                         End If
                     Else
                         Set bstack.lastobj = Nothing
                     End If
                     Set BI = Nothing
                     Set bstack.lastobj = Nothing
                     r = 0
                Else
                    If ac = 0 Then
                        Select Case po
                        Case Is < r
                            po = -1
                        Case Is = r
                            po = 0
                        Case Else
                            po = 1
                        End Select
                        ac = 0
                    Else
                        ac = ac + po
                        If Err.Number = 6 Then
                            Err.Clear
                            r = r - ac
                            If Err.Number = 6 Then Err.Clear
                            Select Case po
                            Case Is < r
                                po = -1
                            Case Is = r
                                po = 0
                            Case Else
                                po = 1
                            End Select
                        Else
                            Select Case ac
                            Case Is < r
                                po = -1
                            Case Is = r
                                po = 0
                            Case Else
                                po = 1
                            End Select
                            
                            ac = 0
                        End If
                    End If
                 End If
             Else
                MissNumExpr
                IsExpA = False
                Exit Function
             End If
        Else  ' <=
            If IsExpBig(bstack, aa$, r, False, True, False, True) Then
                If Not BI Is Nothing Then
                    If Not park Is Nothing Then
                        If TypeOf park Is BigInteger Then
                            Set BI = BI.Add(park)
                        Else
                            GoTo wrong
                        End If
                    End If
                    IsExpA = True
                    If bstack.lastobj Is Nothing Then
                        po = BI.compare(Module13.CreateBigInteger(CStr(Int(r)))) < 1
                    ElseIf TypeOf bstack.lastobj Is BigInteger Then
                        po = BI.compare(CopyBigInteger(bstack.lastobj)) < 1
                        Set bstack.lastobj = Nothing
                    Else
                    Set bstack.lastobj = Nothing
                    End If
                    Set BI = Nothing
                    ac = 0
                ElseIf Not bstack.lastobj Is Nothing Then
                    If TypeOf bstack.lastobj Is BigInteger Then
                        Set BI = bstack.lastobj
                        If ac = 0 Then
                            po = BI.compare(Module13.CreateBigInteger(CStr(Int(po)))) > -1
                        Else ' now r is the bi
                            po = BI.compare(Module13.CreateBigInteger(CStr(Int(ac + po)))) > -1
                            ac = 0
                        End If
                    Else
                        Set bstack.lastobj = Nothing
                    End If
                    Set BI = Nothing
                Else
                    If ac = 0 Then
                        po = po <= r
                    Else
                        ac = ac + po
                        If Err.Number = 6 Then
                            Err.Clear
                            If ac + 0 Then
                            If Err.Number = 6 Then
                                po = ac <= r
                            Else
                                po = po <= r
                            End If
                            Else
                                po = po <= r
                            End If
                        Else
                            po = ac <= r
                        End If
                        
                        ac = 0
                    End If
                End If
            Else
                IsExpA = False
                Exit Function
            End If
        End If
    ElseIf Left$(aa$, 1) = ">" Then   ' <>
        Mid$(aa$, 1, 1) = " "
        If IsExpBig(bstack, aa$, r, False, True, False, True) Then
            If Not BI Is Nothing Then
                If Not park Is Nothing Then
                    If TypeOf park Is BigInteger Then
                        Set BI = BI.Add(park)
                    Else
                        GoTo wrong
                    End If
                End If
                IsExpA = True
                If bstack.lastobj Is Nothing Then
                    po = BI.compare(Module13.CreateBigInteger(CStr(Int(r)))) <> 0
                ElseIf TypeOf bstack.lastobj Is BigInteger Then
                    po = BI.compare(CopyBigInteger(bstack.lastobj)) <> 0
                    Set bstack.lastobj = Nothing
                Else
                Set bstack.lastobj = Nothing
                End If
                Set BI = Nothing
                ac = 0
            ElseIf Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set BI = bstack.lastobj
                    If ac = 0 Then
                        po = BI.compare(Module13.CreateBigInteger(CStr(Int(po)))) <> 0
                    Else ' now r is the bi
                        po = BI.compare(Module13.CreateBigInteger(CStr(Int(ac + po)))) <> 0
                        ac = 0
                    End If
                Else
                    Set bstack.lastobj = Nothing
                End If
                Set BI = Nothing
            Else
                If ac = 0 Then
                    po = po <> r
                Else
                    ac = ac + po
                    If Err.Number = 6 Then
                        Err.Clear
                        If ac + 0 Then
                        If Err.Number = 6 Then
                            po = ac <> r
                        Else
                            po = po <> r
                        End If
                        Else
                            po = po <> r
                        End If
                    Else
                        po = ac <> r
                    End If
                    
                    ac = 0
                End If
            End If
        Else
            MissNumExpr
            IsExpA = False
            Exit Function
        End If
    ElseIf IsExpBig(bstack, aa$, r, False, True, False, True) Then  ' <
        If Not BI Is Nothing Then
            If Not park Is Nothing Then
                If TypeOf park Is BigInteger Then
                    Set BI = BI.Add(park)
                Else
                    GoTo wrong
                End If
            End If
            IsExpA = True
            If bstack.lastobj Is Nothing Then
                po = BI.compare(Module13.CreateBigInteger(CStr(Int(r)))) = -1
            ElseIf TypeOf bstack.lastobj Is BigInteger Then
                po = BI.compare(CopyBigInteger(bstack.lastobj)) = -1
                Set bstack.lastobj = Nothing
            Else
            Set bstack.lastobj = Nothing
            End If
            Set BI = Nothing
            ac = 0
        ElseIf Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is BigInteger Then
                Set BI = bstack.lastobj
                If ac = 0 Then
                    po = BI.compare(Module13.CreateBigInteger(CStr(Int(po)))) = 1
                Else ' now r is the bi
                    po = BI.compare(Module13.CreateBigInteger(CStr(Int(ac + po)))) = 1
                    ac = 0
                End If
            Else
                Set bstack.lastobj = Nothing
            End If
            Set BI = Nothing
        Else
            If ac = 0 Then
                po = po < r
            Else
                ac = ac + po
                If Err.Number = 6 Then
                    Err.Clear
                    If ac + 0 Then
                    If Err.Number = 6 Then
                        po = ac < r
                    Else
                        po = po < r
                    End If
                    Else
                        po = po < r
                    End If
                Else
                    po = ac < r
                End If
                
                ac = 0
            End If
        End If
    Else
        MissNumExpr
        IsExpA = False
        Exit Function
    End If
ElseIf FastSymbol1(aa$, ">") Then  '>=, >
jumpmin:
   
    MUL = 3
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If IsExpBig(bstack, aa$, r, False, True, False, True) Then
            If Not BI Is Nothing Then
                If Not park Is Nothing Then
                    If TypeOf park Is BigInteger Then
                        Set BI = BI.Add(park)
                    Else
                        GoTo wrong
                    End If
                End If
                IsExpA = True
                If bstack.lastobj Is Nothing Then
                    po = BI.compare(Module13.CreateBigInteger(CStr(Int(r)))) > -1
                ElseIf TypeOf bstack.lastobj Is BigInteger Then
                    po = BI.compare(CopyBigInteger(bstack.lastobj)) > -1
                    Set bstack.lastobj = Nothing
                Else
                Set bstack.lastobj = Nothing
                End If
                Set BI = Nothing
                ac = 0
            ElseIf Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set BI = bstack.lastobj
                    If ac = 0 Then
                        po = BI.compare(Module13.CreateBigInteger(CStr(Int(po)))) < 1
                    Else ' now r is the bi
                        po = BI.compare(Module13.CreateBigInteger(CStr(Int(ac + po)))) < 1
                        ac = 0
                    End If
                Else
                    Set bstack.lastobj = Nothing
                End If
                Set BI = Nothing
            Else
                If ac = 0 Then
                    po = po >= r
                Else
                    ac = ac + po
                    If Err.Number = 6 Then
                        Err.Clear
                        If ac + 0 Then
                        If Err.Number = 6 Then
                            po = ac >= r
                        Else
                            po = po >= r
                        End If
                        Else
                            po = po >= r
                        End If
                    Else
                        po = ac >= r
                    End If
                    
                    ac = 0
                End If
            End If
        Else
            MissNumExpr
            IsExpA = False
            Exit Function
        End If
    ElseIf IsExpBig(bstack, aa$, r, False, True, False, True) Then
            If Not BI Is Nothing Then
                If Not park Is Nothing Then
                    If TypeOf park Is BigInteger Then
                        Set BI = BI.Add(park)
                    Else
                        GoTo wrong
                    End If
                End If
                IsExpA = True
                If bstack.lastobj Is Nothing Then
                    po = BI.compare(Module13.CreateBigInteger(CStr(Int(r)))) = 1
                ElseIf TypeOf bstack.lastobj Is BigInteger Then
                    po = BI.compare(CopyBigInteger(bstack.lastobj)) = 1
                    Set bstack.lastobj = Nothing
                Else
                Set bstack.lastobj = Nothing
                End If
                Set BI = Nothing
                ac = 0
            ElseIf Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set BI = bstack.lastobj
                    If ac = 0 Then
                        po = BI.compare(Module13.CreateBigInteger(CStr(Int(po)))) = -1
                    Else ' now r is the bi
                        po = BI.compare(Module13.CreateBigInteger(CStr(Int(ac + po)))) = -1
                        ac = 0
                    End If
                Else
                    Set bstack.lastobj = Nothing
                End If
                Set BI = Nothing
            Else
                If ac = 0 Then
                    po = po > r
                Else
                    ac = ac + po
                    If Err.Number = 6 Then
                        Err.Clear
                        If ac + 0 Then
                        If Err.Number = 6 Then
                            po = ac > r
                        Else
                            po = po > r
                        End If
                        Else
                            po = po > r
                        End If
                    Else
                        po = ac > r
                    End If
                    
                    ac = 0
                End If
            End If
    Else
        MissNumExpr
        IsExpA = False
        Exit Function
    End If
Else
logic = True
Exit Do
End If

Else
logic = True
Exit Do
End If
Loop
If TypeOf ac Is cxComplex Then
    If MemInt(VarPtr(po)) = 36 Then
        If Not TypeOf po Is cxComplex Then Exit Function
        ac = cxStabTwo("cxAdd", ac, po)
    Else
        ac = cxStabTwo("cxAddREAL", ac, po)
    End If
    ElseIf ac = 0 Then
        If myVarType(po, vbString) Then
            SwapVariant ac, po
        Else
            ac = po
        End If
Else
    ac = ac + po
If Err.Number = 6 Then
Err.Clear
ac = CDbl(ac) + CDbl(po)
Err.Clear
End If
End If
po = 1
Loop Until logic
If IntVal < 0 Then
If TypeOf ac Is cxComplex Then
ac.r = -ac.r
ac.I = -ac.I
rr = ac
Else
rr = -ac
End If
ElseIf myVarType(ac, vbString) Then
'rr = ac
SwapVariant rr, ac
Else
rr = ac
End If
If Not BI Is Nothing Then
    If Not park Is Nothing Then
        If TypeOf park Is BigInteger Then
            rr = 0
            Set BI = BI.Add(park)
        Else
            WrongType
            IsExpA = False
            Exit Function
        End If
    End If

    Set bstack.lastobj = BI
End If
    Do While parenthesis > 0
        If FastSymbol1(aa$, ")") Then
            parenthesis = parenthesis - 1
        Else
            Exit Do
        End If
    Loop
    Set park = Nothing
End Function
Function CheckBigInteger(bstack As basetask, r As Variant) As Boolean
Dim BI As BigInteger
If Not bstack.lastobj Is Nothing Then
    If TypeOf bstack.lastobj Is BigInteger Then
    Set BI = bstack.lastobj
    Set bstack.lastobj = Nothing
    If BI.Length < 27 Then
         r = CDec(BI.ToString)
    Else
        Overflow
        Exit Function
    End If
    Else
        Set bstack.lastobj = Nothing
    End If
End If
CheckBigInteger = True
End Function
Private Function MyTrimLi(s$, L As Long) As Long
Dim I&
Dim P2 As Long, P1 As Integer, p4 As Long
 If L > Len(s) Then MyTrimLi = Len(s) + 1: Exit Function
 If L <= 0 Then MyTrimLi = 1: Exit Function
  L = L - 1
  I = Len(s)
  P2 = StrPtr(s) + L * 2:  p4 = P2 + I * 2
  For I = P2 To p4 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 9
    Case Else
     MyTrimLi = (I - P2) \ 2 + 1 + L
   Exit Function
  End Select
  Next I
 MyTrimLi = Len(s) + 1
End Function
Private Function MyTrimLi2(s$, L As Long) As Long
Dim I&
Dim P2 As Long, P1 As Integer, p4 As Long
 If L > Len(s) Then MyTrimLi2 = Len(s) + 1: Exit Function
 If L <= 0 Then MyTrimLi2 = 1: Exit Function
  L = L - 1
  I = Len(s)
  P2 = StrPtr(s) + L * 2:  p4 = P2 + I * 2
  For I = P2 To p4 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case Else
     MyTrimLi2 = (I - P2) \ 2 + 1 + L
   Exit Function
  End Select
  Next I
 MyTrimLi2 = Len(s) + 1
End Function
Function FastOperator(A$, c$, I As Long, Optional cl As Long = 1, Optional Remove As Boolean = True) As Boolean
Dim j As Long
If I <= 0 Then I = 1
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimLi(A$, I)
If I > j Then I = 1 ' no spaces
If j - I < cl - 1 Then Exit Function
If c$ = Mid$(A$, I, cl) Then
If Remove Then Mid$(A$, I, cl) = space$(cl)
FastOperator = True
End If
End Function
Function FastType(A$, c$) As Boolean
Dim W$, I As Long
I = 1
If FastPureLabel(A$, W$, I, , True) = 1 Then
If c$ = W$ Then
A$ = Mid$(A$, I)
FastType = True
End If
End If
End Function
Function IsNumber(bstack As basetask, A$, r As Variant, Optional flatobject As Boolean = False, Optional sg As Integer = 1) As Boolean
Dim sng&, ex$, ig$, DE$, I As Long, sg1 As Boolean, j As Integer


If lookOne(A$, "(") Then IsNumber = False: Exit Function
If Len(A$) = 0 Then IsNumber = False: Exit Function
If MaybeIsSymbol2(A$, "#+-", sng&) Then
sng& = sng& - 1
Do While sng& < Len(A$)
sng& = sng& + 1
Select Case Mid$(A$, sng&, 1)
Case "#"
    If Len(A$) > sng& Then
    If MaybeIsSymbolNoSpace(Mid$(A$, sng& + 1, 1), "[0-9A-Fa-f]") Then
    ex$ = "0x00" + Mid$(A$, sng& + 1, 6)
    If Len(ex$) < 10 Then Exit Function
        If IsNumberCheck(ex$, r) Then
        If ex$ <> "" Then
          
             
        Else
            ex$ = Right$("00000000" + Mid$(A$, sng& + 1, 6), 8)
            A$ = Mid$(A$, sng& + 7)
            
           r = sg * -(CDbl(UNPACKLNG(Right$(ex$, 2)) * 65536#) + CDbl(UNPACKLNG(Mid$(ex$, 5, 2)) * 256#) + CDbl(UNPACKLNG(Mid$(ex$, 3, 2))))
            sg = 1
            If MaybeIsSymbolNoSpace(Mid$(A$, 1, 1), "[0-9]") Then
            MyEr "Too many digits", "пОККэ ЬГЖъА"
            IsNumber = False
            Else
            IsNumber = True
            End If
            Exit Function
        End If
        End If
        Else
        
    End If
    Else

    '' out
    End If
    Exit Function
Case " ", ChrW(160)
Case "+"
    If Abs(sg) < 10 Then sg = sg * 10
Case "-"
sg = -sg
Case Else
Exit Do
End Select
Loop

End If
If sng& > 1 Then Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
If MaybeIsSymbol3(A$, ".", sng&) Then

    If Len(A$) = sng& Then
        ig$ = "0"
        DE$ = "."
        GoTo conthere
    ElseIf Mid$(A$, sng& + 1, 1) Like "[0-9]" Then
        ig$ = "0"
        DE$ = "."
        GoTo conthere
    Else
    ' we have an identifier with . like .x
        IsNumber = IsNumberNew(bstack, A$, r, flatobject)
        If flatobject Then bstack.flatobject
        Exit Function
    End If
    
ElseIf Len(A$) < sng& Then
    IsNumber = False: Exit Function
Else
I = AscW(Mid$(A$, sng&, 1))
If I < 10 Or I > 63 Then
' HERE PROCESS UNARY SIGNS??
    IsNumber = IsNumberNew(bstack, A$, r, flatobject)
        If flatobject Then
        If Not bstack.lastobj Is Nothing Then
        If Not TypeOf bstack.lastobj Is BigInteger Then Set bstack.lastobj = Nothing
        End If
        End If

    Exit Function
Else
    I = 0
    j = 0
    If Mid$(A$, sng&, 1) = "0" Then
        If LCase(Mid$(A$, sng& + 1, 1)) Like "[xВ]" Then
                    
jumphere1:
                    sng& = sng& + 2
                    Do While sng& <= Len(A$)
                        Select Case Mid$(A$, sng&, 1)
                        Case "A" To "F", "a" To "f", "0" To "9"
                            I = I + 1
                        Case "_"
                            If I = 0 Then Exit Do
                            I = I + 1
                            j = j + 1
                        Case Else
                            Exit Do
                        End Select
                        
                    sng& = sng& + 1
                    Loop
                    If I - j > 16 Then
                        OverflowValue
                        IsNumber = False
                        Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                        Exit Function
                    End If
                    If Mid$(A$, sng&, 1) = "%" Then
                        If I - j > 4 Then
                            OverflowValue vbInteger
                            IsNumber = False
                            Exit Function
                        End If
                        If j > 0 Then
                            r = CInt("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                        Else
                            r = CInt("&H" + Mid$(A$, sng - I, I))
                        End If
                        sng& = sng& + 1
                    ElseIf LCase$(Mid$(A$, sng&, 1)) = "u" Then
                     If Not LCase$(Mid$(A$, sng& + 1, 1)) = "b" Then
                        SyntaxError
                        IsNumber = False
                        Exit Function
                     End If
                     If I - j > 2 Then
                            OverflowValue vbByte
                            IsNumber = False
                            Exit Function
                     End If
                        If j > 0 Then
                            r = CByte("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                        Else
                            r = CByte("&H" + Mid$(A$, sng - I, I))
                        End If
                        sng& = sng& + 2
                    Else
                        If I - j > 8 Then ' maybe long long or decimal
                            If Mid$(A$, sng&, 2) = "&&" Then
                                If I - j > 16 Then
                                    OverflowValue 20
                                    IsNumber = False
                                    Exit Function
                                End If
                                If j > 0 Then
                                    r = cInt64("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                                Else
                                    r = cInt64("&H" + Mid$(A$, sng - I, I))
                                End If
                                sng& = sng& + 2
                            ElseIf Mid$(A$, sng&, 1) = "&" Then
                                OverflowValue vbLong
                                IsNumber = False
                                Exit Function
                            Else
                                If j > 0 Then
                                    r = CDec(cInt64("&H" + Replace$(Mid$(A$, sng - I, I), "_", "")))
                                Else
                                    r = CDec(cInt64("&H" + Mid$(A$, sng - I, I)))
                                End If
                                If r < 0 Then r = r + maxlonglong
                                If Mid$(A$, sng&, 1) = "@" Then
                                   sng& = sng& + 1
                                End If
                            End If
                        ElseIf Mid$(A$, sng&, 2) = "&&" Then
                            If j > 0 Then
                                r = cInt64("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                            Else
                                r = cInt64("&H" + Mid$(A$, sng - I, I))
                            End If
                            sng& = sng& + 2
                        ElseIf Mid$(A$, sng&, 1) = "&" Then
                            If j > 0 Then
                                r = CLng("&H" + Replace$(Mid$(A$, sng - I, I), "_", ""))
                            Else
                                r = CLng("&H" + Mid$(A$, sng - I, I))
                            End If
                            sng& = sng& + 1
                        ElseIf Mid$(A$, sng&, 1) = "@" Then
                            If j > 0 Then
                                r = CDec(HexToUnsigned(Replace$(Mid$(A$, sng - I, I), "_", "")))
                            Else
                                r = CDec(HexToUnsigned(Mid$(A$, sng - I, I)))
                            End If
                            sng& = sng& + 1
                        Else
                         If j > 0 Then
                            r = HexToUnsigned(Replace$(Mid$(A$, sng - I, I), "_", ""))
                            Else
                            r = HexToUnsigned(Mid$(A$, sng - I, I))
                            End If
                            IsNumber = True
                        End If
                    End If
                     Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                     IsNumber = True
                    Exit Function
                End If
    Else
        If Mid$(A$, sng&, 1) = "&" Then
            If LCase$(Mid$(A$, sng& + 1, 1)) = "h" Then GoTo jumphere1
            IsNumber = False
            Exit Function
        ElseIf Not Mid$(A$, sng&, 1) Like "[1-9]" Then
            IsNumber = False
            Exit Function
        End If
    End If
    Dim repl As Boolean
    Do While sng& <= Len(A$)
        Select Case Mid$(A$, sng&, 1)
        Case "0" To "9"
        I = I + 1
        Case "_"
        I = I + 1
        repl = True
        Case "."
            
            ig$ = Mid$(A$, sng& - I, I)
            If repl Then repl = False: ig$ = Replace(ig$, "_", "")
            DE$ = "."
            Exit Do
        Case Else
            ig$ = Mid$(A$, sng& - I, I)
            If repl Then repl = False: ig$ = Replace(ig$, "_", "")
        Exit Do
        End Select
        
       sng& = sng& + 1
    Loop
    If Len(ig$) = 0 Then
    ig$ = Mid$(A$, sng& - I, I)
    If repl Then repl = False: ig$ = Replace(ig$, "_", "")
    End If
End If
    If Len(DE$) = 0 Then
    If Len(A$) > sng& Then
    If InStr("EeеЕ", Mid$(A$, sng&, 1)) > 0 Then
    If InStr("1234567890+-", Mid$(A$, sng& + 1, 1)) > 0 Then
        DE$ = "."
        GoTo cont123
    End If
    End If
    End If
   Else
conthere:
      sng& = sng& + 1
cont123:
      I = 0
      repl = False
        Do While sng& <= Len(A$)
       
        Select Case Mid$(A$, sng&, 1)
        Case "0" To "9"
            I = I + 1
        Case "_"
            I = I + 1
            repl = True
        Case "E", "e", "е", "Е"
         If ex$ = vbNullString Then
            sg1 = True
            ex$ = "E"
             Exit Do
        End If
        Case Else
        Exit Do
        End Select
         sng& = sng& + 1
        Loop
        If I > 0 Then
            DE$ = DE$ + Mid$(A$, sng& - I, I)
            If repl Then repl = False: DE$ = Replace(DE$, "_", "")
        End If
        If sg1 Then
        sng& = sng& + 1
         I = 0
         Do While sng& <= Len(A$)
         Select Case Mid$(A$, sng&, 1)
         Case "0" To "9"
             I = I + 1
         Case "+", "-"
            If Len(ex$) = 1 Then
               I = I + 1
            Else
                Exit Do
            End If
         Case Else
             Exit Do
         End Select
          sng& = sng& + 1
         Loop
         If I > 0 Then ex$ = ex$ + Mid$(A$, sng& - I, I)
         sng = sng - Len(ex$)
        End If
    End If

    If ex$ <> "" Then
                If Len(ex$) < 3 Then
                If ex$ = "E" Then
                ex$ = "0"
                ElseIf ex$ = "E-" Or ex$ = "E+" Then
                sng = sng + 2
                End If
                End If
                    
            
                If val(Mid$(ex$, 2)) > 308 Or val(Mid$(ex$, 2)) < -324 Then
                    r = 0 ' val(ig$ & DE$)
                    sng = sng - Len(ex$)
                    ex$ = vbNullString
                    MyEr "Exponet Overflow", "уПЕЯВЕъКИСГ еЙХщТГ"
                    Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                    IsNumber = False
                    Exit Function
                    Else
                    sng = sng + Len(ex$)
                    If sng <= Len(A$) Then
                        If Asc(Mid$(A$, sng, 1)) = 126 Then
                        Mid$(A$, sng, 1) = " "
                        If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                        On Error Resume Next
                        r = CSng(ig$ + DE$ + ex$)
                            If Err.Number = 6 Then
                                Err.Clear
                                Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                                OverflowValue vbSingle
                                Exit Function
                                Err.Clear
                                Exit Function
                            End If
                        Else
                        On Error Resume Next
                            r = val(ig$ + DE$ + ex$)
                            If Err.Number = 6 Then
                                Err.Clear
                                Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                                OverflowValue vbDouble
                                Exit Function
                            End If
                        End If
                    Else
                        On Error Resume Next
                        r = val(ig$ + DE$ + ex$)
                        If Err.Number = 6 Then
                        Err.Clear
                        Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                        OverflowValue vbDouble
                        Exit Function
                        End If
                    End If
                    On Error GoTo 0
                    
                 
                End If
        Else
        If sg < 0 Then
            ig$ = "-" + ig$: sg = 2
        End If
            If sng <= Len(A$) Then
            
            On Error Resume Next
            Select Case Asc(Mid$(A$, sng, 1))
            Case 64
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                
                r = CDec(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                OverflowValue vbDecimal
                'If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                'R = val(ig$ + DE$)
                End If
            Case 35
            Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CCur(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                OverflowValue vbCurrency
                'If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                'R = val(ig$ + DE$)
                End If
            Case 38
                If Mid$(A$, sng + 1, 1) = "&" Then
                        Mid$(A$, sng, 2) = "  "
                        r = cInt64(ig$)
                        If Err.Number = 6 Then
                            Err.Clear
                            OverflowValue 20
                        End If
                Else
                    Mid$(A$, sng, 1) = " "
                    r = CLng(ig$)
                    If Err.Number = 6 Then
                        Err.Clear
                        OverflowValue vbLong
                    End If
                End If
           Case 37
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CInt(ig$)
                If Err.Number = 6 Then
                Err.Clear
                'R = val(ig$)
                OverflowValue vbInteger
                End If
           Case 126
                Mid$(A$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = DefaultDec$
                r = CSng(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                OverflowValue vbSingle
                'If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                'R = val(ig$ + DE$)
                End If
            Case 117, 85
                Select Case Mid$(A$, sng + 1, 1)
                Case "b", "B"
                    Mid$(A$, sng, 2) = "  "
                    sg = 1
                    
                    r = CByte(Abs(val(ig$)))
                Case "d", "D"
                    Mid$(A$, sng, 2) = "  "
                    sg = 1
                    r = CDate(Abs(val(ig$ + DE$)))
                Case Else
                    Mid$(A$, sng, 1) = " "
                    
                    r = 0
                    Set bstack.lastobj = Module13.CreateBigInteger(ig$)
                        Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
                        IsNumber = True
                        Exit Function
                End Select
            Case Else
                r = val(ig$ + DE$)
            End Select
            Else
            r = val(ig$ + DE$)
            End If
            End If
            If Err.Number = 6 Then
                If Len(ex$) > 2 Then
                    ex$ = Left$(ex$, Len(ex$) - 1)
                    sng = sng - 1
                    Err.Clear
                    r = val(ig$ + DE$ + ex$)
                    If Err.Number = 6 Then
                        sng = sng - Len(ex$)
                        If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                         r = val(ig$ + DE$)
                    End If
                End If
                
           ErrInExponet A$
           Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
          IsNumber = False
            Exit Function
            End If
        End If
      Mid$(A$, 1, sng& - 1) = space$(sng& - 1)
    
    IsNumber = True
    Set bstack.lastobj = Nothing

End Function


Function IsNumberNew(bstack As basetask, A$, r As Variant, flatobject) As Boolean
Dim VR As Long, v$, V1&, w1 As Long, w2 As Long, p As Variant, s1$, dd As Long, dn As Long, w3 As Long
Dim pp As Variant, pppp As mArray, ppppL As iBoxArray, nbstack As basetask, usehandler As mHandler, usebackup As Boolean
Dim anything As Object, n$, useFast As FastCollection, userGroup As Group, useProp As PropReference, gr As Boolean, big As BigInteger
Dim sg1 As Boolean, s$, par As Boolean
r = 0#
If A$ = vbNullString Then IsNumberNew = False: Exit Function
'On Error Resume Next

Set bstack.lastobj = Nothing
againpointer:
w2 = Len(A$)
If w2 < 129 Then
    V1& = IsLabelBig(bstack, A$, v$, par, s1$, True, , usebackup, , gr)
Else
    n$ = Left$(A$, 128)
    s$ = bstack.tmpstr
    V1& = IsLabelBig(bstack, n$, v$, par, s1$, True, , usebackup, sg1, gr)
    If Len(n$) = 0 Then
        If sg1 Then bstack.tmpstr = s$
        sg1 = False
        V1& = IsLabelBig(bstack, A$, v$, par, s1$, True, , usebackup, , gr)
    Else
        If sg1 Then
        sg1 = False
        Select Case Len(n$)
        Case Is < 128
            Mid$(A$, 129 - Len(n$), Len(n$)) = n$
            A$ = Mid$(A$, 129 - Len(n$))
        Case Is > 128
            A$ = n$ + Mid$(A$, 129)
        Case Else
            Mid$(A$, 1, 128) = n$
        End Select
        Else
            A$ = Mid$(A$, 129 - Len(n$))
        End If
    End If
End If


If V1& = 0 Then Exit Function

If par Then
par = False
If usebackup Then If V1& > 4 Then GoTo conthere


removethis:
dn = dn + 1
If dn > 2 Then
' it is a var with name this or ауто
V1& = FastPureLabel((v$), v$)
VR = -1

End If
contthis1:
V1& = Abs(V1&)
 If V1& = 1 Then
 GoTo LOOKFORVARNUM
 ElseIf V1& = 4 Then
 GoTo LOOKFORVARNUM4
 ElseIf V1& = 5 Or V1& = 7 Then
 GoTo LOOKFORSUBNUM
 ElseIf V1& = 8 Then
 GoTo LOOKFORVARNUM
 Else
 IsNumberNew = False
  A$ = v$ + A$
    Exit Function
 End If
 ''
End If
conthere:
Select Case V1&
Case 1
If usebackup Then
    If Not numidbackup.Find(v$, w1) Then GoTo LOOKFORVARNUM
Else
    If Not numid.Find(v$, w1, bstack.numnum) Then GoTo LOOKFORVARNUM
    If w1 < 0 Then GoTo LOOKFORVARNUM
End If
findsecond:
On w1 GoTo num1, num2, num3, num4, num5, num6, num7, num8, num9, num10, num11, num12, num13, num14, num15, num16, num17, num18, num19, num20, num21, num22, num23, num24, num25, num26, num27, num28, num29, num30, num31, num32, num33, num34, num35, num36, num37, num38, num39, num40, num41, num42, num43, num44, num45, num46, num47, num48, num49, num50, num51, num52, num53, num54, num55, num56, num57, num58, num59, num60, num61, num62, num63, num64, num65, num66, num67, num68, num69, num70, num71, num72, num73, num74, num75, num76, num77, num78, num79, num80, num81, num82, num83, num84, num85, num86, num87, num88, num89, num90, num91, num92, num93, num94, num95, num96, num97, num98, num99, num100, num101, num102, num103, num104, num105, num106, num107
IsNumberNew = 0
InternalError
Exit Function
num107:
        
    r = MediaPlayer1.Height * Screen.TwipsPerPixelY
    IsNumberNew = True
    Exit Function
num106:
    r = MediaPlayer1.Width * Screen.TwipsPerPixelX
    IsNumberNew = True
    Exit Function

num105: ' "ADDRESSOF","диеухумсгапо"
IsNumberNew = False
    If findAddress(bstack, A$, r) Then
    IsNumberNew = True
    End If
    Exit Function
num104:
If sRec Is Nothing Then
    Set sRec = New RecordMci
    With sRec
    If Not .HaveMic Then Set sRec = Nothing: MissMic: Exit Function
    .Rec_Initialize
    .Mono
    .Bit8
    .QualityAny 11025
    End With
End If
r = sRec.getLevels()
IsNumberNew = True
Exit Function

num103:
r = doslast
IsNumberNew = True
Exit Function

num102: ' Case "MONITORS", "охомес"
r = DisplayMonitorCount
IsNumberNew = True
Exit Function
num101: ' Case "CLIPBOARD.DRAWING", "пяовеияо.сведио"
Set bstack.lastobj = GetImageEmf()
r = 0
IsNumberNew = True
Exit Function
num100: ' Case "CLIPBOARD.IMAGE", "пяовеияо.еийома"
Set bstack.lastobj = GetImageDIB()
r = 0
IsNumberNew = True
Exit Function
num99: ' Case "INTERNET", "диадийтуо"
r = Connected
IsNumberNew = True
Exit Function
num98:
r = pagio$ = "GREEK"
IsNumberNew = True
Exit Function
num82:
r = Infinity()
IsNumberNew = True
Exit Function
num93:
Set bstack.lastobj = NewVarItem()
bstack.lastobj.Typename = ">"
r = 0
IsNumberNew = True
FastSymbol A$, "?"
Exit Function
num90: ' "WINDOW","сусйеуг"
r = FindFormSScreen(bstack.Owner)
IsNumberNew = True
Exit Function
num89: '"OSBIT"
If Is64bit Then
r = 64#
Else
r = 32#
End If
IsNumberNew = True
Exit Function
num88: ' "охомг","SHOW"
    If Not Screen.ActiveForm Is Nothing Then
    If bstack.Owner Is Form1.DIS Then
    r = (Form1.hWnd = Screen.ActiveForm.hWnd And bstack.Owner.Visible)
    ElseIf Typename(bstack.Owner) = "PictureBox" Then
    r = bstack.Owner.Visible
    Else
    r = bstack.Owner.hWnd = Screen.ActiveForm.hWnd
    End If
    
    Else
    r = False
    End If
IsNumberNew = True
Exit Function
num87: ' "ISWINE"
r = IsWine
IsNumberNew = True
Exit Function
' Select Case v$
num1: ' "THIS", "ауто"   ' 1
IsNumberNew = This1(bstack, v$, r)
Exit Function

num2: ' "RND", "туваиос"
r = RndM(rndbase)
IsNumberNew = True
Exit Function

num3: ' "PEN", "пема"

With players(GetCode(bstack.Owner))
For w1 = 0 To 15
If QBColor(w1) = .mypen Then
r = w1
IsNumberNew = True
Exit Function
End If
Next w1
r = -.mypen
IsNumberNew = True
End With
Exit Function
num4: ' "HWND","паяахуяо"
r = myHwnd(bstack)

IsNumberNew = True
Exit Function
num5: ' Case "LOCALE", "топийо"
r = Clid
    
    IsNumberNew = True
    Exit Function

num6: ' "CODEPAGE", "йыдийосекида"
r = UserCodePage
    
    IsNumberNew = True
    Exit Function
num7: ' "SPEECH", "коцос"
  r = NumVoices

    
    IsNumberNew = True
    Exit Function
num8: ' "ERROR", "кахос"
    If LastErNum2 <> 0 Then
        r = LastErNum2
    Else
        r = LastErNum1
    End If
    
    LastErNum2 = 0
    LastErNum1 = 0  'reset when readed
    IsNumberNew = True
    Exit Function
num9: ' "SCREEN.Y", "амакусг.у"
    r = ScrInfo(Console).Height
    
    IsNumberNew = True
    Exit Function
num10: ' "SCREEN.X", "амакусг.в"
    r = ScrInfo(Console).Width
    
    IsNumberNew = True
    Exit Function
num11: ' "TWIPSY", "уьос.сглеиоу"
    r = Screen.TwipsPerPixelY
    
    IsNumberNew = True
    Exit Function
num12: ' "TWIPSX", "пкатос.сглеиоу"
    r = Screen.TwipsPerPixelX
    
    IsNumberNew = True
    Exit Function
num13: ' "REPORTLINES", "цяаллесамажояас"
    r = players(GetCode(bstack.Owner)).LastReportLines
    
    IsNumberNew = True
    Exit Function
num14: ' "LINESPACE", "диастиво"
    r = players(GetCode(bstack.Owner)).uMineLineSpace '' bstack.linespace
    
    IsNumberNew = True
    Exit Function
num15: ' "MODE", "тупос"
With players(GetCode(bstack.Owner))
If bstack.toprinter Then
    If .uMineLineSpace > .MineLineSpace Then
        r = .SZ / szFactor / 2
    Else
         r = .SZ / szFactor
    End If
    Else
    If .uMineLineSpace > .MineLineSpace Then
        r = .UseDouble
    Else
         r = .SZ
    End If
    
    
    End If
    End With
    
    IsNumberNew = True
    Exit Function
num16: ' "MEMORY", "лмглг"
    r = check_mem
    
    IsNumberNew = True
    Exit Function
num17: ' "CHARSET", "ваяайтгяес"   ' charset of the object to display
    r = players(GetCode(bstack.Owner)).charset
    
    IsNumberNew = True
    Exit Function
num18: ' "ITALIC", "пкациа"  ' charset of the object to display
    r = players(GetCode(bstack.Owner)).italics
    
    IsNumberNew = True
    Exit Function
num19: ' "BOLD", "жаядиа"  ' charset of the object to display
    r = players(GetCode(bstack.Owner)).bold
    
    IsNumberNew = True
    Exit Function
num20: ' "COLORS", "вяылата"
    r = 2# ^ bitsPerPixel
    
    IsNumberNew = True
    Exit Function
num21: ' "ауноуса", "ASCENDING"
    r = 0
    IsNumberNew = True
    Exit Function
num22: ' "жхимоуса", "DESCENDING"
    r = 1
    
    IsNumberNew = True
    Exit Function

num23: ' "BOOLEAN", "коцийос"
    r = 1
        
    IsNumberNew = True
    Exit Function
num24: ' "BYTE", "ьгжио"
    r = 2
        
    IsNumberNew = True
    Exit Function
num25: ' "INTEGER", "айеяаиос"
    r = 3
        
    IsNumberNew = True
    Exit Function
num26: ' "LONG", "лайяус"
    r = 4
        
    IsNumberNew = True
    Exit Function
num27: ' "CURRENCY", "коцистийос"
    r = 5
        
    IsNumberNew = True
    Exit Function
num28: ' "SINGLE", "апкос"
    r = 6
        
    IsNumberNew = True
    Exit Function
num29: ' "DOUBLE", "дипкос"
    r = 7
        
    IsNumberNew = True
    Exit Function
num30: ' "DATEFIELD", "глеяолгмиа"
    r = 8
        
    IsNumberNew = True
    Exit Function
num31: ' "BINARY", "дуадийо"
    r = 9
        
    IsNumberNew = True
    Exit Function
num32: ' "TEXT", "йеилемо"
    r = 10
        
    IsNumberNew = True
    Exit Function
num33: ' "OLE"
    r = 11
        
    IsNumberNew = True
    Exit Function
num34: ' "MEMO", "уполмгла"
    r = 12
        
    IsNumberNew = True
    Exit Function
num35: ' "REVISION", "амахеыягсг"
    r = Revision
    
    IsNumberNew = True
    Exit Function
num36: ' "BROWSER", "амакоцио"
        
        r = (Trim(LCase(Form1.view1.LocationURL)) = "about:blank" Or Form1.view1.Visible = False)
    IsNumberNew = True
    Exit Function
num37: ' "VERSION", "ейдосг"
    r = val(CStr(VerMajor) & "." & CStr(VerMinor))
    
    IsNumberNew = True
    Exit Function
num38: ' "MOTION.X", "йимгсг.в"
With bstack
If .toprinter Then
    r = 0
Else
    r = bstack.Owner.Left
    End If
    End With
    
    IsNumberNew = True
    Exit Function
num39: ' Case "MOTION.Y", "йимгсг.у"
With bstack
If .toprinter Then
    r = 0
Else
    r = .Owner.top
    End If
    
    End With
    
    IsNumberNew = True

    Exit Function
num40: ' "MOTION.XW", "йимгсг.вп", "MOTION.WX", "йимгсг.пв"
    r = Form1.Left
    
    IsNumberNew = True
    Exit Function
num41: ' "MOTION.YW", "йимгсг.уп", "MOTION.WY", "йимгсг.пу"
    r = Form1.top
    
    IsNumberNew = True
    Exit Function
num42: ' "FIELD", "педио"
    r = result
    
    
    IsNumberNew = True
    Exit Function
num43: ' "MOUSE.KEY", "деийтгс.йол"
  
    r = mouse2


       
    IsNumberNew = True
    Exit Function
num44: ' "MOUSE", "деийтгс"

If Not releasemouse Then
If Not Form1.Visible Then newshow Basestack1
End If
r = mouse
If r = 0 Then
MyDoEventsNoThread
     r = mouse ' MOUB
End If
    


    IsNumberNew = True
    Exit Function
num45: ' "MOUSE.X", "деийтгс.в"

With bstack
If .toprinter Then
    r = Form1.PrinterDocument1.currentX
ElseIf .toback Then
    r = MOUSEX(Form1.Left)
Else
    r = MOUSEX(Form1.Left + bstack.Owner.Left)
End If
End With
 
    IsNumberNew = True
    Exit Function
num46: ' "MOUSE.Y", "деийтгс.у"
With bstack
If .toprinter Then

r = Form1.PrinterDocument1.currentY
ElseIf .toback Then
r = MOUSEY(Form1.top)
Else
r = MOUSEY(Form1.top + bstack.Owner.top)
End If
End With
       
    IsNumberNew = True
    Exit Function
num47: ' "MOUSEA.X", "деийтгса.в"
  
    r = MOUSEX(Form1.Left)
    
      
    IsNumberNew = True
    Exit Function
num48: ' "MOUSEA.Y", "деийтгса.у"
 
    r = MOUSEY(Form1.top)
   
       
    IsNumberNew = True
    Exit Function

num49: ' "TRUE", "акгхес", "акгхгс"
    r = -1#
    IsNumberNew = True
    Exit Function
num50: ' "FALSE", "ьеудес", "ьеудгс"
    r = 0#
    IsNumberNew = True
    Exit Function
num51: ' "STACK.SIZE", "лецехос.сыяоу"
    IsNumberNew = True
    r = bstack.soros.Total
    
    Exit Function
num52: ' "ISNUM", "еимая"
    IsNumberNew = True
      If bstack.soros.Total > 0 Then
        If bstack.soros.PopType = "N" Then r = True Else r = False
    Else
        r = False
    End If
    
    Exit Function
num53: ' "PI", "пи"
    r = BigPi
    
    
    IsNumberNew = True
    Exit Function
num54: ' "NOT", "ови", "дем"
    If FastSymbol(A$, "(") Then
        If IsExpBig(bstack, A$, r, , True, , True) Then
            processNegateNonZero r
            r = Not r
            IsNumberNew = FastSymbol(A$, ")")
            Exit Function
        Else
            NotAfter A$
        End If
    ElseIf IsExpBig(bstack, A$, r, False, True, , True) Then
        processNegateNonZero r
        r = Not r
    Else
       NotAfter A$
    End If
    IsNumberNew = True
    Exit Function
num55: ' "ISLET", "еимця"
    IsNumberNew = True
    If bstack.soros.Total > 0 Then
        If bstack.soros.PopType = "S" Then r = True Else r = False
    Else
        r = False
    End If
    
    Exit Function
num56: ' Case "WIDTH", "пкатос"
    IsNumberNew = True
    r = players(GetCode(bstack.Owner)).mX
    
    Exit Function
num57: ' "POINT", "сглеио"
'  dsprite ??
    
    If TypeOf bstack.Owner Is MetaDc Then
        MyEr "Can't read pixel from metafile", "ДЕМ ЛПОЯЧ МА ДИАБэСЫ ЕИЙОМОСТОИВЕъО"
    Else
    IsNumberNew = True
    With players(GetCode(bstack.Owner))
    w1 = GetPixel(bstack.Owner.Hdc, .XGRAPH \ dv15, .YGRAPH \ dv15)
        If w1 = -1 Then
            r = &H7FFFFFFF
        Else
            r = -(w1 And &HFFFFFF)
        End If
        
    End With
    End If
    Exit Function
num58: ' "POS.X", "хесг.в"
    IsNumberNew = True
    r = players(GetCode(bstack.Owner)).XGRAPH
    
    Exit Function
num59: ' "POS.Y", "хесг.у"
    IsNumberNew = True
    r = players(GetCode(bstack.Owner)).YGRAPH
    
    Exit Function
num60: ' "SCALE.X", "йкилан.в", "в.сглеиа", "X.TWIPS"
    IsNumberNew = True
    If bstack.toprinter Then
    r = Form1.PrinterDocument1.ScaleWidth
    Else
    r = players(GetCode(bstack.Owner)).MAXXGRAPH
    End If
    
    Exit Function
num61: ' "SCALE.Y", "йкилан.у", "у.сглеиа", "Y.TWIPS"
    IsNumberNew = True
    If bstack.toprinter Then
    r = Form1.PrinterDocument1.ScaleHeight
    Else
    r = players(GetCode(bstack.Owner)).MAXYGRAPH
    End If
    
    Exit Function
num62: ' "EMPTY", "йемо"
    IsNumberNew = True
    r = (bstack.soros.Total = 0)
    
    Exit Function
num63: ' "MOVIE.COUNTER", "MEDIA.COUNTER", "MUSIC.COUNTER", "таимиа.летягтгс", "лоусийг.летягтгс"
    IsNumberNew = True
    r = MediaPlayer1.getPositionInSec
    If MediaPlayer1.Error > 0 Then
        r = -1
    End If
    
    Exit Function
num64: ' "PLAYSCORE", "паифеижымг"
    IsNumberNew = True
    
       r = TaskMaster.PlayMusic
    
    Exit Function
num65: ' "MOVIE", "MEDIA", "MUSIC", "таимиа", "лоусийг"
    IsNumberNew = True
    AVIRUN = MediaPlayer1.isMoviePlaying
    r = AVIRUN
    
    Exit Function
num66: ' "DURATION", "диаяйеиа"
    IsNumberNew = True
    r = MediaPlayer1.getLengthInMS / 1000
    
    Exit Function
num67: ' "VOLUME", "емтасг"
    IsNumberNew = True
    MediaPlayer1.GetMasterVolume vol
    r = CDbl(vol)
    
    Exit Function
num68: ' "TAB", "стгкг"
    IsNumberNew = True
    r = players(GetCode(bstack.Owner)).Column + 1  'CHANGED FROM Ver 7.1
    
    Exit Function
num69: ' "HEIGHT", "уьос"
    IsNumberNew = True
    r = players(GetCode(bstack.Owner)).mY
    
    Exit Function
num70: ' "POS", "хесг"
    IsNumberNew = True
    r = GetRealPos(bstack.Owner)
    
    Exit Function
num71: ' "ROW", "цяаллг"
    IsNumberNew = True
    r = GetRealRow(bstack.Owner)
    
    Exit Function
num72: ' "TIMECOUNT", "жоятос" ' ****************************
  IsNumberNew = True
    If bstack.Prof Is Nothing Then
    r = Prof.MARKTWO
    Else
    r = bstack.Prof.MARKTWO
    End If
    
    Exit Function

num73: ' "TICK", "тий" ' ****************************
  IsNumberNew = True
  If TaskMaster Is Nothing Then
  r = 0
  ElseIf TaskMaster.QueueCount = 0 Then
  r = 0
  Else
    r = tickTimer
    
  End If
    
    Exit Function
num74: ' "TODAY", "сглеяа"
    IsNumberNew = True
    r = CDbl(Date)
    
    Exit Function
num75: ' "NOW", "тыяа"
    IsNumberNew = True
    r = CDbl(CDate(time))
    
     Exit Function
num76: ' "MENU.VISIBLE", "епикоцес.жамеяес"  ' NEW 6.5 REV 8
    IsNumberNew = True
    r = Form1.List1.Visible
    
    Exit Function
num77: ' "MENUITEMS", "епикоцес"
    IsNumberNew = True
    r = Form1.List1.listcount
    
    Exit Function
num78: ' "MENU", "епикоцг"
    IsNumberNew = True
    r = 0
    With Form1.List1
    If .listcount > 0 Then
      r = CDbl(.ListIndex + 1)
     
    End If
    End With
    
    Exit Function
num85: ' "[]"
 Set usehandler = New mHandler
    usehandler.T1 = 3
    Set usehandler.objref = New mStiva
     usehandler.objref.MergeBottom bstack.soros
    '  Set bstack.Sorosref = New mStiva
    Set bstack.lastobj = usehandler
    r = 0
    IsNumberNew = True
    Exit Function

num84: ' "ARRAY", "пимайас"
    If bstack.soros.Total = 0 Then
        EmptyStack A$
        IsNumberNew = False: Exit Function
    ElseIf bstack.soros.StackItemTypeObjectType(1) = "*[mArray]" Then
        Set bstack.lastobj = bstack.soros.PopObj
        r = 0
        If FastSymbol(A$, "#") Then GoTo comehere
        IsNumberNew = True
        Exit Function
    Else
        StackTopNotArray A$
        IsNumberNew = False
    End If
Exit Function
num97:
    IsNumberNew = NewInventory(bstack, A$, r, True)
    Exit Function
num96:
    IsNumberNew = NewInventory(bstack, A$, r, False)
    Exit Function
num95:
w1 = 1
GoTo num941
num94: '"BUFFER", "диаяхяысг"
w1 = 2
num941:
    If bstack.soros.Total = 0 Then
        EmptyStack A$
        IsNumberNew = False: Exit Function
    ElseIf bstack.soros.StackItemType(1) = "*" Then
        Set bstack.lastobj = bstack.soros.PopObj
        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
            If usehandler.T1 <> w1 Then
                Set usehandler = Nothing
pushback:
                bstack.soros.PushObj bstack.lastobj
                Set bstack.lastobj = Nothing
                WrongObject
                IsNumberNew = False
                Exit Function
            End If
        Else
            GoTo pushback
        End If
        r = 0
        IsNumberNew = True
        Exit Function
    Else
        MyErMacro A$, "Stack top isn't " + v$, "г ЙОЯУЖч ТОУ СЫЯОЩ ДЕМ ЕъМАИ " + v$
        IsNumberNew = False
    End If
    Exit Function
num83: ' "GROUP", "олада"
    If bstack.soros.Total = 0 Then
        EmptyStack A$
        IsNumberNew = False: Exit Function
    ElseIf bstack.soros.StackItemTypeObjectType(1) = mGroup Then
        Set bstack.lastobj = bstack.soros.PopObj
        r = 0
        IsNumberNew = True
        Exit Function
    Else
        StackTopNotGroup A$
        IsNumberNew = False
    End If
    Exit Function
num79: ' "NUMBER", "аяихлос", "тилг"
    If bstack.soros.Total = 0 Then
        EmptyStack A$
        IsNumberNew = False: Exit Function
    ElseIf bstack.soros.PopType = "N" Then
        r = bstack.soros.PopVal
        
        IsNumberNew = True
        Exit Function
    ElseIf bstack.soros.PopType = "L" Then
        r = bstack.soros.PopVal
        
        IsNumberNew = True
        Exit Function
    Else
        If bstack.soros.count > 0 Then
            If bstack.soros.IsObj Then
                If TypeOf bstack.soros.objref(1) Is mHandler Then
                    Set usehandler = bstack.soros.objref(1)
                    If usehandler.T1 = 4 Then
                        If myVarType(usehandler.index_cursor, vbString) Then
                            r = usehandler.index_cursor
                        Else
                            r = usehandler.index_cursor * usehandler.sign
                          End If
                        bstack.soros.drop 1
                        IsNumberNew = True
                        Exit Function
                    ElseIf usehandler.UseIterator Then
                        r = usehandler.index_cursor
                        bstack.soros.drop 1
                        IsNumberNew = True
                        Exit Function
                    End If
                End If
            End If
        End If
        StackTopNotNumber A$
        IsNumberNew = False
    End If
    Exit Function
num81: ' "калда"
    Set bstack.lastobj = ProcLambda(bstack, A$, 0)
    r = 0
   If FastSymbol(A$, "(") Then
    If Not CallLambdaASAP(bstack, A$, r) Then IsNumberNew = False: Exit Function
    
    IsNumberNew = True
    Else
    IsNumberNew = Not bstack.lastobj Is Nothing
    End If
Exit Function
num80: ' "LAMBDA"
    Set bstack.lastobj = ProcLambda(bstack, A$, 1)
    r = 0
    If FastSymbol(A$, "(") Then
    If Not CallLambdaASAP(bstack, A$, r) Then IsNumberNew = False: Exit Function
    
    IsNumberNew = True
    Else
    IsNumberNew = Not bstack.lastobj Is Nothing
    End If
Exit Function
num86: ' Case "STACK", "сыяос"
IsNumberNew = IsStackObj(v$, bstack, A$, r)
    Exit Function
num91: 'MONITOR.STACK - екецвос.сыяоу
    r = CurrentStackSize()
    
    IsNumberNew = True
    Exit Function
Exit Function
num92: 'MONITOR.STACK.SIZE - екецвос.лецехос.сыяоу
    r = stacksize
    
    IsNumberNew = True
    Exit Function
Exit Function
LOOKFORVARNUM:
If GetVar(bstack, v$, VR) Then
    If MyIsObject(var(VR)) Then
        SwapStrings n$, v$
        SwapStrings v$, Typename(var(VR))
        If v$ = mProp Then
            Set useProp = var(VR)
            r = useProp.Value
            If Not useProp.lastobj Is Nothing Then
                Set bstack.lastobj = useProp.lastobjfinal
                r = 0
            Else
                
            End If
            Set useProp = Nothing
        ElseIf v$ = mGroup Then
            Set userGroup = var(VR)
            If userGroup.IamCleared Then
                Set userGroup = New Group
                userGroup.BeginFloat 0
                userGroup.EndFloat
                Set bstack.lastobj = userGroup
                IsNumberNew = True
                Exit Function
            End If
            If userGroup.HasValue And Not IsOperator(A$, "::", 2) Then
                If Len(userGroup.Patch) > 0 Then
                    s1$ = userGroup.Patch + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                Else
                    s1$ = n$ + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                End If
                If GetSub(s1$, V1&) Then
foundprivate:
                    Set nbstack = New basetask
                    Set nbstack.Parent = bstack
                    If bstack.IamThread Then Set nbstack.Process = bstack.Process
                    Set nbstack.Owner = bstack.Owner
                    nbstack.OriginalCode = V1&
                    nbstack.UseGroupname = sbf(V1&).sbgroup
                    nbstack.tpointer = sbf(V1&).tpointer
                    nbstack.SetV
                    If GoFunc(nbstack, s1$, ")", p) Then
                        If Not nbstack.StaticCollection Is Nothing Then
                            bstack.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                        End If
                        If Mid(A$, 1, 2) = "=>" Then
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is Group Then
                                    Set userGroup = bstack.lastobj
                                    Set bstack.lastobj = Nothing
                                    If userGroup.IamApointer Then
                                        Set ppppL = BoxGroupVar(CVar(userGroup))
                                        w2 = 0
                                        Set nbstack.lastobj = Nothing
                                        Set nbstack.lastpointer = Nothing
                                        Mid$(A$, 1, 2) = "." + Chr(3): GoTo contgroup
                                    Else
                                        NoOperatorForThatObject "=>"
                                    End If
                                End If
                            Else
                                NoOperatorForThatObject "=>"
                            End If
                            IsNumberNew = False
                            Exit Function
                        ElseIf IsOperator(A$, "(") Then
                            Set ppppL = New mArray
                            Set ppppL.GroupRef = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            If Not nbstack Is Nothing Then Set nbstack.lastobj = Nothing
                            ppppL.Arr = False
                            w2 = -2
                            Set nbstack = Nothing
                            v$ = vbNullString
                            GoTo contrightpar
                        ElseIf FastSymbol(A$, "#") Then
                            Set nbstack = Nothing
                            GoTo comehere
                        ElseIf Left$(A$, 1) = "|" Then
contUDT1:
                        Mid$(A$, 1, 1) = " "
                        If MemInt(VarPtr(p)) = vbUserDefinedType Then
                        w2 = FastPureLabel(A$, s$)
                        If w2 > 0 Then
                            If w2 = 1 Then
                            r = UDTValue(p, s$)
                             ElseIf w2 = 5 Then
                                If IsExp(bstack, A$, p) Then
                                    If FastSymbol(A$, ")") Then
                                         r = GetUDTValueArray(p, CVar(s$), CLng(p))
                                    End If
                                End If
                            End If
                            If MemInt(VarPtr(r)) = vbEmpty Then
                            If LastErNum = 0 Then BadUDTName
                            Else
                            IsNumberNew = True
                            End If
                            Exit Function
                        End If
                        Else
                        If Not bstack.lastobj Is Nothing Then
                            If TypeOf bstack.lastobj Is mHandler Then
                                Set usehandler = bstack.lastobj
                                Set bstack.lastobj = Nothing
                               If Not nbstack Is Nothing Then Set nbstack.lastobj = Nothing
                                If usehandler.T1 = 2 Then
                               If TakeOffset(bstack, usehandler, A$, r) Then
                                IsNumberNew = True
                                    Exit Function
                                End If
                                
                                
                                End If
                            End If
                        End If
                            Set bstack.lastobj = Nothing
                            If Not nbstack Is Nothing Then Set nbstack.lastobj = Nothing
                            WrongType
                        
                        End If
                            IsNumberNew = False
                            Exit Function
                        Else
                            Set nbstack = Nothing
                            r = p
                            
                        End If
                        IsNumberNew = True
                    Else
                        IsNumberNew = False
                    End If
                Else
                    If userGroup.HasStrValue Then
                        r = 0
                        Set bstack.lastobj = CopyGroupObj(var(VR))
                    Else
                        r = 0
                        s1$ = userGroup.Patch + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                        If Left$(s1$, Len(here$) + 1) = here$ + "." Then
                            s1$ = Mid$(s1$, Len(here$) + 2)
                        End If
                        If GetSub(s1$, V1&) Then GoTo foundprivate
                        InternalError
                        IsNumberNew = False
                    End If
                End If
                
            Else
                r = 0
                If userGroup.IamApointer Then
                    If Mid(A$, 1, 2) = "=>" Then
                        If userGroup.link.IamFloatGroup Then
                            Set ppppL = BoxGroupVar(var(VR))
                            Mid$(A$, 1, 2) = "." + Chr(3)
                            IsNumberNew = SpeedGroup(bstack, ppppL, "VAL", "", A$, (0)) = 1
                            r = bstack.LastValue
                            
                        Else
                            Mid(A$, 1, 2) = Chr$(0) + "."
                            Set bstack.lastpointer = userGroup
                            GoTo againpointer
                        End If
                    Else
                        Set bstack.lastpointer = userGroup.link
                        Set bstack.lastobj = userGroup
                    End If
                Else
                    CopyGroup2 var(VR), bstack
                    Set bstack.lastpointer = Nothing
               End If
              IsNumberNew = True
               Exit Function
            End If
        ElseIf v$ = "RefArray" Then
        If V1& = 8 Then
            Dim rA As refArray
            Set rA = var(VR)
jump8:
            If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                If Not FastSymbol(A$, "]") Then
                    SyntaxError
                    Exit Function
                Else
                    Set bstack.lastobj = rA.Copy
                    r = 0
                End If
            Else
                If Not FastSymbol(A$, "]") Then
                    SyntaxError
                    Exit Function
                End If
                p = Abs(Int(p))
conthere123:
                If rA.MarkTwoDimension Then
                    If Not FastOperator(A$, "[", 1) Then
                        ReDim r(0)
                        r(0) = rA(p)
                        Set bstack.lastobj = rA.NewRef(r)
                        r = 0
                    ElseIf Not IsExp(bstack, A$, pp, flatobject:=True, nostring:=True) Then
                        If Not FastSymbol(A$, "]") Then
                            SyntaxError
                            Exit Function
                        End If
                        ReDim r(0)
                        r(0) = rA(p)
                        Set bstack.lastobj = rA.NewRef(r)
                        r = 0
                    Else
                        If Not FastSymbol(A$, "]") Then
                            SyntaxError
                            Exit Function
                        End If
                        pp = Abs(Int(pp))
                        'Set bstack.lastobj = Nothing
                    '' check for object?? not implemented yet
                        If rA.count <= p Then
                            OutOfLimit
                            Exit Function
                        ElseIf rA.count(p) <= pp Then
                            If rA.vtType(p) = 9 Then
                            
                            
                            
                            If rA.IsInnerRefArray(p, rA) Then
                                ' IT IS A REFARRAY???
                                'Set ra = R
                                p = pp
                                GoTo conthere123
                                
                                End If
                            Else
                            ' not impl...
                            End If
                            
                            OutOfLimit
                            Exit Function
                        End If
                        Select Case rA.vtType(p, pp)
                            Case vbObject
                            Set nbstack = bstack
                            Set nbstack.lastobj = rA(p, pp)
                            p = 0
                            
                            GoTo goodjump
                        Case vbUserDefinedType
                            If FastSymbol(A$, "|") Then
                                w2 = IsLabelOnly(A$, s$)
                                If w2 = 1 Then
                                
                                r = rA.GetUDTValue(p, pp, CVar(s$))
                               
                                ElseIf w2 = 5 Then
                                    w1 = CLng(pp)
                                    If IsExp(bstack, A$, pp) Then
                                        If FastSymbol(A$, ")") Then
                                        
                                        r = rA.GetUDTValue(p, CVar(w1), CVar(s$), pp)
                                        End If
                                    End If
                                Else
                                    SyntaxError
                                    Exit Function
                                End If
                                If MemInt(VarPtr(r)) = vbEmpty Then
                                    If LastErNum = 0 Then BadUDTName
                                    Exit Function
                                End If
                            Else
                            r = rA(p, pp)
                            End If
                            If MyIsObject(r) Then
                                Set bstack.lastobj = r
                                Set r = Nothing
                                r = 0
                            End If
                        Case Else
                        r = rA(p, pp)
                        End Select
                        If MyIsObject(r) Then
                            Set bstack.lastobj = r
                            Set r = Nothing
                            r = 0
                        End If
                    End If
                Else
                    Set bstack.lastobj = Nothing
                    '' check for object?? not implemented yet
                    If rA.count((0)) <= p Then
                            OutOfLimit
                            Exit Function
                        Else
                        
                        If rA.vtType((0), p) = vbObject Then
                            Set nbstack = bstack
                            Set nbstack.lastobj = rA((0), p)
                            p = 0
                            GoTo goodjump
                        Else
                            If rA.vtType(0, p) = vbUserDefinedType Then
                                If FastSymbol(A$, "|") Then
                                    w2 = IsLabelOnly(A$, s$)
                                    If w2 = 1 Then
                                        r = rA.GetUDTValue((0), p, CVar(s$))
                                    ElseIf w2 = 5 Then
                                        If IsExp(bstack, A$, pp) Then
                                            If FastSymbol(A$, ")") Then
                                                r = rA.GetUDTValue((0), p, CVar(s$), pp)
                                            End If
                                        End If
                                    Else
                                        SyntaxError
                                        Exit Function
                                    End If
                                    If MemInt(VarPtr(r)) = vbEmpty Then
                                        If LastErNum = 0 Then BadUDTName
                                        Exit Function
                                    End If
                                Else
                                    r = rA((0), p)
                                End If
                            Else
                                r = rA((0), p)
                            End If
                            If MyIsObject(r) Then
                                Set bstack.lastobj = r
                                Set r = Nothing
                                r = 0
                            End If
                        End If
                    End If
                End If
            End If
        Else
            Set bstack.lastobj = var(VR)
            r = 0
        End If
        IsNumberNew = True
        Exit Function
        ElseIf v$ = "mEvent" Then
            CopyEvent var(VR), bstack
            r = 0
        ElseIf v$ = "lambda" Then
            CopyLambda var(VR), bstack
            r = 0
            
        ElseIf v$ = mHdlr Then
            ' this is ok for both buffer and inventory
            Set usehandler = var(VR)
            If usehandler.T1 = 2 Then
                
                If V1& = 8 Then
                If IsExp(bstack, A$, pp, , flatobject:=True, nostring:=True) Then
                
                If Left$(A$, 1) = "]" Then
                
                pp = CLng(pp)
                If Left$(A$, 2) = "]|" Then
                Mid$(A$, 1, 2) = "  "
                GoTo cont8case
                Else
                
                
                Mid$(A$, 1, 1) = " "
                    If usehandler.objref.structref Is Nothing Then
                    
                    If TakeOffset(bstack, usehandler, A$, r, pp) Then
                    IsNumberNew = True
                        
                    End If
                    
                    Exit Function
                    Else
                    Set pp = usehandler.objref.CopyItem(CLng(pp), par)
                    If par Then
                        Set usehandler = New mHandler
                        Set usehandler.objref = pp
                        usehandler.T1 = 2
                        Set bstack.lastobj = usehandler
                        IsNumberNew = True
                    End If
                    r = 0
                    Set pp = Nothing
                    End If
                    Exit Function
                End If
                ElseIf FastSymbol(A$, ",") Then
                    If IsExp(bstack, A$, p, , flatobject:=True, nostring:=True) Then
                        If FastSymbol(A$, "]") Then
                            s1$ = usehandler.objref.CopyItemString(CLng(pp), CLng(p), par)
                            r = ""
                            SwapString2Variant s1$, r
                            IsNumberNew = True
                            Exit Function
                        End If
                    End If
                End If
                End If
                SyntaxError
                Exit Function
                End If
                pp = 0&

                If Left$(A$, 1) = "|" Then
cont8case:
                Set p = var(VR)
                If TakeOffset(bstack, usehandler, A$, r, pp) Then
                Else
                    SyntaxError
                    Exit Function
                End If
                Else
                CopyHandler var(VR), bstack
                r = 0
                End If
            Else
                If Not usehandler.UseIterator Then
                    Set nbstack = Nothing  ' ???
                    If FastSymbol(A$, "#") Then
                        If Not usehandler.T1 = 3 Then WrongObject: Exit Function
                        If Not fMatrix(bstack, A$, usehandler, r) Then
                            Exit Function
                        End If
                        
                    ElseIf flatobject Then
                        If usehandler.T1 = 4 Then
                            r = usehandler.index_cursor
                            
                        Else
                            r = 0
                        End If
                    Else
                        CopyHandler var(VR), bstack
                        r = 0
                    End If
                ElseIf FastSymbol(A$, "^") Then
                    r = usehandler.index_cursor
                    
                ElseIf FastSymbol(A$, "#") Then
                    Set nbstack = Nothing '???
                    IsNumberNew = fMatrix(bstack, A$, usehandler, r)
                    If MyIsObject(r) Then r = 0#
                    
                Else
                    Set bstack.lastobj = var(VR)
                    r = 0
                End If
            End If
            Set usehandler = Nothing
        ElseIf v$ = "Constant" Then
            If var(VR).flag Then
                If VarTypeName(var(VR).Value) = "lambda" Then
                    CopyLambda var(VR).Value, bstack
                    r = 0
                End If
            Else
                r = var(VR)
                
            End If
        Else
            Set bstack.lastobj = var(VR) 'MakeitObjectGeneric(VR)
            r = 0
        End If
        
    Else
        Select Case MemInt(VarPtr(var(VR)))
        Case Is < 9, 11, 17, 14, 20
            r = var(VR)
        Case vbUserDefinedType ' udt
        On Error Resume Next
            If FastSymbol(A$, "|") Then
            w2 = FastPureLabel(A$, s$)
             If w2 > 0 Then
                If w2 = 1 Then
                r = UDTValue(var(VR), s$)
                ElseIf w2 = 5 Then
                     If IsExp(bstack, A$, p) Then
                        If FastSymbol(A$, ")") Then
                        r = GetUDTValueArray(var(VR), CVar(s$), CLng(p))
                        End If
                    End If
                End If
                If MemInt(VarPtr(r)) = vbEmpty Then
                    If LastErNum = 0 Then BadUDTName
                    Exit Function
                End If
             Else
                SyntaxError
             End If
            Else
            r = var(VR)
            End If
            If MyIsObject(r) Then
                Set bstack.lastobj = r
                Set r = Nothing
                r = 0
            End If
        Case 8192 To 8228
            ' make it an refarray???
            r = var(VR)
        Case Else
            r = 0
        End Select
    End If
    IsNumberNew = True
ElseIf VR = -1 Then
    r = ReadVarDouble(bstack, v$)
    If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is Group Then
            If bstack.lastobj.IamApointer Then
                If Left$(A$, 2) = "=>" Then
                    Set ppppL = BoxGroupVar(bstack.lastobj)
                    Mid$(A$, 1, 2) = "." + Chr(3)
                    IsNumberNew = SpeedGroup(bstack, ppppL, "VAL", "", A$, (0)) = 1
                    r = bstack.LastValue
                End If
            End If
        End If
    End If
    
    IsNumberNew = True
    Exit Function
Else
    If Len(v$) > 5 Then
        If Left$(v$, 5) = "THIS." Or Left$(v$, 5) = "ауто." Then
            v$ = Mid$(v$, 5)
            V1& = IsLabel(bstack, (v$), v$)
            If v$ <> "" Then GoTo removethis
        End If
    End If
    IsNumberNew = False
    If IsObject(bstack.LastEnum) Then
        r = bstack.LastEnum.SearchSimple(v$, par)
        
        If par Then
            Set usehandler = New mHandler
            Set usehandler.objref = bstack.LastEnum
            usehandler.T1 = 4
            usehandler.ReadOnly = True
            usehandler.index_cursor = r
            usehandler.index_start = bstack.LastEnum.Index
            Set bstack.lastobj = usehandler
            IsNumberNew = True
            Exit Function
        End If
    End If
    If V1& = 1 Then If numidbackup.Find(v$, w1) Then GoTo findsecond
    If w2 >= Len(A$) Then
        If v$ = myUcase(s1$, True) Then
            A$ = s1$ + A$
        Else
            A$ = v$ + A$
        End If
    End If
    If FindNameForGroup(bstack, v$) Then
        UnknownProperty1 A$, v$
    Else
        If LenB(v$) = 0 Then v$ = s1$
        If GetSub(v$ + "()", V1&) Then
            If Right$(sbf(V1&).sb, 1) = ChrW(&H1FFD) Then
                V1& = val(Mid$(sbf(V1&).sb, InStr(sbf(V1&).sb, "CALL EXTERN ") + 12))
                If var2used >= V1& Then
                    If VarType(var(V1&)) = vbObject Then
                        If TypeOf var(V1&) Is stdCallFunction Then
                            r = CVar(var(V1&).GetAddress)
                            IsLabel bstack, A$, v$
                            IsNumberNew = True
                            Exit Function
                        End If
                    End If
                End If
            End If
        End If
        UnknownVariable1 A$, v$
    End If
End If
Exit Function
Case 4
LOOKFORVARNUM4:
If GetVar(bstack, v$, VR) Then
If VarTypeName(var(VR)) = "lambda" Then
CopyLambda var(VR), bstack
Else

r = var(VR)

End If

IsNumberNew = True
Else
If VR = -1 Then

r = ReadVarInt(bstack, v$)

IsNumberNew = True
Exit Function
End If
IsNumberNew = False
    If w2 >= Len(A$) Then A$ = Left$(v$ + space$(Len(v$)), w2 - Len(A$)) + A$ Else
        If FindNameForGroup(bstack, v$) Then
            UnknownProperty1 A$, v$
        Else
            UnknownVariable1 A$, v$
        End If
    End If


Exit Function
Case 7
If usebackup Then
    GoTo isasub
Else
    GoTo LOOKFORSUBNUM
 End If
Case 5
'On Error Resume Next
If usebackup Then
        If Not funidbackup.Find(v$, w1) Then
       '' GoTo LOOKFORSUBNUM
       GoTo isasub
        End If
Else
    If Not funid.Find(v$, w1, bstack.numfunnum) Then GoTo LOOKFORSUBNUM
    If w1 < 0 Then GoTo LOOKFORSUBNUM
End If
'Select Case v$

findthird:
On w1 GoTo fun1, fun2, fun3, fun4, fun5, fun6, fun7, fun8, fun9, fun10, fun11, fun12, fun13, fun14, fun15, fun16, fun17, fun18, fun19, fun20, fun21, fun22, fun23, fun24, fun25, fun26, fun27, fun28, fun29, fun30, fun31, fun32, fun33, fun34, fun35, fun36, fun37, fun38, fun39, fun40, fun41, fun42, fun43, fun44, fun45, fun46, fun47, fun48, fun49, fun50, fun51, fun52, fun53, fun54, fun55, fun56, fun57, fun58, fun59, fun60, fun61, fun62, fun63, fun64, fun65, fun66, fun67, fun68, fun69, fun70, fun71, fun72, fun73, fun74, fun75, fun76, fun77, fun78, fun79, fun80, fun81, fun82, fun83, fun84, fun85, fun86, fun87, fun88, fun89, fun90, fun91, fun92, fun93, fun94, fun95, fun96, fun97, fun98, fun99, fun100, fun101, fun102, fun103, fun104, fun105, fun106, fun107, fun108, fun109, fun110, fun111, fun112, fun113, fun114, fun115, fun116
IsNumberNew = False
Exit Function
fun116:
    If IsExpBig(bstack, A$, p) Then
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is BigInteger Then
                Set big = bstack.lastobj
                Set bstack.lastobj = Module13.CreateBigInteger(StrConv(big.Reminder, vbUnicode))
                r = 0
            End If
        End If
    End If
    IsNumberNew = FastSymbol(A$, ")", True)
    Exit Function

fun115:
    If IsExpBig(bstack, A$, p) Then
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is BigInteger Then  ' IT IS FOR NOW ALWAYS
            Set big = bstack.lastobj
            Set bstack.lastobj = Nothing
            If FastSymbol(A$, ",") Then
                If IsExpBig(bstack, A$, p) Then
                    If Not bstack.lastobj Is Nothing Then
                        Set p = bstack.lastobj
                        If Not TypeOf p Is BigInteger Then WrongType: Exit Function
                    ElseIf MemInt(VarPtr(p)) = vbString Then
                        Set p = Module13.CreateBigInteger(CStr(p))
                    Else
                        Set p = Module13.CreateBigInteger(CStr(Int(p)))
                    End If
                    If FastSymbol(A$, ",") Then
                        If IsExpBig(bstack, A$, pp) Then
                        If Not bstack.lastobj Is Nothing Then
                            Set pp = bstack.lastobj
                            If Not TypeOf pp Is BigInteger Then WrongType: Exit Function
                        ElseIf MemInt(VarPtr(p)) = vbString Then
                            Set pp = Module13.CreateBigInteger(CStr(p))
                        Else
                            Set pp = Module13.CreateBigInteger(CStr(Int(p)))
                        End If
                        Set bstack.lastobj = big.modpow1(p, pp)
                        r = 0
                        End If
                    Else
                        MissParam A$
                        Exit Function
                    End If
                
                
                End If
            Else
                MissParam A$
                Exit Function
            End If
            End If
        End If
    End If
    IsNumberNew = FastSymbol(A$, ")", True)
    Exit Function
fun113:
IsNumberNew = getVarPtr(bstack, A$, r)
Exit Function
fun112: ' "CREATEOBJ(", "амтийеилемо("
    r = 0
    IsNumberNew = createAnobject(bstack, A$)
Exit Function
fun111: ' "PLAYER(", "паийтгс("
If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
    r = SpriteVisible(CLng(p))
    
    
    
    IsNumberNew = FastSymbol(A$, ")", True)
End If
Exit Function
fun108: '"POINTER(", "деийтгс("
IsNumberNew = GetPointer(bstack, A$)
Set bstack.lastobj = bstack.lastpointer
Set bstack.lastpointer = Nothing
If IsNumberNew Then IsNumberNew = FastSymbol(A$, ")")
Exit Function
fun101: ' "BANK(", "тяап("
IsNumberNew = False
If IsExp(bstack, A$, r, , True) Then
    If FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            r = Round(r, CLng(p))
            IsNumberNew = FastSymbol(A$, ")", True)
            Else
                MissParam A$
        End If
    Else
    r = Round(r)
    IsNumberNew = FastSymbol(A$, ")", True)
End If
    Else
                    
                MissParam A$
    End If

Exit Function

fun99: ' case "IF(","ам("
IsNumberNew = False
If IsExp(bstack, A$, p) Then IsNumberNew = ProcessIf(p, bstack, A$, r)
Exit Function
fun97: ' "READY(", "етоило("
IsNumberNew = False
    w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                    r = Not var(w1).Busy
                Else
                    r = True
                End If
                
                IsNumberNew = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      r = Not pppp.item(w2).Busy
                      Else
                      r = True
                      End If
                Else
                
                End If
                    
                IsNumberNew = FastSymbol(A$, ")", True)
    Else
                    
                MissParam A$
    End If
    Exit Function
fun100: ' "ORDER(","танг("
' this is same as sort numbers inside strings
If IsStrExp(bstack, A$, s1$, False) Then
If FastSymbol(A$, ",") Then
If IsStrExp(bstack, A$, s$, False) Then
If FastSymbol(A$, ")") Then
IsNumberNew = True
r = -compareStr4(s$, s1$)
Exit Function
Else
SyntaxError
Exit Function
End If
End If
End If
End If
MissStringExpr
IsNumberNew = False
Exit Function
fun1: ' "PARAM(", "паяал("
v$ = vbNullString
If IsStrExp(bstack, A$, s1$) Then
j1993874:
Do
w1 = Len(s1$)
      If IsNumberD2(s1$, p) Then
      If v$ = vbNullString Then
      r = p
      
      
        v$ = " "
      Else
      Select Case VarType(p)
        Case vbDate
        v$ = v$ + "," + str$(MemDbl(VarPtr(p) + 8)) + "ud"
        Case vbByte
        v$ = v$ + "," + str$(p) + "ub"
        Case vbLong
        v$ = v$ + "," + str$(p) + "&"
        Case vbDecimal
        v$ = v$ + "," + str$(p) + "@"
        Case vbSingle
        v$ = v$ + "," + str$(p) + "~"
        Case vbCurrency
        v$ = v$ + "," + str$(p) + "#"
        Case vbInteger
        v$ = v$ + "," + str$(p) + "%"
        Case 20
        v$ = v$ + "," + str$(p) + "&&"
        Case Else
        v$ = v$ + "," + str$(p)
        End Select
      End If
      Else
             ISSTRINGA s1$, s$
        If v$ = vbNullString Then Exit Do Else v$ = v$ + ",{" + s$ + "}"
    End If
    FastSymbol s1$, ","
Loop Until Trim$(s1) = vbNullString Or w1 = Len(s1$)
ElseIf IsExp(bstack, A$, p) Then
    If MemInt(VarPtr(p)) = vbString Then s1$ = p: GoTo j1993874
    If bstack.lastobj Is Nothing Then
        ExpectedObjInline A$
    ElseIf TypeOf bstack.lastobj Is mHandler Then
        Set usehandler = bstack.lastobj
        Set bstack.lastobj = Nothing
        If usehandler.indirect >= 0 Then
            If MyIsObject(var(usehandler.indirect)) Then
                dd = usehandler.indirect
                Set usehandler = New mHandler
                On Error Resume Next
                'Err.Clear
                ' maybe we want the typelib
                If FastSymbol(A$, ",") Then
                
                End If
                Set usehandler.objref = MakeATypeLib(var(dd))

                If Err Then
                   Err.Clear
                   Set bstack.lastobj = Nothing
                   cantreadlib A$
                    Else
                   usehandler.T1 = 1
                    Set bstack.lastobj = usehandler
                End If
                
                On Error GoTo 0
                Set usehandler = Nothing
            Else
            ExpectedObjInline A$
            End If
            Else
            If usehandler.IamEnum Then Set anything = usehandler.objref: GoTo contparamhere
        End If
    ElseIf TypeOf bstack.lastobj Is PropReference Then
        Set useProp = bstack.lastobj
        If useProp.IsObj Then
            r = useProp.Value
            Set anything = useProp.lastobjfinal
contparamhere:
            Set usehandler = New mHandler
                On Error Resume Next
                'Err.Clear
                ' maybe we want the typelib
                If FastSymbol(A$, ",") Then
                
                End If
                Set usehandler.objref = MakeATypeLib(anything)

                If Err Then
                    Err.Clear
                    Set bstack.lastobj = Nothing
                    cantreadlib A$
                Else
                    usehandler.T1 = 1
                    Set bstack.lastobj = usehandler
                End If
                On Error GoTo 0
         Else
            ExpectedObjInline A$
        End If
    Else
            Set anything = bstack.lastobj
            Set usehandler = New mHandler
            On Error Resume Next
            If FastSymbol(A$, ",") Then
            
            End If
            Set usehandler.objref = MakeATypeLib(anything)

            If Err Then
                Err.Clear
                Set bstack.lastobj = Nothing
                cantreadlib A$
            Else
                usehandler.T1 = 1
                Set bstack.lastobj = usehandler
            End If
            On Error GoTo 0
        End If
    End If
    IsNumberNew = FastSymbol(A$, ")", True)
    A$ = Mid$(v$, 2) + A$
    Exit Function
fun73: ' "EACH("
    If iter(bstack, A$, 1) Then
        r = 0
        IsNumberNew = FastSymbol(A$, ")", True)
    Else
        IsNumberNew = False
    End If
    Exit Function
fun72: ' "йахе("
    If iter(bstack, A$, 0) Then
        r = 0
        IsNumberNew = FastSymbol(A$, ")", True)
    Else
        IsNumberNew = False
    End If
    Exit Function
fun2: ' "STACKITEM(", "тилгсыяоу("
    IsNumberNew = StackItem(bstack, A$, r)
    If FastSymbol(A$, "#") Then GoTo comehere
    Exit Function
fun3: ' "SGN(", "сгл("
If IsExpBig(bstack, A$, p, flatobject:=True, nostring:=True) Then
    If bstack.lastobj Is Nothing Then
        r = Sgn(MyRound(p, 28))
    Else
        r = bstack.lastobj.bSgn()
        Set bstack.lastobj = Nothing
    End If
    IsNumberNew = FastSymbol(A$, ")", True)
Else
    MissParam A$: IsNumberNew = False
End If
Exit Function
fun4: ' "FRAC(", "дей("
If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
r = MyRound(Abs(Abs(p) - Int(Abs(p))), 13)



 IsNumberNew = FastSymbol(A$, ")", True)
 Else
MissParam A$: IsNumberNew = False
End If
Exit Function
fun5: ' "MATCH(", "таутисг("
If IsStrExp(bstack, A$, s1$, False) Then
If s1$ = vbNullString Then
r = 0

               IsNumberNew = FastSymbol(A$, ")", True)
ElseIf VALIDATEmStiva(bstack, UCase$(s1$), s$) Then   ' Only S and N
                If s$ = vbNullString Then
                    r = False
                Else
                   r = True
               End If
               Else
               r = False
               End If
               
               IsNumberNew = FastSymbol(A$, ")", True)
Else
MissParam A$
End If
Exit Function
fun6: ' "LOCALE(", "топийо("
If IsStrExp(bstack, A$, s1$, False) Then
If FastSymbol(A$, ",") Then
If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
r = FoundSpecificLocaleId(s1$, CLng(Fix(p)))
Else
MissParam A$: IsNumberNew = False: Exit Function
End If
Else
r = FoundLocaleId(s1$)
End If
   

    IsNumberNew = FastSymbol(A$, ")", True)
End If
Exit Function
fun7: ' "FILELEN(", "аявеиоу.лгйос("
If IsStrExp(bstack, A$, s1$, False) Then
If s1$ = vbNullString Then
r = 0

IsNumberNew = FastSymbol(A$, ")", True)
Else
If ExtractPath(s1$) = vbNullString Then
    If CFname(s1$) <> "" Then
        s1$ = CFname(s1$)
    ElseIf mylcasefILE(s1$) = ExtractName(s1$, True) Then
        s1$ = mcd + s1$
    End If
End If
       r = myFileLen(GetDosPath(s1$))
    IsNumberNew = FastSymbol(A$, ")", True)
End If
Else
: MissParam A$
End If
Exit Function
fun8: ' "TAB(", "стгкг("
If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then

r = p * (players(GetCode(bstack.Owner)).Column + 1)
   
    IsNumberNew = FastSymbol(A$, ")", True)
End If
Exit Function
fun9: ' "KEYPRESS(", "патглемо("
If Not IsExp(bstack, A$, p) Then
MissNumExpr
IsNumberNew = False
Exit Function
Else
r = CLng(KeyPressed(CLng(Fix(p))))

End If
 

    IsNumberNew = FastSymbol(A$, ")", True)
    Exit Function
fun10: ' "INKEY(", "емйол("

BLOCKkey = True
If Not IsExp(bstack, A$, p) Then p = 50: dn = 1
If p < 50 Then p = 50
p = p / 2
Call GetSystemTimeAsFileTime(basictimer)
    p = p + basictimer
   If dn = 1 Then r = 0 Else r = clickMe

If Not (bstack.IamThread And dn = 1) Then clickMe2 = -2
               w1 = -1
                    Do While p > basictimer
                    Call GetSystemTimeAsFileTime(basictimer)
                  
                  
                 If Not bstack.IamThread Then
                    MyDoEvents
                    mywait bstack, 5
                    Else
                    
                    p = 0
                    ''If (dn = 0) Then
                    If r = clickMe2 Then Exit Do
                    
                    r = -3
                      clickMe2 = clickMe
                      
                      
                    End If
                    If clickMe2 = r Then clickMe2 = -2
                    If w1 = -1 Then
                    If clickMe2 <> -2 Then
             
              
                    w1 = clickMe2
              
                    If w1 = 19 Or w1 = 131139 Then
                    'this IS A BREAK
                    BLOCKkey = False
                  
                   Form1.GiveASoftBreak (w1 = 19)
                    End If
                    p = 0
                    End If
                    End If
                     
                Loop
                If bstack.IamThread Then
        If bstack.LastClick = w1 Then
            w1 = -1
        Else
            bstack.LastClick = w1
        End If
End If
  r = w1
    
  clickMe2 = -1



IsNumberNew = FastSymbol(A$, ")", True)
BLOCKkey = False
Exit Function
fun11: ' "тлгла(", "MODULE("
    If FastSymbol(A$, ")") Then
        r = uintnew1(Addr(AddressOf Module2.ExtCall))
        
        IsNumberNew = True
    Else
        MakeThisSub1 bstack, A$
        If IsLabel(bstack, A$, s$) Then
            r = True
            If Right$(s$, 1) = "(" Then
                FastSymbol A$, ")"
                s$ = s$ + ")"
            End If
            If GetlocalSub(s$, w1) Then
                ElseIf Not GetSub(s$, w1) Then
                If Not GetSub2(bstack, s$, w1) Then
                    r = False
                End If
            End If
            If FastSymbol(A$, "!") Then
                r = w1
            End If
            
            IsNumberNew = True
        End If
        IsNumberNew = FastSymbol(A$, ")", True)
    End If
    
Exit Function
fun12: ' "басг(", "MDB("
If IsStrExp(bstack, A$, s$, False) Then
If ExtractType(s$) = vbNullString Then s$ = s$ + ".MDB"
s$ = CFname(s$)
If s$ <> "" Then
r = CheckMine(s$)

Else
r = 0
End If
   
    IsNumberNew = FastSymbol(A$, ")", True)
End If
Exit Function
fun13: ' "ASK(", "яыта("
If IsStrExp(bstack, A$, AskText$, False) Then
If Not CallAsk(bstack, A$, v$) Then IsNumberNew = False: Exit Function

r = Form1.NeoASK(bstack)
AskInput = False
    IsNumberNew = FastSymbol(A$, ")", True)
End If
Exit Function
fun14: ' "суцйяоусг(", "COLLIDE("
    IsNumberNew = IsCollide(bstack, A$, r)
    Exit Function
fun15: ' "лецехос.у(", "SIZE.Y("

    IsNumberNew = SizeY(bstack, A$, s$, s1$, r)
    Exit Function
fun16: ' "лецехос.в(", "SIZE.X("
    IsNumberNew = SizeX(bstack, A$, s$, s1$, r)
    Exit Function
fun17: ' "WRITABLE(", "еццяаьило("  ' АМ ЛПОЯЧ МА ЦЯэЬЫ СТО ЖэЙЕКО
    If IsStrExp(bstack, A$, s$, False) Then
      r = WeCanWrite(s$)
   
    
    
    IsNumberNew = FastSymbol(A$, ")", True)
    Exit Function
    End If
    IsNumberNew = False
    Exit Function
fun110:  '"HSL(","вйж("

    If Not ColorHSL(bstack, A$, r) Then Exit Function
    r = -r

        IsNumberNew = FastSymbol(A$, ")", True)
        Exit Function
fun18: ' "COLOR(", "COLOUR(", "вяыла("
    
   If Not ColorRGB(bstack, A$, r) Then Exit Function

    r = -r

        IsNumberNew = FastSymbol(A$, ")", True)
        Exit Function
fun19: ' "DIMENSION(", "диастасг("
IsNumberNew = IsDimension(bstack, A$, r)

    Exit Function
fun20: ' "ARRAY(", "пимайас("
    IsNumberNew = IsArrayFun(bstack, A$, r)
    If FastSymbol(A$, "#") Then GoTo comehere
    Exit Function
fun21: ' "FUNCTION(", "сумаятгсг("
IsNumberNew = False
    If IsStrExp(bstack, A$, s$, False) Then
        If IsSymbolBracket(s$) Then
            PushStage bstack, False
            s1$ = block(s$)
            FastSymbol s$, "}"
            GlobalSub "A_()", s1$, Trim$(s$)
            IsSymbol3 A$, ","
            A$ = "A_(*" + A$
            IsNumberNew = IsExp(bstack, A$, r)
            PopStage bstack
        Else
        If lookOne(A$, ".") Then
            dd = 1
            s1$ = aheadstatus(A$, , dd)
            s$ = s$ + Left$(A$, dd - 1)
            A$ = Mid$(A$, dd)
        End If
        FastSymbol A$, ","
        ' manipulate inline the code...
        If Right$(s$, 1) = ")" Then
            A$ = Left$(s$, Len(s$) - 1) + A$
        ElseIf InStr(s$, ").") > 0 Then
            If Not FastSymbol(A$, ")") Then
                A$ = s$ + "(*" + A$
            Else
                A$ = s$ + A$
            End If
        Else
            A$ = s$ + "(*" + A$
        End If
        IsNumberNew = IsExp(bstack, A$, r)
    End If
    Else
        MissParam A$
    
    End If
    Exit Function
fun22: ' "DRIVE.SERIAL(", "сеияиайос.дисйоу("
    IsNumberNew = DriveSerial1(bstack, A$, r)
Exit Function
fun23: ' "FILE.STAMP(", "аявеиоу.сталпа("
IsNumberNew = False
    If IsStrExp(bstack, A$, s$, False) Then
        pp = 1
        If IsSymbol(A$, ",") Then
            If Not IsExp(bstack, A$, pp) Then
                MissNumExpr
                Exit Function
            End If
        End If
        If CFname(s$, p, pp) <> vbNullString Then
            If p = 0 Then
                CantReadFileTimeStap A$
            Else
                r = p
            End If
        Else
            BadFilename
            Exit Function
        End If
        IsNumberNew = FastSymbol(A$, ")", True)
    Else
         MissParam A$
    End If
    Exit Function
fun25: ' "EXIST.DIR(", "упаявеи.йатакоцос("
IsNumberNew = False
    If IsStrExp(bstack, A$, s$, False) Then
        r = isdir(s$)
        IsNumberNew = FastSymbol(A$, ")", True)
    Else
        MissParam A$
    End If
    Exit Function
fun26: ' "EXIST(", "упаявеи("
    IsNumberNew = ExistNum(bstack, A$, r)
    Exit Function
fun27: ' "JOYPAD(", "кабг("
  IsNumberNew = False
    If IsExp(bstack, A$, r, , True) Then
        
    r = Int(r)
    
    
    If r < 0 Or r > 15 Then
    
    WrongJoypadNumber A$

    Exit Function
    End If
    If Not MYJOYSTAT(r).enabled Then
    IsNumberNew = False
        joypader A$, r
    Exit Function
    End If
    If Not MYJOYSTAT(r).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(r).Wait2Read Then
        joypader A$, r
        
    Exit Function
    End If
    End If
    r = MYJOYSTAT(r).lngButton
IsNumberNew = FastSymbol(A$, ")", True)
       Else
       IsNumberNew = False
  MissParam A$
         ' IsNumberNew = FastSymbol(a$, ")")
  End If
  Exit Function
fun28: ' "JOYPAD.DIRECTION(", "кабг.йатеухумсг("
  IsNumberNew = False
    If IsExp(bstack, A$, r, , True) Then
    r = Int(r)
    
    If r < 0 Or r > 15 Then
    
    WrongJoypadNumber A$
    
    Exit Function
    End If
    If Not MYJOYSTAT(r).enabled Then
        joypader A$, r
    
    Exit Function
    End If
    If Not MYJOYSTAT(r).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(r).Wait2Read Then
        joypader A$, r
    
    Exit Function
    End If
    End If
    r = MYJOYSTAT(r).joyPaD
    IsNumberNew = FastSymbol(A$, ")", True)
       Else
        MissParam A$
  End If
  Exit Function
fun29: ' "JOYPAD.ANALOG.X(", "кабг.амакоцийо.в("
  IsNumberNew = False
    If IsExp(bstack, A$, r, , True) Then
    r = Int(r)
    
    If r < 0 Or r > 15 Then
    
    WrongJoypadNumber A$
    Exit Function
    End If
    If Not MYJOYSTAT(r).enabled Then
        joypader A$, r
            Exit Function
    End If
    If Not MYJOYSTAT(r).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(r).Wait2Read Then
        joypader A$, r
    Exit Function
    End If
    End If
    r = MYJOYSTAT(r).AnalogX
    IsNumberNew = FastSymbol(A$, ")", True)
       Else
        MissParam A$
  End If
  Exit Function
fun30: ' "JOYPAD.ANALOG.Y(", "кабг.амакоцийо.у("
  IsNumberNew = False
    If IsExp(bstack, A$, r, , True) Then
    r = Int(r)
    
    If r < 0 Or r > 15 Then
    
    WrongJoypadNumber A$
    Exit Function
    End If
    If Not MYJOYSTAT(r).enabled Then
        joypader A$, r
    Exit Function
    End If
    If Not MYJOYSTAT(r).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(r).Wait2Read Then
        joypader A$, r
    Exit Function
    End If
    End If
    r = MYJOYSTAT(r).AnalogY
    IsNumberNew = FastSymbol(A$, ")", True)
       Else
            MissParam A$
  End If
  Exit Function
fun104: ' "BUFFER(", "диаяхяысг("
IsNumberNew = False
    If IsStrExp(bstack, A$, s$) Then
j243423:
        If Not bstack.lastobj Is Nothing Then GoTo contbuf1
        w1 = Abs(Asc(v$) < 128)
        If IsLabelSymbolNew(A$, "ыс", "AS", w1) Then
            If IsLabelSymbolNew(A$, "дейаен", "HEX", w1) Then
                Set usehandler = New mHandler
                usehandler.T1 = 2
                Set usehandler.objref = DecodeHEXtoMemBloc(s$, par)
            ElseIf Not IsSymbol(A$, "DECODE64", 8) Then
                MyEr "Only Decode64 supported", "лЭМО ТО Decode64 УПОСТГЯъФЕТАИ"
                Exit Function
            Else
                Set usehandler = New mHandler
                usehandler.T1 = 2
                Set usehandler.objref = Decode64toMemBloc(s$, par)
            End If
            If par Then
                Set bstack.lastobj = usehandler
                IsNumberNew = FastSymbol(A$, ")", True)
                Exit Function
            Else
                MyEr "Can't Decode String", "дЕМ ЛПОЯЧ МА АПОЙЫДИЙОПОИчСЫ ТО АКЖАЯИХЛГТИЙЭ"
                IsNumberNew = False
                Exit Function
            End If
        ElseIf CFname(s$) <> "" Then
            Set usehandler = New mHandler
            usehandler.T1 = 2
            If FastSymbol(A$, ",") Then
                If Not IsExp(bstack, A$, p) Then
                    MissNumExpr
                    Exit Function
                End If
            End If
            Set usehandler.objref = File2newMemblock(s$, r, p)
            If r = 0# Then
                Set bstack.lastobj = usehandler
                IsNumberNew = FastSymbol(A$, ")", True)
                Exit Function
            End If
        Else
            MissFile
        End If
    ElseIf IsExp(bstack, A$, r) Then
        If myVarType(r, vbString) Then
            s$ = r: GoTo j243423
        End If
contbuf1:
        r = 0#
        p = 0#
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                Set bstack.lastobj = Nothing
                If usehandler.T1 = 2 Then
                    If FastSymbol(A$, ",") Then
                        IsExp bstack, A$, r
                        If FastSymbol(A$, ",") Then
                            If Not IsExp(bstack, A$, p) Then
                                MissNumExpr
                                Exit Function
                            End If
                        End If
                    End If
                
                     Set usehandler.objref = usehandler.objref.Copy(r, p)
                    Set bstack.lastobj = usehandler
                    IsNumberNew = FastSymbol(A$, ")", True)
                    Exit Function
                End If
            End If
            
            
        End If
    Else
    IsNumberNew = FastSymbol(A$, ")", True)
    End If
    ' no buffer return (using Buffer() as empty function)
    r = 0#
    Set bstack.lastobj = Nothing
    Exit Function
fun103: ' "IMAGE(", "еийома("
IsNumberNew = False
    If IsStrExp(bstack, A$, s$) Then
j1222:
        If Left$(s$, 4) = "cDIB" And Len(s$) > 12 Then
            Set usehandler = New mHandler
            usehandler.T1 = 2
        
            Set usehandler.objref = SaveStr2MemBlock(s$, r)
            If r = 0 Then
                Set bstack.lastobj = usehandler
                IsNumberNew = FastSymbol(A$, ")", True)
                r = 0#
                Exit Function
            End If
        Else  ' QRcode
                GetQrCode bstack, A$, s$
                If Not bstack.lastobj Is Nothing Then
                    If TypeOf bstack.lastobj Is mHandler Then
                        IsNumberNew = FastSymbol(A$, ")", True)
                        r = 0#
                        Exit Function
                    End If
                End If
        End If
        noImage A$
            
    ElseIf IsExp(bstack, A$, r) Then
        If myVarType(r, vbString) Then
            s$ = r: GoTo j1222
        End If
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                Set bstack.lastobj = Nothing
                If usehandler.T1 = 2 Then
                If usehandler.objref.IsEmf Or usehandler.objref.IsWmf Then
                  ' WRONG BUFFER
                Else
                    If usehandler.objref.ReadImageSizeX(r) Then
                        r = 0
                        dd = 0
                        w1 = -1
                        w2 = -1
                        w3 = 0
                        If FastSymbol(A$, ",") Then
                            If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                                If Not MaybeIsSymbol(A$, ",") Then
                                    Set bstack.lastobj = Nothing
                                    MissParam A$
                                    Exit Function
                                End If
                                dd = &HFFFFFF
                            Else
                                dd = CLng(p)
                            End If
                            If FastSymbol(A$, ",") Then
                                If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                                    If Not MaybeIsSymbol(A$, ",") Then
                                        Set bstack.lastobj = Nothing
                                        MissParam A$
                                        Exit Function
                                    End If
                                Else
                                    w1 = Abs(CLng(p))
                                    If w1 < 1 Then w1 = -1
                                End If
                                If FastSymbol(A$, ",") Then
                                    If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                                        If Not MaybeIsSymbol(A$, ",") Then
                                            Set bstack.lastobj = Nothing
                                            MissParam A$
                                            Exit Function
                                        End If
                                    Else
                                        w2 = Abs(CLng(p))
                                        If w2 < 1 Then w2 = -1
                                    End If
                                    If FastSymbol(A$, ",") Then
                                    If Not IsExp(bstack, A$, p) Then
                                        Set bstack.lastobj = Nothing
                                        MissParam A$
                                        Exit Function
                                    Else
                                        w3 = CLng(Abs(p))
                                    End If
                                End If
                            End If
                        End If
                    Else
                        p = &HFFFFFF
                    End If
                    Set bstack.lastobj = usehandler.CreateFromPicture(dd, w1, w2, w3)
                    End If
                          Set usehandler = Nothing
                          IsNumberNew = FastSymbol(A$, ")", True)
                      Exit Function
                  End If
              End If
           End If
        End If
        Set bstack.lastobj = Nothing
            noImageInBuffer A$
            IsNumberNew = False
            r = 0#
    Else
        MissParam A$
    End If
    Exit Function

fun31: ' "IMAGE.X(", "еийома.в("
IsNumberNew = GetImageX(bstack, A$, r)
    Exit Function
fun32: ' "IMAGE.Y(", "еийома.у("
    IsNumberNew = GetImageY(bstack, A$, r)
   
    Exit Function
fun33: ' "IMAGE.X.PIXELS(", "еийома.в.сглеиа("
IsNumberNew = GetImageXpixels(bstack, A$, r)
    Exit Function
fun34: ' "IMAGE.Y.PIXELS(", "еийома.у.сглеиа("
IsNumberNew = GetImageYpixels(bstack, A$, r)

    Exit Function
fun35: ' "VALID(", "ецйуяо("
IsNumberNew = Validator(bstack, A$, v$, r)
Exit Function
fun36: ' "EVAL(", "ейжя(", "ейжяасг("
    IsNumberNew = IsEval(v$, bstack, A$, r)
    If FastOperator(A$, "(", 1) Then
    If Not bstack.lastobj Is Nothing Then
     If Typename(bstack.lastobj) = mHdlr Then
     Set ppppL = New mArray
     Set ppppL.GroupRef = bstack.lastobj
     Set bstack.lastobj = Nothing
     ppppL.Arr = False
     GoTo contAr2L
     ElseIf Typename(bstack.lastobj) = myArray Then
     Set ppppL = bstack.lastobj
     Set bstack.lastobj = Nothing
     v$ = ppppL.CodeName + "("
     GoTo contAr2
     ElseIf Typename(bstack.lastobj) = mGroup Then
     GoTo contgrouppar
     End If
    Else
    SyntaxError
    Exit Function
    End If
    
    End If
    If FastSymbol(A$, "#") Then GoTo comehere
    Exit Function
fun37: ' "POINT(", "сглеио("
    IsNumberNew = IsPoint(bstack, A$, r)
    Exit Function
fun38: ' "CTIME(", "упыяа("
    IsNumberNew = IsCtime(bstack, A$, r)
    Exit Function
fun39: ' "CDATE(", "уплея("
    IsNumberNew = IsCdate(bstack, A$, r)
    Exit Function
fun40: ' "TIME(", "вяомос("
    IsNumberNew = IsTimeVal(bstack, A$, r)
    Exit Function
fun41: ' "DATE(", "глеяа("
    IsNumberNew = IsDataVal(bstack, A$, r)
    Exit Function
fun42: ' "VAL(", "тилг(", "аниа("
    IsNumberNew = IsVal(bstack, A$, r, Left$(v$, 1) = "V")
    If FastSymbol(A$, "#") Then GoTo comehere
    Exit Function
fun43: ' "хесгдениа("
    IsNumberNew = IsRinstr(bstack, A$, r, (1), 0)
    Exit Function
fun107: ' "RINSTR("
    IsNumberNew = IsRinstr(bstack, A$, r, (1), 1)
    Exit Function
fun44: ' "INSTR(", "хесг("
    IsNumberNew = IsInstr(bstack, A$, r, (1), 0)
    Exit Function
fun106:
    IsNumberNew = IsInstr(bstack, A$, r, (1), 1)
    Exit Function
fun45: ' "RECORDS(", "еццяажес("
    IsNumberNew = IsRecords(bstack, A$, r)
    Exit Function
fun46: ' "GROUP.COUNT(", "олада.сумоко("
    IsNumberNew = IsGroupCount(bstack, A$, r)
    Exit Function
fun47: ' "PARAGRAPH(", "паяацяажос("
    IsNumberNew = IsParagr(bstack, A$, r)
    Exit Function
fun48: ' "PARAGRAPH.INDEX(", "аяихлос.паяацяажоу("
 IsNumberNew = IsParIndex(bstack, A$, r)
    Exit Function
fun49: ' "BACKWARD(", "писы("
    IsNumberNew = IsForwBack(1, bstack, A$, r)
    Exit Function
fun50: ' "FORWARD(", "лпяоста("
    IsNumberNew = IsForwBack(0, bstack, A$, r)
    Exit Function
fun51: ' "DOC.PAR(", "еццяажоу.пая("
    IsNumberNew = IsDocPar(bstack, A$, r)
    Exit Function
fun52: ' "MAX.DATA(", "лецако.сеияас("
    IsNumberNew = IsMaxData(bstack, A$, r)
    Exit Function
fun53: ' "MIN.DATA(", "лийяо.сеияас("
    IsNumberNew = IsMinData(bstack, A$, r)
    Exit Function
fun54: ' "MAX(", "лецако("
    IsNumberNew = IsCompMinMax(2, bstack, A$, r)
    Exit Function
fun55: ' "MIN(", "лийяо("
    IsNumberNew = IsCompMinMax(1, bstack, A$, r)
    Exit Function
fun56: ' "COMPARE(", "суцйяиме("
    IsNumberNew = IsCompMinMax(0, bstack, A$, r)
    Exit Function
fun57: ' "DOC.UNIQUE.WORDS(", "еццяажоу.ломадийес.кенеис("
    IsNumberNew = IsDocUniqueWords(bstack, A$, r)
    Exit Function
fun58: ' "DOC.WORDS(", "еццяажоу.кенеис("
    IsNumberNew = IsDocWords(bstack, A$, r)
    Exit Function
fun59: ' "DOC.LEN(", "еццяажоу.лгйос("
    IsNumberNew = IsDocLen(bstack, A$, r)
    Exit Function
fun60: ' "LEN.DISP(", "лгйос.елж("
    IsNumberNew = IsLenDisp(bstack, A$, r)
    Exit Function
fun61: ' "LEN(", "лгйос("
 IsNumberNew = IsLen(bstack, A$, r)
    Exit Function
fun62: ' "SQRT(", "яифа("
    IsNumberNew = IsSqrt(bstack, A$, r)
    Exit Function
fun63: ' "FREQUENCY(", "сувмотгта("
    IsNumberNew = IsFreq(bstack, A$, r)
    Exit Function
fun64: ' "LOG(", "коц("
    IsNumberNew = IsLog(bstack, A$, r)
    Exit Function
fun65:  ' "LN(", "кж("
    IsNumberNew = IsLn(bstack, A$, r)
    Exit Function
fun66: ' "ATN(", "тон.еж("
    IsNumberNew = IsAtan(bstack, A$, r)
    Exit Function
fun67:  ' "TAN(", "ежап("
  IsNumberNew = IsTan(bstack, A$, r)
    Exit Function
fun68:  ' "COS(", "сум("
    IsNumberNew = IsCos(bstack, A$, r)
    Exit Function
fun69:  ' "SIN(", "гл("
    IsNumberNew = IsSin(bstack, A$, r)
    Exit Function
fun70:  ' "ABS(", "апок("
IsNumberNew = IsAbs(bstack, A$, r)
Exit Function
fun71: ' "LOWORD(", "LOWWORD(", "йатылисо("
    IsNumberNew = IsLOWORD(bstack, A$, r)
    Exit Function
fun74: ' "HIWORD(", "HIGHWORD(", "памылисо("
   IsNumberNew = IsHIWORD(bstack, A$, r)
    Exit Function
fun75: ' "BINARY.NEG(", "дуадийо.амти(", "дуадийо.амтистяожо("
    IsNumberNew = IsBinaryNeg(bstack, A$, r)
    Exit Function
fun76: ' "BINARY.OR(", "дуадийо.г("
    IsNumberNew = IsBinaryOr(bstack, A$, r)
    Exit Function
fun105: ' "BINARY.NOT(", "дуадийо.ови("
    IsNumberNew = IsBinaryNot(bstack, A$, r)
    Exit Function
fun77: ' "BINARY.AND(", "дуадийо.йаи("
    IsNumberNew = IsBinaryAnd(bstack, A$, r)
    Exit Function
fun78: ' "BINARY.XOR(", "дуадийо.апо("
    IsNumberNew = IsBinaryXor(bstack, A$, r)
    Exit Function
fun79: ' "HILOWWORD(", "дуолиса("
    IsNumberNew = IsHILOWWORD(bstack, A$, r)
    Exit Function
fun80: ' "BINARY.SHIFT(", "дуадийо.окисхгсг("
    IsNumberNew = IsBinaryShift(bstack, A$, r)
    Exit Function
fun81: ' "BINARY.ROTATE(", "дуадийг.пеяистяожг("
    IsNumberNew = IsBinaryRotate(bstack, A$, r)
    Exit Function
fun82: ' "SINT(", "айеяаио.дуадийо("
' GET AN Unsigned AND GIVES A SIGN...AS READING BITS
    IsNumberNew = IsSint(bstack, A$, r)
    Exit Function
fun83: ' "USGN(", "дуадийо("
    IsNumberNew = IsUsgn(bstack, A$, r)
    Exit Function
fun84: ' "UINT(", "дуадийо.айеяаио("
' READING BITS OF A SIGN AND GIVE AN Unsigned OF SAME BITS
    IsNumberNew = IsUint(bstack, A$, r)
    Exit Function
fun102: ' "CEIL(","ояож("
    IsNumberNew = IsCeil(bstack, A$, r)
    Exit Function
fun85:  ' "ROUND(", "стяоцц("
    IsNumberNew = IsRound(bstack, A$, r)
    Exit Function
fun86:  ' "INT(", "ай(", "FLOOR(","дапед("
    IsNumberNew = IsInt(bstack, A$, r)
    Exit Function
fun87: ' "SEEK(", "летахесг("
    IsNumberNew = IsSeek(bstack, A$, r)
    Exit Function
fun88:  ' "EOF(", "текос("
    IsNumberNew = IsEof(bstack, A$, r)
    Exit Function
fun89: ' "RANDOM(", "туваиос("
    IsNumberNew = IsRandom(bstack, A$, r)
    Exit Function
fun24: ' "STACK(", "сыяос("
    IsNumberNew = IsStack(bstack, A$, r)
    Exit Function
fun92: ' "GROUP(", "олада("
    IsNumberNew = IsGroup(bstack, A$, r)
    Exit Function
fun98: ' "PROPERTY(", "идиотгта("
    IsNumberNew = IsProperty(bstack, A$, r)
    Exit Function
fun90: ' "CHRCODE(", "ваяйыд("
    IsNumberNew = IsChrCode(bstack, A$, r)
    Exit Function
fun91: ' "ASC(", "йыд("
    IsNumberNew = IsAsc(bstack, A$, r)
    Exit Function
fun94: ' "CONS(", "емысг("
    IsNumberNew = IsCons(bstack, A$, r)
    If FastSymbol(A$, "#") Then GoTo comehere
    Exit Function
fun95: ' "CAR(", "пяыто("
    IsNumberNew = IsCar(bstack, A$, r)
    If FastSymbol(A$, "#") Then GoTo comehere
    Exit Function
fun96: ' "CDR(", "еполема("
    IsNumberNew = IsCdr(bstack, A$, r)
    If FastSymbol(A$, "#") Then GoTo comehere
    Exit Function
fun93: ' "TEST(", "дойилг("
    IsNumberNew = IsTest(bstack, A$, r)
    Exit Function
fun109: ' "BINARY.ADD(", "дуадийо.пяосхесг(","дуадийо.пяо("
    IsNumberNew = IsBinaryAdd(bstack, A$, r)
    Exit Function
fun114:
    If IsExp(bstack, A$, p) Then
        If MemInt(VarPtr(p)) = vbString Then
            SwapString2Variant s$, p
            GoTo FUN114A
        End If
        MissStringExpr
        Exit Function
    ElseIf IsStrExp(bstack, A$, s$, False) Then
FUN114A:
    p = 0
    If FastSymbol(A$, ",") Then
        If Not IsExp(bstack, A$, p, , True, , True) Then
            MissNumExpr
            Exit Function
        End If
    Else
        p = 10
    End If
    If FastSymbol(A$, ")") Then
        IsNumberNew = True
        r = 0
        If p > 1 And p < 37 Then
            Set bstack.lastobj = CreateBigInteger(s$, p)
        Else
            Set bstack.lastobj = CreateBigInteger(s$)
        End If
    End If
    ElseIf FastSymbol(A$, ")") Then
        IsNumberNew = True
        r = 0
        Set bstack.lastobj = CreateBigInteger("0")
    End If
    Exit Function
LOOKFORSUBNUM:
''On Error Resume Next
If Len(s1$) = 1 Then
If s1$ = Chr(0) Then
If bstack.lastpointer Is Nothing Then GoTo skiperror
Set ppppL = bstack.lastpointer
Set bstack.lastpointer = Nothing
w2 = 0
GoTo contAr22
Else
SyntaxError
Exit Function
End If
Else
s1$ = v$ + ")" ' ANY CHAR HERE
End If
MakeThisSubNum bstack, s1$
If IsSymbol(A$, "*") Then
'is a function allways...
If GetlocalSub(s1$, V1&) Then
    GoTo contAr1
ElseIf GetSub(s1$, V1&) Then
GoTo contAr1
ElseIf GetSub2(bstack, s1$, V1&) Then
GoTo contAr1

Else
GoTo skiphere
End If

Else
If neoGetArray(bstack, v$, ppppL, , , True) Then

    GoTo contAr2L
ElseIf LastErNum <> 0 Then
Exit Function
ElseIf GetlocalSub(s1$, V1&) Then
    GoTo contAr1
ElseIf neoGetArray(bstack, v$, ppppL, , True) Then
GoTo contAr2
ElseIf GetSub2(bstack, s1$, V1&) Then
GoTo contAr1

ElseIf GetSub(s1$, V1&) Then
GoTo contAr1
Else
skiphere:
If Len(bstack.UseGroupname) > 0 Then
    If InStr(s1$, bstack.UseGroupname) = 1 Then
        s1$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(s1$, Len(bstack.UseGroupname) + 1)
        If GetSub(s1$, V1&) Then GoTo contAr1
    End If
End If
If Right$(s1$, 1) = ")" Then
    If here$ Like "*." + s1$ Then
        subHash.ItemCreatorNoSwap s1$, bstack.OriginalCode, True
        GoTo contAr1
    ElseIf s1$ = "LAMBDA()" Then
contlambda01:
        If bstack.IamLambda Then
            s1$ = bstack.FuncRec
        Else
           s1$ = Mid$(here$, rinstr(here$, "╩.") + 2)
           If Right$(here$, 2) = "()" And bstack.UseGroupname = vbNullString Then

            s1$ = sbf(bstack.OriginalCode).goodname
            V1& = bstack.OriginalCode
           ElseIf Not GetSub(s1$, V1&) Then
               If here$ Like "*." + s1$ Then
                  ' subHash.ItemCreatorNoSwap s1$, bstack.OriginalCode, True
                  s1$ = sbf(bstack.OriginalCode).goodname
                   V1& = bstack.OriginalCode
               Else
                   GoTo skiperror
               End If
           End If
        End If
        GoTo contAr1
    ElseIf s1$ = "калда()" Then
        GoTo contlambda01
    Else
        If Right$(s1$, 3) <> "$()" Then
            If neoGetArray(bstack, Left$(s1$, Len(s1$) - 2) + "$(", ppppL) Then
            If Typename(ppppL.GroupRef) = mGroup Then
            If Typename(ppppL) = "mArray" Then
            v$ = Left$(s1$, Len(s1$) - 2)
            Set pppp = ppppL
            pppp.CodeName = v$
            End If
            End If
            GoTo contAr2
           End If
        End If
        dd = dd + 1
        If dd > 30 Then
            IsNumberNew = False
            Exit Function
        End If
    End If
End If
If funidbackup.Find(v$, w1) Then GoTo findthird
GoTo skiperror
End If
End If
'''ver 18
If GetSub(s1$, V1&) Then
GoTo contAr1
ElseIf neoGetArray(bstack, v$, pppp) Then
GoTo contAr2
Else
GoTo skiperror
End If
If GetSub(s1$, V1&) Then
contAr1:
's1$ = Trim$(s1$)

    If bstack.NoFuncError Then
    
    CallNext bstack, A$, par, p, v$
    If par Then
       r = p
        IsNumberNew = True
    Else
    r = 0
        IsNumberNew = False
    End If
                
            
Else
    
    Set nbstack = New basetask
    Set nbstack.Parent = bstack
    If bstack.IamThread Then Set nbstack.Process = bstack.Process
    Set nbstack.Owner = bstack.Owner
    nbstack.OriginalCode = V1&
    nbstack.UseGroupname = sbf(V1&).sbgroup
    nbstack.tpointer = sbf(V1&).tpointer
    nbstack.SetV
    If GoFunc(nbstack, s1$, A$, p) Then
        ' Lookone(a$,"#")
goodjump:
        If Left$(A$, 1) = "#" Then
            If nbstack.lastobj Is Nothing Then
                NotArray
                IsNumberNew = False
            End If
            Set nbstack = Nothing
            Set anything = bstack.lastobj
            
           ' Set bstack.lastobj = anything
            If TypeOf bstack.lastobj Is mHandler Then
                FastSymbol A$, "#"
               ' Set nbstack = Nothing
                Set bstack.lastobj = anything
                GoTo comehere
            ElseIf TypeOf bstack.lastobj Is Group Then
jumpgroup001:
                Set userGroup = anything
                Set nbstack = Nothing
                Set bstack.lastobj = anything
                If Not (userGroup.HasValue And Not userGroup.HasParameters) Then
                    Mid$(A$, 1, 1) = "."
                End If
again1001:
                Set ppppL = New ppppLight
                ppppL.Arr = False
                
                Set ppppL.GroupRef = bstack.lastobj
                w2 = -2
                Set nbstack = Nothing
                Set bstack.lastobj = Nothing
                GoTo contgroup3
            Else
                Mid$(A$, 1, 1) = Chr$(1)
                GoTo comehere
            End If
        ElseIf Left$(A$, 1) = "." Then
        If TypeOf bstack.lastobj Is Group Then
                Mid$(A$, 1, 1) = "#"
                Set anything = bstack.lastobj
                GoTo jumpgroup001
        End If
        ElseIf Left$(A$, 1) = "(" Then
            If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is lambda Then
                    FastSymbol A$, "("
                    If Not CallLambdaASAP(bstack, A$, r) Then IsNumberNew = False: Exit Function
                End If
            End If
        ElseIf Left$(A$, 2) = "=>" Then
            Mid$(A$, 1, 2) = "." + Chr(3) ' Chr$(7) + "."
            GoTo again1001
        ElseIf Left$(A$, 1) = "[" Then
         If Not nbstack.lastobj Is Nothing Then
         If TypeOf nbstack.lastobj Is refArray Then
         Set rA = nbstack.lastobj
         Set nbstack.lastobj = Nothing
         Set bstack.lastobj = Nothing
         Mid$(A$, 1, 1) = " "
         GoTo jump8
         End If
         End If
         SyntaxError
         IsNumberNew = False
         Exit Function
        
        ElseIf Left$(A$, 1) = "|" Then
            
            GoTo contUDT1
        ElseIf InStr(v$, "%") > 0 Then
               
                r = MyRound(p)
        Else
                 r = p
  
        End If
            
            IsNumberNew = True
    Else
  ''
     IsNumberNew = False
    End If
End If
Exit Function

ElseIf neoGetArray(bstack, v$, ppppL) Then
contAr2:
    
contAr2L:
    If MaybeIsSymbol3(A$, ")", w3) Then
        IsNumberNew = True
        If Not ppppL.Arr Then
            If Typename(ppppL.GroupRef) = mGroup Then
                If ppppL.GroupRef.HasParameters Then
                
                    GoTo conthere102030
                Else
                MyErMacro A$, "No parameter list for this group", "дЕМ УПэЯВЕИ КъСТА ПАЯАЛщТЯЫМ ЦИА АУТчМ ТГМ ОЛэДА"
                End If
            ElseIf Typename(ppppL.GroupRef) = mHdlr Then
                '' here the poke as alfa(3).value or аКЖА(3).ТИЛч
                Set usehandler = ppppL.GroupRef
                A$ = Mid$(A$, w3 + 1)
                If usehandler.indirect >= 0 Then
                    MyErMacro A$, "Not implemented yet", "дЕМ ЕВЕИ АЙЭЛА УКОПОИГХЕъ АУТЭ"
                    Exit Function
                End If
                If Left$(A$, 1) = "." Then
                ' LOOK FOR GROUP
                    w2 = -usehandler.objref.Index - 2
                    GoTo contgroup
                ElseIf FastSymbol(A$, "(") Then
                    w2 = -usehandler.objref.Index - 2
                    Set usehandler = Nothing
                    GoTo contlambdahere
                Else
                    Set bstack.lastobj = ppppL
                    If usehandler.T1 = 2 Then
                        r = usehandler.objref.GetPtr(0)
                    Else
                        r = usehandler.objref.Done
                    End If
                End If
                Set usehandler = Nothing
            ElseIf Typename(ppppL.GroupRef) = mProp Then
               ' Set useProp = pppp.GroupRef
               ' useProp.IndexOpt
               ' R = useProp.Value
                Set bstack.lastobj = ppppL
                A$ = Mid$(A$, w3 + 1)
            Else
                A$ = Mid$(A$, w3 + 1)
                ' what object we have here????
            End If
        Else
            A$ = Mid$(A$, w3 + 1)
            r = 0
            If FastSymbol(A$, "#") Then
                Set usehandler = New mHandler
                usehandler.T1 = 3
                Set usehandler.objref = ppppL
                Set nbstack = Nothing
                Set bstack.lastobj = usehandler
                GoTo comehere
            End If
            If TypeOf ppppL Is mArray Then
                Set pppp = ppppL
                Set bstack.lastobj = pppp
            Else
                Set bstack.lastobj = ppppL
            End If
        End If
        Exit Function
    End If
    
    If ppppL.Arr Then
        Set pppp = ppppL
        dn = 0
        pppp.SerialItem (0), dd, 5
        dd = dd - 1
        If dd < 0 Then
            If Typename(pppp.GroupRef) = mProp Then
                GoTo contreadprop
            End If
        End If
        p = 0
        pp = 0
        IsNumberNew = True
        w2 = 0
        Do While dn <= dd
            ' pppp.SerialItem w3, dn, 6
             pppp.GetDnum dn, w3, V1&
            If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                If dn < dd Then
                    If Not FastSymbol(A$, ",") Then: MyErMacro A$, "need index for " + v$ + ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " + v$ + ")": IsNumberNew = False: Exit Function
                Else
                    If FastSymbol(A$, ",") Then
                    IsNumberNew = False
                    MyErMacro A$, "too many indexes for array " + v$ + ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " + v$ + ")"
                    Exit Function
                End If
                If Not FastSymbol(A$, ")") Then: MissSymbol ")": IsNumberNew = False: Exit Function
            End If
            On Error Resume Next
            If p < -V1& Then
                IsNumberNew = False
                    MyErMacro A$, "index too low for array " + v$ + ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " + v$ + ")"
                    Exit Function
                End If
                If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
                    IsNumberNew = False
                    MyErMacro A$, "index too high for array " + v$ + ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " + v$ + ")"
                    IsNumberNew = False
                    Exit Function
                End If
                On Error GoTo 0
            Else
                IsNumberNew = False
                If Not LastErNum = -2 Then
                        MyErMacro A$, "missing index for array " + v$ + ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " + v$ + ")"
                End If
                Exit Function
            End If
            dn = dn + 1
        Loop
        'Set ppppL = pppp
                    ' here here here
contAr22:
        If ppppL.ItemType(w2) = mGroup Then
contgroup00:
            If Left$(A$, 1) = "." Then
contgroup:
                               
                IsNumberNew = SpeedGroup(bstack, ppppL, "VAL", v$, A$, w2) = 1
                    
                        r = bstack.LastValue

                ElseIf Left$(A$, 1) = "(" Then
contgroup3:
                    IsNumberNew = SpeedGroup(bstack, ppppL, "VAL", v$, A$, w2) = 1
                            r = bstack.LastValue

                Else
contgroup2:
                    If ppppL.item(w2).IamApointer Then
                        IsNumberNew = True
                        If Left$(A$, 2) = "=>" Then Mid$(A$, 1, 2) = "." + Chr(3): GoTo contgroup
                        Set bstack.lastpointer = pppp.item(w2).link
                        Set bstack.lastobj = pppp.item(w2)
                        r = 0
                    ElseIf pppp.item(w2).HasValue Then
                        If pppp.item(w2).HasParameters Then
                            GoTo contgroup
                        Else
                            IsNumberNew = SpeedGroup(bstack, pppp, "VAL", v$, "", w2) = 1
                                r = bstack.LastValue
                        End If
                    Else
                        If pppp.item(w2).IamApointer Then
                            If Mid(A$, 1, 2) = "=>" Then
                                Mid(A$, 1, 2) = Chr$(0) + "."
                                Set bstack.lastpointer = pppp.item(w2)
                                GoTo againpointer
                            Else
                                Set bstack.lastobj = pppp.item(w2)
                            End If
                        Else
                            bstack.soros.CopyGroupObj pppp.item(w2), anything
                            Set bstack.lastobj = anything
                        End If
                    End If
                End If
              
                Exit Function
                ElseIf pppp.ItemIsObject(w2) Then
                    If FastSymbol(A$, "(") Then
    
contlambdahere:
                        w3 = 0
                        Set ppppL = pppp
                        Select Case pppp.ItemType(w2)
                        Case "lambda"
contlambdahere2:
                            PushStage bstack, False
                            w1 = globalvarGroup("A_" & (Abs(w2)), 0#)
                            Set var(w1) = ppppL.item(w2)
                            If here$ = vbNullString Then
                                GlobalSub "A_" & (Abs(w2)) & "()", "", , , w1
                            Else
                                GlobalSub here$ & "." & bstack.GroupName & "A_" & (Abs(w2)) & "()", "", , , w1
                            End If
againlambda:
                            bstack.tmpstr = "A_" & (Abs(w2)) & "(" & Left$(A$, 1)
                            BackPort A$
                            IsNumberNew = IsNumberNew(bstack, A$, p, False)
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is lambda Then
                                    If IsOperator(A$, "(") Then
                                        Set var(w1) = bstack.lastobj
                                        GoTo againlambda
                                    End If
                                ElseIf IsOperator(A$, "(") Then
                                    If TypeOf bstack.lastobj Is mArray Then
                                        PopStage bstack
                                      '  PopStage bstack
                                        Set ppppL = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        w3 = 0
                                        GoTo contAr2
                                    ElseIf TypeOf bstack.lastobj Is mHandler Then
                                        
                                        Set usehandler = bstack.lastobj
                                        If usehandler.T1 = 3 Then
                                            PopStage bstack
                                            Set anything = usehandler
                                            If CheckIsmArray(anything) Then
                                                Set ppppL = anything
                                            Else
                                                Set ppppL = New ppppLight
                                                ppppL.Arr = False
                                                Set ppppL.GroupRef = usehandler
                                            End If
                                            Set anything = Nothing

                                        ElseIf usehandler.T1 = 1 Then
                                            PopStage bstack
                                            Set ppppL = New ppppLight
                                            ppppL.Arr = False
                                            Set ppppL.GroupRef = usehandler
                                            w2 = -2
                                            GoTo contrightpar
                                        Else
                                            Set ppppL = New ppppLight
                                            ppppL.Arr = False
                                            Set ppppL.GroupRef = usehandler
                                        End If
                                        Set usehandler = Nothing
                                        GoTo contAr2
                                    ElseIf TypeOf bstack.lastobj Is mArray Then
                                ' what???
                                    ElseIf TypeOf bstack.lastobj Is Group Then
                                        PopStage bstack
                                    
cont100203030:
                                        Set ppppL = New ppppLight
                                        ppppL.Arr = False
                                        Set ppppL.GroupRef = bstack.lastobj
                                        w2 = -2
                                        GoTo contgroup3
                                    End If
                                ElseIf TypeOf bstack.lastobj Is mArray Then
                                    PopStage bstack
                                    Set ppppL = bstack.lastobj
                                    Set bstack.lastobj = Nothing
                                    w3 = 0
                                    GoTo contAr2
                                ElseIf TypeOf bstack.lastobj Is Group Then
                                    PopStage bstack
                                    Set ppppL = New ppppLight
                                    ppppL.Arr = False
                                    Set ppppL.GroupRef = bstack.lastobj
                                    w2 = -2
                                    If Left$(A$, 1) = "." Then
                                        GoTo contgroup
                                    Else
                                        GoTo contgroup2
                                    End If
                                End If
                            End If
                            Set var(w1) = Nothing
                            If Right$(ppppL.arrname, 2) = "%(" Then
                                r = MyRound(p)
                            Else
                                r = p
                            End If
                            PopStage bstack
                            IsNumberNew = True
                            Exit Function
                        Case myArray
                            Set ppppL = pppp.item(w2)
                            w3 = 0
                            GoTo contAr2
                        Case mHdlr
                            Set bstack.lastobj = pppp.item(w2)
                            Set usehandler = bstack.lastobj
                            If usehandler.T1 = 3 Then
                                Set anything = usehandler
                                If CheckIsmArray(anything) Then
                                    Set ppppL = anything
                                Else
                                    Set ppppL = New ppppLight
                                    ppppL.Arr = False
                                    Set ppppL.GroupRef = usehandler
                                End If
                            Else
                                Set ppppL = New ppppLight
                                ppppL.Arr = False
                                Set ppppL.GroupRef = usehandler
                            End If
                            Set anything = Nothing
                            Set bstack.lastobj = Nothing
                            Set usehandler = Nothing
                            w3 = 0
                            GoTo contAr2
                        Case mProp
                            pppp.GetPorp useProp, w2
                            w3 = 0
                            Set bstack.lastobj = Nothing
                            Set usehandler = Nothing
                            Set ppppL = pppp
                            GoTo contreadprop2
                        End Select
                        Set bstack.lastobj = Nothing
                        Set usehandler = Nothing
                        w3 = 0
                        Set ppppL = pppp
                        GoTo contAr2
                    Else
    ' here is the fault
                            r = rValue(bstack, ppppL.itemObject(w2))
                            If FastSymbol(A$, "#") Then
                                Set nbstack = Nothing ' ???
comehere:
                                If Not bstack.lastobj Is Nothing Then
                                    If TypeOf bstack.lastobj Is mHandler Then
                                        Set usehandler = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        IsNumberNew = fMatrix(bstack, A$, usehandler, r)
                                        If Left$(A$, 1) = "." And Not bstack.lastobj Is Nothing Then
                                        If TypeOf bstack.lastobj Is Group Then
                                        GoTo cont100203030
                                        
                                        End If
                                        ElseIf bstack.lastobj Is Nothing Then
                                        ElseIf Not TypeOf bstack.lastobj Is mHandler And Not bstack.lastobj Is Nothing Then
                                        Set bstack.lastobj = usehandler
                                        Set usehandler = Nothing
                                        End If
                                        If MyIsObject(r) Then r = 0#
                                        
                                        Exit Function
                                    ElseIf Typename(bstack.lastobj) = myArray Then
                                        Set usehandler = New mHandler
                                        usehandler.T1 = 3
                                        Set usehandler.objref = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        IsNumberNew = fMatrix(bstack, A$, usehandler, r)
                                        If Left$(A$, 1) = "." And Not bstack.lastobj Is Nothing Then
                                            If TypeOf bstack.lastobj Is Group Then GoTo cont100203030
                                        End If
                                        If MyIsObject(r) Then r = 0#
                                        
                                        Exit Function
                                    End If
                                    Exit Function
                                End If
                                SyntaxError
                                IsNumberNew = False
                                Exit Function
                           
                            End If
                        End If
                        Exit Function
                    End If
                    On Error Resume Next
                    
                    If TypeOf ppppL Is mArray Then
                        Set pppp = ppppL
                        If pppp.ItemTypeNum(w2) = vbUserDefinedType Then
                             If FastSymbol(A$, "|") Then
                                w1 = FastPureLabel(A$, s$)
                                r = Empty
                                IsNumberNew = False
                                If w1 > 0 Then
                                    If w1 = 1 Then
                                        r = pppp.GetUDTValue(w2, s$)
                                    ElseIf w1 = 5 Then
                                    If IsExp(bstack, A$, p, , True) Then
                                        If FastSymbol(A$, ")") Then
                                            r = pppp.GetUDTValue(w2, s$, p)
                                            End If
                                        End If
                                    End If

                                If MemInt(VarPtr(r)) = vbEmpty Then
                                    If LastErNum = 0 Then BadUDTName
                                    Exit Function
                                End If
                                Else
                                    SyntaxError
                                End If
                            Else
                                r = pppp.itemnumeric(w2)
                            End If
                            
                        Else
                            r = pppp.itemnumeric(w2)
                        End If
                        If MyIsObject(r) Then
                            Set bstack.lastobj = r
                            Set r = Nothing
                            r = 0
                        End If
                        If Err Then r = 0: Err.Clear
                        On Error GoTo 0
                        
                    Else
                        r = 0
                    End If
                    IsNumberNew = True
                Else
contrightpar:
                    If Typename(ppppL.GroupRef) = mHdlr Then
                        Set usehandler = ppppL.GroupRef
                        If IsExp(bstack, A$, p, flatobject:=True) Then
                            If usehandler.T1 = 2 Then ' OK for Buffer
                                If MemInt(VarPtr(p)) = vbString Then
                                ' no good goto this
                                GoTo syntax1
                                End If
                                With usehandler.objref
                                If FastSymbol(A$, "!") Then
                                  
                                        r = .GetBytePtr(p)
                                 
                                Else
                                    If FastSymbol(A$, ",") Then
                                        If IsStrExp(bstack, A$, s$) Then
                                        
                                        ElseIf FastPureLabel(A$, s$, , True) <> 1 Then
syntax1:
                                            SyntaxError
                                            Exit Function
                                        End If
                                        If .structref.Find(s$) Then
                                            If FastSymbol(A$, ",") Then
                                                If IsExp(bstack, A$, r) Then
                                                    r = .GetPtr(p) + .structref.Value + r
                                                Else
                                                    GoTo syntax1
                                                End If
                                            Else
                                                r = .GetPtr(p) + .structref.Value
                                            End If
                                            If FastSymbol(A$, "!") Then
                                            
                                                    r = r - .GetPtr(0)
                                                
                                            Else
                                                
                                            End If
                                        Else
                                            GoTo syntax1
                                        End If
                                    Else
                                        r = .GetPtr(p)
                                        
                                    End If
                                End If
                                If .status = 4 Then MyErMacro A$, "Buffer locked, wrong use of pointer", "г дИэЯХЯЫСГ ЙКЕИДЧХГЙЕ, ЙАЙч ВЯчСГ ДЕъЙТГ"
                                IsNumberNew = FastSymbol(A$, ")") And .status = 0
                            End With
                            Exit Function
                        ElseIf usehandler.T1 = 3 Then
                            Set bstack.lastobj = Nothing
                            Set anything = usehandler
                            If CheckLastHandler(anything) Then
                                Set usehandler = anything
                                If TypeOf usehandler.objref Is mArray Then
                                    Set pppp = usehandler.objref
                                    Set ppppL = pppp
                                    Set usehandler = Nothing
                                    w2 = CLng(p)
                                    If pppp.count > w2 And w2 >= 0 Then
                                        pppp.Index = w2
                                        If MyIsObject(pppp.Value) Then
                                            FastSymbol A$, ")"
                                            GoTo contAr22
                                        Else
                                            r = pppp.itemnumeric(w2)
                                            GoTo finishnum
                                        End If
                                    Else
                                        indexout A$
                                    End If
                                Else
                                    SyntaxError
                                End If
                                Set usehandler = Nothing
                            Else
                                MyEr "???", "???"
                            End If
                            Exit Function
                        End If
                        Set bstack.lastobj = Nothing
                        If VarType(p) = vbBoolean Then p = CLng(p)
                        If Not FastSymbol(A$, "!") Then
                          If CheckInt64(p) Then
                                s$ = CStr(p)
                            ElseIf VarType(p) = vbString Then
                                s$ = LTrim$(p)
                            Else
                               s$ = LTrim$(str(p))
                            End If
                         GoTo contlabel
                        End If
                        If TypeOf usehandler.objref Is mHandler Then
                            Set usehandler = usehandler.objref
                            If usehandler.indirect = -1 Then
                                Set anything = usehandler.objref
                                Set usehandler = New mHandler
                                Set pppp.GroupRef = usehandler
                                Set usehandler.objref = anything
                                Set anything = Nothing
                                Set bstack.lastobj = Nothing
                            End If
                        End If
                        With usehandler.objref
                            p = MyRound(p)
                            If Abs(p) < .count Then
                                If p < 0 Then
                                    .Index = .count + MyRound(p)
                                Else
                                    .Index = MyRound(p)
                                End If
                                .Done = True
                                '' what??? here here here
                                IsNumberNew = FastSymbol(A$, ")")
                                If Left$(A$, 1) = "." Then
                                    If Fast2NoSpace(A$, ".аниа", 5, ".VALUE", 6, 6) Then
                                        w2 = -100
                                    Else
                                        w2 = -MyRound(p) - 100
                                    End If
                                    GoTo contgroup
                                ElseIf FastSymbol(A$, "(") Then
                                    If .IsObj Then
                                        If TypeOf .ValueObj Is mHandler Then
                                            Set pppp.GroupRef = .ValueObj
                                            w3 = 0
                                            GoTo contAr2
                                        ElseIf TypeOf .ValueObj Is Group Then
                                            Set pppp.GroupRef = .ValueObj
                                            w2 = -2
                                            GoTo contgroup
                                        End If
                                        w2 = -.Index - 100
                                        If TypeOf .ValueObj Is lambda Then GoTo contlambdahere
                                        If TypeOf .ValueObj Is mArray Then
                                            Set pppp = .ValueObj
                                            Set ppppL = pppp
                                            w3 = 0
                                            GoTo contAr2
                                        End If
                                    Else
                                        MissObject A$
                                    End If
                                End If
                                If Not .IsObj Then
                                    If .ValueType(0, r, s$) Then
                                        
                                    Else
                                        r = 0
                                    End If
                                Else
                                    Set bstack.lastobj = usehandler.objref.ValueObj
                                    r = 0
                                End If
                                Exit Function
                            Else
                                indexout A$
                            End If
                        End With
                        Exit Function
                    ElseIf IsStrExp(bstack, A$, s$) Then
                        w3 = 0
contlabel:
                        Set usehandler = ppppL.GroupRef
                        If usehandler.T1 = 1 Then
                            If Typename(usehandler.objref) <> "FastCollection" Then
                                If usehandler.indirect = -1 Then
                                    Set usehandler = usehandler.objref
                                    Set useFast = usehandler.objref
                                    Set usehandler = pppp.GroupRef
                                    Set usehandler.objref = useFast
                                Else
                                    GoTo inv100
                                End If
                            Else
                                Set useFast = usehandler.objref
                            End If
                        Else
inv100:                                 Expected "Inventory", "йАТэСТАСГ"
                            Exit Function
                        End If
                        With useFast
                            If .structLen > 0 Then s$ = myUcase(s$)
                            If .Find(s$) Then
                                IsNumberNew = FastSymbol(A$, ")")
                                If Left$(A$, 1) = "." Then
                                    w2 = -.Index - 100
                                    GoTo contgroup
                                ElseIf Left$(A$, 1) = "(" Then
                                    Mid$(A$, 1, 1) = " "
                                    If .IsObj Then
                                        w2 = -.Index - 100
                                        If TypeOf .ValueObj Is lambda Then GoTo contlambdahere2
                                        If TypeOf .ValueObj Is mArray Then
                                            Set ppppL = .ValueObj
                                            w3 = 0
                                            GoTo contAr2
                                        ElseIf TypeOf .ValueObj Is mHandler Then
                                            Set usehandler = .ValueObj
                                            If usehandler.T1 = 3 Then
                                                Set ppppL = usehandler.objref
                                            Else
                                                Set ppppL.GroupRef = usehandler
                                            End If
                                            w3 = 0
                                            GoTo contAr2
                                        End If
                                    Else
                                        MissObject A$
                                    End If
                                End If
                                If Not .IsObj Then
                                    r = s$
                                    
                                    If Not .ValueType(0, r, s$) Then
                                        r = 0
                                    End If
                                Else
                                    If Typename(.ValueObj) = mGroup Then
                                        Set userGroup = .ValueObj
                                        If userGroup.HasValue Then
                                            w2 = -.Index - 100
                                            GoTo contgroup
                                        Else
                                            r = 0
                                            Set bstack.lastobj = userGroup
                                            Exit Function
                                        End If
                                    Else
                                        r = rValue(bstack, .ValueObj)
                                        If FastSymbol(A$, "#") Then
                                            If Not bstack.lastobj Is Nothing Then
                                                If Typename(bstack.lastobj) = mHdlr Then
                                                    Set usehandler = bstack.lastobj
                                                    Set bstack.lastobj = Nothing
                                                    IsNumberNew = fMatrix(bstack, A$, usehandler, r)
                                                    If MyIsObject(r) Then r = 0#
                                                    
                                                    Exit Function
                                                End If
                                            End If
                                            SyntaxError
                                            IsNumberNew = False
                                            Exit Function
                                        End If
                                    End If
                                End If
                                Exit Function
                            Else
                               indexout A$
                            End If
                        End With
                    Exit Function
                    End If
                ElseIf Typename(ppppL.GroupRef) = mGroup Then
conthere102030:
                    Set userGroup = ppppL.GroupRef
                    If Len(v$) > Len(userGroup.GroupName) Then
                    If Len(ppppL.CodeName) = 0 Then
                        s1$ = Left$(v$, Len(v$) - 1) + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                        Else
                        s1$ = ppppL.CodeName + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                        End If
                    Else
                        s1$ = userGroup.GroupName + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                    End If
                    If GetSub(s1$, V1&) Then
                        Set nbstack = New basetask
                        Set nbstack.Parent = bstack
                        If bstack.IamThread Then Set nbstack.Process = bstack.Process
                        Set nbstack.Owner = bstack.Owner
                        nbstack.OriginalCode = V1&
                        nbstack.UseGroupname = sbf(V1&).sbgroup
                        nbstack.tpointer = sbf(V1&).tpointer
                        nbstack.SetV
                        If GoFunc(nbstack, s1$, A$, p) Then
                            If Not nbstack.StaticCollection Is Nothing Then
                                bstack.Parent.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                            End If
                            IsNumberNew = True
                            If IsOperator(A$, "(") Then
contgrouppar:
                                Set ppppL = New ppppLight
                                If Typename(bstack.lastobj) = mGroup Then
                                    If bstack.lastobj.IamApointer Then
                                        Set ppppL.GroupRef = bstack.lastobj.link
                                    Else
                                        Set ppppL.GroupRef = bstack.lastobj
                                    End If
                                    Set bstack.lastpointer = Nothing
                                    Set bstack.lastobj = Nothing
                                Else
                                    Set ppppL.GroupRef = bstack.lastobj
                                End If
                                ppppL.Arr = False
                                w2 = -2
                                Set nbstack = Nothing
                                v$ = vbNullString
                                GoTo contrightpar
                            ElseIf Left$(A$, 1) = "." Then
                                Set ppppL = New ppppLight
                                If bstack.lastobj.IamApointer Then
                                    Set ppppL.GroupRef = bstack.lastobj.link
                                Else
                                    Set ppppL.GroupRef = bstack.lastobj
                                End If
                                Set bstack.lastobj = Nothing
                                Set bstack.lastpointer = Nothing
                                ppppL.Arr = False
                                w2 = -2
                                Set nbstack = Nothing
                                v$ = vbNullString
                                GoTo contgroup
                            ElseIf Left$(A$, 1) = "|" Then
            
                                GoTo contUDT1
                            ElseIf FastSymbol(A$, "#") Then
                                Set nbstack = Nothing
                                GoTo comehere
                            End If
                            Set nbstack = Nothing
                            r = p
                            
                            IsNumberNew = True
                        Else
                            
                            IsNumberNew = False
                        End If
                    Else
                        If VarTypeName(var(VR)) = mGroup Then
                            Set userGroup = var(VR)
                            If userGroup.HasStrValue Then
                                r = 0
                                Set bstack.lastobj = CopyGroupObj(var(VR))
                            Else
                                r = 0
                                InternalError
                                IsNumberNew = False
                            End If
                        Else
                            r = 0
                            InternalError
                            IsNumberNew = False
                        End If
                    End If
                    Exit Function
                Else
contreadprop:
                    If TypeOf ppppL.GroupRef Is PropReference Then
contreadprop2:
                        Set useProp = ppppL.GroupRef
                        If getindexes(bstack, useProp, A$) Then
                            Set bstack.lastobj = ppppL
                        Else
                            r = useProp.Value
                            Set bstack.lastobj = useProp.lastobjfinal
                        End If
                        If Not bstack.lastobj Is Nothing Then r = 0
                        GoTo finishnum
                    End If
                                        
                End If
                If TypeOf ppppL.GroupRef Is mHandler Then
                    MyEr "Not for this kind of object", "╪ВИ ЦИА АУТЭ ТО АМТИЙЕъЛЕМО"
                    r = 0
                    Exit Function
                Else
                    Set useProp = ppppL.GroupRef
                    r = useProp.Value
                    Set bstack.lastobj = useProp.lastobj
                    
                    
                    If Not MyIsNumeric(r) Then
                        If VarType(r) = 8 Then
                            If Len(r) = 0 Then r = 0 Else r = val(r)
                        Else
                            r = 0#
                        End If
                    End If
finishnum:
                    
                End If
                IsNumberNew = FastSymbol(A$, ")")
               
                If FastSymbol(A$, "#") Then GoTo comehere
                
                
               
                End If
                Exit Function
            Else
skiperror:
            IsNumberNew = False
            If FindNameForGroup(bstack, v$) Then
                UnknownMethod1 A$, v$
            Else
                If Len(v$) > 5 Then
                    If Left$(v$, 5) = "THIS." Or Left$(v$, 5) = "ауто." Then
                        v$ = Mid$(v$, 5)
                        V1& = IsLabel(bstack, (v$), v$)
                        s1$ = vbNullString
                        If v$ <> "" Then IsNumberNew = True: GoTo contthis1
                    End If
                End If
                UnknownFunction1 A$, v$
            End If
            Exit Function
        End If
Case 105
isasub:
    If CurrentStackSize > stacksize Then
        MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
        MOUT = True
        IsNumberNew = False: Exit Function
    End If
    w1 = bstack.soros.Total
    If Not PushParamSUB(bstack, A$) Then
    w1 = bstack.soros.Total - w1
    If w1 > 0 Then bstack.soros.drop w1
    IsNumberNew = False:  Exit Function
    End If
    If FastSymbol(A$, ")") Then
        PushStage bstack, False
        V1& = bstack.OriginalCode
        v$ = bstack.originalname$
        bstack.originalname$ = s1$
        If gr Then
            s1$ = "сумаятгсг " + s1$
        Else
            s1$ = "FUNCTION " + s1$
        End If
        If searchsub(V1&, s1$, w1, V1&, n$, True) Then
againsub:
            If Len(s1$) > 0 Then
                If Not MyRead(7, bstack, s1$, 1) Then
                    bstack.originalname$ = v$
                    PopStage bstack
                    IsNumberNew = False
                    Exit Function
                End If
            End If
            bstack.FuncValue = r
            Set bstack.FuncObj = Nothing
            dn = bstack.addlen
            bstack.RetStack.PushVal CDec(0)
            
            If trace Then
            s1$ = TestShowSub: sg1 = TestShowBypass
            If V1& > 0 Then
                bstack.addlen = Len(sbf(V1&).sb) - w1 - Len(n$) + 1
                TestShowSub = sbf(V1&).sb
            ElseIf V1& = 0 Then
                bstack.addlen = 0
                TestShowSub = n$
            Else
                bstack.addlen = Len(var(-V1&).code) - w1 - Len(n$) + 1
                TestShowSub = var(-V1&).code
            End If
            w1 = w1 + Len(n$)
            TestShowBypass = True
            dd = 1
            executeblock dd, bstack, n$, False, True, , True
            SwapStrings s1$, TestShowSub: TestShowBypass = sg1
            Else
             w1 = w1 + Len(n$)
            dd = 1
            executeblock dd, bstack, n$, False, True, , True
            End If
            bstack.RetStackDrop 1
            bstack.addlen = dn
            If dd > 0 Then
                IsNumberNew = True
                Set bstack.lastobj = bstack.FuncObj
                Set bstack.FuncObj = Nothing
                r = bstack.FuncValue
                bstack.FuncValue = Empty
                If Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is mHandler Then
                            If FastSymbol(A$, "#") Then
                                GoTo comehere
                            End If
                        ElseIf TypeOf bstack.lastobj Is Group Then
                            Set userGroup = bstack.lastobj
                            If Left$(A$, 2) = "=>" Then
                                If userGroup.IamApointer Then
                                    Mid$(A$, 1, 2) = "." + Chr(3) 'Chr$(7) + "."
                                Else
                                    Mid$(A$, 1, 2) = Chr$(7) + "."
                                End If
                                GoTo again1001
                            ElseIf Left$(A$, 1) = "#" Then
                                If Not (userGroup.HasValue And Not userGroup.HasParameters) Then
                                    Mid$(A$, 1, 1) = "."
                                End If
                                GoTo again1001
                            End If
                        ElseIf TypeOf bstack.lastobj Is mArray Then
                            If FastSymbol(A$, "#") Then
                                GoTo comehere
                            End If
                        ElseIf Left$(A$, 1) = "#" Then
                            If Len(A$) > 0 Then
                            Mid$(A$, 1, 1) = Chr$(1)
                            End If
                            GoTo comehere
                        End If
                        If Left$(A$, 1) = "(" Then
                        If TypeOf bstack.lastobj Is lambda Then
                         FastSymbol A$, "("
                            If Not CallLambdaASAP(bstack, A$, r) Then IsNumberNew = False: Exit Function
                        End If
                        End If
                       ' ElseIf TypeOf bstack.lastobj Is refArray Then
                        
                        'Else  ' why this ???
                        '    If Len(a$) > 0 Then
                        '    Mid$(a$, 1, 1) = Chr$(1)
                        '    End If
                        '    GoTo comehere
                        'End If
                End If
            Else
            IsNumberNew = False
            If bstack.ErrorOriginal = 0 Then
            LastErNum = -1
            LastErNum1 = -1
            bstack.ErrorOriginal = V1&
            If V1& > 0 Then
                A$ = n$ + space$(Len(sbf(V1&).sb) - w1 + 1)
            ElseIf V1& = 0 Then
                A$ = n$
            Else
                A$ = n$ + space$(Len(var(-V1&).code) - w1 + 1)
            End If
            End If
            
            Exit Function
            End If
        ElseIf bstack.IamChild Then
            w3 = FindPrevOriginal(bstack)
            If searchsub(w3, s1$, w1, V1&, n$, True) Then
                If w3 <> V1& And V1& < 0 Then
                    V1& = w3
                End If
                GoTo againsub
            Else
                GoTo nofun1
            End If
        Else
nofun1:
            MyEr "Function @" + Mid$(s1$, InStr(s1$, " ") + 1) + ") not found", "г СУМэЯТГСГ @" + Mid$(s1$, InStr(s1$, " ") + 1) + ") ДЕМ БЯщХГЙЕ"
            IsNumberNew = False
        End If
        bstack.originalname$ = v$
        PopStage bstack
    Else
        IsNumberNew = False
    End If
    Exit Function
End Select

'' THESE THREE STATEMENDS NOT USED ANY MORE
    IsNumberNew = False
    A$ = v$ + A$
    Exit Function
''End Select
zerohere:

End Function
Function ValidNumberOnlyMatrix(A$, r As Variant, skipdec As Boolean) As Boolean
r = Empty
Dim I As Long
If Not IsNumberOnly(A$, 1, r, I, , True) Then
    If Fast3NoSpace(A$, "акгхес", 6, "акгхгс", 6, "TRUE", 4, 6) Then
    I = MyTrimL(A$)
    r = CBool(True)
    ValidNumberOnlyMatrix = I > Len(A$)
    ElseIf Fast3NoSpace(A$, "ьеудес", 6, "ьеудгс", 6, "FALSE", 5, 6) Then
    r = CBool(False)
    ValidNumberOnlyMatrix = I > Len(A$)
    Else
    r = 0
   End If
Else
ValidNumberOnlyMatrix = I > Len(A$)
End If
End Function
Private Sub MyDoEventsNoThread()
On Error GoTo there
If TaskMaster Is Nothing Then
    DoEvents
    Exit Sub
ElseIf Not TaskMaster.Processing And TaskMaster.QueueCount = 0 Then
    DoEvents
    Exit Sub
Else
    If TaskMaster.PlayMusic Then
        TaskMaster.OnlyMusic = True
        TaskMaster.TimerTick
        TaskMaster.OnlyMusic = False
    End If
    TaskMaster.StopProcess
    DoEvents
    TaskMaster.StartProcess
End If
Exit Sub
there:
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd1
End Sub
Function ProcLambda(bstack As basetask, rest$, Lang As Long) As Object
' no named functio- object
Dim Body As New lambda, K As Long, n$, dummy As Variant, er As Boolean, pos1 As Long, p As Variant, s$
Dim pppp As mArray, pppp2 As mArray, frm$, Find As basetask, rest1$
Dim ppppL As iBoxArray, Ar As refArray
' need fixed param...with &
again1:
ClearStr rest$
Do While MaybeIsSymbol(rest$, "/\'"): SetNextLine rest$: ClearStr rest$: Loop
If Not FastSymbol(rest$, "->", , 2) Then
' put here description for error
If er Then Exit Function
Do
    If Len(rest$) < 129 Then
        K = IsPureLabel(rest$, n$)
    Else
        rest1$ = Left$(rest$, 128)
        K = IsPureLabel(rest1$, n$)
        If Len(rest1$) = 0 Then
            K = IsPureLabel(rest$, n$)
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
    If K = 0 Then
        If frm$ <> "" Then Exit Function
        If FastSymbol(rest$, "(") Then
            er = True
            frm$ = BlockParam(rest$)
            If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
            FastSymbol rest$, ")"
            frm$ = Trim$(frm$)
            GoTo again1
        Else
            MyEr "Symbol -> for Lambda needed", "вЯЕИэФЕТАИ ТО СЩЛБОКО -> ЦИА ТГМ КэЛДА СУМэЯТГСГ"
            Exit Function
        End If
    End If
    If K > 4 Then If Not FastSymbol(rest$, ")") Then Exit Function
    n$ = myUcase(n$, True)
    If FastSymbol(rest$, "=") Then
        Select Case K
        Case 1
            If IsExp(bstack, rest$, p) Then
                If Not bstack.lastobj Is Nothing Then
                    Set dummy = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    
                    Body.FeedNonLocal n$, dummy, False, var()
                    Set dummy = Nothing
                Else
                    dummy = p
                    Body.FeedNonLocal n$, dummy, False, var()
                End If
                dummy = Empty
            ElseIf IsStrExp(bstack, rest$, s$, False) Then
                dummy = s$
                Body.FeedNonLocal n$, dummy, False, var()
                dummy = Empty
            End If
        Case 4
            If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
                dummy = MyRound(p)
                Body.FeedNonLocal n$, dummy, False, var()
                dummy = Empty
            End If
        Case 3
            If IsStrExp(bstack, rest$, s$, False) Then
                If Not bstack.lastobj Is Nothing Then
                    Set dummy = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    Body.FeedNonLocal n$, dummy, False, var()
                    Set dummy = Nothing
                Else
                    dummy = s$
                    Body.FeedNonLocal n$, dummy, False, var()
                End If
                dummy = Empty
            End If
        Case 5, 7
            If IsExp(bstack, rest$, p) Then
                If Not bstack.lastobj Is Nothing Then
                    If Typename(bstack.lastobj) = myArray Then
                        Set pppp = bstack.lastobj
                        pppp.arrname = n$
                        Set dummy = pppp
                        Body.FeedNonLocal n$, dummy, False, var()
                        Set dummy = Nothing
                        Set pppp = Nothing
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
            Else
                Exit Function
            End If
        Case 6
            If IsStrExp(bstack, rest$, s$) Then
                If Not bstack.lastobj Is Nothing Then
                    If Typename(bstack.lastobj) = myArray Then
                        Set pppp = bstack.lastobj
                        pppp.arrname = n$
                        Set dummy = pppp
                        Body.FeedNonLocal n$, dummy, False, var()
                        Set dummy = Nothing
                        Set pppp = Nothing
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
            Else
                Exit Function
            End If
        Case 8
        GoTo ER122
        End Select
    ElseIf K < 5 Then
    Dim novariant As Boolean
        If GetVar(bstack, n$, pos1, , , True, , novariant) Then
            If VarTypeName(var(pos1)) = "lambda" Then
                Dim aaa As lambda
                var(pos1).CopyTo aaa, var()
                Set dummy = aaa
                Body.FeedNonLocal n$, dummy, Not novariant, var()
                Set dummy = Nothing
                dummy = Empty
                Set aaa = Nothing
            ElseIf VarTypeName(var(pos1)) = mGroup Then
                Set dummy = CopyGroupObj(var(pos1))
                Body.FeedNonLocal n$, dummy, Not novariant, var()
                Set bstack.lastobj = dummy  ' why
                Set dummy = Nothing
            ElseIf VarTypeName(var(pos1)) = "RefArray" Then
                Set Ar = var(pos1)
                Set dummy = Ar.Copy()
                Body.FeedNonLocal n$, dummy, Not novariant, var()
                Set bstack.lastobj = dummy
                Set dummy = Nothing
            Else
                Body.FeedNonLocal n$, var(pos1), Not novariant, var()
            End If
        Else
            If Right$(n$, 1) = "$" Then
                skiperror = True
                If Not IsStr1(bstack, (n$), s$) Then
                    MyEr "", ""
                    dummy = vbNullString
                Else
                    dummy = s$
                End If
                skiperror = False
            Else
                skiperror = True
                If Not IsNumberNew(bstack, (n$), dummy, True) Then
                    dummy = Empty
                End If
                skiperror = False
            End If
            Body.FeedNonLocal n$, dummy, False, var()
            dummy = Empty
        End If
    ElseIf K < 8 Then
        If neoGetArray(bstack, n$, ppppL) Then
            If TypeOf ppppL Is mArray Then
                Set pppp = ppppL
                Set pppp2 = New mArray
                pppp.CopyArray pppp2
                Set dummy = pppp2
                Set pppp2 = Nothing
                Set pppp = Nothing
                Body.FeedNonLocal n$, dummy, False, var()
            Else
                MyEr "not an array " + n$, "ДЕМ ЕъМА ПъМАЙАР " + n$
                Exit Function
            End If
        Else
            MyEr "Array not exist", "дЕМ УПэЯВЕИ ПъМАЙАР"
            Exit Function
        End If
    Else
ER122:
        MyEr "Pass array without []", "дЧСЕ ПъМАЙА ВЫЯъР []"
    Exit Function
    End If
If Not FastSymbol(rest$, ",") Then Exit Do
ClearStr rest$
Do While MaybeIsSymbol(rest$, "/\'"): SetNextLine rest$: ClearStr rest$: Loop
Loop
If frm$ <> "" Then Exit Function
ClearStr rest$
Do While MaybeIsSymbol(rest$, "/\'"): SetNextLine rest$: ClearStr rest$: Loop
If FastSymbol(rest$, "(") Then
    frm$ = BlockParam(rest$)
    If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
        If Not FastSymbol(rest$, ")", True) Then
            frm$ = Trim$(frm$)
            GoTo again1
        End If
    End If
    er = True
    GoTo again1
ElseIf FastSymbol(rest$, "{") Then
' get block
getfunc:
    If frm$ <> "" Then
        If Lang = 1 Then
            frm$ = "Read " + frm$ + vbCrLf
        Else
            frm$ = "дИэБАСЕ " + frm$ + vbCrLf
        End If
        Body.code = frm$ + vbCrLf + block(rest$)
    Else
        Body.code = block(rest$)
    End If
    If Trim$(Body.code) = vbNullString Then Exit Function
    If Not FastSymbol(rest$, "}") Then Exit Function
    K = Len(rest$)
Else
GetLine:
' get one line only
    pos1 = 1
    Body.code = aheadstatus(rest$, False, pos1)
    If pos1 = 1 Then Exit Function
    If frm$ <> "" Then
        If Lang = 1 Then
            frm$ = "Read " + frm$ + vbCrLf
        Else
            frm$ = "дИэБАСЕ " + frm$ + vbCrLf
        End If
        Body.code = frm$ + ": =" + Left$(rest$, pos1 - 1)
    Else
        Body.code = "=" + Left$(rest$, pos1 - 1)
    End If
    K = Len(rest$)
    rest$ = Mid$(rest$, pos1)
End If
If bstack.OriginalCode < 0 Then
    Set Find = bstack
    Do While Find.IamChild
        If Find.OriginalCode > -1 Then Exit Do
        If TypeOf var(-Find.OriginalCode) Is Constant Then
            Set p = var(-Find.OriginalCode).Value
            K = K + p.lastlen
            Body.OriginalCode = p.OriginalCode
        Else
            K = K + var(-Find.OriginalCode).lastlen
            Body.OriginalCode = var(-Find.OriginalCode).OriginalCode
        End If
        Set Find = Find.Parent
    Loop
    Body.lastlen = K
Else
    If Not bstack.Parent Is Nothing Then
    ' Left$(sbf(bstack.OriginalCode).sb, 10) = "'11001EDIT"
    Set Find = bstack
    
    While Not Find Is Nothing
    If Find.OriginalCode < 0 Then
        If TypeOf var(-Find.OriginalCode) Is Constant Then
            Set p = var(-Find.OriginalCode).Value
            K = K + p.lastlen
            Body.OriginalCode = p.OriginalCode
        Else
            K = K + var(-Find.OriginalCode).lastlen
            Body.OriginalCode = var(-Find.OriginalCode).OriginalCode
        End If
        Set Find = Find.Parent
    ElseIf Left$(sbf(Find.OriginalCode).sb, 10) = "'11001EDIT" Then
        frm$ = Mid$(sbf(Find.OriginalCode).sb, 1, InStr(sbf(Find.OriginalCode).sb, vbCr))
        K = K - val(Mid$(frm$, InStr(frm$, ",") + 1))
        Body.OriginalCode = iRVAL(Find.originalname, 0)
        Set Find = Find.Parent
    Else
    Body.OriginalCode = iRVAL(Find.originalname, 0)
    Set Find = Nothing
    End If
    Wend
    If Body.OriginalCode = 0 Then Body.OriginalCode = bstack.OriginalCode
    Body.lastlen = K
    Else
    If Left$(sbf(bstack.OriginalCode).sb, 10) = "'11001EDIT" Then
        frm$ = Mid$(sbf(bstack.OriginalCode).sb, 1, InStr(sbf(bstack.OriginalCode).sb, vbCr))
        K = K - val(Mid$(frm$, InStr(frm$, ",") + 1))
        Body.OriginalCode = iRVAL(bstack.originalname, 0)
        If Body.OriginalCode = 0 Then
        IsLabelOnly Mid$(frm$, 11), frm$
         If subHash.Find(frm$, pos1) Then
         Body.OriginalCode = pos1
         End If
        End If
    Else
    Body.OriginalCode = bstack.OriginalCode
    End If
    Body.lastlen = K
    End If
    
End If
Set ProcLambda = Body
End Function
Function IsLabelBig(bstack As basetask, A$, rrr$, Optional nocommand As Boolean, Optional r$, Optional noconvert As Boolean = False, Optional StrPointer As Boolean, Optional iscommand As Boolean, Optional fixlen As Boolean, Optional gr As Boolean) As Long
    Dim rr&, one As Boolean, br As Integer, c$, dot&, skipcase As Boolean, cc As Long, isstrparam As Boolean, ascwc As Integer
    Dim I As Long
    Dim p, s$
    Dim P1, s1$
    Dim pppp As mArray, a1$, w2 As Long
    r$ = vbNullString
    gr = False
    If A$ = vbNullString Then IsLabelBig = 0: Exit Function  'ok
    A$ = NLtrim$(A$)
    
    If Left$(A$, 1) = "&" Then
      '  a$ = Mid$(a$, 2)
                 If Len(r$) > 0 Then
                        'ERROR
                    rr& = 0
                    '' r$ = VbNullString
                    rrr$ = vbNullString
                    Exit Function
                Else
                    nocommand = True
                    If noconvert Then
                        IsLabelBig = 0
                        Exit Function
                    Else
                        A$ = Mid$(A$, 2)
                        varhash.flat
                        rr& = Abs(IsLabelBig(bstack, A$, r$, , c$))
                        If rr& < 5 And varhash.lastNDX > 0 Then
                            I = varhash.lastNDX
usethat:
                            r$ = varhash.lastkey
                            If MyIsObject(var(I)) Then
                                If var(I) Is Nothing Then
                                ElseIf TypeOf var(I) Is Group Then
                                    If Len(var(I).LastOpen) > 0 Then
                                        c$ = var(I).LastOpen
                                        If GetlocalVar(c$, I) Then
                                            If IsBadCodePtr(var(I).PointerPtr) = 0 Then
                                                c$ = r$
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                            rrr$ = r$
                            IsLabelBig = -50
                            Exit Function
                        End If
                    End If
                    skipcase = True
                    If rr& < 5 Then
                        c$ = myUcase(c$, True)
again2134:
                        If GetlocalVar(r$, I) Then
bypass1:
                            If MyIsObject(var(I)) Then
                                If var(I) Is Nothing Then
                                ElseIf TypeOf var(I) Is Group Then
                                    If Len(var(I).LastOpen) > 0 Then
                                        c$ = var(I).LastOpen
                                        If GetlocalVar(c$, I) Then
                                            If IsBadCodePtr(var(I).PointerPtr) = 0 Then
                                                c$ = r$
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                            rrr$ = here$ + "." + r$
                            IsLabelBig = -50
                            Exit Function
                        ElseIf bstack.ExistVar2(c$) Then
                            r$ = c$
                            If Not bstack.modfuncall Then
abnormal_exit:
                                MyEr "only for module or function call", "ЛЭМО СЕ ЙКчСГ ЦИА ТЛчЛА ч СУМэЯТГСГ"
                                IsLabelBig = 0
                            Exit Function
                        End If
                        c$ = "_" + str$(var2used)
                        If rr& = 6 Then
                            If Not IsStr1(bstack, (r$), s$) Then GoTo cont123
                            If bstack.lastobj Is Nothing Then
                                rr& = globalvarGroup(c$, s$)
                            Else
                                Set p = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                rr& = globalvarGroup(c$, p)
                            End If
                        Else
                            If Not IsNumber(bstack, (r$), p) Then
                                GoTo cont123
                            End If
                            If bstack.lastobj Is Nothing Then
                                rr& = globalvarGroup(c$, p, useType:=Not varhash.Index < 0)
                            Else
                                Set p = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                rr& = globalvarGroup(c$, p)
                            End If
                        End If
                        ' to tempcopy
                        FeedCopyInOut bstack, r$, rr&, ""  ' parent
                        If here$ <> "" Then r$ = here$ + "." + c$ Else r$ = c$
                        rr& = 2
                        GoTo skiploop
                    ElseIf Left$(r$, 5) = "ауто." Or Left$(r$, 5) = "THIS." Then
                        If Len(bstack.UseGroupname) > 0 Then
                            c$ = bstack.UseGroupname + Mid$(r$, 6)
                        Else
                            c$ = StripThis2(here$)
                            If c$ <> "" Then c$ = c$ + "." + Mid$(r$, 6) Else c$ = here$ + "." + r$
                        End If
                        rrr$ = c$
                        IsLabelBig = -50
                        Exit Function
                    ElseIf varhash.Find(r$, cc) Then
                        rrr$ = r$
                        IsLabelBig = -50
                        Exit Function
                    Else
                        If r$ = "THIS" Or r$ = "ауто" Then
                            rrr$ = r$
                            IsLabelBig = -100
                            Exit Function
                        Else
                            c$ = ChrW(-65) + myUcase(c$, True)
                            If varhash.Find2(bstack.UseGroupname + c$, I) Then
                                GoTo usethat
                            End If
                            If GetSub(r$ + ")", rr&) Then
                                r$ = "{" + sbf(rr&).sb + "} " + sbf(rr&).sbgroup
                                rr& = 2
                                GoTo skiploop
                            Else
                                If Not bstack.NoError Then
                                    If r$ <> "" Then
                                        MyErMacro A$, "can't pass reference to " + r$, "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ СТО " + r$
                                    End If
                                    SyntaxError
                                End If
                                GoTo skiploop
                            End If
                        End If
                    End If
                Else
                    If FastSymbol(A$, ")") Then
                        rr& = 0
                        If Left$(r$, 5) = "ауто." Or Left$(r$, 5) = "THIS." Then
                            If varhash.ExistKey(bstack.UseGroupname + Mid$(r$, 6)) Then
                                rrr$ = bstack.UseGroupname + Mid$(r$, 6, Len(r$) - 5)
                                IsLabelBig = -50
                                Exit Function
                            Else
                                If varhash.ExistKey(bstack.UseGroupname + ChrW(-65) + Mid$(r$, 6)) Then
                                    rrr$ = bstack.UseGroupname + ChrW(-65) + Mid$(r$, 6, Len(r$) - 5)
                                    IsLabelBig = -50
                                    Exit Function
                                End If
                                rr& = 2
                            End If
                        ElseIf varhash.ExistKey(here$ + "." + r$) Then
                            rrr$ = here$ + "." + r$
                            IsLabelBig = -50
                            Exit Function
                        ElseIf varhash.ExistKey(r$) Then
                            rrr$ = r$
                            IsLabelBig = -50
                            Exit Function
                        Else
                            rr& = 3
                        End If
                        c$ = vbNullString
                        If rr& > 0 Then
                            If rr& = 2 Then
                                If Len(bstack.UseGroupname) > 0 Then
                                    c$ = bstack.UseGroupname + ChrW(-65) + Mid$(r$, 6)
                                    r$ = bstack.UseGroupname + Mid$(r$, 6)
                                End If
                            End If
checkc:
                            rr& = 1
                            If GetSub(r$ + ")", rr&) Then
                                If sbf(rr&).Extern > 0 Then
                                    r$ = "{CALL EXTERN " & (sbf(rr&).Extern) & "'" & ChrW(&H1FFD) & "}" & sbf(rr&).sbgroup
                                Else
                                    r$ = "{" + sbf(rr&).sb + "}" + sbf(rr&).sbgroup
                                End If
                                rr& = 2
                                GoTo skiploop
                            Else
                                If Len(c$) > 0 Then
                                    r$ = c$
                                    GoTo checkc
                                End If
                                If Not bstack.NoError Then MyErMacro A$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                            End If
                        End If
                        rr& = 0
                        r$ = vbNullString
                    GoTo skiploop
                    Else
                        a1$ = r$
                        If GetOneAsString(bstack, A$, r$, rr&) Then
                            If neoGetArray(bstack, a1$, pppp) Then
                                If Not pppp.Arr Then GoTo cont123
                                c$ = varhash.lastkey
                                If Not NeoGetArrayItem(pppp, bstack, a1$, w2, Mid$(r$, Len(a1$) + 1)) Then GoTo cont123
                                If pppp.ItemType(w2) = mGroup Then
                                    If Len(pppp.item(w2).LastOpen) > 0 Then
                                        r$ = pppp.item(w2).LastOpen
                                        rr& = 2
                                        GoTo skiploop
                                    End If
                                End If
                                r$ = Funcweak(bstack, c$ + Mid$(r$, Len(a1$) + 1))
                                a1$ = c$
                                If Not bstack.modfuncall Then GoTo abnormal_exit
                                c$ = "_" + str$(var2used)
                                If pppp.MyIsObject(pppp.item(w2)) Then
                                    If pppp.ItemType(w2) = mGroup Then
                                        If pppp.item(w2).IamApointer Then
                                            If pppp.item(w2).LastOpen <> vbNullString Then
                                                rr& = 1
                                                r$ = pppp.item(w2).LastOpen
                                                GoTo again2134
                                            Else
                                                rr& = globalvarGroup(c$, P1)
                                                Set var(rr&) = pppp.item(w2)
                                            End If
                                        Else
                                            r$ = "#" + r$
                                            rr& = 2
                                            GoTo skiploop
                                        End If
                                    Else
                                        rr& = globalvarGroup(c$, P1)
                                        Set var(rr&) = pppp.item(w2)
                                    End If
                                Else
                                    rr& = globalvarGroup(c$, pppp.item(w2))
                                End If
                                FeedCopyInOut bstack, r$, rr&, a1$
                                If here$ <> "" Then r$ = here$ + "." + c$ Else r$ = c$
                                rr& = 2
                                GoTo skiploop
                            End If
                        End If
                    End If
                End If
cont123:
                r$ = vbNullString
                rr& = 0
                GoTo skiploop
            End If
       
    End If
    
    
    Do While Len(A$) > 0
    c$ = Left$(A$, 1) 'ANYCHAR HERE
    ascwc = AscW(c$)
    Select Case ascwc
    
    Case 0 To 9
        Select Case ascwc
        Case 8 '
            If Len(r$) > 0 Then Exit Do
            ' get a name from bstack tempstr
            A$ = bstack.tmpstr + Mid$(A$, 2)
            fixlen = True
            bstack.tmpstr = vbNullString
            nocommand = Left$(A$, 1) <> "@"
        Case 2 To 7
            A$ = Mid$(A$, 2)
        Case 1
            isstrparam = True
            GoTo conthere1
        Case 0 ' for group pointers
conthere1:
            If LenB(r$) = 0 Then
                If Not bstack.lastpointer Is Nothing Then
                    With bstack.lastpointer
                        If .lasthere = vbNullString Then
                            If .GroupName <> "" Then
                                If isstrparam Then
                                    r$ = .GroupName + "$"
                                    rr& = 3
                                Else
                                    r$ = .GroupName
                                    rr& = 1
                                End If
                            Else
                            ' why ?
                               Exit Function
                            End If
                        Else
                            If .GroupName <> "" Then
                                If isstrparam Then
                                    r$ = .lasthere + "." + .GroupName + "$"
                                    rr& = 3
                                Else
                                    r$ = .lasthere + "." + .GroupName
                                    rr& = 1
                                End If
                            Else
                                If isstrparam Then
                                    r$ = .lasthere + "$"
                                    rr& = 3
                                Else
                                    r$ = .lasthere
                                    rr& = 1
                                End If
                            End If
                        End If
                    End With
                    Set bstack.lastpointer = Nothing
                    If Mid$(A$, 2, 1) = "." Then
                        A$ = Mid$(A$, 2)
                    Else
                        If Mid$(A$, 2, 2) = "$'" Then
                            rr& = 3
                            A$ = Mid$(A$, 2)
                        ElseIf Mid$(A$, 2, 1) = "'" Then
                            A$ = Mid$(A$, 2)
                        Else
                            Mid$(A$, 1, 1) = "("  ' parameter for value for pointers for groups using in Eval() and Eval$()
                        End If
                    End If
                    nocommand = True
                Else
                    Mid$(A$, 1, 2) = "=>"
                    Exit Function
                End If
            Else
                A$ = Mid$(A$, 2)
            End If
        Case Else
            Exit Do
        End Select
     'elseIf ascwc < 256 And ascwc > 0 Then
    Case 10 To 256
        Select Case ascwc
        Case 64  '"@"
            If r$ = vbNullString Then
                A$ = Mid$(A$, 2)
                iscommand = True
            ElseIf Mid$(A$, 2, 1) <> "(" And Len(r$) > 0 Then
                r$ = r$ + "."
                A$ = Mid$(A$, 2)
            Else
                IsLabelBig = 0: Exit Function
            End If
        Case 63 '"?"
            If r$ = vbNullString Then
                rrr$ = "?"
                IsLabelBig = 1
                Exit Function
            End If
            A$ = Mid$(A$, 2)    ' why this
        Case 46 '"."
            If one Then
                Exit Do
            ElseIf Len(r$) > 0 Then
                r$ = r$ + Left$(A$, 1)
                A$ = Mid$(A$, 2)
            ElseIf Not Mid$(A$, 2, 1) Like "[0-9]" Then
                If Len(r$) > 0 Then
                    r$ = r$ + Left$(A$, 1)
                    rr& = 1
                Else
                    dot& = dot& + 1
                End If
                A$ = Mid$(A$, 2)
            Else
                If r$ = vbNullString And dot& > 0 Then
                    nocommand = True
                    rrr$ = String$(dot& + 1, ".")     ' i want this only in right position for "dir .. "
                    r$ = rrr$
                    A$ = Mid$(A$, 2)
                    IsLabelBig = 1
                Else
                    IsLabelBig = 0
                End If
                Exit Function
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        Case 48 To 57, 95 '"0" To "9", "_"  ' old ,"\"
            If one Then
                Exit Do
            ElseIf Len(r$) > 0 Then
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
                rr& = 1 'is an identifier or floating point variable
            Else
                If dot& > 0 Then A$ = "." + A$: dot& = 0
                Exit Do
            End If
        Case 91
            A$ = Mid$(A$, 2)
            If Len(r$) > 0 Then
                If Len(r$) = 1 Then
                    If r$ <> "[" Then
                        rr& = 8
                        nocommand = True
                        Exit Do
                    End If
                ElseIf Right$(r$, 1) <> "." Then
                    If Right$(r$, 1) <> ChrW(&HFFBF) Then
                        If Left$(r$, 1) <> "[" Then
                            rr& = 8
                            nocommand = True
                            Exit Do
                        End If
                    End If
                End If
                br = br + 1
                r$ = r$ + "["
            Else
                r$ = "["
                br = 1
                rr& = 1 'is an identifier
            End If
        Case 93
            If Len(r$) = 0 Then Exit Do
            If br > 0 Then
                br = br - 1
                r$ = r$ + "]"
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
                Exit Do
            Else
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
                rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If Len(r$) > 0 Then
                one = True
                rr& = 3 ' is string variable
                r$ = r$ + Left$(A$, 1)
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If Len(r$) > 0 Then
                one = True
                rr& = 4 ' is long variable
                r$ = r$ + Left$(A$, 1)
                nocommand = True
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case 58 '":"
            If one Then Exit Do
            If Mid$(A$, 2, 1) <> "\" Then Exit Do
            If InStr(r$, ":") > 1 Then Exit Do
            r$ = r$ + Left$(A$, 2)
            A$ = Mid$(A$, 3)
        Case 40 ' "("
            If Len(r$) > 0 Then
                If Mid$(A$, 2, 2) = ")@" Then
                 r$ = r$ + "()."
                A$ = Mid$(A$, 4)
                ElseIf Mid$(A$, 2, 2) = ")." Then ' And rr& = 1 Then
                 r$ = r$ + "()."
                 rr& = 0
                 one = False
              A$ = Mid$(A$, 4)
              GoTo CONT1234
                Else
                Select Case rr&
                Case 1
                rr& = 5 ' float array or function
                Case 3
                rr& = 6 'string array or function
                Case 4
                rr& = 7 ' long array
                Case Else
                Exit Do
                End Select
                r$ = r$ + Left$(A$, 1)
                A$ = Mid$(A$, 2)
               Exit Do
            
            End If
           Else
           Exit Do
            End If
        Case Else
        Exit Do
        End Select
    Case Else
        If one Then
            Exit Do
        Else
            gr = True
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
        End If
    End Select
CONT1234:
    Loop
skiploop:
    If skipcase Then
        rrr$ = r$
    Else
      rrr$ = myUcase(r$, gr)
    End If
    If dot& Then
havedot:
        nocommand = True
            If Len(r$) > 0 Then
                rr& = bstack.GetDotNew(rrr$, dot&) * rr&
                nocommand = rr&
            Else
                If dot& > 1 Then
                    rrr$ = String$(dot&, ".") + rrr$: If rr& = 0 Then rr& = 1
                Else
                    '' PUT THE DOT BACK
                    If dot& = 1 Then A$ = "." + A$
                End If
            End If
    ElseIf Len(rrr$) > 5 Then
        If Left$(rrr$, 1) = "а" Then
        If Left$(rrr$, 5) = "ауто." Then
        
        
        
        If Len(bstack.UseGroupname) > 0 Then
        rrr$ = bstack.UseGroupname + Mid$(rrr$, 6)
        Else
        rrr$ = Mid$(rrr$, 6)
        dot& = 1
        GoTo havedot
        End If
        End If
        ElseIf Left$(rrr$, 1) = "T" Then
        If Left$(rrr$, 5) = "THIS." Then
          If Len(bstack.UseGroupname) > 0 Then
        rrr$ = bstack.UseGroupname + Mid$(rrr$, 6)
        Else
        rrr$ = Mid$(rrr$, 6)
        dot& = 1
        GoTo havedot
        End If
        End If
        End If
    End If
    If StrPointer Then
        If Abs(rr&) = 3 Then
            cc = LastErNum1
            If IsStr1(bstack, (rrr$), rrr$) Then
                fixlen = True
                A$ = rrr$ + A$
                StrPointer = False
                IsLabelBig = Abs(IsLabelBig(bstack, A$, rrr$, , r$)) * Sgn(rr&)
            End If
            LastErNum1 = cc
            nocommand = True
            Exit Function
        ElseIf Abs(rr&) = 6 Then
            fixlen = True
            A$ = rrr$ + A$
            cc = LastErNum1
            If IsStr1(bstack, A$, rrr$) Then
            A$ = rrr$ + A$
            IsLabelBig = Abs(IsLabelBig(bstack, A$, rrr$, , r$)) * Sgn(rr&)
            LastErNum1 = cc
        Else
            LastErNum1 = cc
            cc = InStr(rrr$, "(")
            If cc > 0 Then
                A$ = Mid$(rrr$, cc + 1) + A$
                rrr$ = Left$(rrr$, cc)
                IsLabelBig = 4 * Sgn(rr&)
            Else
                IsLabelBig = Sgn(rr&)
            End If
        End If
        StrPointer = False
        nocommand = True
        Exit Function
    Else
        IsLabelBig = rr&
    End If
Else
    IsLabelBig = rr&
End If
  
nocommand = IsLabelBig And (Len(r$) = 1 Or nocommand)

End Function
Function IsLabelFileName(bstack As basetask, A$, r$) As Long
Dim rr&, one As Boolean, dot As Boolean, c$, gr As Boolean, cc As Long, p, notwopass As Boolean
r$ = vbNullString
If A$ = vbNullString Then IsLabelFileName = 0: Exit Function  'ok
A$ = NLtrim$(A$)
    Do While Len(A$) > 0
     c$ = Left$(A$, 1) 'ANYCHAR HERE
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 0 To 7
         A$ = Mid$(A$, 2)
        Case 64 '"@"
           If r$ = vbNullString Then
              A$ = Mid$(A$, 2)
              ElseIf Mid$(A$, 2, 1) <> "(" And r$ <> "" Then
            r$ = r$ + "."
              A$ = Mid$(A$, 2)
              Else
                 IsLabelFileName = 0: Exit Function
            End If
        Case 63 '"?"
        If r$ = vbNullString Then
        r$ = "?"
        
        IsLabelFileName = 1
        Exit Function
        End If
        A$ = Mid$(A$, 2)
        Case 58 ' ":"
            If one Then
  
            Exit Do
           
             ElseIf r$ <> "" Then
            If Len(A$) > 1 Then
             
            If Mid$(A$, 2, 1) <> "\" Then
            Exit Do
            ElseIf Mid$(A$, 2, 2) = vbCrLf Then
                Exit Do
            End If
            End If
            
            If InStr(r$, ":") > 0 Then
                IsLabelFileName = 0
            Exit Function
            Else
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1
            End If
            Else
            IsLabelFileName = 0
            Exit Function
            End If
        Case 46 ' "."
            
            If one Then
            
            
            Exit Do
            Else
                If r$ = vbNullString Then dot = True
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
                rr& = 1 'is an identifier or floating point variable
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        
        Case 92 '"\"
           If one Then
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
              Exit Do
            End If
        Case 48 To 57, 95  ' "0" To "9", "_"
            If one Then
                Exit Do
            ElseIf r$ <> "" Then
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
              
                rr& = 1 'is an identifier or floating point variable
            End If
        Case 91
            If r$ = vbNullString Then
               r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
                GoTo alfa
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 38 '"&"
            SyntaxError
            rr& = 0
            If Len(A$) > 0 Then Mid$(A$, 1, 1) = ":" Else A$ = ":"
        Case 36 '"$"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 '"%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            r$ = r$ + c$

            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 40 '"("
            If r$ <> "" Then
                If Mid$(A$, 2, 2) = ")@" Then
                 r$ = r$ + "()."
              A$ = Mid$(A$, 4)
                Else
                    notwopass = True
                    dot = False
                    Select Case rr&
                    Case 3
                    rr& = 1 '5 ' float array or function
                    bstack.tmpstr = r$ + Left$(A$, 1)
                    BackPort A$
                    If Not IsStrExp(bstack, A$, r$, False) Then
                        MissString
                        rr& = 0
                    End If
                    Exit Do
                    Case 1
alfa:
                    rr& = 1
                    bstack.tmpstr = r$ + Left$(A$, 1)
                    BackPort A$
                    If IsExp(bstack, A$, p, flatobject:=True, nostring:=False) Then
                    If myVarType(p, vbString) Then
                        SwapString2Variant r$, p
                    Else
                        MissString
                        rr& = 0
                    End If
                    Exit Do
                    End If
                    Case 4
                    ''rr& = 7 long array
                    ' this is an error
                    Case Else
                    Exit Do
                    End Select
                '    R$ = R$ + c$
                 '   a$ = Mid$(a$, 2)
                    
               Exit Do
            
            End If
           Else
           Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
        
    Loop
    If rr& = 1 Then
        If Not notwopass Then
            If dot Then
                If Right$(r$, 1) <> "." Then
                GoTo 1212
                End If
            ElseIf GetVar(bstack, myUcase(r$, True), rr&) Then
1212:
                    bstack.tmpstr = r$ + Left$(A$, 1)
                    BackPort A$
                    If IsExp(bstack, A$, p, flatobject:=True, nostring:=False) Then
                    If myVarType(p, vbString) Then
                        rr& = 1
                        SwapString2Variant r$, p
                    Else
                        MissString
                        rr& = 0
                    End If
                    
                    End If
            End If
        End If
    ElseIf rr& = 3 Then
        bstack.tmpstr = r$ + Left$(A$, 1)
        BackPort A$
        If IsStrExp(bstack, A$, r$, False) Then
            rr& = 1
            
          Else
                        MissString
                        rr& = 0
        End If
    End If
   IsLabelFileName = rr&
 
 

End Function
Function IsLabel(bstack As basetask, A$, rrr$, Optional skipdot As Boolean) As Long
Dim buf$, fixme As Boolean, q1$
If Len(A$) < 129 Then IsLabel = innerIsLabel(bstack, A$, rrr$, , , skipdot): Exit Function

   
    buf$ = Left$(A$, 128)
    q1$ = bstack.tmpstr
    IsLabel = innerIsLabel(bstack, buf$, rrr$, , , skipdot, fixme)
    If Len(buf$) = 0 Then
        If fixme Then bstack.tmpstr = q1$
        IsLabel = innerIsLabel(bstack, A$, rrr$, , , skipdot)
    Else
        If fixme Then
            Select Case Len(buf$)
            Case Is < 128
                Mid$(A$, 129 - Len(buf$), Len(buf$)) = buf$
                A$ = Mid$(A$, 129 - Len(buf$))
            Case Is > 128
                A$ = buf$ + Mid$(A$, 129)
            Case Else
                Mid$(A$, 1, 128) = buf$
            End Select
        Else
        A$ = Mid$(A$, 129 - Len(buf$))
        End If
    End If

    
    

End Function
'
Function innerIsLabel(bstack As basetask, A$, rrr$, Optional nospace As Boolean = False, Optional skipcase As Boolean = False, Optional skipdot As Boolean, Optional fixlen As Boolean) As Long
Dim rr&, one As Boolean, br As Integer, gr As Boolean, c$, dot&, r$, cc As Long
'r$ = VbNullString
If A$ = vbNullString Then innerIsLabel = 0: Exit Function   ' ok
If Not nospace Then A$ = NLtrim$(A$) Else If AscW(A$) = 32 Then Exit Function
Do While Len(A$) > 0
    c$ = Left$(A$, 1) 'ANYCHAR HERE
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
           If r$ = vbNullString Then
              A$ = Mid$(A$, 2)
              ElseIf Mid$(A$, 2, 1) <> "(" And r$ <> "" Then
            r$ = r$ + "."
              A$ = Mid$(A$, 2)
              Else
                 innerIsLabel = 0: Exit Function
            End If
        Case 63 '"?"
            If r$ = vbNullString Then
                rrr$ = "?"
                innerIsLabel = 1
                Exit Function
            End If
            A$ = Mid$(A$, 2)
        Case 58 '":"
            If one Then
                Exit Do
            ElseIf r$ <> "" Then
                If Len(A$) > 1 Then
                    If Mid$(A$, 2, 1) <> "\" Then
                        Exit Do
                    ElseIf Mid$(A$, 2, 2) = vbCrLf Then
                        Exit Do
                    End If
                End If
                If InStr(r$, ":") > 0 Then
                    innerIsLabel = 0
                    Exit Function
                Else
                    r$ = r$ + c$
                    A$ = Mid$(A$, 2)
                    rr& = 1
                End If
            Else
                innerIsLabel = 0
                Exit Function
            End If
        Case 46 '"."
            If one Then
                Exit Do
            ElseIf r$ <> "" Then
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
            ElseIf Not Mid$(A$, 2, 1) Like "[0-9]" Then
                If r$ <> "" Then
                    r$ = r$ + c$
                    rr& = 1
                Else
                    dot& = dot& + 1
                End If
                A$ = Mid$(A$, 2)
            Else
                If r$ = vbNullString And dot& > 0 Then
                    rrr$ = String$(dot& + 1, ".")     ' i want this only in right position for "dir .. "
                    r$ = rrr$
                    A$ = Mid$(A$, 2)
                    innerIsLabel = 1
                Else
                    innerIsLabel = 0
                End If
                Exit Function
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        Case 91
            A$ = Mid$(A$, 2)
            If Len(r$) > 0 Then
                If Len(r$) = 1 Then
                    If r$ <> "[" Then
                        rr& = 8
                        Exit Do
                    End If
                ElseIf Right$(r$, 1) <> "." Then
                    If Right$(r$, 1) <> ChrW(&HFFBF) Then
                        If Left$(r$, 1) <> "[" Then
                            rr& = 8
                            Exit Do
                        End If
                    End If
                End If
                br = br + 1
                r$ = r$ + "["
            Else
                r$ = "["
                br = 1
                rr& = 1 'is an identifier
            End If
        Case 92 '"\"
            If one Then
                Exit Do
            ElseIf r$ <> "" Or dot& Then
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case 93
            If Len(r$) = 0 Then Exit Do
            If br > 0 Then
                br = br - 1
                r$ = r$ + "]"
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case 48 To 57, 95 '"0" To "9", "_"  ' old ,"\"
            If one Then Exit Do
            If r$ <> vbNullString Then
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
            Else
                If dot& > 0 Then A$ = "." + A$: dot& = 0
                Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then Exit Do
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1
            
        Case 38 ' "&"
            If one Then Exit Do
            
            If r$ <> "" Then
                'ERROR
                rr& = 0
                '' r$ = VbNullString
                rrr$ = vbNullString
                innerIsLabel = 0
                Exit Function
            Else
                A$ = Mid$(A$, 2)
                rr& = Abs(innerIsLabel(bstack, A$, r$, True))
                skipcase = True
                If rr& < 5 Then
                    Dim I As Long
                    If GetlocalVar(r$, I) Then
                        A$ = Chr(34) + here$ + "." + r$ + Chr(34) + A$
                    ElseIf Left$(r$, 5) = "ауто." Or Left$(r$, 5) = "THIS." Then
                        If Len(bstack.UseGroupname) > 0 Then
                            c$ = bstack.UseGroupname + Mid$(r$, 6)
                        Else
                            c$ = StripThis2(here$)
                            If c$ <> "" Then c$ = c$ + "." + Mid$(r$, 6) Else c$ = here$ + "." + r$
                        End If
                        A$ = Chr(34) + c$ + Chr(34) + A$
                    ElseIf varhash.Find(r$, cc) Then
                        A$ = Chr(34) + r$ + Chr(34) + A$

                        If r$ = "THIS" Or r$ = "ауто" Then
                            rrr$ = r$
                            innerIsLabel = -100
                            Exit Function
                        Else
                            If GetSub(r$ + ")", rr&) Then
                                r$ = "{" + sbf(rr&).sb + "} " + sbf(rr&).sbgroup
                                rr& = 2
                                Exit Do
                            Else
                                If cc > 0 Then
                                ElseIf Not bstack.NoError Then
                                    MyErMacro A$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                                End If
                            End If
                        End If
                    End If
                Else
                    If FastSymbol(A$, ")") Then
                        rr& = 0
                        If Left$(r$, 5) = "ауто." Or Left$(r$, 5) = "THIS." Then
                            If varhash.ExistKey(bstack.UseGroupname + Mid$(r$, 6)) > 0 Then
                                A$ = Chr(34) + bstack.UseGroupname & Mid$(r$, 6, Len(r$) - 6) + Chr(34) + A$
                            Else
                                rr& = 2
                            End If
                        ElseIf varhash.ExistKey(here$ & "." & r$) Then
                             A$ = Chr(34) + here$ & "." & r$ + Chr(34) + A$
                        ElseIf varhash.ExistKey(r$) Then
                            A$ = Chr(34) + r$ + Chr(34) + A$
                        Else
                           rr& = 3
                        End If
                        If rr& > 0 Then
                            If rr& = 2 Then
                               If Len(bstack.UseGroupname) > 0 Then
                                   r$ = bstack.UseGroupname + Mid$(r$, 6)
                               End If
                            End If
                            rr& = 1
                            If GetSub(r$ + ")", rr&) Then
                                r$ = "{" + sbf(rr&).sb + "}" + sbf(rr&).sbgroup
                                rr& = 2
                                Exit Do
                            Else
                                If Not bstack.NoError Then MyErMacro A$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                            End If
                        End If
                        rr& = 0
                        r$ = vbNullString
                        Exit Do
                    End If
                End If
                r$ = vbNullString
                rr& = 0
                Exit Do
            End If
        Case 36 ' "$"
       If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ & c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            r$ = r$ & c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                If Mid$(A$, 2, 2) = ")@" Then
                 r$ = r$ & "()."
              A$ = Mid$(A$, 4)
                ElseIf Mid$(A$, 2, 2) = ")." Then ' And rr& = 1 Then
                 r$ = r$ & "()."
                 rr& = 0
                 one = False
              A$ = Mid$(A$, 4)
              GoTo CONT1234
                Else
                Select Case rr&
                Case 1
                rr& = 5 ' float array or function
                Case 3
                rr& = 6 'string array or function
                Case 4
                rr& = 7 ' long array
                Case Else
                Exit Do
                End Select
                r$ = r$ & c$
                A$ = Mid$(A$, 2)
               Exit Do
            
            End If
           Else
           Exit Do
            End If
 Case 8 '
     If Len(r$) > 0 Then Exit Do
     A$ = bstack.tmpstr + Mid$(A$, 2)
     fixlen = True
     bstack.tmpstr = vbNullString
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
                rr& = 1 'is an identifier or floating point variable
            End If
        End If
CONT1234:
    Loop
    If skipcase Then
    rrr$ = r$
    Else
    rrr$ = myUcase(r$, gr)
    End If
   If dot& Then
                           If r$ <> "" Then
     If skipdot And dot& = 1 Then
     rrr$ = "THIS." + rrr$
     
     Else

                        rr& = bstack.GetDotNew(rrr$, dot&) * rr&

                        End If
                           Else
                          If dot& > 1 Then rrr$ = String$(dot&, ".") + rrr$: If rr& = 0 Then rr& = 1
                          End If
    
    
   End If
    innerIsLabel = rr&
End Function
Function IsLabelDIM(bstack As basetask, A$, r$) As Long
Dim rr&, one As Boolean, c$, dot&, gr As Boolean, skipcase As Boolean, cc As Long
r$ = vbNullString
If A$ = vbNullString Then IsLabelDIM = 0: Exit Function ' ok
A$ = NLtrim$(A$)
    Do While Len(A$) > 0
     c$ = Left$(A$, 1) 'ANYCHAR HERE
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
           If r$ = vbNullString Then
              A$ = Mid$(A$, 2)
              ElseIf Mid$(A$, 2, 1) <> "(" And r$ <> "" Then
            r$ = r$ & "."
              A$ = Mid$(A$, 2)
              Else
                 IsLabelDIM = 0: Exit Function
            End If
        Case 63 '"?"
        If r$ = vbNullString Then
        r$ = "?"
        IsLabelDIM = 1
        Exit Function
        End If
        A$ = Mid$(A$, 2)
        Case 58 '":"
            If one Then
  
            Exit Do
           
            ElseIf r$ <> "" Then
            If Len(A$) > 1 Then
            If Mid$(A$, 2, 1) <> "\" Then
            Exit Do
            ElseIf Mid$(A$, 2, 2) = vbCrLf Then
                Exit Do
            End If
            End If
            
            If InStr(r$, ":") > 0 Then
                IsLabelDIM = 0
            Exit Function
            Else
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1
            End If
            Else
            IsLabelDIM = 0
            Exit Function
            End If
        Case 46 '"."
            
            If one Then
  
            Exit Do
           ElseIf r$ <> "" Then
           If dot& = 0 And Len(r$) = 4 Then
            c$ = myUcase(r$, True)
            If c$ = "THIS" Or c$ = "AYTO" Then
                r$ = vbNullString
                dot& = 1
                Else
                r$ = r$ + "."
            End If
            Else
            r$ = r$ + "."
           End If
                    
                       A$ = Mid$(A$, 2)
           ''
           ElseIf Not Mid$(A$, 2, 1) Like "[0-9]" Then
            
                       If r$ <> "" Then
                       r$ = r$ + c$
                      rr& = 1
                                      
                            Else
                            
                            dot& = dot& + 1
                    
                            End If
                         
                         A$ = Mid$(A$, 2)
                        
                        
            Else
                         If r$ = vbNullString And dot& > 0 Then
                     
                             
                                 r$ = String$(dot& + 1, ".")
                                  A$ = Mid$(A$, 2)
                                 IsLabelDIM = 1
                         Else
                              IsLabelDIM = 0
                        End If
                    
            Exit Function
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        
        Case 92 '"\"
           If one Then
            Exit Do
            ElseIf r$ <> "" Or dot& Then
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
              Exit Do
            End If
        Case 48 To 57, 95 '"0" To "9", "_"  ' old ,"\"
       
           If one Then
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
             rr& = 1 'is an identifier or floating point variable
            Else
            If dot& > 0 Then A$ = "." + A$: dot& = 0
            
            Exit Do
            End If
Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 38 ' "&"
        
            If one Then Exit Do
            
            If r$ <> "" Then
            
                rr& = 0
     
              r$ = vbNullString
                Exit Function
            Else
                A$ = Mid$(A$, 2)
                rr& = Abs(IsLabelDIM(bstack, A$, r$))
                skipcase = True
                If rr& < 5 Then
            Dim I As Long
         
                    If GetlocalVar(r$, I) Then
                        A$ = Chr(34) + here$ & "." + r$ + Chr(34) + A$
                    ElseIf Left$(r$, 5) = "ауто." Or Left$(r$, 5) = "THIS." Then
                        If Len(bstack.UseGroupname) > 0 Then
                                 c$ = bstack.UseGroupname + Mid$(r$, 6)
                                 
                         Else
                             c$ = StripThis2(here$)
                             If c$ <> "" Then c$ = c$ + "." + Mid$(r$, 6) Else c$ = here$ + "." + r$
                         End If
                    A$ = Chr(34) + c$ + Chr(34) + A$
                    
                  ElseIf varhash.Find(r$, cc) Then
                         A$ = Chr(34) + r$ & Chr(34) + A$
                    Else
                    '' r$ = myUcase(r$, gr)
                    
                    If r$ = "THIS" Or r$ = "ауто" Then
                
                   IsLabelDIM = -100
                   
                   Exit Function
                    Else
                If GetSub(r$ + ")", rr&) Then
                
                                 r$ = "{" + sbf(rr&).sb + "} " + sbf(rr&).sbgroup
                                 
                    rr& = 2
                    Exit Do
                    Else
                    If Not bstack.NoError Then MyEr "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
                    End If
                    End If
                Else
                    If FastSymbol(A$, ")") Then
                           '' r$ = myUcase(r$, gr)
                            rr& = 0
                            If Left$(r$, 5) = "ауто." Or Left$(r$, 5) = "THIS." Then
                            If varhash.ExistKey(bstack.UseGroupname & Mid$(r$, 6)) Then
                                    A$ = Chr(34) + bstack.UseGroupname & Mid$(r$, 6, Len(r$) - 6) + Chr(34) + A$
                                    Else
                                    rr& = 1
                                    End If
                                ElseIf varhash.ExistKey(here$ & "." & r$) Then
                                     A$ = Chr(34) + here$ + "." + r$ + Chr(34) + A$
                                ElseIf varhash.ExistKey(r$) Then
                                    A$ = Chr(34) + r$ + Chr(34) + A$
                                Else
                                   rr& = 1
                                End If
                                 If rr& = 1 Then
                                 If Len(bstack.UseGroupname) > 0 Then
                                 r$ = bstack.UseGroupname + Mid$(r$, 6)
                                 Else
                                 End If
                                 If GetSub(r$ + ")", rr&) Then
                                    r$ = "{" + sbf(rr&).sb + "}" + sbf(rr&).sbgroup
                                    rr& = 2
     
                                    Exit Do
                    
                    Else
                    If Not bstack.NoError Then MyEr "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
               
                                 
                                 End If
                                 rr& = 0
                                 r$ = vbNullString
                                Exit Do
                            End If
                    End If
                    
                    r$ = vbNullString
                    rr& = 0
                    Exit Do
            End If
            
        Case 36 ' "$"
       If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                If Mid$(A$, 2, 2) = ")@" Then
                    r$ = r$ + "()."
                    A$ = Mid$(A$, 4)
                ElseIf Mid$(A$, 2, 2) = ")." Then ' And rr& = 1 Then
                    r$ = r$ + "()."
                    rr& = 0
                    one = False
                    A$ = Mid$(A$, 4)
                    GoTo CONT1234
                Else
                    Select Case rr&
                    Case 1
                    rr& = 5 ' float array or function
                    Case 3
                    rr& = 6 'string array or function
                    Case 4
                    rr& = 7 ' long array
                    Case Else
                    Exit Do
                    End Select
                    r$ = r$ + c$
                    A$ = Mid$(A$, 2)
                    Exit Do
               End If
            Else
                Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
CONT1234:
    Loop
    If Not skipcase Then r$ = myUcase(r$, gr)
   If dot& Then
                           If r$ <> "" Then
                         '  rr& = bstack.GetDotNew(R$, dot&) * rr&
                           If dot& = 1 Then
                           'R$ = "THIS." + R$
                           
                           'rr& = IsLabel(bstack, (R$), R$)
                           'rr& = -rr&
                           rr& = bstack.GetDotNew(r$, dot&) * rr&
                           Else
                        rr& = bstack.GetDotNew(r$, dot&) * rr&
                        End If
                           Else
                            If dot& > 1 Then r$ = String$(dot&, ".") + r$: If rr& = 0 Then rr& = 1
                          End If
    
    
   End If
    IsLabelDIM = rr&
End Function

Function IsLabelSYMB3(A$, r$) As Boolean ' for RevisionPrint
    Dim rr As Boolean, c$, LB As Long, mb As Long, LLB As Long
    A$ = NLtrim$(A$)
    LLB = Len(A$)
    r$ = vbNullString
    If LLB = 0 Then IsLabelSYMB3 = 0: Exit Function
    mb = 0   'INDICATE LEFT SPACES
    LB = 1
    Do While LB <= LLB
        c$ = Mid$(A$, LB, 1)
        If AscW(c$) < 256 Then
            Select Case AscW(c$)
            Case 32, 160, 9
                If LB - mb > 1 Then
                    LB = LB - 1: Exit Do
                Else
                    mb = LB
                End If
            Case 36, 37, 40, 46, 48 To 57, 95 ' "$", "%", "(", "."
                IsLabelSYMB3 = 0
                Exit Function
            'Case 46 '"."
            ' If LB > mb Then
            '    rr& = 1
            '    Else
            '    IsLabelSYMB3 = 0
            '    Exit Function
            '    End If
            Case 65 To 90, 97 To 122 ' "A" To "Z", "a" To "z"
                rr = True
            Case Else
                LB = LB - 1
                Exit Do
            End Select
        Else
            rr = True
        End If
        LB = LB + 1
    Loop
    r$ = Mid$(A$, mb + 1, LB - mb)
    IsLabelSYMB3 = rr
    If LB > 0 Then A$ = Mid$(A$, LB + 1)

End Function
Function IsLabelSYMB33(A$, r$, chars As Long) As Boolean ' ok
    Dim rr&, c$, LB As Long, mb As Long, LLB As Long
    LLB = Len(A$)
    r$ = vbNullString
    If LLB = 0 Then IsLabelSYMB33 = 0: Exit Function
    mb = 0
    LB = 1
    Do While LB <= LLB
        c$ = Mid$(A$, LB, 1)
        If AscW(c$) < 256 Then
            Select Case AscW(c$)
            Case 32, 160, 9
                If LB - mb > 1 Then
                    LB = LB - 1
                    Exit Do
                Else
                    mb = LB
                End If
            Case 46 '"."
                If LB > mb Then
                    rr& = 1
                Else
                    IsLabelSYMB33 = 0
                    Exit Function
                End If
            Case 65 To 90, 97 To 122 ' "A" To "Z", "a" To "z"
                rr& = 1 'is an identifier or floating point variable
            Case Else
                LB = LB - 1
                Exit Do
            End Select
        Else
            rr& = 1 'is an identifier or floating point variable
        End If
        LB = LB + 1
    Loop
    r$ = Mid$(A$, mb + 1, LB - mb)
    IsLabelSYMB33 = rr&
    If rr& <> 0 Then
        chars = LB + 1
    End If
End Function
Function IsLabelF(A$, rrr$) As Long
Dim buf$
If Len(A$) < 129 Then IsLabelF = IsLabelF1(A$, rrr$): Exit Function

   
    buf$ = Left$(A$, 128)
    IsLabelF = IsLabelF1(buf$, rrr$)
    If buf$ = vbNullString Then
        IsLabelF = IsLabelF1(A$, rrr$)
    Else
        A$ = Mid$(A$, 129 - Len(buf$))
    End If
End Function

Function IsLabelF1(A$, r$) As Long  'ok
' for left side...no &

Dim rr&, one As Boolean, c$, gr As Boolean
r$ = vbNullString
If A$ = vbNullString Then IsLabelF1 = 0: Exit Function
A$ = NLtrim$(A$)
    Do While Len(A$) > 0
    c$ = Left$(A$, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 46 '"."
            If one Then
            Exit Do
            ElseIf r$ <> "" And Len(A$) > 1 Then
            If Mid$(A$, 2, 2) = ". " Or Mid$(A$, 2, 1) = " " Then Exit Do
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1
            Else
            IsLabelF1 = 0
            Exit Function
            End If
      Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
        Exit Do
        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
                one = True
                rr& = 4 ' is long variable
                r$ = r$ + c$
                A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If

    Loop
    r$ = myUcase(r$, gr)
    IsLabelF1 = rr&


End Function
Function IsLabelA(where$, A$, r$) As Long
Dim n$
If Len(A$) < 65 Then
    IsLabelA = IsLabelA1(where$, A$, r$)
Else
    n$ = Left$(A$, 64)
    IsLabelA = IsLabelA1(where$, n$, r$)
    If Len(n$) = 0 Then
        IsLabelA = IsLabelA1(where$, A$, r$)
    Else
        A$ = Mid$(A$, 65 - Len(n$))
    End If
End If
End Function
Function IsLabelA1(where$, A$, r$) As Long 'ok
' for left side...no &

Dim rr&, one As Boolean, c$, gr As Boolean
r$ = vbNullString
If A$ = vbNullString Then IsLabelA1 = 0: Exit Function
A$ = NLtrim$(A$)
    Do While Len(A$) > 0
    c$ = Left$(A$, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
            If Mid$(A$, 2, 1) <> "(" And r$ <> "" Then
              where$ = r$
            r$ = vbNullString
            A$ = Mid$(A$, 2)
            Else
              IsLabelA1 = 0: Exit Function
            End If
        Case 63 '"?"
        If r$ = vbNullString Then
        r$ = "?"
        A$ = Mid$(A$, 2)
        IsLabelA1 = 1
        Exit Function
        Else
        IsLabelA1 = 1
        Exit Function
        End If
        Case 46 '"."
            If one Then
            Exit Do
            Exit Do
            ElseIf r$ <> "" And Len(A$) > 1 Then
            If Mid$(A$, 2, 2) = ". " Or Mid$(A$, 2, 1) = " " Then Exit Do
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1
            Else
            IsLabelA1 = 0
            Exit Function
            End If
      Case 38 ' "&"
            If r$ = vbNullString Then rr& = 2:    A$ = Mid$(A$, 2)
            Exit Do
    Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
        Exit Do
        
        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                            If Mid$(A$, 2, 2) = ")@" Then
                                    r$ = r$ + "()."
                                  
                                 A$ = Mid$(A$, 4)
                               Else
                                       Select Case rr&
                                       Case 1
                                       rr& = 5 ' float array or function
                                       Case 3
                                       rr& = 6 'string array or function
                                       Case 4
                                       rr& = 7 ' long array
                                       Case Else
                                       Exit Do
                                       End Select
                                       r$ = r$ + c$
                                       A$ = Mid$(A$, 2)
                                   Exit Do
                            
                          End If
               Else
                        Exit Do
            
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If

    Loop
    r$ = myUcase(r$, gr)

    IsLabelA1 = rr&

End Function

Function IsLabelDot(where$, A$, r$, Optional dotnum&) As Long 'ok
' for left side...no &

Dim rr&, one As Boolean, br As Integer, c$, firstdot$, gr As Boolean
r$ = vbNullString
If A$ = vbNullString Then IsLabelDot = 0: Exit Function

A$ = NLtrim$(A$)
    Do While Len(A$) > 0
    c$ = Left$(A$, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
            If Mid$(A$, 2, 1) <> "(" And r$ <> "" Then
              where$ = r$
            r$ = vbNullString
            A$ = Mid$(A$, 2)
            Else
              IsLabelDot = 0: A$ = firstdot$ + A$: Exit Function
            End If
        Case 63 '"?"
        If r$ = vbNullString And firstdot$ = vbNullString Then
        r$ = "?"
        A$ = Mid$(A$, 2)
        IsLabelDot = 1
        Exit Function
    
        ElseIf firstdot$ = vbNullString Then
        IsLabelDot = 1
        Exit Function
        Else
        IsLabelDot = 0
        Exit Function
        End If
        Case 46 '"."
            If one Then
            Exit Do
            Exit Do
            ElseIf r$ <> "" And Len(A$) > 1 Then
            If Mid$(A$, 2, 2) = ". " Or Mid$(A$, 2, 1) = " " Then Exit Do
            r$ = r$ + Left$(A$, 1)
            A$ = Mid$(A$, 2)
            rr& = 1
            Else
            firstdot$ = firstdot$ + "."
            A$ = Mid$(A$, 2)
            End If
        Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
        Exit Do
        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            If firstdot$ <> "" Then A$ = firstdot$ + A$
            Exit Do
            ElseIf r$ <> "" Then
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
        Case 91
            A$ = Mid$(A$, 2)
            If Len(r$) > 0 Then
                If Len(r$) = 1 Then
                    If r$ <> "[" Then
                        rr& = 8
                        Exit Do
                    End If
                ElseIf Right$(r$, 1) <> "." Then
                    If Right$(r$, 1) <> ChrW(&HFFBF) Then
                        If Left$(r$, 1) <> "[" Then
                            rr& = 8
                            Exit Do
                        End If
                    End If
                End If
                br = br + 1
                r$ = r$ + "["
            Else
                r$ = "["
                rr& = 1 'is an identifier
            End If
        Case 93
            If Len(r$) = 0 Then Exit Do
            If br > 0 Then
                br = br - 1
                r$ = r$ + "]"
                A$ = Mid$(A$, 2)
            Else
                Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            ElseIf Len(r$) = 0 Then
            If firstdot$ = "." Then
            r$ = "THIS." + c$
            firstdot$ = vbNullString
            Else
            r$ = r$ + c$
            End If
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If r$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            r$ = r$ + c$
            A$ = Mid$(A$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If r$ <> "" Then
                If Mid$(A$, 2, 2) = ")@" Then
                    r$ = r$ + "()."
                    A$ = Mid$(A$, 4)
                ElseIf Mid$(A$, 2, 2) = ")." Then ' And rr& = 1 Then
                    r$ = r$ + "()."
                    rr& = 0
                    one = False
                    A$ = Mid$(A$, 4)
                    GoTo CONT1234
                Else
                       Select Case rr&
                        Case 1
                        rr& = 5 ' float array or function
                        Case 3
                        rr& = 6 'string array or function
                        Case 4
                        rr& = 7 ' long array
                        Case Else
                        Exit Do
                        End Select
                        r$ = r$ + c$
                        A$ = Mid$(A$, 2)
                    Exit Do
                        
                          End If
               Else
                        Exit Do
            
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            If firstdot$ = "." Then
            r$ = "ауто." + c$
            firstdot$ = vbNullString
            Else
            r$ = r$ + c$
            End If
            A$ = Mid$(A$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
CONT1234:
    Loop
    If Len(firstdot$) = 0 Then
    r$ = myUcase(r$, gr)
    ElseIf dotnum& = -1 Then
        r$ = myUcase(r$, gr)
        dotnum& = Len(firstdot$)
    Else
    r$ = firstdot$ + myUcase(r$, gr)
    End If
    IsLabelDot = rr&
   

End Function
Function IsStrExp(basestack As basetask, aa$, rr$, Optional check As Boolean = True) As Boolean
Dim ac$, fault As Boolean, p
If Len(aa$) = 0 Then Exit Function
If check Then
If Not AscW(aa$) = 8 Then
If Not aheadstatusStr(aa$) Then Exit Function
End If
End If

'If check Then If Left$(aheadstatus(aa$, False), 1) <> "S" Then IsStrExp = False: Exit Function
If LastErNum = -2 Then LastErNum = 0 ': LastErNum1 = 0

'If lookOne(aa$, "(") Then
'IsExp basestack, aa$, (0), , True, False
'End If
again:
fault = False
IsStrExp = False
If IsString(basestack, aa$, rr$) Then
    
    Do
        fault = False
        IsStrExp = True
        If Len(ac$) > 0 Then
            ac$ = ac$ + rr$
        Else
            SwapStrings ac$, rr$
        End If
        If Not MaybeIsSymbol(aa$, "+") Then Exit Do
        FastSymbol aa$, "+"
        Set basestack.lastobj = Nothing
        fault = True
        If FastSymbol(aa$, "(") Then
        If IsExpA(basestack, aa$, p, (0)) Then
        If Not basestack.lastobj Is Nothing Then
        If TypeOf basestack.lastobj Is BigInteger Then
        p = basestack.lastobj.ToString
        End If
        Set basestack.lastobj = Nothing
        End If
        If Not FastSymbol(aa$, ")") Then Exit Do
        GoTo cont003003
        End If
        End If
        If Not IsString(basestack, aa$, rr$) Then
            If Not IsNumber(basestack, aa$, p, True) Then
                    Exit Do
            Else
            
cont003003:
                Assign rr$, p
            End If

        End If
    Loop
    If fault Then If LastErNum = -2 Then Exit Function
    If FastSymbol(aa$, "<<", , 2) Then
    basestack.soros.DataStr ac$
    ac$ = vbNullString
    GoTo again
    End If
End If
If Not IsStrExp Then Set basestack.lastobj = Nothing
SwapStrings rr$, ac$
'rr$ = ac$
 End Function

Function ReadVarDouble(bstack As basetask, what$) As Variant
Dim vvv As Variant
bstack.ReadVar what$, vvv
If MyIsObject(vvv) Then
Set bstack.lastobj = vvv
Else
ReadVarDouble = vvv
End If
End Function

Function ReadVarInt(bstack As basetask, what$) As Variant
Dim vvv As Variant
bstack.ReadVar what$, vvv
ReadVarInt = Int(vvv)
End Function
Function ReadVarStr(bstack As basetask, what$) As String
Dim vvv As Variant
bstack.ReadVar what$, vvv
ReadVarStr = vvv
End Function
Function IsString(bstackstr As basetask, A$, r$) As Boolean
r$ = vbNullString
Dim I As Long, q
I = MyTrimL(A$)   ' MyTrimL("   ") return 3 no 0. but never happen to be "   "
If Len(A$) < I Then
    Exit Function
End If
q = AscW(Mid$(A$, I, 1))
Select Case q
Case 92, 47, 39, 58
    Exit Function
Case 123
        r$ = blockString(A$, 125, I + 1)
        IsString = FastSymbol(A$, "}")
        If Not IsString Then GoTo err1111
        Exit Function
Case 34
        r$ = blockString(A$, 34, I + 1)
        IsString = FastSymbol(A$, Chr$(34))
        If Not IsString Then GoTo err1111
        If r$ = vbNullString Then
        Dim rr$
        Do While A$ <> ""
            Oldway A$, rr$
            r$ = r$ + rr$
            If Len(A$) > 0 Then
            If AscW(A$) = 34 Then
                A$ = Mid$(A$, 2)
                r$ = r$ + Chr$(34) + blockString(A$, 34)
                IsString = FastSymbol(A$, Chr$(34))
            Else
            Exit Do
            End If
            Else
            Exit Do
            End If
        Loop
        End If
        If Not IsString Then GoTo err1111
        Exit Function
Case 40
        If IsExp(bstackstr, A$, q) Then
           If myVarType(q, vbString) Then
              SwapString2Variant r$, q: IsString = True
           End If
        End If
Case 1, 2
        IsString = ISSTRINGA(A$, r$)
Case Else
    IsString = IsStr1(bstackstr, A$, r$)
  End Select
Exit Function
err1111:
MyErMacroStr A$, "No closed string, open with " + ChrW(q), "аМОИВТЭ АКЖАЯИХЛГТИЙЭ, ЛЕ " + ChrW(q)

End Function
Private Sub Oldway(A$, r$)
Dim W As Long
        W = 1
        If Mid$(A$, W, 2) = Chr(34) + Chr$(34) Then
            Do
            r$ = r$ + Chr$(34)
            W = W + 2
            Loop Until Not Mid$(A$, W, 2) = Chr(34) + Chr$(34)
            A$ = NLtrim$(Mid$(A$, W))
    End If
End Sub
Function IsStr1(bstackstr As basetask, A$, r$) As Boolean
Dim nbstack As basetask, n$
Dim p As Variant, pp As Variant, pppp As mArray, ppppL As iBoxArray, usehandler As mHandler, rA As refArray
Dim q$, W As Long, w1 As Long, w2 As Long, s$, par As Boolean, usebackup As Boolean
Dim q1$, q2$, w3 As Long, dn As Long, dd As Long, bs As basetask, sg1 As Boolean
Dim anything As Object, gr As Boolean
Dim aaa As lambda
againpointer:
Set bstackstr.lastobj = Nothing
w2 = Len(A$)
If w2 < 129 Then
    w1 = IsLabelBig(bstackstr, A$, q$, par, q2$, , , usebackup, , gr)
Else
    n$ = Left$(A$, 128)
    q1$ = bstackstr.tmpstr
    w1 = IsLabelBig(bstackstr, n$, q$, par, q2$, , , usebackup, sg1, gr)
    If Len(n$) = 0 Then
        If sg1 Then bstackstr.tmpstr = q1$
        w1 = IsLabelBig(bstackstr, A$, q$, par, q2$, , , usebackup, gr)
    Else
        If sg1 Then
            sg1 = False
            Select Case Len(n$)
            Case Is < 128
                Mid$(A$, 129 - Len(n$), Len(n$)) = n$
                A$ = Mid$(A$, 129 - Len(n$))
            Case Is > 128
                A$ = n$ + Mid$(A$, 129)
            Case Else
                Mid$(A$, 1, 128) = n$
            End Select
        Else
            A$ = Mid$(A$, 129 - Len(n$))
        End If
    End If
End If
''''''''If NoOptimum Then If w1 > 0 Then par = False
If w1 <= 0 Or par Then
    If usebackup Then If w1 > 4 Then GoTo conthere
    If w1 = 0 Then Exit Function
    If w1 = -50 Then
        r$ = q$
        IsStr1 = True
        Exit Function
    End If
    If w1 = -100 Then
        w1 = 0
        r$ = vbNullString
        If bstackstr.GetDotNew(r$, 1, True) Then
            If r$ = "THIS." Then
                r$ = Left$(bstackstr.UseGroupname, Len(bstackstr.UseGroupname) - 1)
            ElseIf Len(bstackstr.UseGroupname) > 0 Then
                If bstackstr.tpointer > 0 Then
                    If var(bstackstr.tpointer).GroupName = r$ Then
                        r$ = var(bstackstr.tpointer).Patch
                    Else
                        GoTo cont2345
                    End If
                Else
cont2345:
                    If Len(r$) = 0 Then IsStr1 = False: Exit Function
                    If r$ = bstackstr.UseGroupname Then
                        r$ = Left$(r$, Len(r$) - 1)
                    ElseIf InStr(r$, ".") = 0 Then
                        r$ = Left$(r$, Len(r$) - 1)
                        If here$ <> "" Then r$ = here$ + "." + r$
                    Else
                        r$ = Left$(r$, Len(r$) - 1)
                    End If
                End If
            Else
                If Len(r$) = 1 Then
                    Set bs = bstackstr.Parent
                    Do While Not (bs Is Nothing)
                        If bs.GetDotNew(r$, 1) Then
                            If Len(r$) = 1 Then
                                Set bs = bs.Parent
                            Else
                                r$ = here$ + "." + Left$(r$, Len(r$) - 1)
                                Set bs = Nothing
                                Exit Do
                            End If
                        Else
                            r$ = vbNullString
                            Exit Do
                        End If
                    Loop
                Else
                    If Len(r$) = 0 Then
                    ElseIf Left$(r$, 1) = "*" Then
                        r$ = Mid$(r$, 2, Len(r$) - 2)
                    ElseIf Len(here$) > 0 Then
                        If Len(here$) < Len(r$) Then
                            If Left$(r$, Len(here$) + 1) = here$ + "." Then
                                r$ = Left$(r$, Len(r$) - 1)
                            Else
                                r$ = here$ + "." + Left$(r$, Len(r$) - 1)
                            End If
                        Else
                           r$ = here$ + "." + Left$(r$, Len(r$) - 1)
                        End If
                    Else
                        r$ = Left$(r$, Len(r$) - 1)
                    End If
                End If
            End If
            IsStr1 = True
            Exit Function
        ElseIf Len(bstackstr.UseGroupname) > 0 Then
            r$ = Left$(bstackstr.UseGroupname, Len(bstackstr.UseGroupname) - 1)
            IsStr1 = True
            Exit Function
        End If
        r$ = vbNullString
    End If
    w1 = Abs(w1)
    Select Case w1
    Case 2
        SwapStrings r$, q$
        IsStr1 = True
        Exit Function
    Case 3
        GoTo itisavar
    Case 5
        GoTo rvalObjectstring
    Case 6
        GoTo itisarrayorfunction
    Case 8
     If GetVar(bstackstr, q$, w1) Then
        If MyIsObject(var(w1)) Then
            If Typename(var(w1)) = "RefArray" Then
                FastSymbol1 A$, "["
                Set rA = var(w1)
                r$ = BlockParamSq(A$)
                If r$ = "" Then
                    SyntaxError
                    Exit Function
                End If
                Mid$(A$, 1, Len(r$)) = space$(Len(r$))
                If IsExp(bstackstr, r$, p, flatobject:=True, nostring:=True) Then
                    p = Abs(Int(p))
                    If rA.MarkTwoDimension Then
                            If FastSymbol(A$, "][", True, 2) Then
                            r$ = BlockParamSq(A$)
                            If r$ = "" Then
                                SyntaxError
                                Exit Function
                            End If
                            Mid$(A$, 1, Len(r$)) = space$(Len(r$))
                            If IsExp(bstackstr, r$, pp, flatobject:=True, nostring:=True) Then
                                pp = Abs(Int(pp))
                                If rA.count <= p Then
                                    OutOfLimit
                                    Exit Function
                                ElseIf rA.count(p) <= pp Then
                                    OutOfLimit
                                    Exit Function
                                ElseIf myVarType(rA(p, pp), 9) Then
                                Set bstackstr.lastobj = rA(p, pp)
                                Else
                                r$ = rA(p, pp)
                                IsStr1 = FastSymbol(A$, "]")
                                Exit Function
                                End If
                                
                                If FastSymbol(A$, "]") Then
                                    GoTo Final
                                Else
                                    SyntaxError
                                End If
                            Else
                                MissNumExpr
                            End If
                        End If
                    Else
                            If rA.count((0)) <= p Then
                                OutOfLimit
                                Exit Function
                            Else
                            Select Case rA.vtType(0, p)
                            
                            Case 9
                            
                                

                                Set bstackstr.lastobj = rA(0, p)
                                If Not bstackstr.lastobj Is Nothing Then
                                    If TypeOf bstackstr.lastobj Is BigInteger Then
                                    
                                     SwapString2Variant r$, bstackstr.lastobj.ToString
                                    End If
                                End If
                            Case vbString
                                r$ = rA(0, p)
                                
                            Case vbUserDefinedType
                                
                                If FastOperator(A$, "]|", (1), (2)) Then
                                    w2 = IsLabel(bstackstr, A$, s$)
                                    If w2 > 0 Then
                                    pp = rA(0, p, s$)
there12345:
                                    Select Case MemInt(VarPtr(pp))
                                    Case vbString
                                        SwapString2Variant r$, pp
                                    Case 9
                                        Set bstackstr.lastobj = pp
                                    Case Else
                                        r$ = fixthis(pp)
                                    End Select
                                    End If
                                    IsStr1 = True
                                    Exit Function
                                End If
                                
                            Case Else
                                r$ = fixthis(rA(0, p))
                                
                                
                            End Select
                            IsStr1 = FastSymbol(A$, "]")
                            Exit Function
                            End If
                        If FastSymbol(A$, "]") Then
                            GoTo Final
                        Else
                            SyntaxError
                        End If
                    End If
                    
                Else
                   MissNumExpr
                End If
            Else
                If TypeOf var(w1) Is mHandler Then
                    If var(w1).T1 = 2 Then
                        If IsExp(bstackstr, A$, pp, , True, , True) Then
                            If FastSymbol(A$, ",") Then
                                If IsExp(bstackstr, A$, p, , True, , True) Then
                                If Not FastSymbol(A$, "]") Then IsStr1 = False: SyntaxError: Exit Function
                                    GoTo contMem2Str
                                Else
                                    missNumber
                                    IsStr1 = False
                                    Exit Function
                                End If
                            End If
                            
                            If Not FastSymbol(A$, "]") Then IsStr1 = False: SyntaxError: Exit Function
                            If lookOne(A$, "|") Then GoTo CONThereUDT
                            ' get all as string
                            p = 0
contMem2Str:
                            
                            Set usehandler = var(w1)
                            r$ = usehandler.objref.CopyItemString(pp, p, par)
                            IsStr1 = par
                            Exit Function
                        End If
                    End If
                End If
                WrongObject
            End If
        Else
            MissingObj
        End If
     Else
        UnknownVariable q$
     End If
     IsStr1 = False
     Exit Function
    Case Else
checkpointer:
        If w1 = 1 Then
            If GetVar(bstackstr, q$, w1) Then
                If MyIsObject(var(w1)) Then
                    If TypeOf var(w1) Is Group Then
                        If var(w1).HasValue Then
                            If var(w1).HasValue And Not IsOperator(A$, "::", 2) Then
                                q1$ = q$ + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                                W = w1
                                If GetSub(q1$, w1) Then GoTo foundprivate
                            End If
                        ElseIf var(w1).IamApointer Then
                            Set bstackstr.lastpointer = var(w1)
                            If var(w1).link.IamFloatGroup Then
                                Set ppppL = BoxGroupVar(var(w1))
                                Mid$(A$, 1, 2) = "." + Chr(3)
                                IsStr1 = SpeedGroup(bstackstr, ppppL, "VAL$", "", A$, (0)) = 1
                                r$ = bstackstr.LastValue
                                Exit Function
                            Else
                                Mid$(A$, 1, 2) = Chr(0) + "."
                                GoTo againpointer
                            End If
                        ElseIf lookOne(A$, "#") Then
                            q$ = q$ + "$"
                            W = w1
                            GoTo Checkit
                        End If
                    ElseIf TypeOf var(w1) Is mHandler Then
                        If FastSymbol(A$, "#") Then
comehere:
                            p = vbNullString
                            IsStr1 = fMatrix(bstackstr, A$, var(w1), p)
                            If MemInt(VarPtr(p)) = vbString Then SwapString2Variant r$, p Else r$ = vbNullString
                            Exit Function
                        Else
                            pp = 0&
CONThereUDT:
                            Set usehandler = var(w1)
                            If Not usehandler.objref Is Nothing Then
                                If TypeOf usehandler.objref Is Enumeration Then
                                    If myVarType(usehandler.index_cursor, vbString) Then
                                        r$ = usehandler.index_cursor
                                        IsStr1 = True
                                        Exit Function
                                    Else
                                        If MyIsNumeric(usehandler.index_cursor) Then
                                        If CheckInt64(usehandler.index_cursor) Then
                                            r$ = CStr(usehandler.index_cursor)
                                        ElseIf myVarType(var(w1), vbBoolean) Then
                                            r$ = Format$(var(w1), DefBooleanString)
                                        Else
                                            r$ = fixthis(usehandler.index_cursor)
                                        End If
                                        IsStr1 = True
                                        End If
                                        Exit Function
                                    End If
                                Else
                                p = 0
                                If TakeOffset(bstackstr, usehandler, A$, p, pp) Then
                                    GoTo CONT1234s
                                End If
                                IsStr1 = False
                                Exit Function
                                End If
                                
                            End If
                        End If
                    ElseIf TypeOf var(w1) Is Constant Then
                        'var(w1).flag=true is a lambda function
                        '''''''''''''''''''''''''''''''''''Stop''''''''''''''''''''''''
                        If Not var(w1).flag Then
                            p = var(w1).Value
CONT1234s:
                            
                            If MemInt(VarPtr(p)) = vbString Then
                                SwapString2Variant r$, p
                            ElseIf MemInt(VarPtr(p)) = 20 Then
                                r$ = CStr(p)
                            ElseIf myVarType(p, vbBoolean) Then
                                r$ = Format$(p, DefBooleanString)
                            Else
                                r$ = fixthis(p)
                            End If
                            IsStr1 = True
                            Exit Function
                        End If
                ElseIf TypeOf var(w1) Is BigInteger Then
                    r$ = var(w1).ToString
                    IsStr1 = True
                    Exit Function

                    End If
                Else
                    If myVarType(var(w1), vbString) Then
                        r$ = var(w1)
                        IsStr1 = True
                        Exit Function
                    ElseIf Not myVarType(var(w1), vbObject) Then
                        If CheckInt64(var(w1)) Then
                           r$ = CStr(var(w1))
                        ElseIf myVarType(var(w1), vbBoolean) Then
                            r$ = Format$(var(w1), DefBooleanString)
                        Else
                            r$ = fixthis(var(w1))
                        End If
                        IsStr1 = True
                    End If
                    Exit Function
                End If
                
            ElseIf q$ = "ARRAY" Then
arrentry:
                If bstackstr.soros.Total = 0 Then
                   EmptyStack A$
                    IsStr1 = False: Exit Function
                ElseIf bstackstr.soros.StackItemTypeObjectType(1) = "*[mArray]" Then
                    Set bstackstr.lastobj = bstackstr.soros.PopObj
                    GoTo Final
                Else
                    StackTopNotArray A$
                    IsStr1 = False
                End If
                Exit Function
            ElseIf q$ = "пимайас" Then
                    GoTo arrentry
            ElseIf IsNumberNew(bstackstr, (q$), p, True) Then
            GoTo getsomethinghere
            End If
        End If
        IsStr1 = False
        Exit Function
    End Select
End If
conthere:
Select Case w1
Case 1
    GoTo checkpointer
    Case 3
        IsStr1 = False
        If usebackup Then
            If Not stridbackup.Find(q$, w1) Then GoTo itisavar
        Else
            If Not strid.Find(q$, w1, bstackstr.strnum) Then GoTo itisavar
            If w1 < 0 Then GoTo itisavar
        End If

findsecond:
    IsStr1 = strLiterals(w1, bstackstr, A$, r$)
    Exit Function
itisavar:
    If GetVar(bstackstr, q$, W) Then
        If MyIsObject(var(W)) Then
            If TypeOf var(W) Is lambda Then
                
                r$ = vbNullString
                var(W).CopyTo aaa, var()
                Set bstackstr.lastobj = aaa
                Set aaa = Nothing
            ElseIf TypeOf var(W) Is PropReference Then
                On Error Resume Next
                r$ = var(W).Value
                Set bstackstr.lastobj = var(W).lastobjfinal
                If Err Then r$ = vbNullString
            ElseIf TypeOf var(W) Is Group Then
Checkit:
                If var(W).HasValue And Not IsOperator(A$, "::", 2) Then
                    If Len(var(W).Patch) > 0 Then
                        q1$ = var(W).Patch + "." + ChrW(&H1FFF) + "$()"
                    Else
                        q1$ = Left$(q$, Len(q$) - 1) + "." + ChrW(&H1FFF) + "$()"
                    End If
                    If GetSub(q1$, w1) Then
foundprivate:
                        Set nbstack = New basetask
                        Set nbstack.Parent = bstackstr
                        If bstackstr.IamThread Then Set nbstack.Process = bstackstr.Process
                        Set nbstack.Owner = bstackstr.Owner
                        nbstack.OriginalCode = w1
                        nbstack.UseGroupname = sbf(w1).sbgroup
                        nbstack.tpointer = sbf(w1).tpointer
                        nbstack.SetV
                        If GoFunc(nbstack, q1$, ")", r$) Then
                            If Not nbstack.StaticCollection Is Nothing Then
                                bstackstr.Parent.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                            End If
                            If Mid$(A$, 1, 2) = "=>" Then
                                If Not nbstack.lastobj Is Nothing Then
                                    If TypeOf nbstack.lastobj Is Group Then
                                        If nbstack.lastobj.IamApointer Then
                                            Set ppppL = BoxGroupVar(nbstack.lastobj)
                                            Set nbstack = Nothing
                                            W = 0
                                            Mid$(A$, 1, 2) = "." + ChrW(3)
                                        End If
                                        GoTo groupstrvalue
                                    End If
                                End If
                            End If
                            Set nbstack = Nothing
                            IsStr1 = True
                            If FastSymbol(A$, "#") Then
                                p = vbNullString
                                Set pp = bstackstr.lastobj
                                If TypeOf pp Is mArray Then
                                    ' make it mhandler ??? check again
                                End If
                                Set bstackstr.lastobj = Nothing
                                IsStr1 = fMatrix(bstackstr, A$, pp, p)
                                If MemInt(VarPtr(p)) = vbString Then SwapString2Variant r$, p Else r$ = vbNullString
                                Exit Function
                            End If
                        Else
                            IsStr1 = False
                        End If
                    Else
                        w3 = rinstr(q$, ".", Len(var(W).GroupName) + 1)
                        s$ = Left$(q$, Len(q$) - 1)
                        q1$ = Left$(s$, w3) + ChrW(&HFFBF) + Mid$(s$, w3 + 1) + "." + ChrW(&H1FFF) + "$()"
                        If GetSub(q1$, w1) Then GoTo foundprivate
                        InternalError
                        IsStr1 = False
                    End If
                Else
                    r$ = vbNullString
                    Set bstackstr.lastobj = CopyGroupObj(var(W))
                End If
            ElseIf TypeOf var(W) Is Document Then
                r$ = var(W)
            ElseIf TypeOf var(W) Is Constant Then
                If var(W).flag Then
                    If VarTypeName(var(W).Value) = "lambda" Then
                        CopyLambda var(W).Value, bstackstr
                    End If
                Else
                    GoTo there12001
                End If
            Else
there12001:
                On Error Resume Next
                r$ = var(W).Value
                If Err > 0 Then
                    Err.Clear
                    r$ = var(W)
                    If Err > 0 Then
                        badread
                    End If
                End If
                On Error GoTo 0
            End If
        Else
            If myIsNull(var(W)) Then
                VarNull
                IsStr1 = False
                Exit Function
            Else
                r$ = var(W)
            End If
        End If
        IsStr1 = True
    Else
        If W = -1 Then
            r$ = ReadVarStr(bstackstr, q$)
            IsStr1 = True
            Exit Function
        End If
        IsStr1 = False
        ' MAKE LENGTH EQUAL...
        If stridbackup.Find(q$, w1) Then GoTo findsecond
        If w2 >= Len(A$) Then A$ = Left$(q$ + space$(Len(q$)), w2 - Len(A$)) + A$
        If FindNameForGroup(bstackstr, q$) Then
            MyErMacroStr A$, "Unknown property  " + q$, "╒ЦМЫСТГ ИДИЭТГТА " + q$
        Else
            UnknownVariable1 A$, q$
        End If
    End If
    Exit Function
Case 5
           ' check again
rvalObjectstring:
    If Left$(aheadstatus(q$ + CopyUntilEndOfLine(A$), False), 1) = "S" Then
enter2:
        If neoGetArray(bstackstr, q$, ppppL) Then
            If ppppL.Arr Then
                If FastSymbol(A$, ")") Then
                    If MaybeIsSymbol(A$, "#") Then Set bstackstr.lastobj = ppppL: GoTo Final
                End If
            End If
enterthis:
            If NeoGetArrayItem(ppppL, bstackstr, q$, W, A$, , , True, True) Then
                If Not ppppL.Arr And FastSymbol(A$, ")") Then
                    ' need an object
                    If IsNumber(bstackstr, q$ + ")", p) Then
                        If Not bstackstr.lastobj Is Nothing Then
                            Set pppp.GroupRef = bstackstr.lastobj
                            Set bstackstr.lastobj = Nothing
                            W = -2
                            If FastSymbol(A$, "(") Then
                                If NeoGetArrayItem(pppp, bstackstr, q$, W, A$, , , True) Then
                                End If
                            End If
                        End If
                    End If
                Else
enteragain:
                    If ppppL.ItemType(W) = mGroup Then
                        If ppppL.item(W).IamFloatGroup Then
                            If ppppL.item(W).IamApointer Then
                                If Mid$(A$, 1, 2) = "=>" Then Mid$(A$, 1, 2) = "." + ChrW(3)
                            End If
                            GoTo groupstrvalue
                        End If
                        If ppppL.GroupRef Is Nothing Then
                            GoTo groupstrvalue
                        Else
                            If Len(q$) > Len(ppppL.GroupRef.GroupName) Then
                                q1$ = Left$(q$, Len(q$) - 1) + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                            Else
                                q1$ = ppppL.GroupRef.GroupName + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                            End If
                        End If
                        q$ = BlockParam(A$)
                        A$ = Mid$(A$, Len(q$) + 2)
                        If GetSub(q1$, w1) Then
                            Set nbstack = New basetask
                            Set nbstack.Parent = bstackstr
                            If bstackstr.IamThread Then Set nbstack.Process = bstackstr.Process
                            Set nbstack.Owner = bstackstr.Owner
                            nbstack.OriginalCode = w1
                            nbstack.UseGroupname = sbf(w1).sbgroup
                            nbstack.tpointer = sbf(w1).tpointer
                            nbstack.SetV
                            If GoFunc(nbstack, q1$, q$ + ")", r$) Then
                                If Not nbstack.StaticCollection Is Nothing Then
                                    bstackstr.Parent.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                                End If
                                'Set bstackstr.lastobj = nBstack.lastobj
                                If IsOperator(A$, "(") Then
                                    Set ppppL = New ppppLight
                                    Set ppppL.GroupRef = bstackstr.lastobj
                                    Set bstackstr.lastobj = Nothing
                                    ppppL.Arr = False
                                    W = -2
                                    Set nbstack = Nothing
                                    GoTo contrightstrpar
                                ElseIf Left$(A$, 1) = "." Then
cont1002001:
                                     Set ppppL = New ppppLight
                                     Set ppppL.GroupRef = bstackstr.lastobj
                                     Set bstackstr.lastobj = Nothing
                                     ppppL.Arr = False
                                     W = -2
                                     Set nbstack = Nothing
                                     GoTo groupstrvalue
                                End If
                            End If
                                Set nbstack = Nothing
                                IsStr1 = True
                            Else
                                IsStr1 = False
                            End If
                        ElseIf ppppL.ItemType(W) = mHdlr Then
                        If FastSymbol(A$, "#") Then
                                p = vbNullString
                            IsStr1 = fMatrix(bstackstr, A$, ppppL.item(W), p)
                            If Left$(A$, 1) = "." And Not bstackstr.lastobj Is Nothing Then
                            If TypeOf bstackstr.lastobj Is Group Then
                            GoTo cont1002001
                            End If
                            End If
                            If MemInt(VarPtr(p)) = vbString Then SwapString2Variant r$, p Else r$ = vbNullString
                            Exit Function
                        Else
                        Set anything = pppp.item(W)
                        Set usehandler = anything
                        If usehandler.T1 = 3 Then
                        Set pppp = usehandler.objref
                        Set ppppL = pppp
                        Set usehandler = Nothing
                        GoTo enterthis
                        End If
                        Set usehandler = Nothing
                        End If
                        ElseIf ppppL.ItemType(W) = myArray And InStr(q$, "$") = 0 Then
                            If FastSymbol(A$, "#") Then
                                p = vbNullString
                                Set usehandler = New mHandler
                                Set usehandler.objref = ppppL.item(W)
                                    
                                IsStr1 = fMatrix(bstackstr, A$, usehandler, p)
jump1:
                                If Left$(A$, 1) = "." And Not bstackstr.lastobj Is Nothing Then
                                    If TypeOf bstackstr.lastobj Is Group Then
                                        GoTo cont1002001
                                    End If
                                End If
                                If MemInt(VarPtr(p)) = vbString Then SwapString2Variant r$, p Else r$ = vbNullString
                                Exit Function
                            Else
                                Set bstackstr.lastobj = pppp.item(4)
                                IsStr1 = True
                            End If
                        ElseIf Typename(ppppL.GroupRef) = mProp Then
                            p = ppppL.GroupRef.Value
                            Set bstackstr.lastobj = ppppL.GroupRef.lastobjfinal
                            If Not bstackstr.lastobj Is Nothing Then p = vbNullString
                            If FastSymbol(A$, "#") Then
                                    
                                If TypeOf bstackstr.lastobj Is mHandler Then
                                    Set usehandler = bstackstr.lastobj
                                    Set bstackstr.lastobj = Nothing
                                    IsStr1 = fMatrix(bstackstr, A$, usehandler, p)
                                    GoTo jump1
                                End If
                            ElseIf bstackstr.lastobj Is Nothing Then
                                r$ = ""
                                Exit Function
                            End If
                        ElseIf Not ppppL.IsObjAt(W, p) Then
getsomethinghere:
                            If MemInt(VarPtr(p)) = vbString Then
                                SwapString2Variant r$, p
                            Else
                                If CheckInt64(p) Then
                                    r$ = CStr(p)
                                ElseIf myVarType(p, vbBoolean) Then
                                    r$ = Format$(p, DefBooleanString)
                                ElseIf myVarType(p, vbUserDefinedType) Then
                                    If FastOperator(A$, "|", (1)) Then
                                        w2 = IsLabel(bstackstr, A$, s$)
                                        If w2 > 0 Then
                                            pp = GetUDTValue(p, s$)
                                            GoTo there12345
                                        End If
                                    End If
                                Else
                                    r$ = fixthis(p)
                                End If
                            End If
                            IsStr1 = True
                        Else
                            IsStr1 = False
                        End If
                        Exit Function
                    End If
groupstrvalue:
                    If ppppL.ItemType(W) = mGroup Then
                        IsStr1 = SpeedGroup(bstackstr, ppppL, "VAL$", q$, A$, W) = 1
                        r$ = bstackstr.LastValue
                        Exit Function
                    End If
                Else
                    If Not pppp Is Nothing Then
                        If Not anything Is Nothing Then
                        If myVarType(pppp.item(W), vbObject) Then If anything Is pppp.item(W) Then Exit Function
                        Else
                        If pppp.Arr Then
                        If FastSymbol(A$, ")") Then Set bstackstr.lastobj = pppp: GoTo Final
                        Exit Function
                        End If
                        End If
                           Set anything = pppp.item(W)
                            If CheckLastHandler(anything) Then
                                Set usehandler = anything
                                If usehandler.T1 = 3 Then
                                    If TypeOf usehandler.objref Is mArray Then
                                        Set pppp = usehandler.objref
                                        Set ppppL = pppp
                                        Set usehandler = Nothing
                                    Else
                                        Exit Function
                                    End If
                                Else
                                    Set ppppL = New ppppLight
                                    ppppL.Arr = False
                                    Set ppppL.GroupRef = anything
                                End If
                                Set usehandler = Nothing
                                If NeoGetArrayItem(pppp, bstackstr, q$, W, A$) Then
                                    GoTo enteragain
                                Else
                                    If Not pppp Is Nothing Then
                                        If W < 0 Then
                                        Set usehandler = pppp.item(W)
                                        If Typename(usehandler.objref) = myArray Then
                                            Set pppp = usehandler.objref
                                            Set ppppL = pppp
                                        End If
                                        Set usehandler = Nothing
                                        GoTo enterthis
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            Else
                If usebackup Then
                    If Not strfunidbackup.Find(q$, w1) Then GoTo isasub ' Exit Function
                Else
                    If Not strfunid.Find(q$, w1, bstackstr.strnum) Then
                        q1$ = q$ + ")"
                    If GetSub(q1$, w1) Then
                        Set nbstack = New basetask
                        Set nbstack.Parent = bstackstr
                        Set nbstack.Owner = bstackstr.Owner
                        nbstack.UseGroupname = sbf(w1).sbgroup
                        nbstack.tpointer = sbf(w1).tpointer
                        nbstack.OriginalCode = w1
                        nbstack.SetV
                        If GoFunc(nbstack, q1$, A$, s$, , , True) Then
                            If Not nbstack.StaticCollection Is Nothing Then
                                bstackstr.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                            End If
                            Set bstackstr.lastobj = nbstack.lastobj
                            Set nbstack = Nothing
                            SwapStrings r$, s$
                            s$ = vbNullString
                            If bstackstr.lastobj Is Nothing Then
                                IsStr1 = True
                                Exit Function
                            End If
                            GoTo Final
                        Else
                            IsStr1 = False
                    End If
                End If
                Exit Function
            End If
            If w1 < 0 Then Exit Function
        End If
        On w1 GoTo F1, f2, f3, f4, f5, f6, f7
    Exit Function
F1: ' "STACKITEM(", "тилгсыяоу("
            IsStr1 = StackItem(bstackstr, A$, p)
            GoTo Final
f2: ' "ARRAY(", "пимайас("
            IsStr1 = IsArrayFun(bstackstr, A$, p)
            GoTo Final
f3: ' "CONS(", "емысг("
            IsStr1 = IsCons(bstackstr, A$, p)
            GoTo Final
f4: ' "CAR(", "пяыто("
            IsStr1 = IsCar(bstackstr, A$, p)
            GoTo Final
f5: ' "CDR(", "еполема("
            IsStr1 = IsCdr(bstackstr, A$, p)
            GoTo Final
f6: ' "VAL(", "тилг(", "аниа("
            IsStr1 = IsVal(bstackstr, A$, p, Left$(q$, 1) = "V")
            GoTo Final
f7: ' "EVAL(", "ейжя(", "ейжяасг("
            IsStr1 = IsEval(q$, bstackstr, A$, p)

Final:
           If FastSymbol(A$, "#") Then
                p = vbNullString
                Set pp = bstackstr.lastobj
                Set bstackstr.lastobj = Nothing
                IsStr1 = fMatrix(bstackstr, A$, pp, p)
                If MemInt(VarPtr(p)) = vbString Then SwapString2Variant r$, p Else r$ = vbNullString
    
                Exit Function
            ElseIf Left$(A$, 2) = "=>" Then
                    If TypeOf bstackstr.lastobj Is Group Then
                    Set ppppL = BoxGroupVar(bstackstr.lastobj)
                    Set nbstack = Nothing
                    Set bstackstr.lastobj = Nothing
                    W = 0
                    Mid$(A$, 1, 2) = "." + ChrW(3)
                    GoTo groupstrvalue
                    End If
            ElseIf MemInt(VarPtr(p)) = vbString Then
                SwapString2Variant r$, p
                IsStr1 = True
                Exit Function
            Else
                If CheckInt64(p) Then
                    r$ = CStr(p)
                ElseIf myVarType(p, vbBoolean) Then
                    r$ = Format$(p, DefBooleanString)
                Else
                    r$ = fixthis(p)
                End If
                IsStr1 = True
                Exit Function
            End If
            End If
        Else
       ' If neoGetArray(bstackstr, q$, pppp) Then
            GoTo enter2
            
        'End If
            IsStr1 = False
            Exit Function
        End If

Case 6
    IsStr1 = False
    If usebackup Then
        If Not strfunidbackup.Find(q$, w2) Then
        GoTo isasub
        End If
    Else
        If Not strfunid.Find(q$, w2, bstackstr.strfunnum) Then GoTo itisarrayorfunction
        If w2 < 0 Then GoTo itisarrayorfunction
    End If
findthird:
IsStr1 = strFunctions(w2, q$, bstackstr, A$, r$)
Exit Function
itisarrayorfunction:
    q1$ = q$
    If Right$(q1$, 1) <> ")" Then q1$ = q1$ + ")"
    MakeThisSubNum bstackstr, q1$
            If IsSymbol(A$, "*") Then
            'is a function allways...
            If GetlocalSub(q1$, w1) Then
                GoTo contStrFun
            ElseIf GetSub(q1$, w1) Then
                GoTo contStrFun
            ElseIf GetSub2(bstackstr, q1$, w1) Then
                GoTo contStrFun
            Else
            If Len(bstackstr.UseGroupname) > 0 Then
            If InStr(q1$, bstackstr.UseGroupname) = 1 Then
            q1$ = bstackstr.UseGroupname + ChrW(&HFFBF) + Mid$(q1$, Len(bstackstr.UseGroupname) + 1)
            If GetSub(q1$, w1) Then GoTo contStrFun

            End If
            End If
                GoTo skiperrorStr
            End If
            
            Else
            
            If neoGetArray(bstackstr, q$, ppppL, , , True) Then
                
                GoTo contStrArr
            ElseIf GetlocalSub(q1$, w1) Then
                GoTo contStrFun
            ElseIf neoGetArray(bstackstr, q$, ppppL, , True) Then
                GoTo contStrArr
            ElseIf GetSub2(bstackstr, q1$, w1) Then
                GoTo contStrFun
            ElseIf GetSub(q1$, w1) Then
                GoTo contStrFun
            Else
            If Len(bstackstr.UseGroupname) > 0 Then
            If InStr(q1$, bstackstr.UseGroupname) = 1 Then
            q1$ = bstackstr.UseGroupname + ChrW(&HFFBF) + Mid$(q1$, Len(bstackstr.UseGroupname) + 1)
            If GetSub(q1$, w1) Then GoTo contStrFun
            End If
            End If

                GoTo skiperrorStr
            End If
            End If

    
        If GetSub(q1$, w1) Then
contStrFun:
    If bstackstr.NoFuncError Then
    r$ = q$
                CallNext bstackstr, A$, par, p, r$
                    If par Then
                        IsStr1 = True
                    Else
                        r$ = vbNullString
                        IsStr1 = False
                    End If
                Else
                Set nbstack = New basetask
                Set nbstack.Parent = bstackstr
                Set nbstack.Owner = bstackstr.Owner
                nbstack.UseGroupname = sbf(w1).sbgroup
                nbstack.tpointer = sbf(w1).tpointer
                nbstack.OriginalCode = w1
                nbstack.SetV
                If GoFunc(nbstack, q1$, A$, s$, , , True) Then
                    If Not nbstack.StaticCollection Is Nothing Then
                        bstackstr.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                    End If
                    Set bstackstr.lastobj = nbstack.lastobj
                    SwapStrings r$, s$
                    s$ = vbNullString
                    IsStr1 = True
                Else
                    IsStr1 = False
                End If
                End If
            Exit Function
        ElseIf neoGetArray(bstackstr, q$, ppppL) Then
contStrArr:
            
            If ppppL.Arr Then
            If TypeOf ppppL Is mArray Then
                Set pppp = ppppL
                If FastSymbol(A$, ")") Then
                    IsStr1 = True
                    p = 0
                    Set bstackstr.lastobj = pppp
                    Exit Function
                End If
                dn = 0
                
                dd = pppp.bDnum - 1
                If dd < 0 Then
                    If Typename(pppp.GroupRef) = mProp Then
                    
                    GoTo contreadprop
                    End If
                End If
            Else
            SyntaxError
            Exit Function
            End If
            p = 0
            pp = 0
        IsStr1 = True
        w2 = 0
        Do While dn <= dd
        pppp.GetDnum dn, w3, w1
        If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
        If dn < dd Then
            If Not FastSymbol(A$, ",") Then MyErMacroStr A$, "need index for " + q$ + ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " + q$ + ")": IsStr1 = False: Exit Do
            Else
            If FastSymbol(A$, ",") Then
            IsStr1 = False
            MyErMacroStr A$, "too many indexes for array " + q$ + ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " + q$ + ")"
        Exit Function
        End If
            If Not FastSymbol(A$, ")") Then MissSymbol ")": IsStr1 = False: Exit Function
        End If
              If p < -w1 Then
                 MyErMacroStr A$, "index too low for array " + q$ + ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " + q$ + ")": Exit Function
    
                End If
            On Error Resume Next
        If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
        
            MyErMacroStr A$, "index too high for array " + q$ + ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " + q$ + ")"
            IsStr1 = False: Exit Function
            End If
            On Error GoTo 0
              Else
        IsStr1 = False
        
          MyErMacroStr A$, "missing index for array " + q$ + ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " + q$ + ")"
        Exit Function
    
        End If
        dn = dn + 1
        Loop
    If pppp.ItemIsObject(w2) Then
        If FastSymbol(A$, "(") Then
            If pppp.ItemType(w2) = "lambda" Then
                Set anything = pppp.item(w2)
contlambdastr:
              
                PushStage bstackstr, False
                w1 = globalvarGroup("A_" & (Abs(w2)), 0#)
                Set var(w1) = anything
                If here$ = vbNullString Then
                    dd = ModuleSubAsap("A_" & (Abs(w2)) & "$()", "", , w1)
                Else
                    dd = ModuleSubAsap(here$ & "." & bstackstr.GroupName & "A_" & (Abs(w2)) & "$()", "", , w1)
                End If
againlambda:
                
                'a$ = "A_" & (Abs(w2)) & "$(" + a$
                bstackstr.tmpstr = "A_" & (Abs(w2)) & "$(" + Left$(A$, 1)
                BackPort A$
                IsStr1 = IsStr1(bstackstr, A$, r$)
                If Typename(bstackstr.lastobj) = "lambda" Then
                If Left$(A$, 1) = "(" Then
                    Mid$(A$, 1, 1) = " "
                    Set var(w1) = bstackstr.lastobj
                    Set bstackstr.lastobj = Nothing
                    GoTo againlambda
                End If
                
                End If
                Set var(w1) = Nothing
                PopStage bstackstr
                
            ElseIf pppp.ItemType(w2) = mHdlr Then
                Set bstackstr.lastobj = pppp.item(w2)
                Set ppppL = New ppppLight
                ppppL.Arr = False
                Set ppppL.GroupRef = bstackstr.lastobj
                Set bstackstr.lastobj = Nothing
                GoTo contStrArr
            ElseIf pppp.ItemType(w2) = myArray Then
                Set ppppL = pppp.item(w2)
                GoTo contStrArr
            ElseIf pppp.ItemType(w2) = mGroup Then
                Set ppppL = pppp
                IsStr1 = SpeedGroup(bstackstr, ppppL, "VAL$", q$, A$, w2) = 1
                r$ = bstackstr.LastValue
                Exit Function
            ElseIf pppp.ItemType(w2) = mProp Then
                 ' a$(2)(...
                 p = 0
                 pppp.SwapItem w2, p
                 Set anything = p
                 pppp.SwapItem w2, p
                 Set ppppL = New ppppLight
                 Set ppppL.GroupRef = anything
                 Set anything = Nothing
                 ppppL.Arr = False
                 GoTo contreadprop
            End If
        ElseIf pppp.ItemType(w2) = mGroup Then
                Set ppppL = pppp
                IsStr1 = SpeedGroup(bstackstr, ppppL, "VAL$", q$, "", w2) = 1
                r$ = bstackstr.LastValue
                Exit Function
        ElseIf pppp.ItemIsObject(w2) Then
                    p = rValue(bstackstr, pppp.itemObject(w2))
                    If bstackstr.lastobj Is Nothing Then
                        If TypeOf pppp.itemObject(w2) Is Document Then
                            r$ = pppp.item(w2)
                        Else
                            On Error Resume Next
                            r$ = pppp.item(w2)
                            If Err > 0 Then
                                Err.Clear
                                r$ = CStr(pppp.item(w2).Value)
                                If Err Then
                                    MyEr "Can't fing value in this object", "дЕМ ЛПОЯЧ МА БЯЫ ТИЛч СЕ АУТЭ ТО АМТИЙЕъЛЕМО"
                                    IsStr1 = False
                                    Exit Function
                                End If
                            End If
                        End If
                    End If
                    IsStr1 = True
                    Exit Function
                Else
                    r$ = pppp.item(w2)
                End If
            Else
                 If pppp.IsStringItem(w2) Then
                        r$ = pppp.item(w2)
                 Else
                        p = pppp.item(w2)
                        If myVarType(p, vbEmpty) Then
                            r$ = ""
                        ElseIf CheckInt64(p) Then
                            r$ = CStr(p)
                        ElseIf myVarType(p, vbBoolean) Then
                            r$ = Format$(p, DefBooleanString)
                        Else
                            r$ = fixthis(p)
                        End If
                End If
            End If
            IsStr1 = True
        Exit Function
Else
contrightstrpar:

    If Typename(ppppL.GroupRef) = mHdlr Then
        Set usehandler = ppppL.GroupRef
        If usehandler.T1 <> 1 Then
            If usehandler.T1 = 3 Then
                Set ppppL = usehandler.objref
                Set usehandler = Nothing
                GoTo contStrArr
            Else
                SyntaxError
                IsStr1 = False
                Exit Function
            End If
        End If
    ' only for Inventory
        If Not TypeOf usehandler.objref Is FastCollection Then
            Set ppppL.GroupRef = usehandler.objref
            Set usehandler = Nothing
            GoTo contrightstrpar
        End If
       ' Set usehandler = pppp.GroupRef
        With usehandler.objref
            If IsExp(bstackstr, A$, p, , True) Then
                If MemInt(VarPtr(p)) = vbString Then r$ = p: GoTo str00012344
                If MemInt(VarPtr(p)) = vbBoolean Then p = CLng(p)
                If FastSymbol(A$, "!") Then
                    If Abs(p) < .count Then
                        If p < 0 Then
                            .Index = .count + MyRound(p)
                        Else
                            .Index = MyRound(p)
                        End If
                    Else
                        MyErMacroStr A$, "Index out of limits", "дЕъЙТГР ЕЙТЭР ОЯъЫМ"
                        IsStr1 = False
                        Exit Function
                    End If
                Else
                    .Find p
                End If
            ElseIf IsStrExp(bstackstr, A$, r$) Then
str00012344:
                .Find r$
            End If
            If .Done Then
                If .IsObj Then
                    If TypeOf .ValueObj Is lambda Then
                        If FastSymbol(A$, ")(", , 2) Then
                            Set anything = .ValueObj
                            GoTo contlambdastr
                        Else
                            Set bstackstr.lastobj = .ValueObj
                        End If
                    ElseIf TypeOf .ValueObj Is mArray Then
                    Set ppppL = .ValueObj
                    If FastSymbol(A$, ")(", , 2) Then GoTo contStrArr
                ElseIf TypeOf .ValueObj Is mHandler Then
                    Set ppppL = New ppppLight
                    
                    Set ppppL.GroupRef = .ValueObj
                        If FastSymbol(A$, ")(", , 2) Then GoTo contStrArr
                    ElseIf TypeOf .ValueObj Is Document Then
                        r$ = .ValueObj.textDoc
                    ElseIf TypeOf .ValueObj Is Group Then
                        Set usehandler = pppp.GroupRef
                        Set anything = usehandler.objref
                        dd = anything.Index
                        Set pppp = New mArray: pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
                        Set pppp.item(0) = .ValueObj
                        w2 = 0
                        IsStr1 = IsStr1 And FastSymbol(A$, ")")  ' ????
                        ' why not = IsStr1 And SpeedGroup(bstackstr, pppp, "VAL$", q$, a$, w2) = 1
                        IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", q$, A$, w2) = 1
                        r$ = bstackstr.LastValue
                        anything.Index = dd
                        Set .ValueObj = pppp.item(0)
                        Set pppp.item(0) = Nothing
                        Exit Function
                    ElseIf TypeOf .ValueObj Is PropReference Then
                        .ValueObj.Index = p
                        r$ = .ValueObj.Value
                        Set bstackstr.lastobj = .ValueObj.lastobjfinal
                        IsStr1 = IsStr1 And FastSymbol(A$, ")")
                    Else
                        MyErMacroStr A$, "This kind of object not supported", "аУТОЩ ТОУ ЕъДОУР ТО АМТИЙЕъЛЕМО ДЕМ УПОСТГЯъФЕТАИ"
                    End If
                Else
                    Call .ValueType(2, p, r$)
                End If
            Else
                MyErMacroStr A$, "Key Not Found", "дЕМ БЯщХГЙЕ ТО ЙКЕИДъ"
            End If
        End With
    ElseIf Typename(ppppL.GroupRef) = mGroup Then
        If Len(q$) > Len(ppppL.GroupRef.GroupName) Then
            If Len(ppppL.CodeName) > 0 Then
                If AscW(ppppL.CodeName) = 8191 Then
                q1$ = Left$(q$, Len(q$) - 2) + "." + ChrW(&H1FFF) + "$()"
                Else
                q1$ = ppppL.CodeName + "." + ChrW(&H1FFF) + "$()"
                End If
            Else
                q1$ = Left$(q$, Len(q$) - 2) + "." + ChrW(&H1FFF) + "$()"
            End If
        Else
            q1$ = ppppL.GroupRef.GroupName + ChrW(&H1FFF) + "$()"
        End If
        If GetSub(q1$, w1) Then
            Set nbstack = New basetask
            Set nbstack.Parent = bstackstr
            If bstackstr.IamThread Then Set nbstack.Process = bstackstr.Process
            Set nbstack.Owner = bstackstr.Owner
            nbstack.OriginalCode = w1
            nbstack.UseGroupname = sbf(w1).sbgroup
            nbstack.tpointer = sbf(w1).tpointer
            nbstack.SetV
            If GoFunc(nbstack, q1$, A$, r$) Then
                If Not nbstack.StaticCollection Is Nothing Then
                    bstackstr.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                End If
                'Set bstackstr.lastobj = nBstack.lastobj
                Set nbstack = Nothing
                IsStr1 = True
            Else
                IsStr1 = False
            End If
        Else
            InternalError
            IsStr1 = False
        End If
        Exit Function
    Else
contreadprop:
        If Not getindexes(bstackstr, ppppL.GroupRef, A$) Then
            On Error Resume Next
                r$ = ppppL.GroupRef.Value
                If Err.Number > 0 Then
                    ppppL.GroupRef.IndexAgain
                    If Typename(ppppL.GroupRef.Value) = "Null" Then
                        r$ = ""
                        Err.Clear
                    Else
                        InStr = False
                        MyEr Err.Description, Err.Description
                        Err.Clear
                        Exit Function
                    End If
                End If
           Else
                Set bstackstr.lastobj = pppp
                r$ = vbNullString
           End If
                      
                End If
                  IsStr1 = FastSymbol(A$, ")")
                Exit Function
            End If
        Else  '......
skiperrorStr:
            If Right$(q1$, 1) = ")" Then
                If here$ Like "*." + q1$ Then
                    subHash.ItemCreatorNoSwap q1$, bstackstr.OriginalCode, True
                    GoTo contStrFun
            ElseIf q1$ = "LAMBDA$()" Then
contlambda01:
                If bstackstr.IamLambda Then
                    q1$ = bstackstr.FuncRec
                Else
                    q1$ = Mid$(here$, rinstr(here$, "╩.") + 2)
                    If Right$(here$, 2) = "()" And bstackstr.UseGroupname = vbNullString Then
                        q1$ = sbf(bstackstr.OriginalCode).goodname
                        w1 = bstackstr.OriginalCode
                    ElseIf Not GetSub(q1$, w1) Then
                        If here$ Like "*." + q1$ Then
                            q1$ = sbf(bstackstr.OriginalCode).goodname
                            w1 = bstackstr.OriginalCode
                        Else
                            GoTo skiperrorStr
                        End If
                    End If
                End If
                GoTo contStrFun
            ElseIf q1$ = "калда$()" Then
                GoTo contlambda01
            ElseIf neoGetArray(bstackstr, Left$(q1$, Len(q1$) - 3) + "(", ppppL, , True) Then
                If Typename(ppppL.GroupRef) = mGroup Then
                    If Typename(ppppL) = "mArray" Then
                        q$ = Left$(q1$, Len(q1$) - 3)
                        Set pppp = ppppL
                        pppp.CodeName = q$
                    End If
                End If
                GoTo contStrArr
            End If
            
        End If
        
        If strfunidbackup.Find(q$, w2) Then GoTo findthird
        If FindNameForGroup(bstackstr, q$) Then
            MyErMacroStr A$, "unknown method/array  " + q$, "╒ЦМЫСТГ ЛщХОДОР/ПъМАЙАР " + q$
        Else
            MyErMacroStr A$, "unknown function/array " + q$, "╒ЦМЫСТГ СУМэЯТГСГ/ПъМАЙАР " + q$
        End If
        Exit Function
    End If
Case 106
isasub:
    If CurrentStackSize > stacksize Then
        MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
        MOUT = True
        IsStr1 = False: Exit Function
    End If
    w1 = bstackstr.soros.Total
    If Not PushParamSUB(bstackstr, A$) Then
        w1 = bstackstr.soros.Total - w1
        If w1 > 0 Then bstackstr.soros.drop w1
        IsStr1 = False:  Exit Function
    End If
    If FastSymbol(A$, ")") Then
        PushStage bstackstr, False
        w2 = bstackstr.OriginalCode
        q1$ = bstackstr.originalname$
        bstackstr.originalname$ = q2$ + ")"
        If gr Then
            q2$ = "сумаятгсг " + q2$
        Else
            q2$ = "FUNCTION " + q2$
        End If
        If searchsub(w2, q2$, w1, w2, n$, True) Then
againsub:
            If Len(q2$) > 0 Then
                If Not MyRead(7, bstackstr, q2$, 1) Then
                    bstackstr.originalname$ = q1$
                    PopStage bstackstr
                    IsStr1 = False
                    Exit Function
                End If
            End If
            bstackstr.FuncValue = vbNullString
            Set bstackstr.FuncObj = Nothing
            dn = bstackstr.addlen
            bstackstr.RetStack.Push3long Len(A$), 0, Len(A$) - Len(n$)
            If trace Then
            q2$ = TestShowSub: sg1 = TestShowBypass
            If w2 > 0 Then
                bstackstr.addlen = Len(sbf(w2).sb) - w1 - Len(n$) + 1
                TestShowSub = sbf(w2).sb
            ElseIf w2 = 0 Then
                bstackstr.addlen = 0
                TestShowSub = n$
            Else
                bstackstr.addlen = Len(var(-w2).code) - w1 - Len(n$) + 1
                TestShowSub = var(-w2).code
            End If
            TestShowBypass = True
            dd = 1
            executeblock dd, bstackstr, n$, False, False, , True
            SwapStrings q2$, TestShowSub: TestShowBypass = sg1
            Else
            dd = 1
            executeblock dd, bstackstr, n$, False, False, , True
            End If
            bstackstr.RetStackDrop 1
            bstackstr.addlen = dn
            If dd > 0 Then
                IsStr1 = True
                Set bstackstr.lastobj = bstackstr.FuncObj
                Set bstackstr.FuncObj = Nothing
                If myVarType(bstackstr.FuncValue, vbString) Then
                
                r$ = bstackstr.FuncValue
                Else
                r$ = fixthis(bstackstr.FuncValue)
                End If
                bstackstr.FuncValue = Empty
            Else
                IsStr1 = False
                If bstackstr.ErrorOriginal = 0 Then
                    LastErNum = -1
                    LastErNum1 = -1
                    bstackstr.ErrorOriginal = w2
                    If w2 > 0 Then
                        A$ = n$ + space$(Len(sbf(w2).sb) - w1 + 1)
                    ElseIf w2 = 0 Then
                        A$ = n$
                    Else
                        A$ = n$ + space$(Len(var(-w2).code) - w1 + 1)
                    End If
                End If
                Exit Function
            End If
            If usebackup Then
                    If Not bstackstr.lastobj Is Nothing Then
                        If InStr(q$, "$") = 0 Then GoTo Final
                    End If
            End If
        ElseIf bstackstr.IamChild Then
            dn = FindPrevOriginal(bstackstr)
            If searchsub(dn, q2$, w1, w2, n$, True) Then
                    If dn <> w2 And w2 < 0 Then
                        w2 = dn
                    End If
                GoTo againsub
            Else
                GoTo nofun1
            End If
        Else
nofun1:
            MyEr "Function @" + Mid$(q2$, InStr(q2$, " ") + 1) + ") not found", "г СУМэЯТГСГ @" + Mid$(q2$, InStr(q2$, " ") + 1) + ") ДЕМ БЯщХГЙЕ"
            IsStr1 = False
        End If
        bstackstr.originalname$ = q1$
        PopStage bstackstr
        
    Else
        IsStr1 = False
    End If
    Exit Function
End Select
If A$ = vbNullString Then IsStr1 = False: Exit Function
IsStr1 = True
End Function
Function mDate(bstackstr As basetask, A$, r$) As Boolean
    mDate = True
    Dim pp, p, s$
    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
        If FastSymbol(A$, ",") Then
            If IsExp(bstackstr, A$, pp, flatobject:=True) Then
                If Typename(pp) = "String" Then
                    s$ = pp
                    pp = Clid
                    GoTo here1
                End If
            ElseIf IsStrExp(bstackstr, A$, s$, False) Then
                    pp = Clid
                    GoTo here1
            Else
                MissParam A$
                mDate = False
                Exit Function
            End If
            If FastSymbol(A$, ",") Then
                If IsStrExp(bstackstr, A$, s$, False) Then
here1:
                    If UCase(s$) = "SHORT DATE" Then
                        s$ = GetlocaleString2(&H1F, pp)
                    ElseIf UCase(s$) = "LONG DATE" Then
                        s$ = GetlocaleString2(&H20, pp)
                    End If
                    r$ = FormatDateWithLocale(s$, CDate(p), pp)
                Else
                    MissParam A$
                    mDate = False
                    Exit Function
                End If
            Else
                r$ = FormatDateWithLocale(GetlocaleString2(&H1F, pp), CDate(p), pp)
            End If
        Else
           ' R$ = Format(CDbl(CDate(p)), "SHORT DATE")
            r$ = FormatDateWithLocale(GetlocaleString2(&H1F, Clid), CDate(p), Clid)
        End If
    Else
        MissParam A$
        mDate = False
        Exit Function
    End If
    If Not FastSymbol(A$, ")") Then mDate = False:
End Function
Function ISSTRINGA(bb$, r$) As Boolean
'
Dim q$, W As Long, A$
A$ = NLtrim$(bb$)
r$ = vbNullString
If A$ = vbNullString Then Exit Function
Select Case AscW(A$)
Case 1
q$ = Chr(1)
Case 2
r$ = Mid$(A$, 2, 8)
r$ = Mid$(A$, 10, CLng("&H" + r$))
bb$ = Mid$(A$, Len(r$) + 10)
ISSTRINGA = True
Exit Function
Case 34
q$ = Chr(34)
End Select
If q$ = vbNullString Or Len(A$) < 2 Then ISSTRINGA = False: Exit Function
If q$ = Chr(34) Then
    W = 1
    Do
    W = W + 1
    W = InStr(W, A$, q$)
    If W > 0 Then
    If Mid$(A$, W - 1, 1) <> "\" Then Exit Do
    ElseIf W = 0 Then
    Exit Do
    End If
    Loop

Else
W = InStr(2, A$, q$, vbBinaryCompare)
End If
If W = 0 Then ISSTRINGA = False: Exit Function
r$ = Mid$(A$, 2, W - 2)
bb$ = NLtrim$(Mid$(A$, W + 1))

ISSTRINGA = True

End Function
Function IsOperator(A$, c$, Optional cl As Long = 1) As Boolean
If Len(A$) > 0 Then
If Left$(A$, cl) = c$ Then
    A$ = NLtrim$(Mid$(A$, cl + 1))
    IsOperator = True
End If
End If
End Function
Function IsOperator0(A$, c$, Optional cl As Long = 1) As Boolean
Dim n$
If Len(A) > 0 Then
If Left$(A$, cl) = c$ Then  ' no letters in operator so no UCASE
' check next character
n$ = Left$(Mid$(A$, cl + 1, 1) + " ", 1)
    If Not InStr(novalidstr, n$) > 0 Then
    
    A$ = NLtrim$(Mid$(A$, cl + 1))
    IsOperator0 = True
    End If
End If
End If
End Function
Function IsOperatorNoRemove(A$, c$, Optional cl As Long = 1) As Boolean
Dim n$
If Len(A) > 0 Then
If Left$(A$, cl) = c$ Then  ' no letters in operator so no UCASE
' check next character
n$ = Left$(Mid$(A$, cl + 1, 1) + " ", 1)
    If Not InStr(novalidstr, n$) > 0 Then
    
    
    IsOperatorNoRemove = True
    End If
End If
End If
End Function
Function codeW(A$) As Long
If A$ <> "" Then
If AscW(A$) < 128 Then codeW = 1
End If
End Function


Function IsSymbol(A$, c$, Optional L As Long = 1, Optional mis As Boolean = False) As Boolean
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I <= j Then

If myUcase(Mid$(A$, I, L)) = c$ Then
A$ = NLtrim$(Mid$(A$, L + I))
IsSymbol = True

 Else
 If mis Then
 MissSymbol c$
 ElseIf I > 1 Then
 A$ = Mid$(A$, I)
 End If
IsSymbol = False
End If
Else
 If mis Then
 MissSymbol c$
 Else
 A$ = vbNullString
 End If
IsSymbol = False
End If
End Function

Function IsSymbolBracket(A$) As Boolean
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
If Mid$(A$, I, 1) = "{" Then
A$ = Mid$(A$, I + 1)
IsSymbolBracket = True
End If
End Function


Private Function IsSymbol3(A$, c$) As Boolean
' SAME AS FASTSYMB WITHOUT trim after
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
If j - I > -1 Then
If c$ = Mid$(A$, I, 1) Then
A$ = Mid$(A$, I + 1)
IsSymbol3 = True
End If
End If
End Function
'
Function Fast2NoSpace(A$, c$, cl As Long, D$, dl As Long, ahead&) As Boolean
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
Pad$ = myUcase(Left$(A$, ahead&))
If c$ = Left$(Pad$, cl) Then
j = MyTrimLi(A$, cl + 1)
check:
If Len(Mid$(A$, j, 1)) > 0 Then
Select Case AscW(Mid$(A$, j, 1))
Case 36, 37, 40, 46, 48 To 57, 95, Is < 0, Is > 64
Fast2NoSpace = False
Case Else
A$ = Mid$(A$, j)
Fast2NoSpace = True
End Select
Else
A$ = Mid$(A$, j)
Fast2NoSpace = True
End If
Exit Function
End If
If D$ = Left$(Pad$, dl) Then
j = MyTrimLi(A$, dl + 1)
GoTo check
End If
End Function
Function Fast3NoSpaceCheck(Pos As Long, A$, c$, cl As Long, D$, dl As Long, E$, el As Long, ahead&) As Boolean
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
Pad$ = myUcase(Mid$(A$, Pos, ahead&))
If c$ = Left$(Pad$, cl) Then
    Pos = Pos + cl
    Fast3NoSpaceCheck = True
Exit Function
End If
If D$ = Left$(Pad$, dl) Then
Pos = Pos + dl
Fast3NoSpaceCheck = True
Exit Function
End If
If E$ = Left$(Pad$, el) Then
Pos = Pos + el
Fast3NoSpaceCheck = True
End If

End Function
Function Fast3NoSpace(A$, c$, cl As Long, D$, dl As Long, E$, el As Long, ahead&) As Boolean
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
Pad$ = myUcase(Left$(A$, ahead&))
If c$ = Left$(Pad$, cl) Then
A$ = Mid$(A$, MyTrimLi(A$, cl + 1))
Fast3NoSpace = True
Exit Function
End If
If D$ = Left$(Pad$, dl) Then
A$ = Mid$(A$, MyTrimLi(A$, dl + 1))
Fast3NoSpace = True
Exit Function
End If
If E$ = Left$(Pad$, el) Then
A$ = Mid$(A$, MyTrimLi(A$, el + 1))
Fast3NoSpace = True
End If

End Function
Function Fast3Label(A$, c$, cl As Long, D$, dl As Long, E$, el As Long, ahead&) As Boolean
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
Pad$ = myUcase(Mid$(A$, I, ahead&)) + " "
If j - I >= cl - 1 Then
If InStr(c$, Left$(Pad$, cl)) > 0 Then
If Mid$(Pad$, cl + 1, 1) Like "[0-9+.\( @-]" Then
A$ = Mid$(A$, MyTrimLi(A$, I + cl))
Fast3Label = True
End If
Exit Function
End If
End If
If j - I >= dl - 1 Then
If InStr(D$, Left$(Pad$, dl)) > 0 Then
If Mid$(Pad$, dl + 1, 1) Like "[0-9+.\( @-]" Then
A$ = Mid$(A$, MyTrimLi(A$, I + dl))
Fast3Label = True
End If
Exit Function
End If
End If
If j - I >= el - 1 Then
If InStr(E$, Left$(Pad$, el)) > 0 Then
If Mid$(Pad$, el + 1, 1) Like "[0-9+.\( @-]" Then
A$ = Mid$(A$, MyTrimLi(A$, I + el))
Fast3Label = True
End If
End If
End If
End Function
Function Fast2VarNoTrim(A$, c$, cl As Long, D$, dl As Long, ahead&, Pos As Long) As Boolean
' need space
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function
Pad$ = myUcase(Mid$(A$, I, ahead&)) + " "
If j - I >= cl - 1 Then
If InStr(c$, Left$(Pad$, cl)) > 0 Then
If Mid$(Pad$, cl + 1, 1) = " " Then
Mid$(A$, I) = space$(cl)
Pos = 1
Fast2VarNoTrim = True
Exit Function
End If
End If
End If
If dl = 0 Then Exit Function
If j - I >= dl - 1 Then
If InStr(D$, Left$(Pad$, dl)) > 0 Then
If Mid$(Pad$, dl + 1, 1) = " " Then
Mid$(A$, I) = space$(dl)
Pos = 2
Fast2VarNoTrim = True
End If
End If
End If
End Function
Function Fast2Varl(A$, c$, cl As Long, D$, dl As Long, ahead&, ByVal f As Long) As Boolean
' use F if dl>0
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then A$ = vbNullString: Exit Function
Pad$ = myUcase(Mid$(A$, I, ahead&))
If f = 2 Then GoTo there
If j - I >= cl - 1 Then
If Left$(Pad$, cl) = c$ Then
I = I + cl
If Len(A$) >= I Then
Select Case AscW(Mid$(A$, I, 1))
Case Is < 36, 39, 41, 44, 47, 58, 61, 92, 123, 125, 160
Case Else
Exit Function
End Select
End If
A$ = Mid$(A$, MyTrimLi(A$, I))
Fast2Varl = True
Exit Function
End If
End If
If dl = 0 Or f = 1 Then Exit Function
there:
If j - I >= dl - 1 Then
If Left$(Pad$, dl) = D$ Then

I = I + dl
If Len(A$) >= I Then
Select Case AscW(Mid$(A$, I, 1))
Case Is < 36, 39, 41, 44, 47, 58, 61, 92, 123, 125, 160
Case Else
Exit Function
End Select
End If

A$ = Mid$(A$, MyTrimLi(A$, I))
Fast2Varl = True
End If
End If

End Function
Function Fast2VarSpace(A$, c$, cl As Long, D$, dl As Long, ahead&) As Boolean
' need always space
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then A$ = vbNullString: Exit Function
Pad$ = myUcase(Mid$(A$, I, ahead&))
If j - I >= cl - 1 Then
If Left$(Pad$, cl) = c$ Then
If Mid$(Pad$, cl + 1, 1) = " " Then
A$ = Mid$(A$, MyTrimLi(A$, I + cl))
Fast2VarSpace = True
Exit Function
End If
End If
End If
If dl = 0 Then Exit Function
If j - I >= dl - 1 Then
If Left$(Pad$, dl) = D$ Then
If Mid$(Pad$, dl + 1, 1) = " " Then
A$ = Mid$(A$, MyTrimLi(A$, I + dl))
Fast2VarSpace = True
End If
End If
End If
End Function
Function Fast3Varl(A$, c$, cl As Long, D$, dl As Long, E$, el As Long, ahead&) As Boolean
Dim I As Long, Pad$, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then A$ = vbNullString: Exit Function
Pad$ = myUcase(Mid$(A$, I, ahead&))
If j - I >= cl - 1 Then
If Left$(Pad$, cl) = c$ Then
A$ = Mid$(A$, MyTrimLi(A$, I + cl))
Fast3Varl = True
Exit Function
End If
End If
If dl = 0 Then Exit Function
If j - I >= dl - 1 Then
If Left$(Pad$, dl) = D$ Then
A$ = Mid$(A$, MyTrimLi(A$, I + dl))
Fast3Varl = True
End If
End If
If el = 0 Then Exit Function
If j - I >= el - 1 Then
If Left$(Pad$, el) = E$ Then
A$ = Mid$(A$, MyTrimLi(A$, I + el))
Fast3Varl = True
End If
End If
End Function

Function ConstNew(bstack As basetask, b$, W$, makeallglobal As Boolean, Lang As Long) As Boolean
Dim p As Variant, ii As Long, ss$, what As Long, vType As Boolean
    Dim cv As Constant
    Do
    what = IsLabel(bstack, b$, W$)
    vType = False
    Select Case what
    Case 1, 4
        If GetlocalVar(W$, ii) Then
        MyEr "Variable exist as local", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ТОПИЙч"
        ConstNew = False
        Exit Function
        ElseIf GetVar(bstack, W$, ii, True) And makeallglobal Then
        If bstack.Vars < ii Then
        MyEr "Variable exist as global", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ЦЕМИЙч"
        ConstNew = False
        
        Exit Function
        End If
        End If
        p = 0
    If IsLabelSymbolNew(b$, "ыс", "AS", Lang) Then
            If IsLabelSymbolNew(b$, "аяихлос", "DECIMAL", Lang) Then
                p = CDec(0)
            ElseIf IsLabelSymbolNew(b$, "дипкос", "DOUBLE", Lang) Then
                p = 0#
            ElseIf IsLabelSymbolNew(b$, "апкос", "SINGLE", Lang) Then
                p = 0!
            ElseIf IsLabelSymbolNew(b$, "коцийос", "BOOLEAN", Lang) Then
                what = 0
                p = False
            ElseIf IsLabelSymbolNew(b$, "лайяус", "LONG", Lang) Then
                If IsLabelSymbolNew(b$, "лайяус", "LONG", Lang) Then
                    what = 0
                    p = cInt64(0)
                Else
                    what = 0
                    p = 0&
                End If
            ElseIf IsLabelSymbolNew(b$, "айеяаиос", "INTEGER", Lang) Then
                what = 0
                p = 0
            ElseIf IsLabelSymbolNew(b$, "коцистийос", "CURRENCY", Lang) Then
                p = 0@
            ElseIf IsLabelSymbolNew(b$, "атупос", "VARIANT", Lang) Then
                what = 0
                vType = True
                p = 0
            ElseIf IsLabelSymbolNew(b$, "цяалла", "STRING", Lang) Then
                what = 0
                p = vbNullString
            ElseIf IsLabelSymbolNew(b$, "ьгжио", "BYTE", Lang) Then
                what = 0
                p = CByte(0)
            Else
                MyEr "No type found", "ДЕМ БЯчЙА ТЩПО"
                Exit Function
            End If
            
            If FastSymbol(b$, "=") Then
                If vType Or MemInt(VarPtr(p)) = vbString Then
                    If ISSTRINGA(b$, ss$) Then
                        p = ss$
                        GoTo conthere
                    ElseIf MemInt(VarPtr(p)) = vbString Then
                        MissString
                        Exit Function
                    End If
                End If
                If Not IsNumberD2(b$, p, True) Then missNumber: Exit Function
                
            Else
                If MemInt(VarPtr(p)) = vbString Then
                MissString
                Else
                missNumber
                End If
                Exit Function
            End If
            If what = 4 Then
            If VarType(p) <> vbBoolean Then p = Int(p)
            End If
            GoTo conthere
    ElseIf FastSymbol(b$, "=") Then
                
                If Not IsExp(bstack, b$, p) Then
                    If Not IsStrExp(bstack, b$, ss$, False) Then
                    MissNumExpr
                    Exit Function
                    Else
                        p = CVar(ss$)
                    End If
                End If
            ElseIf GetVar(bstack, W$, ii, True) Then
                p = var(ii)
            Else
                
                MyEr "No global const found", "дЕМ БЯщХГЙЕ ЦЕМИЙч СТАХЕЯч"
            Exit Function
            End If
conthere:
            If Not bstack.lastobj Is Nothing Then
makelambda:
            If Typename(bstack.lastobj) = "lambda" Then
            Set cv = New Constant
            cv.DefineOnce bstack.lastobj
            Set bstack.lastobj = Nothing
            ii = globalvar(W$, p, , makeallglobal)
            If makeallglobal Or here$ = vbNullString Then
             GlobalSub W$ + "()", "", , , ii
            Else
            GlobalSub here$ + "." + W$ + "()", "", , , ii
            End If
            Else
            Set bstack.lastobj = Nothing
            Set cv = New Constant
            ii = globalvar(W$, p, , makeallglobal)
            cv.DefineOnce p
            End If
            Else
            Set bstack.lastobj = Nothing
            Set cv = New Constant
            If what = 4 Then
                cv.DefineOnce MyRound(p)
            Else
                If vType Then
                    cv.DefineOnce p, vType
                Else
                    cv.DefineOnce p
                End If
            End If
            ii = globalvar(W$, p, , makeallglobal)
            End If
            Set var(ii) = cv
            ConstNew = True
    Case 3
        If GetlocalVar(W$, ii) Then
        MyEr "Variable exist as local", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ТОПИЙч"
        ConstNew = False
        Exit Function
        ElseIf GetVar(bstack, W$, ii, True) And makeallglobal Then
        If bstack.Vars < ii Then
        MyEr "Variable exist as global", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ЦЕМИЙч"
        ConstNew = False
        
        Exit Function
        End If
        End If
              If FastSymbol(b$, "=") Then
                If Not IsStrExp(bstack, b$, ss$) Then MissStringExpr: Exit Function
            ElseIf GetVar(bstack, W$, ii, True) Then
                ss$ = var(ii)
            Else
                
                MyEr "No global const found", "дЕМ БЯщХГЙЕ ЦЕМИЙч СТАХЕЯч"
            Exit Function
            End If
             If Not bstack.lastobj Is Nothing Then GoTo makelambda
            Set bstack.lastobj = Nothing
            Set cv = New Constant
            cv.DefineOnce ss$
            ii = globalvar(W$, p, , makeallglobal)
            Set var(ii) = cv
            ConstNew = True
    Case Else
        MyErMacro b$, "No constant for that type " + W$, "╪ВИ СТАХЕЯч ЦИА АУТЭ ТО ТЩПО " + W$
        Exit Function
    End Select
 Loop Until Not FastSymbol(b$, ",")
End Function

Sub ConnectStatic(bstack As basetask, ByVal what$)
''what$ = "%_" + what$
Dim vvv As Variant, Parent As basetask, parent1 As basetask
Set Parent = bstack.Parent
Do While Not Parent Is Nothing
If Parent.StaticInUse$ = what$ Then
   Set bstack.StaticCollection = Parent.StaticCollection
    bstack.StaticInUse$ = what$
     bstack.OriginalCode = Parent.OriginalCode
    Exit Do
End If
Set Parent = Parent.Parent
Loop
Set Parent = Nothing
End Sub
Function Execute(bstack As basetask, b$, once As Boolean, Optional linebyline As Boolean, Optional loopthis As Boolean = False, Optional noblock As Boolean = True, Optional restartmodule As Boolean, Optional onlyone As Boolean = False) As Long
Dim di As Object, nchr As Integer
Set di = bstack.Owner
Dim myobject As Object, usehandler As mHandler, usehandler1 As mHandler
If checkbreak(bstack, b$, once) Then GoTo enterbreak
Dim pppp As mArray, ppppL As iBoxArray, bb$, ec$, I As Long, jump As Boolean, slct As Long, sp As Variant, sw$, ok As Boolean, IFCTRL As Long
'If linebyline Then
If loopthis Or linebyline And Not noblock Then IFCTRL = bstack.IFCTRL: jump = bstack.jump
Dim W$, LLL As Long, sss As Long, v As Long, p As Variant, ss$, lbl As Boolean, st As Variant, bs As basetask
Dim sX, VarStat As Boolean, NewStat As Boolean, noVarStat As Boolean
Dim x1 As Long, y1 As Long, x2 As Long, y2 As Long, SBB$, nd&, Lang As Long, kolpo As Boolean, iscom As Boolean
Dim temphere$, one As Boolean

If loopthis Then Execute = 2 Else Execute = 1
againexecute:
sss = Len(b$): lbl = True
Do While Len(b$) <> LLL
    If checkbreakEsc(bstack) Then
enterbreak:
    NOEXECUTION = False
    MyClear bstack, ""
    NOEXECUTION = True
        MyEr "", ""
        k1 = 0
        REFRESHRATE = 40
        SLOW = False
        extreme = False
        If MOUT Then
            TaskMaster.Dispose
            'NOEXECUTION = False
            MOUT = False
            MKEY$ = "@Start" + Chr$(13)
            'b$ = "@Start : error {}"
            once = False
            Prefresh(GetCode(bstack.Owner)).k1 = 0
            MyDoEvents0 bstack.Owner
            MyEr "", ""
            LLL = 0
            'NOEXECUTION = True
            Execute = 0
            Exit Function
        Else
            myesc b$
            If once Then
                b$ = vbCrLf + b$   ' this cause troubles...
                Execute = 0
            Else
                once = True
                Execute = 1
            End If
            Exit Function
        End If
    End If
    If (trace And Not stoponerror) Or SLOW Then
       If WaitShow > 0 Then WaitShow = WaitShow - 1
        refreshGui
        If IsWine Then
            MyDoEvents1 di
        ElseIf trace And Not bypasstrace Then
            MyDoEvents0new di   ' change from simple to version 2\ change to mydoevents0
        Else
            MyDoEvents1 di
        End If
    End If
again1:

    'If Not b$ = vbCrLf Then
    lbl = Left$(b$, 1) <> ":"
againExtra:
    
    If DropCommentOrLine(b$) Then ', True
        NewStat = False
        VarStat = False
        noVarStat = False
    End If
againExtra2:
    LLL = Len(b$)
    sss = LLL
    I = 0
    If LLL = 0 Then Exit Do
    If MaybeIsSymbol2(b$, a123, I) Then
        If Mid$(b$, I, 1) = "=" Then
            b$ = Mid$(b$, MyTrimLi(b$, I + 1))
            If (InStr(bstack.originalname$, "(") > 1) Then   ' return from a function no error checking
                x1 = 0
                If GetReturnArray(bstack, x1, b$, p, ss$, pppp) Then Execute = 0: Exit Function
                If once Then Exit Function
            End If
            If Len(b$) > 0 Then GoTo loopcontinue
        ElseIf Mid$(b$, I, 1) = "-" Then
            If Mid$(b$, I + 1, 1) = ">" Then
                b$ = Mid$(b$, MyTrimLi(b$, I + 2))
                If (InStr(bstack.originalname$, "(") > 1) Then
                    x1 = 0
                    If Not GetPointer(bstack, b$) Then Execute = 0: Exit Function
                    If bstack.lastpointer Is Nothing Then MissingGroup:   Execute = 0: Exit Function
                    Set bstack.FuncObj = bstack.lastpointer
                    bstack.FuncValue = 0&
                    Set bstack.lastpointer = Nothing
                    Set bstack.lastobj = Nothing
                    If once Then Exit Function
                End If
                GoTo loopcontinue
            Else
                SyntaxError
                Execute = 0
                Exit Function
            End If
        Else
            b$ = Mid$(b$, MyTrimLi(b$, I + 1))
            I = 0
            If MaybeIsSymbol3(b$, "}", I) Then
             '   If checkbreakEsc(bstack) Then Execute = 1: b$ = vbNullString: Exit Function
                b$ = Mid$(b$, MyTrimLi(b$, I + 1))
                sss = Len(b$)
                lbl = False
                GoTo againExtra
            End If
            If executeblock(Execute, bstack, b$, once, kolpo) Then Exit Function
            '' WHY 4???
            ''If Execute = 4 Then b$ = "{" + b$: Exit Function
            If kolpo Then ec$ = block(b$)
            If Execute = 2 And Len(b$) > 0 Then Exit Function
           
            If Not FastSymbol(b$, "}") Then
                Execute = 0: Exit Function
            Else
                DropCommentOrLine b$, True
                sss = Len(b$)
                'If Not MaybeIsSymbol(b$, b12345) Then SyntaxError: Execute = 0: Exit Function
                lbl = False
            End If
            
            If NocharsInLine(b$) Then Exit Function
            sss = LLL  'basic...
            If jump Or IFCTRL = 2 Then
                jump = False
                I = 1
                While FastOperator(b$, vbCrLf, I, 2)
                Wend
                If IsLabelSymbolNew(b$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                If I > 0 Then lbl = True
            End If
            If linebyline Then Exit Do
        End If
    End If

contVarNew:
    If MaybeIsSymbol(b$, "/\'") Then
        NewStat = False
        VarStat = False
        noVarStat = False
        SetNextLine b$
        sss = Len(b$)
        lbl = True
        If jump Or IFCTRL = 2 Then
            If IsLabelSymbolNew(b$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
            If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
        End If
        If sss > 0 Then GoTo again1
        GoTo JUMPHERE
    ElseIf FastSymbol(b$, ":") Then
        NewStat = False
        VarStat = False
        noVarStat = False
        sss = Len(b$)
        If sss > 0 Then GoTo againExtra
        GoTo JUMPHERE
    End If
jumpforCR:
    If ReplaceCRLFSPACE(b$) Then
        If Len(b$) = 0 Then
        GoTo JUMPHERE
        End If
        NewStat = False
        VarStat = False
        noVarStat = False
        
        sss = LLL: lbl = True: jump = False
        If IsNumberLabel(b$, W$) Then
        If FastSymbol(b$, vbCrLf, , 2) Then GoTo againexecute
        sss = Len(b$): sss = LLL: lbl = False: jump = False:  If sss = 0 Then sss = 2: b$ = vbCrLf
        End If
    Else
        If lbl Then
            If IsNumberLabel(b$, W$) Then
                If IFCTRL = 2 Then
                    once = False
                    b$ = W$
                    Execute = 2
                    Exit Function
                Else
                    sss = Len(b$): sss = LLL: jump = False: If sss = 0 Then sss = 2: b$ = vbCrLf
                End If
            End If
        End If
    End If
    If VarStat Or NewStat Or noVarStat Then

        If FastSymbol(b$, ",") Then
            sss = LLL: lbl = False: jump = False
              If Not onlyone Or linebyline Then
                DropCommentOrLine b$
                LLL = Len(b$)
            End If
jump101:
        ElseIf FastOperator(b$, ":", 1) Then
entry1:
            NewStat = False
            VarStat = False
            noVarStat = False
            GoTo contconthere
        ElseIf NocharsInLine(b$) Then
            SetNextLine b$
            
            If b$ <> "" Then GoTo again1
        Else
            PlaceAcommaBefore
            Execute = 0
            Exit Function
        End If

        one = True
        iscom = True
        Select Case IsLabelDotSub(temphere$, b$, W$, ss$, Lang, nchr)
        Case 0
            one = False
            VarStat = False
            NewStat = False
            noVarStat = False
            GoTo contconthere
        Case 1234
            VarStat = False
            NewStat = False
            noVarStat = False
            GoTo contconthere
        Case 1
            If Left$(W$, 1) = "." Then
                ss$ = W$
                IsLabel bstack, ss$, W$
            End If
            GoTo VarOnly
        Case 2
            noref
            Execute = 0
            Exit Function
        Case 3
            GoTo contcase3
        Case 4
            GoTo contcase4
        Case 5
            GoTo contcase5
        Case 6
            GoTo contcase6
        Case 7
            GoTo contcase7
        Case 10
            GoTo contcase10
        Case Else
            GoTo errstat
        End Select
    ElseIf FastSymbol(b$, ":") Then
contconthere:
        NewStat = False: VarStat = False: noVarStat = False: sss = LLL: lbl = False: jump = False: If sss = 0 Then sss = 2: b$ = vbCrLf
    End If
again2:
    If lookOne(b$, "@") Then W$ = vbNullString: GoTo parsecommand
again3:
one = True
    x1 = IsLabelDotSub(temphere$, b$, W$, ss$, Lang, nchr)
again4:
    Select Case x1
    Case 0
        If FastSymbol(b$, "(") Then
            I = 1
            x1 = 0
            While Len(aheadstatus(b$, False, I)) > 0
                x1 = I - 1
                I = I + 1
            Wend
            ss$ = Left$(b$, x1)
            If x1 > 0 And MyTrim(ss$) <> vbNullString Then
                Mid$(b$, 1, x1) = space$(x1)
                If FastSymbol(b$, ")", True) Then
                    If FastSymbol(b$, "=") Then
                        If IsExp(bstack, b$, p) Then
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is mArray Then
                                Set pppp = bstack.lastobj
                                GoTo wehavearray
                                ElseIf TypeOf bstack.lastobj Is mHandler Then
                                    If CheckIsmArray(bstack.lastobj) Then
                                    
                                      Set usehandler = bstack.lastobj
                                      
                                        Set pppp = usehandler.objref
wehavearray:
                                        Set bstack.lastobj = Nothing
                                        Set myobject = bstack.soros
                                        Set bstack.Sorosref = New mStiva
                                        bstack.soros.MergeBottomCopyArray pppp
                                        If Not MyRead(1, bstack, ss$, 1) Then
                                            Set bstack.lastobj = Nothing
                                            Set bstack.Sorosref = myobject
                                            Execute = 0
                                            Exit Function
                                        End If
                                        Set bstack.lastobj = Nothing
                                        Set bstack.Sorosref = myobject
                                        Set myobject = Nothing
                                        GoTo loopagain
                                    Else
a123321:                                    NotArray
                                            Execute = 0
                                            Exit Function
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        GoTo a123321
        End If
        one = False
    Case 1234
        GoTo jumpforCR
    Case 2
        NoRef2
        Execute = 0
        Exit Function
    Case 1
        If sss = LLL Then
            If lbl Then
                If lookA123(b$) Then
                    sw$ = GetNextLine(b$)
                    LLL = Len(b$): sss = LLL: GoTo again1
                End If
            End If
            If Trim$(W$) = vbNullString Then
                Execute = 1
                Exit Function
            End If
            If trace Then
                If Not bypasstrace Then
tragain:
                    If Not TraceThis(bstack, di, b$, ss$, SBB$) Then Execute = 0: Exit Function
                    If Len(tracecode) > 0 Then
                    ss$ = tracecode
                    tracecode = vbNullString
                    bypasstrace = True

                     If executeblock(Execute, bstack, ss$, once, kolpo, , , True) Then bypasstrace = False: Exit Function

                     bypasstrace = False
                     tracecode = vbNullString
                    GoTo tragain
                   
                    End If
                End If
            End If
            iscom = False
            If Left$(W$, 1) = "." Then
               '  ss$ = w$
                 
               ' IsLabel bstack, ss$, w$
               If Not expanddot(bstack, W$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
               Execute = 0
               Exit Function
               End If
                iscom = True
               
                lbl = False
                GoTo VarOnly
            ElseIf Len(temphere$) > 0 Then
                iscom = True
                lbl = False
                VarStat = True
                GoTo VarOnly
            ElseIf Not NoOptimum Then
                v = 0
                If MaybeIsSymbolNoSpace(b$, "[+/*~-]") Then
                    GoTo VarOnly
                ElseIf MaybeIsSymbol(b$, "<=_") Then
                    GoTo VarOnly
                ElseIf Not comhash.Find2(W$, I, v) Then
                    iscom = True
                    lbl = False
                    GoTo VarOnly
                ElseIf I <> 0 Then
                    If IsBadCodePtr(I) = 0 Then
                        On Error GoTo myerr1
                        If CallByPtr(I, bstack, b$, Lang) Then
                            LLL = 0 ' maybe b$ changed inside the call if LLL=len(b$) then we exit from loop
                            
                            GoTo conthere222
                        Else
myerr1:
                            If bstack Is Nothing Then Exit Function
                            If LastErNum1 = -1 And bstack.IamThread Then Execute = 1 Else Execute = 0
                            If Err Then GoTo errstat0 Else Exit Function
                        End If
                        On Error GoTo errstat0
                    Else
                        GoTo parsecommand
                    End If
                ElseIf v <> 0 Then
                    On v GoTo contif, ContElse, contElseIf, contSelect, ContTry, ForCont, contNext, contRefr, contWhile, ContRepeat, ContGoto, contSub, autogosub, ContOn, contLoop, contBreak, ContContinue, ContRestart, ContReturn, ContEnd, ContExit, ContInline, contUpdate, contThread, contAfter, contPart, contStatic, contEvery, contTask, ContScan, contTarg, BypassGlobalComm, BypassComm, contNegLocal, contNegGlobal, makeconst, VarOnly, contCall, contBinary, contHALT, contSTOP, contDraw, contVar, contClass
                    Execute = 0: Exit Function
contClass:
        one = True
        iscom = True
        noVarStat = True
        sss = LLL: lbl = False: jump = False
            If Not onlyone Or linebyline Then
                DropCommentOrLine b$
                LLL = Len(b$)
            End If
        GoTo VarOnly
BypassGlobalComm:
                    iscom = True
                    GoTo parsecommand
BypassComm:
                    If bstack.commnum = 0 Then
                        W$ = "@" + W$
                    ElseIf bstack.commnum > comhash.Index Then
                        W$ = "@" + W$
                    Else
                        iscom = True
                    End If
                    GoTo parsecommand
                Else
                    GoTo parsecommand
                End If
            End If
            Select Case W$
            Case "STOP", "диайопг"
contSTOP:
                If HaltLevel = 0 Then
                If trace Then GoTo notask
                
                If MsgBoxN("[STOP] л2000 - Temporary Execution Stop / пЯОСЫЯИМч йЯэТГСГ еЙТщКЕСГР" + vbCrLf + "use Exit to Return / ВЯГСИЛОПОъГСЕ ТО щНОДОР ЦИА ЕПИСТЯОЖч", vbYesNo, MesTitle$) = vbYes Then
notask:
                Set bs = bstack
                
                HaltLevel = HaltLevel + 1
                
                crNew bstack, players(GetCode(bstack.Owner))
                Form1.MyPrompt "", UserName + " (exit)>", bstack
                HaltLevel = HaltLevel - 1
                Set bstack = bs
                If ExTarget Then
                NOEXECUTION = True
                ElseIf HaltLevel < 0 Then
                    b$ = "START"
                    Execute = 1
                    ok = True
                    Exit Do
                Else
                    ExTarget = False
                    MOUT = False
                End If

                End If
                Else
                    
                  ExTarget = False
                    MOUT = False
                End If
            Case "HALT", "акт"
contHALT:
                ss$ = here$
                HaltLevel = HaltLevel + 1
                Form1.MyPrompt "", ">>"
                HaltLevel = HaltLevel - 1
                If HaltLevel < 0 Then
                    b$ = "START"
                    Execute = 1
                    ok = True
                    Exit Do
                Else
                    here$ = ss$
                    ExTarget = False
                    MOUT = False
                End If
            Case "TARGET", "стовос"
contTarg:
                targetsMyExec Execute, b$, bb$, v, di, W$, bstack, VarStat, temphere$
                If Execute = 0 Then Exit Function
            Case "SCAN", "саяысе"
ContScan:
                ClearJoyAll
                PollJoypadk
                If GetForegroundWindow <> Form1.hWnd Or Not Targets Then
                    If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                    End If
                    MyDoEvents0 di
                    If Fkey > 0 Then
                        If FK$(Fkey) <> "" Then
                            If bstack.IamChild And bstack.IamAnEvent And Fkey = 13 And lastAboutHTitle <> "" Then
                                abt = True
                                Fkey = 0
                                vHelp
                            Else 'If Not trace Then
                                ss$ = FK$(Fkey)
                                Fkey = 0
                                If TaskMaster Is Nothing Then
                                If Not interpret(Basestack1, ss$) Then
                                    Execute = 0
                                    Exit Function
                                End If
                                Else
                                TaskMaster.StopProcess
                                If Not interpret(Basestack1, ss$) Then
                                    Execute = 0
                                End If
                                TaskMaster.StartProcess
                                If Execute = 0 Then Exit Function
                                End If
                            End If
                        End If
                        Fkey = 0
                    End If
                Else
                    If di.Visible = False Then di.Visible = True
                        NoAction = False
                        nomore = True
                        If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                        sX = Timer + p
                        x1 = Form1.lockme
                        If x1 Then UnHook Form1.hWnd
                            Form1.lockme = False
                            Do
                                y1 = BLOCKkey
                                BLOCKkey = True
                                MyDoEvents0 Form1
                                BLOCKkey = y1
                                If exWnd <> 0 Then ss$ = MyTitle$(bstack)
                                If Fkey > 0 Then
                                    If FK$(Fkey) <> "" Then
                                        b$ = FK$(Fkey) + b$
                                        Fkey = 0
                                        Exit Do
                                    End If
                                End If
                            Loop Until NoAction Or Timer > sX Or myexit(bstack) Or bstack.IamThread
                            Form1.lockme = x1
                            If x1 And GetForegroundWindow = Form1.hWnd Then Form1.hookme Form1.TEXT1.glistN
                        Else
                        Do
                            MyDoEvents0 Form1
                            If exWnd <> 0 Then ss$ = MyTitle$(bstack)
                            If Fkey > 0 Then
                                If FK$(Fkey) <> "" Then
                                    b$ = FK$(Fkey) + b$
                                    Fkey = 0
                                    Exit Do
                                End If
                            End If
                        Loop Until NoAction Or myexit(bstack)
                    End If
                    nomore = False
                End If
            Case "REFRESH", "амамеысг"
contRefr:
                If IsLabelSymbolNew(b$, "дойилг", "TEST", Lang) Then
                    MyDoEvents1 di
                ElseIf IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                    With Prefresh(GetCode(di))
                        If Int(p) = 0# Then
                             Call GetSystemTimeAsFileTime(basictimer)
                            .k1 = basictimer + REFRESHRATE
                        Else
                            REFRESHRATE = p
                            .k1 = 0
                            bstack.RRCOUNTER = 0
                            If bstack.IamThread Then
                                MyDoEvents0 di
                            Else
                                MyDoEvents1 di
                            End If
                        End If
                    End With
                Else
                    Prefresh(GetCode(di)).RRCOUNTER = 0
                    MyDoEvents0 di
                    bstack.RRCOUNTER = 0
                End If
                If exWnd <> 0 Then
                    ss$ = MyTitle$(bstack)
                End If
                If Fkey > 0 Then If FK$(Fkey) <> "" Then MKEY$ = MKEY$ + FK$(Fkey)
                Fkey = 0
            Case "статийг", "статийес", "STATIC"
contStatic:
                StaticNew bstack, b$, W$, Lang
            Case "мгла", "THREAD"
contThread:
                ss$ = vbNullString
                If IsLabelSymbolNewExp(b$, "хесе", "SET", Lang, ss$) Then
                    If bstack.Process Is Nothing Then GoTo dothesame
                    If Not StaticNew(bstack, b$, W$, Lang) Then Execute = 0: Exit Function
                ElseIf IsLabelSymbolNewExp(b$, "ауто", "THIS", Lang, ss$) Then
                    If bstack.Process Is Nothing Then
dothesame:
                        b$ = vbNullString
                        NoThisInThread
                        Execute = 0: Exit Function
                        once = False
                    ElseIf IsLabelSymbolNewExp(b$, "сбгсе", "ERASE", Lang, ss$) Then
                        If Not bstack.Process Is Nothing Then
                            Set bstack.Process.Process = Nothing
                        End If
                        
                        GoTo exitfromhere
                    ElseIf IsLabelSymbolNewExp(b$, "йяата", "HOLD", Lang, ss$) Then
                        bstack.Process.Busy = True
                    ElseIf IsLabelSymbolNewExp(b$, "нейима", "RESTART", Lang, ss$) Then
                        bstack.Process.Busy = False
                        b$ = vbNullString
                    ElseIf IsLabelSymbolNewExp(b$, "йахе", "INTERVAL", Lang, ss$) Then
                        If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                            If p < 2 Then p = 2
                                bstack.Process.Interval = p
                            Else
                                b$ = vbNullString
                                MisInterval
                                Execute = 0: Exit Function
                            End If
                        Else
                            b$ = vbNullString
                            NoClauseInThread
                            Execute = 0: Exit Function
                        End If
                Else
                    If linebyline Then
                        b$ = W$ + " " + b$
                        Execute = Execute(bstack, b$, once, False)
                        Exit Do
                    End If
                    If Not MyThread(bstack, b$, Lang) Then Execute = 0: Exit Function
                    If Left$(here$ + "#", 1) = "!" Then here$ = Mid$(here$, 2)
                End If
            Case "LOOP", "йуйкийа"
contLoop:
                If noblock Then
                loopthis = True
                    Execute = 2
                  '  If checkbreakEsc(bstack) Then Execute = 1: b$ = vbNullString: Exit Function
                Else
                    Execute = 5: Exit Function
                End If
                
            Case "BREAK", "диейоье"
contBreak:
            restartmodule = False
            'If bstack.SubLevel > 0 Then
            '        WaitShow = 0
            '         PopStagePartContinue2 bstack, bstack.RetStackTotal
            '        once = False
            '        b$ = Chr$(0)
            '        If bstack.RetStackTotal = 0 Then Execute = 1 Else Execute = 2
            'Else
                b$ = "BREAK"
                once = True
                Execute = 2
             '   End If
                
                Exit Function
            Case "CONTINUE", "сумевисе"
ContContinue:
 restartmodule = False


                If Execute <> 2 Then
                    b$ = "CONTINUE"
                    once = True
                    Execute = 3
                Else
                    b$ = vbNullString
                End If
                Exit Function
            Case "RESTART", "нейима"
ContRestart:
                b$ = vbNullString
                If restartmodule Then
             restartmodule = False
                loopthis = True
                End If
                Execute = 2
                Exit Function
            Case "RETURN", "епистяожг"
ContReturn:
                LastErNum = 0
                If IsExp(bstack, b$, p) Then
                    If bstack.lastobj Is Nothing Then
                        BadUseofReturn
                        Execute = 0
                        Exit Function
                    ElseIf Typename(bstack.lastobj) = mHdlr Then
                        Select Case bstack.lastobj.T1
                        Case 1
                            If ChangeValues(bstack, b$) Then GoTo loopcontinue
                        Case 2
                            If ChangeValuesMem(bstack, b$, Lang) Then GoTo loopcontinue
                        Case 3
                            If ChangeValuesArray(bstack, b$) Then GoTo loopcontinue
                        Case 4
                            NoProperObject
                            Set bstack.lastobj = Nothing
                            Execute = 0
                            Exit Function
                         End Select
                     End If
                     BadUseofReturn
                     Execute = 0
                     Exit Function
                ElseIf IsStrExp(bstack, b$, ss$) Then
                    append_table bstack, ss$, b$, True, Lang
                Else
                    If LastErNum <> 0 Then
                        LLL = Len(b$) - 1
                    Else
                        If bstack.RetStackTotal = 0 Then
                            stackproblem
                            Execute = 0
                            Exit Function
                        Else
                            PopStagePartContinue2 bstack, bstack.RetStackTotal
                        End If
                        once = False
                        b$ = Chr$(0)
                        Execute = 2
                        Exit Function
                    End If
                End If
            Case "END", "текос"
ContEnd:
                WaitShow = 0
                W$ = vbNullString
                If IsLabelSymbolNewExp(b$, "ам", "IF", Lang, W$) Then
                    If bstack.UseofIf > 0 Then
                        If Not HaveMark2(bstack) Then
                            MissIF
                            Execute = 0: Exit Function
                        End If
                        bstack.UseofIf = bstack.UseofIf - 1
                    Else
                            MissIF
                            Execute = 0: Exit Function
                    End If
                        lbl = False
                        If Len(b$) > 0 Then
                        If Left$(b$, 2) = vbCrLf Then lbl = True
                        End If
                ElseIf IsLabelSymbolNewExp(b$, "яоутимас", "SUB", Lang, W$) Then
                    once = False
                    b$ = Chr$(0)
                    Execute = 2
                    Exit Function
                ElseIf IsLabelSymbolNewExp(b$, "епикоцгс", "SELECT", Lang, W$) Then
                    NoCommandOrBlock
                    Execute = 1
                    Exit Function
                ElseIf IsLabelSymbolNewExp(b$, "сумаятгсгс", "FUNCTION", Lang, W$) Then
                    once = False
                    b$ = Chr$(0)
                    Execute = 2
                    Exit Function
                Else
                    b$ = vbNullString   ' no more syntax error
                    Execute = 1
                    MOUT = True
                    Exit Function
                End If
            Case "енодос", "EXIT"
         ''\\"SUB", "яоутима"
ContExit:
               '' If loopthis Then loopthis = False: Execute = 1
                ss$ = vbNullString
                If IsLabelSymbolNewExp(b$, "яоутимас", "SUB", Lang, ss$) Then
                    WaitShow = 0
                     PopStagePartContinue2 bstack, bstack.RetStackTotal
                    once = False
                    b$ = Chr$(0)
                    If bstack.RetStackTotal = 0 Then Execute = 1 Else Execute = 2
                    Exit Function
                ElseIf IsLabelSymbolNewExp(b$, "сумаятгсгс", "FUNCTION", Lang, ss$) Then
                WaitShow = 0
                     PopStagePartContinue2 bstack, bstack.RetStackTotal
                    once = False
                    b$ = Chr$(0)
                    If bstack.RetStackTotal = 0 Then Execute = 1 Else Execute = 2
                    Exit Function
                ElseIf IsLabelSymbolNewExp(b$, "циа", "FOR", Lang, ss$) Then
exitfor:

                    once = False
                    PopStagePartContinue2 bstack, bstack.RetStackTotal
                    I = FastPureLabel(b$, W$)
                    If I = 0 Then
                        I = IsNumberLabel(b$, W$)
                        If I = 0 Then
                            b$ = "NEXT"
                            Execute = 2
                        Else
                            b$ = W$
                            Execute = 12
                        End If
                    ElseIf I = 1 Then
                        b$ = W$
                        Execute = 12
                    Else
                    
                    
                    If Execute <> 2 Then Execute = 1 Else Execute = 3
                   restartmodule = False
                     b$ = vbNullString
                    once = True
                    Exit Function
                        b$ = "NEXT"
                        Execute = 2
                    End If
                    Exit Function
                ElseIf IsLabelSymbolNewExp(b$, "ейтупысгс", "PRINTING", Lang, ss$) Then
                    If bstack.toprinter Then
                        pnum = 0
                        oprinter.ClearUp
                        Form1.PrinterDocument1.Picture = LoadPicture("")
                        Set bstack.Owner = Form1.DIS
                        bstack.toprinter = False
                        SetNormal bstack.Owner
                    End If
                    b$ = vbNullString
                    once = True
                Else
exitfromhere:
                    If Execute <> 2 Then Execute = 1 Else Execute = 3
                   restartmodule = False
                    
                    b$ = vbNullString
                    once = True
                    Exit Function
                End If
            Case "FOR", "циа"
ForCont:
                If linebyline Then
                   If Not b$ = vbNullString Then
                    If AscW(b$) <> 32 Then
                        b$ = W$ + " " + b$
                    Else
                        b$ = W$ + b$
                    End If
                    Execute = Execute(bstack, b$, once, False)
                    Exit Do
                   Else
                   SyntaxError
                   Execute = 0
                   Exit Function
                   
                   End If
                End If
                If once = True Then Execute = 0: Exit Function
                If Len(b$) < 129 Then
                    x1 = Abs(IsLabelBig(bstack, b$, W$, , SBB$, , True))
                Else
                    ss$ = Left$(b$, 128)
                    ok = True
                    x1 = Abs(IsLabelBig(bstack, ss$, W$, , SBB$, , ok))
                    If Len(ss$) > 0 Then
                        If ok Then
                            b$ = Mid$(b$, 129 - Len(ss$))
                        ElseIf Len(ss$) <= 128 Then
                            Mid$(b$, 129 - Len(ss$), Len(ss$)) = ss$
                            Mid$(b$, 1, 129 - Len(ss$)) = space$(128 - Len(ss$))
                        Else
                            b$ = ss$ + Mid$(b$, 129)
                        End If
                    Else
                        x1 = Abs(IsLabelBig(bstack, b$, W$, , SBB$, , True))
                    End If
                End If
                If x1 = 8 Then
                bstack.tmpstr = W$ + "[" + Left$(b$, 1)
                BackPort b$
                If IsExp(bstack, b$, p) Then
                    If bstack.lastobj Is Nothing Then
                    SyntaxError
                    Exit Function
                    ElseIf Not TypeOf bstack.lastobj Is Group Then
                    SyntaxError
                    Exit Function
                    End If
                        
                        
                        Set ppppL = New ppppLight
                        ppppL.Arr = False
                        Set ppppL.GroupRef = bstack.lastobj
                        v = -2
                        GoTo startwithgroup
                Else
                    SyntaxError
                    Exit Function
                End If
                End If
againfor948:
                nd& = x1
                Select Case x1
                Case 1, 4 'FLOATING POINT
                    If MaybeIsSymbol(b$, "<=") Then
                        If FastSymbol(b$, "=") Then
                            If bstack.StaticCollection Is Nothing Then GoTo cont10456
                            If bstack.ExistVar(W$) Then
                                x2 = -1
                                x1 = nd&
                                If IsExp(bstack, b$, p) Then
                                    If nd& = 4 Then p = MyRound(p) Else p = MyRound(p, 28)
                                    bstack.SetVar W$, p
                                    GoTo eos
                                Else
                                    Execute = 0
                                    Exit Function
                                End If
                            Else
cont10456:
                                x1 = Abs(GetlocalVar(W$, x2)) * x1
                            End If
                        ElseIf FastSymbol(b$, "<=", , 2) Then
                            x1 = Abs(GetVar(bstack, W$, x2, True)) * x1
                        End If
                        If x1 Then
                            If IsExp(bstack, b$, p) Then
                                If VarType(var(x2)) <> VarType(p) Then
                                    On Error Resume Next
                                    Select Case VarType(var(x2))
                                    Case vbInteger
                                        'x1 = 16
                                        p = CInt(p)
                                    Case vbLong
                                        x1 = 8
                                        p = CLng(p)
                                    Case vbSingle
                                        p = CSng(p)
                                    Case vbCurrency
                                        p = CCur(p)
                                    Case vbDecimal
                                        p = CDec(p)
                                    Case 20  ' INT64
                                        p = cInt64(p)
                                    Case vbByte
                                        p = CByte(p)
                                    Case vbDate
                                        p = CDate(p)
                                    Case Else
                                        p = Int(p)
                                    End Select
                                    If Err.Number = 6 Then
                                        Execute = 0
                                        OverflowValue VarType(var(x2))
                                        Exit Function
                                    End If
                                End If
                                If x1 = 1 Then
                                    var(x2) = MyRound(p, 28)
                                Else
                                    var(x2) = p
                                End If
                            End If
                            
                        ElseIf IsExp(bstack, b$, p) Then
                            If nd& > 1 Then p = MyRound(p)
                            x2 = globalvar(W$, p, , VarStat, temphere$)
                            x1 = nd&
                        Else
                            Execute = 0
                            Exit Function
                        End If
eos:
                        If IsLabelSymbolNew(b$, "еыс", "TO", Lang) Then
                            
                            If IsExp(bstack, b$, sp) Then
                            If VarType(sp) <> VarType(p) Then
                                    On Error Resume Next
                                    Select Case VarType(p)
                                    Case vbInteger
                                        
                                        sp = CInt(sp)
                                    Case vbLong
                                        
                                        sp = CLng(sp)
                                    Case vbSingle
                                        sp = CSng(sp)
                                    Case vbCurrency
                                        sp = CCur(sp)
                                    Case vbDecimal
                                        sp = CDec(sp)
                                    Case 20  ' INT64
                                        sp = cInt64(sp)
                                    Case vbByte
                                        sp = CByte(sp)
                                    Case vbDate
                                        sp = CDate(sp)
                                    Case Else
                                        sp = Int(sp)
                                    End Select
                                    If Err.Number = 6 Then
                                        Execute = 0
                                        OverflowValue VarType(p)
                                        Exit Function
                                    End If
                                End If
                                
                            
                            
                            
                            
                            
                            If nd& = 4 Then
                                sp = MyRound(sp)
                                p = MyRound(p)
                            ElseIf x1 > 1 Then
                                'sp = Int(sp)
                                'p = Int(p)
                            ElseIf myVarType(p, vbDouble) Then
                                If RoundDouble Then sp = MyRound(sp, 13)
                                p = MyRound(p, 28)
                            End If
                            'If x1 > 1 Then sp = Round(sp, 0)
                            ' like BASIC FOR
                            If ForLikeBasic Then
                                st = 1
                            Else
                                st = Sgn(sp - p)
                            End If
                            If IsLabelSymbolNew(b$, "ама", "STEP", Lang) Then
                                If VarType(p) = vbSingle Then st = CSng(1)
                                If IsExp(bstack, b$, st) Then
                                    If VarType(p) = vbSingle Then
                                        st = CSng(st)
                                    End If
                                    If x1 > 1 Then
                                        If x1 >= 8 Then st = Fix(st) Else st = Round(st)
                                    End If
                                    If Not (Sgn(sp - p) = 0 Or st = 0) Then
                                        If ForLikeBasic And Sgn(st) <> Sgn(sp - p) Then
                                            st = 1
                                            sp = p - 1
                                        Else
                                            st = Abs(st)
                                            If sp < p Then
                                                If Fix(st) = st Then
                                                    If st <> 0 Then sp = sp - ((sp - p) Mod st) \ 2
                                                Else
                                                    sX = Abs(((sp - p) / st))
                                                    If sX = MyRound(sX) Then
                                                        sp = sp - MyRound(st / 2)
                                                    ElseIf st < 1 Then
                                                        sp = sp - 1 / EXP(18 - (Log(st + Abs(sp - p))) / Log(10))
                                                    Else
                                                       sp = p - Fix(sX) * st - st / 2
                                                    End If
                                                End If
                                            Else
                                                If Not (Fix(st) = st) Then
                                                    sX = Abs(((sp - p) / st))
                                                    If sX = MyRound(sX) Then
                                                        sp = sp + MyRound(st / 2)
                                                    ElseIf st < 1 Then
                                                        sp = sp + 1 / EXP(18 - (Log(st + Abs(sp - p))) / Log(10))
                                                    Else
                                                        sp = p + Fix(sX) * st + st / 2
                                                    End If
                                                End If
                                            End If
                                            st = Sgn(sp - p) * st
                                        End If
                                    End If
                                Else
                                    Execute = 0
                                    Exit Function
                                End If
                            End If
                            If st = 0 Then sp = p
                            If Not FastSymbol(b$, "{") Then
                            '' this is the old like Basic For
                               ' sw$ = b$
                                I = 1
                                aheadstatusNext b$, I, Lang, ok
                                If Not ok Then
                                MyEr "лissing Next", "дЕМ БЯчЙА ТО еПЭЛЕМО"
                                Execute = 0: Exit Function
                                End If
                                ss$ = Left$(b$, I - 1)
                                 b$ = Mid$(b$, I)
                                sw$ = ss$
                                sX = p
                                y1 = True
                                bstack.RetStack.PushVal 0  ' RETURN LENGTH FROM END OF B$
                                bstack.RetStack.PushStr W$   ' for check if is the right variable
                                TraceStore bstack, nd&, b$, 0
                                
                                slct = bstack.addlen
                                If ForLikeBasic Then
                                    If st > 0 And sp < p Then
                                        'once = False
                                        ss$ = "NEXT " + W$
                                        
                                        'Execute = 2
                                        'GoTo contbasicfor
                                    End If
                                End If
                                GoTo contfor
                            Else
                                y1 = False
                                ss$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                sw$ = ss$
                                TraceStore bstack, nd&, b$, 0
                                slct = bstack.addlen ' reusing slct variable
                                If FastSymbol(b$, "}") Then
                                    If ForLikeBasic Then
                                        If st > 0 And sp < p Then
                                            ss$ = "exit"
                                        End If
                                    End If
contfor:
                                    Execute = 1
                                    ok = False
                                    v = Len(b$)
                                    y2 = 0
                                        If x1 = 1 Then
                                            Do
                                                bstack.addlen = slct
                                                If executeblock(Execute, bstack, ss$, once, ok, , True) Then
                                                    bstack.addlen = nd&
                                                    If Execute <> 1 Then
                                                        If Execute = 2 Then
                                                             SwapStrings b$, ss$
                                                             Exit Function
                                                        Else
                                                            b$ = ss$ + b$: Exit Function
                                                        End If
                                                    End If
                                                Else
                                                    bstack.addlen = nd&
                                                    If Execute = 2 And ss$ <> "" And Not ok Then
                                                        If y1 And ss$ = "NEXT" Then
                                                            Execute = 1: Exit Do
                                                        End If
                                                        SwapStrings b$, ss$
                                                        Exit Function
                                                    ElseIf Execute = 12 Then
                                                        bstack.RetStackDrop 2
                                                        Execute = 2
                                                        b$ = ss$
                                                        Exit Function
                                                    End If
                                                End If
                                                If Not (ok Or MOUT) Or Execute = 3 Then
                                                    Execute = 1
                                                    ss$ = sw$
                                                    p = p + st
                                                Else
                                                    Exit Do
                                                End If
                                              '  If checkbreakEsc(bstack) Then Execute = 1: Exit Do
                                                If x2 < 0 Then
                                                    bstack.SetVar W$, MyRound(p, 10)
                                                Else
                                                    If Not myVarType(var(x2), VarType(p)) Then
                                                    On Error Resume Next
                                                        Select Case VarType(var(x2))
                                                        Case vbInteger
                                                            var(x2) = CInt(p)
                                                        Case vbLong
                                                            var(x2) = CLng(p)
                                                        Case vbSingle
                                                            var(x2) = CSng(MyRound(p, 10))
                                                        Case vbCurrency
                                                            var(x2) = CCur(MyRound(p, 10))
                                                        Case vbDecimal
                                                            var(x2) = CDec(MyRound(p, 10))
                                                        Case 20
                                                            var(x2) = cInt64(p)
                                                        Case vbByte
                                                            var(x2) = CByte(p)
                                                        Case vbDate
                                                            var(x2) = CDate(p)
                                                        Case Else
                                                            var(x2) = CDbl(MyRound(p, 10))
                                                        End Select
                                                        If Err.Number = 6 Then
                                                        If st > 0 Then
                                                            If p > sp Then Err.Clear: Exit Do
                                                        ElseIf st < 0 Then
                                                            If p < sp Then Err.Clear: Exit Do
                                                        Else
                                                            Exit Do
                                                        End If
                                                            OverflowValue VarType(var(x2))
                                                            Execute = 0
                                                            Exit Function
                                                        End If
                                                    ElseIf x1 > 1 Then
                                                        var(x2) = p
                                                    Else
                                                        var(x2) = MyRound(p, 10)
                                                    End If
                                                End If
                                                If st > 0 Then
                                                    If p > sp Then Exit Do
                                                ElseIf st < 0 Then
                                                    If p < sp Then Exit Do
                                                Else
                                                    Exit Do
                                                End If
                                            Loop
'                    ElseIf x1 > 4 Then
                    
'                        On Error GoTo LONGERR
'                        y2 = p
'                        x1 = sp
'                        sss = st
'                        sp = sss
'                        Do
'                            bstack.addlen = slct
'                            If executeblock(Execute, bstack, ss$, once, ok, , True) Then
'                                bstack.addlen = nd&
'                                If Execute <> 1 Then
'                                    If Execute = 2 Then
'                                         SwapStrings b$, ss$
'                                         Exit Function
'                                    Else
'                                        b$ = ss$ + b$: Exit Function
'                                    End If
'                                    End If
'                            Else
'
'                            bstack.addlen = nd&
'                                If Execute = 2 And ss$ <> "" And Not ok Then
'                                    If y1 And ss$ = "NEXT" Then
'                                        Execute = 1: Exit Do
'                                    End If
'                                    SwapStrings b$, ss$
'                                    Exit Function
'                                ElseIf Execute = 12 Then
'                                    bstack.RetStackDrop 2
'                                    Execute = 2
'                                    b$ = ss$
'                                    Exit Function
'                                End If
'                            End If
'                            If Not (ok Or MOUT) Or Execute = 3 Then
'                                Execute = 1
'                                ss$ = sw$
 '                               y2 = y2 + sss
 '                           Else
 '                               Exit Do
 '                           End If
 '                           If myexit(bstack) Then Execute = 1: Exit Do
 '                           On Error Resume Next
 '                           If VarType(var(x2)) = vbInteger Then
 '                               var(x2) = CINT(y2)
 '                           Else
 '                               var(x2) = y2
 '                           End If
 '                           On Error GoTo 0
 '                           If st > 0 Then
 '                               If y2 > x1 Then Exit Do
 '                           ElseIf st < 0 Then
 '                               If y2 < x1 Then Exit Do
 '                           Else
 '                               Exit Do
 '                           End If
 '                       Loop
 '                       sss = sp
                                        Else
                                            Do
                                                bstack.addlen = slct
                                                If executeblock(Execute, bstack, ss$, once, ok, , True) Then
                                                    bstack.addlen = nd&
                                                    If Execute <> 1 Then
                                                        If Execute = 2 Then
                                                             SwapStrings b$, ss$
                                                             Exit Function
                                                        Else
                                                            b$ = ss$ + b$: Exit Function
                                                        End If
                                                        End If
                                                Else
                                                bstack.addlen = nd&
                                                    If Execute = 2 And ss$ <> "" And Not ok Then
                                                        If y1 And ss$ = "NEXT" Then
                                                            Execute = 1: Exit Do
                                                        End If
                                                        SwapStrings b$, ss$
                                                        Exit Function
                                                    ElseIf Execute = 12 Then
                                                        bstack.RetStackDrop 2
                                                        Execute = 2
                                                        b$ = ss$
                                                        Exit Function
                                                    End If
                                                End If
                                                If Not (ok Or MOUT) Or Execute = 3 Then
                                                    Execute = 1
                                                    ss$ = sw$
                                                    p = p + st
                                                Else
                                                    Exit Do
                                                End If
                                              '  If checkbreakEsc(bstack) Then Execute = 1: Exit Do
                                                If x2 < 0 Then
                                                     bstack.SetVar W$, p
                                                Else
                                                    var(x2) = p
                                                End If
                                                If st > 0 Then
                                                    If p > sp Then Exit Do
                                                ElseIf st < 0 Then
                                                    If p < sp Then Exit Do
                                                Else
                                                    Exit Do
                                                End If
                                            Loop
                                        End If
                                        If Execute = 1 And y1 Then
                                            bstack.RetStackDrop 2
                                        End If
                                        x2 = 0  ' need to erased - because reused
                                        y2 = 0
                                        If MOUT Then Execute = 0: Exit Function
                                        ok = True
                                    End If
                                End If
                            End If
                        End If
                    Else
                        v = -1
                        Set pppp = Nothing
                        
                        GoTo startwithgroup
                    End If
                Case 5
againarraystring:

                    If neoGetArray(bstack, W$, ppppL) Then
                        If NeoGetArrayItem(ppppL, bstack, W$, v, b$) Then

                            'If VarTypeName$(ppppL.item(v)) = mGroup Then
                            If ppppL.ItemType(v) = mGroup Then
                                If Left$(b$, 1) = "." Then
                                    If SpeedGroup(bstack, ppppL, "VAL", "", b$, v) = 1 Then
                                        If Typename(bstack.lastobj) = mGroup Then
                                            Set ppppL = New ppppLight
                                            ppppL.Arr = False
                                            Set ppppL.GroupRef = bstack.lastobj
                                            v = -2
                                        Else
                                            MissingGroup
                                            Exit Function
                                        End If
                                    Else
                                        Exit Function
                                    End If
                                End If

                            
                            
                            
startwithgroup:
                                
                                
                                Execute = SpeedGroup(bstack, ppppL, "FOR", W$, b$, v)
                                Set ppppL = Nothing ' ok here
                                If Execute = 0 Then
                                    If LastErNum1 = 0 Then SyntaxError
                                    Exit Function
                                ElseIf Execute <> 1 And b$ <> "" Then
                                    once = False
                                    Exit Function
                                End If
                                sss = Len(b$)
                                GoTo loopagain
                            End If
                            If MaybeIsSymbol(b$, "=<") Then
                            NotForArray
                            Else
                            MissingGroup
                            End If
                        Else
                            NotExistArray
                        End If
                        Execute = 0
                        Exit Function
                    Else
                        ok = False
                        If Right$(W$, 2) <> "$(" Then
                            W$ = Left$(W$, Len(W$) - 1) + "$("
                            GoTo againarraystring
                        End If
                    End If
                Case 6
                    If neoGetArray(bstack, W$, ppppL) Then
                        If NeoGetArrayItem(ppppL, bstack, W$, v, b$) Then
                            'If VarTypeName$(ppppL.item(v)) = mGroup Then
                            If ppppL.ItemType(v) = mGroup Then
                                GoTo startwithgroup
                            Else
                                If TypeOf ppppL Is mArray Then
                                    Set pppp = ppppL
                                    If pppp.IsStringItem(v) Then
                                        ec$ = pppp.item(v)
                                        x1 = Abs(IsLabelBig(bstack, ec$, W$, , SBB$, , True))
                                        If Not ec$ = vbNullString Then b$ = ec$ + b$
                                        Set pppp = New mArray
                                        GoTo againfor948
                                    Else
                                        MissString
                                        Execute = 0
                                        Exit Function
                                    End If
                                Else
                                        Execute = 0
                                        Exit Function
                                End If
                            End If
                        Else
                            Execute = 0
                            Exit Function
                        End If
                    Else
                        NotExistArray
                    End If
                End Select
                If Not ok Then
                    Execute = 0
                    Exit Function
                End If
            Case "NEXT", "еполемо"
contNext:
                If IsLabel(bstack, b$, W$) Then
                    If bstack.IsInRetStackString(ss$) Then
                        'ss$ = bstack.RetStack.PopStr
                        If ss$ <> W$ Then
                            bstack.RetStack.PushStr ss$
                            MissNext
                            Execute = 0
                            Exit Function
                        Else
                            With bstack.RetStack
                               .drop 1
                               .PushVal Len(b$)
                               .PushStr ss$
                           End With
                        End If
                        Exit Function
                    End If
                Else
                ' NEW FOR M2000, WE CAN USE NO VARIABLE
                    If bstack.IsInRetStackString(ss$) Then
                            With bstack.RetStack
                               .drop 1
                               .PushVal Len(b$)
                               .PushStr ss$
                           End With
                        Exit Function
                    End If
                End If
            Case "CALL", "йакесе"
        ' CHECK FOR NUMBER...
contCall:
                On Error Resume Next
                Err.Clear
                NeoCall ObjPtr(bstack), b$, Lang, ok
                If Not ok Or Err <> 0 Then
                    Execute = 0
                    Exit Function
                End If
        
            Case "INLINE", "емхесг"
ContInline:
                If once = True Then Execute = 0: Exit Function
                If IsLabelSymbolNew(b$, "йыдийа", "CODE", Lang) Then
                    If IsLabelDot(here$, b$, sw$) = 1 Then
                        If GetSub(myUcase(sw$, True), nd&) Then
                            WaitShow = Len(b$)
                            bstack.addlen = 0
                            If IsSymbol(b$, ",") Then
                                If Lang = 1 Then
                                    b$ = vbCrLf + "Inline code " + b$
                                Else
                                    b$ = vbCrLf + "╦МХЕСГ йЧДИЙА " + b$
                                End If
                            End If
                            b$ = vbCrLf + sbf(nd&).sb + b$
                            If trace Then TestShowSub = b$
                            sss = Len(b$)
                            GoTo again1
                        ElseIf GetSub(here$ + sw$, nd&) Then
                            WaitShow = Len(b$)
                            b$ = vbCrLf + sbf(nd&).sb + b$
                            If trace Then TestShowSub = b$
                            sss = Len(b$)
                            GoTo again1
                        End If
                    Else
                        GoTo errstat1
                    End If
                Else
                    If IsStrExp(bstack, b$, ss$, False) Then
                        WaitShow = Len(b$)
                        bstack.addlen = 0
                        b$ = vbCrLf + ss$ + b$
                        If trace Then TestShowSub = b$
                        sss = Len(b$)
                        GoTo again1
                    Else
                        SyntaxError
                        Execute = 0
                        Exit Function
                    End If
                End If
            Case "UPDATE", "епийаияо"
contUpdate:
                If Len(bstack.UseGroupname) > 0 Then
                    b$ = ": set " + Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1) + "=" + Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1) + vbCrLf + b$
                    sss = Len(b$)
                Else
                    OnlyInAGroup
                    Execute = 0
                    Exit Function
                End If
                GoTo again1
            Case "AFTER", "лета"
contAfter:
                If linebyline Then
                    b$ = W$ + " " + b$
                    Execute = Execute(bstack, b$, once, False)
                    Exit Do
                End If
                If once = True Then Execute = 0: Exit Function
                If IsExp(bstack, b$, p) Then
                    If FastSymbol(b$, "{") Then
                        ss$ = block(b$) + vbCrLf + "thread this erase"
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                        sp = GetTaskId + 20000
                        b$ = Mid$(b$, 2)
                        Set bs = New basetask
                        bs.IamAnEvent = bstack.IamAnEvent
                        Set bs.Parent = bstack
                        bstack.PushThread CLng(sp), "after"
                        sThreadInternal bs, sp, 0, ss$, uintnew(p), here$, True
                        Set bs = Nothing
                        LLL = 0
                        Execute = 1
                    Else
                        LLL = 0
                        b$ = vbCrLf & "WAIT " & Int(p) & ": " & b$
                        Execute = 1
                    End If
                End If
            Case "сведио", "DRAWING"
contDraw:
            If Not linebyline Then
                    If once = True Then Execute = 0: Exit Function
                End If
                Execute = 0
                If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                    If Not FastSymbol(b$, ",", True) Then Execute = 0: Exit Function
                    If Not IsExp(bstack, b$, sp, flatobject:=True, nostring:=True) Then MissParam b$: Execute = 0: Exit Function
                If FastSymbol(b$, "{") Then
                    ss$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If
                     TraceStore bstack, nd&, b$, 0
                    Mid$(b$, 1, 1) = " "
                     x2 = Len(b$)
                    
                    If Not MakeEmf(bstack, b$, Lang, ss$, p, sp) Then
                    
                        Execute = 0:  b$ = ss$ + space$(x2): Exit Function
                    End If
                    TraceRestore bstack, nd&
                    Execute = 1
                    Else
                        SyntaxError
                        Execute = 0: Exit Function
                End If
                Else
                    If FastSymbol(b$, "{") Then
                        ss$ = block(b$)
                                    If Not Left$(b$, 1) = "}" Then
                                        Execute = CheckBlock(once): Exit Function
                                    End If
                        TraceStore bstack, nd&, b$, 0
                        Mid$(b$, 1, 1) = " "
                        x2 = Len(b$)
                        If Not MakeEmf(bstack, b$, Lang, ss$) Then
                        
                            Execute = 0: b$ = ss$ + space$(x2): Exit Function
                        End If
                        TraceRestore bstack, nd&
                        Execute = 1
                        Else
                        SyntaxError
                            Execute = 0: Exit Function
                    End If
                End If
            Case "дуадийо", "BINARY"
contBinary:
                If Not linebyline Then
                    If once = True Then Execute = 0: Exit Function
                End If
                Execute = 0
                If FastSymbol(b$, "{") Then
                    ss$ = block(b$)
                    
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If
                    b$ = Mid$(b$, 2)
                    If Not GetRes(bstack, b$, Lang, ss$) Then
                        Execute = 0: Exit Function
                    End If
                    Execute = 1
                End If
            Case "леяос", "PART"
contPart:
                If Not linebyline Then
                    If once = True Then Execute = 0: Exit Function
                End If
                Execute = 0
                If FastSymbol(b$, "{") Then
                    ss$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                    x2 = Len(b$)
                    TraceStore bstack, nd&, b$, 0
                    b$ = Mid$(b$, 2)
                    If IsLabelSymbolNew(b$, "ыс", "AS", Lang) Then
          ' search for variable name only
                        ok = False
                        If Abs(IsLabel(bstack, b$, W$)) = 1 Then
                            If GetlocalVar(W$, v) Then ' exist...
                                LLL = 0
                                If var(v) = 0 Then var(v) = True: ok = True
                            ElseIf GetVar(bstack, W$, v) Then ' exist...
                                LLL = 0
                                If var(v) = 0 Then var(v) = True: ok = True
                            Else
                                v = globalvar(W$, ok, , VarStat, temphere$)
                                LLL = 0
                            End If
                            If ok Then
                                ok = False
                                Execute = 1
                                Call executeblock(Execute, bstack, ss$, (once), ok, , True)
                                bstack.addlen = nd&
                                If Execute = 0 Then b$ = ss$ + space$(x2): Exit Function
                                
                                var(v) = False
                                ok = True
                                If linebyline Then
                                    ClearStr b$
                                    Exit Do
                                End If
                            Else
                                bstack.addlen = nd&
                                Execute = 1
                            End If
                            
                        Else
                            ' ????
                            Exit Function
                        End If
                    Else
                        SyntaxError
                        Execute = 0
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
        
            Case "DO", "REPEAT", "епамакабе", "епамекабе"
ContRepeat:
                If linebyline Then
                    b$ = W$ + " " + b$
                    sw$ = here$
                    Execute = Execute(bstack, b$, once, False)
                    SwapStrings sw$, here$
                    Exit Do
                End If
                If once = True Then Execute = 0: Exit Function
                sw$ = here$
                If Not FastSymbol(b$, "{") Then
                I = 1
                aheadstatusDO b$, I, Lang, ok
                If ok Then
                    v = Len(b$)
                    ss$ = Left$(b$, I - 1)
                    b$ = Mid$(b$, I)
                    
                    TraceStore bstack, x1, b$, 0
                    
                    y1 = bstack.addlen
                    GoTo contdo
                Else
                    MissUntil
                    Execute = 0
                    Exit Function
                End If
                Else

                    v = Len(b$)
                    ss$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                    TraceStore bstack, x1, b$, 0
                     b$ = Mid$(b$, 2)
                    y1 = bstack.addlen
contdo:
                    ok = False
                    sss = Len(b$)
                    ec$ = ss$
                    If IsLabelSymbolNew(b$, "осо", "WHEN", Lang) Then
                    nchr = True
                    GoTo CONDwhen
                    End If
                    If IsLabelSymbolNew(b$, "левяи", "UNTIL", Lang) Then
                    nchr = False
CONDwhen:
                        Execute = 1
                        bstack.addlen = y1
                        Call executeblock(Execute, bstack, ss$, once, ok, , True)
                        bstack.addlen = x1
                            If Execute = 0 Then
                                b$ = space$(v - (Len(ec$) - Len(ss$)))
                                Execute = 0: Exit Function
                            ElseIf Execute = 2 Then
                                If ss$ <> "" And Not ok Then
                                    b$ = ss$: Exit Function
                                ElseIf ss$ = "" And ok Then
                                    b$ = "BREAK": Exit Function
                                End If
                            End If
                            If Execute = 3 Then ok = False
                            If ok Or MOUT Then
                                If ok Then
                                    ss$ = GetNextLine(b$)  'FORGET ANY CODE TO THE RIGHT
                                Else
                                    Exit Function
                                End If
                            Else
                                sss = Len(b)
                                W$ = b$
                                If IsExp(bstack, b$, p) Then
                                If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is mHandler Then
                                
                                Set usehandler = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                
                                    With usehandler
                                            If .UseIterator Then
                                                I = .indirect
                                                If I < 0 Then
                                                    Set myobject = .objref
                                                    If TypeOf myobject Is mHandler Then
                                                        Set usehandler1 = myobject
                                                        Set myobject = usehandler1.objref
                                                        Set usehandler1 = Nothing
                                                    End If
                                                Else
                                                    InternalError
                                                    b$ = vbNullString
                                                    Exit Function
                                                End If
                                                p = .index_End <> -1 And Not myobject.IsEmpty
                                                If p Then
                                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                                    If v >= 0 Then
                                                        p = .index_cursor < .index_End
                                                    Else
                                                        p = .index_cursor > .index_End
                                                    End If
                                                    If p Then myobject.Index = .index_cursor + v: .index_cursor = .index_cursor + v
                                                End If
                                                p = Not p
                                            ElseIf .IamEnum Then
                                                p = .Iterate()
                                                p = Not p
                                            End If
                                        
                                        End With
                                        Set usehandler = Nothing
                                    End If
                                  End If
                                W$ = Left$(W$, Len(W$) - Len(b$))
                                If nchr Then p = p = 0
                                If p = 0 Then
                                    bb$ = W$
                                    ok = False
                                    Do
                                        ss$ = ec$
                                        W$ = bb$
                                        Execute = 1
                                        bstack.addlen = y1
                                        Call executeblock(Execute, bstack, ss$, once, ok, , True)
                                        bstack.addlen = x1
                                        If Execute = 0 Then
                                            b$ = space$(v - (Len(ec$) - Len(ss$)))
                                            SwapStrings sw$, here$
                                            Execute = 0: Exit Function
                                        ElseIf Execute = 2 Then
                                            If ss$ <> "" And Not ok Then
                                                SwapStrings sw$, here$
                                                b$ = ss$: Exit Function
                                            ElseIf ss$ = "" And ok Then
                                                SwapStrings sw$, here$
                                                b$ = "BREAK": Exit Function
                                            End If
                                        End If
                                        If Execute = 3 Then ok = False
                                        If ok Or MOUT Then Exit Do
                                        IsExp bstack, W$, p
                                    
                                    If Not bstack.lastobj Is Nothing Then
                                        If TypeOf bstack.lastobj Is mHandler Then
                                        Set usehandler = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        With usehandler
                                            If .UseIterator Then
                                                I = .indirect
                                                If I < 0 Then
                                                    Set myobject = .objref
                                                    If TypeOf myobject Is mHandler Then
                                                        Set usehandler1 = myobject
                                                        Set myobject = usehandler1.objref
                                                        Set usehandler1 = Nothing
                                                    End If
                                                Else
                                                    InternalError
                                                    b$ = vbNullString
                                                    Exit Function
                                                End If
                                                p = .index_End <> -1 And Not myobject.IsEmpty
                                                If p Then
                                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                                    If v >= 0 Then
                                                        p = .index_cursor < .index_End
                                                    Else
                                                        p = .index_cursor > .index_End
                                                    End If
                                                    If p Then myobject.Index = .index_cursor + v: .index_cursor = .index_cursor + v
                                                End If
                                                p = Not p
                                            ElseIf .IamEnum Then
                                                p = .Iterate()
                                                p = Not p
                                            End If
                                         End With
                                         Set usehandler = Nothing
                                        End If
                                    End If
                                    If nchr Then p = p = 0
                                    Loop Until p
                                    SwapStrings sw$, here$
                                End If
                            End If
                        End If
                    Else
                 ' play always
                        If IsLabelSymbolNew(b$, "памта", "ALWAYS", Lang) Then
                            Do
                                ss$ = ec$
                                Execute = 1
                                bstack.addlen = y1
                                Call executeblock(Execute, bstack, ss$, once, ok, , True, True)
                                bstack.addlen = x1
                                
                                If Execute = 0 Then
                                    b$ = space$(v - (Len(ec$) - Len(ss$)))
                                    SwapStrings sw$, here$
                                    Execute = 0: Exit Function
                                ElseIf Execute = 2 Then
                                    If ss$ <> "" And Not ok Then
                                        SwapStrings sw$, here$
                                        b$ = ss$: Exit Function
                                    ElseIf ss$ = "" And ok Then
                                        SwapStrings sw$, here$
                                        b$ = "BREAK": Exit Function
                                    End If
                                ElseIf Execute = 1 Then
                                'If ok Then once = True: b$ = vbNullString: Exit Function
                                ElseIf Execute = 3 Then
                                ok = False
                                End If
                                If ok Or MOUT Then Exit Do
                            Loop
                        Else
                            Execute = 0
                            Exit Function
                        End If
                 End If
                        lbl = False
                        If Len(b$) > 0 Then
                        If Left$(b$, 2) = vbCrLf Then lbl = True
                        End If
            End If
        Case "емы", "WHILE"
contWhile:
            If linebyline Then
                b$ = W$ + " " + b$
                sw$ = here$
                Execute = Execute(bstack, b$, once, False)
                SwapStrings sw$, here$
                Exit Do
            End If
            If once = True Then Execute = 0: Exit Function
            I = 0
            x1 = 0
again112:
            I = I + 1
            If Len(aheadstatus(b$, False, I)) > 0 Then
            x1 = I
            If MaybeIsSymbol3(b$, ",", I) Then GoTo again112
            End If
            If x1 > 0 Then
            Else
            SyntaxError
            Execute = 0
            Exit Function
            End If
            x1 = x1 - 1
            W$ = Left$(b$, x1)
            
            
            
            If IsExp(bstack, W$, p, nostring:=True) Then
            
                st = True
                ss$ = vbNullString
getanother:
                            If Not bstack.lastobj Is Nothing Then
                            If TypeOf bstack.lastobj Is mHandler Then
                            Set usehandler = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            With usehandler
                            If .UseIterator Then
                                I = .indirect
                                If I < 0 Then
                                    Set myobject = .objref
                                    If TypeOf myobject Is mHandler Then
                                        Set usehandler1 = myobject
                                        Set myobject = usehandler1.objref
                                        Set usehandler1 = Nothing
                                    End If
                                Else
                                    InternalError
                                    b$ = vbNullString
                                    Exit Function
                                End If
                                p = .index_End <> -1 And Not myobject.IsEmpty
                                If p Then
                                    myobject.Index = .index_start
                                    .index_cursor = .index_start
                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                End If
                            ElseIf .IamEnum Then
                                p = .index_End <> -1
                                If p Then
                                    If .index_End <> 0 Then
                                        p = .Iterate()
                                    End If
                                End If
                            End If
                            Set bstack.lastobj = Nothing
                        End With
                        Set usehandler = Nothing
                    End If
                End If
                st = st And p
                If FastSymbol(W$, ",") Then
                    If IsExp(bstack, W$, p) Then
                        If Not bstack.lastobj Is Nothing Then GoTo getanother
                    Else
                        MissNumExpr
                        Execute = 0
                        Exit Function
                    End If
                End If
                    If Not Len(NLtrim(W$)) = 0 Then
                    If Len(W$) > x1 Then
                    b$ = W$ + b$
                    ElseIf Len(W$) = x1 Then
                    Mid$(b$, 1, x1) = W$
                    Else
                    Mid$(b$, 1, x1) = space$(x1 - Len(W$)) + W$
                    End If
                    
                    End If
                    'w$ = Left$(w$, Len(w$) - Len(b$))
                    W$ = Left$(b$, x1)
                    b$ = Mid$(b$, x1 + 1)
                    If p = 0# Then
                        If FastSymbol(b$, "{") Then
                            W$ = block(b$)
                            If Not Left$(b$, 1) = "}" Then
                                Execute = CheckBlock(once): Exit Function
                            End If
                          '  b$ = NLtrim$(b$)
                            If FastSymbol(b$, "}") Then
                                b$ = NLtrim(b$)
                                If b$ = vbNullString Then Exit Function
                                GoTo again1
                            Else
                                b$ = NLtrim$(b$)
                                If b$ = vbNullString Then Exit Function
                                GoTo again1
                            End If
                        Else
                                I = 1
                                aheadstatusENDWHILE b$, I, Lang, ok, sss
                               If Not ok Then
                                   MissWhile
                                Execute = 0
                                Exit Function
                            End If
                                b$ = NLtrim(Mid$(b$, I))
                                If b$ = vbNullString Then Exit Function
                                                        lbl = False
                                                If Len(b$) > 0 Then
                                                If Left$(b$, 2) = vbCrLf Then lbl = True
                                                End If
                                GoTo again1
                            Exit Do
                        End If
                    Else
                        If Not FastSymbol(b$, "{") Then
                        I = 1
                        aheadstatusENDWHILE b$, I, Lang, ok, sss
                        If ok Then
                            ss$ = Left$(b$, sss - 1) + space$(I - sss)
                            b$ = Mid$(b$, I)
                            TraceStore bstack, x1, b$, 0
                            y1 = bstack.addlen
                            ec$ = ss$
                            
                            GoTo contWhile1
                        Else
                            MissWhile
                            Execute = 0
                            Exit Function
                        End If
                        
                        Else
                            ss$ = block(b$)
                            If Not Left$(b$, 1) = "}" Then
                                Execute = CheckBlock(once): Exit Function
                            End If
                            TraceStore bstack, x1, b$, 0
                            y1 = bstack.addlen
                            ec$ = ss$
                            b$ = Mid$(b$, 2)
contWhile1:
                            sss = Len(b$)
                            bb$ = W$
                            Execute = 1
                            ok = False
                            sw$ = here$
                            Do
                                st = True
                                ss$ = ec$
                                W$ = bb$
                                bstack.addlen = y1
                                If executeblock(Execute, bstack, ss$, once, ok, , True) Then
                                    SwapStrings sw$, here$
                                    TraceRestore bstack, x1
                                    If Execute = 2 Then
                                    If ok And ss$ = "" Then b$ = "BREAK": Exit Function
                                    b$ = ss$: Exit Function
                                    End If
                                    b$ = ss$ + b$
                                    Exit Function
                                Else
                                    SwapStrings sw$, here$
                                    TraceRestore bstack, x1
                                    If Execute = 2 And ss$ <> "" And Not ok Then
                                        b$ = ss$
                                        Exit Function
                                    ElseIf Execute = 12 Then
                                        Execute = 2
                                        b$ = ss$
                                        Exit Function
                                    End If
                                End If
                                If Execute = 3 Then ok = False
                                If ok Or MOUT Then Exit Do
another1:
                                IsExp bstack, W$, p
                                                           If Not bstack.lastobj Is Nothing Then
                            If TypeOf bstack.lastobj Is mHandler Then
                            Set usehandler = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            With usehandler
                                            If .UseIterator Then
                                                I = .indirect
                                                If I < 0 Then
                                                    Set myobject = .objref
                                                    If TypeOf myobject Is mHandler Then
                                                        Set usehandler1 = myobject
                                                        Set myobject = usehandler1.objref
                                                        Set usehandler1 = Nothing
                                                    End If
                                                Else
                                                    InternalError
                                                    b$ = vbNullString
                                                    Exit Function
                                                End If
                                                p = .index_End <> -1 And Not myobject.IsEmpty
                                                If p Then
                                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                                    If v >= 0 Then
                                                        p = .index_cursor < .index_End
                                                    Else
                                                        p = .index_cursor > .index_End
                                                    End If
                                                    If p Then myobject.Index = .index_cursor + v: .index_cursor = .index_cursor + v
                                                End If
                                            ElseIf .IamEnum Then
                                                p = .Iterate()
                                            End If
                                        End With
                                        Set usehandler = Nothing
                                        End If
                                    End If
                               
                                st = st And p
                                If FastSymbol(W$, ",") Then GoTo another1
                            Loop Until st = 0 Or NOEXECUTION
                 ' addition in 8.9 rev 33
                            Set bstack.lastobj = Nothing
                            If MOUT Then Execute = 0: Exit Function
                    End If
                End If
            End If
                        lbl = False
                        DropCommentOrLine b$, True
                        sss = Len(b$)
                        If Len(b$) > 0 Then
                            If Left$(b$, 2) <> vbCrLf Then
                                GoTo jumpforCR
                            End If
                        Else
                            Exit Do
                        End If
                        
        Case "йахе", "EVERY"
contEvery:
            If once = True Then Execute = 0: Exit Function
            If linebyline Then
                b$ = W$ + " " + b$
                sw$ = here$
                Execute = Execute(bstack, b$, once, False)
                SwapStrings sw$, here$
                Exit Do
            End If
            If IsExp(bstack, b$, p) Then
                If p <= 0 Then
                    If FastSymbol(b$, "{") Then
                        W$ = block(b$)
                        If Not Left$(b$, 1) = "}" Then
                              Execute = CheckBlock(once): Exit Function
                        End If
                        b$ = Mid$(b$, 2)
                        sss = Len(b$)
                    Else
                        Exit Do
                    End If
                Else
                    sw$ = here$
                    If FastSymbol(b$, "{") Then
                        ss$ = block(b$) '+ "}"
                        If Not Left$(b$, 1) = "}" Then
                            Execute = CheckBlock(once): Exit Function
                        End If
                        ec$ = ss$
                        b$ = Mid$(b$, 2)
                        sss = Len(b$)
                        Execute = 1
                        ok = False
                        ' GET A TICK HERE
                        
                        If p < 1 Then p = 1
                        
                        y2 = Signed(p)
                        'sX = y2
                        'Call GetSystemTimeAsFileTime(basictimer)
                        x2 = timeGetTime
                        Do
                            ss$ = ec$
                            'y2 = sX
                            Execute = 1
                            Call executeblock(Execute, bstack, ss$, once, ok, , True)
                            If Execute = 0 Then   '''Execute(bstack, ss$, ok) = 0
                                If NOEXECUTION Then
                                    b$ = "START"
                                    Execute = 1
                                    ok = True
                                    Exit Do
                                End If
                                b$ = ss$ + b$
                                SwapStrings sw$, here$
                                Execute = 0: Exit Function
                            ElseIf Execute = 2 Then
                                If Len(ss$) > 0 Then
                                    SwapStrings sw$, here$
                                    b$ = ss$: Exit Function
                                ElseIf ok Then
                                    b$ = "BREAK": once = True
                                    SwapStrings sw$, here$
                                    Exit Function
                                End If
                            End If
                            If ok Or MOUT Then Exit Do
                            If UnsignedSub(timeGetTime, x2) > y2 Then
                                '
                                x2 = UnsignedSub(x2, Not y2) ' // add
                            End If
                            If bstack.IamThread Then SkipRefresh bstack
                                Do
                                    ProcTask2 bstack
                                    x1 = timeGetTime
                                Loop Until UnsignedSub(x1, x2) >= y2
                                x2 = x1
                            
                        Loop
                        SwapStrings sw$, here$
                        If NOEXECUTION Then
                            b$ = "START"
                            Execute = 1
                            ok = True
                            Exit Do
                        End If
                        If MOUT Then Execute = 0: Exit Function
                    Else
                        sss = Len(b$)
                    End If
                End If
            End If
        Case "йуяио.еяцо", "MAIN.TASK", "TASK.MAIN"
contTask:
            If once = True Then Execute = 0: Exit Function
            If linebyline Then
                b$ = W$ + " " + b$
                sw$ = here$
                Execute = Execute(bstack, b$, once, False)
                SwapStrings sw$, here$
                Exit Do
            End If
            ' only one task main
            If taskmainonly = True Then Execute = 0: Exit Function
            taskmainonly = True
            W$ = b$
            Execute = 1
            If IsExp(bstack, b$, p) Then
                If FastSymbol(b$, "{") Then
                    ss$ = block(b$)
                    If Not Left$(b$, 1) = "}" Then
                        Execute = CheckBlock(once): Exit Function
                    End If
                    b$ = Mid$(b$, 2)
                    sp = GetTaskId + 20000
                    Set bs = New basetask
                    Set bs.Parent = bstack
                    bstack.PushThread CLng(sp), "_multi"
                    sThreadInternal bs, sp, 10, ss$, -1&, here$, True
                    TaskMaster.Message CLng(sp), 3, CLng(uintnew(p))
                    On Error Resume Next
                    bstack.TaskMain = True
                    I = 0
                    Do
                        If TaskMaster Is Nothing Then Execute = 0: Exit Function
                        If TaskMaster.PlayMusic Then
                            TaskMaster.OnlyMusic = True
                            TaskMaster.TimerTick
                            TaskMaster.OnlyMusic = False
                        End If
                        If TaskMaster Is Nothing Then Execute = 0: Exit Function
                        
                            
                            If TaskMaster.Processing Then
                                TaskMaster.TimerTick
                                I = 0
                            Else
                            'MyDoEvents0 di
                            'MyDoEventsNoRefresh
                            If I = 1 Then
                                DoEvents
                                I = 10
                            Else
                                If Timer Mod (100 + I) < 10 Then I = I + 1
                            End If
                        End If
                        
                        bstack.TaskMain = bstack.exist(CLng(sp), "_multi") = False
                    Loop Until MOUT Or bstack.TaskMain Or NOEXECUTION Or TaskMaster.QueueCount < 2
                    If bstack.exist(CLng(sp), "_multi") Then
                        TaskMaster.Message CLng(sp), 1
                    End If
                    On Error GoTo 0
                    bstack.TaskMain = False
                    If TaskMaster.PlayMusic Then mute = True
                End If
            End If
            taskmainonly = False
            If MOUT Then Execute = 0: Exit Function
        Case "ELSE", "аккиыс"
ContElse:
    
            
            If IFCTRL = 0 Then
            If lookB123(b$) Then
                If HaveMark(bstack, I, ok) Then
                  If I = 0 Then
                    SyntaxError
                    Execute = 0: Exit Function
                    End If
                    If (Not ok) Or I = 2 Then
                 
findEndif:
                       I = SetNextLineCLR(b$)
                        I = MyTrimLi(b$, I + 1)
                        If I > 0 Then
                        
                        aheadstatusENDIF b$, I, Lang, ok
                        If Not ok Then Execute = 0: Exit Function
                        
                        If I = Len(b$) + 2 Then MissENDIF: Execute = 0: Exit Function
                        DropMark bstack
                        bstack.UseofIf = bstack.UseofIf - 1

                        b$ = Mid$(b$, I)
                        Else
                        b$ = vbNullString
                        End If
                        sss = Len(b$)
                        lbl = False
                        If Len(b$) > 0 Then
                        If Left$(b$, 2) = vbCrLf Then lbl = True
                        End If

                
                    Else
                    ' no other else.if
                    DropMark bstack
                    MarkIf bstack, 0, False
                    End If
                  GoTo loopcontinue
                End If
            End If
                SyntaxError
                Execute = 0
                Exit Function
                
            Else
                If (Not jump) Or IFCTRL = 2 Then
                
                    If FastSymbol(b$, "{") Then
                        W$ = block(b$)
                            If Not Left$(b$, 1) = "}" Then
                                Execute = CheckBlock(once): Exit Function
                            End If
                        b$ = Mid$(b$, 2)
                                    DropCommentOrLine b$, True
                                    If Not CheckFreeExecute(b$) Then
                                        SyntaxError
                                        Execute = 0
                                        Exit Function
                                    End If
                    ElseIf lookB123(b$) Then
                        I = SetNextLineCLR(b$)
                        I = MyTrimLi(b$, I + 1)
                        If I > 0 Then
                        
                        aheadstatusENDIF b$, I, Lang, ok
                        If Not ok Then Execute = 0: Exit Function
                        If I = Len(b$) + 2 Then MissENDIF: Execute = 0: Exit Function
                        DropMark bstack
                        bstack.UseofIf = bstack.UseofIf - 1
                        b$ = Mid$(b$, I)
                        Else
                        b$ = vbNullString
                        End If
                        lbl = True
                    Else
                    If Not once Then
                        SetNextLine b$
                        End If
                        lbl = True
                        jump = False
                        sss = Len(b$)
                        GoTo loopagain
                        lbl = True
                    End If
                    jump = False
                Else
                    If IsNumberLabel(b$, W$) Then
                        once = False
                        b$ = W$
                        Execute = 2
                        Exit Function
                    End If
                    If lookB123(b$) Then
                    If Not once Then
                        SetNextLineCLR b$
                        End If
                        lbl = True
                        jump = False
                        sss = Len(b$)
                        GoTo loopagain
                    End If
                                lbl = False
                                IFCTRL = 0 ' NONEED ANYTHING AND ERROR FOR IF.ELSE AND ELSE
                                jump = False
                                sss = Len(b$)
                                If FastSymbol(b$, "{") Then
                                    ss$ = block(b$)
                                    If Not Left$(b$, 1) = "}" Then
                                        Execute = CheckBlock(once): Exit Function
                                    End If
                                    TraceStore bstack, nd&, b$, 0
                                    b$ = Mid$(b$, 2)
                                    Call executeblock(Execute, bstack, ss$, False, ok, , True)
                                    TraceRestore bstack, nd&
                                    If Execute = 2 Then
                                        If Len(ss$) > 0 Then b$ = ss$: Exit Function
                                        If ok Then b$ = "BREAK": once = True: Exit Function
                                    End If
                                    DropCommentOrLine b$, True
                                    If Not CheckFreeExecute(b$) Then
                                        SyntaxError
                                        Execute = 0
                                        Exit Function
                                    End If
                    Else
                
                    If once Or linebyline Then GoTo again1
                    End If
                    
                End If
                
            End If
            IFCTRL = 0 ' NONEED ANYTHING AND ERROR FOR IF.ELSE AND ELSE
            jump = False

                    lbl = False
                    
                    DropCommentOrLine b$, True
                    sss = Len(b$)
                    If Len(b$) > 0 Then
                        If Left$(b$, 2) <> vbCrLf Then
                            GoTo againExtra2
                        End If
                    Else
                        Exit Do
                    End If
            
        Case "TRY", "дес"
ContTry:
            If IsLabelSymbolNew(b$, "яеула", "STREAM", Lang) Then
                If bstack.CallW <> "" Then
                    ss$ = here$
                    I = bstack.soros.Total
                    here$ = bstack.fHere
                    If bstack.strg Then
                        If IsStrExp(bstack, (bstack.CallW), ec$) Then
                            bstack.soros.DataStr ec$
                        End If
                    Else
                        If IsExp(bstack, (bstack.CallW), p) Then
                            bstack.soros.DataVal p
                        End If
                    End If
                    here$ = ss$
                End If
                GoTo loopagain
            End If
            If once = True Then Execute = 0: Exit Function
            If linebyline Then
                b$ = W$ + " " + b$
                sw$ = here$
                PushErrStage bstack
                Execute = Execute(bstack, b$, once, False)
                PopErrStage bstack
                SwapStrings sw$, here$
                bstack.nokillvars = False
                Exit Do
            End If
        ' летабкгтг
            I = Abs(IsLabel(bstack, b$, W$))
            Select Case I
            Case 0  ' new
                If FastSymbol(b$, "{") Then
                    Execute = 1
                    ss$ = block(b$)
                    If Not Left$(b$, 1) = "}" Then
                        Execute = CheckBlock(once): Exit Function
                    End If
                    TraceStore bstack, x1, b$, 0
                    b$ = Mid$(b$, 2)
                    Execute = 1

                    PushErrStage bstack
                    Call executeblock(Execute, bstack, ss$, once, ok, , True)
                    PopErrStage bstack
                    TraceRestore bstack, x1
                    bstack.nokillvars = False
                    If NOEXECUTION Then Exit Function
                    once = False
                    MOUT = False
                   ' NOEXECUTION = False
                    NERR = False
                    LastErNum = 0
                    LastErNum1 = 0
                    bstack.ErrorOriginal = 0
                    If LastErName <> "" Then LastErName = Chr(0) + LastErName
                    If LastErNameGR <> "" Then LastErNameGR = Chr(0) + LastErNameGR
                        If Execute = 2 Then
                          If ss$ = "" Then
                             ' no here
                             ' b$ = ": Break"
                          Else
                              b$ = ": Goto " + ss$
                          End If
                          sss = Len(b$)
                          End If
                              Execute = 1
                        Else
                        SyntaxError
                        Execute = 0: Exit Function
                    End If
            Case 1, 4
                If FastSymbol(b$, "{") Then
                    p = 0#
                    If Not GetlocalVar(W$, v) Then
                        If Not GetVar(bstack, W$, v) Then
                            v = globalvar(W$, p, , VarStat, temphere$) '': GetlocalVar W$, v
                        End If
                    End If
                    Execute = 1
                    ss$ = block(b$)
                    If Not Left$(b$, 1) = "}" Then
                        Execute = CheckBlock(once): Exit Function
                    End If
                    b$ = Mid$(b$, 2)
                    LastErNum2 = 0
                    PushErrStage bstack
                    Call executeblock(Execute, bstack, ss$, once, ok, , True)
                    PopErrStage bstack
                    
                    var(v) = CDbl(Execute = 1)
                    If NOEXECUTION Then Exit Function
                    MOUT = False
                   ' NOEXECUTION = False
                    NERR = False
                    LastErNum = 0
                    LastErNum2 = LastErNum1
                    LastErNum1 = 0
                    bstack.ErrorOriginal = 0
                    If Execute = 2 Then
                          If ss$ = "" Then
    
                          Else
                              b$ = ": Goto " + ss$
                          End If
                          sss = Len(b$)
                          End If
                              Execute = 1
                Else
                SyntaxError
                Execute = 0: Exit Function
                End If
                
            End Select
            If MOUT Then Execute = 0: Exit Function
            Execute = 1
        Case "ELSE.IF", "аккиыс.ам"
contElseIf:
          '  If once = True Then Execute = 0: Exit Function
            If IFCTRL = 0 Then
                If HaveMark(bstack, I, ok) Then
                    If I = 0 Then
                    SyntaxError
                    Execute = 0: Exit Function
                    End If
                    x1 = 1
                    aheadstatusThen b$, x1, Lang, W$
                    If W$ = vbNullString Then
                        MissTHENELSE
                        Execute = 0
                        Exit Function
                    End If
                    
                    If lookB123(b$, x1) Then
                    'If MaybeIsSymbol3lot(b$, b123, (x1)) Then
                        If (Not ok) Or I = 2 Then
                    ' so we have to jump
                            x1 = I
                            I = SetNextLineCLR(b$)
                            I = MyTrimLi(b$, I + 1)
                            If I > 0 Then
                                aheadstatusELSEIF b$, I, Lang, ok, x1, (ok)
                                 If x1 = 0 Then
                              DropMark bstack
                              bstack.UseofIf = bstack.UseofIf - 1
                              End If
                                b$ = Mid$(b$, I)
                            Else
                                b$ = vbNullString
                            End If
                            sss = Len(b$)
                            lbl = True
                        Else
                        ' so we have to check expression
                            If IsExp(bstack, Left$(b$, x1), p, flatobject:=True, nostring:=True) Then
                                I = 1
                                ok = (p = 0#)
                                ' drop old save new
                                Select Case Lang
                                Case 0
                                    Select Case W$
                                    Case "аккиыс"
                                        Mid$(b$, 1, x1) = space(x1)
                                        ok = Not ok
                                        GoTo contThenElseIf
                                    Case "тоте"
                                      GoTo contThenElseIf
                                    End Select
                              Case 1
                                  Select Case W$
                                  Case "ELSE"
                                      Mid$(b$, 1, x1) = space(x1)
                                      ok = Not ok
                                        GoTo contThenElseIf
                                  Case "THEN"
contThenElseIf:
                                      If ok Then
                                            x1 = x1 + 1
                                            aheadstatusELSEIF b$, x1, Lang, ok, I, (ok)
                                                DropMark bstack
                                            If I = 0 Then
                                                bstack.UseofIf = bstack.UseofIf - 1
                                                Else
                                                MarkIf bstack, 1, True
                                            End If
                                            b$ = Mid$(b$, x1)
                                      Else
                                      Mid$(b$, 1, x1) = space(x1)
                                       DropMark bstack
                                        MarkIf bstack, 2, True
                                      End If
                                  End Select
                              End Select
                              sss = Len(b$)
                              lbl = True
                            End If
                        End If
                        GoTo loopcontinue
                    End If
                End If
                SyntaxError
                Execute = 0
                Exit Function
                
            Else
                ' use of flags
                If (Not jump) Or IFCTRL = 2 Then
                ' LOOK AHEAD...DO NOT PLAY THE LOGICAL EXPRESSION
                ' ALSO THROW ALL { } ELSE {} BECAUSE FOUND THAT IS AN EXPRESSION;;;
                    IFCTRL = 1
                    
                    aheadstatusIF b$, IFCTRL, Lang, W$
                    
                    If Len(W$) = 0 Then SyntaxError: Execute = 0: Exit Function
                    If FastOperator(b$, vbCrLf, IFCTRL, 2) Then
                    b$ = Mid$(b$, IFCTRL)
                                            SetNextLine b$
                          IFCTRL = 1
                    aheadstatusANY b$, IFCTRL
                    
                    b$ = Mid$(b$, IFCTRL)
                    Else
                    
                   ' aheadstatusANY b$, IFCTRL
                    
                    b$ = Mid$(b$, IFCTRL)
                    If FastSymbol(b$, "{") Then
                       W$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                                        b$ = Mid$(b$, 2)
                                         If FastSymbol(b$, ":") Then
                                    sss = Len(b$)
                                    
                                    IFCTRL = 0: GoTo again1
                                    End If
                    Else
                    SetNextLine b$
                    End If
                    End If
                     If bstack.RetStackTotal > 0 Then
                    If IsLabelSymbolNew(b$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                    If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                                                    If bstack.RetStack.LookTopVal = -3 Then
                                                        jump = False
                                                        IFCTRL = 0
                                                    End If
                                                Else
                    lbl = True
                    IFCTRL = 1
                    jump = False
                    I = 1
                    While FastOperator(b$, vbCrLf, I, 2)
                    Wend
                    If IsLabelSymbolNew(b$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                    If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                    End If
              
                Else   ' ONLY FOR NOT JUMP
                    If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
                        IFCTRL = 1
                        jump = (p = 0#)
                        I = 1
                        Select Case Abs(IsLabel(bstack, b$, W$))  ' now w$ is Ucase
                        Case 1
                            Select Case W$
                            Case "THEN", "тоте"
                                    'While FastOperator(b$, vbCrLf, i, 2)
                                    'Wend
                                    
                                If jump Then
                                    If FastSymbol(b$, "{") Then
                                        W$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                        b$ = Mid$(b$, 2)
                                         If FastSymbol(b$, ":") Then
                                    sss = Len(b$)
                                    
                                    IFCTRL = 0: GoTo again1
                                    End If

                                    Else
                                            I = 1
                                            aheadstatusELSE b$, I, Lang, W$
                                            If Len(W$) > 2 Then
                                            If Lang = 0 Then
                                                Select Case W$
                                                Case "аккиыс"
                                                    b$ = Mid$(b$, I)
                                                    GoTo ContElse
                                                Case "аккиыс.ам"
                                                     b$ = Mid$(b$, I)
                                                    GoTo contElseIf
                                                End Select
                                            Else
                                                Select Case W$
                                                Case "ELSE"
                                                    b$ = Mid$(b$, I)
                                                    GoTo ContElse
                                                Case "ELSE.IF"
                                                    b$ = Mid$(b$, I)
                                                    GoTo contElseIf
                                                End Select
                                         
                                                End If
                                                
                                                sss = Len(b$)
                                                
                                                GoTo again1
                                            Else
                                                SetNextLine b$
                                                lbl = True
                                            End If
                                        'End If
                                    End If
                                Else
                                    If Not FastSymbol(b$, "{") Then
                                    ' ELSE.IF true THEN ******************************************************
                                        If MaybeIsSymbol(b$, "0123456789") Then GoTo ContGoto
                                        I = 1
                                        aheadstatusELSE b$, I, Lang, W$
                                        If Len(W$) > 2 Then
                                        ' #1
                                            ss$ = Left$(b$, I - 1 - Len(W$)) '+ "}"
                                            
                                            If once Then
                                            
                                                once = False
                                                b$ = Mid$(b$, Len(ss$) + 1)
                                                TraceStore bstack, nd&, b$, 0
                                                Call executeblock(Execute, bstack, ss$, once, ok, , True, False)
                                                TraceRestore bstack, nd&
                                                If Execute = 0 Then
                                                   b$ = ss$ + b$
                                                ElseIf Execute = 5 Then
                                                 once = True
                                                GoTo contLoop
                                                ElseIf Execute = 6 Then
                                                b$ = vbNullString
                                                Execute = 2
                                                 once = True
                                                Exit Function
                                                ElseIf Execute = 2 And once Then
                                                    b$ = ss$
                                                    Exit Function
                                           ElseIf Execute = 3 Then
                                            b$ = ss$
                                            Exit Function
                                                Else
                                                    SetNextLine b$
                                                End If
                                                 once = True
                                                Exit Function
                                            Else
                                            ' else.if  then .... no block
                                                b$ = Mid$(b$, Len(ss$) + 1)
                                                ok = False
                                                 TraceStore bstack, nd&, b$, 0
                                                Call executeblock(Execute, bstack, ss$, False, ok, , True, False)
                                                 TraceRestore bstack, nd&
                                            End If
                                            If Execute = 1 Then
                                            If ok Then Exit Function
                                          
                                            GoTo contif2
                                            ElseIf Execute = 2 Then
                                                b$ = ss$
                                                once = False
                                                
                                            Exit Function
                                        ElseIf Execute = 6 Then
                                            GoTo ContRestart
                                        ElseIf Execute = 5 Then
                                            Execute = 2
                                            loopthis = True
                                            GoTo contif2
                                        Else
                                            If loopthis Then Execute = 2
                                            GoTo ContContinue
                                            End If
                                        Else
                                            IFCTRL = 2
                                        End If
                                    Else
contelseifpass:
                                        IFCTRL = 2
                                        ss$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                                        TraceStore bstack, nd&, b$, 0
                                        b$ = Mid$(b$, 2)
                                        Call executeblock(Execute, bstack, ss$, False, ok, , True)
                                       TraceRestore bstack, nd&
                                        If Execute = 1 Then
                                       ' If once Then Exit Do
                                        
                                        If FastSymbol(b$, ":") Then
                                        
                                            sss = Len(b$)
                                          IFCTRL = 0: GoTo again1
                                        End If
                                        If Not lookB123(b$) Then GoTo contif2
                                        Else
                                                  b$ = ss$
                                                once = False
                                                Execute = 2
                                                Exit Function
                                        End If
                                    End If
                                    
                                End If
                            Case "ELSE", "аккиыс"
                                   ' While FastOperator(b$, vbCrLf, i, 2)
                                    'Wend
                                    
                                If Not jump Then      ' JUMP FALSE SKIP ELSE
                                    If FastSymbol(b$, "{") Then
                                        W$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                        b$ = Mid$(b$, 2)
                                    Else
                                            I = 1
                                            
                                            aheadstatusELSE b$, I, Lang, W$
                                            If Len(W$) > 2 Then
                                             jump = True
                                            IFCTRL = 1
                                            If Lang = 0 Then
                                                Select Case W$
                                                Case "аккиыс"
                                                    b$ = Mid$(b$, I)
                                                    GoTo ContElse
                                                Case "аккиыс.ам"
                                                     b$ = Mid$(b$, I)
                                                    GoTo contElseIf
                                                End Select
                                            Else
                                                Select Case W$
                                                Case "ELSE"
                                                    b$ = Mid$(b$, I)
                                                    GoTo ContElse
                                                Case "ELSE.IF"
                                                    b$ = Mid$(b$, I)
                                                    GoTo contElseIf
                                                End Select
                                            End If
                                            sss = Len(b$)
                                            Else
                                                SetNextLine b$
                                                lbl = True
                                            End If
                                    
                                    End If
                                    jump = True
                                    IFCTRL = 1
                                Else
                                IFCTRL = 2
                                If MaybeIsSymbol(b$, "0123456789") Then GoTo ContGoto
                                I = 1
                                aheadstatusELSE b$, I, Lang, W$
                                If Len(W$) > 2 Then
                                ' #2
                                    ss$ = Left$(b$, I - 1 - Len(W$))
                                    If once Then
                                          once = False
                                                b$ = Mid$(b$, Len(ss$) + 1)
                                                TraceStore bstack, nd&, b$, 0
                                                Call executeblock(Execute, bstack, ss$, once, ok, , True, False)
                                                TraceRestore bstack, nd&
                                                
                                                If Execute = 0 Then
                                                   b$ = ss$ + b$
                                                ElseIf Execute = 5 Then
                                                once = True
                                                GoTo contLoop
                                                ElseIf Execute = 6 Then
                                                b$ = vbNullString
                                                Execute = 2
                                                once = True
                                                Exit Function
                                              ElseIf Execute = 3 Then
                                                    b$ = ss$
                                                    Exit Function
                                                ElseIf Execute = 2 And once Then
                                                    b$ = ss$
                                                    Exit Function
                                                Else
                                                    SetNextLine b$
                                                End If
                                                once = True
                                                Exit Function
                                Else
                                ' else.if else ..... no block
                                    b$ = Mid$(b$, Len(ss$) + 1)
                                    TraceStore bstack, nd&, b$, 0
                                    Call executeblock(Execute, bstack, ss$, False, ok, , True, False)
                                    TraceRestore bstack, nd&
                                    
                                End If
                                If Execute = 1 Then    ' else.if pass
                                If ok Then Exit Function
                                        If FastSymbol(b$, ":") Then
                                            sss = Len(b$)
                                          IFCTRL = 0: GoTo again1
                                        End If
                                        If Not lookB123(b$) Then GoTo contif2
                                ElseIf Execute = 2 Then
                                    If ok And Len(ss$) = 0 Then b$ = "BREAK" Else b$ = ss$
                                    once = False
                                    Exit Function
                                ElseIf Execute = 6 Then
                                    GoTo ContRestart
                                ElseIf Execute = 5 Then
                                loopthis = True
                                Execute = 2
                                Else
                                    If loopthis Then Execute = 2
                                    GoTo ContContinue
                                End If
                                Else
                                If FastSymbol(b$, "{") Then GoTo contelseifpass
                                End If
                              
                                End If
                            Case Else
                                Execute = 0
                                Exit Function
                            End Select
                             If bstack.RetStackTotal > 0 Then
                                If IsLabelSymbolNew(b$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                                If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                                                    If bstack.RetStack.LookTopVal = -3 Then
                                                        jump = False
                                                        IFCTRL = 0
                                                    End If
                                                Else
                           
                            If jump Or IFCTRL = 2 Then
                                I = 1
                                If Not once Then
                                If FastOperator(b$, vbCrLf, I, 2) Then
                                While FastOperator(b$, vbCrLf, I, 2)
                                Wend
                                End If
                                End If
                                If IsLabelSymbolNew(b$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                                If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                                
                            
                            End If
                            End If
                        Case Else
                            Execute = 0
                            Exit Function
                        End Select
                    Else
                        Execute = 0
                        Exit Function
                    End If
                End If
            End If
            sss = Len(b$)
        Case "IF", "ам"
contif:
       
       jump = 0
       IFCTRL = 0
        If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
            x1 = 1           ' NEED THEN OR ELSE OR ELSE.IF
            ok = (p = 0#)                    ' JUMP TRUE GOTO ELSE
            I = 1
            Select Case Abs(IsLabel(bstack, b$, W$))
            Case 1
            Select Case W$
                Case "THEN", "тоте"

                    If ok Then
                        If lookB123(b$) Then
                            I = SetNextLineCLR(b$)
                            MarkIf bstack, 1, ok
                            bstack.UseofIf = bstack.UseofIf + 1
                            x1 = 1
                            aheadstatusELSEIF b$, I, Lang, ok, x1, (ok)
                            DropMark bstack
                            If x1 = 0 Then
                                bstack.UseofIf = bstack.UseofIf - 1
                            Else
                                MarkIf bstack, 1, True
                            End If
                              
                              b$ = Mid$(b$, I)
         
                              IFCTRL = 0
                              jump = False
                        lbl = False
                        If Len(b$) > 0 Then
                        If Left$(b$, 2) = vbCrLf Then lbl = True
                        End If
                        sss = Len(b$)
                        GoTo loopcontinue
                    ElseIf FastSymbol(b$, "{") Then
                               '     If once = True Then Execute = 0: Exit Function
                                    W$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                    b$ = Mid$(b$, 2)
                                    If FastSymbol(b$, ":") Then
                                    sss = Len(b$)
                                    
                                    IFCTRL = 0: GoTo again1
                                    End If
                                       I = 1
                                        aheadstatusELSE b$, I, Lang, W$
                                        If Len(W$) > 2 Then GoTo contif22
                                        DropCommentOrLine b$, True
                                        If Not CheckFreeExecute(b$) Then
                                            SyntaxError
                                            Execute = 0
                                            Exit Function
                                        End If
                                        sss = Len(b$)
                                        GoTo loopagain
                                    
                    Else
contif2:
                                        I = 1
                                        aheadstatusELSE b$, I, Lang, W$
                                        If Len(W$) > 2 Then
contif22:
                                        jump = ok
                                        If IFCTRL = 0 Then IFCTRL = 1
                                            If Lang = 0 Then
                                                Select Case W$

                                                Case "аккиыс"
                                                    b$ = Mid$(b$, I)
                                                    GoTo ContElse
                                                Case "аккиыс.ам"
                                                     b$ = Mid$(b$, I)
                                                    GoTo contElseIf
                                                End Select
                                            Else
                                                Select Case W$
                                                Case "ELSE"
                                                    b$ = Mid$(b$, I)
                                                    GoTo ContElse
                                                Case "ELSE.IF"
                                                    b$ = Mid$(b$, I)
                                                    GoTo contElseIf
                                                End Select
                                            End If
                                            
                                            sss = Len(b$)
                                        Else
                                            If once Then
                                                W$ = GetStrUntil(vbCrLf, b$, False)
                                                Exit Function
                                            Else
                                        'if module2
                                        SetNextLine b$
                                        
                                        
                                    End If
                                 End If
                                End If
                                If bstack.RetStackTotal = 0 Then
                                        jump = ok
                                       If IFCTRL = 0 Then IFCTRL = 1
                                Else
                                    If Not bstack.RetStack.LookTopVal = -3 Then
                                        jump = ok
                                        If IFCTRL = 0 Then IFCTRL = 1
                                     Else
                                        IFCTRL = 0
                                    End If
                                End If
                    Else
                        
                    If lookB123(b$) Then
                        I = SetNextLineCLR(b$)
                        MarkIf bstack, 2, jump
                        bstack.UseofIf = bstack.UseofIf + 1
                        jump = False
                        IFCTRL = 0
                        lbl = True
                        sss = Len(b$)
                        GoTo loopcontinue
                    Else
                        IFCTRL = 1
                        jump = True
                        If MaybeIsSymbol(b$, "0123456789") Then GoTo ContGoto
                         
                        IFCTRL = 2 ' NONEED ANYTHING BUT NOT ERROR FOR IF.ELSE AND ELSE
                        If Not FastSymbol(b$, "{") Then
                            I = 1
                            aheadstatusELSE b$, I, Lang, W$
                            If Len(W$) > 2 Then
                            ' #3
                                ss$ = Left$(b$, I - 1 - Len(W$))
                                b$ = Mid$(b$, I - Len(W$))
                            If once Then
                            TraceStore bstack, nd&, b$, 0
                            once = False
                                    Call executeblock(Execute, bstack, ss$, once, ok, , True, False)
                                    TraceRestore bstack, nd
                                    If Execute = 0 Then
                                                   b$ = ss$ + b$
                                            ElseIf Execute = 5 Then
                                                once = True
                                                GoTo contLoop
                                            ElseIf Execute = 6 Then
                                                b$ = vbNullString
                                                Execute = 2
                                                once = True
                                                Exit Function
                                            ElseIf Execute = 3 Then
                                            b$ = ss$
                                            Exit Function
                                            ElseIf Execute = 2 And once Then
                                                    b$ = ss$
                                                    Exit Function
                                        ElseIf Execute = 1 Then
                                            If ok And Len(ss$) = 0 Then
                                            b$ = vbNullString
                                            Else
                                            SetNextLineNL b$
                                            End If
                                        Else
                                            If ok = True Then b$ = "BREAK" Else b$ = ss$
                                            once = False
                                           ' Execute = 2
                                        Exit Function
                                    End If
                                    Exit Do
                            Else
                                ' if then ...   else or else.if, no block
                                TraceStore bstack, nd&, b$, 0
                                    Call executeblock(Execute, bstack, ss$, False, ok, , True, False)
                                    TraceRestore bstack, nd&
                            End If
                            If Execute = 1 Then
                            
                                SetNextLine b$
                                lbl = True
                                    If bstack.RetStackTotal > 0 Then
                                        
                                    If bstack.RetStack.LookTopVal = -3 Then
                                        IFCTRL = 0
                                    End If
                                End If
                                If ok Then once = True: b$ = vbNullString: Exit Function
                            ElseIf Execute = 2 Then
                                If ok And Len(ss$) = 0 Then b$ = "BREAK" Else b$ = ss$
                                once = False
                                Exit Function
                            ElseIf Execute = 6 Or Execute = 3 Then
                                GoTo ContRestart
                            ElseIf Execute = 5 Then
                                loopthis = True
                                ok = False
                                SetNextLine b$
                                Execute = 2
                                If bstack.RetStackTotal > 0 Then
                                    If bstack.RetStack.LookTopVal = -3 Then
                                        IFCTRL = 0
                                    End If
                                End If
                            Else
                                If loopthis Then Execute = 2
                                GoTo ContContinue
                            End If
                        Else
                            If bstack.RetStack.LookTopVal = -3 Then
                                IFCTRL = 0
                            End If
                        End If
                    Else
                       ' bstack.addlen = Len(b$)
                        ss$ = block(b$)
                        If Not Left$(b$, 1) = "}" Then
                            Execute = CheckBlock(once): Exit Function
                        End If
                        ok = False
                        TraceStore bstack, nd&, b$, 0
                        Call executeblock(Execute, bstack, ss$, False, ok, , True)
                        TraceRestore bstack, nd&
                        b$ = Mid$(b$, 2)
                        If Execute = 1 Then
                            If FastSymbol(b$, ":") Then
                                sss = Len(b$)
                                IFCTRL = 0
                                GoTo again1
                            End If
                            If Not lookB123(b$) Then GoTo contif2
                            IFCTRL = 0
                        ElseIf Execute = 2 Then
                        If ok Then b$ = "BREAK": once = True Else b$ = ss$
                        Exit Function
                        End If
                        End If
                        End If
                    End If
                Case "ELSE", "аккиыс"
                
                    If lookB123(b$) Then
                    
                    
                    If Not ok Then
                        ' find END IF
                         MarkIf bstack, 1, ok
                         bstack.UseofIf = bstack.UseofIf + 1
                        GoTo findEndif
                    Else
                         MarkIf bstack, 0, ok
                         bstack.UseofIf = bstack.UseofIf + 1
                        jump = False
                        IFCTRL = 0
                        lbl = True
                    End If
                    I = SetNextLineCLR(b$)
                    ElseIf Not ok Then       ' JUMP FALSE SKIP ELSE
                    
                        If FastSymbol(b$, "{") Then
                            If once = True Then Execute = 0: Exit Function
                            W$ = block(b$)
                                If Not Left$(b$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                            b$ = Mid$(b$, 2)
                        Else
                            SetNextLine b$
                            lbl = True
                             sss = Len(b$)
                             GoTo again1
                        End If
                        IFCTRL = 0 ' NONEED ANYTHING AND ERROR FOR IF.ELSE AND ELSE
                    Else
                        If MaybeIsSymbol(b$, "0123456789") Then GoTo ContGoto
                        IFCTRL = 0
                        jump = False
                    End If
                    sss = Len(b$)
                Case Else
                    Execute = 0
                    Exit Function
                End Select
            Case Else
                Execute = 0
                Exit Function
            End Select
            If once Then
            
            sss = Len(b$)
            GoTo again1
            Else
            If jump Or IFCTRL = 2 Then
               ' lbl = True
                I = 1
                If FastOperator(b$, vbCrLf, I, 2) Then
                While FastOperator(b$, vbCrLf, I, 2)
                Wend
                If IsLabelSymbolNew(b$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                End If
                GoTo again1
            End If
            End If
                    lbl = False
                    DropCommentOrLine b$, True
                    If Len(b$) > 0 Then
                        If Left$(b$, 2) <> vbCrLf Then
                            GoTo againExtra2
                        End If
                    Else
                        Exit Do
                    End If
    Else
        ' error
        If LastErNum = -2 Then
            Execute bstack, b$, True
        Else
            MissNumExpr
        End If
        Execute = 0
        Exit Function
    End If
    sss = Len(b$)
Case "SELECT", "епекене", "епикене"  '*************************************** SELECT CASE
contSelect:
        'Us$ = vbNullString
        If once = True Then Execute = 0: Exit Function
        If exeSelect(Execute, once, bstack, b$, v, Lang) Then Exit Function
        If Execute = 2 And Len(b$) = 0 Then Exit Function
        once = False
        lbl = False
        If Len(b$) > 0 Then
        If Left$(b$, 2) = vbCrLf Then lbl = True
        End If
        sss = Len(b$)
Case "апо", "ON"                 '************************************* ON NUMBER GOTO LABELS
ContOn:
        If IsExp(bstack, b$, p, flatobject:=True, nostring:=True) Then
        y1 = IsLabelSymbolNew(b$, "пяос", "GOTO", Lang)
        y2 = False
        If Not y1 Then
        y1 = IsLabelSymbolNew(b$, "диалесоу", "GOSUB", Lang)
        If Not y1 Then
            MisGosub
        End If
        y2 = True
        End If
            If y1 Then
            On Error Resume Next
                p = CLng(p)
                If Err.Number = 6 Then
                    OverflowValue vbLong
                    Execute = 0
                    Exit Function
                End If
                                On Error GoTo 0
                If p <= 0 Then ' no exit
                SetNextLine b$
               ' If loopthis Then loopthis = False: Execute = 1
                If Execute <> 2 Then Execute = 1 Else Execute = 3
            b$ = vbNullString
           once = True
           Exit Function
                Else
                W$ = vbNullString
                I = 0
                Do
                I = 1
                 x1 = FastPureLabel(b$, W$)
                    If x1 = 0 Then
                    If Not IsNumberLabel(b$, W$) Then p = 1000: Exit Do
                    
                    ElseIf x1 > 1 Then
                        p = 1000
                        Exit Do
                    End If
                    I = 0
                    p = p - 1
                    If Not FastSymbol(b$, ",") Then Exit Do
                    
                Loop Until p = 0#
                If p <> 0 Then
                
                If I = 0 Then
                Execute = 1: W$ = GetNextLine$(b$): sss = Len(b$):
                End If
                W$ = vbNullString
                'Exit Do
                Else
                If I > 0 Then
                MissingLabel
                sss = LLL
                  Execute = 0
                Exit Function
                Else
                If y2 Then
                If bstack.SubLevel > deep And deep <> 0 Then
' GO BACK TO FIRST CALL
If bstack.RetStackTotal >= 9 * deep Then
             NoMoreDeep deep

             Execute = 0
             Exit Function

            
Else
bstack.RetStackDrop bstack.RetStackTotal
 End If
  InternalError
 NOEXECUTION = True
 Execute = 0
Exit Function
 
End If
               
               If p = 1000 Then Exit Function
                SetNextLine b$
               If x1 = 1 Then
               I = 1
               GoTo contHereFromOn
               Else
               GoTo contHere2FromOn
               End If
               
                
                End If
                b$ = W$
                Execute = 2
                Exit Function
                End If
                End If
                End If
            Else
              sss = LLL
            End If
        Else
            MissParam b$
            Execute = 0
            Exit Function
        End If
          
Case "SUB", "яоутима"
contSub:
           If once = True Then Execute = 0: Exit Function
   If Execute <> 2 Then
              b$ = W$
           once = True
           Execute = 3
         
           Else
           b$ = vbNullString
           
        End If
           Exit Function
Case "GOSUB", "диалесоу"
autogosub:
    'If checkbreakEsc(bstack) Then Execute = 1: Exit Function
    If bstack.SubLevel > deep And deep <> 0 Then
        ' GO BACK TO FIRST CALL
        If bstack.RetStackTotal >= 9 * deep Then
            NoMoreDeep deep
            Execute = 0
            Exit Function
        Else
            bstack.RetStackDrop bstack.RetStackTotal
        End If
        InternalError
        NOEXECUTION = True
        Execute = 0
        Exit Function
    End If
    If Len(bstack.tmpstr) = 0 Then
        I = FastPureLabel(b$, W$)
        If I = 6 Or I = 3 Then
againsub:
            If Len(b$) = 0 Then
                bstack.tmpstr = W$ + " "
                BackPort b$
            Else
                bstack.tmpstr = W$ + Left$(b$, 1)
                BackPort b$
            End If
            If Not IsStrExp(bstack, b$, W$, False) Then
                InternalError
                Execute = 0
                Exit Function
            End If
            I = FastPureLabel(W$, "", , , , , False)
            If I = 5 Then bb$ = W$: GoTo constrsub
        End If
    Else
        I = FastPureLabel(bstack.tmpstr, W$)
        bstack.tmpstr = vbNullString
        If I = 6 Or I = 3 Then GoTo againsub
    End If
contHereFromOn:
    If I = 5 Then
        once = False
        y1 = bstack.soros.Total
        If Not PushParamSUB(bstack, b$) Then
            y1 = bstack.soros.Total - y1
            If y1 > 0 Then bstack.soros.drop y1
            Execute = 0
            Exit Function
        End If
        If FastSymbol(b$, ")") Then
            PushStage bstack, False
            bstack.RetStack.PushLong Len(b$) '********************************
            If Lang Then
                bstack.RetStack.PushStr "SUB " + W$
            Else
                bstack.RetStack.PushStr "яоутима " + W$
            End If
            b$ = ChrW$(0)
            loopthis = Execute = 2
            Execute = 2
            bstack.IFCTRL = IFCTRL
            bstack.jump = jump
            Exit Function
        Else
            If Lang Then
                MissSymbol " ) for calling sub " + W$ + ")"
            Else
                MissSymbol " ) ЦИА ЙКчСГ ЯОУТъМАР " + W$ + ")"
            End If
            Execute = 0
            Exit Function
        End If
    ElseIf I = 1 Then
        once = False
        PushStage bstack, True
        bstack.RetStack.PushVal Len(b$)
        bstack.RetStack.PushStr "S " + W$
        b$ = Chr$(0)
        Execute = 2
        Exit Function
    ElseIf I = 0 Then
        If IsNumberLabel(b$, W$) Then
contHere2FromOn:
        once = False
        PushStage bstack, True  ' CORRECT FROM REV 45 - VER 8
        bstack.RetStack.PushVal Len(b$)
        bstack.RetStack.PushStr "* " + W$
        b$ = Chr$(0)
        bstack.IFCTRL = IFCTRL
        bstack.jump = jump
        Execute = 2
        Exit Function
    Else
        If Not IsStrExp(bstack, b$, bb$) Then
            InternalError
            Execute = 0
            Exit Function
        End If
constrsub:
        I = FastPureLabel(bb$, W$)
        If I = 5 Then
            once = False
            y1 = bstack.soros.Total
            If Not PushParamSUB(bstack, bb$) Then
                y1 = bstack.soros.Total - y1
                If y1 > 0 Then bstack.soros.drop y1
                    Execute = 0
                    Exit Function
                End If
                If FastSymbol(bb$, ")") Then
                    PushStage bstack, False
                    bstack.RetStack.PushVal Len(b$)
                    If Lang Then
                        bstack.RetStack.PushStr "SUB " + W$
                    Else
                        bstack.RetStack.PushStr "яоутима " + W$
                    End If
                    b$ = Chr$(0)
                    '' here is the fault...execute 2 means loop...
                    '' it is known only here...
                    loopthis = Execute = 2
                    Execute = 2
                    bstack.IFCTRL = IFCTRL
                    bstack.jump = jump
                    Exit Function
                Else
                    MissSymbol ")"
                    Execute = 0
                    Exit Function
                End If
            ElseIf I > 0 Then
                bb$ = vbNullString
                GoTo contHereFromOn
            End If
        End If
    Else
        bstack.tmpstr = W$ + Left$(b$, 1)
        BackPort b$
        Exit Do
    End If
Case "GOTO", "пяос"               '**************************************** This is the GOTO statement
ContGoto:
       ' If checkbreakEsc(bstack) Then Execute = 1: Exit Function
        If Trim$(b$) = vbNullString Or FastSymbol(b$, ":") Then
                Execute = 0
                MissingLabel
                Exit Function
        Else
        ' GET OUT FOR NEXT
    
        
        I = FastPureLabel(b$, W$, , , , , False)

                If I = 1 Then
                    once = False
                    b$ = W$
                    Execute = 2
                    Exit Function
                ElseIf I = 0 Then
                    If IsNumberLabel(b$, W$) Then
                        once = False
                        b$ = W$
                        Execute = 2
                        Exit Function
                        '  Else
                        'b$ = w$ & b$
                    End If
                Else
                    'b$ = w$ & b$
                
                Exit Do
                End If
              End If
Case "VAR", "VARIABLE", "VARIABLES", "летабкгтг", "летабкгтес"
contVar:
            
            Select Case chektype1(bstack, b$, Lang)
            Case 0
                 Execute = 0: Exit Function
            Case 1
                sss = LLL: lbl = False: jump = False
                GoTo loopcontinue
            Case 2

                noVarStat = True
                sss = LLL: lbl = False: jump = False
                GoTo jump101
            End Select
            
Case "LOCAL", "топийа", "топийг", "топийес"
contNegLocal:
 '               If noVarStat Then SyntaxError: Execute = 0: Exit Function
        
                If Not NewStat Then
                 If IsLabelSymbolNew(b$, "дипкос", "DOUBLE", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbDouble) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "айеяаиос", "INTEGER", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbInteger) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "лайяус", "LONG", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbLong) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "апкос", "SINGLE", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbSingle) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "коцийос", "BOOLEAN", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbBoolean) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "аяихлос", "DECIMAL", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbDecimal) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "коцистийос", "CURRENCY", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbCurrency) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "цяалла", "STRING", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbString) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "атупос", "VARIANT", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbVariant) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "олада", "GROUP", Lang) Then
                    If Not ProcGroup(-1, bstack, b$, Lang) Then
                    Execute = 0
                    Exit Function
                    End If
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "ьгжио", "BYTE", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbByte) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "ANTIKEIMENO", "OBJECT", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbObject) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "лецакосайеяаиос", "BIGINTEGER", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, True, vbObject, , New BigInteger) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "апая", "ENUM", Lang) Then

                If Not ProcEnum(bstack, b$, , True) Then Execute = 0: Exit Function
                GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "апаяихлгсг", "ENUMERATION", Lang) Then

                If Not ProcEnum(bstack, b$, , True) Then Execute = 0: Exit Function

                GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "долг", "STRUCTURE", Lang) Then

                If Not makestruct(bstack, b$, Lang, False, True) Then Execute = 0: Exit Function

                GoTo loopcontinue
                End If
                    NewStat = True
                    End If
                    sss = Len(b$)
                    LLL = sss
                iscom = True
                    Select Case IsLabelDotSub(temphere$, b$, W$, ss$, Lang, nchr)
                    Case 1234, 0
                    GoTo errstat
                    Case 1
                    If Left$(W$, 1) = "." Then
                     ss$ = W$
                    IsLabel bstack, ss$, W$
                    End If
                    GoTo VarOnly
                    Case 2
                    noref
                    Execute = 0
                    Exit Function
                    Case 3
                    GoTo contcase3
                    Case 4
                    GoTo contcase4
                    Case 5
                    GoTo contcase5
                    Case 6
                    GoTo contcase6
                    Case 7
                    GoTo contcase7
                    End Select
                  GoTo errstat
Case "GLOBAL", "цемийо", "цемийг", "цемийес"
contNegGlobal:
              '  If NewStat Then LocalAndGlobal: Execute = 0: Exit Function
            If Not VarStat Then
                If IsLabelSymbolNew(b$, "дипкос", "DOUBLE", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbDouble) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "айеяаиос", "INTEGER", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbInteger) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "лайяус", "LONG", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbLong) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "апкос", "SINGLE", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbSingle) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "коцийос", "BOOLEAN", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbBoolean) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "аяихлос", "DECIMAL", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbDecimal) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "коцистийос", "CURRENCY", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbCurrency) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "цяалла", "STRING", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbString) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "атупос", "VARIANT", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbVariant) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "ьгжио", "BYTE", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbByte) Then Execute = 0: Exit Function
                    GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "олада", "GROUP", Lang) Then
                    ' group can't be used as variable because exist read only variable
                    ' which pop group from stack
               If Not ProcGroup(1, bstack, b$, Lang) Then Execute = 0: Exit Function
               ElseIf IsLabelSymbolNew(b$, "ANTIKEIMENO", "OBJECT", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbObject) Then Execute = 0: Exit Function
                    GoTo loopcontinue
               '
               ElseIf IsLabelSymbolNew(b$, "лецакосайеяаиос", "BIGINTEGER", Lang) Then
                    If Not MyAnyType(bstack, b$, Lang, False, vbObject, , New BigInteger) Then Execute = 0: Exit Function
                    GoTo loopcontinue
               ElseIf IsLabelSymbolNew(b$, "цецомос", "EVENT", Lang) Then
                If lookOne(b$, "=") Then
                
                VarStat = True
                    If Lang = 0 Then
                    W$ = "цецомос"
                       Else
                    W$ = "EVENT"
                    End If
                    sss = Len(b$)
                    GoTo VarOnly
                End If
                If Not GlobalEVENT(bstack, b$, Lang) Then Execute = 0: Exit Function
                ElseIf IsLabelSymbolNew(b$, "йатастасг", "INVENTORY", Lang) Then
                If lookOne(b$, "=") Then
                
                VarStat = True
                    If Lang = 0 Then
                    W$ = "йатастасг"
                       Else
                    W$ = "INVENTORY"
                    End If
                    sss = Len(b$)
                    GoTo VarOnly
                End If
                If IsLabelSymbolNew(b$, "оуяа", "QUEUE", Lang) Then
                    If Not GlobalHandler(bstack, b$, Lang, 3) Then Execute = 0: Exit Function
                Else
                    If Not GlobalHandler(bstack, b$, Lang, 1) Then Execute = 0: Exit Function
                End If
                ElseIf IsLabelSymbolNew(b$, "диаяхяысг", "BUFFER", Lang) Then
                           If lookOne(b$, "=") Then
                
                VarStat = True
                    If Lang = 0 Then
                    W$ = "диаяхяысг"
                       Else
                    W$ = "BUFFER"
                    End If
                    sss = Len(b$)
                    GoTo VarOnly
                End If
                If Not GlobalHandler(bstack, b$, Lang, 2) Then Execute = 0: Exit Function
            
                ElseIf IsLabelSymbolNew(b$, "апая", "ENUM", Lang) Then

                If Not ProcEnum(bstack, b$, True) Then Execute = 0: Exit Function
                GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "апаяихлгсг", "ENUMERATION", Lang) Then

                If Not ProcEnum(bstack, b$, True) Then Execute = 0: Exit Function

                GoTo loopcontinue
                ElseIf IsLabelSymbolNew(b$, "долг", "STRUCTURE", Lang) Then

                If Not makestruct(bstack, b$, Lang, True, False) Then Execute = 0: Exit Function

                GoTo loopcontinue
                Else
                GoTo CONT12212
                
                
               End If
                VarStat = True
                sss = Len(b$)
               
                Else
CONT12212:
                VarStat = True
                sss = Len(b$)
                
                    LLL = sss
                iscom = True
                    Select Case IsLabelDotSub(temphere$, b$, W$, ss$, Lang, nchr)
                    Case 1234, 0
                    GoTo errstat
                    Case 1
                    If Left$(W$, 1) = "." Then
                     ss$ = W$
                    IsLabel bstack, ss$, W$
                    ElseIf comhash.Find2(W$, I, v) Then
                    If I = 0 And v = 36 Then
                    ConstNew bstack, b$, W$, True, Lang
                    
                    If LastErNum = -1 Then
                    Execute = 0
                    Exit Function
                    End If
                    sss = Len(b$)
                    GoTo loopcontinue
                    End If
                    
                    End If
                    GoTo VarOnly
                    Case 2
                    noref
                    Execute = 0
                    Exit Function
                    Case 3
                    GoTo contcase3
                    Case 4
                    GoTo contcase4
                    Case 5
                    GoTo contcase5
                    Case 6
                    GoTo contcase6
                    Case 7
                    GoTo contcase7
                    End Select
                  GoTo errstat
                  End If
Case "CONST", "стахеяг", "стахеяес"
makeconst:
        ConstNew bstack, b$, W$, here$ = vbNullString, Lang
         If LastErNum = -1 Then
                    Execute = 0
                    Exit Function
                    End If
       ' sss = Len(b$)
        'GoTo AGAIN1
Case Else
    If Not NoOptimum Then
        If Not iscom Then GoTo parsecommand
    Else
    iscom = False
    End If
VarOnly:
    
    
    On ExecuteVar(Execute, 1, bstack, W$, b$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$, noVarStat) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers, forerror
    
     
    If NoOptimum Then
    If GetSub(W$, v) Then
        iscom = True
    End If
    End If
parsecommand:
                    'If VarStat Or NewStat Then GoTo errstat
    
    If Not Identifier(bstack, W$, b$, iscom, Lang) Then
    
    If NERR Then NOEXECUTION = True
conthere111:
        If LastErNum1 = -1 And bstack.IamThread Then Execute = 1 Else Execute = 0
        Exit Function
        ' just happy here
exitdo:
        Exit Do
exitfunc:
        Set bstack.lastpointer = Nothing
        Exit Function
    Else
        If bstack.callx1 > 0 Then
            If Not ProcModuleEntry(bstack, "", 0, b$, Lang) Then
                          If MOUT And b$ = vbNullString Then
                Else
                    unknownid b$, W$
                End If
            End If
            bstack.RemoveOptionals
        End If
        iscom = False
conthere222:
        If bstack.connectnow Then
            bstack.connectnow = False
        End If
        lbl = False
        DropCommentOrLine b$, True
        sss = Len(b$)
        If Len(b$) > 0 Then
            If Left$(b$, 2) <> vbCrLf Then
                GoTo againExtra2
            End If
        Else
            Exit Do
        End If
        'If NocharsInLine(b$) Then Exit Do Else lbl = lookOne(b$, Chr(13))
    End If
End Select

    Else
   b$ = W$ + b$
    Execute = 0
         If FindNameForGroup(bstack, W$) Then
                UnknownProperty W$
        Else
                UnknownVariable W$
        End If

    Exit Function
forerror:
Execute = 0
Exit Function
    End If

Case 2
If Not lbl Then b$ = W$ + b$: Exit Do
b$ = Mid$(b$, 2)
lbl = False
sss = Len(b$)
Case 3
contcase3:
On ExecuteVar(Execute, 3, bstack, W$, b$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$, noVarStat) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 4
contcase4:
On ExecuteVar(Execute, 4, bstack, W$, b$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$, noVarStat) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 5
contcase5:
On ExecuteVar(Execute, 5, bstack, W$, b$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$, noVarStat) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 6
contcase6:
On ExecuteVar(Execute, 6, bstack, W$, b$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$, noVarStat) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 7
contcase7:
On ExecuteVar(Execute, 7, bstack, W$, b$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$, noVarStat) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 8:
If Len(bstack.tmpstr) > 0 And Len(b$) > 0 Then
    W$ = bstack.tmpstr
    Mid$(b$, 1, 1) = Right$(W$, 1)
    
    If Left$(W$, 1) = "@" Then
    W$ = Mid$(W$, 2, Len(W$) - 2)
    GoTo parsecommand
    End If
    W$ = Left$(W$, Len(W$) - 1)
    
        
        b$ = NLtrim$(b$)
        If Right$(W$, 1) = "." Then
         x1 = IsLabelDotSub(temphere$, b$, sw$, ss$, Lang, nchr)
         W$ = W$ + sw$
         
        ' sss = Len(b$)
        'LLL = sss
        one = True
        
        nchr = AscW(W$)
        Else
        'sss = Len(b$)
        'LLL = sss
        SwapStrings sw$, W$
        x1 = IsLabelDotSub(temphere$, sw$, W$, ss$, Lang, nchr)
        one = True
        If Len(Trim(sw$)) > 0 Then
        If nchr = 40 Then
        nchr = AscW(W$)
        b$ = sw$ + b$
        Else
        nchr = AscW(sw$)
        End If
        ElseIf Len(W$) > 0 Then
        nchr = AscW(W$)
        Else
        nchr = 0
        End If
        
        End If
        
        bstack.tmpstr = vbNullString
        
        GoTo again4
    
Else
    MyEr "Internal Error 2", "еСЫТЕЯИЙЭ КэХОР 2"
    Execute = 0
    Exit Function
End If
Case 10
contcase10:
If Left$(W$, 1) = "." Then
               If Not expanddot(bstack, W$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
               Execute = 0
               Exit Function
               End If
End If
iscom = True
lbl = False

                
            

On ExecuteVar(Execute, 8, bstack, W$, b$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$, noVarStat) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case Else
If lookOne(b$, ".") Then
b$ = NLtrim$(b$)
        nd& = Len(b$)
        If bstack.GetDot(b$, (1)) Then
           sss = (Len(b$) - nd&) + sss
           LLL = (Len(b$) - nd&) + LLL
        End If
        GoTo again2
Else
one = False
End If
If MaybeIsSymbol(b$, ",+*/_!@()[];<>|~`0123456789") Then
SyntaxError
Execute = 0
Exit Function
End If
End Select
loopcontinue:
If once Then
    If Not lookOne(b$, ":") Then
    Exit Do
    Else
    If onlyone Then Exit Do

    End If

End If
loopagain:
If one Then
    If linebyline Then
        If Not lookOne(b$, ":") Then Exit Do
    End If
End If
Loop
JUMPHERE:
If linebyline Then
    With bstack
    .IFCTRL = IFCTRL
    .jump = jump
    End With
    Exit Function
ElseIf onlyone Then
    Exit Function
End If
'linebyline = False

'If Len(b$) > 0 Then If AscW(b$) = 34 Then SyntaxError: Execute = 0
'If Len(b$) > 0 Then If sss = LLL Then SyntaxError: Execute = 0

If Len(b$) > 0 Then
Debug.Print sss, LLL, bstack.OriginalCode, bstack.originalname
If bstack.OriginalCode >= 0 Then

Debug.Print Left$(sbf(bstack.OriginalCode).sb, 200)
Else
' from lambda function
Debug.Print Left$(var(-bstack.OriginalCode).code$, 200)
End If
'If sss = LLL Then SyntaxError: Execute = 0
End If
Exit Function
errstat0:
If Err.Number = 13 Then
MyEr Err.Description, "КэХОР ТЩПОР ПАЯАЛщТЯОУ"
Else
MyEr Err.Description, Err.Description
End If
Err.Clear
Execute = 0: Exit Function
errstat1:
MissModuleName
Execute = 0: Exit Function
errstat:
MissVarName
Execute = 0: Exit Function
LONGERR:
If Err.Number = 6 Then
    Execute = 0
    OverflowValue
ElseIf Err.Number = 450 Then
    Execute = 0
    WrongOperator
End If
Exit Function
forfloatpointers:
Set ppppL = BoxGroupObj(bstack.lastpointer)
v = 0
Set bstack.lastpointer = Nothing
Execute = SpeedGroup(bstack, ppppL, "", W$, b$, v)
Set ppppL = Nothing  ' now group ref counting work fine
If Execute = 0 Then
    Exit Function
ElseIf Execute <> 1 And b$ <> "" Then
    once = False
    Exit Function
End If
sss = Len(b$)
GoTo loopagain
forpointers:
If Len(b$) > 1 Then
    If Not bstack.lastpointer Is Nothing Then
        '  Mid$(b$, 1, 1) = " "
        nchr = 0
        x1 = IsLabelDotSub(temphere$, b$, W$, ss$, Lang, nchr)
        With bstack.lastpointer
           If x1 = 0 Then
                Select Case nchr
                Case 40
                    If .link.HasStrValue Then
                        If here$ = .lasthere Then
                            W$ = .GroupName + "$("
                        Else
                            W$ = .lasthere + "." + .GroupName + "$("
                        End If
                        Mid$(b$, 1, 1) = " "
                        x1 = 6
                        sss = Len(b$)
                        GoTo contcase6
                    Else
                        If here$ = .lasthere Then
                            W$ = .GroupName + "("
                        Else
                            W$ = .lasthere + "." + .GroupName + "("
                        End If
                        Mid$(b$, 1, 1) = " "
                        x1 = 5
                        sss = Len(b$)
                        GoTo contcase5
                    End If
                Case 60
                    W$ = .lasthere + "." + .GroupName
                Case Else
                    If here$ = .lasthere Then
                        W$ = .GroupName
                    Else
                        W$ = .lasthere + "." + .GroupName
                    End If
                End Select
                x1 = 1
            
                GoTo VarOnly
            Else
            If .lasthere = vbNullString Then
                W$ = .GroupName + "." + W$
            Else
                W$ = .lasthere + "." + .GroupName + "." + W$
                End If
                If MaybeIsSymbol3(b$, "=", I) Then
                If I = 1 Then
                Mid$(b$, 1, 1) = "_"
                Else
                Mid$(b$, I - 1, 1) = "<"
                End If
                
                End If
            End If
            End With
            Set bstack.lastpointer = Nothing
        Else
            InternalError
            Execute = 0
            Exit Function
        End If

End If
GoTo again4


End Function

Function GoFunc(mystack As basetask, what$, rest$, vl As Variant, Optional Recursive As Long, Optional ByVal choosethis As Long = -1, Optional ByVal strg As Boolean = False, Optional ByVal usesamestack As Boolean = False) As Boolean
Dim f As Long, it As Long, pa$
Dim x1 As Long, par As Boolean, ohere$, W$, loopthis As Boolean
Dim Vars As Long, Vname As Long, subs As Long, snames As Long
Dim once As Boolean, RetStackSize As Long
Dim subsfc As FastCollection
Dim c As Constant, myl As lambda
Dim basestack As basetask
Dim ok As Boolean, nokillvars As Boolean
Dim I As Long, p As Long, S3 As Long, bb$, code$, ec$, small$, sbi As Long
Set basestack = mystack.Parent
If basestack Is Nothing Then Set basestack = mystack
ohere$ = here$
Dim backup$, TSHB As Boolean
If trace Then SwapStrings backup$, TestShowSub: TSHB = TestShowBypass
TestShowBypass = False
If CurrentStackSize > stacksize Then
    MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
    MOUT = True
    Set basestack = Nothing
    GoFunc = False: GoTo lastfun
End If
pa$ = mystack.UseGroupname
mystack.UseGroupname = basestack.UseGroupname
mystack.Look2Parent = True
mystack.strg = strg
mystack.fHere = here$
Vname = varhash.count
Vars = var2used
If usesamestack Then
    Set mystack.Sorosref = basestack.soros
Else
    If Not PushParamGeneralV70(mystack, rest$, basestack.restpart) Then
        mystack.Look2Parent = False
        GoTo lastfun
    End If
End If
mystack.Look2Parent = False
mystack.UseGroupname = pa$
If choosethis >= 0 Then
    x1 = choosethis
    If what$ = vbNullString Then
        If SecureNames Then
            If Left$(here$, 1) <> "_" Then If basestack.IamThread Then here$ = "_" + LTrim$(str$(basestack.Process.id)) + here$
            here$ = RVAL33(here$, x1)
        Else
            here$ = RVAL(here$, 1) + mystack.originalname
        End If
    ElseIf Recursive Then
        here$ = RVAL(here$, 1) + "." + Trim$(what$)
        If SecureNames Then If basestack.IamThread Then If Left$(here$, 1) <> "_" Then here$ = "_" + LTrim$(basestack.Process.id) + here$: basestack.StaticInUse = LTrim$(basestack.Process.id)
    Else
        If SecureNames Then If basestack.IamThread Then If basestack.StaticInUse = vbNullString Then basestack.StaticInUse = LTrim$(basestack.Process.id)
    End If
Else
    If InStr(what$, "(") > 0 Then
        If GetSub(what$, x1) Then
            If here$ = vbNullString Then
                If ohere$ = vbNullString Then here$ = what$
            Else
                here$ = RVAL(here$, 1) + "." + what$ ' Left$(Trim$(what$), 1) & x1
               
                If SecureNames Then If basestack.IamThread Then If Left$(here$, 1) <> "_" Then here$ = "_" + LTrim$(basestack.Process.id) + here$: basestack.StaticInUse = LTrim$(basestack.Process.id)
            End If
        ElseIf GetSub2(basestack, what$, x1) Then
            If here$ = vbNullString Then
                If ohere$ = vbNullString Then here$ = what$
            Else
                here$ = RVAL(here$, 1) + "." + Trim$(what$)
            End If
        End If
    Else
        If here$ = vbNullString Then
            If GetSub(what$, x1) Then
                here$ = RVAL(here$, 1)
            End If
        ElseIf GetlocalSub(what$, x1) Then
            here$ = RVAL(here$, 1)
        ElseIf GetSub(what$, x1) Then
            here$ = RVAL(here$, 1)
        ElseIf Recursive > 0 Then
            here$ = RVAL(here$, 1)
            x1 = Recursive
        End If
    End If
End If
 ' prepare function for static variables
If iRVAL(basestack.StaticInUse, 0) = 0 Then
    mystack.StaticInUse = RVAL(basestack.StaticInUse, 1) + "." + what$ + mystack.StaticInUse
  '  If Not basestack Is Basestack1 Then
        If Not basestack.StaticCollection Is Nothing Then
            StaticWork basestack, mystack, mystack.StaticInUse$
        End If
   ' End If
ElseIf basestack.OriginalCode = mystack.OriginalCode Then
    mystack.StaticInUse = basestack.StaticInUse
    Set mystack.StaticCollection = basestack.StaticCollection
Else
    mystack.StaticInUse = RVAL(basestack.StaticInUse, 1) + "." + what$ + mystack.StaticInUse
    If mystack.CallLocalLast Then
    mystack.StaticInUse = basestack.StaticInUse
    ElseIf Not basestack Is Basestack1 Then
        If Not basestack.StaticCollection Is Nothing Then
            StaticWork basestack, mystack, mystack.StaticInUse$
        End If
    End If
End If

If here$ <> ohere$ Or mystack.IamChild Or basestack.IamAnEvent Then
    subs = sb2used: snames = subHash.count
    If Not mystack.CallLocalLast Then
        With mystack
            .commnum = comhash.count
            .strfunnum = strfunid.count
            .numfunnum = funid.count
            .strnum = strid.count
            .numnum = numid.count
        End With
    End If
    I = 1: FK$(13) = vbNullString
    nokillvars = basestack.nokillvars: basestack.nokillvars = False
    If nokillvars Then
        mystack.ErrVars = basestack.ErrVars
        If sbf(x1).sbc Then
            numid.pushtopGlobal
            funid.pushtopGlobal
            strfunid.pushtopGlobal
            strid.pushtopGlobal
        End If
    Else
        mystack.ErrVars = var2used
    End If
    If Mid$(sbf(x1).sb, I) = vbNullString Then
        GoFunc = True
        If sbf(x1).Extern = 0 Then GoTo emptyfunc
    End If
    mystack.originalname$ = here$
    If usesamestack Then
        GoFunc = True
    ElseIf FastSymbol(rest$, ")") Then
        GoFunc = True
    ElseIf GoFunc Then
        MyEr "Missing )", "КЕъПЕИ )"
        GoFunc = False
        GoTo lastfun
    End If

    If FastSymbol(rest$, "<<", , 2) Then
        f = 1
        W$ = aheadstatus(rest$, True, f)
        W$ = Left$(rest$, f - 1)
        rest$ = Mid$(rest$, f)
        f = 1
        While FastSymbol(rest$, "<<", , 2)
            pa$ = aheadstatus(rest$, True, f)
            W$ = W$ + " << " + Left$(rest$, f - 1)
            rest$ = Mid$(rest$, f)
            f = 1
        Wend
        mystack.CallW = W$
        mystack.NoFuncError = True
        par = True
    End If
    
    Do
        If choosethis >= 0 Then
            mystack.UseGroupname = pa$
        Else
            mystack.UseGroupname = sbf(x1).sbgroup
            mystack.tpointer = sbf(x1).tpointer
        End If
        code$ = Mid$(sbf(x1).sb, I)
        If Len(code$) = 0 Then
            If sbf(x1).Extern > 0 Then
                If Not PrepareLambda(mystack, myl, sbf(x1).Extern, code$, c) Then
                    GoTo fastexit
                End If
            End If
        End If
        it = 1
        RetStackSize = mystack.RetStackTotal
againstream:
        ec$ = code$
        If Len(ec$) > 0 Then
            it = 1
            ok = False
            once = True
            I = 1
            Do
                bb$ = Mid$(ec$, I)
subsentry10:
                ok = False
                Select Case Execute(mystack, bb$, ok, False, loopthis)   ' this is a major point
                Case 0
thh:
                    code$ = bb$
                    it = 0
                    Set mystack.lastobj = Nothing
                    GoTo normalexit
                Case 1
                    If LastErNum <> 0 Then code$ = vbNullString
                    If once Then Exit Do
                    here$ = ohere$
                    Exit Do
                Case 2
                    If Not ok Then
                        I = 1
                        If Len(bb$) <> 0 Then
                            If bb$ = ChrW$(0) Then
                                If trace Then TestShowBypass = False
                                If RetStackSize = mystack.RetStackTotal And mystack.RetStack.LookTopVal < 0 Then
                                ' this is a return form other block
                                    it = 2
                                    SwapStrings code$, bb$
                                    GoTo fastexit
                                End If
                                If Not mystack.IsInRetStackString(small$) Then
                                    p = mystack.isPop3Long(S3, sbi)
                                    If p > 0 Then
                                        If S3 > 0 Then
                                            bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                        ElseIf S3 = 0 Then
                                            bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                        Else
                                            bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                        End If
                                        If trace Then
                                            TestShowBypass = True
                                            If TestShowBypass Then
                                                If S3 < 0 Then
                                                    TestShowSub = var(-S3).code
                                                ElseIf S3 = 0 Then
                                                    TestShowSub = ec$
                                                Else
                                                    TestShowSub = sbf(S3).sb
                                                End If
                                            End If
                                            mystack.addlen = sbi
                                        End If
                                        PopStage mystack
                                        GoTo subsentry10
                                    Else
fulty:
                                        MyEr "Fault in Return", "кэХОР СТГМ еПИСТЯОЖч"
                                        mystack.Flush
                                        Exit Do
                                    End If
                                Else
                                    If InStr(small$, " ") > 0 Then
                                        mystack.PushSecondThird S3, sbi
                                        If searchsub(mystack.OriginalCode, small$, I, S3, bb$) Then
                                            If Len(small$) <> 0 Then If Not MyRead(7, mystack, small$, 1) Then GoTo thh
                                            GoTo contSub
                                        ElseIf mystack.IamChild Then
                                            If searchsub(FindPrevOriginal(mystack), small$, I, S3, bb$) Then
                                                If Len(small$) <> 0 Then If Not MyRead(7, mystack, small$, 1) Then GoTo thh
contSub:
                                                If Len(bb$) = 0 Then
                                                    If S3 < 0 Then
                                                        bb$ = Mid$(var(-S3).code, I)
                                                    Else
                                                        bb$ = Mid$(sbf(S3).sb, I)
                                                    End If
                                                    sbi = 0
                                                Else
                                                    If S3 < 0 Then
                                                        sbi = Len(var(-S3).code) - I - Len(bb$)
                                                    Else
                                                        sbi = Len(sbf(S3).sb) - I - Len(bb$)
                                                    End If
                                                End If
                                                If trace Then
                                                    TestShowBypass = True
                                                    If TestShowBypass Then
                                                        If S3 < 0 Then
                                                            TestShowSub = var(-S3).code
                                                        Else
                                                            TestShowSub = sbf(S3).sb
                                                        End If
                                                    End If
                                                    mystack.addlen = Len(TestShowSub) - I + 1 - Len(bb$)
                                                End If
                                                GoTo subsentry10
                                            Else
therebad:
                                                badSubNotFound
                                                If mystack.IsDecimal Then
                                                    p = mystack.Pop3Long(S3, sbi)
                                                    If S3 > 0 Then
                                                        bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                                    ElseIf S3 = 0 Then
                                                        bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                                    Else
                                                        bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                                    End If
                                                End If
                                                mystack.RetStackDrop 3 '5
                                                GoTo thh  ' see procmoduleentry myerror1: for additional code
                                                ' or exit do ???
                                            End If
                                        Else
                                            GoTo therebad
                                        End If
                                    End If
                                End If
                            ElseIf bb$ = "BREAK" Then
                                GoTo breakexit
                            Else
                                If subsfc Is Nothing Then Set subsfc = New FastCollection
                                If subsfc.ExistKey(bb$) Then
                                    I = subsfc.Value
                                    If subsfc.sValue = 0 Then
                                        If I = 0 Or I > Len(ec$) Then
                                            SwapStrings rest$, bb$
                                            '  bstack.addlen = nd&
                                            GoTo thh
                                        Else
                                            bb$ = Mid$(ec$, I)
                                            sbi = 0 ' ???? CHECK THIS
                                        End If
                                    Else
                                        S3 = subsfc.sValue
                                        If S3 < 0 Then
                                            If I = 0 Or I > Len(var(-S3).code$) Then
                                                SwapStrings rest$, bb$
                                                '  bstack.addlen = nd&
                                                GoTo thh
                                            Else
AGAINGOTOLAMBDA:
                                                If mystack.SubLevel > 0 Then
                                                    If Len(var(-S3).code$) - I > sbi Then
                                                        bb$ = Mid$(var(-S3).code$, I, Len(var(-S3).code$) - I - sbi)
                                                    Else
                                                        bb$ = Mid$(var(-S3).code$, I)
                                                        sbi = 0
                                                    End If
                                                Else
                                                    bb$ = Mid$(var(-S3).code$, I)
                                                    sbi = 0
                                                End If
                                            End If
                                        Else
                                            If I = 0 Or I > Len(sbf(S3).sb) Then
                                                SwapStrings rest$, bb$
                                                '  bstack.addlen = nd&
                                                GoTo thh
                                            End If
AGAINGOTO:
                                            If mystack.SubLevel > 0 Then
                                                If Len(sbf(S3).sb) - I > sbi Then
                                                    bb$ = Mid$(sbf(S3).sb, I, Len(sbf(S3).sb) - I - sbi)
                                                Else
                                                    bb$ = Mid$(sbf(S3).sb, I)
                                                    sbi = 0
                                                End If
                                            Else
                                                bb$ = Mid$(sbf(S3).sb, I)
                                                sbi = 0
                                            End If
                                        End If
                                    End If
                                    GoTo subsentry10
                                Else
                                    If S3 = 0 Then
                                        I = PosLabel(bb$, ec$)
                                        If I = 0 Or I > Len(ec$) Then
                                            GoTo checkother
                                        Else
                                            subsfc.ItemCreator2 bb$, I, 0
                                            bb$ = Mid$(ec$, I)
                                            sbi = 0
                                            GoTo subsentry10
                                        End If
                                    End If
checkother:
                                If S3 < 0 Then
                                    I = PosLabel(bb$, var(-S3).code$)
                                    If I = 0 Or I > Len(var(-S3).code$) Then
                                        SwapStrings rest$, bb$
                                        '  bstack.addlen = nd&
                                        GoTo thh
                                    End If
                                    subsfc.ItemCreator2 bb$, I, S3
                                    GoTo AGAINGOTOLAMBDA
                                Else
                                    I = PosLabel(bb$, sbf(S3).sb)
                                    If I = 0 Or I > Len(sbf(S3).sb) Then
                                        SwapStrings rest$, bb$
                                         '  bstack.addlen = nd&
                                        GoTo thh
                                    End If
                                    subsfc.ItemCreator2 bb$, I, S3
                                    GoTo AGAINGOTO
                                    
                                End If
                                
                                GoTo subsentry10
                            End If
                            End If
                        Else
                            loopthis = False
                        End If
                    Else ' ok is true
                        code$ = ""
                        once = ok
                        it = 2: Set mystack.lastobj = Nothing
                        GoTo breakexit
                    End If
                Case Else
                    If once Then Exit Do
                    here$ = ohere$
                    Exit Do
                End Select
                here$ = ohere$
               ' If checkbreakEsc(mystack) Then it = 1: Exit Do
            Loop
        ElseIf mystack.UseofIf > 0 Then
            MissENDIF
            it = 0
        Else
            it = 1
        End If
breakexit:
normalexit:
fastexit:
        TestShowBypass = False
        If Not myl Is Nothing Then
            myl.CopyFromVar mystack, var()
            If c Is Nothing Then Set var(sbf(x1).Extern) = myl
        End If
        If Not basestack.CopyInOutCol Is Nothing Then CopyBack basestack
        Select Case it ''Execute(mystack, code$, False)
        Case 0
            Set mystack.lastobj = Nothing
            Set mystack.FuncObj = Nothing
            mystack.ThrowThreads  ' always throw threads
            If Not NERR Then   ' Nerr = true from command ERROR 0 means Fatal Error, shows a message and act as a crash!
                If Not myl Is Nothing Then
                    MyErMacro rest$, Chr(0) + "Problem in lambda", Chr(0) + "пЯЭБКГЛА СТГ КэЛДА"
                    FK$(13) = "EDIT " & GetName(sbf(myl.OriginalCode).goodname) & "," & (-myl.lastlen - Len(bb$) - 1)
                    'FK$(13) = "EDIT " & GetName(sbf(myl.OriginalCode).goodname) & "," & (-myl.lastlen - Len(rest$) + 1)
                    GoTo there1234
                End If
                If Len(mystack.UseGroupname) > 0 Then
                    If InStr(mystack.UseGroupname, ChrW(&H1FFF)) > 0 Then
                        pa$ = GetNextLine((sbf(Abs(mystack.OriginalCode)).sb))
                        If InStr(pa$, ",") = 0 Then
                            pa$ = "'11001EDIT " + GetModuleName(mystack, here$) + "," + Mid$(pa$, 11)
                        End If
                        FK$(13) = Mid$(pa$, 7) + "-" + LTrim$(str(Len(NLtrim$(code$))))
                        If Right$(GetName(sbf(x1).goodname), 2) = "()" Then
                            MyErMacro rest$, "Problem in class in function " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), "пЯЭБКГЛА СТГ ЙКэСГ СТГ СУМэЯТГСГ " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        Else
                            MyErMacro rest$, "Problem in class in module " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), "пЯЭБКГЛА СТГ ЙКэСГ СТО ТЛчЛА " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        End If
                        GoTo there1234
                    End If
                End If
                pa$ = GetModuleName(mystack, here$)
                If Right$(pa$, 1) = "(" Then pa$ = pa$ + ")"
                pa$ = "EDIT " & pa$ & ", " & (Len(sbf(x1).sb) + 1)
                If Left$(sbf(x1).sb, 10) = "'11001EDIT" Then
                    pa$ = Mid$(GetNextLine(sbf(x1).sb), 7) ''+ "+1"
                    sbf(x1).sb = Mid$(sbf(x1).sb, 3) ' needed because we measure length...look the preparation of Shift F1 below
                    Set sbf(x1).subs = Nothing
                    If what$ <> "" Then
                        If InStrRev(here$, ".") > 0 Then
                        ' any fucntion defined inside module or function has this direction
                        
                        MyEr "in function " + GetName(what$), "СТГ СУМэЯТГСГ " + GetName(what$) ' Mid$(what$, InStrRev(what$, ".") + 1)
                    Else
                        MyEr "in function " + what$, "СТГ СУМэЯТГСГ " + what$
                    End If
                Else
                    If Right$(GetName(sbf(x1).goodname), 2) = "()" Then
                        MyEr "in function ", "СТГ СУМэЯТГСГ "
                    Else
                        MyEr "in module ", "СТО ТЛчЛА "
                    End If
                End If
            Else
                If Right$(here$, 1) = ")" Then
                    If what$ <> "" Then
                        MyEr "in function " + GetName(what$), "СТГ СУМэЯТГСГ " + GetName(what$) 'Mid$(what$, InStrRev(what$, ".") + 1)
                    Else
                        MyEr "in function ", "СТГ СУМэЯТГСГ "
                    End If
                Else
                    MyEr "in module " + GetName(here$), "СТО ТЛчЛА " + GetName(here$)
                End If
            End If
            If (Len(sbf(x1).sb) - Len(code$)) < 0 Then ' Maybe in a galaxy far away
                FK$(13) = pa$
            Else  ' Or in Earth
                If Len(pa$) > 0 Then
                    ' prepare Shift F1 for a jump to the point of interest..the faulty one
                    If InStr(FK$(13), ",") > 0 Then
                        GoTo there1234
                        '' forget it
                        ''If Left$(pa$, InStr(pa$, ",")) = Left$(FK$(13), InStr(FK$(13), ",")) Then GoTo there1234
                    End If
                        If (Len(sbf(x1).sb) - Len(code$)) < 0 Then
                            FK$(13) = pa$
                        Else
                            DropLeft ",", FK$(13)
                            If FK$(13) <> "" Then FK$(13) = "+" + FK$(13)
                            FK$(13) = pa$ & "-" & LTrim$(str(Len(code$))) + FK$(13)
                        End If
                    End If
                End If
there1234:
                If LastErNum = 0 Then MyErMacro rest$, "", ""
            End If
            GoFunc = False
            If Not basestack.CopyInOutCol Is Nothing Then CopyBack basestack
            here$ = ohere$
            If Not mystack.CallLocalLast Then
                With mystack
                    If .commnum <> comhash.count Then comhash.ReduceHash .commnum, sbf()
                    If .numfunnum <> funid.count Then funid.ReduceHash .numfunnum
                    If .strfunnum <> strfunid.count Then strfunid.ReduceHash .strfunnum
                    If .numnum <> numid.count Then numid.ReduceHash .numnum
                    If .strnum <> strid.count Then strid.ReduceHash .strnum
                End With
                If nokillvars Then
                    If sbf(x1).sbc Then
                        numid.poptopGlobal
                        funid.poptopGlobal
                        strfunid.poptopGlobal
                        strid.poptopGlobal
                    End If
                End If
            End If
            If var2used > Vars Then var2used = Vars
            varhash.ReduceHash Vname, var()
            If UBound(var()) <> varhash.MaxSpace Then
                    ReDim Preserve var(varhash.MaxSpace) As Variant
            End If
            sb2used = subs
            subHash.ReduceHash snames, sbf()
            If UBound(sbf()) <> subHash.MaxSpace Then
                    ReDim Preserve sbf(subHash.MaxSpace) As modfun
            End If
            basestack.soros.MergeTop mystack.soros
            Exit Do
        Case 1, 3
            If Len(W$) > 0 Then
                pa$ = block(code$)
                If FastSymbol(code$, "}") Then GoTo againstream
            End If
emptyfunc:
            here$ = mystack.originalname$
            mystack.ThrowThreads
            Set mystack.lastobj = mystack.FuncObj
            Set mystack.FuncObj = Nothing
            If MyIsObject(mystack.lastobj) Then
                If mystack.lastobj Is Nothing Then
                    If myVarType(vl, &H4008) Then
                    If myVarType(mystack.FuncValue, vbString) Then
                        vl = mystack.FuncValue
                    Else
                        vl = fixthis(mystack.FuncValue)
                    End If
                    Else
                        vl = mystack.FuncValue
                    End If
                Else
                    Set basestack.lastobj = mystack.lastobj
                End If
            Else
                If myVarType(vl, &H4008) Then
                    If myVarType(mystack.FuncValue, vbString) Then
                        vl = mystack.FuncValue
                    Else
                        vl = fixthis(mystack.FuncValue)
                    End If
                Else
                    vl = mystack.FuncValue
                End If
            End If
            here$ = ohere$
            If Not mystack.CallLocalLast Then
                With mystack
                    If .commnum <> comhash.count Then comhash.ReduceHash .commnum, sbf()
                    If .numfunnum <> funid.count Then funid.ReduceHash .numfunnum
                    If .strfunnum <> strfunid.count Then strfunid.ReduceHash .strfunnum
                    If .numnum <> numid.count Then numid.ReduceHash .numnum
                    If .strnum <> strid.count Then strid.ReduceHash .strnum
                End With
            End If
            If Not nokillvars Then
                If var2used > Vars Then var2used = Vars
                varhash.ReduceHash Vname, var()
                If UBound(var()) <> varhash.MaxSpace Then
                        ReDim Preserve var(varhash.MaxSpace) As Variant
                End If
                sb2used = subs
                subHash.ReduceHash snames, sbf()
                If UBound(sbf()) <> subHash.MaxSpace Then
                        ReDim Preserve sbf(subHash.MaxSpace) As modfun
                End If
            Else
                If sbf(x1).sbc Then
                    numid.poptopGlobal
                    funid.poptopGlobal
                    strfunid.poptopGlobal
                    strid.poptopGlobal
                End If
            End If
            Exit Do
        Case 2
            mystack.ThrowThreads  ' for safety...
            I = 1
            If code$ <> "" Then
                If code$ = Chr$(0) Then
                    If basestack.IsInRetStackNumberLong(p) Then I = Len(sbf(x1).sb) - p + 1
                Else
                    If InStr(code$, vbCr) > 0 Then
                        I = rinstr(sbf(x1).sb, code$)
                        If I = 0 Then I = Len(sbf(x1).sb) + 1
                    Else
                        I = PosLabel(code$, sbf(x1).sb)
                    End If
                End If
            Else
                GoTo emptyfunc
            End If
        Case 12
            MyEr "Exit for out of for next loop", "╦НОДОР ЦИА щНЫ АПЭ цИА еПЭЛЕМО"
            GoFunc = False
            Exit Do
        End Select
    Loop
Else
    rest$ = what$ + " " + rest$
    GoFunc = False
End If
lastfun:
If trace Then SwapStrings backup$, TestShowSub: TestShowBypass = TSHB
End Function

Function RepPara(basestack As basetask, rest$) As Boolean
Dim x1 As Long, y1 As Long, I As Long, j As Long
Dim X As Double, Y As Long, YY, ss$, s$, what$
Dim pppp As mArray, aa() As String, p As Variant
RepPara = True
        If Not IsExp(basestack, rest$, YY) Then
        Err.Clear
        On Error Resume Next
            ' new mode
            If Left$(rest$, 1) = "&" Then Mid$(rest$, 1, 1) = " "
            x1 = Abs(IsLabel(basestack, rest$, what$))
            If x1 = 8 Then
               NotForArrayBrackets
               RepPara = False
               Exit Function
            ElseIf x1 = 3 Or x1 = 1 Then
                    If GetVar(basestack, what$, I) Then
                        If x1 = 1 Then If Not myVarType(var(I), vbString) Then MissingStrVar: RepPara = False: Exit Function
                        If FastSymbol(rest$, ",") Then
                            If IsStrExp(basestack, rest$, ss$, False) Then
                                  aa = Split(var(I), ss$)
                                    Do While FastSymbol(rest$, ",")
                                        RepPara = True
                                        If IsExp(basestack, rest$, p, flatobject:=True) Then
                                            p = Abs(p)
                                            If FastSymbol(rest$, ":=", , 2) Then
                                                If IsStrExp(basestack, rest$, s$, False) Then
                                                ' HERE PLACE PART TO ARRAY, MAKE IT BIGGER IF NEEDED
                                                    If UBound(aa) < p Then
                                                        ReDim Preserve aa(p)
                                                        aa(p) = s$
                                                        Else
                                                        aa(p) = s$
                                                        
                                                    End If
                                                
                                                Else
                                                     RepPara = False
                                                End If
                                            Else
                                                RepPara = False
                                            End If
                                        Else
                                            RepPara = False
                                            Exit Do
                                        End If
                                    Loop
                                If IsObject(var(I)) Then
                                var(I).EmptyDoc
                                var(I).textDoc = Join(aa, ss$)
                                Else
                                var(I) = Join(aa, ss$)
                                End If
                                Else
                                MissStringExpr
                            End If
                        Else
                        MissPar
                        End If
                    End If
            ElseIf x1 = 6 Or x1 = 5 Then
                    If neoGetArray(basestack, what$, pppp) Then
                        If Not NeoGetArrayItem(pppp, basestack, what$, I, rest$) Then RepPara = False: Exit Function
                        If Not pppp.IsStringItem(I) Then
                        If pppp.ItemType(I) <> doc Then
                            MissType
                            RepPara = False
                            Exit Function
                            End If
                        End If
                        If FastSymbol(rest$, ",") Then
                            If IsStrExp(basestack, rest$, ss$) Then
                                  aa = Split(pppp.item(I), ss$)
                                    Do While FastSymbol(rest$, ",")
                                        RepPara = True
                                        If IsExp(basestack, rest$, p, flatobject:=True) Then
                                            p = Abs(p)
                                            If FastSymbol(rest$, ":=", , 2) Then
                                                If IsStrExp(basestack, rest$, s$, False) Then
                                                ' HERE PLACE PART TO ARRAY, MAKE IT BIGGER IF NEEDED
                                                    If UBound(aa) < p Then
                                                        ReDim Preserve aa(p)
                                                        aa(p) = s$
                                                        Else
                                                        aa(p) = s$
                                                        
                                                    End If
                                                
                                                Else
                                                     RepPara = False
                                                End If
                                            Else
                                                RepPara = False
                                            End If
                                        Else
                                            RepPara = False
                                            Exit Do
                                        End If
                                    Loop
                                If IsObject(pppp.item(I)) Then
                                    pppp.item(I).EmptyDoc
                                    pppp.item(I).textDoc = Join(aa, ss$)
                                Else
                                    pppp.item(I) = Join(aa, ss$)
                                End If
                                Else
                                MissStringExpr
                            End If
                        Else
                        MissPar
                        End If
                        
                    End If
            Else
                MyEr "Need a string/document as variable/array item or a numeric expression, look help", "вЯЕИэФОЛАИ АКЖАЯИХЛГТИЙЭ ч щЦЦЯАЖО СЕ ЛЕТАБКГТч ч СЕ СТОИВЕъО ПъМАЙА ч ЛИА щЙЖЯАСГ АЯИХЛГТИЙч, ДЕР БОчХЕИА"
                RepPara = False
            End If
            Exit Function
            
        Else
            
                Err.Clear
        On Error Resume Next
            Y = CLng(YY)
            If Err Then
            Overflow
            RepPara = False
            Exit Function
            End If
         If FastSymbol(rest$, ",") Then
                    If IsExp(basestack, rest$, X) Then
                        X = Int(X)
                        If X < 1 Then
                        MyErMacro rest$, "the index base must be >=1", "Г БэСГ ДЕъЙТГ ПЯщПЕИ МА ЕъМАИ >=1"
                        Exit Function
                        End If
                     
                    End If
            Else
                X = 0
            End If
        
            If Left$(rest$, 1) = "&" Then Mid$(rest$, 1, 1) = " "
            x1 = Abs(IsLabel(basestack, rest$, what$))
            If x1 = 3 Then
                    If GetVar(basestack, what$, I) Then
                            If VarTypeName(var(I)) = doc Then
                                    If Not FastSymbol(rest$, "=") Then
                                        MissSymbol "="
                                        RepPara = False
                                        Exit Function
                                    Else
                                            If Not IsStrExp(basestack, rest$, what$) Then
                                                MissStringExpr
                                                RepPara = False
                                                Exit Function
                                            Else
                                            
                                            s$ = GetNextLineNoTrim(what$)
                                                 j = var(I).ParagraphFromOrder(Y)
                                                 If j = -1 Then
                                                        
                                                           MyErMacro rest$, "no such paragraph" & (Y), "ДЕМ УПэЯВЕИ ТщТОИА ПАЯэЦЯАЖОР" & (Y)
                                                         Exit Function
                                                Else
                                                If X > 1 Then
                                                If what$ = vbNullString Then
                                                
                                                ss$ = var(I).TextParagraph(j)
                                                
                                                s$ = Left(ss$ + space$(X - 1), X - 1) + s$ + Mid$(ss$, Len(s$) + X)
                                                Else
                                                
                                                s$ = Left(var(I).TextParagraph(j) + space$(X - 1), X - 1) + s$
                                                
                                                End If
                                            
                                                End If
                                                ''var(i).ReWritePara j, s$
                                                var(I).TextParagraph(j) = s$
                                                SetNextLine what$
                                                While what$ <> ""
                                                    s$ = GetNextLineNoTrim(what$)
                                                    Y = Y + 1
                                                    j = var(I).ParagraphFromOrder(Y)
                                                    If j = -1 Then
                                                        var(I).AppendParagraph s$
                                                    Else
                                                        If what$ = vbNullString Then s$ = s$ + Mid$(var(I).TextParagraph(j), Len(s$) + 1)
                                                        ''var(i).ReWritePara j, s$
                                                        var(I).TextParagraph(j) = s$
                                                    End If
                                                    SetNextLine what$
                                                Wend
                                                
                                                End If
                                            End If
                                    End If
                            Else
                                 MissingDoc   ' only doc not string var
                                 RepPara = False
                                Exit Function
                            End If
                    Else
                        Nosuchvariable what$
                        RepPara = False
                        Exit Function
                    End If
            ElseIf x1 = 6 Then
                    If neoGetArray(basestack, what$, pppp) Then
                        If Not NeoGetArrayItem(pppp, basestack, what$, I, rest$) Then RepPara = False: Exit Function
                        If pppp.ItemType(I) = doc Then
                                    If Not FastSymbol(rest$, "=") Then
                                            MissSymbol "="
                                            RepPara = False
                                            Exit Function
                                            Else
                                If IsStrExp(basestack, rest$, what$) Then
                                            s$ = GetNextLineNoTrim(what$)
                                                 j = pppp.item(I).ParagraphFromOrder(Y)
                                                 
                                                If j = -1 Then
                                            
                                               MyErMacro rest$, "no such paragraph" & (Y), "ДЕМ УПэЯВЕИ ТщТОИА ПАЯэЦЯАЖОР" & (Y)
                                             Exit Function
                                             Else
                                                If X > 1 Then
                                                    If what$ = vbNullString Then
                                                        ss$ = pppp.item(I).TextParagraph(j)
                                                        s$ = Left(ss$ + space$(X - 1), X - 1) + s$ + Mid$(ss$, Len(s$) + X)
                                                    Else
                                                        s$ = Left(pppp.item(I).TextParagraph(j) + space$(X - 1), X - 1) + s$
                                                    End If
                                                End If
                                                ''pppp.item(i).ReWritePara j, s$
                                                pppp.item(I).TextParagraph(j) = s$
                                                SetNextLine what$
                                                While what$ <> ""
                                                    s$ = GetNextLineNoTrim(what$)
                                                    
                                                    Y = Y + 1
                                                    j = pppp.item(I).ParagraphFromOrder(Y)
                                                    If j = -1 Then
                                                    
                                                    pppp.item(I).AppendParagraph s$
                                                    Else
                                                    
                                                    If what$ = vbNullString Then s$ = s$ + Mid$(pppp.item(I).TextParagraph(j), Len(s$) + 1)
                                                    
                                                   '' pppp.item(i).ReWritePara j, s$
                                                     pppp.item(I).TextParagraph(j) = s$
                                                    End If
                                                    SetNextLine what$
                                                Wend
                                                
                                              End If
                                Else
                                    MissStringExpr
                                    RepPara = False
                                    Exit Function
                                
                                End If

                            End If
                        Else
                             MissingDoc   ' only doc not string var
                             RepPara = False
                            Exit Function
                        End If
                    End If
            Else
                MissingDoc   ' only doc not string var
                RepPara = False
                Exit Function
            End If
        End If
End Function
Function IdentifierGroup(basestack As basetask, what$, rest$, Lang As Long, alocal As Boolean, addlen As Long) As Boolean
    IdentifierGroup = True
    Select Case what$
    Case "&"
       IdentifierGroup = MyFunction(2, basestack, rest$, Lang, addlen)
        Exit Function
    Case "FUNCTION", "сумаятгсг"
        IdentifierGroup = MyFunction(-1, basestack, rest$, Lang, True, alocal, addlen)
        Exit Function
    Case "MODULE", "тлгла"
        IdentifierGroup = MyModule(basestack, rest$, Lang, True, alocal, addlen, True)
        Exit Function
    Case "SUPERCLASS", "упеяйкасг"
        IdentifierGroup = ProcClass(basestack, rest$, Lang, True)
    Exit Function
    Case "GROUP", "олада"
      IdentifierGroup = ProcGroup(0, basestack, rest$, Lang)
      Exit Function
    Case "CLASS", "йкасг"
        IdentifierGroup = ProcClass(basestack, rest$, Lang, False)
    Exit Function
    Case "DIM", "пимайас", "пимайес"
        IdentifierGroup = MyDim(basestack, rest$, Lang, alocal)
        Exit Function
    Case "йатастасг", "INVENTORY"
        IdentifierGroup = ProcInventory(basestack, rest$, Lang, alocal)
        Exit Function
    Case "диаяхяысг", "BUFFER"
        IdentifierGroup = ProcBuffer(basestack, rest$, Lang)
        Exit Function
    Case "EVENT", "цецомос"
     IdentifierGroup = myEvent(basestack, rest$, Lang, alocal)
     Exit Function
    Case "DOCUMENT", "еццяажо"
        IdentifierGroup = MyDocument(basestack, rest$, Lang)
        Exit Function
    Case "STRING", "цяалла"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbString)
        Exit Function
    Case "VARIANT", "атупос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbVariant)
        Exit Function
    Case "INTEGER", "айеяаиос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbInteger)
        Exit Function
    Case "LONG", "лайяус"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbLong)
        Exit Function
    Case "DOUBLE", "дипкос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbDouble)
        Exit Function
    Case "SINGLE", "апкос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbSingle)
        Exit Function
    Case "BOOLEAN", "коцийос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbBoolean)
        Exit Function
    Case "DECIMAL", "аяихлос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbDecimal)
        Exit Function
    Case "BIGINTEGER", "лецакосайеяаиос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbObject, , New BigInteger)
        Exit Function
    Case "CURRENCY", "коцистийос"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbCurrency)
        Exit Function
    Case "BYTE", "ьгжио"
        IdentifierGroup = MyAnyType(basestack, rest$, Lang, alocal, vbByte)
        Exit Function
    Case "апаяихлгсг", "апая", "ENUMERATION", "ENUM"

    IdentifierGroup = ProcEnumGroup(basestack, rest$, LenB(here$) = 0)
    
    Exit Function
    End Select
End Function
Function Identifier(basestack As basetask, what$, rest$, Optional nocom As Boolean = False, Optional Lang As Long = 1) As Boolean
Dim x1 As Long, y1 As Long, it As Long, ohere$, s$, par As Boolean, p As Variant
'If Not TaskMaster Is Nothing Then
'If TaskMaster.PlayMusic Then
'    TaskMaster.OnlyMusic = True
'    TaskMaster.TimerTick
'    TaskMaster.OnlyMusic = False
'End If
'End If
If what$ = vbNullString Then
    Identifier = IsLabel(basestack, rest$, what$)
     
    If Not Identifier Then Exit Function
    what$ = myUcase(what$)
    Lang = codeW(what$)
Else
    Identifier = True
    x1 = Len(rest$)
    If Left$(what$, 1) <> "@" Then
        If nocom Then GoTo JUMPHEREFORMODULESFAST
    Else
        what$ = Mid$(what$, 2)
    End If
End If
Select Case what$
Case "&"
   Identifier = MyFunction(2, basestack, rest$, Lang)
    Exit Function
Case "амакутгс", "PROFILER"  ' no Neo...
Identifier = True
If basestack.Prof Is Nothing Then
If FastSymbol(rest$, "!") Then
Set basestack.Prof = New clsProfiler
basestack.Prof.MARKONE
Else
FastSymbol rest$, "!"
Prof.MARKONE
End If
Else
basestack.Prof.MARKONE
End If
Exit Function
Case "FUNCTION", "сумаятгсг"
    Identifier = MyFunction(0, basestack, rest$, Lang)
    Exit Function
Case "MODULE", "тлгла"
    Identifier = MyModule(basestack, rest$, Lang)
    Exit Function
Case "SUPERCLASS", "упеяйкасг"
    Identifier = ProcClass(basestack, rest$, Lang, True)
Exit Function
Case "EVENT", "цецомос"
 Identifier = myEvent(basestack, rest$, Lang)
 Exit Function
Case "GROUP", "олада"
  Identifier = ProcGroup(0, basestack, rest$, Lang)
  Exit Function
Case "CLASS", "йкасг"
    Identifier = ProcClass(basestack, rest$, Lang, False)
Exit Function
Case "DIM", "пимайас", "пимайес"
    Identifier = MyDim(basestack, rest$, Lang)
    Exit Function
Case "йатастасг", "INVENTORY"
    Identifier = ProcInventory(basestack, rest$, Lang)
    Exit Function
Case "диаяхяысг", "BUFFER"
    Identifier = ProcBuffer(basestack, rest$, Lang)
    Exit Function
Case "WAIT", "амаломг"  '' copy to NeoWait
Identifier = MyDelay(basestack, rest$)
Exit Function
Case "REPORT", "амажояа"
Identifier = MyReport(basestack, rest$, Lang)
Exit Function
Case "LET", "стг", "стгм", "сто"  'ok
Identifier = MyLet(basestack, rest$, Lang)
Exit Function
Case "COMMIT", "амехесе"
Identifier = MyRead(3, basestack, rest$, Lang)
Exit Function
Case "ICON", "еийомидио"
Identifier = MyIcon(basestack, rest$)
Exit Function
Case "TITLE", "титкос"
Identifier = ProcTitle(basestack, rest$, Lang)
Exit Function
Case "ESCAPE", "диажуцг"
Identifier = MyEscape(rest$, Lang)
Case "HIDE", "сбгсе"
newHide basestack
Exit Function
Case "SHOW", "амаье"
newshow basestack
Exit Function
Case "WRITE", "цяаье"
Identifier = MyWrite(basestack, rest$, Lang)
Exit Function
Case "TEXT", "йеилемо", "HTML"  'ok
Identifier = ProcText(basestack, what$ = "HTML", rest$)
Exit Function
Case "STRUCTURE", "долг"  ' ok
Identifier = myStructure(basestack, rest$, Lang)
Exit Function
Case "басг", "BASE"   'ok
' меа басг
Identifier = NewBase(basestack, rest$, Lang)
Exit Function
Case "аявеио", "TABLE"   'ok
Identifier = NewTable(basestack, rest$, Lang)
' меос пимайас стгм басг
Exit Function
Case "ейтекесг", "EXECUTE"   'ok
 If IsLabelSymbolNew(rest$, "йыдийа", "CODE", Lang) Then
Identifier = ExecCode(basestack, rest$)
 Else
    CommExecAndTimeOut basestack, rest$
    Identifier = True
End If
' меа киста
Case "вяылатисе", "PSET"
    Identifier = MyPset(basestack, rest$)
Case "амайтгсг", "RETRIEVE"  'ok
getrow basestack, rest$, , , Lang
Exit Function
Case "амафгтгсг", "SEARCH"  'ok
getrow basestack, rest$, , "", Lang
Exit Function
Case "пяосхгйг", "APPEND"  'ok
' басг,пимайас,стоивеиа
par = Appfields(basestack, rest$)
Exit Function
Case "ажаияесг", "DELETE"  'ok
' басг, пимайас,поио , ти
par = DELfields(basestack, rest$)
Exit Function
Case "танг", "ORDER"  'ok
Identifier = MyOrder(basestack, rest$, Lang)
Exit Function
Case "епистяожг", "RETURN"  ' no need here
' басг,"SELECT пимайас",стоивеиа
If IsStrExp(basestack, rest$, s$) Then
append_table basestack, s$, rest$, True, Lang
End If
Exit Function
Case "сулпиесг", "COMPRESS"  'ok
BaseCompact basestack, rest$
Exit Function
Case "LAYER", "епипедо" ' ok
Identifier = ProcLayer(basestack, rest$)
Exit Function
Case "PRINTER", "ейтупытгс"  ' ok
Identifier = ProcPrinter(basestack, rest$)
Exit Function
Case "MOTION", "йимгсг"
Identifier = ProcMotion(basestack, rest$, Lang)
Exit Function
Case "ASSERT", "аниысг"
ProcAssert basestack, rest$
Exit Function
Case "PAGE", "секида" 'ok
ProcPage basestack, rest$, Lang
Exit Function
Case "PRINTING", "ейтупысг"
 Identifier = ProcPrinting(basestack, rest$, Lang)
 Exit Function
Case "FORMLABEL", "етийета.жоялас"
Identifier = ProcLabel(basestack, rest$)
Exit Function
Case "LEGEND", "епицяажг"
' NEW JUSTIFY...1 RIGHT,2 CENTER ,3 LEFT
Identifier = ProcLegend(basestack, rest$)
Exit Function
Case "MEDIA", "MOVIE", "таимиа", "MUSIC", "лоусийг"  ' ЛЭМО щМА ЙАИ ЛПОЯЕъ МА ПЕЯИЛщМЕИ ч МА ТО ДИЧНЕИ ЦИА эККО
Identifier = ProcMedia(basestack, rest$, Lang)
Exit Function
Case "PUT", "дысе"
Identifier = MyPut(basestack, rest$)
Exit Function
Case "жояла", "FORM"
Kform = True
Identifier = MakeForm(basestack, rest$)
Exit Function
Case "SUBDIR", "упойатакоцос"
    Identifier = ProcSubDir(basestack, rest$, Lang)
Exit Function
Case "DIR", "йатакоцос"
    Identifier = ProcDir(basestack, rest$, Lang)
Exit Function
Case "START", "аявг"
    Identifier = newStart(basestack, rest$)
    Exit Function
Case "REMOVE", "диацяажг"
    Identifier = ProcRemove(basestack, rest$, Lang)
Exit Function
Case "DEF", "йаме"
    Identifier = ProcDef(basestack, rest$, Lang)
    Exit Function
Case "LOAD", "жоятысе" '
Identifier = ProcLoad(basestack, rest$, Lang)
Exit Function
Case "SAVE", "сысе"
Identifier = ProcSave(basestack, rest$, Lang)
Exit Function
Case "OVERWRITE", "йатавыягсг"
Identifier = RepPara(basestack, rest$)
Exit Function
Case "INSERT", "паяелбокг"
Identifier = IdPara(basestack, rest$, Lang)
Exit Function
Case "DOCUMENT", "еццяажо"
Identifier = MyDocument(basestack, rest$, Lang)
Exit Function
Case "STOCK", "стой"
Identifier = StockValues(basestack, rest$, Lang)
Exit Function
Case "LINK", "емысе"
Identifier = MyLink(basestack, rest$, Lang)
Exit Function
Case "REFER", "апедысе"
Identifier = MyRead(2, basestack, rest$, Lang)
Exit Function
Case "READ", "диабасе"
Identifier = MyRead(1, basestack, rest$, Lang)
Exit Function
Case "DOUBLE"
Dim K As Long
K = MyTrimL(rest$): If K > 1 Then rest$ = Mid$(rest$, K)
If CheckFreeExecute(rest$) Then
    SetDouble basestack.Owner
    Identifier = True
Else
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbDouble, True)
End If
Case "дипка"
SetDouble basestack.Owner
Case "дипкос"
        Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbDouble, True)
        Exit Function
Case "INTEGER", "айеяаиос"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbInteger, True)
    Exit Function
Case "LONG", "лайяус"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbLong, True)
    Exit Function
Case "SINGLE", "апкос"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbSingle, True)
    Exit Function
Case "BOOLEAN", "коцийос"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbBoolean, True)
    Exit Function
Case "DECIMAL", "аяихлос"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbDecimal, True)
    Exit Function
Case "BIGINTEGER", "лецакосайеяаиос"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbObject, True, New BigInteger)
    Exit Function
Case "CURRENCY", "коцистийос"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbCurrency, True)
    Exit Function
Case "STRING", "цяалла"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbString, True)
    Exit Function
Case "BYTE", "ьгжио"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbByte, True)
    Exit Function
Case "VARIANT", "атупос"
    Identifier = MyAnyType(basestack, rest$, Lang, Len(here$) > 0, vbVariant, True)
    Exit Function
Case "NORMAL", "йамомийа"
SetNormal basestack.Owner
Exit Function
Case "ERROR", "кахос"
Identifier = MyError(basestack, rest$, Lang)
Exit Function
Case "SET", "хесе"
    it = 1
    aheadstatusANY rest$, it
    s$ = Left$(rest$, it - 1)
    If interpret(basestack, s$) Then
        rest$ = Mid$(rest$, it)
    Else
        rest$ = s$ + Mid$(rest$, it)
    End If
    
    Exit Function
Case "NEW", "мео"
    Identifier = MyNew(basestack, rest$, Lang)
    Exit Function
Case "EDIT", "суццяажг", "с"
    Identifier = ProcEdit(basestack, rest$, Lang)
    Exit Function
Case "SCAN", "саяысе"
    Identifier = MyScan(basestack, rest$)
    Exit Function
Case "пема", "PEN"
    Identifier = ProcPen(basestack, rest$)
    Exit Function
Case "охомг", "CLS"
    Identifier = ProcCls(basestack, rest$)
    Exit Function
Case "HEX", "дейаен"
    Identifier = RevisionPrint(basestack, rest$, 1, Lang)
    Exit Function
Case "PRINT", "тупысе", "?"
    Identifier = RevisionPrint(basestack, rest$, 0, Lang)
    Exit Function
Case "BACK", "BACKGROUND", "пеяихыяио"
    ProcBackGround basestack, rest$, Lang, Identifier
    Exit Function
Case "PUSH", "баке"
    par = MyPush(basestack, rest$)
    Exit Function
Case "DATA", "сеияа"
    par = MyData(basestack, rest$)
    Exit Function
Case "SWAP", "аккане"
    Identifier = MySwap(basestack, rest$, Lang)
    Exit Function
Case "CLOSE", "йкеисе"
    Identifier = MyClose(basestack, rest$, Lang)
    Exit Function
Case "SEEK", "летахесг"
    Identifier = MySeek(basestack, rest$)
    Exit Function
Case "APPEND.DOC", "пяосхесе.еццяажо"
    Identifier = ProcSaveDoc(1, basestack, rest$)
    Exit Function
Case "SAVE.DOC", "сысе.еццяажо"
    Identifier = ProcSaveDoc(0, basestack, rest$)
    Exit Function
Case "MERGE.DOC", "суцвымеусе.еццяажо"
    Identifier = ProcLoadDoc(1, basestack, rest$)
    Exit Function
Case "LOAD.DOC", "жоятысе.еццяажо"
    Identifier = ProcLoadDoc(0, basestack, rest$)
    Exit Function
Case "FIND", "еуяесг"
    Identifier = ProcFind(basestack, rest$)
    Exit Function
Case "WORDS", "кенеис"
    Identifier = ProcWords(basestack, rest$)
    Exit Function
Case "SORT", "танимолгсг"
    Identifier = ProcSort(basestack, rest$, Lang)
    Exit Function
Case "OVER", "памы"  'амтицяажеи тгм йояужг
    Identifier = ProcOver(basestack, rest$)
    Exit Function
Case "SHIFTBACK", "жеяеписы"  'летайимеи апо тгм йояужг
    Identifier = ProcShiftBack(basestack, rest$)
    Exit Function
Case "SHIFT", "жеяе"  'летайимеи стгм йояужг
    Identifier = ProcShift(basestack, rest$)
    Exit Function
Case "DROP", "пета"
    Identifier = ProcDrop(basestack, rest$, Lang)
    Exit Function
Case "SCREEN.PIXELS", "амакусг.охомгс"
    Identifier = ProcScreenRes(basestack, rest$)
    Exit Function
Case "SOUNDREC", "гвоцяажгсг"
    Identifier = ProcSoundRec(basestack, rest$, Lang)
    Exit Function
Case "KEYBOARD", "пкгйтяокоцио"
    Identifier = ProcKeyboard(basestack, rest$, Lang)
    Exit Function
Case "JOYPAD", "кабг"
    Identifier = ProcJoypad(basestack, rest$)
    Exit Function
Case "PIPE", "аукос"
    Identifier = ProcPipe(basestack, rest$)
    Exit Function
Case "GET", "паяе"
    Identifier = ProcGet(basestack, rest$)
    Exit Function
Case "мгла", "THREAD"
    Identifier = MyThread(basestack, rest$, Lang)
    Exit Function
Case "HOLD", "йяатгсе"
    Identifier = ProcHold(basestack)
    Exit Function
Case "RELEASE", "ажгсе"
    Identifier = ProcRelease(basestack)
    Exit Function
Case "USE", "вягсг"
    Identifier = ProcUSE(basestack, rest$, Lang)
    Exit Function
Case "OPEN.FILE", "амоицла.аявеиоу"
    Identifier = ProcOpenFile(basestack, rest$, Lang)
    Exit Function
Case "OPEN.IMAGE", "амоицла.еийомас"
    Identifier = ProcOpenImage(basestack, rest$, Lang)
    Exit Function
Case "FLUSH", "адеиасе"
    Identifier = ProcFlush(basestack, rest$, Lang)
    Exit Function
Case "PROPERTIES", "идиотгтес"  ''for printer
    Identifier = ProcPropeties(basestack, rest$)
    Exit Function
Case "SPEECH", "коцос"
    Identifier = ProcSpeech(basestack, rest$)
    Exit Function
Case "DOS", "йомсока"
    Identifier = ProcDos(basestack, rest$)
    Exit Function
Case "WIN", "сус", "сустгла"
    Identifier = ProcWin(basestack, rest$)
    Exit Function
Case "WINDOW", "паяахуяо"
    Kform = True
    ProcWindow basestack, rest$, basestack.Owner, Identifier
    Exit Function
Case "FIELD", "педио"
    Identifier = ProcField(basestack, rest$, Lang)
    Exit Function
Case "TEST", "дойилг"
    Identifier = procTestMe(basestack, rest$, what$)
    Exit Function
Case "MOUSE.ICON", "деийтг.лояжг"
    i3MouseIcon basestack, rest$, Lang
    Exit Function
Case "MOTION.W", "йимгсг.п"
    Identifier = procMotionW(basestack, rest$)
    Exit Function
Case "CLIPBOARD", "пяовеияо"
    Identifier = MyClipboard(basestack, rest$, Lang)
    Exit Function
Case "богхеиа", "HELP"
    Identifier = MyHelp(basestack, rest$, Lang)
    Exit Function
Case "CLEAR", "йахаяо"
    Identifier = MyClear(basestack, rest$)
    Exit Function
Case "DECLARE", "ояисе"  'OBJECT
    Identifier = MyDeclare(basestack, rest$, Lang)
    Exit Function
Case "REM", "сгл"
    NeoRem 0, rest$, 0, Identifier
    Exit Function
Case "VOLUME", "емтасг"
    Identifier = MyVol(basestack, rest$)
    Exit Function
Case "ABOUT", "пеяи"
    ProcAbout basestack, rest$, Lang
    Exit Function
Case "SMOOTH", "олака"
        If IsLabelSymbolNew(rest$, "ови", "OFF", Lang) Then
        GDILines = False
        ElseIf IsLabelSymbolNew(rest$, "маи", "ON", Lang) Then
        GDILines = True
        End If
    Exit Function
Case "OPTIMIZATION", "бектистопоигсг"  '' not a
        If IsLabelSymbolNew(rest$, "ови", "OFF", Lang) Then
        NoOptimum = True
        ElseIf IsLabelSymbolNew(rest$, "маи", "ON", Lang) Then
        NoOptimum = False
        End If
    Exit Function
Case "LINESPACE", "диастиво"  'ok
    Identifier = procLineSpace(basestack, rest$)
    Exit Function
Case "BOLD", "жаядиа"      'ok
    ProcBold basestack, rest$
    Exit Function
Case "MODE", "тупос"
    Identifier = ProcMode(basestack, rest$)
    Exit Function
Case "GRADIENT", "жомто"
    Identifier = ProcGradient(basestack, rest$)
    Exit Function
Case "CHOOSE.OBJECT", "епекене.амтийеилемо", "епикене.амтийеилемо"
    ProcChooseObj basestack, rest$, Lang
    Exit Function
Case "CHOOSE.FONT", "епекене.цяаллатосеияа", "епикене.цяаллатосеияа"
    ProcChooseFont basestack, Lang
    Exit Function
Case "INPUT", "еисацыцг"   ' ok
    Identifier = MyInput(basestack, rest$, Lang)
    Exit Function
Case "мглата", "THREADS"
    procthreads basestack.Owner, basestack, rest$, Lang
    Exit Function
Case "ояио.амадяолгс", "RECURSION.LIMIT"
    Identifier = ProcRecursionLimit(basestack, rest$, Lang)
    Exit Function
Case "LOCALE", "топийо"
    Identifier = ProcSalata(3, basestack, rest$)
    Exit Function
Case "CODEPAGE", "йыдийосекида"
    Identifier = ProcSalata(2, basestack, rest$)
    Exit Function
Case "CHARSET", "ваяайтгяес"
    Identifier = ProcSalata(1, basestack, rest$)
    Exit Function
Case "STEP", "бгла"
    Identifier = ProcStep(basestack, rest$, Lang)
    Exit Function
Case "MOVE", "хесг"
    Identifier = ProcMove(basestack, rest$)
    Exit Function
Case "покуцымо", "POLYGON"
    Identifier = ProcPoly(basestack, rest$, Lang)
    Exit Function
Case "CIRCLE", "йуйкос"
    Identifier = ProcCircle(basestack, rest$, Lang)
    Exit Function
Case "PLAYER", "паийтгс"
    Identifier = ProcPlayer(basestack, rest$, Lang)
    Exit Function
Case "IMAGE", "еийома"
    Identifier = ProcImage(basestack, rest$, Lang)
    Exit Function
Case "SPRITE", "диажамо", "диажамеиа"
    ' ok NeoSprite exist
    If IsStrExp(basestack, rest$, s$) Then
        sprite basestack, s$, rest$
    ElseIf IsExp(basestack, rest$, p) Then
        spriteGDI basestack, rest$
    End If
    If LastErNum1 <> 0 Then Identifier = False
    Exit Function
Case "COPY", "амтецяаье", "амтицяаье"
    Identifier = MyCopy(basestack, rest$, Lang)
    Exit Function
Case "паине", "PLAY"
    Identifier = MyPlayScore(basestack, rest$)
    Exit Function
Case "SCORE", "жымг"
    Identifier = MyScore(basestack, rest$)
    Exit Function
Case "TARGETS", "стовои"
    Identifier = ProcTargets(basestack, rest$, Lang)
    Exit Function
Case "LATIN", "катимийа"
    LATIN basestack '****************************************************************
    Exit Function
Case "GREEK", "еккгмийа"
    GREEK basestack
    Exit Function
Case "MODULES", "тлглата"
    Identifier = MyModules(basestack, rest$, Lang)
    Exit Function
Case "FILES", "аявеиа"
    Identifier = ProcFiles(basestack, rest$, Lang)
    Exit Function
Case "CAT", "йатакоцои", "йат"
    Identifier = ProcCat(basestack, rest$, Lang)
    Exit Function
Case "DRAWINGS", "сведиа"
    Identifier = MyDrawings(basestack, rest$, Lang)
    Exit Function
Case "BITMAPS", "еийомес"
    Identifier = MyBitmaps(basestack, rest$, Lang)
    Exit Function
Case "MOVIES", "таимиес"
    Identifier = MyMovies(basestack, rest$, Lang)
    Exit Function
Case "SOUNDS", "гвои"
    Identifier = MySounds(basestack, rest$, Lang)
    Exit Function
Case "WRITER", "суццяажеас"
    Identifier = ProcWriter(basestack, rest$, Lang)
    Exit Function
Case "LIST", "киста"
    Identifier = ProcList(basestack, rest$, Lang)
    Exit Function
Case "FRAME", "пкаисио" ' BOX X1,Y1,COL,BOX
    Identifier = MyFrame(basestack, rest$)
    Exit Function
Case "MARK", "сглади"
    Identifier = MyMark(basestack, rest$)
    Exit Function
Case "LINE", "цяаллг"
    Identifier = MyLineInput(basestack, rest$, Lang)
    Exit Function
Case "CURSOR", "дяолеас" ' CURSOR X,Y
    Identifier = MyCursor(basestack, rest$)
    Exit Function
Case "FILL", "баье"
    Identifier = ProcFill(basestack, rest$)
    Exit Function
Case "FLOODFILL", "целисе"
    Identifier = ProcFLOODFILL(basestack, rest$, Lang)
    Exit Function
Case "ваяане", "DRAW"   ' LINE X1,Y1,COL
    Identifier = ProcDraw(basestack, rest$, Lang)
    Exit Function
Case "WIDTH", "павос"
    Identifier = ProcDrawWidth(basestack, rest$)
    Exit Function
Case "йалпукг", "CURVE"
    Identifier = ProcCurve(basestack, rest$, Lang)
    Exit Function
Case "PATH", "COLOR", "вяыла", "ивмос"
    Identifier = ProcPath(basestack, rest$, Lang)
    Exit Function
Case "DESKTOP", "епижамеиа"
    Identifier = ProcDesktop(basestack, rest$, Lang)
    Exit Function
Case "CHOOSE.COLOR", "епекене.вяыла", "епикене.вяыла"
    Identifier = ProcChooseColor(basestack, rest$, Lang)
    Exit Function
Case "SAVE.AS", "апохгйеусг.ыс"
    Identifier = ProcSaveAs(basestack, rest$, Lang)
    Exit Function
Case "аккацг", "CHANGE"
    Identifier = ProcCHANGE(basestack, rest$, Lang)
    Exit Function
Case "STACK", "сыяос"
    Identifier = ProcStack(basestack, rest$, Lang)
    Exit Function
Case "ейдосг", "VERSION"
    Identifier = ProcVersion(basestack)
    Exit Function
Case "цяаллатосеияа"
    Identifier = ProcFont(basestack, rest$, 0&)
    Exit Function
Case "FONT"
    Identifier = ProcFont(basestack, rest$, 1&)
    Exit Function
Case "SCROLL", "йукисг"
    Identifier = ProcSrcoll(basestack, rest$, Lang)
    Exit Function
Case "EDIT.DOC", "диояхысе"
    Identifier = ProcEditDoc(basestack, rest$, Lang)
    Exit Function
Case "ITALIC", "пкациа"   '.......................
    Identifier = ProcItalic(basestack, rest$)
    Exit Function
Case "йкеиди", "FKEY"
    Identifier = ProcFKey(basestack, rest$, Lang)
    Exit Function
Case "OPEN", "амоине"
    Identifier = ProcOpen(basestack, rest$, Lang)
    Exit Function
Case "NAME", "омола"
    Identifier = ProcName(basestack, rest$, Lang)
    Exit Function
Case "WITH", "ле"
    Identifier = MyWith(basestack, rest$, Lang)
    Exit Function
Case "METHOD", "леходос"
    Identifier = MyMethod(basestack, rest$, Lang, False, False)
    Exit Function
Case "TUNE", "лекыдиа"
    Identifier = ProcTune(basestack, rest$)
    Exit Function
Case "гвос", "SOUND"
    Identifier = ProcSound(basestack, rest$)
    Exit Function
Case "DB.USER", "басг.вягстгс"
    Identifier = ProcDBUSER(basestack, rest$, Lang)
    Exit Function
Case "DB.PROVIDER", "басг.паяовос"
    Identifier = ProcDBprovider(basestack, rest$, Lang)
    Exit Function
Case "TONE", "томос"
    Identifier = ProcTone(basestack, rest$)
    Exit Function
Case "VIEW", "деине"
    Identifier = ProcView(basestack, rest$, Lang)
    Exit Function
Case "CHOOSE.ORGAN", "епекене.ояцамо", "епикене.ояцамо"
    Identifier = ProcChooseOrgan(basestack, rest$, Lang)
    Exit Function
Case "BROWSER", "амакоцио"
    Identifier = ProcBrowser(basestack, rest$, Lang)
    Exit Function
Case "лпип", "BEEP"
    Identifier = ProcBeep(basestack, rest$)
    Exit Function
Case "MENU", "епикоцг"
    Identifier = MyMenu(0, basestack, rest$, Lang)
    Exit Function
Case "THREAD.PLAN", "сведио.мглатым"
    Identifier = ProcThreadPlan(basestack, rest$, Lang)
    Exit Function
Case "яухлисеис", "SETTINGS"
    Identifier = ProcSettings(basestack, rest$, Lang)
    Exit Function
Case "PROTOTYPE", "пяытотупо"
    Identifier = ProcProto(basestack, rest$, Lang)
    Exit Function
Case "апаяихлгсг", "апая", "ENUMERATION", "ENUM"
    Identifier = ProcEnum(basestack, rest$, LenB(here$) = 0)
    Exit Function
Case Else
    x1 = Len(rest$)
    Identifier = True
JUMPHEREFORMODULESFAST:
            MakeThisSub basestack, what$
          If GetSub(what$, y1) Then
               it = 0
            ElseIf GetSub(here$ + "." + what$, y1) Then
                    it = 1
            ElseIf Len(basestack.UseGroupname) > 0 Then

            If InStr(what$, basestack.UseGroupname) = 1 Then
            s$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
            If GetSub(s$, y1) Then
                it = 0
            ElseIf GetSub(here$ + "." + s$, y1) Then
                it = 1
            Else
                If GetSub(what$ + "()", y1) Then
                    GoTo jump123class
                ElseIf GetSub(what$ + "$()", y1) Then
                    GoTo jump123class
                ElseIf GetSub(s$ + "()", y1) Then
                    GoTo jump123class
                ElseIf GetSub(s$ + "$()", y1) Then
                    GoTo jump123class
                End If
                GoTo conthereplease
            End If
            Else
            GoTo conthereplease
            End If
            Else
            If GetSub(what$ + "()", y1) Then
jump123class:
                If sbf(y1).IamAClass Then
                ' it is a definition
jumpclassfinal:
                  If AddGroupFromClass(basestack, rest$, what$, here$ = "", False, "") Then Identifier = True
                  Exit Function
                End If
            End If
            If GetSub(what$ + "$()", y1) Then
                If sbf(y1).IamAClass Then
                    GoTo jumpclassfinal
                End If
            End If
conthereplease:
                rest$ = what$ + rest$
                   MyEr "unknown module " + what$, "╒ЦМЫСТО ТЛчЛА " + what$
                   
                   Identifier = False
                   Exit Function
            End If
            If NORUN1 Then rest$ = vbNullString: Exit Function


            x1 = y1
            If Len(what$) = 0 Then Identifier = False: Exit Function
            '''funcno = funcno + 1
            what$ = myUcase(what$): MakeThisSub basestack, what$
            ohere$ = here$
            If it = 0 Then
            If SecureNames Then
            
                If here$ = vbNullString Then
                If Len(what$) > 3 Then
                s$ = "▀" & x1 & "⌡" 'Left$(what$, 1) & x1
                Else
                s$ = what$
                End If
                Else
                s$ = RVAL33(here$, x1)
                End If
            Else
                s$ = what$
            End If
            
            Else
                s$ = ohere$ + "." + what$
            End If
            y1 = var2used
            par = PushParamGeneral(basestack, rest$, s$)
            y1 = y1 - var2used
            If LastErNum = -2 Then
                If Left$(rest$, 12) <> " : ERROR -2" Then rest$ = vbNullString
                    Identifier = True
                    Exit Function
                    Else
                If Not par Then Identifier = False: Exit Function
            End If
            here$ = s$
            With basestack
                 If .OriginalCode <> x1 And x1 <> 0 Then
                    .callohere = ohere$
                    .callx1 = x1
                    .ByName = y1
                    Identifier = True
                Else
                MyErMacro rest$, "Use Call command to call recuirsive in module", "вЯГСИЛОПОъГСЕ ТГМ йэКЕСЕ ЦИА АМАДЯОЛИЙч ЙКчСГ ТЛчЛАТОР"
                If here$ <> ohere$ Then here$ = ohere$
                Identifier = True
                End If
            End With
            Exit Function
NERR:

                        If MOUT And rest$ = vbNullString Then
                        Else
                                MyErMacro rest$, "unknown identifier " + what$, "╒ЦМЫСТО АМАЦМЫЯИСТИЙЭ " + what$
                        End If
                        Identifier = True
            
End Select


End Function

Function ReboundArr(bstack As basetask, Name$, arrcode As Long) As Boolean
On Error GoTo 0
Dim ss$
Name$ = myUcase(Name$)
If Left$(Name$, 5) = "ауто." Or Left$(Name$, 5) = "THIS." Then
    ss$ = bstack.UseGroupname + Mid$(Name$, 6)
Else
    If here$ = vbNullString Then
        ss$ = Name$
    Else
        ss$ = here$ + "." + Name$
    End If
End If

ReboundArr = varhash.findRebound(ss$, arrcode, var())

End Function
Function ReboundVar(bstack As basetask, Name$, q As Long) As Boolean
On Error GoTo 0
Dim ss$
Name$ = myUcase(Name$)
If Left$(Name$, 5) = "ауто." Or Left$(Name$, 5) = "THIS." Then
    ss$ = bstack.UseGroupname + Mid$(Name$, 6)
Else
    If here$ = vbNullString Then
        ss$ = Name$
    Else
        ss$ = here$ + "." + Name$
    End If
End If

ReboundVar = varhash.findRebound(ss$, q, var())

End Function
Function globalvarex(Name$, q As Variant) As Long
Dim makeitglobal As Boolean, ohere$
On Error GoTo 0
Dim j As Long

    j = AllocVar()
    If MyIsObject(q) Then
        Set var(j) = q
    Else
        If Right$(Name$, 1) = "%" Then
            On Error Resume Next
            q = MyRound(q)
            If Err.Number = 6 Then q = 0
            On Error GoTo 0
        End If
        var(j) = q
    End If

varhash.ItemCreator myUcase(Name$), j, , , True
globalvarex = j
End Function
Function globalvarEmpty(Name$) As Long
globalvarEmpty = AllocVar()
varhash.ItemCreator (Name$), globalvarEmpty, , , True
End Function
Function globalvar(Name$, q As Variant, Optional link As Boolean = False, Optional makeitglobal As Boolean = False, Optional ohere$ = vbNullString, Optional useType As Boolean = True) As Long
On Error GoTo 0
Dim j As Long, M As Long
If Not link Then
    If ohere$ <> vbNullString Then
        If varhash.Find2(ohere$ + "." + Name$, M, makeitglobal) And Not link Then
            If Not makeitglobal Then
                j = M
            Else
                j = AllocVar()
                varhash.ItemCreator ohere$ + "." + Name$, j, link, False, useType
            End If
        Else
            j = AllocVar()
            varhash.ItemCreator ohere$ + "." + Name$, j, link, False, False
        End If
        ohere$ = vbNullString
        If MyIsObject(q) Then
            Set var(j) = q
        Else
            If Right$(Name$, 1) = "%" Then
                On Error Resume Next
                q = MyRound(q)
                If Err.Number = 6 Then q = 0
                On Error GoTo 0
            End If
            var(j) = q
        End If
        globalvar = j
        Exit Function
    End If
    j = AllocVar()
    If MyIsObject(q) Then
        Set var(j) = q
    Else
        If Right$(Name$, 1) = "%" Then
            On Error Resume Next
            q = MyRound(q)
            If Err.Number = 6 Then q = 0
            On Error GoTo 0
        End If
        var(j) = q
    End If
Else
    If CStr(q) = vbNullString Then
        j = 0
    Else
        j = CLng(q)
    End If
End If
If Right$(Name$, 1) = "$" Then
    If strid.Find(Name$, M) Then
        If Len(here$) = 0 Or makeitglobal Then
            strid.ItemCreator2 Name$, -2
            varhash.ItemCreator2 strid, Name$, j, link, makeitglobal, useType
        Else
            strid.ItemCreator2 Name$, -1
            varhash.ItemCreator here$ + "." + Name$, j, link, , useType
        End If
        globalvar = j
        Exit Function
    End If
    If Len(here$) = 0 Or makeitglobal Then
        varhash.ItemCreator2 strid, Name$, j, link, makeitglobal, useType
    Else
        varhash.ItemCreator here$ + "." + Name$, j, link, , useType
    End If
Else
    If numid.Find(Name$, M) Then
        If Len(here$) = 0 Or makeitglobal Then
            numid.ItemCreator2 Name$, -2
            varhash.ItemCreator2 numid, Name$, j, link, makeitglobal, useType
         Else
            numid.ItemCreator Name$, -1
            varhash.ItemCreator here$ + "." + Name$, j, link, , useType
        End If
        globalvar = j
        Exit Function
    End If
    If Len(here$) = 0 Or makeitglobal Then
        varhash.ItemCreator2 numid, Name$, j, link, makeitglobal, useType
    Else
        varhash.ItemCreator here$ + "." + Name$, j, link, , useType
    End If
End If
globalvar = j
End Function
Function globalvarGroup(Name$, q As Variant, Optional link As Boolean = False, Optional makeitglobal As Boolean = False, Optional ohere$ = vbNullString, Optional useType As Boolean = True) As Long
On Error GoTo 0
Dim j As Long, M As Long
If Not link Then
    If ohere$ <> vbNullString Then
        If varhash.Find2(ohere$ + "." + Name$, M, makeitglobal) And Not link Then
            If Not makeitglobal Then
                j = M
            Else
                j = AllocVar()
                varhash.ItemCreator ohere$ + "." + Name$, j, link, False, useType
            End If
        Else
            j = AllocVar()
            varhash.ItemCreator ohere$ + "." + Name$, j, link, False, False
        End If
        ohere$ = vbNullString
        If MyIsObject(q) Then
            Set var(j) = q
        Else
            If Right$(Name$, 1) = "%" Then
                On Error Resume Next
                q = MyRound(q)
                If Err.Number = 6 Then q = 0
                On Error GoTo 0
            End If
            var(j) = q
        End If
        globalvarGroup = j
        Exit Function
    End If
    j = AllocVar()
    If MyIsObject(q) Then
        Set var(j) = q
    Else
        If Right$(Name$, 1) = "%" Then
            On Error Resume Next
            q = MyRound(q)
            If Err.Number = 6 Then q = 0
            On Error GoTo 0
        End If
        var(j) = q
    End If
Else
    If CStr(q) = vbNullString Then
        j = 0
    Else
        j = CLng(q)
    End If
End If

If here$ = vbNullString Then
varhash.ItemCreator (Name$), j, link, makeitglobal, useType
ElseIf makeitglobal Then
varhash.ItemCreator (Name$), j, link, False, useType
Else
varhash.ItemCreator here$ + "." + Name$, j, link, , useType
End If
globalvarGroup = j
End Function
Function globalvarStr(Name$, q$, Optional link As Boolean = False, Optional makeitglobal As Boolean = False, Optional ohere$ = vbNullString) As Long
On Error GoTo 0
Dim j As Long, M As Long
If Not link Then
    If ohere$ <> vbNullString Then
        If varhash.Find2(ohere$ + "." + Name$, M, makeitglobal) And Not link Then
            If Not makeitglobal Then
                j = M
            Else
                j = AllocVar()
                varhash.ItemCreator ohere$ + "." + Name$, j, link, False, True
            End If
        Else
            j = AllocVar()
            varhash.ItemCreator ohere$ + "." + Name$, j, link, False, False
        End If
        ohere$ = vbNullString
        MoveStringToVariant q$, var(j)
        globalvarStr = j
        Exit Function
    End If
    j = AllocVar()
    MoveStringToVariant q$, var(j)
Else
    If Len(q$) = 0 Then
        j = 0
    Else
        j = CLng(q)
    End If
End If
If strid.Find(Name$, M) Then
If M > -1 Then strid.ItemCreator2 Name$, -1
End If
If here$ = vbNullString Or makeitglobal Then
    varhash.ItemCreator2 strid, Name$, j, link, makeitglobal, True
Else
    varhash.ItemCreator here$ + "." + Name$, j, link, , True
End If
globalvarStr = j
End Function
Function GlobalVarRefOnly(Name$, Optional gl As Boolean = False) As Long
On Error GoTo 0
Dim j As Long
j = AllocVar() ' var2used
 var(j) = 0&  ' like an empty...
If here$ = vbNullString Or gl Then
varhash.ItemCreator myUcase(Name$), j, , gl, True
Else
varhash.ItemCreator here$ + "." + myUcase(Name$), j, , gl, True

End If
GlobalVarRefOnly = j
End Function
Sub GlobalVarRefLink(Name$, j As Long, Optional gl As Boolean = False)
On Error GoTo 0
If here$ = vbNullString Or gl Then
varhash.ItemCreator myUcase(Name$), j, True, gl
Else
varhash.ItemCreator here$ + "." + myUcase(Name$), j, True, gl

End If
End Sub
Sub GlobalVarRefLink2(Name$, j As Long, Optional gl As Boolean = False)
varhash.ItemCreator myUcase(Name$), j, True, gl

End Sub
Function LinkGroup(bstack As basetask, ByVal Name$, inpq As Variant, Optional usefinal As Boolean = False) As Boolean
Dim I As Long, Vlist As Boolean, FList, f$, aa$, v As Long
Dim s() As String, ThisGroup As Group, q As Group, ss$, it As Long, ohere$, itGroup As Group
Dim UnhidePrivate As Boolean, c As Constant

If VarTypeName(inpq) <> mGroup Then Exit Function
Set q = inpq
If q.IamApointer Then
    Exit Function
End If
If bstack.tpointer <> 0 Then
If VarTypeName(var(bstack.tpointer)) = mGroup Then
Set ThisGroup = var(bstack.tpointer)
UnhidePrivate = q.MatchTypes(ThisGroup.mytypes)
Set ThisGroup = Nothing
End If
End If
If Not usefinal Then
    If here$ = vbNullString Then
        Name$ = Name$ + "."
    Else
       Name$ = here$ + "." + myUcase(Name$) + "."
    End If
End If
cont1:



FList = q.FuncList
ohere$ = here$
here$ = Left$(Name$, Len(Name$) - 1)
Dim iamvariant As Boolean
For I = 1 To q.FieldsCount
    aa$ = q.ReadField(I)
    v = Abs(Split(aa$)(1))
    Vlist = True
    If MyIsObject(var(v)) Then
        Select Case Typename(var(v))
        Case mGroup
            Set ThisGroup = var(v)
            With ThisGroup
                ss$ = Split(aa$)(0)
                If Left$(ss$, 1) = "#" Then iamvariant = True: ss$ = Mid$(ss$, 2) Else iamvariant = False
                If Left$(ss$, 1) = "*" Then
                    ss$ = Mid$(ss$, 2)
                    If UnhidePrivate And AscW(ss$) = -65 Then
                        ss$ = Mid$(ss$, 2)
                    End If
                    If .IamApointer Then
                        varhash.ItemCreator Name$ + ss$, v, True
                    Else
                        it = globalvar(ss$, it)
                        MakeitObject2 var(it)
                        LinkGroup bstack, ss$, var(v)
                        Set itGroup = var(it)
                        itGroup.edittag = .edittag
                        itGroup.FuncList = .FuncList
                        itGroup.GroupName = ss$ + "."
                       ' Set itGroup.Sorosref = .soros.Copy
                        If UBound(.Fields) > 1 Then itGroup.Fields = .Fields
                        itGroup.HasValue = .HasValue
                        itGroup.HasSet = .HasSet
                        itGroup.HasStrValue = .HasStrValue
                        itGroup.HasParameters = .HasParameters
                        itGroup.HasParametersSet = .HasParametersSet
                        itGroup.HasRemove = .HasRemove
                        Set itGroup.Events = .Events
                        itGroup.highpriorityoper = .highpriorityoper
                        itGroup.HasUnary = .HasUnary
                        
                        itGroup.Patch = Name$ + ss$
                        If .HasStrValue Then
                              varhash.ItemCreator Name$ + ss$ + "$", it, True, , True
                        End If
                        Set itGroup.mytypes = .mytypes
                    End If
                Else
                    it = globalvar(ss$, it)
                    MakeitObject2 var(it)
                    Set itGroup = var(it)
                    If .IamApointer Then
                        If .link.IamFloatGroup Then
                           Set itGroup.LinkRef = .link
                            itGroup.IamApointer = True
                            itGroup.isRef = True
                        Else
                            itGroup.edittag = .link.edittag
                            itGroup.FuncList = .link.FuncList
                            itGroup.GroupName = ss$ + "."
                           ' Set itGroup.Sorosref = .link.soros.Copy
                            If UBound(.link.Fields) > 1 Then itGroup.Fields = .link.Fields
                            itGroup.HasValue = .link.HasValue
                            itGroup.HasSet = .link.HasSet
                            itGroup.HasStrValue = .link.HasStrValue
                            itGroup.HasParameters = .link.HasParameters
                            itGroup.HasParametersSet = .link.HasParametersSet
                            itGroup.HasRemove = .link.HasRemove
                            Set itGroup.Events = .link.Events
                            itGroup.highpriorityoper = .link.highpriorityoper
                            itGroup.HasUnary = .link.HasUnary
                            itGroup.Patch = here$ + "." + ss$
                            If .link.HasStrValue Then
                                varhash.ItemCreator Name$ + ss$ + "$", it, True, , True
                            End If
                            Set itGroup.mytypes = .link.mytypes
                        End If
                    Else
                        If UnhidePrivate And AscW(ss$) = -65 Then
                            ss$ = Mid$(ss$, 2)
                        End If
                        varhash.ItemCreator Name$ + ss$, v, True, , Not iamvariant
                    End If
                End If
            End With
        Case "lambda"
islambda:
            ss$ = Split(aa$)(0)
            If Left$(ss$, 1) = "#" Then iamvariant = True: ss$ = Mid$(ss$, 2) Else iamvariant = False
            If UnhidePrivate And AscW(ss$) = -65 Then
            ss$ = Mid$(ss$, 2)
            End If
            varhash.ItemCreator Name$ + ss$, v, True, , Not iamvariant
            GlobalSub Name$ + ss$ + "()", "", Name$, , v
        Case "Constant"
            If var(v).flag Then
                GoTo islambda
            Else
                GoTo cont123
            End If
        Case Else
            GoTo cont123
        End Select
    Else
cont123:
        ss$ = Split(aa$)(0)
        If Left$(ss$, 1) = "#" Then iamvariant = True: ss$ = Mid$(ss$, 2) Else iamvariant = False
        varhash.ItemCreator Name$ + ss$, v, True, , Not iamvariant

        If UnhidePrivate And AscW(ss$) = -65 Then
            varhash.ItemCreator Name$ + Mid$(ss$, 2), v, True, , Not iamvariant
        End If
    End If
Next



Dim mm As Long
Dim als As Long
Dim subname$
If FList <> "" Then
If UnhidePrivate Then
subname$ = Replace(FList, ChrW(-65), "")
subname$ = Replace(Replace(subname$, Chr$(3), Name$), Chr$(2), Name$)
Else
subname$ = Replace(Replace(FList, Chr$(3), Name$), Chr$(2), Name$)
End If

s() = Split(subname$, Chr$(1))
For I = LBound(s$()) + 1 To UBound(s$())
If s(I) <> "" Then
mm = val(Split(s(I))(1))

als = AllocSub()
sbf(als) = sbf(Abs(mm))
ss$ = Split(s(I))(0)
 subHash.ItemCreator ss$, als, True

 
 End If
Next I

End If
here$ = ohere$
LinkGroup = Vlist Or FList <> ""

End Function

Sub GlobalArr(bstack As basetask, Name$, rst$, items As Long, q As Long, Optional useglobalname As Boolean = False, Optional Reverse As Boolean = False, Optional declareglobal As Boolean = False)
' new mArray..
Dim afto As New mArray, NewKey As Long, zeroitem As Object
If rst$ = vbNullString And q = -1 Then
' Make an empty array
rst$ = NLtrim(rst$)
GoTo dummyarray
End If


Dim j As Long, I As Long, p As Variant, aa As Boolean, onemore As Long, pbase As Variant
If DimLikeBasic And ArrBase = 0 Then onemore = 1: Reverse = True
items = 1
I = 0
If FastSymbol(rst$, ChrW(8)) Then


pbase = afto.myarrbase
I = 1
GoTo neojump1
Else

    Do
        If IsExp(bstack, rst$, p, flatobject:=True, nostring:=True) Then
            pbase = afto.myarrbase
            If Fast2Label(rst$, "TO", 2, "еыс", 3, 3) Then
                pbase = -p
                onemore = 0
                If IsExp(bstack, rst$, p, flatobject:=True, nostring:=True) Then
                    If p < -pbase Then
                        j = -p
                        p = -pbase
                        pbase = j
                    End If
                    p = p + pbase + 1
                Else
                    missNumber
                    Exit Sub
                End If
            End If
            I = I + 1
            If onemore Then If p > 0 Then p = p + onemore
            items = items * Int(Abs(p))
            afto.PushDim CLng(p), pbase
            aa = True
        Else
            GoTo dummyarray
        End If
        If I > 9 Then Exit Do
    Loop Until Not FastSymbol(rst$, ",")
End If

If aa And FastSymbol(rst$, ")") Then
neojump1:
afto.RevOrder = Reverse
If Right$(Name$, 2) <> "$(" Then
    If Fast2VarNoTrim(rst$, "ыс", 2, "AS", 2, 3, j) Then
    I = 0
    j = j - 1
        If IsLabelSymbolNew(rst$, "аяихлос", "DECIMAL", j, I) Then
            afto.MyTypeToBe = vbDecimal
        ElseIf IsLabelSymbolNew(rst$, "дипкос", "DOUBLE", j, I) Then
            afto.MyTypeToBe = vbDouble
        ElseIf IsLabelSymbolNew(rst$, "апкос", "SINGLE", j, I) Then
            afto.MyTypeToBe = vbSingle
        ElseIf IsLabelSymbolNew(rst$, "коцийос", "BOOLEAN", j, I) Then
            afto.MyTypeToBe = vbBoolean
        ElseIf IsLabelSymbolNew(rst$, "лайяус", "LONG", j, I) Then
            If IsLabelSymbolNew(rst$, "лайяус", "LONG", j) Then
                afto.MyTypeToBe = 20
            Else
                afto.MyTypeToBe = vbLong
            End If
        ElseIf IsLabelSymbolNew(rst$, "айеяаиос", "INTEGER", j, I) Then
            afto.MyTypeToBe = vbInteger
        ElseIf IsLabelSymbolNew(rst$, "коцистийос", "CURRENCY", j, I) Then
            afto.MyTypeToBe = vbCurrency
        ElseIf IsLabelSymbolNew(rst$, "ьгжио", "BYTE", j, I) Then
            afto.MyTypeToBe = vbByte
        ElseIf IsLabelSymbolNew(rst$, "цяалла", "STRING", j, I) Then
            afto.MyTypeToBe = vbString
        ElseIf IsLabelSymbolNew(rst$, "атупос", "VARIANT", j, I) Then
        afto.MyTypeToBe = vbVariant
        ElseIf IsLabelSymbolNew(rst$, "амтийеилемо", "OBJECT", j, I) Then
        afto.MyTypeToBe = vbObject
        ElseIf IsLabelSymbolNew(rst$, "лецакосайеяаиос", "BIGINTEGER", j, I) Then
        afto.MyTypeToBe = vbObject
        Set zeroitem = New BigInteger
        ElseIf IsLabelSymbolNew(rst$, "глеяолгмиа", "DATE", j, I) Then
            afto.MyTypeToBe = vbDate
      '  ElseIf IsLabelSymbolNew(rst$, "диепажг", "INTERFACE", j, i) Then
      '      afto.MyTypeToBe = vbDataObject
        End If
    End If
End If
If p < 0 Then

End If
afto.PushEnd

If Not zeroitem Is Nothing Then
     afto.SerialItem CVar(zeroitem), 0, 3
'    afto.Fillobj bstack
    Set zeroitem = Nothing
End If
dummyarray:
    NewKey = AllocVar()  ' version 8.1
    ' check if is already in ucase
    Name$ = myUcase(Name$)
    If here$ = vbNullString Or useglobalname Then
        ''If bstack.tpointer > 0 Then
        varhash.ItemCreator (Name$), NewKey, , declareglobal, True

        afto.arrname = Name$
    Else
        varhash.ItemCreator here$ + "." + bstack.GroupName + Name$, NewKey, , , True
        'afto.arrname = here$ + "." + bstack.GroupName + Name$
        afto.arrname = bstack.GroupName + Name$
    End If
    If q = -1 Then
            q = NewKey
    End If
    Set var(NewKey) = afto
    
Else
If FastSymbol(rst$, ",") Then
items = 0
MyEr "No more 10 dimensions allowed", "лщВЯИ 10 ДИАСТэСЕИР ЕПИТЯщПОМТАИ"
Else

    items = -1
    rst$ = ":?" + rst$
    End If
End If

End Sub
Private Function GlobalArrProp(bstack As basetask, Name$, globalName As Boolean) As ppppLight
' new mArray..
Dim afto As New ppppLight, NewKey As Long
afto.PushDim 1
afto.PushEnd
NewKey = AllocVar()
Name$ = myUcase(Name$)
If here$ = vbNullString Or globalName Then
    varhash.ItemCreator (Name$), NewKey, , , True
    afto.arrname = Name$
Else
    varhash.ItemCreator here$ + "." + bstack.GroupName + Name$, NewKey, , , True
    afto.arrname = bstack.GroupName + Name$
End If
Set var(NewKey) = afto
Set GlobalArrProp = afto
End Function

Sub GlobalArrResize(afto As mArray, bstack As basetask, Name$, rst$, items As Long)
' new mArray..

Dim j As Long, I As Long, p As Variant, aa As Boolean, onemore As Long, pbase As Variant
If DimLikeBasic And afto.myarrbase = 0 Then onemore = 1
items = 1
I = 0
afto.StartResize
If FastSymbol(rst$, ChrW(8)) Then
pbase = afto.myarrbase
I = 1
items = 0
afto.PushDim 0&, pbase
afto.PushEnd
Else
    Do
    If IsExp(bstack, rst$, p) Then
    If afto.IHaveGui And p <> 0 Then GoTo noredim
    pbase = afto.myarrbase
    If Fast2Label(rst$, "TO", 2, "еыс", 3, 3) Then
        pbase = -p
        onemore = 0
        If IsExp(bstack, rst$, p) Then
            If p < -pbase Then
            j = -p
            p = -pbase
            pbase = j
            
            End If
            p = p + pbase + 1
            
        Else
            missNumber
            Exit Sub
        End If
    End If
    I = I + 1
    If onemore Then If p > 0 Then p = p + onemore
    items = items * Int(Abs(p))
    afto.PushDim CLng(p), pbase
    aa = True
    Else
    GoTo fault
    End If
    If I > 9 Then Exit Do
    
    Loop Until Not FastSymbol(rst$, ",")

afto.PushEnd
fault:
If aa And FastSymbol(rst$, ")") Then
I = 1
If Fast2VarNoTrim(rst$, "ыс", 2, "AS", 2, 3, I) Then
Dim ss$
If IsLabelOnly(rst$, ss$) = 1 Then
Else
    SyntaxError
End If
End If
Else
     If FastSymbol(rst$, ",") Then
items = 0
MyEr "No more 10 dimensions allowed", "лщВЯИ 10 ДИАСТэСЕИР ЕПИТЯщПОМТАИ"
Else
    items = -1
    rst$ = ":?" + rst$
    End If
End If
End If
Exit Sub
noredim:
MyEr "No Redim allowed, use Declare Over/Under ", "дЕМ ЕПИТЯщПОМТАИ АККАЦщР, ВЯГСИЛОПОъГСЕ ТГМ ояисе памы/упо"
End Sub


Function neoGetArray(bstack As basetask, ByVal nm$, ga As iBoxArray, Optional searchonly As Boolean = False, Optional ByVal useglobalname As Boolean = False, Optional useLocalOnly As Boolean = False, Optional rightexpression As Boolean, Optional feedback As Boolean, Optional fromthere As Long = 0) As Boolean
Dim K As Long, myobject As Object
Dim n$, hidden As Boolean
nm$ = myUcase(nm$)
If Len(nm$) = 0 Then SyntaxError: Exit Function
If useglobalname Or here$ = vbNullString Then
n$ = bstack.GroupName + nm$
ElseIf Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
'nm$ = bstack.UseGroupname + Mid$(nm$, 6)

GoTo here12
Else
hidden = Left$(nm$, 1) = ChrW(&H1FFF)
n$ = here$ + "." + bstack.GroupName + nm$
End If


If Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
here12:
    If useLocalOnly Then Exit Function
    If Len(bstack.UseGroupname) > 0 Then
    If Mid$(nm$, 6, 1) = ChrW(&HFFBF) Then
    n$ = bstack.UseGroupname + Mid$(nm$, 6)
      If Not varhash.Find3(n$, K, feedback) Then
 GoTo isagroupvalue
    ' varhash.Find3 Left$(n$, Len(n$) - 2), k, feedback
     
     End If
    Else
    n$ = bstack.UseGroupname + Mid$(nm$, 6)
    
     If Not varhash.Find3(n$, K, feedback) Then
     n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
     varhash.Find3 n$, K, feedback
     End If
     End If
     If K = 0 Then
     ' check for inventory

     n$ = bstack.UseGroupname + Mid$(nm$, 6)
isagroupvalue:
      If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find3(n$, K, feedback) Then
            If MyIsObject(var(K)) Then
            If var(K) Is Nothing Then
                Set ga = New ppppLight
                Set ga.GroupRef = Nothing
                ga.Arr = False
                neoGetArray = True
               
                Exit Function
            ElseIf TypeOf var(K) Is mHandler Then
                
                If var(K).T1 < 3 Then
                Set ga = New ppppLight
                Set ga.GroupRef = var(K)
                ga.Arr = False
                neoGetArray = True
                Exit Function
                Else
                K = 0
                End If
            ElseIf TypeOf var(K) Is Group Then
            GoTo checkGroup
            End If
            End If
        End If
        n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
              If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find3(n$, K, feedback) Then
            If TypeOf var(K) Is mHandler Then
            If var(K).T1 < 3 Then
                Set ga = New ppppLight
                Set ga.GroupRef = var(K)
                ga.Arr = False
                neoGetArray = True
                 Exit Function
                End If
            End If
            K = -1
        End If
     
     End If
    Else
    n$ = Mid$(nm$, 5)
      If bstack.GetDot(n$, 1) Then varhash.Find3 here$ + "." + n$, K, feedback Else Exit Function
    End If

ElseIf varhash.Find(n$, K) = False Then
If useLocalOnly Then
If Len(bstack.UseGroupname) > 0 Then
        If InStr(nm$, bstack.UseGroupname) = 1 Then
        n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, Len(bstack.UseGroupname) + 1)
        varhash.Find3 n$, K, feedback
        Else
        If n$ Like "*[$%](" Then
        n$ = Mid$(n$, 1, Len(n$) - 2)
        Else
        n$ = Mid$(n$, 1, Len(n$) - 1)
        End If
        If varhash.Find3(n$, K, feedback) Then
        GoTo contHandler
        End If
        
        End If
Else
If n$ Like "*[$%](" Then
n$ = Mid$(n$, 1, Len(n$) - 2)
Else
n$ = Mid$(n$, 1, Len(n$) - 1)
End If
If varhash.Find3(n$, K, feedback) Then
contHandler:
    If TypeOf var(K) Is mHandler Then
        If var(K).T1 < 3 Then
            Set ga = New ppppLight
            Set ga.GroupRef = var(K)
            ga.Arr = False
            neoGetArray = True
            Exit Function
        End If
    ElseIf TypeOf var(K) Is Group Then
checkGroup:
    If rightexpression Then
        If var(K).HasParametersSet Then
             Set ga = New ppppLight
                    Set ga.GroupRef = var(K)
                    ga.Arr = False
                    neoGetArray = True
                    Exit Function
            Else
        
            Exit Function
            End If
    ElseIf var(K).HasParameters Then
            Set ga = New ppppLight
                   Set ga.GroupRef = var(K)
                   
                   If Not hidden Then
                   ga.CodeName = var(K).FloatGroupName
                   If Len(ga.CodeName) = 0 Then ga.CodeName = n$
                   Else
                   ga.CodeName = vbNullString
                   End If
                   ga.Arr = False
                   neoGetArray = True
                   Exit Function
            Else
            
            Exit Function
    End If

    End If
    K = -1
End If
End If
Else
            If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If

' check group or handler

        If varhash.Find3(n$, K, feedback) Then
checkforglobal:
            If TypeOf var(K) Is mHandler Then
                If var(K).T1 < 3 Then
                        If rightexpression Then
                        Set ga = New mArray
                        Else
                        Set ga = New ppppLight
                        End If
                        Set ga.GroupRef = var(K)

                        ga.Arr = False
                        
                        neoGetArray = True
                        Exit Function
                        Else
                        
                    End If
            Else
                If MyIsObject(var(K)) Then
                    If Typename(var(K)) = mGroup Then
                    
checkgrouphere:
                        If var(K).HasParametersSet Then
                            ' process parameters
                            Set ga = New ppppLight
                            Set ga.GroupRef = var(K)
                            ga.Arr = False
                            neoGetArray = True
                        If rightexpression Then Exit Function
                        ElseIf var(K).HasParameters Then  ' this is for inventories
                            Set ga = New mArray
                            Set ga.GroupRef = var(K)
                            ga.CodeName = n$
                            ga.Arr = False
                            neoGetArray = True
                        End If
                        Exit Function
                    Else
                        If varhash.Find(nm$, K) Then GoTo conthere
                        Exit Function
                    End If
                Else
                    If varhash.Find(nm$, K) Then GoTo conthere
                    Exit Function
                End If
            End If
            K = -1
            n$ = bstack.GroupName + nm$
                ' not a mhandler
        Else
        n$ = nm$
        If Not varhash.Find3(n$, K, feedback) Then
          If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find3(n$, K, feedback) Then GoTo checkforglobal
      n$ = nm$
      End If
        End If
End If
Else
fromthere = 0
End If
conthere:
If K <= 0 Then
    
            If searchonly Then Exit Function
            If Not useLocalOnly Then
                        n$ = nm$
                        varhash.Find3 n$, K, feedback
        Else
       
    If bstack.StaticCollection Is Nothing Then Exit Function
    
    If bstack.ExistVar(Left$(nm$, Len(nm$) - 1)) Then
    bstack.ReadVar Left$(nm$, Len(nm$) - 1), var(0)
    If VarTypeName(var(0)) = mHdlr Then
                Set ga = New ppppLight
                Set ga.GroupRef = var(0)
                ga.Arr = False
                neoGetArray = True
                var(0) = 0&
                Exit Function
    End If
    var(0) = 0&
                Exit Function
    End If
     Exit Function
        
            End If
End If


If K > fromthere Then
If myVarType(var(K), vbEmpty) Then
Set ga = New mArray: neoGetArray = True
Else
If TypeOf var(K) Is iBoxArray Then
    Set ga = var(K)
Else
    Set myobject = var(K)
    If CheckIsmArray(myobject) Then
        Set ga = myobject
    Else
        NotArray
        Set myobject = Nothing
    Exit Function
    End If
    Set myobject = Nothing
End If

End If
  neoGetArray = True
           
ElseIf K = 0 Then
 If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find(n$, K) Then
            If TypeOf var(K) Is mHandler Then
                If var(K).T1 < 3 Then
                    Set ga = New ppppLight
                    Set ga.GroupRef = var(K)
                    ga.Arr = False
                    neoGetArray = True
                    Exit Function
                End If
            End If
            K = -1
        End If


If n$ = vbNullString Then Exit Function
        nm$ = Mid$(n$, 1, Len(n$) - 1)
        If Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
    If useLocalOnly Then Exit Function
    If Len(bstack.UseGroupname) > 0 Then
    n$ = bstack.UseGroupname + Mid$(nm$, 6)
     If Not varhash.Find(n$, K) Then
     n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
     varhash.Find n$, K
     End If
    Else
    n$ = Mid$(nm$, 5)
      If bstack.GetDot(n$, 1) Then varhash.Find here$ + "." + n$, K Else Exit Function
    End If
End If
        If varhash.Find(n$, K) Then
        If TypeOf var(K) Is mHandler Then
        
        Set ga = New ppppLight
        Set ga.GroupRef = var(K)
        ga.Arr = False
        neoGetArray = True
        Exit Function
        End If
        End If
End If


End Function
Function neoGetArrayLinkOnly(bstack As basetask, ByVal nm$, link As Long, Optional useglobalname As Boolean = False, Optional useLocalOnly As Boolean = False) As Boolean
Dim K As Long
Dim n$
nm$ = myUcase(nm$)
If Len(nm$) > 5 And False Then
           ' not used any more
                If Left$(nm$, 5) = "THIS." Then
               
                    n$ = StripThis2(here$)
                    If n$ <> "" Then n$ = n$ + "." + bstack.GroupName + Mid$(nm$, 6) Else n$ = here$ + "." + nm$
                ElseIf Left$(nm$, 5) = "ауто." Then
           
                    n$ = StripThis2(here$)
                    If n$ <> "" Then n$ = n$ + "." + bstack.GroupName + Mid$(nm$, 6) Else n$ = here$ + "." + nm$
                Else
                If useglobalname Then
                    n$ = nm$
                    Else
                    n$ = here$ + "." + bstack.GroupName + nm$
                    End If
                End If

Else
If useglobalname Then
n$ = nm$
Else
If here$ = vbNullString Then
n$ = nm$
Else

n$ = here$ + "." + bstack.GroupName + nm$
End If
End If
End If

If varhash.Find(n$, K) = False And Len(bstack.UseGroupname) > 0 Then
    If Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
        If useLocalOnly Then Exit Function
        If StripThis2(bstack.UseGroupname) = vbNullString Then
            n$ = bstack.UseGroupname + Mid$(nm$, 6)
        Else
            n$ = StripThis2(bstack.UseGroupname) + "." + Mid$(nm$, 6)
        End If
        varhash.Find n$, K
    End If
End If
If K = 0 Then
    If Not useLocalOnly Then
        n$ = myUcase(nm$)
        varhash.Find n$, K
    End If
End If
If K > 0 Then
    link = K
    neoGetArrayLinkOnly = True
    
End If

End Function

Function CopyArrayItems(bstack As basetask, nm$) As String
Dim K As Long
If neoGetArrayLinkOnly(bstack, nm$, K) Then CopyArrayItems = CStr(K)

End Function

Function CopyArrayItemsNoFormated(bstack As basetask, nm$) As Long
Dim K As Long
If varhash.Find(nm$, K) Then
CopyArrayItemsNoFormated = K
ElseIf varhash.Find(nm$, K) Then
If TypeOf var(K) Is mHandler Then
CopyArrayItemsNoFormated = -K
End If
End If
End Function
Function ModuleSubAsap(n$, q As String, Optional sbgroupname As String = vbNullString, Optional Extern As Long) As Long
Dim j As Long, where As Long
j = AllocSub()
With sbf(j)
    .Extern = Extern
    .sb = q
    .sbc = 0
    .sbgroup = sbgroupname
    Set .subs = Nothing
    .goodname = n$
    .Changed = False
End With
subHash.ItemCreator n$, j
ModuleSubAsap = j
End Function
Function ModuleSub(Name$, q As String, Optional sbgroupname As String = vbNullString) As Long
Dim j As Long, n$, where As Long
n$ = myUcase(Name$, True)
j = AllocSub()
With sbf(j)
    .Extern = 0
    .sb = q
    .sbc = 0
    .sbgroup = sbgroupname
    Set .subs = Nothing
    .goodname = Name$
    .Changed = False
    .locked = Right$(q, 1) = ChrW(&H1FFD)
    If .locked Then
    On Error Resume Next
    where = val(Mid$(q, InStr(q, "CALL EXTERN ") + 12))
    If VarType(var(where)) = vbObject Then
        If TypeOf var(where) Is lambda Then
        .Extern = where
        ElseIf Not TypeOf var(where) Is stdCallFunction Then
        GoTo mes11
        Else
        .sbc = where
        End If
    Else
mes11:
    MyEr "Declaration Problem " + Name$, "пЯЭБКГЛА оЯИСЛОЩ " + Name$
    Exit Function
    End If
    End If
End With
subHash.ItemCreator n$, j
ModuleSub = j
End Function
Function GlobalSub(Name$, q As String, Optional sbgroupname As String = vbNullString, Optional ByVal nameonly$ = vbNullString, Optional Extern As Long = 0) As Long
Dim j As Long, n$, where As Long
n$ = myUcase(Name$, True)
j = AllocSub()
With sbf(j)
    .Extern = Extern
    .sb = q
    .sbc = 0
    .sbgroup = sbgroupname
    .tpointer = 0
    Set .subs = Nothing
    .goodname = Name$
    .Changed = False
End With
If Not nameonly$ = vbNullString Then
If sbgroupname = vbNullString Then
    nameonly$ = myUcase(nameonly$, True)
    If comhash.Find(nameonly$, where) Then
    
    If n$ = nameonly$ Then
    comhash.ItemCreator2 nameonly$, 0, 32
    Else
    comhash.ItemCreator2 nameonly$, 0, 33
    End If
    End If
    End If
End If
subHash.ItemCreator n$, j

GlobalSub = j
End Function

Function GetGlobalVar(nm$, I As Long) As Boolean

If varhash.Find(myUcase(nm$), I) Then
GetGlobalVar = True
End If
End Function

Function StripThis(ByVal n$) As String

Dim A$, b$, I&
A$ = n$
DropLeft "╩.", A$


'Exit Function
A$ = StripRVAL(A$)  ' we need that

If A$ = n$ Then
StripThis = vbNullString
Exit Function
Else
b$ = A$
End If
I& = InStr(n$, ".")
If I& > 0 Then

DropLeft ".", n$
I& = InStrRev(n$, ".") - 1
If I& > 0 Then
StripThis = b$ + "." + Left$(n$, I&)
Else
StripThis = b$
End If
Else
StripThis = b$
End If
End Function
Function StripThis2(ByVal n$) As String

Dim A$, b$, I&

If StripRVAL2(n$, A$) Then
StripThis2 = A$
Exit Function
End If
If A$ = n$ Then
StripThis2 = vbNullString
Exit Function
Else
b$ = A$
End If
I& = InStr(n$, ".")
If I& > 0 Then

DropLeft ".", n$
I& = InStrRev(n$, ".") - 1
If I& > 0 Then
StripThis2 = b$ + "." + Left$(n$, I&)
Else
StripThis2 = b$
End If
Else
StripThis2 = b$
End If
End Function

Function GetVar1(bstack As basetask, ByVal nm$, I As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False, Optional finalname As String, Optional checktype As Boolean = 0) As Boolean
If skip Then Exit Function
' called from unfloat
If varhash.Find2(nm$, I, checktype) Then GetVar1 = True
End Function
Function GetVar3(bstack As basetask, ByVal nm$, I As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False, Optional finalname As String, Optional checktype As Boolean = 0, Optional feedback As Boolean, Optional nosearch As Boolean, Optional statobj As Boolean = False) As Boolean
If skip Then Exit Function
If Not bstack.StaticCollection Is Nothing Then
    If bstack.ExistVar(nm$, statobj) Then I = -1: Exit Function
    
End If
Dim n$, cc As Long
  
cc = Len(nm$)
If cc > 5 Then
    If Left$(nm$, 5) = "ауто." Then
    GoTo cont1
    ElseIf Left$(nm$, 5) = "THIS." Then
cont1:
        If Len(bstack.UseGroupname) > 0 Then
            feedback = False
            n$ = bstack.UseGroupname + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
        Else
            n$ = StripThis2(here$)
            If n$ <> vbNullString Then
                n$ = n$ + "." + Mid$(nm$, 6)
            Else
                If IsLabel(bstack, Mid$(nm$, 6), n$) Then
                    n$ = here$ + "." + n$
                Else
                    n$ = here$ + "." + nm$
                End If
            End If
        End If
        
    Else
        If lookglobalonly Then
            n$ = nm$
        Else

           
            n$ = here$ + "." + nm$
        End If
    End If
ElseIf cc = 4 Then
    If nm$ = "ауто" Then
    GoTo cont2
    ElseIf nm$ = "THIS" Then
cont2:

        n$ = vbNullString
         If bstack.GetDotNew(n$, 1) Then
           If Len(n$) = 0 Then GetVar3 = False: Exit Function
            nm$ = Left$(n$, Len(n$) - 1)
            finalname = nm$
            feedback = True
        End If
    End If
    If lookglobalonly Then
        n$ = nm$
    Else
        n$ = here$ + "." + nm$
    End If
Else
    If lookglobalonly Then
        n$ = nm$
    Else
        n$ = here$ + "." + nm$
    End If

End If

If varhash.Find2(n$, cc, checktype, feedback) Then
there12:
    GetVar3 = True
    I = cc
ElseIf Not looklocalonly Then
    n$ = nm$
    If Len(bstack.UseGroupname) > 0 Then
        If InStr(n$, bstack.UseGroupname) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find(n$, cc) Then
                checktype = True
                I = cc
                GetVar3 = True
                nm$ = n$
            End If
        ElseIf InStr(bstack.UseGroupname, n$) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find2(n$, cc, checktype, feedback) Then
                I = cc
                GetVar3 = True
                nm$ = n$
            End If
        End If
    End If
    If Not GetVar3 Then
        If varhash.Find2(nm$, cc, checktype, feedback) Then
            I = cc
            GetVar3 = True
        End If
    End If
End If
End Function
Function GetVar(bstack As basetask, ByVal nm$, I As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False, Optional finalname As String, Optional checktype As Boolean = 0, Optional feedback As Boolean, Optional nosearch As Boolean) As Boolean
If skip Then Exit Function
If Not bstack.StaticCollection Is Nothing Then
    If bstack.ExistVar(nm$) Then I = -1: Exit Function
End If
Dim n$, cc As Long
  
cc = Len(nm$)
If cc > 5 And I >= 0 Then
    If Left$(nm$, 5) = "ауто." Then
    GoTo cont1
    ElseIf Left$(nm$, 5) = "THIS." Then
cont1:
        If Len(bstack.UseGroupname) > 0 Then
            feedback = False
            n$ = bstack.UseGroupname + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
        Else
            n$ = StripThis2(here$)
            If n$ <> vbNullString Then
                n$ = n$ + "." + Mid$(nm$, 6)
            Else
                If IsLabel(bstack, Mid$(nm$, 6), n$) Then
                    n$ = here$ + "." + n$
                Else
                    n$ = here$ + "." + nm$
                End If
            End If
        End If
        
    Else
        If lookglobalonly Then
            n$ = nm$
        Else

           
            n$ = here$ + "." + nm$
        End If
    End If
Else
    If lookglobalonly Then
        n$ = nm$
    Else
        n$ = here$ + "." + nm$
    End If

End If

If varhash.Find2(n$, cc, checktype, feedback) Then
there12:
    GetVar = True
    I = cc
ElseIf Not looklocalonly Then
    n$ = nm$
    If Len(bstack.UseGroupname) > 0 Then
        If InStr(n$, bstack.UseGroupname) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find(n$, cc) Then
                
                checktype = varhash.vType(varhash.Index)
                I = cc
                GetVar = True
                nm$ = n$
            End If
        ElseIf InStr(bstack.UseGroupname, n$) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find2(n$, cc, checktype, feedback) Then
                I = cc
                GetVar = True
                nm$ = n$
            End If
        End If
    End If
    If Not GetVar Then
        If varhash.Find2(nm$, cc, checktype, feedback) Then
            I = cc
            GetVar = True
        ElseIf varhash.Find2(here$ + "." + nm$, cc, checktype, feedback) Then
            I = cc
            GetVar = True
        End If
    End If
End If

End Function
Function FindGuiImage(basestack As basetask, Scr As Object) As Object
Dim p As Long
    p = GetCode(Scr)
    If p > 32 Then
        If getvar2(basestack, players(p).ControlName, p, True) Then
           Set FindGuiImage = var(p)
        End If
     End If
End Function
Function getvar2(bstack As basetask, nm$, I As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False) As Boolean
If skip Then Exit Function
If Not bstack.StaticCollection Is Nothing Then
If bstack.ExistVar(nm$) Then I = -1: Exit Function
End If
Dim n$, cc As Long
cc = Len(nm$)
If cc > 5 Then
    If Left$(nm$, 5) = "ауто." Then
    GoTo cont1
    ElseIf Left$(nm$, 5) = "THIS." Then
cont1:
        If Len(bstack.UseGroupname) > 0 Then
                  n$ = bstack.UseGroupname + Mid$(nm$, 6)
                If varhash.Find(n$, cc) Then GoTo there12
                
                    n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
                If varhash.Find(n$, cc) Then GoTo there12
        Else
        
            n$ = StripThis2(here$)
            If n$ <> "" Then
                n$ = n$ + "." + Mid$(nm$, 6)
            
            Else
            If IsLabel(bstack, Mid$(nm$, 6), n$) Then ' NO NEED DOT ANY MORE..(WE USE DOTNEW)
                    n$ = here$ + "." + n$
            Else
                    n$ = here$ + "." + nm$
            End If
            End If
        End If
    Else
    If lookglobalonly Then
     n$ = nm$
    Else
        n$ = here$ + "." + nm$
        End If
    End If
ElseIf cc = 4 Then
    If nm$ = "ауто" Then
    GoTo cont2
    ElseIf nm$ = "THIS" Then
cont2:

       n$ = vbNullString

        If bstack.GetDotNew(n$, 1) Then
            If Len(n$) = 0 Then getvar2 = False: Exit Function
           nm$ = Left$(n$, Len(n$) - 1)
        End If
    End If
    If lookglobalonly Then
         n$ = nm$
        Else
    n$ = here$ + "." + nm$


    End If
Else
    If lookglobalonly Then
        n$ = nm$
    Else
        n$ = here$ + "." + nm$
    End If

End If

If varhash.Find(n$, cc) Then
there12:
    getvar2 = True
    I = cc
ElseIf Not looklocalonly Then
    If varhash.Find(nm$, cc) Then
    I = cc
    getvar2 = True
    ElseIf Len(bstack.UseGroupname) > 0 Then
        If InStr(nm$, bstack.UseGroupname) = 1 Then
        n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, Len(bstack.UseGroupname) + 1)
        If varhash.Find(n$, cc) Then
        I = cc
        getvar2 = True
    End If
    End If
    End If
End If



End Function
Function GetlocalVar(nm$, I As Long) As Boolean
If varhash.Find(here$ + "." + myUcase(nm$), I) Then GetlocalVar = True
End Function

Function RVAL33(ByVal s$, v As Long) As String
Dim ss$, n As Long, what$

n = InStrRev(s$, "╚")

If n = 0 Then
RVAL33 = s$ + "╚" & (v) & "╩╚" & (v) & "╩"
Else
    ss$ = Left$(s$, n - 1&)
    RVAL33 = RVAL(ss$, 1) & "╚" & (v) & "╩"
End If
End Function
Function RVAL2(ByVal s$, v As Long) As String
Dim ss$
If InStr(s$, "╚") = 0 Then
RVAL2 = s$
Else
ss$ = GetStrUntil("╚", s$)
If val(s$) + v <= 0 Then
RVAL2 = ss$ + "."
Else
RVAL2 = ss$ & "╚" & (val(s$) + v) & "╩."
End If
End If
End Function
Function iRVAL22(ByVal s$) As Long
    Dim n As Long
    iRVAL22 = val(Mid$(s$, InStrRev(s$, "╚") + 1))
End Function
Function RVAL(ByVal s$, v As Long) As String
Dim ss$
If InStr(s$, "╚") = 0 Then
RVAL = s$ & "╚" & (v) & "╩"
Else
ss$ = GetStrUntil("╚", s$)

RVAL = ss$ & "╚" & (val(s$) + v) & "╩"
End If
End Function
Function TheSame(ByVal s$, ByVal q$) As Boolean
Dim part1 As String
part1 = StripRVAL(s$)
If part1 <> "" Then
    If InStr(part1, ".") > 0 Then
    ' all in part1
    Else
    DropLeft ".", s$
    part1 = part1 + "." + s$
    End If
    End If
TheSame = part1 = q$
End Function
Function StripRVAL2(s$, result$) As Boolean
' return s$ number as string
' return function name...
'
Dim bb$, VarName$
bb$ = s$
If InStr(s$, "╚") = 0 Then
' look varlist to find group
Dim I As Long
I = InStrRev(s$, ".")
If I > 1 Then s$ = Left$(s$, I - 1)
If InStrRev(VarName$, "." + s$ + " ") < 1 Then Exit Function
s$ = Mid$(VarName$, InStrRev(VarName$, Chr$(1), InStrRev(VarName$, "." + s$ + " ")) + 1)
result$ = GetStrUntil(" ", s$)
StripRVAL2 = True
If Not VarTypeName(var(val(s$))) = mGroup Then StripRVAL2 = False: s$ = bb$: result$ = vbNullString
Else
result$ = GetStrUntil("╚", s$)
End If

End Function
Function StripRVAL(ByVal s$) As String
Dim I
I = InStrRev(s$, "╚")
If I = 0 Then
' do not delete this.....
    StripRVAL = s$
ElseIf I = 1 Then
Else
    StripRVAL = Left$(s$, I - 1)
End If
End Function
Function iRVAL(ByVal s$, v As Long) As Long
If InStr(s$, "╚") = 0 Then
iRVAL = v
Else
DropLeft "╚", s$
iRVAL = val(s$) + v
End If
End Function

Function GetSubFullName(nm$, fullname$) As Boolean
If Len(here$) > 0 Then
    If Len(here$) > Len(nm$) Then
        If Mid$(here$, Len(here$) - Len(nm$)) = "." + nm$ Then
            GetSubFullName = subHash.ExistKey(nm$)
          fullname = nm$: Exit Function
        End If
    End If
End If

If here$ <> "" Then
     GetSubFullName = subHash.ExistKey(here$ + "." + nm$)
  If GetSubFullName Then fullname$ = here$ + "." + nm$: Exit Function
End If

    GetSubFullName = subHash.ExistKey(nm$)
 If GetSubFullName Then fullname$ = nm$





End Function



Function GetSub2(bstack As basetask, nm$, I&) As Boolean
I& = 0
If Len(here$) > 0 Then
    If Len(here$) > Len(nm$) Then
        If Mid$(here$, Len(here$) - Len(nm$)) = "." + nm$ Then
               '
                I& = bstack.OriginalCode
                If bstack.IamLambda Then
                    GetSub2 = subHash.Find(bstack.FuncRec, I&)
                    If GetSub2 Then nm$ = bstack.FuncRec
                Else
                     nm$ = sbf(I&).goodname

                    GetSub2 = True
                End If
        End If
   ElseIf Right$(here$, 1) = "╩" Then
   GetSub2 = subHash.Find(here$ + "." + nm$, I&)
    End If
End If

If I& = 0 And here$ <> "" Then
     GetSub2 = subHash.Find(here$ + "." + nm$, I&)
ElseIf I& <> 0 Then
    Exit Function
End If
If I& = 0 Then
    GetSub2 = subHash.Find(nm$, I&)
Else
    Exit Function
End If
If I& = 0 Then
   
Else
    Exit Function
End If

End Function

Function GetSub(nm$, I&) As Boolean
I& = 0
If Len(here$) > 0 Then
    If Len(here$) > Len(nm$) Then
        If Mid$(here$, Len(here$) - Len(nm$)) = "." + nm$ Then
               
            GetSub = subHash.Find(StripRVAL(here$) + "." + nm$, I&)
            
        End If
   ElseIf Right$(here$, 1) = "╩" Then
   GetSub = subHash.Find(here$ + "." + nm$, I&)
    End If
End If
If GetSub Then Exit Function
If I& = 0 And here$ <> "" Then
     GetSub = subHash.Find(here$ + "." + nm$, I&)
ElseIf I& <> 0 Then
    Exit Function
End If
If I& = 0 Then
    GetSub = subHash.Find(nm$, I&)
       
End If

End Function

Function GetlocalSub(nm$, I&) As Boolean

If subHash.Find(here$ + "." + nm$, I&) Then GetlocalSub = True

End Function
Function GetGlobalSubAfterHere(basestack As basetask, nm$, I&) As Boolean

If basestack.IamAnEvent Or basestack.IamLambda Or basestack.IamAnEvent Then
    GetGlobalSubAfterHere = subHash.Find(nm$, I&)
    Exit Function
ElseIf subHash.Find(nm$, I&) Then
GetGlobalSubAfterHere = Not basestack.IamChild
End If

End Function

Function GetlocalSubExtra(nm$, I&) As Boolean
Dim n$
Dim subname$
subname$ = subHash.Show
n$ = "." + nm$ + " "
I& = InStr(subname$, n$)
If I& > 0 Then

GetlocalSubExtra = True
I& = val(Mid$(subname$, I& + Len(n$)))
Else
GetlocalSubExtra = False
End If
End Function
Function PosLabel(ByVal W$, b$, Optional ByVal lim As Long = 0) As Long
Dim I As Long, j As Long, jmp As Boolean
On Error Resume Next
If val(Left$(W$, 1)) = 0 Then W$ = W$ + ":": jmp = True
If lim = 0 Then lim = Len(b$)
PosLabel = lim + 1
If Left$(b$, Len(W$)) = W$ Then
    If Not jmp Then If Mid$(b$, Len(W$) + 1, 1) Like "[0-9]" Then GoTo conthere
    I = 1
    PosLabel = 1: Exit Function
Else
conthere:
Dim w1$
w1$ = Chr(10) + W$
Do
I = InStr(I + 1, b$, w1$)
If I > 0 Then
    If jmp Then Exit Do
    If Not Mid$(b$, I + Len(W$) + 1, 1) Like "[0-9]" Then Exit Do
    I = I + Len(W$)
Else
    Exit Do
End If
Loop
If I = 0 Then
Dim w2$
w1$ = " " + W$
w2$ = "0" + W$
Dim w3$
w3$ = ChrW(9) + W$
j = I
    Do
again00:
    I = InStr(j + 1, b$, w3$)
    If I > lim Then Exit Function
    If I = 0 Then
    I = j
    j = InStr(I + 1, b$, w1$)
    If j > lim Then Exit Function
     If j = 0 Then I = 0: Exit Do
    I = j
    End If
    
    If I < 2 Then Exit Do
    j = MyTrimRfrom(b$, 1, I + 1)

    
    
    If j < 2 Then Exit Do
    If Mid$(b$, j - 1, 1) = Chr(10) Then
    If Not jmp Then
    If Not Mid$(b$, I + Len(W$) + 1, 1) Like "[0-9]" Then Exit Do
    Else
    Exit Do
    End If
    End If
    j = j + Len(W$)
    
    Loop
    If I = 0 Then
    j = 0
    Do
    
shiftone:
    I = InStr(j + 1, b$, w2$)
    If I > lim Then Exit Function
    If I = 0 Then Exit Do
    If Mid$(b$, I + Len(w2$), 1) Like "[0-9]" Then j = j + 1: GoTo shiftone
    If I <= 1 Then Exit Do
    j = I - 1
    
    While j > 1 And Mid$(b$, j, 1) = "0"
            j = j - 1
    Wend
    If j < 2 Then Exit Do
    If Mid$(b$, j, 1) = Chr(10) Then Exit Do
    j = MyTrimRfrom(b$, 1, j) - 1
   
    If Mid$(b$, j, 1) = Chr(10) Then Exit Do
    j = I + Len(w2$)
    Loop
    End If
End If


End If
If jmp Then

If I > 0 Then
While Mid$(b$, MyTrimLi(b$, I + Len(W$) + 1), 1) Like thislabel$ And I > 0
    I = InStr(I + Len(W$) + 1, b$, Chr(10) + W$)
Wend
If I > lim Then Exit Function
If I > 0 Then PosLabel = I + 1

End If

Else
If I > lim Then Exit Function
If I > 1 Then PosLabel = I + 1
End If
End Function


Function logical(basestack As basetask, s$, D As Variant, Optional par As Long = 0, Optional flatobject As Boolean = False, Optional ByPass As Boolean = False, Optional sg As Integer = 1, Optional ByVal nostring As Boolean) As Boolean
Dim b$, S2$, S3$, usehandler As mHandler
Dim ah As String
again11:
If ByPass Then
'Mid$(s$, 1, 1) = Right$(basestack.tmpstr, 1)
'ah = aheadstatusFast(basestack.tmpstr)
Exit Function
Else
    ah = aheadstatusFast(s$)
End If
If InStr(ah, "l") = 0 Then
If InStr(ah, "N") > 0 Then
If Len(ah) = 1 Then
If Not IsNumber(basestack, s$, D, flatobject, sg) Then
    If lookOne(s$, "(") Then
    Dim ret As Boolean
jump1234:
    FastSymbol s$, "("
        ByPass = False
        ret = GetArr(basestack, s$, D, "", 0, ByPass)
        logical = ret
        Exit Function
    End If
    Set basestack.lastobj = Nothing
    If LastErNum1 < 0 Then Exit Function
Else
    If flatobject Then basestack.flatobject
    logical = True
End If
Else
comehere:
If Not IsNumber(basestack, s$, D, flatobject, sg) Then
    If lookOne(s$, "(") Then
    Set basestack.lastobj = Nothing
    GoTo jump1234
    End If
    Set basestack.lastobj = Nothing
    If LastErNum1 < 0 Then Exit Function
Else
    logical = True
End If
End If
Else
If par > 0 Then
cont1112:
If Not GetArr(basestack, s$, D, S2$, 0, ByPass) Then
    Set basestack.lastobj = Nothing
Else
    If Len(s$) > 0 Then
    If AscW(s$) = 8 Then
    par = par - 1
    If basestack.lastobj Is Nothing Then
        If basestack.soros.StackItemType(1) = "S" Then GoTo 123456
        GoTo comehere
    Else
        ByPass = True
        GoTo again11
    End If
   Else
    ByPass = True
   End If
    End If
    logical = True
End If

If logical Then
par = par - 1
End If
Exit Function
Else
If AscW(s$) = 8 Then
123456
If IsString(basestack, s$, b$) Then
s$ = NLtrim$(s$)
If Len(s$) > 0 Then
If InStr("<=>~", Left$(s$, 1)) > 0 Then
GoTo conthere
End If
End If

D = vbNullString
SwapString2Variant b$, D
logical = True
End If
Else
logical = False
End If
End If
End If
12345
If nostring Then If myVarType(D, vbString) Then GoTo jumpnostr1
s$ = NLtrim$(s$)
Exit Function
Else
If Left$(ah, 2) = "SN" Then Exit Function
nostring = False
End If
On Error Resume Next

If Err.Number > 0 Then Exit Function
If Left$(ah, 1) <> "N" Then
IsStrExp basestack, s$, b$, False
conthere:
logical = False
If Not mTextCompare Then
    If FastSymbol(s$, "=") Then
        logical = False
        If IsStrExp(basestack, s$, S2$, False) Then
            logical = True
            D = b$ = S2$
        Else
            MissStringExpr
        End If
        Exit Function
    ElseIf FastSymbol(s$, "<") Then
        logical = False
        If Left$(s$, 1) = "=" Then
            Mid$(s$, 1, 1) = " "
            If Left$(s$, 2) = " >" Then
                Mid$(s$, 2, 1) = " "
                If IsStrExp(basestack, s$, S2$, False) Then
                    logical = True
                    Select Case b$
                    Case Is < S2$
                        D = -1
                    Case Is = S2$
                        D = 0
                    Case Else
                        D = 1
                    End Select
                Else
                    MissStringExpr
                End If
            Else
                If IsStrExp(basestack, s$, S2$, False) Then
                    logical = True
                    D = b$ <= S2$
                Else
                    MissStringExpr
                End If
            End If
            Exit Function
        ElseIf Left$(s$, 1) = ">" Then
            Mid$(s$, 1, 1) = " "
            If IsStrExp(basestack, s$, S2$, False) Then
                logical = True
                D = b$ <> S2$
            Else
                MissStringExpr
            End If
        ElseIf IsStrExp(basestack, s$, S2$, False) Then
            logical = True
            D = b$ < S2$
        Else
            MissStringExpr
        End If
        Exit Function
    ElseIf FastSymbol(s$, ">") Then
        logical = False
        If Left$(s$, 1) = "=" Then
            Mid$(s$, 1, 1) = " "
            If IsStrExp(basestack, s$, S2$, False) Then
                logical = True
                D = b$ >= S2$
            Else
                MissStringExpr
            End If
        ElseIf IsStrExp(basestack, s$, S2$, False) Then
            logical = True
            D = b$ > S2$
        Else
            MissStringExpr
        End If
        Exit Function
    ElseIf FastSymbol(s$, "~") Then
        logical = False
        If IsStrExp(basestack, s$, S2$, False) Then
            logical = True
            D = b$ Like S2$
        Else
            MissStringExpr
        End If
        Exit Function
    ElseIf MaybeIsSymbol(s$, "+") Then
    If myVarType(D, vbString) Then
        logical = False
        Mid$(s$, 1, 1) = " "
        If IsStrExp(basestack, s$, S2$, False) Then
            logical = True
            b$ = b$ + S2$
           GoTo conthere
        ElseIf IsNumber(basestack, s$, D, True) Then
            logical = True
            
            If CheckInt64(D) Then
                   S2$ = CStr(D)
            ElseIf MemInt(VarPtr(D)) = vbBoolean Then
                S2$ = Format$(D, DefBooleanString)
            Else
                S2$ = fixthis(D)
            End If
            b$ = b$ + S2$
            
           GoTo conthere
        Else
            MissStringExpr
        End If
    End If
    ElseIf MaybeIsSymbol(s$, "-") Then
    If myVarType(D, vbEmpty) Then
        D = vbNullString
        SwapString2Variant b$, D
        logical = True
        Exit Function
       End If
    End If
Else
    If FastSymbol(s$, "=") Then
        logical = False
        If IsStrExp(basestack, s$, S2$, False) Then
            logical = True
            D = CompareStr2(b$, S2$) = 0
        Else
            MissStringExpr
        End If
        Exit Function
    ElseIf FastSymbol(s$, "<") Then
        logical = False
        If Left$(s$, 1) = "=" Then
            Mid$(s$, 1, 1) = " "
            If Left$(s$, 2) = " >" Then
                Mid$(s$, 2, 1) = " "
                If IsStrExp(basestack, s$, S2$, False) Then
                    logical = True
                    D = CompareStr2(b$, S2$)
                Else
                    MissStringExpr
                End If
            ElseIf IsStrExp(basestack, s$, S2$, False) Then
                logical = True
                D = CompareStr2(b$, S2$) < 1
            Else
                MissStringExpr
            End If
        ElseIf Left$(s$, 1) = ">" Then
            Mid$(s$, 1, 1) = " "
            If IsStrExp(basestack, s$, S2$, False) Then
                logical = True
                D = CompareStr2(b$, S2$) <> 0
            Else
                MissStringExpr
            End If
        ElseIf IsStrExp(basestack, s$, S2$, False) Then
            logical = True
            D = CompareStr2(b$, S2$) = -1
        Else
            MissStringExpr
        End If
        Exit Function
        ElseIf FastSymbol(s$, ">") Then
            logical = False
            If Left$(s$, 1) = "=" Then
                Mid$(s$, 1, 1) = " "
                If IsStrExp(basestack, s$, S2$, False) Then
                    logical = True
                    D = CompareStr2(b$, S2$) > -1
                Else
                    MissStringExpr
                End If
            ElseIf IsStrExp(basestack, s$, S2$, False) Then
                logical = True
                D = CompareStr2(b$, S2$) = 1
            Else
                MissStringExpr
            End If
            Exit Function
        ElseIf FastSymbol(s$, "~") Then
            logical = False
            If IsStrExp(basestack, s$, S2$, False) Then
                logical = True
                D = b$ Like S2$
            Else
                MissStringExpr
            End If
            Exit Function
        ElseIf MaybeIsSymbol(s$, "+") Then
            If myVarType(D, vbString) Then
                logical = False
                Mid$(s$, 1, 1) = " "
                If IsStrExp(basestack, s$, S2$, False) Then
                    logical = True
                    b$ = b$ + S2$
                   GoTo conthere
                End If
            End If
        ElseIf MaybeIsSymbol(s$, "-") Then
            If myVarType(D, vbEmpty) Then
                D = vbNullString
                SwapString2Variant b$, D
                logical = True
                Exit Function
               End If
            End If
        End If
    If LastErNum = -2 Then
    logical = True
    Else
    GoTo cont145
    End If
    Exit Function
Else
cont145:
If par = -1 Then
    If FastSymbol(s$, "(") Then
    par = 1
    GoTo cont1112
End If
par = 0
End If
If IsNumber(basestack, s$, D, flatobject, sg) Then
If myVarType(D, vbString) Then
If nostring Then
jumpnostr1:
        MyEr "no string allowed", "ДЕМ ЕПИТЯщПЕТАИ АКЖАЯИХЛГТИЙЭ"
        logical = False
        Exit Function

End If
SwapString2Variant b$, D
GoTo conthere
ElseIf Not basestack.lastobj Is Nothing Then
If TypeOf basestack.lastobj Is mHandler Then
Set usehandler = basestack.lastobj
If usehandler.T1 = 4 Then
If myVarType(usehandler.index_cursor, vbString) Then
    If nostring Then GoTo jumpnostr1
    b$ = usehandler.index_cursor
    Set basestack.lastobj = Nothing
    GoTo conthere
End If
End If
End If
End If
'If SG < 0 Then D = -D
logical = True
End If
End If

End Function

Function logicalSelect(basestack As basetask, s$, D As Variant, Optional par As Long = 0, Optional flatobject As Boolean = False, Optional ByPass As Boolean = False, Optional sg As Integer = 1, Optional ByVal nostring As Boolean) As Boolean
Dim b$, S2$, S3$, usehandler As mHandler, getcom As Boolean
Dim ah As String, I As Long

For I = 1 To Len(s$)
    If InStr("><=", Mid$(s$, I)) = 0 Then Exit For
Next I
If MemInt(VarPtr(D)) = vbString Then
    SwapString2Variant b$, D
    D = Empty
    GoTo conthere
End If
again11:
If ByPass Then
    ah = aheadstatusFast(basestack.tmpstr)
Else
    ah = aheadstatusFast(s$)
End If
If InStr(ah, "l") = 0 Then
    If InStr(ah, "N") > 0 Then
        If Len(ah) = 1 Then
            If Not IsNumber(basestack, s$, D, flatobject, sg) Then
                Set basestack.lastobj = Nothing
                If LastErNum1 < 0 Then Exit Function
            Else
                If flatobject Then
                    Set basestack.lastobj = Nothing
                End If
                logicalSelect = True
            End If
        Else
            If Not IsNumber(basestack, s$, D, flatobject, sg) Then
                Set basestack.lastobj = Nothing
                If LastErNum1 < 0 Then Exit Function
            Else
                logicalSelect = True
            End If
        End If
    Else
        If par > 0 Then
            If Not GetArr(basestack, s$, D, S2$, 0, getcom) Then
                Set basestack.lastobj = Nothing
            Else
                If Len(s$) > 0 Then
                    If AscW(s$) = 8 Then
                        par = par - 1
                        ' what ????
                        ByPass = True
                        GoTo again11
                    End If
                End If
                logicalSelect = True
            End If
            If logicalSelect Then
                par = par - 1
            End If
            Exit Function
        Else
            logicalSelect = False
        End If
    End If
    If nostring Then If myVarType(D, vbString) Then GoTo jumpnostr1
    s$ = NLtrim$(s$)
    Exit Function
Else
    If Left$(ah, 2) = "SN" Then Exit Function
    nostring = False
End If

On Error Resume Next

If Err.Number > 0 Then Exit Function
If Left$(ah, 1) <> "N" Then
    IsStrExp basestack, s$, b$, False
conthere:
    logicalSelect = False
    If Not mTextCompare Then
        If FastSymbol(s$, "=") Then
            logicalSelect = False
            If IsStrExp(basestack, s$, S2$, False) Then
                logicalSelect = True
                D = b$ = S2$
            Else
                MissStringExpr
            End If
            Exit Function
        ElseIf FastSymbol(s$, "<") Then
            logicalSelect = False
            If Left$(s$, 1) = "=" Then
                Mid$(s$, 1, 1) = " "
                If Left$(s$, 2) = " >" Then
                    Mid$(s$, 2, 1) = " "
                    If IsStrExp(basestack, s$, S2$, False) Then
                        logicalSelect = True
                        Select Case b$
                        Case Is < S2$
                            D = -1
                        Case Is = S2$
                            D = 0
                        Case Else
                            D = 1
                        End Select
                    Else
                        MissStringExpr
                    End If
                Else
                    If IsStrExp(basestack, s$, S2$, False) Then
                        logicalSelect = True
                        D = b$ <= S2$
                    Else
                        MissStringExpr
                    End If
                End If
                Exit Function
            ElseIf Left$(s$, 1) = ">" Then
                Mid$(s$, 1, 1) = " "
                If IsStrExp(basestack, s$, S2$, False) Then
                    logicalSelect = True
                    D = b$ <> S2$
                Else
                    MissStringExpr
                End If
            ElseIf IsStrExp(basestack, s$, S2$, False) Then
                logicalSelect = True
                D = b$ < S2$
            Else
                MissStringExpr
            End If
            Exit Function
        ElseIf FastSymbol(s$, ">") Then
            logicalSelect = False
            If Left$(s$, 1) = "=" Then
                Mid$(s$, 1, 1) = " "
                If IsStrExp(basestack, s$, S2$, False) Then
                    logicalSelect = True
                    D = b$ >= S2$
                Else
                    MissStringExpr
                End If
            ElseIf IsStrExp(basestack, s$, S2$, False) Then
                logicalSelect = True
                D = b$ > S2$
            Else
                MissStringExpr
            End If
            Exit Function
        ElseIf FastSymbol(s$, "~") Then
            logicalSelect = False
            If IsStrExp(basestack, s$, S2$, False) Then
                logicalSelect = True
                D = b$ Like S2$
            Else
                MissStringExpr
            End If
            Exit Function
        ElseIf MaybeIsSymbol(s$, "+") Then
        If myVarType(D, vbString) Then
            logicalSelect = False
            Mid$(s$, 1, 1) = " "
            If IsStrExp(basestack, s$, S2$, False) Then
                logicalSelect = True
                b$ = b$ + S2$
               GoTo conthere
            ElseIf IsNumber(basestack, s$, D, True) Then
                logicalSelect = True
                
                If CheckInt64(D) Then
                       S2$ = CStr(D)
                ElseIf MemInt(VarPtr(D)) = vbBoolean Then
                    S2$ = Format$(D, DefBooleanString)
                Else
                    S2$ = fixthis(D)
                End If
                b$ = b$ + S2$

               GoTo conthere
            Else
                MissStringExpr
            End If
        End If
        ElseIf MaybeIsSymbol(s$, "-") Then
        If myVarType(D, vbEmpty) Then
            D = vbNullString
            SwapString2Variant b$, D
            logicalSelect = True
            Exit Function
           End If
        End If
    Else
        If FastSymbol(s$, "=") Then
            logicalSelect = False
            If IsStrExp(basestack, s$, S2$, False) Then
                logicalSelect = True
                D = CompareStr2(b$, S2$) = 0
            Else
                MissStringExpr
            End If
            Exit Function
        ElseIf FastSymbol(s$, "<") Then
            logicalSelect = False
            If Left$(s$, 1) = "=" Then
                Mid$(s$, 1, 1) = " "
                If Left$(s$, 2) = " >" Then
                    Mid$(s$, 2, 1) = " "
                    If IsStrExp(basestack, s$, S2$, False) Then
                        logicalSelect = True
                        D = CompareStr2(b$, S2$)
                    Else
                        MissStringExpr
                    End If
                ElseIf IsStrExp(basestack, s$, S2$, False) Then
                    logicalSelect = True
                    D = CompareStr2(b$, S2$) < 1
                Else
                    MissStringExpr
                End If
            ElseIf Left$(s$, 1) = ">" Then
                Mid$(s$, 1, 1) = " "
                If IsStrExp(basestack, s$, S2$, False) Then
                    logicalSelect = True
                    D = CompareStr2(b$, S2$) <> 0
                Else
                    MissStringExpr
                End If
            ElseIf IsStrExp(basestack, s$, S2$, False) Then
                logicalSelect = True
                D = CompareStr2(b$, S2$) = -1
            Else
                MissStringExpr
            End If
            Exit Function
            ElseIf FastSymbol(s$, ">") Then
                logicalSelect = False
                If Left$(s$, 1) = "=" Then
                    Mid$(s$, 1, 1) = " "
                    If IsStrExp(basestack, s$, S2$, False) Then
                        logicalSelect = True
                        D = CompareStr2(b$, S2$) > -1
                    Else
                        MissStringExpr
                    End If
                ElseIf IsStrExp(basestack, s$, S2$, False) Then
                    logicalSelect = True
                    D = CompareStr2(b$, S2$) = 1
                Else
                    MissStringExpr
                End If
                Exit Function
            ElseIf FastSymbol(s$, "~") Then
                logicalSelect = False
                If IsStrExp(basestack, s$, S2$, False) Then
                    logicalSelect = True
                    D = b$ Like S2$
                Else
                    MissStringExpr
                End If
                Exit Function
            ElseIf MaybeIsSymbol(s$, "+") Then
                If myVarType(D, vbString) Then
                    logicalSelect = False
                    Mid$(s$, 1, 1) = " "
                    If IsStrExp(basestack, s$, S2$, False) Then
                        logicalSelect = True
                        b$ = b$ + S2$
                       GoTo conthere
                    End If
                End If
            ElseIf MaybeIsSymbol(s$, "-") Then
                If myVarType(D, vbEmpty) Then
                    D = vbNullString
                    SwapString2Variant b$, D
                    logicalSelect = True
                    Exit Function
                   End If
                End If
            End If
        If LastErNum = -2 Then
        logicalSelect = True
        Else
        GoTo cont145
        End If
        Exit Function
Else
cont145:
If IsNumber(basestack, s$, D, flatobject, sg) Then
    If myVarType(D, vbString) Then
        If nostring Then
jumpnostr1:
        MyEr "no string allowed", "ДЕМ ЕПИТЯщПЕТАИ АКЖАЯИХЛГТИЙЭ"
        logicalSelect = False
        Exit Function
End If
    SwapString2Variant b$, D
    GoTo conthere
ElseIf Not basestack.lastobj Is Nothing Then
    If TypeOf basestack.lastobj Is mHandler Then
    Set usehandler = basestack.lastobj
    If usehandler.T1 = 4 Then
    If myVarType(usehandler.index_cursor, vbString) Then
        If nostring Then GoTo jumpnostr1
        b$ = usehandler.index_cursor
        Set basestack.lastobj = Nothing
        GoTo conthere
    End If
End If
End If
End If
'If SG < 0 Then D = -D
logicalSelect = True
End If
End If

End Function

Function BlockParam(s$) As String
' need to be open
Dim I As Long, j As Long
j = 1
For I = 1 To Len(s$)
Select Case AscW(Mid$(s$, I, 1))
Case 0
Exit For
Case 34
I = InStr(I + 1, s$, Chr(34))
If I = 0 Then Exit Function
Case 40
j = j + 1
Case 41
j = j - 1
If j = 0 Then Exit For
Case 123
I = InStr(I + 1, s$, Chr$(125))
If I = 0 Then Exit Function
End Select
Next I
If j = 0 Then
BlockParam = Left$(s$, I - 1)
End If
End Function
Function BlockParamSq(s$) As String
' need to be open
Dim I As Long, j As Long, K As Long
K = 1
For I = 1 To Len(s$)
Select Case AscW(Mid$(s$, I, 1))
Case 91
K = K + 1
Case 93
K = K - 1
If j = 0 And K = 0 Then
    BlockParamSq = Left$(s$, I - 1)
    Exit For
End If
Case 0, 13, 10
Exit For
Case 34
I = InStr(I + 1, s$, Chr(34))
If I = 0 Then Exit Function
Case 40
j = j + 1
Case 41
j = j - 1
If j < 0 Then Exit For
Case 123
I = InStr(I + 1, s$, Chr$(125))
If I = 0 Then Exit Function
End Select
Next I
End Function
Function block(s$) As String
Dim I As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
If Trim$(s$) = vbNullString Then Exit Function
c = Len(s$)
a1 = True
I = 1
Do
Select Case AscW(Mid$(s$, I, 1))
Case 32
' nothing
Case 34
Do While I < c
I = I + 1
If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
Loop

Case 47
If Mid$(s$, I + 1, 1) = "/" Then I = I + 1: GoTo a1111
Case 39, 92
a1111:
Do While I < c
I = I + 1
If Mid$(s$, I, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123


If jump Then
jump = False
' we have a multiline text
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, I, 1))
    Case 34
    Do While I < c
    I = I + 1
    If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
    If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    I = I + 1
    Loop Until I > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
I = I + 1
Loop Until I > c
If j = 1 Then
block = Left$(s$, I - 1)

s$ = Mid$(s$, I)
Else
block = vbNullString
End If



End Function
Function blockLen(s$) As Long
Dim I As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
If Trim$(s$) = vbNullString Then Exit Function
c = Len(s$)
a1 = True
I = 1
Do
Select Case AscW(Mid$(s$, I, 1))
Case 32
' nothing
Case 34
Do While I < c
I = I + 1
If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
Loop
Case 47
If Mid$(s$, I + 1, 1) = "/" Then I = I + 1: GoTo a1111
Case 39, 92
a1111:
Do While I < c
I = I + 1
If Mid$(s$, I, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123


If jump Then
jump = False
' we have a multiline text
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, I, 1))
    Case 34
    Do While I < c
    I = I + 1
    If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
    If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    I = I + 1
    Loop Until I > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
I = I + 1
Loop Until I > c
If j = 1 Then
blockLen = I
Else
blockLen = 0
End If



End Function

Function blockLen2(s$, Pos) As Long
Dim I As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
If Trim$(s$) = vbNullString Then Exit Function
c = Len(s$)
a1 = True
I = Pos
Do
Select Case AscW(Mid$(s$, I, 1))
Case 32
' nothing
Case 34
Do While I < c
I = I + 1
If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
Loop
Case 47
If Mid$(s$, I + 1, 1) = "/" Then I = I + 1: GoTo a1111
Case 39, 92
a1111:
Do While I < c
I = I + 1
If Mid$(s$, I, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123
If jump Then
jump = False
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, I, 1))
    Case 34
    Do While I < c
    I = I + 1
    If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
    If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    I = I + 1
    Loop Until I > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
I = I + 1
Loop Until I > c
If j = 1 Then
blockLen2 = I
Else
blockLen2 = 0
End If



End Function
Function BlockParam2OLD(s$, Pos As Long) As Boolean
' need to be open
Dim I As Long, j As Long, j1 As Long, ii As Long
j = 1
For I = Pos To Len(s$)
Select Case AscW(Mid$(s$, I, 1))
Case 0
Exit For
Case 34
again:
ii = InStr(I + 1, s$, """")
If ii = 0 Then Exit Function
 I = ii
'If Mid$(s$, ii - 1, 1) = "`" Then GoTo again
Case 91
j1 = j1 + 1
Case 93
j1 = j1 - 1
'If j1 = 0 Then Exit For
Case 40
j = j + 1
Case 41
j = j - 1
If j = 0 Then Exit For
Case 123
I = I + 1
If blockStringPOS(s$, I) Then
Else
I = 0
End If
If I = 0 Then Exit Function
End Select
Next I
If j = 0 And j1 = 0 Then Pos = I: BlockParam2OLD = True
End Function
Function BlockParam2p(s$, Pos As Long) As Boolean
' need to be open
Dim I As Long, ii As Long, j As Long, j1 As Long
j = 1
For I = Pos To Len(s$)
Select Case AscW(Mid$(s$, I, 1))
Case 0
Exit For
Case 34
again:
ii = InStr(I + 1, s$, """")
If ii = 0 Then Exit Function
 I = ii
'If Mid$(s$, ii - 1, 1) = "`" Then GoTo again
Case 91
j1 = j1 + 1
Case 93
j1 = j1 - 1
If j1 < 0 Then Exit For
Case 40
j = j + 1
Case 41
j = j - 1
If j = 0 Then Exit For
Case 123
I = I + 1
If blockStringPOS(s$, I) Then
Else
I = 0
End If
If I = 0 Then Exit Function
End Select
Next I
If j = 0 And j1 = 0 Then Pos = I: BlockParam2p = True
End Function
Function BlockParam2s(s$, Pos As Long) As Boolean
' need to be open
Dim I As Long, ii As Long, j As Long, j1 As Long, exit1 As Boolean
j1 = 1
For I = Pos To Len(s$)
Select Case AscW(Mid$(s$, I, 1))
Case 0
Exit For
Case 34
again:
ii = InStr(I + 1, s$, """")
If ii = 0 Then Exit Function
 I = ii
'If Mid$(s$, ii - 1, 1) = "`" Then GoTo again
Case 91
j1 = j1 + 1
Case 93
j1 = j1 - 1
If j1 <= 0 Then Exit For
Case 40
j = j + 1
Case 41
j = j - 1
If j < 0 Then Exit For
Case 123
I = I + 1
If blockStringPOS(s$, I) Then
Else
I = 0
End If
If I = 0 Then Exit Function
End Select
Next I
If j = 0 And j1 = 0 Then Pos = I: BlockParam2s = True
End Function
Function blockStringPOS(s$, Pos As Long) As Boolean
Dim I As Long, j As Long, c As Long
Dim a1 As Boolean
c = Len(s$)
a1 = True
I = Pos
If I > Len(s$) Then Exit Function
Do
Select Case AscW(Mid$(s$, I, 1))
Case 34
Do While I < c
I = I + 1
If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
Loop
Case 123
j = j - 1
Case 125
j = j + 1: If j = 1 Then Exit Do
End Select
I = I + 1
Loop Until I > c
If j = 1 Then
blockStringPOS = True
Pos = I
Else
Pos = Len(s$)
End If

End Function
Function block2(s$) As String
Dim I As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
Dim alter As Boolean
If Trim$(s$) = vbNullString Then Exit Function

c = Len(s$)
a1 = True
I = 1
Do
Select Case AscW(Mid$(s$, I, 1))
Case 32
' nothing
Case 34
Do While I < c
I = I + 1
If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
Loop
Case 47
If Mid$(s$, I + 1, 1) = "/" Then I = I + 1: GoTo a1111
Case 39, 92
a1111:
Do While I < c
I = I + 1
If Mid$(s$, I, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123


If jump Then
jump = False
' we have a multiline text
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, I, 1))
    Case 34
    Do While I < c
    I = I + 1
    If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
    If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    I = I + 1
    Loop Until I > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
I = I + 1
Loop Until I > c
If j = 1 Then
block2 = Left$(s$, I - 1)
s$ = Mid$(s$, I)
'DoEvents
Else
block2 = vbNullString
End If



End Function
Function blockString(s$, endstr As Long, Optional I As Long = 1) As String
' endstr 34 or 125
Dim j As Long, c As Long, start As Long
start = I
Dim a1 As Boolean
c = Len(s$)
If I > c Then Exit Function
If c < 1 Then Exit Function
a1 = True
Do
Select Case AscW(Mid$(s$, I, 1))
Case 13
If endstr = 34 Then blockString = vbNullString: Exit Function
Case 34
If endstr = 34 Then
If I = 1 Then I = 2
j = 1: Exit Do
Else
Do While I < c
I = I + 1
If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
Loop
End If

Case 123
j = j - 1
Case 125
j = j + 1: If j = 1 And endstr = 125 Then Exit Do
End Select
I = I + 1
Loop Until I > c
If j = 1 Then
blockString = Mid$(s$, start, I - start)
s$ = Mid$(s$, I)
Else
s$ = Mid$(s$, I)
blockString = "Error " + Chr(34) + "missing " + Chr$(endstr) + Chr(34)
End If
If endstr = 125 Then
If Right$(blockString, 1) = " " Then
I = Len(blockString) - MyTrimRStr(blockString)
If I > 0 Then blockString = Replace$(blockString, Chr$(10) + space(I), Chr$(10))
ElseIf MyTrimRStr(Right$(blockString, 1)) = 1 Then
I = Len(blockString) - MyTrimRNoCr(blockString)
If I > 0 Then blockString = Replace$(blockString, Chr$(10) + Right$(blockString, I), Chr$(10))

End If
End If

End Function
Public Function MyTrimRStr(s$) As Long
Dim I&, L As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s): If L = 0 Then MyTrimRStr = 1: Exit Function
  P2 = StrPtr(s): L = L - 1
  p4 = P2 + L * 2
  For I = p4 To P2 Step -2
  GetMem2 I, P1
  Select Case P1
    Case 32
    Case Else
     MyTrimRStr = (I - P2) \ 2 + 1
   Exit Function
  End Select
  Next I
 MyTrimRStr = L + 2
End Function
Public Function MyTrimRNoCr(s$) As Long
Dim I&, L As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s): If L = 0 Then MyTrimRNoCr = 1: Exit Function
  P2 = StrPtr(s): L = L - 1
  p4 = P2 + L * 2
  For I = p4 To P2 Step -2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 9
    Case Else
     MyTrimRNoCr = (I - P2) \ 2 + 1
   Exit Function
  End Select
  Next I
 MyTrimRNoCr = L + 2
End Function
Sub SetNextLine(c$)
Dim I
I = InStr(c$, vbCrLf)
If I = 0 Then c$ = vbNullString Else c$ = Mid$(c$, I + 2)
End Sub
Function SetNextLineCLR(c$) As Long
SetNextLineCLR = InStr(c$, vbCrLf)
If SetNextLineCLR > 0 Then Mid$(c$, 1, SetNextLineCLR + 1) = space(SetNextLineCLR + 1): SetNextLineCLR = SetNextLineCLR + 1
End Function
Function CopyUntilEndOfLine(A$) As String
Dim I As Long
I = InStr(A$, vbCrLf)
If I = 0 Then CopyUntilEndOfLine = A$ Else CopyUntilEndOfLine = Left$(A$, I - 1)
End Function
Sub SetNextLineNL(c$)
Dim I
I = InStr(c$, vbCrLf)
If I = 0 Then c$ = vbNullString Else c$ = Mid$(c$, I)
End Sub
Function GetNextLine(c$) As String
Dim I, j$
I = InStr(c$, vbCrLf)
If I = 0 Then GetNextLine = NLtrim$(c$): c$ = vbNullString Else GetNextLine$ = NLtrim$(Left$(c$, I - 1)): c$ = Mid$(c$, I)
End Function
Sub NoLines(c$)
Dim I
c$ = Trim$(c$)
Do While Left$(c$, 2) = vbCrLf
c$ = Trim$(Mid$(c$, 3))
Loop
End Sub

Sub RTarget(DDD As Object, tar As target)
' RENDER TARGET
Dim xl&, yl&, b As Long, f As Long, Tag$, id&
Dim X&, Y&, ox&, oy&
Dim prive As basket, D As Object
Dim C2&, V1&, V2&, vert&, mem As MemBlock
Dim zoom As Single
Set D = DDD.Owner
prive = players(GetCode(D))
With tar
id& = .id
Tag$ = .Tag
X& = .lX
Y& = .lY
xl& = .tx + 1
yl& = .ty
b = .back
f = .fore
C2& = .barC
V1& = .topval
V2& = .botval
vert& = .Vertical
prive.mypen = .pen
zoom = .imagesize / 100
Dim half As Long
half = 1 - (.ty - .lY + 1) Mod 2
Dim dd As Object
If .layer = 0 Then
Set dd = Form1.DIS
ElseIf .layer = -1 Then
Set dd = Form1
ElseIf .layer > 0 And .layer < 33 Then
Set dd = Form1.dSprite(.layer)
Else
Set dd = D
End If

prive.Xt = .Xt
prive.Yt = .Yt
prive.uMineLineSpace = .sUAddTwipsTop
prive.mX = 100
prive.mY = 100
prive.SZ = .SZ
Set mem = .drawimage
End With
dd.FontSize = prive.SZ
LCTbasket dd, prive, Y&, X&

If f <> &H81000000 Then BoxBigNew dd, prive, xl& - 1, yl&, f
If b <> &H81000000 Then BoxColorNew dd, prive, xl& - 1, yl&, b
If Not mem Is Nothing Then
If mem.SubType > 0 Then
Dim upleft As Long, Up As Long, downright As Long, down As Long
Dim fx&, fy&

If zoom < 0 Then
        If C2& <> &H81000000 Then
            If vert& = 0 Then
                BoxColorNewBarHor D, prive, xl& - 1, yl&, C2&, V2&, V1&
            Else
                BoxColorNewBarVer D, prive, xl& - 1, yl&, C2&, V2&, V1&
            End If
        End If
        C2& = &H81000000
        zoom = -zoom
End If
upleft = (prive.curpos * prive.Xt) \ dv15
downright = (xl& * prive.Xt) \ dv15
Up = (prive.currow * prive.Yt) \ dv15
down = ((yl& + 1) * prive.Yt) \ dv15

fx& = (xl& - prive.curpos) * prive.Xt \ dv15
fy& = (yl& - prive.currow + 1) * prive.Yt \ dv15

   If zoom = 0 Then
    ' expand to target width
    mem.DrawImageToHdc dd, upleft, Up, fx&, fy&
    Else

Select Case id Mod 10
Case 4, 1, 7
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, down - fx& * zoom, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, downright - fy& * zoom - (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 6, 3, 9
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, Up + (fx& - fx& * zoom) \ 2, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 8
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, Up + prive.uMineLineSpace \ dv15, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fx& - fy&) \ 2 + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 5
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, Up + (fy& - fx&) \ 2 + (fx& - fx& * zoom) \ 2, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fx& - fy&) \ 2 + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 2
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, down - fx& * zoom - prive.uMineLineSpace \ dv15, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fx& - fy&) \ 2 + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
End Select
End If
End If
End If
If C2& <> &H81000000 Then
    If vert& = 0 Then
        BoxColorNewBarHor D, prive, xl& - 1, yl&, C2&, V2&, V1&
    Else
        BoxColorNewBarVer D, prive, xl& - 1, yl&, C2&, V2&, V1&
    End If
End If
If id& < 100 Then
    half = 0
    Tag$ = Left$(Tag$, xl& - X&)
    If Tag$ <> "" Then
    '1
    Select Case id& Mod 10
    Case 4, 5, 6
    Y& = (yl& + Y&) \ 2
    Case 7, 8, 9
    Y& = yl&
    Case Else
    End Select
    
    Select Case id& Mod 10
    Case 2, 5, 8
   
    X& = (xl& + X& - Len(Tag$)) \ 2
    Case 3, 6, 9
    X& = xl& - Len(Tag$)
    
    Case Else
    End Select
    If (id& Mod 10) > 0 Then
    LCTbasket dd, prive, Y&, X&
    dd.FontTransparent = True
    dd.ForeColor = mycolor(prive.mypen)
       PlainBaSket dd, prive, Tag$, True, True
    End If
    End If
Else
        If Tag$ <> "" Then
    id& = id& Mod 100
    Select Case id& Mod 10
    Case 4, 5, 6
    Y& = (yl& + Y&) \ 2
    Case 7, 8, 9
    half = 0
    Y& = yl&
    Case Else
    half = 0
    End Select
    f = 3
    Select Case id& Mod 10
    Case 2, 5, 8
    f = 2
    Case 3, 6, 9
    f = 1
    Case Else
    End Select
    
    If (id& Mod 10) > 0 Then
    LCTbasket dd, prive, Y&, X&
    dd.FontTransparent = True
    dd.currentX = dd.currentX - dv15 * 2
    If half = 1 Then
    dd.currentY = dd.currentY + prive.Yt \ 2 '+ mybasket.uMineLineSpace \ 2
    End If
    dd.ForeColor = mycolor(prive.mypen)
    
    If Not D Is dd Then
    Set DDD.Owner = dd
    wwPlain2 DDD, prive, Tag$, xl& - X&, 10000, , True, f, , , True
    Set DDD.Owner = D
    Else
    wwPlain2 DDD, prive, Tag$, xl& - X&, 10000, , True, f, , , True
    End If
    End If
End If
    

End If
PlaceBasket dd, players(GetCode(dd))
End Sub

Public Sub DropLeft(ByVal uStr As String, fromstr As String)
Dim I As Long
I = InStr(fromstr, uStr)
If I > 0 Then
fromstr = Mid$(fromstr, I + Len(uStr))
Else
fromstr = vbNullString
End If
End Sub
Public Function GetStrUntil(ByVal sStr As String, fromstr As String, Optional RemoveSstr As Boolean = True) As String
Dim I As Long

If fromstr = vbNullString Then GetStrUntil = vbNullString: Exit Function
I = InStr(fromstr, sStr)
If I < 2 Then
GetStrUntil = vbNullString
fromstr = vbNullString
Else
GetStrUntil = Left$(fromstr, I - 1)
If RemoveSstr Then
fromstr = Mid$(fromstr, Len(sStr) + I)
Else
fromstr = Mid$(fromstr, I)
End If
End If
End Function

Function NeoGetArrayItem(pp As iBoxArray, bstack As basetask, v$, Offset As Long, rst$, Optional noObject As Boolean = False, Optional closepar As Boolean = True, Optional fromstr As Boolean, Optional rightexpr As Boolean = False, Optional idx As mIndexes) As Boolean
If pp Is Nothing Then
    MyEr "Internal Error: NeoGetArrayItem", "ЕСЫТЕЯИЙЭ КэХОР: NeoGetArrayItem": Exit Function
End If
If noObject And pp.IhaveClass Then Exit Function
Dim dn As Long, dd As Long, w3 As Long, sp$, lim As Long, usehandler As mHandler, usehandler1 As mHandler
Dim p As Variant, pppp As mArray
If Len(v$) > 0 Then sp$ = ")"
again123:
dd = 0
dn = 0
If Not pp.Arr Then
    Dim ppp$
    If TypeOf pp.GroupRef Is mHandler Then
        Set usehandler = pp.GroupRef
        If usehandler.T1 <> 1 Then Expected "Inventory", "йАТэСТАСГ": Exit Function
        If TypeOf usehandler.objref Is mHandler Then
            Set usehandler1 = usehandler.objref
            Set usehandler.objref = usehandler1.objref
        End If
        If IsExp(bstack, rst$, p) Then
            With usehandler.objref
                If Not FastSymbol(rst$, "!") Then ppp$ = CStr(p): GoTo contlabel1
                p = MyRound(p)
                If Abs(p) < .count Then
                    If p < 0 Then
                        .Index = .count + Int(p)
                    Else
                        .Index = Int(p)
                    End If
                    .Index = p
                    Offset = -.Index - 100
                    .Done = True
                Else
                    MyEr "Index out of limits", "дЕъЙТГР ЕЙТЭР ОЯъЫМ"
                End If
            End With
        ElseIf IsStrExp(bstack, rst$, ppp$) Then
contlabel1:
            Set usehandler = pp.GroupRef
            With usehandler.objref
                If Not .Find(ppp$) Then
                    MyEr "Key not exist", "дЕМ УПАЯВЕИ ТО ЙКЕИДъ"
                    NeoGetArrayItem = False
                    Exit Function
                Else
                    Offset = -.Index - 100
                End If
                If Typename(.ValueObj) = mGroup Then
                    If .ValueObj.HasParametersSet Or .ValueObj.HasParameters Then
                        NeoGetArrayItem = True
                    End If
                ElseIf FastSymbol(rst, ")(", , 2) Then
                    GoTo CheckThis
                Else
                    .Done = True
                End If
            End With
        End If
    ElseIf TypeOf pp.GroupRef Is Group Then
        If Not fromstr Then
            If rightexpr Then
            ElseIf pp.GroupRef.HasParameters Then
                If Not pp.GroupRef.HasStrValue Then
                    If Len(rst$) > 0 Then
                        bstack.tmpstr = v$ + Left$(rst$, 1)
                        ppp$ = Left$(rst$, 1)
                        BackPort rst$
                        If IsNumber(bstack, rst$, p) Then
                            If Not bstack.lastpointer Is Nothing Then
                                If bstack.lastpointer.IamApointer Then
                                    Set pp.GroupRef = bstack.lastpointer
                                Else
                                    Set pp.GroupRef = bstack.lastobj
                                End If
                            ElseIf Not bstack.lastobj Is Nothing Then
                                If TypeOf pp.GroupRef Is Group Then
                                    Set pp.GroupRef = bstack.lastobj
                                End If
                            End If
                            Set bstack.lastobj = Nothing
                            Set bstack.lastpointer = Nothing
                        Else
                            If Len(rst$) > 0 Then Mid$(rst$, 1, 1) = ppp$
                        End If
                    End If
                End If
            End If
        End If
        Offset = -2
        NeoGetArrayItem = True
        Exit Function
    Else
contprop:
            Dim aProp As PropReference
            Set aProp = pp.GroupRef
            dn = 0
            If idx Is Nothing Then Set idx = New mIndexes
againprop:
            If IsExp(bstack, rst$, p) Then
                idx(dn) = p
                aProp.Index = p
            ElseIf IsStrExp(bstack, rst$, ppp$) Then
                idx(dn) = ppp$
                aProp.Index = ppp$
            Else
                idx.IndexOpt dn
                aProp.IndexOpt
            End If
            If FastSymbol(rst$, ",") Then dn = dn + 1: GoTo againprop
            Set aProp = Nothing
        End If
conthere:
        If closepar Then If Not FastSymbol(rst$, ")") Then MyEr "missing )", "КЕъПЕИ )": Exit Function
        NeoGetArrayItem = True
    Else
        Set pppp = pp
        If pppp.SerialItem((0), dd, 5) Then
            dd = dd - 1
            Offset = 0
            If dd < 0 Then If VarTypeName(pppp.GroupRef) = mProp Then GoTo contprop
            Do While dn <= dd
                pppp.GetDnum dn, w3, lim
                If IsExp(bstack, rst$, p, flatobject:=True, nostring:=True) Then
                    If dn < dd Then
                        If Not FastSymbol(rst$, ",") Then MyEr "need index for " + v$ + sp$, "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " + v$ + sp$: Exit Function
                    Else
                        If FastSymbol(rst$, ",") Then MyEr "too many indexes for array " + v$ + sp$, "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " + v$ + sp$: Exit Function
                        If Not FastSymbol(rst$, ")") Then MyEr "missing )", "КЕъПЕИ )": Exit Function
                    End If
                    On Error Resume Next
                    If p < -lim Then
                        MyEr "index too low for array " + v$ + sp$, "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " + v$ + sp$: Exit Function
                    End If
                    If pppp.PushOffset(Offset, dn, CLng(p)) Then
                        NeoGetArrayItem = True
                    Else
                        MyEr "index too high for array " + v$ + sp$, "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " + v$ + sp$: Exit Function
                    End If
                Else
                    If Not LastErNum = -2 Then
                        MyEr "missing index for array " + v$ + sp$, "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " + v$ + sp$
                    End If
                    Exit Function
                End If
                dn = dn + 1
            Loop
            
        End If
    End If
    If lookOne(rst, "(") Then
CheckThis:
        ppp$ = VarTypeName(pp.item(Offset))
        If ppp$ = myArray Then
            FastSymbol rst$, "("
            Set pp = pp.item(Offset)
            NeoGetArrayItem = False
            GoTo again123
        ElseIf ppp$ = mHdlr Then
            FastSymbol rst$, "("
            Set usehandler = pp.item(Offset)
            If usehandler.T1 = 3 Then
                If Typename(usehandler.objref) = myArray Then
                    Set pp = usehandler.objref
                Else
                    Exit Function
                End If
                Set usehandler = Nothing
            Else
                Set pp = New ppppLight
                pp.Arr = False
                Set pp.GroupRef = usehandler
            End If
            p = vbEmpty
            NeoGetArrayItem = pp.Arr
            GoTo again123
        ElseIf VarTypeName(pp.item(Offset)) = mGroup Then
            NeoGetArrayItem = True
        End If
End If
End Function



Public Sub TaskMasterTick()
' This is the TimerFunction that will be
' called when SetTimer times out.
Static once As Boolean
If once Then Exit Sub
  If Not TaskMaster Is Nothing Then
     Call GetSystemTimeAsFileTime(basictimer)
    If Abs(MasterTimer - basictimer > 0.025@) Then
        If Not extreme Then once = True: DoEvents: once = False
        Call GetSystemTimeAsFileTime(basictimer)
        MasterTimer = basictimer
    End If
   ' Form1.Caption = MasterTimer
   On Error Resume Next
    TaskMaster.TimerTick
  End If

End Sub

Public Function VALIDATEmStiva(bs As basetask, p$, s$) As Boolean
Dim st As mStiva, ss$, j As Long, anything As Object, usehandler As mHandler

Set st = bs.soros
Dim I As Long, r$
If p$ <> "" Then
    ''s$ = VbNullString
    If st.Total < Len(p$) Then Exit Function
    Do While I < Len(p$)
    I = I + 1
    j = AscW(st.StackItemType(I))
If j <> 62 Then
    Select Case AscW(Mid$(p$, I, 1))
    Case 62
    ' OPTIONAL IS OK ??

    Case 66, 98, 916, 948
        If j <> 42 Then Exit Function
        If VarTypeName$(st.StackItem(I)) = mHdlr Then
            If st.StackItem(I).T1 <> 2 Then Exit Function
        Else
            Exit Function
        End If
    
    Case 73, 105, 922, 954
        If j <> 42 Then Exit Function
        If VarTypeName$(st.StackItem(I)) = mHdlr Then
            Set usehandler = st.StackItem(I)
            If usehandler.T1 = 3 Then
                Set anything = usehandler.objref
                If CheckDeepAny(anything) Then
                    If VarTypeName$(anything) = "FastCollection" Then
                        If anything.structLen <> 0 Then Exit Function
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
            ElseIf usehandler.T1 <> 1 Then
                Exit Function
            End If
        Else
            Exit Function
        End If
        Set usehandler = Nothing
    Case 67, 99, 931, 963
        If j <> 42 Then Exit Function
        If VarTypeName$(st.StackItem(I)) = mHdlr Then
            Set usehandler = st.StackItem(I)
            If usehandler.T1 = 3 Then
                Set anything = usehandler.objref
                If CheckDeepAny(anything) Then
                    If VarTypeName$(anything) = "mStiva" Then
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
            Else
                Exit Function
            End If
        Else
            Exit Function
        End If
        Set usehandler = Nothing
    Case 925, 957, 913, 945, 78, 110 '' number  - use spellunicode to make it
        If j = 42 Then
            If VarTypeName(st.StackItem(I)) = mHdlr Then
                Set usehandler = st.StackItem(I)
                If usehandler.T1 <> 4 Then Exit Function
                Set usehandler = Nothing
            Else
                Exit Function
            End If
        ElseIf j <> 78 Then
            Exit Function
        End If
    Case 923, 955, 70, 102  ' change from L l to F f form lambda
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(I)), 1))
        If j <> 108 Then Exit Function
    Case 915, 947, 83, 115 '' string
        If j <> 83 Then Exit Function
    Case 928, 960, 65, 97  '' array
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(I)), 2))
        If j <> 65 Then
            If VarTypeName$(st.StackItem(I)) = mHdlr Then
                Set usehandler = st.StackItem(I)
                If usehandler.T1 = 3 Then
                    Set anything = usehandler.objref
                    If CheckDeepAny(anything) Then
                        If VarTypeName$(anything) = myArray Then
                        Else
                            Exit Function
                        End If
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
                Set usehandler = Nothing
            Else
                Exit Function
            End If
        End If
    Case 917, 69
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(I)), 2))
        If j <> 69 Then Exit Function
    Case 927, 959, 954, 71, 103, 67, 99
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(I)), 1))
         If j <> 71 Then Exit Function
    Case 76, 924
    If j <> 76 Then Exit Function
    Case Else
        Exit Function
    End Select
    End If
    
    Loop
    s$ = " "
    VALIDATEmStiva = True
    Exit Function
Else
    Do
    I = I + 1
    If st.Total < I Then Exit Do
        ss$ = st.StackItemType(I)
        If ss$ = "*" Then
        
            ss$ = Left$(Typename(st.StackItem(I)), 2)
checkagain:
            If ss$ = "mA" Then ss$ = "A"
            If ss$ = "mE" Then ss$ = "E"
            If ss$ = "Gr" Then ss$ = "G"
            If ss$ = "la" Then ss$ = "F"
            If ss$ = "mS" Then ss$ = "C"
            If ss$ = "mH" Then
                Set usehandler = st.StackItem(I)
ch2:
                Select Case usehandler.T1
                Case 1
                ss$ = "I"
                Case 2
                ss$ = "B"
                Case 3
                Set anything = usehandler.objref
                If CheckDeepAny(anything) Then
                    ss$ = Left$(Typename(anything), 2)
                    If ss$ = "mH" Then Set usehandler = anything: GoTo ch2
                    Set usehandler = Nothing
                    GoTo checkagain
                End If
                Set usehandler = Nothing
                ss$ = "U"   ' "Undefined"
                Case 4
                ss$ = "N"
                Case Else
                ss$ = "U"   ' "Undefined"
                End Select
            End If
        End If
    r$ = r$ + Right$("?" + ss$, 1)
    Loop
    s$ = r$
End If
VALIDATEmStiva = r$ <> ""
End Function

Public Function VALIDATE(st$, p$, s$) As Boolean
Dim dummy As Double
Dim I As Long, j As Long, ok As Boolean
If Len(st$) = 0 Then
VALIDATE = True
End If
' NORMALIZE
s$ = vbNullString
ok = True
For I = 1 To Len(st$)
Select Case Mid$(st$, I, 1)
Case " ", ",", ChrW(160)

Case Is = Chr(34)
j = InStr(I + 1, st$, Chr(34), vbBinaryCompare)
If j = 0 Then Exit For
s$ = s$ + "S"
I = j + 1
            If p$ <> "" Then
                Select Case AscW(p$)
                Case 915, 947, 83, 115 '' string
                Case Else
                        ok = False: Exit For
                End Select
                    p$ = Mid$(p$, 2)
                    If p$ = vbNullString Then Exit For
             End If
 Case Is = Chr$(2)
            If Len(Mid$(st$, I + 1, 8)) = 8 Then
             I = I + CLng("&H" + Mid$(st$, I + 1, 8)) + 8
             s$ = s$ + "S"
             If p$ <> "" Then
                Select Case AscW(p$)
                Case 915, 947, 83, 115 '' string
                Case Else
                        ok = False: Exit For
                End Select
             p$ = Mid$(p$, 2)
             If p$ = vbNullString Then Exit For
             End If
             Else
             Exit For
             End If
Case Else
        If IsNumberD3(st$, I, j) Then
                If I = 0 Then I = j + 1
                I = I + j - 2
                s$ = s$ + "N"
                    If p$ <> "" Then
                Select Case AscW(p$)
                 Case 925, 957, 913, 945, 78, 110 '' number
                Case Else
                        ok = False: Exit For
                End Select
                         p$ = Mid$(p$, 2)
                         If p$ = vbNullString Then Exit For
                    End If
      Else
          Exit For
      End If
End Select
      

Next I
 ' TO P$ ха паяеи то упокоипо

   p$ = Mid$(st$, I + 1)
   st$ = Left$(st$, I)
    VALIDATE = ok
End Function

Public Function VALIDATEpart(st$, p$) As Boolean
Dim dummy As Double
Dim I As Long, j As Long, ok As Boolean, s$
If Len(st$) = 0 Then
VALIDATEpart = False   ' reverse logic here...
End If
' NORMALIZE
s$ = vbNullString
ok = True
For I = 1 To Len(st$)
If Mid$(st$, I, 1) = Chr$(2) Then
            If Len(Mid$(st$, I + 1, 8)) = 8 Then
             I = I + CLng("&H" + Mid$(st$, I + 1, 8)) + 8
             Else
             Exit For
             End If
      ElseIf IsNumberD3(st$, I, j) Then
      I = j + I - 2
      Else
      I = I - 1
      Exit For
      End If
      

Next I
p$ = Left$(st$, I)
    st$ = " " + Mid$(st$, I + 1)
    VALIDATEpart = p$ <> ""
End Function








Sub mywait(bstack As basetask, pp As Variant, Optional SLEEPSHORT As Boolean = False)
Dim p As Boolean, E As Boolean
On Error Resume Next
If bstack Is Nothing Then
If pp = 0 Then Exit Sub
End If
If bstack.Process Is Nothing Then
''If extreme Then MyDoEvents1 Form1

Else

Err.Clear
p = bstack.Process.Done
If Err.Number = 0 Then
E = True
If p <> 0 Then
Exit Sub
End If
End If
End If
Dim tn As Long, dt As Long
tn = timeGetTime
If pp < 1 Then dt = 1 Else dt = CLng(pp)
If TaskMaster Is Nothing Then Set TaskMaster = New TaskMaster
Dim oldRR As Currency
oldRR = RRCOUNTER
Do
    If TaskMaster.Processing And Not bstack.TaskMain Then
        If Not bstack.toprinter Then bstack.Owner.Refresh
        TaskMaster.TimerTick
        MyDoEvents1 Form1
        If SLEEPSHORT Then Sleep 1
        If UnsignedSub(timeGetTime, tn) >= dt Then Exit Do
    Else
        If UnsignedSub(timeGetTime, tn) >= dt Then Exit Do
        MyDoEvents1 Form1
        If SLEEPSHORT Then
            Sleep 3
        ElseIf oldRR <> RRCOUNTER Then
            Sleep 1: oldRR = RRCOUNTER
        End If
       
    End If

    If E Then
        p = bstack.Process.Done
        If Err.Number = 0 Then
            If p <> 0 Then
                Exit Do
            End If
        End If
    End If
    
Loop Until NOEXECUTION
If exWnd <> 0 Then MyTitle$ bstack
End Sub
Sub ProcTask(bstack As basetask)
Sleep 1
If IsWine Then
DoEvents
Else
SleepWaitEdit2 10
End If
End Sub
Sub ProcTask2(bstack As basetask)
On Error GoTo procbliah2
If bstack.IamThread And trace Then
    If SLOW Or IsWine Then Sleep 1
TaskMaster.rest
If IsWine Then
DoEvents
Else
SleepWaitEdit2 1
End If
TaskMaster.RestEnd
Exit Sub

ElseIf TaskMaster Is Nothing Then
If SLOW Or IsWine Then
Sleep 1
End If
DoEvents
Else
If TaskMaster.Processing Then
          TaskMaster.RestEnd1
 TaskMaster.TimerTickNow

ElseIf SLOW Or IsWine Then
Sleep 1
End If
TaskMaster.rest
If IsWine Then
DoEvents
Else
SleepWaitEdit2 1
End If
TaskMaster.RestEnd
End If
Exit Sub
procbliah2:
DoEvents
Sleep 1
End Sub

Sub ResetBreak()
Do While KeyPressedLong(&H13) <> 0
    MyDoEvents
Loop
End Sub
Private Sub MyDoEvents()
On Error GoTo there
If TaskMaster Is Nothing Then
    DoEvents
    Exit Sub
ElseIf Not TaskMaster.Processing And TaskMaster.QueueCount = 0 Then
    DoEvents
    Exit Sub
Else
    If TaskMaster.PlayMusic Then
        TaskMaster.OnlyMusic = True
        TaskMaster.TimerTick
        TaskMaster.OnlyMusic = False
    End If
    TaskMaster.StopProcess
    TaskMaster.TimerTick
    DoEvents
    TaskMaster.StartProcess
End If
Exit Sub
there:
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd1
End Sub
Function myexit(bstack As basetask) As Boolean
On Error Resume Next
If extreme Then
Else
If escok Then
    If KeyPressed(&H1B) Then
        If Modalid <> 0 Then
            Modalid = 0
            ShutEnabledGuiM2000
            MyDoEvents
            While KeyPressed(&H1B)
                MyDoEvents
            Wend
        Else
            NOEXECUTION = True
            ShutEnabledGuiM2000 True
            MyDoEvents
            If AVIRUN Then AVI.GETLOST
            NOEXECUTION = True
            While KeyPressed(&H1B)
                    MyDoEvents
            Wend
            myexit = True
            Exit Function
        End If
    ElseIf NOEXECUTION Then
        ShutEnabledGuiM2000 True
        MyDoEvents
    End If
End If
End If
If bstack Is Nothing Then myexit = True: Exit Function
If TaskMaster Is Nothing Then Exit Function
If TaskMaster.OnlyMusic Then TaskMaster.TimerTick
If bstack.IamThread Then myexit = bstack.Process.Done Else myexit = False
End Function
Function myexit2(bstack As basetask) As Boolean
    If KeyPressed(&H1B) Then
        If Modalid <> 0 Then
            Modalid = 0
            ShutEnabledGuiM2000
            MyDoEvents
            While KeyPressed(&H1B)
                MyDoEvents
            Wend
        Else
            NOEXECUTION = True
            ShutEnabledGuiM2000 True
            MyDoEvents
            If AVIRUN Then AVI.GETLOST
            NOEXECUTION = True
            While KeyPressed(&H1B)
                    MyDoEvents
            Wend
            myexit2 = True
            Exit Function
        End If
    ElseIf NOEXECUTION Then
        ShutEnabledGuiM2000 True
        MyDoEvents
    End If

End Function

Sub closeAll()
Dim I As Long
CloseAllHandlers
CloseAllConnections
End Sub
Function MakeitObjectGeneric(Number As Long) As Object
Dim aa As New mHandler, K As Long
aa.T1 = 3
On Error GoTo there
If Not MyIsObject(var(Number)) Then
Set var(Number) = aa
aa.T1 = 0
Else
If var(Number) Is Nothing Then
Number = -1

Else
Do While TypeOf var(Number) Is mHandler
If var(Number).indirect < 0 Then Exit Do
If K > 20 Then MyEr "too many references", "ПОККщР АМАЖОЯщР": Exit Do
Number = var(Number).indirect
K = K + 1
Loop
End If
there:
aa.indirect = Number
End If
Set aa.objref = Nothing
Set MakeitObjectGeneric = aa

End Function

Sub PlaceIteratorData(bstack As basetask, anything As Variant, st, en)
Dim usehandler As mHandler, usehandler1 As mHandler
Set usehandler = bstack.lastobj
If MyIsObject(anything) Then
Set usehandler1 = anything
Set usehandler.objref = usehandler1.objref
End If
With usehandler.objref
    If st < 0 Then st = .count + st Else st = st - 1
    If en < 0 Then en = .count + en Else en = en - 1
    If st < 0 Then st = 0: en = -2 '0
    If en < 0 Then en = -1 '0
    If st >= .count Then en = -1: st = .count - 1
    If en >= .count Then en = -1 ' .count - 1
    
End With
With usehandler
    .T1 = 3
     .indirect = -1
    .index_start = st
    .index_End = en
    .index_cursor = st
    .UseIterator = True
End With
If MyIsObject(anything) Then
    If TypeOf usehandler.objref Is FastCollection Then
        usehandler.T1 = 1
        Set usehandler.objref = anything
    ElseIf TypeOf usehandler.objref Is Enumeration Then
        Set usehandler.objref = New mHandler
        Set usehandler = usehandler.objref
        Set usehandler1 = anything
        Set usehandler.objref = usehandler1.objref
        usehandler.T1 = 4
        usehandler.index_cursor = st
    End If
End If

End Sub
Sub MakeitObjectInventory(var As Variant, Optional queue As Boolean)
Dim aa As New mHandler
aa.T1 = 1 ' 1 for Inventory
Set aa.objref = New FastCollection
If queue Then aa.objref.AllowAnyKey
Set var = aa
End Sub
Sub MakeitObjectBuffer(var As Variant)
Dim aa As New mHandler
aa.T1 = 2 ' 2 for Buffer
Set aa.objref = New MemBlock
Set var = aa
End Sub
Sub MakeitObjectLong(var As Variant)
Dim aa As Long
var = aa
End Sub
Sub MakeitObjectEvent(var As Variant)
Dim aa As New mEvent
Set var = aa
End Sub
Sub MakeitObject(var As Variant)
Dim aa As New Document
Set var = aa
var.textDoc = vbNullString
End Sub
Sub MakeitPropReference(var As Variant)
Dim aa As New PropReference
Set var = aa
End Sub
Sub CreateFormObject(var As Variant, id As Long)
Dim aa As Object
Select Case id
'Case 0
'Set aa = New Server  ' next time...
Case 1
Set aa = New GuiM2000
Case 2  '
Set aa = New GuiButton
Case 3
Set aa = New GuiTextBox
Case 4
Set aa = New GuiCheckBox
Case 5
Set aa = New GuiEditBox
Case 6
Set aa = New GuiListBox
Case 7
Set aa = New GuiDropDown
Case 8
Set aa = New GuiImage
Case 9
Set aa = New ExtControl
End Select
Set var = aa
End Sub
Sub CreateFormOtherObject(var As Variant, THISOBJECT As Object)
Set var = THISOBJECT
End Sub

Sub CreateitObject(var As Variant, THISOBJECT As String, Optional ByVal cc As Variant)
Dim aa As Object
Dim nVal As String
If IsMissing(cc) Then
If Left$(THISOBJECT, 1) = "{" Then
    nVal = strProgIDfromSrting(THISOBJECT)
    If Len(nVal) > 0 Then THISOBJECT = nVal
End If
On Error Resume Next
Set aa = CreateObject(THISOBJECT)
If Err Then
MyEr Err.Description, Err.Description
End If

Else
Set aa = CreateObject(THISOBJECT, CStr(cc))
End If
Set var = aa
End Sub

Function CheckVarGroup(basestack As basetask, var As Variant, s As String, Optional Final As Boolean = False) As Long
Dim D As Document, c As Constant
                
If VarTypeName(var) = doc Then
Set D = var
D.FasttextDoc = s

ElseIf VarTypeName(var) = "lambda" Then
If Not basestack.lastobj Is Nothing Then
If TypeOf basestack.lastobj Is lambda Then
    Set var = basestack.lastobj
End If
End If
ElseIf Not basestack.lastobj Is Nothing Then
If TypeOf basestack.lastobj Is lambda Then
    Set var = basestack.lastobj
    Set basestack.lastobj = Nothing
    CheckVarGroup = 1
    ' means make function for lambda for group
End If
Else
MoveStringToVariant s, var
End If

If Final Then
    Set c = New Constant
    c.DefineOnce var
    Set var = c
End If
Set basestack.lastobj = Nothing
End Function
Sub CheckVar(var As Variant, s As String, Optional Append As Boolean)
If VarTypeName(var) = doc Then
If var.IsEmpty Then
var.FasttextDoc = s
Else
Dim kk As Document
Set kk = var
kk.InsertDoc kk.LastParagraph, kk.TextParagraphLen(kk.LastParagraph) + 1, s
End If
ElseIf Append Then
If LenB(var) = 0 Then
MoveStringToVariant s, var
Else
var = var + s
End If
Else
MoveStringToVariant s, var
End If
End Sub
Function CheckVarOnlyNo(var As Variant, s As String, Optional checktype As Boolean = True) As Boolean
If VarTypeName(var) = doc Then
    If var.IsEmpty Then
        var.textDoc = s
    Else
        var.InsertDoc var.LastParagraph, var.TextParagraphLen(var.LastParagraph) + 1, s
    End If
ElseIf MyIsObject(var) Then
    CheckVarOnlyNo = True  ' this is an error
Else
    If MemInt(VarPtr(var)) = vbString Then
        MoveStringToVariant s, var
    ElseIf checktype Then
        WrongType
        CheckVarOnlyNo = True  ' this is an error
    Else
        var = ""
        MoveStringToVariant s, var
    End If
End If
End Function





Sub MakeitObject2(var As Variant)
Dim aa As Object
Set aa = New Group
Set var = aa
End Sub
Sub prepareGroup(bstack As basetask, ByVal ohere$, vvv As Long, Optional Glob As Boolean = False, Optional isAstr As Boolean = False, Optional alocal As Boolean = False)
Dim hv As Boolean
If Not Glob Then
If alocal Then
Else
If here$ = vbNullString Then
    hv = GetVar(bstack, bstack.GroupName + ohere$, vvv, True)
Else
    hv = GetlocalVar(bstack.GroupName + ohere$, vvv)
 End If
End If
 End If
If hv Then
    If Not MyIsObject(var(vvv)) Then
        MakeitObject2 var(vvv)
    ElseIf VarTypeName(var(vvv)) <> mGroup Then
        MakeitObject2 var(vvv)
        GoTo conthere
    ElseIf var(vvv).IamApointer Then
     PushStage bstack, False
     Dim myobject As Object
     Set myobject = var(vvv)
     UnFloatGroup bstack, ohere$, vvv, myobject, var(vvv).IamGlobal
     Set myobject = Nothing
     
    End If
Else
    vvv = GlobalVarRefOnly(bstack.GroupName + ohere$, Glob)
    MakeitObject2 var(vvv)
conthere:
    If isAstr Then
    GlobalVarRefLink bstack.GroupName + ohere$ + "$", vvv, Glob
    End If
 'If Not glob Then
 var(vvv).GroupName = ohere$ + "."
 var(vvv).HasStrValue = isAstr
End If
var(vvv).edittag = vbNullString
End Sub

Public Function CleanStr(sStr As String, noValidcharList As String) As String
Dim A$, I As Long '', ddt As Boolean
If noValidcharList <> "" Then
''If Len(sStr) > 20000 Then ddt = True
If Len(sStr) > 0 Then
For I = 1 To Len(sStr)
''If ddt Then If i Mod 321 = 0 Then Sleep 20
If InStr(noValidcharList, Mid$(sStr, I, 1)) = 0 Then A$ = A$ + Mid$(sStr, I, 1)

Next I
End If
Else
A$ = sStr
End If
CleanStr = A$
End Function
Sub CallByObject(bstack As basetask, ret As Boolean, that As stdCallFunction)
Dim Up As Long, getparam As Boolean, pp As Long
Dim K As Long, p As Variant, Final(0 To 63) As Variant
Dim x1 As Long, what$, curtype As Long, s$, link$, rtype As Variant
Dim thisref(0 To 63) As Long
Dim usehandler As mHandler

If that.ReadType(that.count - 1) = -100 Then
Up = that.count - 1
getparam = True
Else
Up = that.count
End If
For K = 1 To Up
       
        If that.IsByRef(K - 1) Then
            ' look for label..and check it
           If bstack.IsInStackString(what$) Then
                   
                    If that.ReadType(K - 1) <= 4 Then
                            If GetGlobalVar(bstack.GroupName + what$, x1) Then
                                    thisref(K - 1) = x1 ' so that is used to restore value
                                    If MyIsObject(var(x1)) Then
                                         ' THIS IS NOT GOOD
                                    
                                    Else
                                        If that.ReadType(K - 1) = 2 Then
                                         Final(K - 1) = CLng(VarPtr(var(x1)) + 8)
                                         
                                        Else
                                             Final(K - 1) = var(x1)
                                            End If
                                             ' so if this is a long we place a variant long
                                           ' thisref(k - 1) = x1
                                     End If
                            Else
                            ' no such variable
                            End If
                    Else
                    ' error no array yet
                    
                    End If
            Else
            ' type mismatch
            ' exit - error
            End If
        Else
        Dim ii As Long
                Select Case that.ReadType(K - 1)
                Case 2
                   If Not bstack.IsInStackNumber(p) Then
                   
                    If Not bstack.IsInStackLong(ii) Then
                        If bstack.soros.StackItemTypeIsObject(1) Then
                            If bstack.soros.StackItemTypeObjectType(1) = "*[Enumeration]" Then
                                Set usehandler = bstack.soros.PopObj
                                If MyIsNumeric(usehandler.index_cursor) Then
                                    ii = usehandler.index_cursor * usehandler.sign
                                Else
                                    Exit For
                                End If
                            Else
                                Exit For
                            End If
                        Else
                            Exit For
                        End If
                    Else
                        Exit For
                    End If
                    Final(K - 1) = ii
                    Else
                    If VarType(p) = 20 Then
                    Final(K - 1) = p
                    Else
                    Final(K - 1) = CLng(p)
                    End If
                   End If
                Case 20
                If Not bstack.IsInStackNumber(p) Then
                   Final(K - 1) = p
                  End If
                Case 1, 5
                        If Not bstack.IsInStackNumber(p) Then
                   
                    If Not bstack.IsInStackLong(ii) Then Exit For
                    Final(K - 1) = ii
                    Else
                    Final(K - 1) = p
                    End If
                Case 4, 7
                      If Not bstack.IsInStackNumber(p) Then
                   
                    If Not bstack.IsInStackLong(ii) Then Exit For
                    Final(K - 1) = ii
                    Else
                    Final(K - 1) = MyRound(p)
                    End If
                Case Else
                    If Not bstack.IsInStackString(s$) Then Exit For
                    Final(K - 1) = s$
                End Select
        End If
Next K
If getparam Then
Do
If bstack.IsInStackLong(pp) Then
Final(K - 1) = pp
K = K + 1
ElseIf bstack.IsInStackNumber(p) Then
Final(K - 1) = p
K = K + 1
ElseIf bstack.IsInStackString(s$) Then
 Final(K - 1) = s$
K = K + 1
Else
Exit Do
End If
Loop Until bstack.soros.IsEmpty Or K = 63

Up = K - 1
End If

If K > Up Then
'all is ok
' make your call
If that.RetType = 0 Then
rtype = vbLong
Else
rtype = that.RetType
End If
If that.CallAddr = 0 Then
If Left$(that.func, 1) = "#" Then
that.CallAddr = GetFuncPtrOrd(that.LIB, that.func)
Else
that.CallAddr = GetFuncPtr(that.LIB, that.func)
End If
End If
If that.CallAddr = 0 Then Exit Sub
On Error GoTo there
Select Case rtype
Case 9, 13
If that.CallType = 0 Then
Set rtype = Fast_stdCallW(that.CallAddr, rtype, Final(), Up)
Else
Set rtype = Fast_cdeclCallW(that.CallAddr, rtype, Final(), Up)
End If
If ret Then
    bstack.soros.PushObj rtype   ' FEEDBACK TO STACK
End If
Case Else
If that.CallType = 0 Then
rtype = Fast_stdCallW(that.CallAddr, rtype, Final(), Up)
Else
rtype = Fast_cdeclCallW(that.CallAddr, rtype, Final(), Up)
End If
If ret Then
    If that.RetType = 0 Then
        bstack.soros.PushVal rtype    ' FEEDBACK TO STACK
    Else
        bstack.soros.PushStr GetBStrFromPtr(x1)
    End If
End If

End Select
Else
'error message


Exit Sub
End If
For K = 1 To that.count
If that.IsByRef(K - 1) Then
' RESTORE VALUES...
    If that.ReadType(K - 1) < 5 Then
    If that.ReadType(K - 1) <> 2 Then var(thisref(K - 1)) = Final(K - 1)
    
    End If
End If
Next K
Exit Sub
there:
MyEr Err.Description, Err.Description
Err.Clear
End Sub

Sub CallGlobal(s$)
Dim ohere$
ohere$ = here$
here$ = "@"
 Execute Basestack1, s$, False
 s$ = vbNullString
here$ = ohere$
End Sub
Public Sub ProcProperty(bstack As basetask, v(), vIndex As Long, FN$, rest$, language As Long, Optional hardlink As Boolean = False, Optional usethis As Long)
Dim var1() As Variant, s$, r As Double, L As Long, NewRef As Long, many As Long, y1 As Boolean, x1 As Long, y2 As Boolean, Y3 As Long
Dim var2() As String, ss$, sp As Variant, indirect As Boolean, s1$, newvar As Boolean
Dim vv As Object, handlerFLAG As Boolean, usehandler As mHandler
Dim oo As Object, myVar As Variant
Set vv = v(vIndex)
Dim pppp As iBoxArray

If TypeOf vv Is mHandler Then
    Set usehandler = vv
    If usehandler.indirect >= 0 Then
        vIndex = usehandler.indirect
        Set vv = var(usehandler.indirect)
    Else
        If usehandler.UseIterator Then
        ElseIf usehandler.IamEnum Then
            handlerFLAG = True
        Else
            Set vv = usehandler.objref
        End If
    End If
    indirect = True
End If
If TypeOf vv Is ExtControl Then Set vv = vv.Value
If TypeOf vv Is PropReference Then
    myVar = vv.Value
    If IsObject(vv.lastobj) Then Set vv = vv.lastobjfinal Else NoObjectFound: Exit Sub
End If
Do
    ReDim var1(0 To 0)
    Erase var2()
    Set pppp = Nothing
    
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, r) Then
            If FastSymbol(rest$, "@") Then
                Set oo = bstack.lastobj
                Set bstack.lastobj = Nothing
                ReDim var1(0 To 1)
                If IsExp(bstack, rest$, sp) Then
                    var1(0) = sp
                ElseIf IsStrExp(bstack, rest$, ss$) Then
                    var1(0) = ss$
                End If
                If oo Is Nothing Then
                    var1(1) = r
                Else
                    If TypeOf oo Is mHandler Then
                        Set bstack.lastobj = oo
                        Set var(1) = bstack.lastobjIndirect(var())
                    Else
                        Set var1(1) = oo
                    End If
                    Set oo = Nothing
                End If
                CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 2
            Else
                If bstack.lastobj Is Nothing Then
conthere:
                    var1(0) = r
                    CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 1
                Else
                    Set var1(0) = bstack.lastobj
                    If TypeOf var1(0) Is mHandler Then
                        Set usehandler = var1(0)
                        If usehandler.T1 = 4 Then GoTo conthere
                    End If
                    Set bstack.lastobj = Nothing
                    CallByNameFixParamArray vv, FN$, VbSet, var1(), var2(), 1
                End If
            End If
        ElseIf IsStrExp(bstack, rest$, s$) Then
            If FastSymbol(rest$, "@") Then
                ReDim var1(0 To 1)
                If IsExp(bstack, rest$, sp) Then
                    var1(0) = sp
                ElseIf IsStrExp(bstack, rest$, ss$) Then
                    var1(0) = ss$
                    End If
                    var1(1) = s$
                    CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 2
                Else
                    var1(0) = s$
                    CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 1
                End If
            End If
        ElseIf IsLabelSymbolNew(rest$, "ыс", "AS", language) Then
        ' WE MAKE A NEW OBJECT
            If TypeOf var(vIndex) Is GuiM2000 Then If UCase(FN$) = "VISIBLE" Then FN$ = "TrueVisible"
                                                            
            If FN$ = vbNullString Then
                L = usethis
            ElseIf handlerFLAG Then
                Set usehandler = vv
                L = FindDISPID(usehandler.objref, FN$)
                Set usehandler = Nothing
            Else
                L = FindDISPID(vv, FN$)
            End If
            If L <> -1 Then
                ' we have vv, fn$, l and we are looking for a label to make an object to that
                y1 = IsLabelSymbolNew(rest$, "цемийо", "GLOBAL", language)
                If Not y1 Then y2 = IsLabelSymbolNew(rest$, "мео", "NEW", language) Else y2 = False
                x1 = Abs(IsLabel(bstack, rest$, s$))
                If x1 < 5 Then
                    If y1 Or y2 Then GoTo jumpthere
                        If GetlocalVar(s$, NewRef) Then
                            ' so it is an object now
                            If Not MyIsObject(var(NewRef)) Then
                                MakeitPropReference var(NewRef)
                                GoTo jumpheretoo
                            ElseIf VarTypeName(var(NewRef)) <> mProp Then
                                If VarTypeName(var(NewRef)) = mHdlr Then
                                    GoTo contenum
                                Else
                                    MakeitPropReference var(NewRef)
                                End If
                                GoTo jumpheretoo
                            End If
                        Else
jumpthere:
''GlobalVar s$, 0   'we push a zero..GlobalVar create
''GetlocalVar s$, newref
                            If y1 Then
                                NewRef = GlobalVarRefOnly(s$, y1)
                            Else
                                NewRef = GlobalVarRefOnly(bstack.GroupName + s$)
                            End If
contenum:
                            If L = -4 Then
                                ' get now object
                                sp = vbEmpty
                                If ReadPropObj(vv, -4, sp) Then
                                    Set usehandler = New mHandler
                                    Set var(NewRef) = usehandler
                                    usehandler.ConstructEnumerator sp
                                    Set usehandler = Nothing
                                Else
                                    NoEnumerator
                                End If
                            Else
                                MakeitPropReference var(NewRef)
jumpheretoo:
                                If hardlink Then
                                    Set oo = v(vIndex)
                                    If TypeOf oo Is mHandler Then
                                        Set usehandler = oo
                                        Set oo = usehandler.objref
                                        If usehandler.T1 <> 1 Then
                                            GoTo there
                                        End If
                                    End If
                                    var(NewRef).ConstructObj oo, L
                                    Set oo = Nothing
                                Else
                                    If vv Is var(vIndex) Then
                                        var(NewRef).Construct vIndex, L, indirect    ' this is the link vindex is an index to var()
                                    Else
                                        var(NewRef).ConstructObj vv, L
                                    End If
                                End If
                            End If
                        End If
                    Else
                        If y2 Then
                            If FastSymbol(rest$, ")") Then GoTo contherenew
                        End If
                        If neoGetArray(bstack, s$, pppp, Len(here$) = 0, , Len(here$) > 0) Then
                            If NeoGetArrayItem(pppp, bstack, s$, NewRef, rest$) Then
                            With pppp
                                MakeitPropReference myVar
                                If .Arr Then Set .item(NewRef) = myVar
                                If hardlink Then
                                    Set oo = v(vIndex)
                                    If TypeOf oo Is mHandler Then
                                        Set usehandler = oo
                                        With usehandler
                                            If .indirect < 0 Then
                                                Set oo = .objref
                                                        '  Else
                                                        '    If .indirect <= var2used Then
                                                        '   End If
                                            End If
                                        End With
                                    End If
                                    myVar.ConstructObj oo, L
                                    Set oo = Nothing
                                Else
                                    myVar.Construct vIndex, L   ' this is the link vindex is an index to var()
                                End If
                                Set myVar = Nothing
                            End With
                            Set usehandler = Nothing
                        End If
                    ElseIf FastSymbol(rest$, ")") Then

contherenew:
                    If pppp Is Nothing Then
                        Set pppp = GlobalArrProp(bstack, s$, y1)
                    End If
                        MakeitPropReference myVar
                        If hardlink Then
                            Set oo = v(vIndex)
                            If TypeOf oo Is mHandler Then
                                Set usehandler = oo
                                Set oo = usehandler.objref
                                Set usehandler = Nothing
                            End If
                            myVar.ConstructObj oo, L
                            Set oo = Nothing
                        Else
                            myVar.Construct vIndex, L   ' this is the link vindex is an index to var()
                        End If
                        myVar.UseIndex = True
                        pppp.PushProp myVar
                    End If
                End If
            End If
        ElseIf IsLabelSymbolNew(rest$, "паяе", "GET", language) Then
            y1 = IsLabelSymbolNew(rest$, "цемийо", "GLOBAL", language)
            If Not y1 Then newvar = IsLabelSymbolNew(rest$, "мео", "NEW", language)
            Y3 = IsLabelSymbolNew(rest$, "лецецомота", "WITHEVENTS", language)
            L = FindDISPID(vv, FN$)
            FN$ = UCase(FN$)
            x1 = Abs(IsLabel(bstack, rest$, s$))
            If ReadOneParameter(vv, L, s$, myVar) Then
            
            GoTo jumpFromGet
            Else
            End If
        ElseIf IsLabelSymbolNew(rest$, "хесе", "SET", language) Then
        
            y1 = IsLabelSymbolNew(rest$, "цемийо", "GLOBAL", language)
            L = FindDISPID(vv, FN$)
            FN$ = UCase(FN$)
            If L <> -1 Then
                x1 = Abs(IsLabel(bstack, rest$, s$))
                If x1 < 5 Then
                    If Not FastSymbol(rest$, "(") Then
                        If Not ReadOneParameter(vv, L, s$, myVar) Then
                            If MyIsObject(myVar) Then
                                If myVar Is Err Then
                                    Set errbag = New ErrorBag
                                    errbag.CopyErr
                                    Set myVar = errbag
                                    Set errbag = Nothing
                                    Err.Clear
                                End If
                            Else
                                MyEr s$, s$
                                GoTo there
                            End If
                        End If
                    Else
                        GoTo contindex
                    End If
                Else
contindex:
            If IsExp(bstack, rest$, sp) Then
            Err.Clear
            Set myVar = ReadOneIndexParameter(vv, L, s1$, sp, False)
            If Err.Number Then
                If MyIsObject(myVar) Then
                    If myVar Is Err Then
                        Set errbag = New ErrorBag
                        errbag.CopyErr
                        Set myVar = errbag
                        Set errbag = Nothing
                    End If
                End If
                Err.Clear
                Set myVar = ReadOneIndexParameter(vv, L, s1$, sp, True)
                If MyIsObject(myVar) Then
                    If myVar Is Err Then
                        Set errbag = New ErrorBag
                        errbag.CopyErr
                        Set myVar = errbag
                        Set errbag = Nothing
                    End If
                End If
                Err.Clear
            End If
        ElseIf IsStrExp(bstack, rest$, ss$) Then
            On Error Resume Next
            Err.Clear
            Set myVar = ReadOneIndexParameter(vv, L, s1$, ss$, False)
            If Err.Number Then
               If MyIsObject(myVar) Then
                        If myVar Is Err Then
                            Set errbag = New ErrorBag
                            errbag.CopyErr
                            Set myVar = errbag
                            Set errbag = Nothing
                        End If
                    End If
                    Err.Clear
                    Set myVar = ReadOneIndexParameter(vv, L, s1$, ss$, True)
                    If MyIsObject(myVar) Then
                        If myVar Is Err Then
                            Set errbag = New ErrorBag
                            errbag.CopyErr
                            Set myVar = errbag
                            Set errbag = Nothing
                        End If
                    End If
                    Err.Clear
                End If
            End If
            If Not FastSymbol(rest$, ")") Then GoTo there
            If x1 > 4 Then s$ = Left$(s$, Len(s$) - 1)
        End If
jumpFromGet:
        Dim ev As ComShinkEvent
        If newvar Then
        GoTo jumpnewvar
        ElseIf GetlocalVar(s$, NewRef) Then
            If IsObject(myVar) Then
                    Set var(NewRef) = myVar
                    If Y3 Then
                        If GetShink(ev, NewRef, s$) Then
                            If Not GetVar(bstack, ChrW(&HFFBF) + "_" + s$, Y3) Then
                                        Y3 = globalvarGroup(ChrW(&HFFBF) + "_" + s$, CVar(vbNullString), , y1)
                            End If
                            Set var(Y3) = ev
                            'Debug.Print "WithEvents Set 0"
                         Else
                            MyEr "Can't handle events here", "дЕМ ЛПОЯЧ МА ВЕИЯИСТЧ ЦЕЦОМЭТА"
                            GoTo there
                         End If
                End If
                
                
            Else
                var(NewRef) = myVar
            End If
        Else
jumpnewvar:
            NewRef = GlobalVarRefOnly(s$, y1)
            If IsObject(myVar) Then
                Set var(NewRef) = myVar
                If Y3 Then
                        If GetShink(ev, NewRef, s$) Then
                            Y3 = globalvarGroup(ChrW(&HFFBF) + "_" + s$, CVar(vbNullString), , y1)
                            Set var(Y3) = ev
                            'Debug.Print "WithEvents Set"
                         Else
                            MyEr "Can't handle events here", "дЕМ ЛПОЯЧ МА ВЕИЯИСТЧ ЦЕЦОМЭТА"
                            GoTo there
                         End If
                End If
            Else
                var(NewRef) = myVar
            End If
        End If
    End If
    End If

    If FastSymbol(rest$, ",") Then
        If Not IsStrExp(bstack, rest$, FN$, False) Then Exit Do
    Else
        Exit Do
    End If
Loop
there:
Set oo = Nothing
Set pppp = Nothing
Set vv = Nothing
End Sub
Sub ProcMethod(bstack As basetask, v(), vIndex As Long, FN$, rest$, language As Long, ok As Boolean, groupok As Boolean, prive As Boolean)
Dim var1() As Variant, s$, r As Double, L As Long, NewRef As Long, Glob As Boolean, newvar As Boolean
Dim vv As Object, result As Variant, retobject As Object, usehandler As mHandler, oUnk As stdole.IUnknown
Dim namarg As Long, x1 As Long
ok = True
Set vv = v(vIndex)
If TypeOf vv Is mHandler Then
Set usehandler = vv
If usehandler.indirect >= 0 Then

vIndex = usehandler.indirect
If var2used < usehandler.indirect Then
MyEr "weak reference  out of scope", "Г АМАЖОЯэ ЕъМАИ ЕЙТЭР СЙОПОЩ"
ok = False
Exit Sub
End If

Set vv = var(usehandler.indirect)

Else
Set vv = usehandler.objref
End If
End If
Set usehandler = Nothing
If vv Is Nothing Then Exit Sub
If TypeOf vv Is ExtControl Then
Set vv = vv.Value
ElseIf TypeOf vv Is PropReference Then
result = vv.Value
result = Empty
If IsObject(vv.lastobj) Then Set vv = vv.lastobjfinal Else ok = False: NoObjectFound: Exit Sub
End If

ReDim var1(0 To 0)
Dim var2() As String
ReDim var2(0 To 0)
' expression or label:=expression'

''Exit Sub
Dim what$, it As Long, items As Long, Y3 As Long, ok1 As Boolean

' we have parameters..(by value)
If FastSymbol(rest$, "(") Then  ' we have "(par1, par2...) as result"
        RealMeth bstack, rest$, var1(), var2(), items, namarg, ok1
        If Not ok1 Then Exit Sub
If Not FastSymbol(rest$, ")", True) Then Exit Sub
result = CallByNameFixParamArray(vv, FN$, VbMethod, var1(), var2(), items, retobject, namarg, bstack.IamAnEvent, oUnk)
ElseIf FastSymbol(rest$, ",") Then
RealMeth bstack, rest$, var1(), var2(), items, namarg, ok1  ' if we have as result then we get an error...
If Not ok1 Then Exit Sub
 result = CallByNameFixParamArray(vv, FN$, VbMethod, var1(), var2(), items, retobject, namarg, bstack.IamAnEvent, oUnk)
Else

 result = CallByNameFixParamArray(vv, FN$, VbMethod, var1(), var2(), 0, retobject, namarg, bstack.IamAnEvent, oUnk)
 

End If
If Not retobject Is Nothing Then
    Y3 = IsLabelSymbolNew(rest$, "лецецомота", "WITHEVENTS", language)
    If groupok And Y3 Then
            MyEr "not withevents as group member", "ЭВИ ЛЕ ЦЕЦОМЭТА СЕ ЛщКОР ОЛэДАР"
            Exit Sub
    End If
     If IsLabelSymbolNew(rest$, "ыс", "AS", language) Then
            Glob = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", language)
            If groupok And Glob Then
                    MyEr "not GLOBAL for group member", "ЭВИ цемийг ЦИА ЛщКОР ОЛэДАР"
                    Exit Sub
            End If
            newvar = IsLabelSymbolNew(rest$, "мео", "NEW", language)
            If groupok And newvar Then
                    MyEr "not new for group member", "ЭВИ МщО ЦИА ЛщКОР ОЛэДАР"
                    Exit Sub
            End If
             If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                If Not Not groupok Then
                ElseIf prive Then
                    what$ = bstack.GroupName + ChrW(&HFFBF) + what$
                Else
                    what$ = bstack.GroupName + what$
                End If
                        If newvar Then
                            it = globalvar(what$, 0, , Glob)
                            Set var(it) = retobject
                        ElseIf GetVar(bstack, what$, it) Then
                            Set var(it) = retobject
                        Else
                            it = globalvar(what$, 0, , Glob)
                            Set var(it) = retobject
                        End If
                            
                                If Y3 <> 0 Then
                                            Dim ev As ComShinkEvent
                                    If GetShink(ev, it, what$) Then
                                            ' private
                                            ' no need for a name, we do not address it in any way.
                                            ' ev knows how to call handler
                                            If newvar Then
                                                it = globalvarGroup(ChrW(&HFFBF) + "_" + what$, s$, , Glob)
                                            ElseIf Not GetVar(bstack, ChrW(&HFFBF) + "_" + what$, it) Then
                                                        
                                                        it = globalvarGroup(ChrW(&HFFBF) + "_" + what$, s$, , Glob)
                                                        End If
                                                        
                                                    Set var(it) = ev
                                     Else
                                            MyEr "Can't handle events here", "дЕМ ЛПОЯЧ МА ВЕИЯИСТЧ ЦЕЦОМЭТА"
                                            ok = False
                                             
                                         '   End Sub
                                     End If
                                End If
            End If
     End If
Else
     If MemInt(VarPtr(oUnk)) <> 0 Then
     Set result = oUnk
     End If
     If IsLabelSymbolNew(rest$, "ыс", "AS", language) Then
             Glob = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", language)
             If groupok And Glob Then
                    MyEr "not GLOBAL for group member", "ЭВИ цемийг ЦИА ЛщКОР ОЛэДАР"
                    Exit Sub
             End If
             newvar = IsLabelSymbolNew(rest$, "мео", "NEW", language)
              If groupok And newvar Then
                    MyEr "not new for group member", "ЭВИ МщО ЦИА ЛщКОР ОЛэДАР"
                    Exit Sub
                End If
             Dim rA As refArray
             x1 = Abs(IsLabel(bstack, rest$, what$))
                If Not groupok Then
                ElseIf prive Then
                    what$ = bstack.GroupName + ChrW(&HFFBF) + what$
                Else
                    what$ = bstack.GroupName + what$
                End If
             
             
             Select Case x1
             Case 1
                               If newvar Then
                                    globalvar what$, result, , Glob
                                ElseIf GetVar(bstack, what$, it) Then
                                    var(it) = result
                                    
                                Else
                                    If (MemInt(VarPtr(result)) And vbArray) <> 0 Then
                                        If (MemInt(ArrPtr(result))) = 1 Then
                                        Set rA = New refArray
                                            rA.Value(0) = result
                                            'ra.flat = True
                                            Set result = rA
                                        End If
                                    End If
                                    globalvar what$, result, , Glob
                                    
                                    
                                End If
              Case 4
                                If newvar Then
                                    globalvar what$, Int(result), , Glob
                                ElseIf GetVar(bstack, what$, it) Then
                                    var(it) = Int(result)
                                Else
                                    globalvar what$, Int(result), , Glob
                                    
                                End If
              Case 3
                                If newvar Then
                                    globalvar what$, result, , Glob
                                ElseIf GetVar(bstack, what$, it) Then
                                    var(it) = result
                                Else
                                    globalvar what$, result, , Glob
                                End If
              Case 5
                    If newvar Then
                        MyEr "not new for arrays", "ЭВИ МЕО ЦИА ПъМАЙЕР"
                        Exit Sub
                    End If
                    bstack.soros.PushVal result
                    s$ = BlockParam(rest$)
                    L = Len(s$)
                    MyRead 6, bstack, what$ + s$ + ")", language, what$, x1
                    Mid$(rest$, 1, L) = space(L)
                    FastSymbol rest$, ")", True
             Case 8
                    If newvar Then
                        MyEr "not new for RefArrays", "ЭВИ МЕО ЦИА ПъМАЙЕР ЛЕ []"
                        Exit Sub
                    End If
                    bstack.soros.PushVal result
again1:
                    s$ = BlockParamSq(rest$)
                    L = Len(s$)
                    Mid$(rest$, 1, L) = space(L)
                    FastSymbol rest$, "]", True
                    what$ = what$ + "[" + s$ + "]"
                    If FastSymbol(rest$, "[") Then GoTo again1
                    MyRead 6, bstack, what$, language, what$, x1
                    
              End Select
            
    End If
End If
End Sub

Sub RealMeth(bstack As basetask, rest$, var2() As Variant, var3() As String, NoNameditems As Long, namedargument As Long, ok As Boolean)
'  testmeth "122,&beta,121,alfa:=a+4, beta:=122"
Dim s$
Dim mm As mArray, usehandler As mHandler
Dim trap As Long, ss$, p As Variant, items As Long, ref As Boolean, I As Long, z As Variant, c As Long
ok = True
Do
again:
If FastSymbol(rest$, ",") Then
' second, or more is optional
        
        items = items + 1
        If UBound(var2()) < items Then ReDim Preserve var2(items + 1)
        OptVariant var2(items - 1)
        If namedargument = 0 Then NoNameditems = NoNameditems + 1
        GoTo again
End If
I = 1
If MaybeIsSymbol2(rest$, "&", I) Then
    If Not Mid$(rest$, I + 1, 2) Like "[hH][0123456789abcdefABCDEF]" Then
        ref = FastSymbol(rest$, "&")
    End If
End If
s$ = aheadstatus(rest$) + " "
Select Case Left$(s$, 1)
Case "S"
        If (trap Mod 2 = 0) And namedargument > 0 Then Exit Do  ' is a fault
        If ref Then
            I = IsLabel(bstack, rest$, ss$)
            If I > 0 Then
                If I > 4 Then If Not FastSymbol(rest$, ")", True) Then Exit Sub
                GetVar bstack, ss$, I
                c = 1
again2:
                If MyIsObject(var(I)) Then
                    If TypeOf var(I) Is mHandler Then
                        Set usehandler = var(I)
                        If usehandler.indirect <> -1 Then
                            I = usehandler.indirect
                            c = c + 1
                            If c < 20 Then Set usehandler = Nothing: GoTo again2 Else InternalError: Exit Sub
                        End If
                        If usehandler.T1 = 3 Then
                            Set mm = usehandler.objref
                            mm.ExportStringArrayNow
                            mm.refArray = vbNullString
                            Set var2(items) = mm
                            Set mm = Nothing
                        Else
                            VarByRef VarPtr(var2(items)), var(I)
                        End If
                        Set usehandler = Nothing
                    ElseIf TypeOf var(I) Is mArray Then
                            Set mm = var(I)
                            mm.ExportStringArrayNow
                            mm.refArray = vbNullString
                            Set var2(items) = var(I)
                            Set mm = Nothing
                    Else
                        VarByRef VarPtr(var2(items)), var(I)
                    End If
                ElseIf VarType(var(I)) = vbDecimal Then
                    VarByRefDecimal VarPtr(var2(items)), var(I)
                Else
                    VarByRef VarPtr(var2(items)), var(I)
                End If
                If namedargument = 0 Then NoNameditems = NoNameditems + 1
            Else
                NoReference
                ok = False
                Exit Sub
            End If
        ElseIf IsStrExp(bstack, rest$, ss$) Then
        If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mArray Then
        Set mm = bstack.lastobj
        If mm.Arr Then
        mm.ExportStringArrayNow
        mm.refArray = 0&
        End If
        Set var2(items) = mm
        Set mm = Nothing
        
        Else
        var2(items) = ss$
        End If
        Else
        
            var2(items) = ss$
            End If
           If namedargument = 0 Then NoNameditems = NoNameditems + 1
        Else
            var2(items) = vbNullString
            s$ = vbNullString
        End If
        If trap > 0 Then trap = trap + 1
        items = items + 1
        If UBound(var2()) < items Then ReDim Preserve var2(items + 1)
Case "N"
        ' maybe is a named argument

        c = 1
        I = FastPureLabel(rest$, ss$, c, , , , False)
            If I > 0 Then
               If Mid$(rest$, c, 2) = ":=" Then
                    I = IsLabel(bstack, rest$, ss$)
                    rest$ = Mid$(rest$, 3)
                    
                    namedargument = namedargument + 1
                    If UBound(var3()) < namedargument Then ReDim Preserve var3(namedargument + 1)
                    var3(namedargument) = ss$
                    trap = 1
                    GoTo again
                Else
                   If ref Then
                   I = IsLabel(bstack, rest$, ss$)
                   If I > 4 Then If Not FastSymbol(rest$, ")", True) Then Exit Sub
                   GetVar bstack, ss$, I
                    
                    c = 1
again3:
                    If varhash.vType(varhash.Index) = False Then
                    
                VarByRefVariant VarPtr(var2(items)), var(I)
                ElseIf MyIsObject(var(I)) Then
                        If TypeOf var(I) Is mHandler Then
                            Set usehandler = var(I)
                            If usehandler.indirect <> -1 Then
                                I = var(I).indirect
                                c = c + 1
                                If c < 20 Then Set usehandler = Nothing: GoTo again3 Else InternalError: Exit Sub
                            End If
                            If usehandler.T1 = 3 Then
                                Set mm = usehandler.objref
                                mm.ExportArrayNow
                                Set var2(items) = mm
                                Set mm = Nothing
                            ElseIf usehandler.T1 = 4 Then
                               ' usehandler.sign * usehandler.index_cursor
                                  var2(items) = usehandler.sign * usehandler.index_cursor
                            Else
                                VarByRef VarPtr(var2(items)), var(I)
                            End If
                            Set usehandler = Nothing
                        ElseIf TypeOf var(I) Is mArray Then
                            Set mm = var(I)
                            mm.ExportArrayNow
                            Set var2(items) = var(I)
                            Set mm = Nothing
                        Else
                                VarByRef VarPtr(var2(items)), var(I)
                        End If
                    ElseIf VarType(var(I)) = vbDecimal Then
                        VarByRefDecimal VarPtr(var2(items)), var(I)
                    Else
                    
                        VarByRef VarPtr(var2(items)), var(I)
                    End If
                    If namedargument = 0 Then NoNameditems = NoNameditems + 1


                ElseIf Not ((trap Mod 2 = 0) And namedargument > 0) Then
                    If IsExp(bstack, rest$, p) Then
                        If bstack.lastobj Is Nothing Then
                             var2(items) = p
                        Else
                        If TypeOf bstack.lastobj Is mHandler Then
                            Set usehandler = bstack.lastobj

                            If usehandler.T1 = 4 Then
                                var2(items) = p
                            ElseIf usehandler.T1 = 3 Then
                                Set mm = usehandler.objref
                                Set var2(items) = mm
                                Set mm = Nothing
                            Else
                            Set var2(items) = bstack.lastobjIndirect(var())
                            End If
                        ElseIf TypeOf bstack.lastobj Is mArray Then
                            Set mm = bstack.lastobj
                            mm.refArray = 0&
                            mm.IsByValue = True
                            Set var2(items) = mm
                            Set mm = Nothing
                        Else
                            Set var2(items) = bstack.lastobj
                        End If
                        Set bstack.lastobj = Nothing
                    End If
                    If namedargument = 0 Then NoNameditems = NoNameditems + 1
                          If trap > 0 Then trap = trap + 1
                    End If
                Else
                    Exit Do
                End If
            End If
        Else
            If Not ((trap Mod 2 = 0) And namedargument > 0) Then
                If IsExp(bstack, rest$, p) Then
                    If Not bstack.lastobj Is Nothing Then
                    Set var2(items) = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    Else
                    var2(items) = p
                    End If
                    If namedargument = 0 Then NoNameditems = NoNameditems + 1
                    If trap > 0 Then trap = trap + 1
                Else
                    Exit Do
                End If
            Else
                Exit Do
            End If
        End If
        items = items + 1
        If UBound(var2()) < items Then ReDim Preserve var2(items + 1)
    End Select
    If Not FastSymbol(rest$, ",") Then Exit Do
Loop Until s$ = vbNullString
End Sub


Function ReadProp(fromIndex As Long, ByVal propIndex As Long, RETVAR As Variant) As Boolean
Dim o As Object, er$, usehandler As mHandler
On Error GoTo there
Set o = var(fromIndex)
If o Is Nothing Then

Exit Function
End If
If TypeOf o Is mHandler Then
0   Set usehandler = o
propIndex = -propIndex
If usehandler.UseIterator Then
Else
Set o = usehandler.objref
End If
Set usehandler = Nothing
End If
If o Is Nothing Then Exit Function
If TypeOf o Is ExtControl Then
Set o = o.Value
ElseIf TypeOf o Is PropReference Then
    If o.IsObj Then Set o = o.Value
End If
er$ = vbNullString
RETVAR = Empty
ReadProp = ReadOneParameter(o, propIndex, er$, RETVAR)
If MyIsObject(RETVAR) Then
If RETVAR Is Err Then
        Set errbag = New ErrorBag
        errbag.CopyErr
        Set RETVAR = errbag
        Set errbag = Nothing
        Err.Clear
End If
End If
If er$ <> "" Then
there:
BadGetProp
End If
End Function
Function ReadPropIndex(fromIndex As Long, ByVal propIndex As Long, myIndex As Variant, Optional maybeObject As Boolean, Optional retObj) As Variant
Dim o As Object, er$, check As Boolean, usehandler As mHandler
On Error GoTo there
Set o = var(fromIndex)
If o Is Nothing Then Exit Function
If TypeOf o Is mHandler Then
propIndex = -propIndex
Set usehandler = o
Set o = usehandler.objref
Set usehandler = Nothing
End If
er$ = vbNullString
check = True
If TypeOf o Is ExtControl Then
Set o = o.Value
ElseIf TypeOf o Is PropReference Then
Dim pp
pp = o.Value
Set o = o.lastobjfinal
End If
ReadPropIndex = ReadOneIndexParameter(o, propIndex, er$, myIndex, , check)

If Not check Then
    maybeObject = True
    ReadPropIndex = 0
    Set retObj = o
End If
If er$ <> "" Then
there:
BadGetProp
End If
End Function
Sub WriteProp(fromIndex As Long, ByVal propIndex As Long, Anyval As Variant)
Dim o As Object, er$, usehandler As mHandler
Set o = var(fromIndex)
If o Is Nothing Then Exit Sub
If TypeOf o Is mHandler Then
propIndex = -propIndex
Set usehandler = o
If usehandler.UseIterator Then
Else
Set o = usehandler.objref
End If
Set usehandler = Nothing
End If
'ChangeOneIndexParameter
If TypeOf o Is ExtControl Then
Set o = o.Value
End If
ChangeOneParameter o, propIndex, Anyval, er$
If er$ <> "" Then
BadLetProp
End If
End Sub
Sub WritePropIndex(fromIndex As Long, ByVal propIndex As Long, Anyval As Variant, myIndex)
Dim o As Object, er$, usehandler As mHandler
Set o = var(fromIndex)
If o Is Nothing Then Exit Sub
If TypeOf o Is mHandler Then
propIndex = -propIndex
Set usehandler = o
Set o = usehandler.objref
Set usehandler = Nothing
End If
If TypeOf o Is ExtControl Then
Set o = o.Value
End If
ChangeOneIndexParameter o, propIndex, Anyval, er$, myIndex
If er$ <> "" Then
BadLetProp
End If
End Sub
Function ReadPropIndexObj(o As Object, ByVal propIndex As Long, myIndex) As Variant
Dim er$
er$ = vbNullString
If TypeOf o Is ExtControl Then
Set o = o.Value
End If
 ReadPropIndexObj = ReadOneIndexParameter(o, propIndex, er$, myIndex)
If er$ <> "" Then
BadGetProp
End If
End Function
Function ReadPropObj(o As Object, ByVal propIndex As Long, RETVAR As Variant) As Boolean
Dim er$
If TypeOf o Is ExtControl Then
Set o = o.Value
End If
er$ = vbNullString
ReadPropObj = ReadOneParameter(o, propIndex, er$, RETVAR)
If MyIsObject(RETVAR) Then
If RETVAR Is Err Then
        Set errbag = New ErrorBag
        errbag.CopyErr
        Set RETVAR = errbag
        Set errbag = Nothing
        Err.Clear
End If
End If
If er$ <> "" Then
BadGetProp
End If
End Function
Sub WritePropObj(o As Object, ByVal propIndex As Long, Anyval As Variant)
Dim er$
If TypeOf o Is ExtControl Then
Set o = o.Value
End If
ChangeOneParameter o, propIndex, Anyval, er$
If er$ <> "" Then
BadLetProp
End If
End Sub
Sub WritePropIndexObj(o As Object, ByVal propIndex As Long, Anyval As Variant, myIndex)
Dim er$
If TypeOf o Is ExtControl Then
Set o = o.Value
End If
ChangeOneIndexParameter o, propIndex, Anyval, er$, myIndex
If er$ <> "" Then
BadLetProp
End If
End Sub

Sub MakeThisSub(ThatStack As basetask, rest$)

If Left$(rest$, 5) = "THIS." Then
Dim s$
If ThatStack.GetDotNew(s$, 1) Then

    rest$ = s$ + Mid$(rest$, 6)
    ElseIf ThatStack.GroupName = vbNullString Then
        rest$ = ThatStack.UseGroupname + Mid$(rest$, 6)
    Else
        rest$ = ThatStack.GroupName + Mid$(rest$, 6)
    End If

ElseIf Left$(rest$, 5) = "ауто." Then

If ThatStack.GetDotNew(s$, 1) Then

    rest$ = s$ + Mid$(rest$, 6)
    ElseIf ThatStack.GroupName = vbNullString Then
    rest$ = ThatStack.UseGroupname + Mid$(rest$, 6)

Else

    rest$ = ThatStack.GroupName + Mid$(rest$, 6)
End If

Else

End If
End Sub
Sub MakeThisSub1(ThatStack As basetask, rest$)
Dim s$
If Len(rest$) < 7 Then Exit Sub
s$ = myUcase(Left$(rest$, 5), AscW(rest$) < 128)
If s$ = "THIS." Then
s$ = vbNullString
If ThatStack.GetDotNew(s$, 1) Then

    rest$ = s$ + Mid$(rest$, 6)
    ElseIf ThatStack.GroupName = vbNullString Then
        rest$ = ThatStack.UseGroupname + Mid$(rest$, 6)
    Else
        rest$ = ThatStack.GroupName + Mid$(rest$, 6)
    End If

ElseIf s$ = "ауто." Then
s$ = vbNullString
If ThatStack.GetDotNew(s$, 1) Then

    rest$ = s$ + Mid$(rest$, 6)
    ElseIf ThatStack.GroupName = vbNullString Then
    rest$ = ThatStack.UseGroupname + Mid$(rest$, 6)

Else

    rest$ = ThatStack.GroupName + Mid$(rest$, 6)
End If
End If
End Sub
Sub MakeThisSubNum(ThatStack As basetask, rest$)
If Left$(rest$, 1) = "T" Then
If Left$(rest$, 5) = "THIS." Then
    If Len(ThatStack.UseGroupname) > 0 Then
        rest$ = ThatStack.UseGroupname + Mid$(rest$, 6)
    Else
        rest$ = ThatStack.GroupName + Mid$(rest$, 6)
    End If
    End If
ElseIf Left$(rest$, 1) = "а" Then
If Left$(rest$, 5) = "ауто." Then
    If Len(ThatStack.UseGroupname) > 0 Then
       rest$ = ThatStack.UseGroupname + Mid$(rest$, 6)
    Else
        rest$ = ThatStack.GroupName + Mid$(rest$, 6)
    End If
End If
End If
End Sub
Function ColorHSL(bstack As basetask, n$, r As Variant) As Boolean
    Dim R2 As Variant, R3 As Variant, ss$, par As Boolean
    ColorHSL = True
    If IsExp(bstack, n$, r, , True) Then
        If FastSymbol(n$, ",") Then
            If IsExp(bstack, n$, R2, , True) Then
                If R2 < 0 Then R2 = 0
                If R2 > 100 Then R2 = 100
                If FastSymbol(n$, ",") Then
                    If IsExp(bstack, n$, R3, , True) Then
                        If R3 < 0 Then R3 = 0
                        If R3 > 100 Then R3 = 100
                        par = True
                        r = HSL(r, R2, R3)
                    End If
                End If
            End If
        End If
    End If
    If Not par Then ColorHSL = False: MissNumExpr: Exit Function
End Function
Function ColorRGB(bstack As basetask, n$, r As Variant) As Boolean
Dim R2 As Variant, R3 As Variant, ss$, par As Boolean
ColorRGB = True
    If IsExp(bstack, n$, r, , True) Then
            par = True
            If FastSymbol(n$, ",") Then
            par = IsExp(bstack, n$, R2, , True)
            If par And FastSymbol(n$, ",") Then
            par = IsExp(bstack, n$, R3, , True)
            End If
            r = rgb(Abs(r Mod 256), Abs(R2 Mod 256), Abs(R3 Mod 256))
            Else
            r = mycolor(r)
            End If
            If Not par Then ColorRGB = False: Exit Function
            
    ElseIf IsStrExp(bstack, n$, ss$) Then
            ' value in hexadecimal input as in html RGB
            ' we have to make BGR
    
            ss$ = Right$("00000000" + ss$, 8)
   r = CDbl(UNPACKLNG(Right$(ss$, 2)) * 65536#) + CDbl(UNPACKLNG(Mid$(ss$, 5, 2)) * 256#) + CDbl(UNPACKLNG(Mid$(ss$, 3, 2)))
   
         
             Else
              ColorRGB = False
              
    End If
End Function

Function globalArrByPointer(bs As basetask, basestack As basetask, what$, Optional newonly As Boolean = False, Optional checkforglobal As Boolean) As Boolean
Dim pppp As mArray, ppppAny As iBoxArray, myobject As Object, wasAglobal As Boolean
Dim Ar As refArray
   If bs.IsObjectRef(myobject) Then
   If newonly Then GoTo there1
   
             If neoGetArray(basestack, what$, ppppAny, , , , , wasAglobal) Then
             If Not checkforglobal Then If wasAglobal Then GoTo there1
                    If Not ppppAny Is Nothing Then
                        If TypeOf myobject Is mHandler Then
                        If CheckIsmArray(myobject) Then
                            Set var(varhash.lastNDX) = myobject
                            var(varhash.lastNDX).common = ppppAny.common
                            Else
                                  NotArray
                                  Exit Function
                        
                        End If
                        ElseIf TypeOf myobject Is mArray Then
                        Set pppp = ppppAny
                        myobject.CopyArray pppp
                        Else
                        NotArray
                        globalArrByPointer = False
                        Set myobject = Nothing
                        Exit Function
                        End If
                        Set myobject = Nothing
                        globalArrByPointer = True
                    End If
            Else
there1:
      
                GlobalArr basestack, basestack.GroupName + what$, "", 0, -1
                If neoGetArray(basestack, what$, pppp) Then  ''basestack.GroupName &
                        If TypeOf myobject Is mHandler Then
                        If CheckIsmArray(myobject) Then
                            Set var(varhash.lastNDX) = myobject
                                  Else
                                  NotArray
                                  Exit Function
                        
                        End If
                        ElseIf TypeOf myobject Is refArray Then
                        Set Ar = myobject
                        Set Ar = Ar.Copy()
                        If Ar.count = 1 Then
                            pppp.MyTypeToBe = Ar.vtType(0)
                            pppp.PushDim Ar.count(0)
                            Ar.Value = Ar.Value(0)
                            Ar.flat = True
                            
                            pppp.PushEnd Ar
                           
                        Else
                            MyEr "RefArray has more dimensions than one", "о RefArray щВЕИ ПЕЯИССЭТЕЯЕР ДИАСТэСЕИР АПЭ ЛИА"
                            Exit Function
                        End If
                        ElseIf TypeOf myobject Is mArray Then
                        
                        myobject.CopyArray pppp
                        Else
                        NotArray
                        globalArrByPointer = False
                        Set myobject = Nothing
                        Exit Function
                         End If
                         globalArrByPointer = True
                        Set myobject = Nothing
                End If
                
             End If
      
    End If
End Function
Public Sub CopyHandler(f As Variant, bstack As basetask)
Dim aa As mHandler, bb As mHandler
Set aa = f
aa.CopyTo bb
Set bstack.lastobj = bb
Set aa = Nothing
Set bb = Nothing
End Sub
Public Function CopyHandlerObj(f As Variant) As Object
Dim aa As mHandler, bb As mHandler
Set aa = f
aa.CopyTo bb
Set CopyHandlerObj = bb
Set aa = Nothing
Set bb = Nothing
End Function
Public Sub CopyLambdaAny(f As Variant, obj As Object)
Dim aa As lambda, bb As lambda
Set aa = f
aa.CopyTo bb, var()
Set obj = bb
Set aa = Nothing
Set bb = Nothing
End Sub
Public Sub CopyLambda(f As Variant, bstack As basetask)
Dim aa As lambda, bb As lambda
Set aa = f
aa.CopyTo bb, var()
Set bstack.lastobj = bb
Set aa = Nothing
Set bb = Nothing
End Sub

Public Sub CopyGroup2(mg As Variant, bstack As basetask)
Dim myGroup As Group
Set myGroup = mg
If myGroup.IamSuperClass Or myGroup.IamApointer Then
    Set bstack.lastobj = mg
    Exit Sub
End If
Dim K As Group, I As Long, j As Long, s$, w3 As Long, w1 As Integer
Dim b$(), vvl As Variant, delme As Document, myfirstArray As mArray, mySecondArray As mArray

Set K = New Group
'Set k.Sorosref = myGroup.soros.Copy
Dim BI As Long
BI = 1

'i = myGroup.soros.Total
I = myGroup.FieldsCount
K.BeginFloat I + 2
K.PokeItem 0, "Variables-Arrays"
K.PokeItem 1, I
Dim usevariant As Boolean
For j = 2 To I * 2 + 1 Step 2
'Debug.Print k.soros.StackItem(BI), BI
'Debug.Print myGroup.ReadField(BI), BI
    b$() = Split(myGroup.ReadField(BI), " ")
    w3 = Abs(val(b$(1)))
    w1 = AscW(Right$(b$(0), 1))
    If w1 = 41 Then
        b$(0) = Left$(b$(0), Len(b$(0)) - 1)
    End If
    If w1 <> 40 Then
        s$ = VarTypeName(var(w3))
        K.PokeItem j, b$(0)
        If s$ = doc Then 'preserve Documents
            MakeitObject vvl
            vvl.EmptyDoc
            vvl.textDoc = var(w3).textDoc
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        ElseIf s$ = mGroup Then
            vvl = -1
            CopyGroup2 var(w3), bstack
            Set vvl = bstack.lastobj
            Set bstack.lastobj = Nothing
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        ElseIf s$ = mHdlr Then
            Set vvl = CopyHandlerObj(var(w3))
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        Else
            K.PokeItem j + 1, var(w3)
        End If
    Else
        If w3 = 0 Then
            Set vvl = New mArray   '' empty array
        Else
            s$ = VarTypeName(var(w3))
            If s$ = "Empty" Then
            ElseIf s$ = myArray Then
                Set myfirstArray = var(w3)
                If Not myfirstArray.common Then
                    Set mySecondArray = New mArray
                    myfirstArray.CopyArray mySecondArray
                    Set myfirstArray = Nothing
                    Set vvl = mySecondArray
                    Set mySecondArray = Nothing
                Else
                    Set vvl = myfirstArray
                End If
            Else
                If MyIsObject(var(w3)) Then Set vvl = var(w3)
            End If
        End If
        K.PokeItem j, b$(0) + ")"
        K.PokeItem j + 1, vvl
        Set vvl = Nothing
        vvl = Empty
    End If
    BI = BI + 1
Next j
With myGroup
    K.PokeItem j, myGroup.localList
    K.PokeItem j + 1, GetFunctionList(.FuncList)
    K.oldFuncRef = vbNullString
    K.HasStrValue = .HasStrValue
    K.HasValue = .HasValue
    K.HasSet = .HasSet
    K.HasParameters = .HasParameters
    K.HasParametersSet = .HasParametersSet
    K.HasRemove = .HasRemove
    Set K.SuperClassList = .SuperClassList
    Set K.Events = .Events
    K.highpriorityoper = .highpriorityoper
    K.HasUnary = .HasUnary
    K.PointerPtr = ObjPtr(mg)
    K.ToDelete = True
    'Set k.mytypes = .mytypes
    K.mergeTypes .mytypes
End With
Set bstack.lastobj = K
End Sub
Public Function CopyGroupObj(mg As Variant, Optional nofunc As Boolean = False) As Object
Dim myGroup As Group
If Not myVarType(mg, vbObject) Then Exit Function
If mg Is Nothing Then Exit Function
If Not TypeOf mg Is Group Then
Set CopyGroupObj = mg: Exit Function
End If
Set myGroup = mg
If myGroup.IamSuperClass Or myGroup.IamApointer Then
    Set CopyGroupObj = myGroup
    
    Exit Function
End If
If myGroup.IamFloatGroup Then
    Set CopyGroupObj = myGroup
    
    Exit Function

End If
Dim Name$, K As Group, I As Long, j As Long, s$, w3 As Long, w1 As Integer
Dim b$(), vvl As Variant
Set K = New Group
'Set k.Sorosref = myGroup.soros.Copy
Dim BI As Long
BI = 1
I = myGroup.FieldsCount 'myGroup.soros.Total
K.BeginFloat I + 2
K.PokeItem 0, "Variables-Arrays"
K.PokeItem 1, I
For j = 2 To I * 2 + 1 Step 2
    b$() = Split(myGroup.ReadField(BI), " ")
    w3 = Abs(val(b$(1)))
    w1 = AscW(Right$(b$(0), 1))
    If w1 = 41 Then
        b$(0) = Left$(b$(0), Len(b$(0)) - 1)
    End If
    If w1 <> 40 Then
        K.PokeItem j, b$(0)
        s$ = VarTypeName(var(w3))
        If s$ = doc Then 'preserve Documents
            MakeitObject vvl
            vvl.EmptyDoc
            vvl.textDoc = var(w3).textDoc
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        ElseIf s$ = mGroup Then
            vvl = -1
            Set vvl = CopyGroupObj(var(w3))
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        ElseIf s$ = mHdlr Then
            Set vvl = CopyHandlerObj(var(w3))
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        Else
            K.PokeItem j + 1, var(w3)
        End If
    Else
        If w3 = 0 Then
            Set vvl = New mArray   '' empty array
        Else
            If myVarType(var(w3), vbEmpty) Then
            Else
                Set vvl = var(w3)
            End If
            K.PokeItem j, b$(0) + ")"
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        End If
    End If
    BI = BI + 1
Next j
With myGroup
    K.PokeItem j, myGroup.localList
    If nofunc Then
    Else
        If ChangedFunctionList(.FuncList) Then
            K.PokeItem j + 1, GetFunctionList(.FuncList)
        Else
            If .oldFuncRef <> vbNullString Then
                K.PokeItem j + 1, .oldFuncRef
                K.oldFuncRef = vbNullString
            Else
                K.PokeItem j + 1, GetFunctionList(.FuncList)
            End If
        End If
    End If
    K.HasStrValue = .HasStrValue
    K.HasValue = .HasValue
    K.HasSet = .HasSet
    K.HasParameters = .HasParameters
    K.HasParametersSet = .HasParametersSet
    K.HasRemove = .HasRemove
    Set K.SuperClassList = .SuperClassList
    Set K.Events = .Events
    K.highpriorityoper = .highpriorityoper
    K.HasUnary = .HasUnary
    K.PointerPtr = ObjPtr(mg)
    K.ToDelete = False
    Set K.mytypes = .mytypes
End With
Set CopyGroupObj = K
End Function



Public Function CopyGroup0Obj(mg As Variant, usethisk As Variant) As Object
Dim myGroup As Group, grgroup As Group
Set myGroup = mg
Dim Name$, K As Group, BI As Long, j As Long, s$, w3 As Long, w1 As Integer
Dim b$(), vvl As Variant
If TypeOf usethisk Is Group Then
    Set K = usethisk
Else
    Set K = New Group
End If

BI = 1
If Not K.IamFloatGroup Then Exit Function
    K.PokeItem 0, "Variables-Arrays"
    For j = 2 To myGroup.FieldsCount * 2 + 1 Step 2
        b$() = Split(myGroup.ReadField(BI), " ")
        w3 = Abs(val(b$(1)))
        w1 = AscW(Right$(b$(0), 1))
        If w1 = 41 Then
            b$(0) = Left$(b$(0), Len(b$(0)) - 1)
        End If
            If w1 <> 40 Then
            s$ = VarTypeName(var(w3))
            If s$ = doc Then 'preserve Documents
            ElseIf s$ = mGroup Then
                vvl = -1
                K.PeekItem j + 1, vvl
                CopyGroup0Obj var(val(b$(1))), vvl
                Set vvl = Nothing
                vvl = Empty
            ElseIf s$ = mHdlr Then
                Set vvl = CopyHandlerObj(var(w3))
                K.PokeItem j + 1, vvl
                Set vvl = Nothing
                vvl = Empty
            Else
                K.PokeItem j + 1, var(w3)
            End If
    Else
        If w3 = 0 Then
            Set vvl = New mArray
        Else
            If myVarType(var(w3), vbEmpty) Then
            Else
                Set vvl = var(w3)
            End If
            K.PokeItem j, b$(0) + ")"
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        End If
    End If
    BI = BI + 1
Next j
Set CopyGroup0Obj = K

End Function
Public Function CopyGroup1(mg As Variant, usethisk As Variant) As Object
Dim myGroup As Group, grgroup As Group
Set myGroup = mg
Dim Name$, K As Group, j As Long, s$, v As Variant, w3 As Long, w1 As Integer
Dim b$(), vvl As Variant
If TypeOf usethisk Is Group Then
    Set K = usethisk
Else
    Set K = New Group
End If
Dim BI As Long
BI = 1
If Not K.IamFloatGroup Then Exit Function
K.PokeItem 0, "Variables-Arrays"
For j = 2 To myGroup.FieldsCount * 2 + 1 Step 2
    b$() = Split(myGroup.ReadField(BI), " ")
    w3 = Abs(val(b$(1)))
    w1 = AscW(Right$(b$(0), 1))
    If w1 = 41 Then
        b$(0) = Left$(b$(0), Len(b$(0)) - 1)
    End If
    If w1 <> 40 Then
        s$ = VarTypeName(var(w3))
        If s$ = doc Then 'preserve Documents
        ElseIf s$ = mGroup Then
            vvl = -1
            K.PeekItem j + 1, vvl
            Set CopyGroup1 = CopyGroup1(var(w3), vvl)
            Set vvl = Nothing
            vvl = Empty
        ElseIf s$ = mHdlr Then
            Set vvl = CopyHandlerObj(var(w3))
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        Else
            K.PokeItem j + 1, var(w3)
        End If
    Else
        If w3 = 0 Then
            Set vvl = New mArray   '' empty array
        Else
            
            If myVarType(var(w3), vbEmpty) Then
            Else
                Set vvl = var(w3)
            End If
            K.PokeItem j, b$(0) + ")"
            K.PokeItem j + 1, vvl
            Set vvl = Nothing
            vvl = Empty
        End If
    End If
    BI = BI + 1
Next j
Set CopyGroup1 = K
End Function
Sub UnFloatGroup(bstack As basetask, what$, I As Long, myobject1 As Object, Optional Glob As Boolean = False, Optional Temp As Boolean = False, Optional MakeNew As Boolean)
Dim ThisGroup As Group, myobject As Group, it As Long
If (myobject1 Is Nothing) Then Exit Sub
If Not TypeOf myobject1 Is Group Then Exit Sub
Set myobject = myobject1

If myobject.IamApointer Then
    Set var(I) = myobject
    Exit Sub
End If
While Right$(what$, 1) = "."
    what$ = Left$(what$, Len(what$) - 1)
Wend
If Len(what$) = 0 Then Exit Sub
Dim v As Long, s$, frm$, vvl As Variant, x1 As Long, ss$, frmarr$, sss$, j As Long
Dim grtype As Variant, ps2push As String, uni As Boolean, uni1 As Boolean, other As Group
Dim UnhidePrivate As Boolean
If bstack.tpointer <> 0 Then
    x1 = bstack.tpointer
    If MyIsObject(var(x1)) Then
        If TypeOf var(x1) Is Group Then
            Set other = myobject
            Set ThisGroup = var(x1)
            UnhidePrivate = other.MatchTypes(ThisGroup.mytypes)
            Set other = Nothing
        End If
    End If
    x1 = 0
End If
Set var(I) = New Group
Set ThisGroup = var(I)
ThisGroup.IamGlobal = Glob
' check this again
ThisGroup.ToDelete = myobject.ToDelete
If Not myobject.SuperClassList Is Nothing Then
    Set ThisGroup.SuperClassList = myobject.SuperClassList
    If myobject Is Nothing Then Exit Sub
    If myobject.IamSuperClass Then Set myobject = myobject.SuperClassList: uni = True
End If
'Set ps = ThisGroup.soros
Dim subgroup As Object, pppp As mArray
Dim ohere$, oldgroupname$
ohere$ = here$

oldgroupname$ = bstack.GroupName
If bstack.GroupName <> "" Then

If Len(ohere$) = 0 Then
    ThisGroup.Patch = what$
Else
    ThisGroup.Patch = ohere$ + "." + what$
    End If
    bstack.GroupName = bstack.GroupName + what$ + "."
    
Else
    bstack.GroupName = what$ + "."
    If Glob Or Len(ohere$) = 0 Then
    ThisGroup.Patch = what$
    Else
    ThisGroup.Patch = ohere$ + "." + what$
    End If
End If
Dim usevariant As Boolean
With myobject
    ThisGroup.HasRemove = .HasRemove
    If .IamFloatGroup Then
        .PeekItem 0, grtype
        .PeekItem 1, vvl
        For x1 = 2 To 1 + vvl * 2 Step 2
            .PeekItem x1, vvl    'here is the name
            s$ = vvl
            If s$ = vbNullString Then InternalError: s$ = "asap"
            usevariant = False
            If Left$(s$, 1) = "#" Then s$ = Mid$(s$, 2): usevariant = True
            If Temp Then If Left$(s$, 1) = "@" Then s$ = Mid$(s$, 2)
            If uni Then
                uni1 = Left$(s$, 1) = "@"
                If Temp And uni1 Then
                    uni1 = False: s$ = Mid$(s$, 2)
                End If
            End If
            If uni1 Then GoTo cont1010
            .PeekItem x1 + 1, vvl  'here is the value
            frm$ = VarTypeName(vvl)
                
            If frm$ = myArray Then
                s$ = Left$(s$, Len(s$) - 1)
                ss$ = vbNullString
                j = -1
                If Temp Then
                    GlobalArr bstack, ThisGroup.Patch + "." + s$, ss$, 0, j, True
                    Set var(j) = vvl
                Else
                      Set subgroup = vvl
                      GlobalArr bstack, ThisGroup.Patch + "." + s$, ss$, 0, j, True
                      Set pppp = var(j)
                      subgroup.CopyArray pppp
                      Set subgroup = Nothing
                End If
                '
                If AscW(s$) = -65 And UnhidePrivate Then
                varhash.ItemCreator ThisGroup.Patch + "." + Mid$(s$, 2), j, True, , True
                End If
                If usevariant Then
                    'ps.DataStr "#" + s$ + " " + str(-j)
                    ThisGroup.Add2Field "#" + s$ + " " + str(-j)
                Else
                    'ps.DataStr s$ + str(j)
                    ThisGroup.Add2Field s$ + str(j)
                End If
            ElseIf frm$ = "lambda" Then
                v = globalvarGroup(ThisGroup.Patch + "." + s$, 0, , True)
isalambda:
                If AscW(s$) = -65 And UnhidePrivate Then
                    varhash.ItemCreator ThisGroup.Patch + "." + Mid$(s$, 2), v, True, , True
                    it = GlobalSub(ThisGroup.Patch + "." + Mid$(s$, 2) + "()", "", ThisGroup.Patch + ".", , v)
                Else
                    it = GlobalSub(ThisGroup.Patch + "." + s$ + "()", "", ThisGroup.Patch + ".", , v)
                    End If
                    sbf(it).tpointer = I
                GoTo conthere2
            ElseIf frm$ = mHdlr Then
                Set vvl = CopyHandlerObj(vvl)
                GoTo conthere1
            ElseIf frm$ = "mEvent" Then
                CopyEvent vvl, bstack
                Set vvl = bstack.lastobj
                Set bstack.lastobj = Nothing
                If here$ = vbNullString Then
                    vvl.Upgrade bstack.GroupName
                Else
                    vvl.Upgrade here$ + "." + bstack.GroupName
                End If
                GoTo conthere1
            Else  ' is not array so...
                If frm$ = mGroup Then
                    Set other = vvl
                    Dim spare As Object
                    If Left$(s$, 1) = "*" Then
                        v = globalvarGroup(ThisGroup.Patch + "." + Mid$(s$, 2), 0, , True)
                        If AscW(Mid$(s$, 2, 1)) = -65 And UnhidePrivate Then
                            globalvarGroup ThisGroup.Patch + "." + Mid$(s$, 3), v, True, True
                        End If
                        If other.IamApointer Then
                            If ThisGroup.ToDelete Then
                               myobject.PokeItem x1 + 1, 0
                               other.ToDelete = True
                            End If
                            Set var(v) = vvl
                        Else
                            Set spare = vvl
                            here$ = ThisGroup.Patch
                                ' check this too
                            other.ToDelete = ThisGroup.ToDelete
                            If AscW(Mid$(s$, 2, 1)) = -65 And UnhidePrivate Then
                                UnFloatGroup bstack, Mid$(s$, 3), v, spare, Glob, Temp, MakeNew
                            Else
                                UnFloatGroup bstack, Mid$(s$, 2), v, spare, Glob, Temp, MakeNew
                            End If
                            here$ = ohere$
                            Set other = Nothing
                            Set spare = Nothing
                        End If
                        'ps.DataStr s$ + str(v)
                        ThisGroup.Add2Field s$ + str(v)
                    Else
                        v = globalvarGroup(bstack.GroupName + s$, 0)
                        Set spare = vvl
                        here$ = ThisGroup.Patch
                        UnFloatGroup bstack, s$, v, spare, Glob, Temp, MakeNew
                        here$ = ohere$
                        Set spare = Nothing
                        'ps.DataStr "*" + s$ + str(v)
                        ThisGroup.Add2Field "*" + s$ + str(v)
                    End If
                Else
                    If Right$(s$, 2) = "()" Then
                        s$ = Left$(s$, Len(s$) - 1)
                    End If
conthere1:
                       
                    v = globalvarGroup(ThisGroup.Patch + "." + s$, 0, , True, , Not usevariant)
                    If UnhidePrivate And AscW(s$) = -65 Then
                        globalvarGroup ThisGroup.Patch + "." + Mid$(s$, 2), v, True, True, , Not usevariant
                    End If
                    
conthere2:
                    If MyIsObject(vvl) Then
                        Set var(v) = vvl
                        If Not vvl Is Nothing Then
                        If TypeOf vvl Is Constant Then
                        If myVarType(vvl.Value, vbObject) Then
                        Set vvl = vvl.Value
                        If Not vvl Is Nothing Then
                        If TypeOf vvl Is lambda Then
                        GoTo isalambda
                        End If
                        End If
                        End If
                        End If
                        
                        End If
                        
                        

                    Else
                        var(v) = vvl
                    End If
                    If usevariant Then
                        'ps.DataStr "#" + s$ + " " + str(-v)
                        ThisGroup.Add2Field "#" + s$ + " " + str(-v)
                    Else
                        'ps.DataStr s$ + str(v)
                        ThisGroup.Add2Field s$ + str(v)
                    End If
                End If
            End If
cont1010:
        Next x1
        If ohere$ = vbNullString Or Len(bstack.UseGroupname) > 0 Or Glob Then
            here$ = vbNullString
        Else
            here$ = ohere$
        End If
        If MyIsObject(vvl) Then
        Set vvl = Nothing
        End If
        .PeekItem x1, vvl
        If Trim$(vvl) <> "" Then
            s$ = CStr(vvl)
            ExecuteGroupStruct bstack, what$, (I), s$, 0, 1
        End If
        .PeekItem x1 + 1, vvl
        ' save definitions
        ThisGroup.oldFuncRef = vvl
        If Trim$(vvl) <> "" Then
            s$ = CStr(vvl)
            bstack.GroupName = vbNullString
            While s$ <> ""
                here$ = ThisGroup.Patch
                x1 = IsLabelA1("", s$, ss$)
                
                If x1 <> 0 Then
                    sss$ = s$
                    If Len(ss$) > 6 Then
                    j = 0
                        x1 = IsLabelA1("", s$, ss$)
                        If UnhidePrivate And AscW(ss$) = -65 Then
                        Mid$(sss$, Len(sss$) - Len(s$) - Len(ss$) + 1, 1) = " "
                        End If
                        frm$ = vbNullString
                        If MyFunction(-2 * (&H1FFF = AscW(ss$)), bstack, sss$, 1, True, MakeNew) Then '' >6 len for function
                            x1 = bstack.IndexSub
                            If FastSymbol(sss$, ChrW(&H1FFD)) Then
                                sbf(x1).locked = True
                                frm$ = " " + str$(-x1)
                            Else
                                frm$ = str$(x1)
                            End If
                            If Asc(s$) <> 32 Then
                                If InStr(s$, " ") = 2 Then
                                    ss$ = ss$ + Left$(s$, 1)
                                    s$ = Mid$(s$, 2)
                                Else
                                    ss$ = ss$ + Left$(s$, 2)
                                    s$ = Mid$(s$, 3)
                                End If
                            End If
                            If sbf(x1).sbgroup = here$ + "." Then
                                If InStr(ThisGroup.FuncList, Chr$(2) + ss$ + "() ") = 0 Then
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + "()" + frm$ + Chr$(1) + ThisGroup.FuncList
                                End If
                            Else
                                ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + "()" + frm$ + Chr$(1) + ThisGroup.FuncList
                                sbf(x1).sbgroup = here$ + "."
                                sbf(x1).tpointer = I
                            End If
                        Else
                            x1 = 0
                        End If
                    Else
                        x1 = IsLabelA1("", s$, ss$)
                        If UnhidePrivate And AscW(ss$) = -65 Then
                        Mid$(sss$, Len(sss$) - Len(s$) - Len(ss$) + 1, 1) = " "
                        End If
                        If MyModule(bstack, sss$, 1, True, MakeNew) Then
                            x1 = bstack.IndexSub
                            sbf(x1).sbc = 1
                            If FastSymbol(sss$, ChrW(&H1FFD)) Then
                                sbf(x1).locked = True
                                frm$ = " " + str$(-x1)
                            Else
                                frm$ = str$(x1)
                            End If
                            If sbf(x1).sbgroup = here$ + "." Then
                                If InStr(ThisGroup.FuncList, Chr$(2) + ss$ + "() ") = 0 Then
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + str(x1) + Chr$(1) + ThisGroup.FuncList
                                End If
                            Else
                                If sbf(x1).locked Then
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + frm$ + Chr$(1) + ThisGroup.FuncList
                                Else
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + frm$ + Chr$(1) + ThisGroup.FuncList
                                End If
                                sbf(x1).sbgroup = here$ + "."
                                sbf(x1).tpointer = I
                            End If
                        Else
                            x1 = 0
                        End If
                    End If
                    sss$ = NLtrim$(sss$) + " "
                    While AscW(sss$) = 13
                        SetNextLine sss$
                        sss$ = NLtrim$(sss$) + " "
                    Wend
                    If Len(bstack.UseGroupname) > 0 Or Glob Then
                        here$ = vbNullString
                    Else
                       here$ = ohere$
                    End If
                    s$ = sss$
                Else
                    s$ = vbNullString
                End If
            Wend
        End If
    End If
End With
With ThisGroup
    .GroupName = what$ + "."
    .FloatGroupName = myobject.FloatGroupName
    If myobject.HasStrValue Then
        GlobalVarRefLink2 here$ + "$", I, Glob
    End If
    .HasStrValue = myobject.HasStrValue
    .HasValue = myobject.HasValue
    .HasSet = myobject.HasSet
    .HasParameters = myobject.HasParameters
    .HasParametersSet = myobject.HasParametersSet
    Set .Events = myobject.Events
    .highpriorityoper = myobject.highpriorityoper
    .HasUnary = myobject.HasUnary
    .HasRemove = myobject.HasRemove Or .HasRemove
    Set .mytypes = myobject.mytypes
End With
SwapStrings here$, ohere$
bstack.GroupName = oldgroupname$
End Sub
Sub UnFloatGroupReWriteVars(bstack As basetask, what$, I As Long, myobject1 As Object, Optional mergesuper As Boolean = False, Optional MakeNew As Boolean, Optional bypassnew As Boolean = False)
Dim ThisGroup As Group, ohere$, addon As Boolean, myobject As Group
If myobject1 Is Nothing Then Exit Sub
If Not TypeOf myobject1 Is Group Then Exit Sub
Set myobject = myobject1
Set ThisGroup = var(I)

If myobject.IamApointer Then
    If ThisGroup.IamApointer Then Set var(I) = myobject: Exit Sub
    If myobject.link.IamFloatGroup And ThisGroup.FieldsCount = 0 Then
        Set var(I) = myobject
        Exit Sub
    ElseIf myobject.link.IamFloatGroup Then
    If myobject.link Is NullGroup Then
        Set myobject = New Group
        myobject.BeginFloat 0
        myobject.EndFloat
    Else
        Set myobject = CopyGroupObj(myobject.link)
        End If
    Else
        SwapStrings ohere$, here$
        here$ = myobject.lasthere
        If GetVar(bstack, myobject.GroupName, I, , , True) Then
            CopyGroup2 myobject.link, bstack
        End If
        SwapStrings here$, ohere$
        If bstack.lastobj Is Nothing Then Exit Sub
        If Not TypeOf bstack.lastobj Is Group Then Exit Sub
        Set myobject = bstack.lastobj
        Set bstack.lastobj = Nothing
    End If
End If
If ThisGroup.IamApointer Then
    If ThisGroup.link.IamFloatGroup Then
        Set var(I).link = myobject
    Else
        SyntaxError
    End If
    Exit Sub
End If
While Right$(what$, 1) = "."
    what$ = Left$(what$, Len(what$) - 1)
Wend
If Len(what$) = 0 Then Exit Sub
If Not bypassnew Then
If Len(ThisGroup.Patch) > 0 Then

If Len(bstack.UseGroupname) > 0 Then
If bstack.tpointer = I Then
    bypassnew = bstack.ErrVars > bstack.tpointer
Else
bypassnew = (Left(ThisGroup.Patch, Len(bstack.UseGroupname)) = bstack.UseGroupname And Not bstack.nokillvars)
End If
End If
End If
End If
Dim v As Long, s$, frm$, vvl As Variant, x1 As Long, ss$, frmarr$, sss$, j As Long
Dim grtype As Variant, ps2push As String, ff$, uni As Boolean, limit As Long   ' TT As Long
Dim usevariant As Boolean
'Set ps = var(i).soros
Dim subgroup As Object, pppp As mArray
Dim oldgroupname$, Glob As Boolean
ohere$ = here$  ' get a backup

 Glob = ThisGroup.IamGlobal
 uni = myobject.IamSuperClass
  If Not myobject.SuperClassList Is Nothing Then
  
 Set ThisGroup.SuperClassList = myobject.SuperClassList
 
  If myobject.IamSuperClass Then Set myobject = myobject.SuperClassList
 End If
If Len(bstack.UseGroupname) > 0 Or Glob Then
    If Not Glob Then
Else
here$ = vbNullString
End If

'If glob Then here$ = VbNullString
End If
 oldgroupname$ = bstack.GroupName
 
    If bstack.GroupName <> "" Then
  bstack.GroupName = bstack.GroupName + what$ + "."
  Else
  bstack.GroupName = what$ + "."
  End If
            If myobject Is Nothing Then GoTo exithere1
With myobject
    ThisGroup.HasRemove = .HasRemove Or ThisGroup.HasRemove
    If Not .IamFloatGroup Then GoTo exithere1
    If .IamFloatGroup Then
        addon = bstack.ErrVars < I Or Not Glob
        .PeekItem 0, grtype
        .PeekItem 1, vvl
        For x1 = 2 To 1 + vvl * 2 Step 2
            .PeekItem x1, vvl    'here is the name
            s$ = vvl
            If uni Then
                If Left$(s$, 1) = "@" Then
                    If mergesuper Then
                        s$ = Mid$(s$, 2)
                    Else
                        GoTo cont1010
                    End If
                End If
            End If
            If Left$(s$, 1) = "#" Then s$ = Mid$(s$, 2): usevariant = True Else usevariant = False
            .PeekItem x1 + 1, vvl  'here is the value
            If MyIsObject(vvl) Then
                If vvl Is Nothing Then
                    GoTo cont1010
                ElseIf TypeOf vvl Is mArray Then
                    s$ = Left$(s$, Len(s$) - 1)
                    ss$ = vbNullString
                    If here$ = vbNullString And Len(bstack.UseGroupname) > 0 Then
                        If neoGetArrayLinkOnly(bstack, bstack.UseGroupname + s$, j) Then GoTo conthere1111
                    End If
                    If Not neoGetArrayLinkOnly(bstack, ThisGroup.Patch + "." + s$, j) Then
                        If bypassnew Then GoTo cont1010
                        j = -1
                        Set subgroup = vvl
                        GlobalArr bstack, ThisGroup.Patch + "." + s$, ss$, 0, j, True
                        Set pppp = var(j)
                        subgroup.CopyArray pppp
                        Set subgroup = Nothing
                    Else
conthere1111:
                        Set subgroup = vvl
                        Set pppp = var(j)
                        subgroup.CopyArray pppp
                        Set subgroup = Nothing
                    End If
                    If addon Then
                        If usevariant Then
                            ' PS.DataStrUn "#" + s$ + " " + str$(-j)
                            ThisGroup.MergeField "#" + s$ + " " + str$(-j)
                        Else
                            ' PS.DataStrUn s$ + str$(j)
                            ThisGroup.MergeField s$ + str$(j)
                        End If
                    End If
                ElseIf TypeOf vvl Is lambda Then

                    If GetVar1(bstack, bstack.GroupName + s$, v) And here$ = vbNullString Then
                    ElseIf Not GetVar1(bstack, s$, v) Then
isalambda:
                        If bypassnew Then GoTo cont1010
                        v = globalvarGroup(bstack.GroupName + s$, 0)
                        If here$ = vbNullString Then
                            GlobalSub bstack.GroupName + s$ + "()", "", bstack.GroupName, , v
                        Else
                            GlobalSub here$ + "." + bstack.GroupName + s$ + "()", "", here$ + "." + bstack.GroupName, , v
                        End If
                    End If
                    Set var(v) = vvl
                    If addon Then
                    ' PS.DataStrUn s$ + str(v)
                    ThisGroup.MergeField s$ + str(v)
                    End If
                Else  ' is not array so...
                        '' drop *
                    If AscW(s$) = 42 Then s$ = Mid$(s$, 2)
                    ps2push = bstack.GroupName + s$
                    If GetVar1(bstack, ps2push, v) Then
                    ElseIf GetVar1(bstack, here$ + "." + ps2push, v) Then
                    ElseIf Not GetVar1(bstack, s$, v) Then
                        If bypassnew Then GoTo cont1010
                        v = globalvarGroup(ps2push, 0)
                    End If
                    If TypeOf vvl Is Group Then
                        Dim spare As Object
                        Set spare = vvl
                        If MyIsObject(var(v)) Then
                            If Typename(var(v)) = mGroup Then
                                UnFloatGroupReWriteVars bstack, s$, v, spare, , MakeNew, bypassnew
                            Else
                                GoTo cont1928374
                            End If
                        Else
cont1928374:
                            ss$ = here$
                            If Len(bstack.GroupName) > 1 Then
                                here$ = bstack.GroupName
                                here$ = Left$(here$, Len(here$) - 1)
                            End If
                            UnFloatGroup bstack, s$, v, spare, , , MakeNew
                            here$ = ss$
                        End If
                        Set spare = Nothing
                        If addon Then
                        ' PS.DataStrUn "*" + s$ + str(v)
                        ThisGroup.MergeField "*" + s$ + str(v)
                        End If
                        GoTo cont1010
                    ElseIf TypeOf vvl Is mHandler Then
                        Set vvl = CopyHandlerObj(vvl)
                    ElseIf TypeOf vvl Is mEvent Then
                        CopyEvent vvl, bstack
                        Set vvl = bstack.lastobj
                        Set bstack.lastobj = Nothing
                        If here$ = vbNullString Then
                            vvl.Upgrade bstack.GroupName
                        Else
                            vvl.Upgrade here$ + "." + bstack.GroupName
                        End If
                    ElseIf TypeOf vvl Is Constant Then
                        If VarTypeName(var(v)) = "Constant" Then
                            GoTo cont1010
                        ElseIf VarTypeName(vvl.Value) = "lambda" Then
                            If MemInt(VarPtr(var(v))) = 2 Then
                            GoTo isalambda
                            End If
                        End If
                    End If
                    Set var(v) = vvl
                                        
                    If addon Then ' ps.DataStrUn s$ + Str(v)
                        If usevariant Then
                            ' PS.DataStrUn "#" + s$ + " " + str$(-v)
                            ThisGroup.MergeField "#" + s$ + " " + str$(-v)
                        Else
                            ' PS.DataStrUn s$ + str$(v)
                            ThisGroup.MergeField s$ + str$(v)
                        End If
                    End If
                End If
            Else
                If AscW(s$) = 42 Then s$ = Mid$(s$, 2)  ' CHECK THIS FOR ERROR
                ps2push = bstack.GroupName + s$
                If GetVar1(bstack, ps2push, v) Then
                ElseIf GetVar1(bstack, here$ + "." + ps2push, v) Then
                ElseIf Not GetVar1(bstack, s$, v) Then
                    If bypassnew Then GoTo cont1010
                    v = globalvarGroup(ps2push, 0)
                End If
                var(v) = vvl
                If addon Then
                    If usevariant Then
                        ' PS.DataStrUn "#" + s$ + " " + str$(-v)
                        ThisGroup.MergeField "#" + s$ + " " + str$(-v)
                    Else
                        ' PS.DataStrUn s$ + str$(v)
                        ThisGroup.MergeField s$ + str$(v)
                    End If
                End If
            End If
cont1010:
        Next x1
    End If
    If ohere$ = vbNullString Or Glob Then
        here$ = vbNullString
    Else
       here$ = ohere$
    End If
    .PeekItem x1, vvl
    If Trim$(vvl) <> "" Then
        s$ = CStr(vvl)
        ExecuteGroupStruct bstack, what$, (I), s$, 0, 1
    End If
    .PeekItem x1 + 1, vvl
    If Trim$(vvl) <> "" Then
        s$ = CStr(vvl)
        bstack.GroupName = vbNullString
        While s$ <> ""
            If ohere$ = vbNullString Or Glob Then
                here$ = oldgroupname$ + what$
            Else
                here$ = ohere$ + "." + oldgroupname$ + what$
            End If
            x1 = IsLabelA1("", s$, ss$)
            If x1 <> 0 Then
                sss$ = s$
                If Len(ss$) > 6 Then
                    x1 = IsLabelA1("", s$, ss$)
                    frm$ = vbNullString
                    If MyFunction(-2 * (&H1FFF = AscW(ss$)), bstack, sss$, 1, True, MakeNew, , bypassnew) Then     '' >6 len for function
                        If Asc(s$) <> 32 Then
                            If InStr(s$, " ") = 2 Then
                                ss$ = ss$ + Left$(s$, 1)
                                s$ = Mid$(s$, 2)
                            Else
                                ss$ = ss$ + Left$(s$, 2)
                                s$ = Mid$(s$, 3)
                            End If
                        End If
                        x1 = bstack.IndexSub
                        sbf(x1).Changed = True
                        If FastSymbol(sss$, ChrW(&H1FFD)) Then
                            sbf(x1).locked = True
                            frm$ = " " + str$(-x1)
                        Else
                            frm$ = str$(x1)
                        End If
                        If Not sbf(x1).sbgroup = here$ + "." Then
                            If addon Then ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + "()" + frm$ + Chr$(1) + ThisGroup.FuncList
                            sbf(x1).sbgroup = here$ + "."
                            sbf(x1).tpointer = I
                        End If
                    Else
                        x1 = 0
                    End If
                Else
                    x1 = IsLabelA1("", s$, ss$)
                    If MyModule(bstack, sss$, 1, True, MakeNew, , , bypassnew) Then
                        x1 = bstack.IndexSub
                        sbf(x1).sbc = 1
                        sbf(x1).Changed = True
                        If FastSymbol(sss$, ChrW(&H1FFD)) Then
                            sbf(x1).locked = True
                            frm$ = " " + str$(-x1)
                        Else
                            frm$ = str$(x1)
                        End If
                        If Not sbf(x1).sbgroup = here$ + "." Then
                            If addon Then ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + frm$ + Chr$(1) + ThisGroup.FuncList
                            sbf(x1).sbgroup = here$ + "."
                            sbf(x1).tpointer = I
                        End If
                    Else
                        x1 = 0
                    End If
                End If
                sss$ = NLtrim$(sss$) + " "
                While AscW(sss$) = 13
                    SetNextLine sss$
                    sss$ = NLtrim$(sss$) + " "
                Wend
                If Len(bstack.UseGroupname) > 0 Or Glob Then
                    here$ = vbNullString
                Else
                   here$ = ohere$
                End If
                s$ = sss$
            Else
                s$ = vbNullString
            End If
        Wend
    End If
End With
With ThisGroup
    .IamCleared = False
    .HasValue = myobject.HasValue Or .HasValue
    .HasSet = myobject.HasSet Or .HasSet
    .HasStrValue = myobject.HasStrValue Or .HasStrValue
    .HasParameters = myobject.HasParameters Or .HasParameters
    .HasParametersSet = myobject.HasParametersSet Or .HasParametersSet
    If Not myobject.Events Is Nothing Then
        If .Events Is Nothing Then
            Set .Events = myobject.Events
        End If
    End If
    .highpriorityoper = MergeOperators(myobject.highpriorityoper, .highpriorityoper)
    .HasUnary = myobject.HasUnary Or .HasUnary
    .HasRemove = myobject.HasRemove Or .HasRemove
    If Not bypassnew Then
    .mergeTypes myobject.mytypes
    End If
End With

exithere1:
SwapStrings here$, ohere$
bstack.GroupName = oldgroupname$

End Sub
Function ChangedFunctionList(ByVal s$) As Boolean
ChangedFunctionList = True
Exit Function
Dim c$, K$(), Final As Long
Do While s$ <> "" And Not ChangedFunctionList
If ISSTRINGA(s$, c$) Then ChangedFunctionList = sbf(Abs(val(Split(c$, " ")(1)))).Changed
Loop

End Function


Function GetFunctionList(ByVal s$) As String
Dim c$, f$, K$(), qq$, Final As Long, tmp$, oldl As Long, mtrim As Long
Dim final2 As Long
While s$ <> ""
If ISSTRINGA(s$, c$) Then
K$() = Split(c$, " ")
Final = val(K$(1))
If Not Right$(sbf(Abs(Final)).sb, 2) = vbCrLf Then
qq$ = vbCrLf
End If
final2 = Final < 0
If Right$(K$(0), 1) = ")" Then
If UBound(K$) = 2 Then
f$ = "Function " + Mid$(K$(0), 2, Len(K$(0)) - 3) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + ChrW(&H1FFD) + ChrW(&H1FFD) + f$

Else
If final2 Then
f$ = "Function " + Mid$(K$(0), 2, Len(K$(0)) - 3) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + ChrW(&H1FFD) + f$
Else
f$ = "Function " + Mid$(K$(0), 2, Len(K$(0)) - 3) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + f$
End If
End If
Else
If final2 Then
f$ = "Module " + Mid$(K$(0), 2, Len(K$(0)) - 1) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + ChrW(&H1FFD) + f$
Else
f$ = "Module " + Mid$(K$(0), 2, Len(K$(0)) - 1) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + f$
End If
End If
End If

Wend
GetFunctionList = f$
End Function
Sub ResetFunctionList(s$)
Dim c$, K$(), Final As Long
While s$ <> ""
If ISSTRINGA(s$, c$) Then
K$() = Split(c$, " ")
Final = val(K$(1))
With sbf(Abs(Final))
.sb = vbNullString
.sbc = 0

.sbgroup = vbNullString
.goodname = vbNullString
.locked = False
.tpointer = 0
.IamAClass = False
Set .subs = Nothing
End With
End If
Wend

End Sub

Function SBcode(I As Long) As String
If I < 0 Then
SBcode = var(-I).code$
Else
SBcode = sbf(I).sb
End If
End Function
Function GlobalHandler(basestack As basetask, rest$, Lang As Long, typeHandler As Long) As Boolean
Dim x1 As Long, ss$, I As Long, s$, what$, par As Boolean
Do
x1 = Abs(IsLabel(basestack, rest$, what$))
If x1 <> 1 Then GlobalHandler = False: Exit Function
ss$ = here$
here$ = vbNullString

I = globalvar(basestack.GroupName + what$, Empty, , True)
Select Case typeHandler
Case 1
MakeitObjectInventory var(I)
here$ = ss$
If FastSymbol(rest$, "=") Then
Set basestack.lastobj = var(I)
GlobalHandler = AddInventory(basestack, rest$)
Exit Function
End If
Case 2
MakeitObjectBuffer var(I)
here$ = ss$
Case 3
MakeitObjectInventory var(I), True
here$ = ss$
If FastSymbol(rest$, "=") Then
Set basestack.lastobj = var(I)
GlobalHandler = AddInventory(basestack, rest$)
Exit Function
End If

Case Else
here$ = ss$
End Select
Loop Until Not FastSymbol(rest$, ",")
If rest$ <> "" Then
If Not MaybeIsSymbol(rest$, ":" + vbCr) Then
SyntaxError
Else
GlobalHandler = True
End If
Else
GlobalHandler = True
End If

 


End Function
Function GlobalEVENT(basestack As basetask, rest$, Lang As Long) As Boolean
Dim x1 As Long, ss$, I As Long, s$, what$

x1 = Abs(IsLabel(basestack, rest$, what$))
If x1 <> 1 Then GlobalEVENT = False: Exit Function
ss$ = here$
here$ = vbNullString
I = globalvar(basestack.GroupName + what$, Empty, , True)
MakeitObjectEvent var(I)
here$ = ss$
GlobalEVENT = ProcEvent(basestack, rest$, Lang, I)
 


End Function

Function dimString(typo$) As String
Dim pppp As mArray, pp, I As Long, p, lim As Long
Dim b$(), vl$
b$() = Split(typo$, " ")

Set pppp = var(val(b$(1)))
      pppp.SerialItem pp, CLng(p), 5
         Dim A$()
         If pp < 1 Then dimString$ = b$(0) + ")": Exit Function
         ReDim A$(pp - 1)
      For I = 0 To pp - 1
      pppp.GetDnum I, p, lim
      'pppp.SerialItem p, i, 6
      A$(I) = Trim$(str$(-lim)) + " TO " + Trim$(str$(p - lim - 1))
      Next I
      pppp.SerialItem p, 0&, 2
      If InStr(b$(0), "$") > 0 Then
      vl$ = "{" & (p) & "} "
      Else
      If IsNumeric(p) Then
       vl$ = "=" & (p) & " "
       Else
       vl$ = "=0 "
      End If
      End If
      If pp > 1 Then
      dimString = b$(0) + Join(A$(), ",") + ")" + vl$
      Else
      dimString = b$(0) + A$(0) + ")" + vl$
      End If
End Function
Sub LogGroup(bstack As basetask, vvv As Long, ohere$, OvarnameLen As Long, lcl As Boolean, ByPass As Boolean, Unique As Boolean)
If ByPass Then GoTo bye

'unique = False

'
Dim ss$, W$, I As Long, nm$, nt$, CM$, nt1$, j As Long, K As Long, dropit As Long
Dim s() As String, eGroup As Group
Set eGroup = var(vvv)
      With eGroup

  
        
        If here$ <> "" Then
        W$ = UCase(here$ + "." + ohere$ + ".")
        Else
        W$ = UCase(ohere$ + ".")
        End If
            If OvarnameLen <= varhash.count Then
                    
            For I = OvarnameLen To varhash.count  ' or not
            
                 varhash.ReadVar I - 1, ss$, dropit
                 
                If Left(ss$, Len(W$)) = W$ Then
                j = dropit
                    
                nt$ = VarTypeName(var(j))
                    
                 If Not lcl Then
                          If nt$ = mGroup Then
                          If Right$(ss$, 1) <> "$" Then
                          
                         '.soros.DataStr "*" + Mid$(ss$, Len(W$) + 1) + str(j)
                         .Add2Field "*" + Mid$(ss$, Len(W$) + 1) + str(j)
                         Else
                         
                         End If
                         Else
                         If varhash.vType(I - 1) = False Then
                         If Unique Then
                         '.soros.DataStr "#@" + Mid$(ss$, Len(W$) + 1) + " " + str(-j)
                         .Add2Field "#@" + Mid$(ss$, Len(W$) + 1) + " " + str(-j)
                         Else
                         '.soros.DataStr "#" + Mid$(ss$, Len(W$) + 1) + " " + str(-j)
                         .Add2Field "#" + Mid$(ss$, Len(W$) + 1) + " " + str(-j)
                         End If
                         Else
                         If Unique Then
                         '.soros.DataStr "@" + Mid$(ss$, Len(W$) + 1) + str(j)
                         .Add2Field "@" + Mid$(ss$, Len(W$) + 1) + str(j)
                         Else
                         '.soros.DataStr Mid$(ss$, Len(W$) + 1) + str(j)
                         .Add2Field Mid$(ss$, Len(W$) + 1) + str(j)
                         End If
                        End If
                         End If
                            Else
                             nm$ = Mid$(ss$, Len(W$) + 1)
                          
                                If nt1$ <> nt$ Then .localList = .localList + vbCrLf: CM$ = vbNullString
                           If I = OvarnameLen Then CM$ = "Local " Else CM$ = ", "
                           If nt$ = "Long" Then
                           If CM$ = "," Then nt1$ = vbNullString Else nt1$ = nt$ + " "
                           .localList = .localList & CM$ & nt1$ & nm$ + "=" & var(j)
                           ElseIf nt$ = myArray Then
                            .localList = .localList + vbCrLf + "local DIM " + dimString(nm$ + str$(j)) + vbCrLf
                           ElseIf nt$ = doc Then
                           If CM$ = "," Then nt1$ = vbNullString Else nt1$ = nt$ + " "
                           .localList = .localList & CM$ & nt1$ & nm$ & "={" & (var(j)) & "}"
                           ElseIf InStr(nm$, "$") Then
                                .localList = .localList & CM$ & nm$ & "={" & (var(j)) & "}"
                           Else
                                .localList = .localList + CM$ + nm$ + "=" + str(var(j))
                            End If
                            nt1$ = nt$
                End If
                End If
            Next I

            If lcl Then .localList = .localList + vbCrLf
            End If
        
           
           '
           

End With
bye:
OvarnameLen = varhash.count + 1 'Len(VarName$) + 1   'we record ...AGAIN

End Sub
Function FindNameForGroup(bstack As basetask, W$) As Boolean
Dim ss() As String, w2 As Long
  If InStr(W$, ChrW(&H1FFF)) > 0 Then
        If InStr(W$, ".") > 0 Then
        ss() = Split(W$, ".")
            If GetVar(bstack, ss(0), w2) Then
                If VarTypeName(var(w2)) = mGroup Then
                   If var(w2).FloatGroupName <> "" Then ss(0) = var(w2).FloatGroupName: FindNameForGroup = True
                   W$ = Join(ss(), ".")
                            If InStr(W$, ChrW(&H1FFF)) > 0 Then
                             W$ = vbNullString
                            Else
                             FindNameForGroup = True
                             End If
                 Else
                 W$ = vbNullString
                End If
                                 Else
                 W$ = vbNullString
            End If
                             Else
                 W$ = vbNullString
    End If
    End If
End Function
Function procTestMe(bstack As basetask, rest$, what$) As Boolean
Dim ss$
procTestMe = True

If Not Form1.Visible Then
    newshow Basestack1
    k1 = 0
End If
If FastSymbol(rest$, "!") Then
untest:
    If trace Then
        With Form2
            If .Busy Then
                Do
                    Sleep 10
                Loop Until Not .Busy
            End If
            .Busy = True
            If pagio$ = "GREEK" Then
            .gList2.HeadLine = "╦КЕЦВОР"
            Else
            .gList2.HeadLine = "Control"
            End If
            If TestShowCode And here$ <> "" Then
                Form2.gList3(2).BackColor = &H606060
            Else
                Form2.gList3(2).BackColor = &H3B3B3B
            End If
            .label1(0) = vbNullString
            .label1(1) = vbNullString
            .label1(2) = vbNullString
            .Hide
             Set .Process = Nothing
             STq = False
            STEXIT = False
            STbyST = False
            trace = False
             .Busy = False
         End With
    End If
    Exit Function
End If
With Form2
If .Busy Then
    Do
        Sleep 10
    Loop Until Not .Busy
End If
End With
If bypassST Then Form2.Busy = True: GoTo bb1
STq = False
STEXIT = False
STbyST = True
Form2.Show , Form1
   Form2.Busy = True
    If here$ = vbNullString Then
       TestShowSub = vbNullString
       TestShowStart = 0
       Form2.testpad.Text = vbNullString
       Form2.testpad.glistN.CapColor = rgb(128, 128, 0)
       Form2.testpad.Show
       Form2.testpad.SetRowColumn 1, 1
    End If
    Form2.switchview = 0
    Sleep 10
    'MyDoEvents
' gList2.HeadLine
    If bstack.IamLambda Then
        If pagio$ = "GREEK" Then
            Form2.label1(0) = "сумаятгсг калда"
        Else
            Form2.label1(0) = "LAMBDA FUNCTION"
        End If
    Else
        Form2.label1(0) = GetName$(here$)
    End If
    Form2.label1(1) = what$
    Form2.label1(2) = GetStrUntil(vbCrLf, rest$ + vbCrLf, False)
    Dim back$
bb1:
    If ISSTRINGA(rest$, ss$) Then IsSymbol rest$, ","
    If ss$ <> "" Then
    With Form2
        If pagio$ = "GREEK" Then
            .gList2.HeadLine = "╦КЕЦВОР: " + ss$
        Else
            .gList2.HeadLine = "Control: " + ss$
        End If
     If Not bypassST Then TestShowCode = True
    End With
    If TestShowCode And here$ <> "" Then
        Form2.gList3(2).BackColor = &H606060
        If Len(TestShowSub) >= WaitShow And WaitShow > 0 Then
            TestShowStart = rinstr(TestShowSub, Mid$(rest$, 2)) - 1
    Else
        WaitShow = 0
        ss$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))
        If Left$(ss$, 10) = "'11001EDIT" Then
            TestShowSub = Mid$(sbf(Abs(bstack.OriginalCode)).sb, Len(ss$) + 3)
        Else
             TestShowSub = ss$
        End If
        If bstack.addlen Then
            If Len(TestShowSub) - bstack.addlen - Len(rest$) > 0 Then
                TestShowStart = Len(TestShowSub) - bstack.addlen - Len(rest$) + 1
            Else
                TestShowStart = 1
            End If
        Else
            TestShowStart = Len(TestShowSub) - Len(rest$) + 1
        End If
        If TestShowStart <= 0 Then
            TestShowStart = rinstr(TestShowSub, Mid$(rest$, 2)) - 1
        End If
    End If
Else
    TestShowSub = vbNullString
End If
Set Form2.Process = bstack
stackshow bstack
' not that from version 12
'MyDoEvents
Form1.Show , Form5
Form2.gList2.RefreshNow
what$ = vbNullString
Form2.Busy = False
If FastPureLabel(rest$, what$, , , , , False) = 1 Then
rest$ = ": " + rest$
If Not trace Then
trace = True
procTestMe = Execute(bstack, what$, True) = 1
GoTo untest
Else


End If
ElseIf what$ <> "" Then
com1020:
Dim M As Long, s$
Do
M = 1

 what$ = aheadstatus(rest$, , M)

 If M > 1 Then
 
 If Asc(Left$(LTrim(Left$(rest$, M)), 1) + " ") < 32 Then Exit Do
 STq = True
 If s$ <> "" Then
 s$ = s$ + ", " + LTrim$(Left$(rest$, M - 1))
 Else
s$ = s$ + LTrim$(Left$(rest$, M - 1))
End If
Mid$(rest$, 1, M - 1) = space$(M - 1)
STbyST = False
End If
If Not FastSymbol(rest$, ",") Then Exit Do
Loop Until M = 1
If Not Form2.Visible Then Form2.Show , Form1
Form2.Compute.vartext = s$
rest$ = NLtrim(rest$)
trace = True


TestShowCode = False
Form2.gList4.ListIndex = 1
End If

Else
If FastPureLabel(rest$, what$, , , , , False) = 1 Then
TestShowCode = True
rest$ = ": " + rest$
trace = True
 Set Form2.Process = bstack
stackshow bstack
'MyDoEvents
Form1.Show , Form5
Else
GoTo com1020
End If

End If
Form2.Busy = False
End Function
Function procMotionW(bstack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, myform As GuiM2000, where As Long
Dim Scr As Object
If TypeOf bstack.Owner Is GuiM2000 Then
procMotionW = True
Set myform = bstack.Owner
myform1:
where = FindFormSScreen(myform)
  If Not IsExp(bstack, rest$, X) Then X = myform.Left
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, Y) Then procMotionW = False: Exit Function
        Else
        
        Y = myform.top
    End If
    If FastSymbol(rest$, ";") Then
    X = ((ScrInfo(where).Width - 1) - myform.Width) / 2 + ScrInfo(where).Left
    Y = ((ScrInfo(where).Height - 1) - myform.Height) / 2 + ScrInfo(where).top
    If X < ScrInfo(where).Left Then X = ScrInfo(where).Left
    If Y < ScrInfo(where).top Then Y = ScrInfo(where).top
    End If
    
myform.move X, Y
ElseIf val("0" + bstack.Owner.Tag) > 32 Then
Set Scr = bstack.Owner.Parent
If Scr Is Nothing Then Exit Function
While Not TypeOf Scr Is GuiM2000
Set Scr = Scr.Parent
If Scr Is Nothing Then Exit Function
Wend
procMotionW = True
Set myform = Scr
GoTo myform1
ElseIf TypeOf bstack.Owner Is MetaDc Then
oxiforMetaFiles
Exit Function
Else
'If Not Form1.Visible Then Exit Function
procMotionW = True
'Form1.Visible = True
'If Form3.Visible Then Form3.skiptimer = True: Form3.WindowState = 0
Console = FindFormSScreen(Form1)

If Form1.WindowState <> 0 Then Form1.WindowState = 0 ': mydoevents
If IsWine Then Sleep 50: Form1.SetFocus

If Form1.WindowState = 0 Then
    If Not IsExp(bstack, rest$, X) Then X = Form1.Left
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, Y) Then procMotionW = False: Exit Function
        Else
        
        Y = Form1.top
    End If
    
    If FastSymbol(rest$, ";") Then
    X = ((ScrInfo(Console).Width - 1) - Form1.Width) / 2 + ScrInfo(Console).Left
    Y = ((ScrInfo(Console).Height - 1) - Form1.Height) / 2 + ScrInfo(Console).top
    End If
' LETS MOVE

If IsWine And Form1.Width = ScrInfo(Console).Width Then Form1.Width = ScrInfo(Console).Width - dv15
If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top
If IsWine Then
If X = ScrInfo(Console).Left And Y = ScrInfo(Console).top Then
Form1.move X, Y
'If form5iamloaded Then Form5.RestorePos
Sleep 10
End If
End If
Form1.move X, Y
'If form5iamloaded Then Form5.RestorePos
Console = FindFormSScreen(Form1)
    If FastSymbol(rest$, ";") Then
    X = ((ScrInfo(Console).Width - 1) - Form1.Width) / 2 + ScrInfo(Console).Left
    Y = ((ScrInfo(Console).Height - 1) - Form1.Height) / 2 + ScrInfo(Console).top
    If X < ScrInfo(where).Left Then X = ScrInfo(where).Left
    If Y < ScrInfo(where).top Then Y = ScrInfo(where).top
    If Form1.top > VirtualScreenHeight() - 100 Then Form1.top = ScrInfo(Console).top
    Form1.move X, Y
    End If
Form1.Up
If IsWine Then Sleep 10
End If
End If
End Function
Function procLineSpace(bstack As basetask, rest$) As Boolean
Dim X As Double
procLineSpace = True
If IsExp(bstack, rest$, X) Then

    If CLng(X) < 0 Or CLng(X) > 60 * dv15 Then
    OutOfLimit
    Else
    X = (X \ 30) * 60
    X = CLng(X) / 2
    
   SetText bstack.Owner, CLng(X)
    
    End If
ElseIf FastSymbol(rest$, "!") Then
   SetText bstack.Owner, 4 * Screen.TwipsPerPixelY
Else
MissNumExpr
procLineSpace = False

Exit Function
End If


End Function

Function ProcLabel(basestack As basetask, rest$) As Boolean
Dim s$, frm$, p As Variant, X As Double, Y As Double, sX As Double, sY As Double
Dim Scr As Object, prive As basket
Set Scr = basestack.Owner
prive = players(GetCode(Scr))
ProcLabel = True
If Not IsStrExp(basestack, rest$, s$) Then Exit Function


frm$ = Replace(s$, ChrW(&HFFFFF8FB), ChrW(&H2007))
s$ = vbNullString
X = 0
If FastSymbol(rest$, ",") Then
    If Not IsStrExp(basestack, rest$, s$) Then
    If TypeOf Scr Is GuiM2000 Then
        If Len(prive.FontName) > 0 Then
            s$ = prive.FontName
        Else
            s$ = Scr.Controls(1).FontName
        End If
    Else
    s$ = prive.FontName
    End If
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, X) Then
         If TypeOf Scr Is GuiM2000 Then
                 If Len(prive.FontName) > 0 Then
                    X = prive.SZ
                 Else
                    X = Scr.Controls(1).FontSize
                End If
         Else
            X = prive.SZ
        End If
        End If
        
            Y = 0
            
                If FastSymbol(rest$, ",") Then
                    If Not IsExp(basestack, rest$, p) Then p = 0
                  If FastSymbol(rest$, ",") Then
                    If IsExp(basestack, rest$, sY) Then
                        nPlain basestack, frm$, s$, X, Y, CLng(p), True, CLng(sY \ DXP)
                    Else
                        nPlain basestack, frm$, s$, X, Y, CLng(-p - 1)
                    End If
                 Else
                    nPlain basestack, frm$, s$, X, Y, CLng(-p - 1)
                 End If
                Else
                    nPlain basestack, frm$, s$, X, Y, -1
                End If
    Else
        nPlain basestack, frm$, s$, X, 0, -1
    End If
Else
nPlain basestack, frm$, prive.FontName, prive.SZ, X, -1
End If
PlaceBasket Scr, prive
End Function
Function ProcLegend(basestack As basetask, rest$) As Boolean
Dim s$, frm$, p As Variant, X As Double, Y As Double, sX As Double, sY As Double
Dim Scr As Object, prive As basket
Set Scr = basestack.Owner
prive = players(GetCode(Scr))
ProcLegend = True
If FastSymbol(rest$, "!") Then
ProcLegend = False
If IsStrExp(basestack, rest$, s$, False) Then
      If InStr(s$, ChrW(&HFFFFF8FB)) > 0 Then s$ = Replace(s$, ChrW(&HFFFFF8FB), ChrW(&H2007))

    ProcLegend = True
    If Not FastSymbol(rest$, ",") Then ProcLegend = False: Exit Function
    If IsExp(basestack, rest$, p) Then
    X = p
    If Not FastSymbol(rest$, ",") Then
    Y = 1
    ElseIf Not IsExp(basestack, rest$, Y) Then
       ProcLegend = False: Exit Function
    End If
    Else
    X = prive.mX
    If Not FastSymbol(rest$, ",") Then ProcLegend = False: Exit Function
    If Not IsExp(basestack, rest$, Y) Then ProcLegend = False: Exit Function
    End If
    wPlain Scr, prive, s$, (X), Y - 1
End If
Else
If Not IsStrExp(basestack, rest$, s$, False) Then Exit Function


frm$ = Replace(s$, ChrW(&HFFFFF8FB), ChrW(&H2007))
s$ = vbNullString
X = 0
If FastSymbol(rest$, ",") Then
If Not IsStrExp(basestack, rest$, s$, False) Then Exit Function
End If
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, X) Then Exit Function
End If
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, Y) Then Exit Function
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, p) Then Exit Function
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, sX) Then Exit Function
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, sY) Then Exit Function
nPlain basestack, frm$, s$, X, Y, CLng(p), sX <> False, CLng(sY \ DXP)
Else
nPlain basestack, frm$, s$, X, Y, CLng(p), sX <> False
End If
Else
nPlain basestack, frm$, s$, X, Y, CLng(p)
End If
Else
nPlain basestack, frm$, s$, X, Y
End If
Else

nPlain basestack, frm$, s$, X
End If
End If
If FastSymbol(rest$, ";") Then
''NO REFRESH
Else
If Not extreme Then If Not basestack.toprinter Then MyRefresh basestack ' MyDoEvents1 Scr
End If
PlaceBasket Scr, prive
End Function

Function ExecuteEmfBlock(basestack As basetask, rest$, it As Long, ww, hh) As Object
Dim mDC As New MetaDc, Scr As Object, prive As basket
Dim oldprintFlag As Boolean, bNo&, nd&, OldGDILines As Boolean, once As Boolean
Set Scr = basestack.Owner
bNo = GetCode(Scr)
prive = players(bNo)
oldprintFlag = basestack.toprinter
If oldprintFlag Then basestack.toprinter = False
Dim www As Long, hhh As Long
www = ww
hhh = hh
mDC.create prive.mypen, www, hhh
ww = www
hh = hhh
prive.IamEmf = True
Set mDC.Font = Scr.Font
GetCode mDC
players(mDC.prive) = prive
With players(mDC.prive)
If ww <> 0 Then .MAXXGRAPH = CLng(ww)
If hh <> 0 Then .MAXYGRAPH = CLng(hh)
mDC.Width = .MAXXGRAPH
mDC.Height = .MAXYGRAPH
.curpos = 0
.currow = 0
.XGRAPH = 0
.YGRAPH = 0
End With

Set basestack.Owner = mDC
SetText mDC

If Not TaskMaster Is Nothing Then
If TaskMaster.Processing Or TaskMaster.QueueCount <> 0 Then
 TaskMaster.StopProcess
End If
End If
  '  OldGDILines = GDILines
  '  GDILines = True
            Call executeblock(it, basestack, rest$, False, once, , True)
   ' GDILines = OldGDILines
    If it = 2 Then
        If rest$ = "" Then
            If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
        Else
            rest$ = ": Goto " + rest$
            If trace Then WaitShow = 2: TestShowSub = rest$
        End If
        
                it = 1
        End If
   

    players(mDC.prive) = zero
    players(mDC.prive).used = False
    
    Set basestack.Owner = Scr

    If it = 0 Then
    MyEr "Problem in drawing", "пЯЭБКГЛА СТО СВщДИО"
    
    End If
        Set ExecuteEmfBlock = mDC.getEmfObj()
If oldprintFlag Then basestack.toprinter = True
        If Not TaskMaster Is Nothing Then
            If TaskMaster.Processing Or TaskMaster.QueueCount <> 0 Then
                TaskMaster.StartProcess
            End If
        End If


End Function
Function ProcLayer(basestack As basetask, rest$) As Boolean
Dim I As Long, p As Variant, x1 As Long, y1 As Long, X As Double, Y As Double
Dim s$, f As Long, pa$, sX As Double, it As Long, w3 As Long, ya As Long, AddTwipsTopL As Long
Dim Scr As Object, scr1 As Object, nd&, oldprintFlag As Boolean, oldBackFlag As Boolean
Dim prive As basket, orig As Long
oldprintFlag = basestack.toprinter
If oldprintFlag Then basestack.toprinter = False
oldBackFlag = basestack.toback
If oldBackFlag Then basestack.toback = False
ProcLayer = True
Set Scr = basestack.Owner
prive = players(GetCode(Scr))  ' backup
If Not IsExp(basestack, rest$, p) Then
    prive = players(0)
    p = 0 ' dis
    Set basestack.lastobj = Nothing
End If
If basestack.lastobj Is Nothing Then
    If p > 32 Or p < 0 Then p = 0 ' dis
    Else
        If Typename(basestack.lastobj) = mHdlr Then
            I = basestack.lastobj.indirect
            If I >= 0 And I <= var2used Then
                If MyIsObject(var(I)) Then
                    Set scr1 = var(I)
                    p = GetCode(scr1)
                    If TypeOf scr1 Is GuiM2000 Then
                    ElseIf TypeOf scr1 Is GuiImage Then
                        Set scr1 = Scr.pbox
                        scr1.Tag = CLng(p)
                    End If
                    If p = 0 Then
                        Set scr1 = Nothing
                    End If
                Else
                    Set scr1 = Nothing
                    p = 0
                End If
            End If
        Else
            Set scr1 = basestack.lastobj
            p = GetCode(scr1)
            If TypeOf scr1 Is GuiM2000 Then
            ElseIf TypeOf scr1 Is GuiImage Then
                Set scr1 = scr1.pbox
                scr1.Tag = CLng(p)
            End If
            If p = 0 Then
                Set scr1 = Nothing
            End If
        End If
    End If
    Set basestack.lastobj = Nothing
    w3 = basestack.tolayer
    basestack.tolayer = CLng(p)
    If lookOne(rest$, "{") Then
    If p > 32 Then
        If players(p).MAXXGRAPH = 0 Then
            SetTextBasketBack scr1, players(0)
            If TypeOf scr1 Is VB.PictureBox Then
            scr1.Cls
            
            End If
            SetText scr1, prive.MineLineSpace, True
            With players(p)
            .ShowCaret = False
            .italics = False
            .bold = False
            .curpos = 0
            .currow = 0
            .mysplit = 0
            .osplit = 0
            .XGRAPH = 0
            .YGRAPH = 0
            .lastprint = True
            .Paper = Form1.DIS.BackColor
            .mypen = players(0).mypen
            .mypentrans = players(0).mypentrans
            .ReportTab = ReportTabWidth
            End With
            With Prefresh(p)
            Call GetSystemTimeAsFileTime(basictimer)
            .k1 = basictimer + REFRESHRATE: .RRCOUNTER = 1
            End With
            scr1.BackColor = Form1.DIS.BackColor
            scr1.currentX = 0
            scr1.currentY = 0
         End If
    ElseIf p > 0 Then
        f = FindSpriteByTag(CLng(p))
        If f = 0 Then
        f = GetNewLayerObj(CLng(p), Scr.Width, Scr.Height)
        SetTextBasketBack Form1.dSprite(f), prive   ' load form prive to dSprite
        With players(p)
            Form1.dSprite(f).Font.Italic = .italics
            Form1.dSprite(f).Font.bold = .bold
        End With
        SetText Form1.dSprite(f), prive.MineLineSpace, True    'load Players() with first values
        With players(p)
            .curpos = 0
            .currow = 0
            .mysplit = 0
            .osplit = 0
            .Paper = Form1.DIS.BackColor
            .mypen = players(0).mypen
            .mypentrans = players(0).mypentrans
            .ReportTab = ReportTabWidth
        End With
    With Prefresh(p)
    Call GetSystemTimeAsFileTime(basictimer)
        .k1 = basictimer + REFRESHRATE: .RRCOUNTER = 1
        End With
    Form1.dSprite(f).BackColor = Form1.DIS.BackColor
End If
orig = p
p = f
End If


If p = 0 Then
Set basestack.Owner = Form1.DIS

ElseIf p < 33 Then
Set basestack.Owner = Form1.dSprite(p)
Else
Set basestack.Owner = scr1
End If
nd& = basestack.addlen
it = Execute(basestack, rest$, False, True, , True)
basestack.addlen = nd&
            If it = 2 Then
                        If rest$ = "" Then
                        rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                        Else
                        rest$ = ": Goto " + rest$
                         If trace Then WaitShow = 2: TestShowSub = rest$
                        End If
                        it = 1
                        End If
MyDoEvents2 basestack.Owner
GdiFlush
basestack.tolayer = w3
Set basestack.Owner = Scr
If it = 0 Then
ProcLayer = False
End If
End If
If oldprintFlag Then basestack.toprinter = True
If oldBackFlag Then basestack.toback = True


End Function
Function blockStringAhead(s$, pos1 As Long) As Long
Dim I As Long, j As Long, c As Long
c = Len(s$)
I = pos1
If I > c Then blockStringAhead = c: Exit Function
Do

Select Case AscW(Mid$(s$, I, 1))
Case 34
Do While I < c
I = I + 1
If AscW(Mid$(s$, I, 1)) = 34 Then Exit Do
If AscW(Mid$(s$, I, 1)) = 13 Then Exit Do
Loop
Case 123
j = j - 1
Case 125
j = j + 1: If j = 0 Then Exit Do
End Select
I = I + 1
Loop Until I > c
If j = 0 Then
pos1 = I
blockStringAhead = True
Else
blockStringAhead = False
End If


End Function



Function ProcEdit(basestack As basetask, rest$, Lang As Long) As Boolean
Dim s$, x1 As Long, y1 As Long, o As Long, frm$, I As Long, par As Boolean, p As Variant
Dim Scr As Object, ss$, prev$, bb As CodeBlock
ProcEdit = True
If FastSymbol(rest$, "!") Then
If FastSymbol(rest$, "!") Then SHOWCODE = Not SHOWCODE
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
EditTabWidth = Abs(p)

If Not FastSymbol(rest$, ",") Then Exit Function
End If
ProcEdit = False
Exit Function
End If
If Not (basestack.IamChild Or basestack.IamAnEvent) Then abt = False: mHelp = False: lastAboutHTitle = vbNullString
Set Scr = basestack.Owner
If Left$(Typename(Scr), 3) = "Gui" Then oxiforforms: Exit Function
If TypeOf basestack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
Form1.EditTextWord = False ' edit code
Form1.TEXT1.TabWidth = EditTabWidth
Form1.TabControl = EditTabWidth
s$ = aheadstatus(rest$, False, y1)
If y1 > 2 And Left$(s$, 1) = "S" Then
If Mid$(rest$, y1 - 1, 1) = "(" Or Mid$(rest$, y1 - 2, 2) = "()" Then s$ = "ok"

End If

If Left$(s$, 1) = "S" Then
    
    If IsStrExp(basestack, rest$, s$) Then
        If s$ <> "" Then
            If ExtractPath(s$) = vbNullString Then
                If CFname(s$) <> "" Then
                    s$ = CFname(s$)
                ElseIf mylcasefILE(s$) = ExtractName(s$, True) Then
                    s$ = mcd + s$
                End If
                If ExtractType(s$) = vbNullString Then
                    MyEr "missing file type (.gsb or .txt or .gm2)", "ДЕМ УПэЯВЕИ ТЩПОР АЯВЕъОУ (.gsb Г .txt Г .gm2)"
                    Set Scr = Nothing
                    Exit Function
                End If
            End If
            s$ = ExtractPath(s$) + ExtractName(s$, True)
            ' check if path exist
            ' uSE THE MYDIR.ISDIR
            If Dir$(ExtractPath(s$), vbDirectory) = vbNullString Then
            ' error
                MyEr "wrong path to save", "КэХОР ТЭПОР ЦИА СЧСИЛО"
                Set Scr = Nothing
                Exit Function
            ElseIf ExtractName(s$, True) = vbNullString Then
                MyEr "missing file name", "ВэХГЙЕ ТО ЭМОЛА АЯВЕъОУ"
                Set Scr = Nothing
                Exit Function
            End If
          Dim oldclid As Long
          oldclid = Clid
            If CFname(s$) <> "" Then
            s$ = CFname(s$)
             frm$ = ReadUnicodeOrANSI(s$, True, x1)
             ' CHECK TO SEE IF THIS IS A PASSWORD PROTECTED PROGRAMM
             For I = 1 To Len(frm$)
             If AscW(Mid$(frm$, I, 1)) < 128 Then
             Exit For
             End If
             Next I
             If I > Len(frm$) Then
             If Lang = 1 Then
             MsgBoxN "not text found", 0
             Else
             MsgBoxN "ДЕМ БЯчЙА ЙЕъЛЕМО", 0
             End If
             Set Scr = Nothing
             Exit Function
             End If
           ' par = Len(frm$) = FileLen(GetDosPath(s$)) ' not unicode
            par = x1 = 3
     
            Else
            frm$ = vbNullString
            par = False
            End If
            Form1.EditTextWord = LCase(ExtractType(s$)) <> "gsb"
            Form1.TEXT1.Title = ExtractName(s$, True) + " "
            If x1 = 0 Then x1 = -5
         '   Form1.ResetMarks
            Form1.TEXT1.glistN.UseTab = UseTabInForm1Text1
            If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, p) Then
            o = CLng(p)
            End If
            End If
            
            If o < 1 Then o = 0
            If o > Len(frm$) Then o = Len(frm$) + 1
            With players(GetCode(basestack.Owner))
            ScreenEdit basestack, frm$, 0, .mysplit, .mX - 1, .mY - 1, o, x1
            End With
         '   Form1.ResetMarks
            If frm$ <> "" And Abs(x1) >= 0 And Not CancelEDIT Then
                If par Then
                    I = FreeFile
                        If Not WeCanWrite(s$) Then Set Scr = Nothing: Exit Function
                        On Error Resume Next
                        Open GetDosPath(s$) For Output As I
                        If Err.Number > 0 Then
                            Err.Clear
                            MyEr "Bad filename", "кэХОР СТО ЭМОЛА АЯВЕъОУ"
                            Set Scr = Nothing
                            Exit Function
                        End If
                        Print #I, frm$;
                        Close I
                    Else
                    par = SaveUnicode(s$, frm$, x1)
                End If
                
            End If
        End If
        Set Scr = Nothing
        Clid = oldclid
        Exit Function
    Else
    Set Scr = Nothing
    Exit Function
    End If
End If

    If s$ <> "" Then
x1 = Abs(IsLabel(basestack, rest$, s$))
        If x1 > 0 Then
        If x1 > 3 Then
            s$ = Replace$(s$, "(", "")
            If FastSymbol(rest$, ")") Then
            End If
            s$ = s$ + "()"
            End If
        Else
        Set Scr = Nothing
        Exit Function
        End If
        MakeThisSub basestack, s$  'NO GOOD..
        If GetSub(s$, x1) Then
        p = x1
        If sbf(x1).locked Then
        GoTo jump11
        End If
jump1:
            If x1 < lckfrm And lckfrm <> 0 Then
jump11:
            
            MyEr s$ + " is locked", s$ + " ЕъМАИ ЙКЕИДЫЛщМО"
            'rest$ = vbNullString
            ProcEdit = False
            Set Scr = Nothing
            Exit Function
            End If
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
            y1 = Abs(IsLabel(basestack, rest$, frm$))
              If y1 <> 0 Then
           '' frm$ = myUcase(frm$)
             GetSub frm$, x1
             
            If x1 = 0 Then
            If y1 > 3 Then frm$ = frm$ + ")"
            GetSubFullName s$, ss$
            If ss$ <> Mid$(frm$, Len(ss$) - Len(s$) + 1) Then
                Check2SaveModules = True
                subHash.RenameKey ss$, Mid$(frm$, Len(ss$) - Len(s$) + 1)
                x1 = p
                sbf(x1).goodname = subHash.LastKnown
            End If
            End If
            End If
            Set Scr = Nothing
            Exit Function
            ElseIf FastSymbol(rest$, ",") Then
            I = 1
                If IsExp(basestack, rest$, p) Then
                    I = Int(p)
                    If I < 0 Then I = Len(sbf(x1).sb) + I
                    If I < 0 Then I = 0
                    If I > Len(sbf(x1).sb) Then I = Len(sbf(x1).sb) + 1
                End If
                sbf(x1).sbc = I
            End If
            If sbf(x1).sbc = 0 Then sbf(x1).sbc = -1
        MakeMyTitle s$, Lang
        Form1.TEXT1.glistN.UseTab = UseTabInForm1Text1
        
        With players(GetCode(basestack.Owner))
            prev$ = sbf(x1).sb
            ScreenEdit basestack, prev$, 0, .mysplit, .mX - 1, .mY - 1, sbf(x1).sbc, , , , True
            End With
            If SHOWCODE Then
            Set bb = New CodeBlock
            bb.Construct (sbf(x1).sb)
            bb.ExportStr basestack
            End If
            If prev$ <> sbf(x1).sb Then
            Set sbf(x1).subs = Nothing
            sbf(x1).sb = prev$
            Check2SaveModules = True
            End If
            If I <> 0 Then
                If pagio$ = "GREEK" Then
                    FK$(13) = "@с " & s$ & "," & (I)
                Else
                    FK$(13) = "@EDIT " & s$ & "," & (I)
                End If
            Else
                If pagio$ = "GREEK" Then
                    FK$(13) = "@с " & s$
                Else
                    FK$(13) = "@EDIT " & s$
                End If
            End If
            Form1.StoreBookMarks
        Else
        If InStr(s$, ".") > 0 Then
        frm$ = s$
        s$ = GetStrUntil(".", frm$)
        If GetSub(s$, x1) Then
        GoTo jump1
        End If
        End If
            If FastSymbol(rest$, ",") Then
             If IsExp(basestack, rest$, p) Then
             End If
            End If
            I = -1
           MakeMyTitle s$, Lang
           Form1.TEXT1.glistN.UseTab = UseTabInForm1Text1
           With players(GetCode(basestack.Owner))
            ScreenEdit basestack, frm$, 0, .mysplit, .mX - 1, .mY - 1, I ', , , , Len(frm$) = 0
            End With
            If frm$ <> "" Then
            MakeThisSub basestack, s$
                If here$ = vbNullString And InStr(s$, "(") = 0 Then
                    x1 = GlobalSub(s$, frm$, , s$)
                Else
                    x1 = ModuleSub(s$, frm$)
                End If
                Check2SaveModules = True

                If x1 <> 0 Then sbf(x1).sbc = I: Set sbf(x1).subs = Nothing
                FK$(13) = "@EDIT " & s$ & "," & (I)
                Else
                FK$(13) = "@EDIT " & s$
            End If
        End If
    ElseIf Not (basestack.IamChild Or basestack.IamAnEvent) Then
        Form1.TEXT1.glistN.UseTab = False
        frm$ = Mid$(Replace$(QUERYLIST, vbCr, vbCrLf), 3)
        Form1.ShadowMarks = True
        If UserCodePage = 1253 Then
        Form1.TEXT1.Title = "къСТА ЕМТОКЧМ "
        Else
        Form1.TEXT1.Title = "Command List "
        End If
        With players(GetCode(basestack.Owner))
        ScreenEdit basestack, frm$, 0, .mysplit, .mX - 1, .mY - 1
        End With
        Form1.ShadowMarks = False
        Form1.StoreBookMarks
        QUERYLIST = vbCr + Replace$(frm$, vbCrLf, vbCr)
    End If

End Function
Function ProcModuleEntry(basestack As basetask, ohere$, x1 As Long, rest$, Optional Lang As Long = -1, Optional thisIsEvent As Boolean = False) As Boolean
On Error GoTo there22

If LastErNum = -1 Then GoTo there22
Dim bs As basetask, loopthis As Boolean
Dim subs As Long, snames As Long, Vname As Long
Dim I As Long, p As Long, S3 As Long, bb$, pa$, small$, sbi As Long
Dim EXITNOW As Boolean
Dim restart As Boolean
Dim backup$, TSHB As Boolean
If trace Then SwapStrings backup$, TestShowSub: TSHB = TestShowBypass
TestShowBypass = False
'LastErName = VbNullString: LastErNameGR = VbNullString
If CurrentStackSize > stacksize Then
    MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
    ProcModuleEntry = False:
    here$ = ohere$
    GoTo modfun
End If
' ******************************************* module entry..............
If x1 = 0 Then x1 = basestack.callx1: ohere$ = basestack.callohere: basestack.callx1 = 0
I = 1
Set bs = New basetask
With bs
    .ByName = basestack.ByName
    .IamAnEvent = thisIsEvent
    Set .Parent = basestack
    Set .Sorosref = basestack.soros   'same stack
    Set .Owner = .Parent.Owner
    .originalname$ = ohere$
    .SetV2
    Vname = .Vname
    .ErrVars = .Vars
    basestack.ByName = 0
    .ByName = 0
    .commnum = comhash.count
    .strfunnum = strfunid.count
    .numfunnum = funid.count
    .strnum = strid.count
    .numnum = numid.count
    If sbf(x1).sbc Then
        numid.pushtopGlobal
        funid.pushtopGlobal
        strfunid.pushtopGlobal
        strid.pushtopGlobal
    Else
        numid.pushtop
        funid.pushtop
        strfunid.pushtop
        strid.pushtop
    End If
    subs = sb2used: snames = subHash.count
    .UseGroupname = sbf(x1).sbgroup
    .tpointer = sbf(x1).tpointer
    .OriginalCode = x1
    If Not basestack.StaticCollection Is Nothing Then
        StaticWork basestack, bs, here$
    End If
    .StaticInUse$ = here$
End With
If SecureNames Then
    If basestack.IamThread Then
        here$ = str$(basestack.Process.id) + here$
        Mid$(here$, 1, 1) = "_"
    End If
End If
If Lang <> -1 Then
    If IsSymbol(rest$, ";") Then
        Do
            If IsLabel(basestack, rest$, small$, True) = 1 Then
                If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                    If Abs(IsLabelBig(basestack, rest$, pa$)) <> 1 Then GoTo myerror1
                     MakeThisSub1 basestack, pa$
                Else
                    pa$ = small$
            End If
                    If subHash.Find(ohere$ + "." + pa$, I) Then
                        MyModule bs, small$ + " {}", Lang
                        sbf(bs.IndexSub).locked = True
                        sbf(bs.IndexSub).sb = sbf(I).sb
                        sbf(bs.IndexSub).sbc = sbf(I).sbc
                        sbf(bs.IndexSub).sbgroup = sbf(I).sbgroup
                         
                    ElseIf subHash.Find(pa$, I) Then
                        MyModule bs, small$ + " {}", Lang
                        sbf(bs.IndexSub).locked = True
                        sbf(bs.IndexSub).sb = sbf(I).sb
                        sbf(bs.IndexSub).sbc = sbf(I).sbc
                        sbf(bs.IndexSub).sbgroup = sbf(I).sbgroup
                    End If
                End If
        Loop Until Not IsSymbol(rest$, ",")
    End If
End If
I = 1
'If checkbreakEsc(bs) Then
'    ProcModuleEntry = False: GoTo modfun
'End If
restart = True
S3 = x1
Do
    bb$ = Mid$(sbf(S3).sb, I)
againmod:
    If LastErNum = -1 Then
        If bs.SubLevel > 0 Then GoTo unwindstack
        GoTo myerror1
    End If
    EXITNOW = False
    Select Case Execute(bs, bb$, EXITNOW, False, loopthis, , restart)
    Case 0
myerror1:
        If bs.ErrorOriginal = 0 Then If sbi > 0 Then bb$ = bb$ + space$(sbi)
        If MOUT And Not NOEXECUTION Then
            MOUT = False
            rest$ = vbNullString: MyEr "", ""
            Exit Do
        End If
        If sb2used <> 0 And Not NERR Then
            If Len(bs.UseGroupname) > 0 Then
                If InStr(bs.UseGroupname, ChrW(&H1FFF)) > 0 Then
                    pa$ = GetNextLine((sbf(Abs(bs.OriginalCode)).sb))
                    FK$(13) = Mid$(pa$, 7) & "-" & (Len(bb$))
                    MyErMacro rest$, "Problem in class in module " + GetName(here$), "пЯЭБКГЛА СТГ ЙКэСГ СТО ТЛчЛА " + GetName(here$)
                    ProcModuleEntry = True
                    GoTo thh1
                End If
            End If
            If bs.ErrorOriginal > 0 Then
            If bs.ErrorOriginal <> bs.OriginalCode Then
            If Left$(bb$, 10) <> ": Error -1" Then bb$ = ": Error -1 " + bb$
            If bs.IamChild Then If bs.Parent.OriginalCode <> bs.ErrorOriginal Then bs.Parent.ErrorOriginal = bs.ErrorOriginal
            rest$ = bb$: ProcModuleEntry = False
            GoTo th0
            End If
            End If
            
            pa$ = "EDIT " + GetModuleName(bs, here$) + "," + str$(Len(sbf(x1).sb) + 1)
            If ohere$ <> "" Then
                If Left$(sbf(x1).sb, 10) = "'11001EDIT" Then
                    pa$ = Mid$(GetNextLine(sbf(x1).sb), 7)
                    sbf(x1).sb = Mid$(sbf(x1).sb, 3)
                    Set sbf(x1).subs = Nothing
                    If SecureNames Then
                        MyEr "in module " + GetModuleName(bs, here$), "СТО ТЛчЛА " + GetModuleName(bs, here$)
                    Else
                        MyEr "in module " + GetName(ohere$) + "." + GetName(here$), "СТО ТЛчЛА " + GetName(ohere$) + "." + GetName(here$)
                    End If
                Else
                    MyEr "in module " + GetName(sbf(x1).goodname), "СТО ТЛчЛА " + GetName(sbf(x1).goodname)
                End If
            Else
                If here$ = vbNullString Then
                    MyEr "in command prompt", "СТГМ ЕИСАЦЫЦч ЕМТОКЧМ"
                Else
                    MyEr "in module " + GetName(sbf(x1).goodname), "СТО ТЛчЛА " + GetName(sbf(x1).goodname)
                End If
            End If
            If InStr(FK$(13), ",") > 0 Then
                GoTo thh
            End If
            If (Len(sbf(x1).sb) - Len(bb$)) < 0 Then
                FK$(13) = pa$
            Else
                DropLeft ",", FK$(13)
                If FK$(13) <> "" Then FK$(13) = "+" + FK$(13)
                FK$(13) = pa$ + str$(-Len(bb$)) + FK$(13)
            End If
        Else
            If sb2used > 0 Then
                MyEr "in module " + GetName(here$), "СТО ТЛГЛА " + GetName(here$)
            Else
                MyEr "", ""
            End If
        End If
th0:
        bs.UseofIf = 0
        GoTo thh
    Case 1, 3
thh:
        TestShowBypass = False
        If bs.IamChild Then
            If Not bs.soros Is bs.Parent.soros Then
                Set bs.Parent.Sorosref = bs.soros
            End If
        End If
        If LastErNum <> 0 And bs.ErrorOriginal = 0 Then
            rest$ = vbNullString
            bs.UseofIf = 0
        End If
        If Not EXITNOW Then If bs.UseofIf > 0 Then MissENDIF: ProcModuleEntry = False
thh1:
        On Error Resume Next
        If Not basestack.CopyInOutCol Is Nothing Then CopyBack basestack
        With bs
            .ThrowThreads
            MOUT = False
            var2used = .Vars
            varhash.ReduceHash Vname, var()
            If UBound(var()) <> varhash.MaxSpace Then
                    ReDim Preserve var(varhash.MaxSpace) As Variant
            End If
            sb2used = subs
            subHash.ReduceHash snames, sbf()
            If UBound(sbf()) <> subHash.MaxSpace Then
                    ReDim Preserve sbf(subHash.MaxSpace) As modfun
            End If
            If .commnum <> comhash.count Then comhash.ReduceHash .commnum, sbf()
            If .numfunnum <> funid.count Then funid.ReduceHash .numfunnum
            If .strfunnum <> strfunid.count Then strfunid.ReduceHash .strfunnum
            If .strnum <> strid.count Then strid.ReduceHash .strnum
            If sbf(x1).sbc Then
                numid.poptopGlobal
                funid.poptopGlobal
                strfunid.poptopGlobal
                strid.poptopGlobal
            Else
                numid.poptop
                funid.poptop
                strfunid.poptop
                strid.poptop
            End If
        End With
        Set bs = Nothing
        here$ = ohere$
        Exit Do
    Case 2
        I = 1
        If Len(bb$) <> 0 Then
            If bb$ = ChrW$(0) Then
                If trace Then TestShowBypass = False
unwindstack:
                If Not bs.IsInRetStackString(small$) Then
                    p = bs.isPop3Long(S3, sbi)
                    If p > 0 Then
                        If S3 > 0 Then
                            bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                        Else
                            bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                        End If
                        If trace Then
                            TestShowBypass = True
                            If TestShowBypass Then
                                If S3 < 0 Then
                                    TestShowSub = var(-S3).code
                                Else
                                    TestShowSub = sbf(S3).sb
                                End If
                            End If
                            bs.addlen = sbi
                        End If
                        PopStage bs
                        GoTo againmod
                    Else
fulty:
                        MyEr "Fault in Return", "кэХОР СТГМ еПИСТЯОЖч"
                        bs.Flush
                        Exit Do
                    End If
                Else
                    If InStr(small$, " ") > 0 Then
                        bs.PushSecondThird S3, sbi
                        If searchsub(x1, small$, I, S3, bb$) Then
                            If Len(small$) <> 0 Then
                                If Not MyRead(7, bs, small$, 1) Then
                                    bb$ = "  "
                                    GoTo myerror1
                                End If
                            End If
                            GoTo contSub
                            ' x1 here is wrong...Check this
                        'ElseIf x1 <> basestack.OriginalCode And basestack.OriginalCode <> 0 Then
                            ElseIf basestack.IamChild Then  ' maybe I use this line not above
                            If searchsub(FindPrevOriginal(bs), small$, I, S3, bb$) Then
                                If Len(small$) <> 0 Then
                                If Not MyRead(7, bs, small$, 1) Then
                                
                                'bb$ = "  "
                                'GoTo myerror1
                                End If
                                End If
contSub:
                                If Len(bb$) = 0 Then
                                    If S3 < 0 Then
                                        bb$ = Mid$(var(-S3).code, I)
                                    Else
                                        bb$ = Mid$(sbf(S3).sb, I)
                                    End If
                                    sbi = 0
                                Else
                                    If S3 < 0 Then
                                        sbi = Len(var(-S3).code) - I - Len(bb$)
                                    Else
                                        sbi = Len(sbf(S3).sb) - I - Len(bb$)
                                    End If
                                End If
                                If LastErNum = -1 Then
                                    GoTo unwindstack
                                End If
                                If trace Then
                                    TestShowBypass = True
                                    If TestShowBypass Then
                                        If S3 < 0 Then
                                            TestShowSub = var(-S3).code
                                        Else
                                            TestShowSub = sbf(S3).sb
                                        End If
                                    End If
                                    bs.addlen = Len(TestShowSub) - I + 1 - Len(bb$)
                                End If
                                GoTo againmod
                            Else
therebad:
                            badSubNotFound
                            If bs.IsDecimal Then
                            p = bs.Pop3Long(S3, sbi)
                            If S3 > 0 Then
                                bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                             ElseIf S3 = 0 Then
                       
                            Else
                                bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                            End If
                            End If
                            bs.RetStackDrop 3 '5
                            GoTo myerror1
                            End If
                        Else
                            GoTo therebad
                            
                        End If
                    End If
                End If
            ElseIf bb$ = "BREAK" Then
                    GoTo thh1
            Else
                If sbf(S3).subs Is Nothing Then
                    Set sbf(S3).subs = New FastCollection
                End If
                If sbf(S3).subs.ExistKey(bb$) Then
                    If IsNumeric(sbf(S3).subs.Value) Then
                        I = sbf(S3).subs.Value
                        x1 = S3
                    Else
                        I = val(Split(sbf(S3).subs.Value)(0))
                        x1 = val(Split(sbf(S3).subs.Value)(1))
                    End If
                   
                Else
                    If InStr(bb$, vbCr) > 0 Then
                        I = rinstr(sbf(S3).sb, bb$)
                        If I = 0 Then I = Len(sbf(S3).sb) + 1
                    Else
                        I = PosLabel(bb$, sbf(S3).sb)
                    End If
                    sbf(S3).subs.AddKey bb$, I
                    x1 = S3
                End If
                If trace Then
                    bs.addlen = 0
                    TestShowBypass = True
                    TestShowSub = sbf(S3).sb
                End If
                If bs.SubLevel > 0 Then
                    If x1 = S3 Then
                        If Len(sbf(S3).sb) - I > sbi Then
                            bb$ = Mid$(sbf(S3).sb, I, Len(sbf(S3).sb) - I - sbi)
                            GoTo againmod
                        Else
                            sbi = 0
                        End If
                    Else
                        sbi = 0
                    End If
                Else
                    sbi = 0
                End If
            End If
        Else
            If Not loopthis Then GoTo thh1
            loopthis = False
        End If
    Case 12
        MyEr "Exit for out of for next loop", "╦НОДОР ЦИА щНЫ АПЭ цИА еПЭЛЕМО"
        Exit Do
    End Select
    If Not restart Then
        restart = True
        bs.IFCTRL = False
        bs.jump = False
        If bs.RetStackTotal > 0 Then
            bs.UseofIf = 0
            bs.Flush
        End If
    End If
Loop
ProcModuleEntry = True
modfun:
If trace Then SwapStrings backup$, TestShowSub: TestShowBypass = TSHB
Exit Function
there22:
If Err Then
    MyEr Err.Description, Err.Description
    Err.Clear
    If Not bs Is Nothing Then GoTo thh
End If
GoTo modfun
End Function
Function PushParamGeneralV70(basestack As basetask, rest$, rest1$) As Boolean
Dim ps As mStiva
Set ps = New mStiva
If Len(rest1$) > 0 Then
If lookOne(rest1$, ")") Then PushParamGeneralV70 = True: GoTo conthere
If Not PushParamGeneralV7(basestack, rest1$, ps) Then Exit Function
End If
If Len(rest$) > 0 Then
If lookOne(rest$, ")") Then PushParamGeneralV70 = True: GoTo conthere
If Not PushParamGeneralV7(basestack, rest$, ps) Then Exit Function
End If
conthere:
PushParamGeneralV70 = True
With basestack
  If .SorosNothing Then

    Set .Sorosref = ps
  Else
     .soros.MergeTop ps
  End If
End With

End Function
Private Function PushParamSUB(basestack As basetask, rest$) As Boolean
PushParamSUB = True

Dim ps As mStiva, p As Variant, s$, usehandler As mHandler, usestiva As mStiva
    Set ps = New mStiva
    
    Set basestack.lastobj = Nothing
                Do
            If FastSymbol(rest$, "?") Then
                        ps.DataOptional
            ElseIf FastSymbol(rest$, "!") Then
                If IsExp(basestack, rest$, p, nostring:=True) Then
                If basestack.lastobj Is Nothing Then
                   ps.DataValLong p
                ElseIf TypeOf basestack.lastobj Is mHandler Then
                    Set usehandler = basestack.lastobj
                    If TypeOf usehandler.objref Is mStiva Then
                        ps.MergeBottom usehandler.objref
                    ElseIf TypeOf usehandler.objref Is mArray Then
                     ps.MergeBottomCopyArray usehandler.objref
                        Else
                            PushParamSUB = False
                            MyEr "Expected Stack Object after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО ТЩПОУ сЫЯОЩ ЛЕТэ ТО !"
                            Set basestack.lastobj = Nothing
                            Exit Function
                    End If
                    Set usehandler.objref = Nothing
                ElseIf TypeOf basestack.lastobj Is mArray Then
                     ps.MergeBottomCopyArray basestack.lastobj
                     
                End If
                Set basestack.lastobj = Nothing
                End If
                ElseIf IsExp(basestack, rest$, p) Then
                If Not basestack.lastobj Is Nothing Then
                If TypeOf basestack.lastobj Is mStiva Then
                    Set usestiva = basestack.lastobj
                    ps.MergeBottom usestiva
                    Set usestiva = Nothing
                ElseIf Not basestack.lastpointer Is Nothing Then
                    ps.DataObj basestack.lastobj
                    Set basestack.lastpointer = Nothing
                    
                ElseIf Not basestack.lastobj Is Nothing Then
                    ps.DataObj basestack.lastobj

                End If
                Set basestack.lastobj = Nothing
       
            Else
            If myVarType(p, vbString) Then
                SwapString2Variant s$, p
                ps.DataStr s$
            Else
                ps.DataVal p
            End If
        End If
    ElseIf Not LastErNum <> 0 Then
    If IsStrExp(basestack, rest$, s$, False) Then  ' Len(basestack.tmpstr) = 0
       If Not basestack.lastpointer Is Nothing Then
            ps.DataObj basestack.lastobj
            Set basestack.lastpointer = Nothing
        ElseIf Not basestack.lastobj Is Nothing Then
           ps.DataObj basestack.lastobj
        Else
            ps.DataStr s$
        End If
        Set basestack.lastobj = Nothing
    ElseIf lookOne(rest$, ",") Then
        ps.DataOptional
    ' here
    End If
    Else
  If LastErNum <> 0 Then
    
     PushParamSUB = False
  Exit Do
    End If
    End If
      If LastErNum <> -2 And LastErNum <> 0 Then
      MyEr "Error in input list", "пЯЭБКГЛА СТИР ПАЯАЛщТЯОУР"
      
      PushParamSUB = False
      Exit Do
      End If
    If Not FastSymbol(rest$, ",") Then Exit Do
                Loop
             With basestack
             If .SorosNothing Then
           
               Set .Sorosref = ps
             Else
                .soros.MergeTop ps
             End If
             End With
            
End Function
Private Function PushParamGeneralV7(basestack As basetask, rest$, ps As mStiva) As Boolean
PushParamGeneralV7 = True
Dim p As Variant, s$, usehandler As mHandler, usestiva As mStiva
Dim ParentStack As basetask
Set ParentStack = basestack.Parent
Set ParentStack.lastobj = Nothing
            Do
            If FastSymbol(rest$, "?") Then
                ps.DataOptional
            ElseIf FastSymbol(rest$, "!") Then
                If IsExp(ParentStack, rest$, p) Then
                    If ParentStack.lastobj Is Nothing Then
                        ps.DataValLong p
                    ElseIf TypeOf ParentStack.lastobj Is mHandler Then
                        Set usehandler = ParentStack.lastobj
                        If TypeOf usehandler.objref Is mStiva Then
                            ps.MergeBottom usehandler.objref
                        ElseIf TypeOf usehandler.objref Is mArray Then
                            ps.MergeBottomCopyArray usehandler.objref
                        Else
                            PushParamGeneralV7 = False
                            MyEr "Expected Stack Object after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО ТЩПОУ сЫЯОЩ ЛЕТэ ТО !"
                            Set ParentStack.lastobj = Nothing
                            ParentStack.modfuncall = False
                            Exit Function
                        End If
                        Set usehandler.objref = Nothing
                    ElseIf TypeOf ParentStack.lastobj Is mArray Then
                          ps.MergeBottomCopyArray ParentStack.lastobj
                    End If
                    Set ParentStack.lastobj = Nothing
                End If
        ElseIf IsExp(ParentStack, rest$, p) Then
            If Not ParentStack.lastobj Is Nothing Then
                If TypeOf ParentStack.lastobj Is mStiva Then
                    Set usestiva = ParentStack.lastobj
                    ps.MergeBottom usestiva
                    Set usestiva = Nothing
                ElseIf Not ParentStack.lastpointer Is Nothing Then
                    ps.DataObj ParentStack.lastobj
                    Set ParentStack.lastpointer = Nothing
                    Set ParentStack.lastobj = Nothing
                Else
                    ps.DataObj ParentStack.lastobj
                    Set ParentStack.lastobj = Nothing
                End If
                Set ParentStack.lastobj = Nothing
            Else
            If myVarType(p, vbString) Then
                SwapString2Variant s$, p
                ps.DataStr s$
            Else
                ps.DataVal p
            End If
            End If
    ElseIf Not LastErNum <> 0 Then
    ParentStack.modfuncall = True
    If IsStrExp(ParentStack, rest$, s$, False) Then 'Len(ParentStack.tmpstr) = 0
       If Not ParentStack.lastpointer Is Nothing Then
            ps.DataObj ParentStack.lastobj
            Set ParentStack.lastpointer = Nothing
            Set ParentStack.lastobj = Nothing
        ElseIf Not ParentStack.lastobj Is Nothing Then
            ps.DataObj ParentStack.lastobj
            Set ParentStack.lastobj = Nothing
        Else
        ps.DataStr s$
        End If
    ElseIf lookOne(rest$, ",") Then
        ps.DataOptional
    ' here
    End If
     ParentStack.modfuncall = False
    Else
  If LastErNum <> 0 Then
     PushParamGeneralV7 = False
  Exit Do
    End If
    End If
      If LastErNum <> -2 And LastErNum <> 0 Then
      MyEr "Error in input list", "пЯЭБКГЛА СТИР ПАЯАЛщТЯОУР"
      PushParamGeneralV7 = False
      End If
    If Not FastSymbol(rest$, ",") Then Exit Do
                Loop
             Set ParentStack = Nothing
End Function
Function PushParamGeneral(basestack As basetask, rest$, Optional ByVal temphere$) As Boolean
PushParamGeneral = True

Dim ps As mStiva, p As Variant, s$, ok As Long, usehandler As mHandler, usestiva As mStiva
    Set ps = New mStiva
    Set basestack.lastobj = Nothing
    Do
        If FastSymbol(rest$, "%") Then
            p = IsLabel(basestack, rest$, s$, True)
            ok = 1
            If p < 4 Then
                ExecuteVar ok, p, basestack, s$, rest$, (ok), 1, True, False, 0, "", 0, (temphere), False
                If ok <> 1 Then PushParamGeneral = False: basestack.modfuncall = False: Exit Function
                ps.DataOptional
            Else
                MyEr "Array can't pass by name", "о ПъМАЙАР ДЕМ ЛПОЯЕъ МА ПЕЯэСЕИ ЛЕ ЭМОЛА"
                PushParamGeneral = False: basestack.modfuncall = False: Exit Function
            End If
        ElseIf FastSymbol(rest$, "?") Then
            ps.DataOptional
        ElseIf FastSymbol(rest$, "!") Then
            If IsExp(basestack, rest$, p) Then
                If basestack.lastobj Is Nothing Then
                   ps.DataValLong p
                ElseIf TypeOf basestack.lastobj Is mHandler Then
                    Set usehandler = basestack.lastobj
                    If TypeOf usehandler.objref Is mStiva Then
                        ps.MergeBottom usehandler.objref
                    ElseIf TypeOf usehandler.objref Is mArray Then
                        ps.MergeBottomCopyArray usehandler.objref
                    Else
                        PushParamGeneral = False: basestack.modfuncall = False
                        MyEr "Expected Stack Object after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО ТЩПОУ сЫЯОЩ ЛЕТэ ТО !"
                        Set basestack.lastobj = Nothing
                        Exit Function
                    End If
                    Set usehandler.objref = Nothing
                ElseIf TypeOf basestack.lastobj Is mArray Then
                    ps.MergeBottomCopyArray basestack.lastobj
                End If
                Set basestack.lastobj = Nothing
            End If
        ElseIf IsExp(basestack, rest$, p) Then
            If Not basestack.lastobj Is Nothing Then
                If TypeOf basestack.lastobj Is mStiva Then
                    Set usestiva = basestack.lastobj
                    ps.MergeBottom usestiva
                    Set usestiva = Nothing
                ElseIf Not basestack.lastpointer Is Nothing Then
                    ps.DataObj basestack.lastobj
                    Set basestack.lastpointer = Nothing
                ElseIf Not basestack.lastobj Is Nothing Then
                    ps.DataObj basestack.lastobj
                End If
                Set basestack.lastobj = Nothing
            Else
                If myVarType(p, vbString) Then
                    SwapString2Variant s$, p
                    ps.DataStr s$
                Else
                    ps.DataVal p
                End If
            End If
        ElseIf Not LastErNum <> 0 Then
            basestack.modfuncall = True
            If IsStrExp(basestack, rest$, s$, False) Then ' Len(basestack.tmpstr) = 0
                If Not basestack.lastpointer Is Nothing Then
                    ps.DataObj basestack.lastobj
                    Set basestack.lastpointer = Nothing
                ElseIf Not basestack.lastobj Is Nothing Then
                    ps.DataObj basestack.lastobj
                Else
                    ps.DataStr s$
                End If
                Set basestack.lastobj = Nothing
            ElseIf lookOne(rest$, ",") Then
                ps.DataOptional
    ' here
            End If
            basestack.modfuncall = False
        Else
            If LastErNum <> 0 Then
                PushParamGeneral = False
            Exit Do
        End If
    End If
    If LastErNum <> -2 And LastErNum <> 0 Then
        MyEr "Error in input list", "пЯЭБКГЛА СТИР ПАЯАЛщТЯОУР"
        PushParamGeneral = False
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
Loop
With basestack
    If .SorosNothing Then
        Set .Sorosref = ps
    Else
        .soros.MergeTop ps
    End If
End With
End Function

Sub PushParamStraight(basestack As basetask, rest$)
Dim p As Variant, s$
    Dim ps As mStiva
    Set ps = basestack.soros
    basestack.modfuncall = True
                Do
                    If IsExp(basestack, rest$, p) Then
                            If Not basestack.lastpointer Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastpointer = Nothing
                                Set basestack.lastobj = Nothing
                            ElseIf Not basestack.lastobj Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastobj = Nothing
                            Else
                                If myVarType(p, vbString) Then
                                    SwapString2Variant s$, p
                                    ps.DataStr s$
                                Else
                                    ps.DataVal p
                                End If
                            End If
                    ElseIf IsStrExp(basestack, rest$, s$, False) Then ' Len(basestack.tmpstr) = 0
                    
                            If Not basestack.lastpointer Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastpointer = Nothing
                                Set basestack.lastobj = Nothing
                            ElseIf Not basestack.lastobj Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastobj = Nothing
                            Else
                                ps.DataStr s$
                            End If

                    Else
                    
                            Exit Do
                    End If
                    If Not FastSymbol(rest$, ",") Then Exit Do
                Loop
        basestack.modfuncall = False
             Set ps = Nothing
End Sub

Function searchsub(ByVal where As Long, W$, Final As Long, site As Long, code$, Optional needfunc As Boolean = False) As Boolean
Static aCopy As New Document
Dim EndPoint As Long
Dim ww$(), vv()
ww$() = Split(W$)
If where = 0 Or W$ = "" Then
Exit Function
Else
If where < 0 Then
    With var(-where)
    If .subs Is Nothing Then
        Set .subs = New FastCollection
    Else
        If UBound(ww$()) = 0 Then
            W$ = ww$(0)
        ElseIf needfunc Then
            W$ = "@" + ww$(1)
        Else
            W$ = ww$(1)
        End If
        If .subs.ExistKey(UCase(W$)) Then
        
            vv = .subs.Value
            Final = vv(0)
            site = vv(1)
            W$ = vv(2)
            code$ = vv(3)
            searchsub = True
        Exit Function
        End If
        W$ = Join(ww$)
    End If
    End With
Else
    With sbf(where)
    If .subs Is Nothing Then
        Set .subs = New FastCollection
    Else
        If UBound(ww$()) = 0 Then
            W$ = ww$(0)
        ElseIf needfunc Then
            W$ = "@" + ww$(1)
        Else
            W$ = ww$(1)
        End If
        If .subs.ExistKey(UCase(W$)) Then
            '  EndPoint ???????????
            vv = .subs.Value
            Final = vv(0)
            site = vv(1)
            W$ = vv(2)
            code$ = vv(3)
        WaitShow = 0
        searchsub = True
        Exit Function
        End If
        W$ = Join(ww$)
    End If
    End With
    End If
End If

Dim len1 As Long, there1 As Long, A$
Dim there As Long, Curs As Long, Curs2 As Long
Dim a1 As Long, b As Long, c As Long, D As Long
Dim ss$, Dump$
len1 = Len(ww$(0))
If len1 = 1 Then
' looking for simple sub
    If ww$(0) = "S" Then
          ' labelname: /// return  (maybe more than one labels
        Set aCopy = New Document
        With aCopy
            .EmptyDoc
            If where > 0 Then
                .textDocFast = sbf(where).sb
            Else
                .textDocFast = var(-where).code$
            End If
            .LCID = 1032
            ww$(1) = ww$(1) + ":"
            Do While .FindIdentifier(ww$(1), False, there, Curs)
                If NLtrim$(Left$(.TextParagraph(there), Curs - 1)) = vbNullString Then
                    Final = -1
                    .FindPos .FirstParagraphLine(there) + 2, 1, Final, a1, b, c, D
                    Final = Final + 1 ' because mid$ starts from 1
                    W$ = vbNullString
                    searchsub = True
                    GoTo register
                End If
            Loop
        End With
    Else
        ' looking Number ///return (maybe more than one return statements)
        If where > 0 Then
            Final = PosLabel(ww$(1), sbf(where).sb)
        Else
            Final = PosLabel(ww$(1), var(-where).code$)
        End If
        
        If Final <> 1 Then
            
            If where > 0 Then
                If Final > Len(sbf(where).sb) Then Exit Function
            Else
                If Final > Len(var(-where).code$) Then Exit Function
            End If
            W$ = vbNullString
            searchsub = True
            GoTo register
        End If
    End If
    Exit Function
End If
' No we have something better
'Set aCopy = New Document

With aCopy
    .EmptyDoc
    .textDocFast = A$
    If where > 0 Then
        .textDocFast = sbf(where).sb
    Else
        .textDocFast = var(-where).code$
    End If
    .LCID = 1032
paliedo:
    there = 0
    Curs = 0
    Do
        If .FindIdentifier(ww$(0), False, there, Curs) Then
            ss$ = Left$(aCopy.TextParagraph(there), Curs - 1)
            IsNumberLabel ss$, Dump$
            If Trim$(ss$) = vbNullString Then
                Curs2 = Curs
                there1 = there
                If .FindIdentifier(ww$(1), True, there1, Curs2) Then
                    If there1 <> there Then
                        Curs = 0
                    Else
                        Final = -1
                        .FindPos .FirstParagraphLine(there1) + 2, 1, Final, a1, b, c, D
                        Final = Final + 1 ' because mid$ starts from 1
                        W$ = BlockParam(Trim(Mid$(.TextParagraph(there), Curs2 + Len(ww(1)))))
                        searchsub = True
                        Exit Do
                    End If
                End If
            End If
        Else
            If ww$(0) = "яоутима" Then
                ww$(0) = "яоут╨ма"
                GoTo paliedo
            ElseIf ww$(0) = "сумаятгсг" Then
                ww$(0) = "сум╒ятгсг"
                GoTo paliedo
            End If
            Exit Do
        End If
    Loop
End With
register:
If searchsub Then
If where > 0 Then
site = where
sitehere:
        If sbf(site).subs Is Nothing Then Set sbf(site).subs = New FastCollection
        code$ = vbNullString
        If Len(ww$(0)) > 1 Then
            EndPoint = Final
            If Not aheadstatusENDSUBorFUN(sbf(where).sb, EndPoint, -(AscW(ww$(0)) < 128), needfunc) Then
                If needfunc Then MisEndFunc Else MisEndSub
                searchsub = False
                Exit Function
            End If
            code$ = Mid$(sbf(where).sb, Final, EndPoint - Final)
        End If
        
        If needfunc Then
            sbf(site).subs.AddKey "@" + UCase(ww$(1)), Array(Final, where, W$, code$)
        Else
            sbf(site).subs.AddKey UCase(ww$(1)), Array(Final, where, W$, code$)
        End If
ElseIf where < 0 Then
site = where
sitethere:
    If var(-site).subs Is Nothing Then Set var(-site).subs = New FastCollection
        code$ = vbNullString
        If Len(ww$(0)) > 1 Then
            EndPoint = Final
            If Not aheadstatusENDSUBorFUN(var(-where).code$, EndPoint, -(AscW(ww$(0)) < 128), needfunc) Then
                If needfunc Then MisEndFunc Else MisEndSub
                searchsub = False
                Exit Function
            End If
            code$ = Mid$(var(-where).code$, Final, EndPoint - Final)
        End If
        If needfunc Then
            var(-site).subs.AddKey "@" + UCase(ww$(1)), Array(Final, where, W$, code$)
        Else
            var(-site).subs.AddKey UCase(ww$(1)), Array(Final, where, W$, code$)
        End If
    End If
End If
End Function

Function executeblock(Exec As Long, bstack As basetask, b$, once As Boolean, kolpo As Boolean, Optional ByVal stepbystep As Boolean = False, Optional skipblock As Boolean = False, Optional noblock As Boolean = True) As Boolean
executeblock = True
Dim I As Long, LL As Long, oldLL As Long, p As Long
Dim x2 As Long, y2 As Long, monce As Long, w3 As Long
Dim myLevel As Long, oldexec As Long, loopthis As Boolean, RetStackSize As Long
Dim subs As FastCollection
Dim oldjump As Long, oldifctrl As Long, olduseofif As Long
Dim S3 As Long, bb$, small$, ex2 As Long, sbi As Long
' save state in execution stack
oldjump = bstack.jump: oldifctrl = bstack.IFCTRL: olduseofif = bstack.UseofIf
RetStackSize = bstack.RetStackTotal
If Exec = 0 Then Exec = 1
oldexec = Exec: myLevel = bstack.SubLevel: I = 1
If noblock Then monce = once Else monce = True

If Not skipblock Then  ' find block
    ex2 = blockLen(b$)
    If bstack.addlen <> 0 Then
        LL = bstack.addlen + Len(b$) - ex2 + 1
    Else
        LL = Len(b$) - ex2 + 1
    End If
Else
    LL = bstack.addlen
End If
oldLL = bstack.addlen
If ex2 > 0 Then ex2 = ex2 - 1 Else ex2 = Len(b$)
sbi = ex2
Do
    bb$ = Mid$(b$, I, ex2 - I + 1)
fromfirst0:
    kolpo = once: once = False
    bstack.addlen = LL
   
    w3 = Execute(bstack, bb$, kolpo, stepbystep, loopthis, noblock)
'    If NOEXECUTION Then w3 = 0
    
    bstack.addlen = oldLL
cont111:
    Select Case w3
    Case 0
Error1:
                
        If bstack.RetStackTotal - RetStackSize > 0 Then
            bstack.UseofIf = olduseofif
            bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
        End If
        If myLevel <> bstack.SubLevel Then
            b$ = bb$
            Exec = 0
            Exit Function
        End If
        If NocharsInLine(bb$) Then
            b$ = vbNullString
        Else
            If LastErNum = -2 Then
                SwapStrings b$, bb$
            ElseIf LL >= oldLL Then
                b$ = bb$ + space$(LL - oldLL)
            Else
                b$ = vbNullString$
            End If
        End If
        Exec = 0
        Exit Function
    Case 1
ALFA12:
        If LastErNum = -2 Then
            If NocharsInLine(bb$) Then
                b$ = vbNullString
            Else
                If Left$(bb$, 12) = " : ERROR -2" Then
                    b$ = bb$
                ElseIf ex2 < Len(bb$) Then
                    b$ = vbNullString
                Else
                    b$ = Mid$(b$, ex2 - Len(bb$) + 1)
                End If
            End If
            Exec = 0
            Exit Function
        End If
        Exec = oldexec ''1
        If kolpo And monce And Exec = 1 Then
            SwapStrings b$, bb$
            once = True
            Exit Function
        ElseIf kolpo And NocharsInLine(bb$) Then
            If RetStackSize < bstack.RetStackTotal Then PopStagePart bstack, bstack.RetStackTotal - RetStackSize
            Exec = w3
            Exit Do
        End If
        If stepbystep Then
            b$ = bb$
        Else
            b$ = Right$(b$, Len(b$) - ex2)
        End If

        Exit Do
    Case 2
        If bb$ = "BREAK" Then
            Exec = 2
            If noblock Then
                b$ = vbNullString
            Else
                SwapStrings b$, bb$
            End If
            once = True
            kolpo = True
            Exit Function
        ElseIf bb$ = "NEXT" Then
            SwapStrings b$, bb$
            If RetStackSize < bstack.RetStackTotal Then
                Exec = 2
                PopStagePartContinue bstack, bstack.RetStackTotal - RetStackSize
            Else
                Exec = 2
            End If
            Exit Do
        End If
        
        If Not kolpo Then
            If Len(bb$) > 0 Then
                If bb$ = ChrW$(0) Then
                    'bstack.addlen = 0
                    If trace Then TestShowBypass = False
                    If RetStackSize >= bstack.RetStackTotal Then
                        If bstack.IsDecimal Then
                            ' this is a return form other block
                            Exec = 2
                            b$ = bb$
                            Exit Function
                        End If
                    ElseIf Not bstack.IsDecimal Then
                        If RetStackSize < bstack.RetStackTotal Then PopStagePartContinue bstack, bstack.RetStackTotal - RetStackSize
                    End If
                    I = 1
from123:
                    If Not bstack.IsInRetStackString(small$) Then
                        p = bstack.Pop3Long(S3, sbi)
                        If p < 0 Then
                            Exec = 0
                            If RetStackSize <> bstack.RetStackTotal Then
                                MyEr "Problem in return stack", "пЯЭБКГЛА СТО СЫЯЭ ЕПИСТЯОЖчР"
                            End If
                            bstack.Flush
                            b$ = vbNullString
                            Exit Function
                        End If
                        If LastErNum = -1 Then
                            bstack.RetStack.PushLong p
                            Exec = 0
                            Exit Function
                        End If
jumphere1:
                        If S3 = 0 And sbi > 0 Then
                        
                        End If
                        Exec = 1
                        I = ex2 - p + 1
                        PopStage bstack
                        If loopthis Or stepbystep Or x2 = 2 Then
                            bb$ = Mid$(b$, I, ex2 - I + 1)
                            
                            
                            bstack.addlen = oldLL
                            If x2 = 2 Or stepbystep Then
                                If bb$ = vbCrLf Then bb$ = vbNullString: w3 = 1: GoTo cont111
                                If bb$ = " " Then bb$ = vbNullString: w3 = 1: GoTo cont111
                            End If
                            GoTo fromfirst0
                        Else
                            bb$ = Mid$(b$, p + 1, ex2 - p)
                        End If
                        If bb$ = vbCrLf Then Exit Do
                    Else
findelsesub0:
                        If InStr(small$, " ") > 0 Then
                            bstack.PushSecondThird S3, sbi
                            S3 = bstack.OriginalCode
                            If searchsub(S3, small$, I, S3, bb$) Then
                                If Len(small$) <> 0 Then
                                    If Not MyRead(7, bstack, small$, 1) Then
                                        Exec = 0
                                        Exit Function
                                    End If
                                End If
                                GoTo contSub
                            ElseIf bstack.IamChild Then
                                If searchsub(FindPrevOriginal(bstack), small$, I, S3, bb$) Then
                                If Len(small$) <> 0 Then
                                    If Not MyRead(7, bstack, small$, 1) Then
                                        Exec = 0
                                        Exit Function
                                    End If
                                End If
contSub:
                                If Len(bb$) = 0 Then
                                    If S3 < 0 Then
                                        bb$ = Mid$(var(-S3).code, I)
                                    Else
                                        bb$ = Mid$(sbf(S3).sb, I)
                                    End If
                                    sbi = 0
                                Else
                                    If S3 < 0 Then
                                        sbi = Len(var(-S3).code) - I - Len(bb$)
                                    Else
                                        sbi = Len(sbf(S3).sb) - I - Len(bb$)
                                    End If
                                End If
                                kolpo = False
                                
                                If trace Then
                                    TestShowBypass = True
                                    If TestShowBypass Then
                                    If S3 < 0 Then
                                        TestShowSub = var(-S3).code
                                    Else
                                        TestShowSub = sbf(S3).sb
                                    End If
                                    End If
                                    bstack.addlen = Len(TestShowSub) - I + 1 - Len(bb$)
                                End If
                                
                                y2 = y2 + 1
subsub02:
                                Exec = 0
                                x2 = Execute(bstack, bb$, kolpo)
                                If x2 = 2 Then
                                    If bb$ = Chr$(0) Then
                                        If trace Then TestShowBypass = False
                                        If bstack.IsInRetStackString(small$) Then GoTo findelsesub0
                                        y2 = y2 - 1
                                        If y2 = 0 Then GoTo from123  'normal level
                                            p = bstack.isPop3Long(S3, sbi)
                                            If p > 0 Then
                                                If S3 > 0 Then
                                                
                                                    bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                                ElseIf S3 = 0 Then
                                                    GoTo jumphere1
                                                Else
                                                    bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                                End If
                                                If trace Then
                                                    TestShowBypass = True
                                                    If TestShowBypass Then
                                                        If S3 < 0 Then
                                                            TestShowSub = var(-S3).code
                                                        Else
                                                            TestShowSub = sbf(S3).sb
                                                        End If
                                                    End If
                                                    bstack.addlen = sbi
                                                End If
                                                
                                                PopStage bstack
                                                Exec = 1
                                                GoTo subsub02
                                            Else
                                                Exit Do
                                            End If
                                        ElseIf InStr(bb$, " ") > 0 Then
                                            GoTo findelsesub0
                                        Else
                                             If subs Is Nothing Then Set subs = New FastCollection
                                             If subs.ExistKey(bb$) Then
                                                I = subs.Value
                                                If subs.sValue = 0 Then
                                                    If I = 0 Or I > ex2 Then
                                                        b$ = bb$
                                                        Exec = 2
                                                        Exit Do
                                                    Else
                                                        bb$ = Mid$(b$, I, ex2 - I + 1)
                                                    End If
                                                Else
                                                    S3 = subs.sValue
                                                    If S3 < 0 Then
                                                        If I = 0 Or I > Len(var(-S3).code$) Then
                                                            b$ = bb$
                                                            Exec = 2
                                                            Exit Do
                                                        End If
                                                        GoTo AGAINGOTOLAMBDA
                                                    Else
                                                        If I = 0 Or I > Len(sbf(S3).sb) Then
                                                            b$ = bb$
                                                            Exec = 2
                                                            Exit Do
                                                        End If
                                                        GoTo AGAINGOTO
                                                    End If
                                                    
                                                End If
                                                GoTo subsub02
                                            Else
                                                If S3 = 0 Then
                                                ' priority in the code
                                                    I = PosLabel(bb$, b$, ex2)
                                                    If I = 0 Or I > ex2 Then
                                                        GoTo checkother
                                                    Else
                                                        subs.ItemCreator2 bb$, I, 0
                                                        bb$ = Mid$(b$, I, ex2 - I + 1)
                                                        GoTo subsub02
                                                    End If
                                                    
                                                End If
                                                
checkother:
                                                If S3 < 0 Then
                                                    I = PosLabel(bb$, var(-S3).code$)
                                                    If I = 0 Or I > Len(var(-S3).code$) Then
                                                        b$ = bb$
                                                        Exec = 2
                                                        Exit Do
                                                    End If
AGAINGOTOLAMBDA:
                                                    subs.ItemCreator2 bb$, I, S3
                                                    If Len(var(-S3).code$) - I > sbi Then
                                                    bb$ = Mid$(var(-S3).code$, I, Len(var(-S3).code$) - I - sbi)
                                                    Else
                                                    bb$ = Mid$(var(-S3).code$, I)
                                                    sbi = 0
                                                    End If
                                                ElseIf S3 > 0 Then
                                                    I = PosLabel(bb$, sbf(S3).sb)
                                                    If I = 0 Or I > Len(sbf(S3).sb) Then
                                                        b$ = bb$
                                                        Exec = 2
                                                        Exit Do
                                                    End If
                                                    subs.ItemCreator2 bb$, I, S3
AGAINGOTO:
                                                    If Len(sbf(S3).sb) - I > sbi Then
                                                    bb$ = Mid$(sbf(S3).sb, I, Len(sbf(S3).sb) - I - sbi)
                                                    Else
                                                    bb$ = Mid$(sbf(S3).sb, I)
                                                    sbi = 0
                                                    End If
                                                Else ' cascade to upper level
                                                    b$ = bb$
                                                    Exec = 2
                                                    Exit Do
                                                End If
                                                GoTo subsub02
                                            End If
                                        End If
                                    ElseIf x2 = 1 Then
                                        If LastErNum <> -2 Then
                                        ' not good, we have to find which blocks
                                        ' 7 to 5 reduced
                                            bstack.RetStackDrop 5 * bstack.SubLevel - myLevel
                                            ' b$ = ec$  ' why??
                                            Exec = oldexec
                                            Exit Function
                                        End If
                                        ' NO RETURN...DROP STACK
                                        bstack.RetStackDrop 2
                                        Exit Do
                                    ElseIf x2 = 0 Then
                                        If bstack.ErrorOriginal <> 0 Then
                                        b$ = bb$
                                        ElseIf S3 <> 0 Then
                                        
                                           ' If bstack.OriginalCode <> S3 Then
                                            bstack.ErrorOriginal = S3
                                                'If S3 < 0 Then
                                                '    b$ = Mid$(var(-S3).code, Len(var(-S3).code) - sbi - Len(bb$))
                                                'Else
                                                b$ = bb$ + space(sbi + 1) 'Mid$(sbf(S3).sb, Len(sbf(S3).sb) - sbi - Len(bb$))
                                                'End If
                                            'Else
                                            'b$ = bb$  '+ space(sbi)
                                            'End If
                                        Else
                                        bstack.ErrorOriginal = 0
                                        b$ = bb$ + space(sbi)
                                        End If
                                        Exec = 0
                                        Exit Function
                                    End If
                                Else
                                    badSubNotFound
                                    Exec = 0
                                    If bstack.IsDecimal Then
                                         p = bstack.Pop3Long(S3, sbi)
                                         If S3 > 0 Then
                                             bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                          ElseIf S3 = 0 Then
                                            bb$ = Mid$(b$, p + 1, ex2 - p)
                                         Else
                                             bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                         End If
                                    End If
                                    bstack.RetStackDrop 3 '5
                                    GoTo Error1
                                End If
                            Else
                                bstack.RetStackDrop 3 '5
                                Exit Do
                            End If
                        Else
                            bstack.RetStackDrop 1
                            b$ = Chr$(0)
                            Exec = 2
                            Exit Function
                        End If
                    End If
                ElseIf lookOne(bb$, "}") Or NocharsInLine(bb$) Then
                    I = 1
                    bb$ = Left$(b$, ex2)
                Else
                    If monce = True Then
                        b$ = bb$
                        Exec = w3
                        Exit Do
                    End If
                    If subs Is Nothing Then Set subs = New FastCollection
                    If subs.ExistKey(bb$) Then
                        I = subs.Value
                        If I = 0 Or I > ex2 Then
                            b$ = bb$
                            Exec = 2
                            Exit Do
                        Else
                            bb$ = Mid$(b$, I, ex2 - I + 1)
                            GoTo fromfirst0
                        End If
                    Else
                        I = PosLabel(bb$, b$, ex2)
                        If I = 0 Or I > ex2 Then
                            b$ = bb$
                            Exec = 2
                            Exit Do
                        Else
                            subs.ItemCreator2 bb$, I, 0
                            bb$ = Mid$(b$, I, ex2 - I + 1)
                            GoTo fromfirst0
                        End If
                    End If
                End If
            Else
                If noblock Then
                    If loopthis And w3 = 2 Then
                        oldexec = 2
                        If Len(NLtrim$(bb$)) > 0 Then
                            GoTo fromfirst0
                        End If
                        loopthis = False
                        I = 1
                        oldexec = 1
                    Else
                        I = 1
                    End If
                Else
                    If w3 = 2 Then w3 = 6
                    Exec = w3
                    Exit Function
                End If
            End If
        Else
            If monce Then
                If loopthis And kolpo Then Exec = 5: b$ = bb$: Exit Function
                kolpo = False
            Else
                once = kolpo
            End If
            'If checkbreakEsc(bstack) Then Exec = oldexec: Exit Do
            Exec = 2: b$ = bb$: Exit Function
        End If
    Case Else
        If w3 = 12 Then
            b$ = bb$
            Exec = 12
            Exit Do
        ElseIf w3 = 3 And bb$ = "CONTINUE" Then
            If noblock Then
                b$ = Mid$(b$, ex2 + 1)
            Else
                b$ = bb$
            End If
            If RetStackSize < bstack.RetStackTotal Then PopStagePartContinue bstack, bstack.RetStackTotal - RetStackSize
           ' If checkbreakEsc(bstack) Then Exec = oldexec: Exit Do
            Exec = 3: Exit Do
        ElseIf w3 = 3 And NocharsInLine(bb$) Then
        If Not skipblock Then bb$ = "}"
          ' bb$ = Mid$(b$, ex2 + 1)
            If Exec = 2 Then Exec = 1: loopthis = False
            oldexec = 1
            w3 = 1
            If RetStackSize < bstack.RetStackTotal Then PopStagePart bstack, bstack.RetStackTotal - RetStackSize

            GoTo ALFA12   ' FROM REVISION 121
        ElseIf w3 = 5 Then
            oldexec = 5
            If Len(NLtrim$(bb$)) > 0 Then GoTo fromfirst0
            Exec = 5
            Exit Function
        End If
        If IsSymbol(b$, "}") Then
            Exec = 1: Exit Do
            If once Then Exit Do
        Else
            b$ = Right$(b$, Len(b$) - Len(bb$))
        End If
        Exit Do
    End Select
   
    'If checkbreakEsc(bstack) Then Exec = oldexec: Exit Do
    If monce Then Exit Do
Loop
If Exec > 1 Then
    If bstack.RetStackTotal - RetStackSize > 0 Then
        bstack.UseofIf = olduseofif
        bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
    End If
End If
bstack.jump = oldjump
bstack.IFCTRL = oldifctrl

executeblock = False
End Function
Function StockValues(bstack As basetask, b$, Lang As Long) As Boolean
' Stock  A[$|%| ]() in  A,B$,C(3)   copy values to stock array...and

' Stock  A[$|%| ]() out  A,B$,C(3),...  copy values to variables and make empty space in stock

' Stock A[$|%| ]()  keep  N,  B[$|%| ]()
' Stock A[$|%| ]()  sweep  N [,  value ]   fill a copy of value to n items or empty slots
Dim W$, pppp As mArray, ppppAny As iBoxArray, v As Long, VN As Long, I As Long, what$, pppp1 As mArray, V1 As Long
Dim bs As New basetask, p As Variant, P1 As Variant, soros As mStiva, ww$, ss$, usehandler As mHandler
Dim useType As Boolean, vt As Integer
I = Abs(IsLabel(bstack, b$, what$))
If I > 4 And I < 8 Then
    If neoGetArray(bstack, what$, ppppAny) Then
        If Not ppppAny.Arr Then NeedAnArray1: Exit Function
        If NeoGetArrayItem(ppppAny, bstack, what$, v, b$) Then
            Set pppp = ppppAny
againhere:
            If IsLabelSymbolNew(b$, "апо", "IN", Lang) Then
                If what$ = vbNullString Then Exit Function   ' no for no named array
                Set soros = bstack.soros
                Set bstack.Sorosref = bs.soros
                ' Need bstack and not bs because bstack has more info inside.
                If MyData(bstack, b$) Then
                    Set bstack.Sorosref = soros
                    Set soros = Nothing
                    VN = v + bs.soros.Total - 1
                    If pppp.UpperMonoLimit >= VN Then
                        With bs.soros
                            I = 1
                            For v = v To VN
                                If Not .StackItemTypeIsObject(I) Then
                                    pppp.item(v) = .StackItem(I)
                                Else
                                    If TypeOf .StackItem(I) Is mArray Then
                                        If .StackItem(I).Arr Then
                                            Set pppp1 = New mArray
                                            .StackItem(I).CopyArray pppp1
                                            Set pppp.item(v) = pppp1
                                        Else
                                            Set pppp.item(v) = .StackItem(I)
                                        End If
                                    Else
                                        Set pppp.item(v) = .StackItem(I)
                                    End If
                                End If
                                I = I + 1
                            Next v
                        End With
                    Else
                        MyEr "Stock out of space", "тО СТОЙ щЛЕИМЕ АПЭ ВЧЯО"
                        Exit Function
                    End If
                    StockValues = True
                    Exit Function
                End If
            ElseIf IsLabelSymbolNew(b$, "се", "OUT", Lang) Then
                Do
                    If MyIsObject(pppp.item(v)) Then
                        Select Case Abs(IsLabel(bstack, b$, W$))
                        Case 1, 4
                            If GetVar(bstack, W$, I, , , , ww$) Then
                                If Typename$(var(I)) = mGroup Then
                                    ss$ = bstack.GroupName
                                    If ww$ <> "" Then W$ = ww$
                                    If Len(var(I).GroupName) > Len(W$) Then
                                        If var(I).IamRef Then
                                            ww$ = here$
                                            here$ = vbNullString
                                            UnFloatGroupReWriteVars bstack, W$, I, pppp.item(v)
                                            here = ww$
                                        Else
                                            UnFloatGroupReWriteVars bstack, W$, I, pppp.item(v)
                                        End If
                                    Else
                                        bstack.GroupName = Left$(W$, Len(W$) - Len(var(I).GroupName) + 1)
                                        W$ = Left$(var(I).GroupName, Len(var(I).GroupName) - 1)
                                        If Len(var(I).GroupName) > 0 Then
                                            ww$ = here$
                                            here$ = vbNullString
                                            UnFloatGroupReWriteVars bstack, W$, I, pppp.item(v)
                                            here = ww$
                                        Else
                                            bstack.GroupName = ss$
                                            GroupWrongUse
                                            StockValues = False
                                            Exit Function
                                        End If
                                    End If
                                    bstack.GroupName = ss$
                                Else
                                      bs.soros.PushObj pppp.item(v)
                                      bs.soros.Copy2TopItem 1
                                      
                                      Set var(I) = bs.soros.PopObj
                                      bs.soros.drop 1
                                End If
                            Else
                                I = globalvar(W$, 0)
                                bs.soros.PushObj pppp.item(v)
                                bs.soros.Copy2TopItem 1
                                If TypeOf pppp.itemObject(v) Is mArray Then
                                    If pppp.item(v).Arr Then
                                        Set usehandler = New mHandler
                                        Set var(I) = usehandler
                                        usehandler.T1 = 3
                                        Set usehandler.objref = bs.soros.PopObj
                                    Else
                                        Set var(I) = bs.soros.PopObj
                                    End If
                                Else
                                    Set var(I) = bs.soros.PopObj
                                End If
                                bs.soros.drop 1
                            End If
                        Case 3
                            If GetVar(bstack, W$, I, checktype:=useType) Then
                                If useType Then
                                    If pppp.ItemType(v) = "Document" Then
                                        Set var(I) = pppp.item(v)
                                    ElseIf pppp.ItemType(v) = "lambda" Then
                                        Set var(I) = pppp.item(v)
                                    Else
                                        WrongType
                                        Exit Function
                                    End If
                                Else
                                    Set var(I) = pppp.item(v)
                                End If
                            Else
                                I = globalvar(W$, 0)
                                Set var(I) = pppp.item(v)
                            End If
                        Case 5, 6, 7
                            If neoGetArray(bstack, W$, ppppAny) Then
                                If Not ppppAny.Arr Then NeedAnArray1: Exit Function
                                Set pppp1 = ppppAny
                                If IsSymbol(b$, ")") Then
                                    bs.soros.PushObj pppp.item(v)
                                    If Not globalArrByPointer(bs, bstack, W$) Then MissingArray
                                Else
                                    If NeoGetArrayItem(ppppAny, bstack, W$, V1, b$) Then
                                        Set ppppAny.item(V1) = pppp.item(v)
                                    End If
                                End If
                            ElseIf IsSymbol(b$, ")") Then
                                bs.soros.PushObj pppp.item(v)
                                If Not globalArrByPointer(bs, bstack, W$) Then MissingArray
                            End If
                        End Select
                    Else
                        vt = Abs(IsLabel(bstack, b$, W$))
                        Select Case vt
                        Case 1, 3, 4
                            If Not GetVar(bstack, W$, I, checktype:=useType) Then
                                If vt = 1 Then
                                I = globalvar(W$, 0, useType:=False)
                                    useType = False
                                ElseIf vt = 3 Then
                                    I = globalvar(W$, CVar(vbNullString))
                                    useType = True
                                Else
                                    useType = True
                                    I = globalvar(W$, 0#)
                                End If
                            End If
                            If MyIsObject(var(I)) Then
                                If TypeOf var(I) Is Document Then
                                    var(I).EmptyDoc
                                    var(I).textDoc = pppp.item(v)
                                End If
                            Else
                                If useType Then
                                    p = pppp.item(v)
                                    'If myVarType(p, VarType(var(i))) Then
                                    If AssignTypeNumeric(p, VarType(var(I))) Then
                                        SwapVariant p, var(I)
                                        Else
                                        WrongType
                                        StockValues = False
                                        Exit Function
                                    End If
                                Else
                                    var(I) = pppp.item(v)
                                End If
                            End If
                        Case 5, 6, 7
                            If neoGetArray(bstack, W$, pppp1) Then
                                If Not pppp1.Arr Then MissingArray: Exit Function
                                If lookOne(b$, ")") Then
                                    If Not NeoGetArrayItem(pppp1, bstack, W$ + ")", V1, "") Then
                                        I = -1
                                        GlobalArr bstack, W$, vbNullString, 0, I
                                        Set var(I) = pppp.item(v)
                                    End If
                                ElseIf NeoGetArrayItem(pppp1, bstack, W$, V1, b$) Then
                                    pppp1.item(V1) = pppp.item(v)
                                End If
                            End If
                        Case Else
                            SyntaxError
                            Exit Function
                        End Select
                    End If
                    v = v + 1
                    If pppp.UpperMonoLimit < v Then
                        If lookOne(b$, ",") Then
                            UpperArrayLimit
                            Exit Function
                        End If
                    End If
                Loop Until Not FastSymbol(b$, ",")
            ElseIf IsLabelSymbolNew(b$, "циа", "KEEP", Lang) Then
                If IsExp(bstack, b$, p) Then
                    If p <> MyRound(p) Or p < 0 Then
                        MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                        Exit Function
                    End If
                    If IsSymbol(b$, ",") Then
                        If Abs(IsLabel(bstack, b$, W$)) > 4 Then
                            If neoGetArray(bstack, W$, pppp1) Then
                                If Not pppp1.Arr Then NeedAnArray1: Exit Function
                                If NeoGetArrayItem(pppp1, bstack, W$, V1, b$) Then
                                    If Not (V1 + p - 1 <= pppp1.UpperMonoLimit) Then
                                        MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                                        Exit Function
                                    Else
                                        If pppp1 Is pppp Then
                                            If v = V1 Then
                                                ' do nothing
                                            ElseIf Abs(v - V1) < p Then
                                                'from top
                                                If V1 > v Then
                                                    For I = p - 1 To 0 Step -1
                                                        With pppp
                                                            If MyIsObject(.item(I + v)) Then
                                                                If I + v < V1 Then
                                                                    bs.soros.PushObj .item(I + v)
                                                                    bs.soros.Copy2TopItem 1
                                                                    Set pppp1.item(I + V1) = bs.soros.PopObj
                                                                    bs.soros.drop 1
                                                                Else
                                                                    Set pppp1.item(I + V1) = .item(I + v)
                                                                End If
                                                            Else
                                                                pppp1.item(I + V1) = .item(I + v)
                                                            End If
                                                        End With
                                                    Next I
                                                Else  ' v > V1
                                                    For I = 0 To p - 1
                                                        With pppp
                                                            If MyIsObject(.item(I + v)) Then
                                                                If p + V1 <= v + I Then
                                                                    bs.soros.PushObj .item(I + v)
                                                                    bs.soros.Copy2TopItem 1
                                                                    Set pppp1.item(I + V1) = bs.soros.PopObj
                                                                    bs.soros.drop 1
                                                                Else
                                                                    Set pppp1.item(I + V1) = .item(I + v)
                                                                End If
                                                            Else
                                                                pppp1.item(I + V1) = .item(I + v)
                                                            End If
                                                        End With
                                                    Next I
                                                End If
                                            Else
                                                For I = 0 To p - 1
                                                    With pppp
                                                        If MyIsObject(.item(I + v)) Then
                                                            bs.soros.PushObj .item(I + v)
                                                            bs.soros.Copy2TopItem 1
                                                            Set pppp1.item(I + V1) = bs.soros.PopObj
                                                            bs.soros.drop 1
                                                        Else
                                                            pppp1.item(I + V1) = .item(I + v)
                                                        End If
                                                    End With
                                                Next I
                                            End If
                                        Else
                                            For I = 0 To p - 1
                                                With pppp
                                                    If MyIsObject(.item(I + v)) Then
                                                        bs.soros.PushObj .item(I + v)
                                                        bs.soros.Copy2TopItem 1
                                                        Set pppp1.item(I + V1) = bs.soros.PopObj
                                                        bs.soros.drop 1
                                                    Else
                                                        pppp1.item(I + V1) = .item(I + v)
                                                    End If
                                                End With
                                            Next I
                                        End If
                                        StockValues = True
                                        Exit Function
                                    End If
                                End If
                            End If
                        ElseIf Right$(W$, 1) = "$" Then
                            If GetVar(bstack, W$, V1) Then
                                var(V1) = vbNullString
                            Else
                                V1 = globalvar(W$, "")
                            End If
                            VN = Right$(what$, 3) = "$"
                            If p - 1 + v > pppp.UpperMonoLimit Then
                                MyEr "Invalid copy number", "лГ щЦЙУЯОР ДЕъЙТГР АМТИЦЯАЖчР"
                                Exit Function
                            End If
                            For I = 0 To p - 1
                                With pppp
                                    If MyIsObject(.item(I + v)) Then
                                        If VN Then var(V1) = var(V1) + Sput("") Else var(V1) = var(V1) & " 0"
                                    Else
                                        Select Case Typename(.item(I + v))
                                        Case "Double"
                                           var(V1) = var(V1) + " " + Trim$(str(.item(I + v)))
                                        Case "String"
                                           W$ = .item(I + v)
                                           If IsNumberD2(W$, p) Then
                                              var(V1) = var(V1) + " " + .item(I + v)
                                           Else
                                              var(V1) = var(V1) + Sput(.item(I + v))
                                           End If
                                        Case Else
                                           If VN Then var(V1) = var(V1) + Sput("") Else var(V1) = var(V1) & " 0"
                                        End Select
                                    End If
                                End With
                            Next I
                            StockValues = True
                            Exit Function
                        End If
                    End If
                End If
            ElseIf IsLabelSymbolNew(b$, "хесе", "SWEEP", Lang) Then
                If what$ = vbNullString Then Exit Function   ' no for no named array
                If IsExp(bstack, b$, p) Then
                    If p <> MyRound(p) Or p < 0 Then
                        MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                        Exit Function
                    End If
                    If Not (v + p - 1 <= pppp.UpperMonoLimit) Then
                        MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                        Exit Function
                    Else
                    If Not IsSymbol(b$, ",") Then
                        For I = 0 To p - 1
                            If MyIsObject(pppp.item(I + v)) Then
                                Set pppp.item(I + v) = Nothing
                            End If
                            pppp.item(I + v) = Empty
                        Next I
                    Else
                        I = 1
                        what$ = aheadstatus(b$, False, I)
                        Set bstack.lastobj = Nothing
                        If what$ <> "" Then
                            If Left$(what$, 1) = "N" Then
                                If IsNumber(bstack, b$, P1) Then
                                    If bstack.lastobj Is Nothing Then
                                        For I = 0 To p - 1
                                            pppp.item(I + v) = P1
                                        Next I
                                    Else
                                        bs.soros.PushObj bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        For I = 0 To p - 1
                                            bs.soros.Copy2TopItem 1
                                            Set pppp.item(I + v) = bs.soros.PopObj
                                        Next I
                                    End If
                                End If
                            Else
                                If IsString(bstack, b$, what$) Then
                                    If bstack.lastobj Is Nothing Then
                                        For I = 0 To p - 1
                                            pppp.item(I + v) = what$
                                        Next I
                                    Else
                                        bs.soros.PushObj bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        For I = 0 To p - 1
                                            bs.soros.Copy2TopItem 1
                                            Set pppp.item(I + v) = bs.soros.PopObj
                                        Next I
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If
        StockValues = True
    Else
        b$ = what$ + b$
        If IsExp(bstack, b$, p) Then
            what$ = vbNullString
            If Typename(bstack.lastobj) = myArray Then Set pppp = bstack.lastobj: Set bstack.lastobj = Nothing: GoTo againhere
        ElseIf IsStrExp(bstack, b$, what$) Then
            what$ = vbNullString
            If Typename(bstack.lastobj) = myArray Then Set pppp = bstack.lastobj: Set bstack.lastobj = Nothing: GoTo againhere
        End If
    End If
End If
            
End Function
Public Function SubsExist() As Boolean
SubsExist = subHash.count > 0
End Function
Sub TraceStore(b As basetask, v As Long, c$, o&)
    v = b.addlen
    b.addlen = Len(c$) - o& + b.addlen
End Sub
Sub TraceRestore(b As basetask, v As Long)
         b.addlen = v
End Sub
Sub SetSizeAndHotSpot(thisbasket As basket, maxx As Long, MaxY As Long, Optional ByVal HotSpotX = 0, Optional ByVal HotSpotY = 0)
With thisbasket
.MAXXGRAPH = maxx
.MAXYGRAPH = MaxY
If Not IsMissing(HotSpotX) Then .X = CLng(HotSpotX)  ' this is hotspot
If Not IsMissing(HotSpotY) Then .Y = CLng(HotSpotY)
End With
End Sub
Sub FeedBasket(DDD As Object, thisbasket As basket, alinespace As Long)
With thisbasket
.FontName = DDD.FontName
.SZ = DDD.FontSize
.charset = DDD.Font.charset
.MineLineSpace = alinespace
.uMineLineSpace = alinespace
''.Paper = ddd.BackColor
FrameText DDD, .SZ, 0, 0, -.Paper, (DDD.Name <> "Form1")

End With
End Sub
Sub PlaceBasketPrive(DDD As Object, thisbasket As basket)
On Error Resume Next
With thisbasket
If Not DDD.FontName = .FontName And DDD.Font.charset = .charset And DDD.FontSize = .SZ Then
DDD.Font.charset = 0
DDD.FontSize = 9
DDD.FontName = .FontName
DDD.Font.charset = .charset
DDD.FontSize = .SZ
End If
' these I have to delete after change
End With
End Sub
Sub PlaceBasket(DDD As Object, thisbasket As basket)
On Error Resume Next
With thisbasket
If Not (DDD.FontName = .FontName And DDD.Font.charset = .charset And DDD.Font.Size = .SZ) Then
StoreFont .FontName, .SZ, .charset
DDD.Font.charset = 0
DDD.FontSize = 9
DDD.FontName = .FontName
DDD.Font.charset = .charset
DDD.FontSize = .SZ
End If
DDD.ForeColor = .mypen
End With
End Sub
Function GetCode(dq As Object) As Long
Dim u As Long
    If dq Is Form1.DIS Or dq Is Nothing Then
        GetCode = 0
    ElseIf dq Is Form1 Then
        GetCode = -1
    ElseIf dq Is Form1.PrinterDocument1 Then
        GetCode = -2
    ElseIf (TypeOf dq Is GuiM2000) Or (TypeOf dq Is GuiImage) Then
        On Error Resume Next
        u = dq.prive
        ' check this again
        If Err > 0 Then Err.Clear: oxiforforms: GetCode = -1: Set dq = Form1: Exit Function
        If u = 0 Then
        For u = 33 To 1032
        If Not players(u).used Then Exit For
        Next u
        If u = 1033 Then ResourceLimit: GetCode = -1: Set dq = Form1: Exit Function
        players(u) = zero
        dq.prive = u
        
        
        players(u).used = True
        End If
        
        GetCode = u
    ElseIf TypeOf dq Is MetaDc Then
        On Error Resume Next
        u = dq.prive
        ' check this again
        If Err > 0 Then Err.Clear: oxiforMetaFiles: GetCode = -1: Set dq = Form1: Exit Function
        If u = 0 Then
            For u = 33 To 1032
                If Not players(u).used Then Exit For
            Next u
            If u = 1033 Then ResourceLimit: GetCode = -1: Set dq = Form1: Exit Function
            dq.prive = u
            players(u) = zero
            players(u).used = True
        End If
        GetCode = u
    ElseIf TypeOf dq Is PictureBox Then
        If dq.Name = "dSprite" Then
            GetCode = dq.Index
        Else
            GetCode = CLng("0" & dq.Tag)
        End If
    End If
End Function
Static Function MyRound(A As Variant, Optional ByVal I As Integer = 0)
Dim j As VbVarType
j = VarType(A)
If j < vbSingle Or j = 20 Or j = vbString Then MyRound = A: Exit Function
Dim c As Variant
Static n(1 To 28) As Single, D(1 To 28) As Double, cur(1 To 28) As Currency, dec(1 To 28) As Variant
Static sg(-1 To 1) As Single, sg4(-1 To 1) As Double, sg8(-1 To 1) As Currency
On Error GoTo there
If n(1) = 0 Then
    sg(-1) = CSng(-0.5)
    sg(1) = CSng(0.5)
    sg4(-1) = -0.5
    sg4(1) = 0.5
    sg8(-1) = CCur(-0.5)
    sg8(1) = CCur(0.5)
    For c = 1& To 6&
        n(c) = CSng(10 ^ c)
    Next c
    For c = 7& To 27&
        n(c) = CSng(-1)
    Next c
        n(c) = CSng(10 ^ 5)
        n(10) = CSng(10 ^ 5)
    For c = 1& To 13&
        D(c) = CDbl(10 ^ c)
    Next c
    For c = 14& To 27&
        D(c) = CDbl(-1)
    Next c
    D(c) = CDbl(10 ^ 13)
    
    For c = 1& To 3&
        cur(c) = CCur(10 ^ c)
    Next c
    For c = 4& To 28&
        cur(c) = CCur(-1)
    Next c
    For c = 1& To 28&
        dec(c) = CDec(10 ^ c)
    Next c
End If
    If I = 0 Then
        MyRound = Sgn(A) * Int(Abs(A) + 0.5!)
        Exit Function
    Else
        c = Fix(A)
        Select Case j
        Case vbSingle
            If n(I) > 0 Then
                c = sg(Sgn(A))
                MyRound = Fix(A * n(I) + c) / n(I)
            Else
                MyRound = A
            End If
            Exit Function
        Case vbDouble
            c = sg4(Sgn(A))
 
            If D(I) > 0 Then
                MyRound = Fix(A * D(I) + c) / D(I)
            Else
                MyRound = A
            End If
            Exit Function
        Case vbCurrency
            If cur(I) > 0 Then
                c = sg8(Sgn(A))
                MyRound = Fix(A) + Fix((A - Fix(A)) * cur(I) + c) / cur(I)
            Else
                MyRound = A
            End If
            Exit Function
        Case vbDecimal
            c = sg8(Sgn(A))
            MyRound = Fix(A) + Fix((A - Fix(A)) * dec(I) + c) / dec(I)
            Exit Function
        Case Else
            MyRound = A
            Exit Function
        End Select
    End If
there:
Err.Clear
MyRound = A
If I < 0 Or I > 28 Then MyEr "Round Place exit range 0 to 28", "г ХщСГ СТЯОЦЦУКОПОъГСГР ЕЙТЭР ПЕЯИОВчР АПЭ 0 щЫР 28"
End Function


Function AllocVar()
var2used = var2used + 1
  If UBound(var()) <= var2used + 20 Then
            varhash.Expand UBound(var()) * 2
            On Error Resume Next
            If UBound(var()) <> varhash.MaxSpace Then
                    ReDim Preserve var(varhash.MaxSpace) As Variant
            End If
            If Err.Number > 0 Then
                NOEXECUTION = True
                MyEr Err.Description, Err.Description
                Err.Clear
                Exit Function
            End If
            
        End If
       AllocVar = var2used
End Function
Function AllocSub() As Long
    'On Error Resume Next
    If UBound(sbf()) <= sb2used + 1 Then
        subHash.Expand UBound(sbf()) * 2
        If UBound(sbf()) <> subHash.MaxSpace Then
            ReDim Preserve sbf(subHash.MaxSpace) As modfun
        End If
    End If
    sb2used = sb2used + 1
    AllocSub = sb2used
End Function

Function ProcEventVarSet(bstack As basetask, I As Long) As mEvent

If I = -1 Then  '
    If Typename(bstack.lastobj) = "mEvent" Then
    Set ProcEventVarSet = bstack.lastobj
    Else
    MyEr "Not found an object Event", "дЕМ БЯчЙА щМА АМТИЙЕъЛЕМО цЕЦОМЭР"
    Exit Function
    End If
Else
    Set ProcEventVarSet = var(I)
End If
End Function
Function ProcEvent(bstack As basetask, rest$, Lang As Long, I As Long) As Boolean
'look for { }, or hold
Dim aa As mEvent, s$, lastname$, dd As Long, pm As Long, pf As Long
ProcEvent = True
Dim ss$, rd$, ss1$
If FastSymbol(rest$, "{") Then
Set aa = ProcEventVarSet(bstack, I)
aa.BypassInit 10
aa.VarIndex = I
If here$ = vbNullString Then
    aa.NoHere = bstack.GroupName
Else
    aa.NoHere = here$ + "." + bstack.GroupName
End If
aa.enabled = True
ss$ = NLtrim$(block(rest$))
rd$ = vbNullString
While ss$ <> ""
If FastSymbol(ss$, vbCrLf, , 2) Then
ss$ = NLtrim(ss$)
ElseIf IsLabelSymbolNew(ss$, "диабасе", "READ", Lang) Then
If Lang = 1 Then
If rd$ = vbNullString Then rd$ = "READ "
Else
If rd$ = vbNullString Then rd$ = "диабасе "
End If

Do
dd = 1
      s$ = aheadstatus(ss$, , dd)
      If s$ <> "" Then
      pm = pm + 1
      If FastPureLabel(ss$, ss1$, , , , , False) Then
   
            If pm < 2 Then
            rd$ = rd$ + Left$(ss$, dd - 1)
            Else
            rd$ = rd$ + "," + Left$(ss$, dd - 1)
            End If
      
      ss$ = Mid$(ss$, dd)
      Else
      ProcEvent = False
      Exit Function
      End If
      Else
      Exit Do
      End If
   Loop Until Not FastSymbol(ss$, ",")

ElseIf IsLabelSymbolNew(ss$, "сумаятгсг", "FUNCTION", Lang) Then
'' check only for blocks
pf = pf + 1
If FastSymbol(ss$, "{") Then
s$ = "{" + rd$ + vbCrLf + block(ss$) + "}" + here$ + "." + bstack.GroupName
If Not FastSymbol(ss$, "}") Then ProcEvent = False: Exit Function
aa.GenItemCreator LTrim$(str(pf * 123)), s$
While ss$ <> ""
If FastSymbol(ss$, vbCrLf, , 2) Then
    ss$ = NLtrim(ss$)
ElseIf IsLabelSymbolNew(ss$, "сумаятгсг", "FUNCTION", Lang) Then
        If FastSymbol(ss$, "{") Then
            s$ = "{" + rd$ + vbCrLf + block(ss$) + "}"
            If Not FastSymbol(ss$, "}") Then ProcEvent = False: Exit Function
            ' БэКЕ щМА key
            pf = pf + 1
            aa.GenItemCreator LTrim$(str(pf * 123)), s$
        Else
            ProcEvent = False: Exit Function
        End If
Else
    ProcEvent = False: Exit Function
End If
Wend
End If
Else
    ProcEvent = False: Exit Function
End If
Wend
aa.ParamBlock rd$, pm




Set aa = Nothing

If Not FastSymbol(rest$, "}") Then ProcEvent = False: Exit Function
' do something
' find Read command and some Functions
ElseIf IsLabelSymbolNew(rest$, "ажгсе", "RELEASE", Lang) Then
    Set aa = ProcEventVarSet(bstack, I)
    aa.enabled = True
ElseIf IsLabelSymbolNew(rest$, "йяатгсе", "HOLD", Lang) Then
    Set aa = ProcEventVarSet(bstack, I)
    aa.enabled = False
ElseIf IsLabelSymbolNew(rest$, "йахаяо", "CLEAR", Lang) Then
    Set aa = ProcEventVarSet(bstack, I)
    aa.enabled = False
    aa.BypassInit 10
ElseIf IsLabelSymbolNew(rest$, "мео", "NEW", Lang) Then
    Set aa = ProcEventVarSet(bstack, I)
    Do
        dd = 1
        ss$ = aheadstatus(rest$, , dd)
        If ss$ = "S" Then
            lastname$ = here$ + "." + MyTrim(myUcase(Left(rest$, dd - 1), True))
            If Not IsStrExp(bstack, rest$, s$) Then ProcEvent = False: Exit Function
            If Not lookOne(s$, "{") Then
            If GetSub(s$, pm) Then
                If sbf(pm).Extern > 0 Then
                    s$ = "{CALL EXTERN" + str$(sbf(pm).Extern) + "'" + ChrW(&H1FFD) + "}" + sbf(pm).sbgroup
                Else
                    s$ = "{" + sbf(pm).sb + "}" + sbf(pm).sbgroup
                End If
            Else
            s$ = "{CALL VOID " + s$ + "}"
            End If
            End If
        ElseIf ss$ = "N" Then
            ss$ = "&" + Left$(rest$, dd)
            If Not IsString(bstack, (ss$), s$) Then
                ProcEvent = False: Exit Function
            Else
                lastname$ = subHash.LastKnown
            End If
            rest$ = Mid$(rest$, dd)
        Else
            s$ = vbNullString
        End If
        If Len(s$) > 1 Then
            If Not aa.StandBy("(FREE)", lastname$, s$) Then aa.GenItemCreator lastname$, s$
        Else
            ProcEvent = False
            Exit Function
        End If
    Loop Until Not FastSymbol(rest$, ",")
    Set aa = Nothing
ElseIf IsLabelSymbolNew(rest$, "пета", "DROP", Lang) Then
    Set aa = ProcEventVarSet(bstack, I)
    Do
        dd = 1
        ss$ = aheadstatus(rest$, , dd)
        If ss$ = "S" Then
              lastname$ = here$ + "." + MyTrim(myUcase(Left(rest$, dd - 1), True))
              If Not IsStrExp(bstack, rest$, s$) Then ProcEvent = False: Exit Function
        ElseIf ss$ = "N" Then
              ss$ = "&" + Left$(rest$, dd)
              If Not IsString(bstack, (ss$), s$) Then
                  ProcEvent = False: Exit Function
              Else
                  lastname$ = subHash.LastKnown
              End If
              rest$ = Mid$(rest$, dd)
        Else
                s$ = vbNullString
        End If
        If Len(s$) > 1 Then
            aa.StandBy lastname$, "(FREE)", "" ' no erroro if not found
        Else
            ProcEvent = False
            Exit Function
        End If
    Loop Until Not FastSymbol(rest$, ",")
    Set aa = Nothing
    Exit Function
End If
Set aa = Nothing
End Function
Sub CopyEvent(A As Variant, bstack As basetask)
Dim alfa As New mEvent, I As Long
Dim aa As mEvent

Set aa = A
'' now put code to copy a to alfa
alfa.BypassInit CLng(A.CurMaxSpace)
Dim aaa() As GenItem, bbb() As Long, mytop As Long
aa.CopySpaceUp aaa(), bbb(), mytop
alfa.CopySpaceDown aaa(), bbb(), mytop
alfa.ParamBlock aa.ParamsRead, aa.params
alfa.NoHere = aa.NoHere
alfa.enabled = aa.enabled
Set bstack.lastobj = alfa
Set aa = Nothing
End Sub
Function CallEvent(bstack As basetask, rest$, Lang As Long, ByVal I As Long) As Boolean

If I > -1 Then
If VarTypeName(var(I)) <> "mEvent" Then
Exit Function
End If
Else
If Typename(bstack.lastobj) <> "mEvent" Then
Exit Function
End If
End If
CallEvent = True
Dim A As mEvent, n$, f$, bb As mStiva, oldbstack As mStiva, nowtotal As Long, oldstatic As FastCollection
FastSymbol rest$, ","
If I < 0 Then
Set A = bstack.lastobj
I = var2used + CLng(Rnd(1000))
Else
Set A = var(I)
End If
''bstack.Look2Parent = True
If Not PushParamGeneral(bstack, rest$) Then

CallEvent = False
Set A = Nothing
Exit Function

End If
''bstack.Look2Parent = False
Dim j As Long, K, s1$, klm As Long
Set oldbstack = bstack.soros
Set oldstatic = bstack.StaticCollection

Dim ohere$
ohere$ = here$
If A Is Nothing Then Exit Function
For j = 0 To A.count - 1

here$ = "EV" & I & "." & j
If A.enabled Then
'Set bstack.StaticCollection = Nothing
Set bstack.StaticCollection = A.StaticCollection
A.ReadVar j, n$, f$
If f$ <> "" Then
Set bb = New mStiva
Set bstack.Sorosref = bb
bb.Copy2TopNItems2FromStiva A.params, oldbstack
PushStage bstack, False
s1$ = Mid$(f$, 2, rinstr(f$, "}") - 2)
klm = ModuleSubAsap("A_()", s1$, Trim$(Mid$(f$, Len(s1$) + 3)))
If Not ProcModuleEntry(bstack, "A_()", klm, "", , True) Then
    PopStage bstack
    bb.Flush
    GoTo conthere
End If

PopStage bstack

bb.Flush
End If
End If
Set A.StaticCollection = bstack.StaticCollection
Next j
conthere:
Set A.StaticCollection = bstack.StaticCollection
Set bstack.Sorosref = oldbstack
Set bstack.StaticCollection = oldstatic
Set oldstatic = Nothing
Set oldbstack = Nothing
bstack.soros.drop A.params
Set bb = Nothing

here$ = ohere$
End Function
Public Function CallEventFromGui(gui As GuiM2000, A As mEvent, aString$) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
olescok = escok
escok = False
extr = extreme
extreme = True
tr = trace
If tr Then If Rnd * 100 > 3 Then trace = False
On Error Resume Next

CallEventFromGui = True
Dim n$, f$, bb As mStiva, oldbstack As mStiva, nowtotal As Long
Dim bstack As basetask
Set bstack = New basetask
With bstack
    .IamAnEvent = True
Set .Owner = Basestack1.Owner
'Set .StaticCollection = a.StaticCollection
End With
Dim I As Long
If A Is Nothing Then GoTo conthere1
I = A.VarIndex
bstack.soros.DataStr aString$
If gui.Index >= 0 Then
bstack.soros.DataVal gui.Index
End If
bstack.soros.DataObj gui

Set oldbstack = bstack.soros
Dim j As Long, s1$, klm As Long
Dim ohere$
ohere$ = here$
For j = 0 To A.count - 1
here$ = "EV" & I & "." & j
If A.enabled Then
A.ReadVar j, n$, f$
If f$ <> "" Then
Set bb = New mStiva
If Not A.StaticCollection Is Nothing Then
If A.StaticCollection.ExistKey(n$) Then
Set bstack.StaticCollection = A.StaticCollection.ValueObj
End If
End If
Set bstack.Sorosref = bb
bb.Copy2TopNItems2FromStiva A.params, oldbstack
PushStage bstack, False
s1$ = Mid$(f$, 2, rinstr(f$, "}") - 2)
klm = ModuleSubAsap("A_()", s1$, Trim$(Mid$(f$, Len(s1$) + 3)))
If Not ProcModuleEntry(bstack, "A_()", klm, "", , True) Then
    PopStage bstack
    bb.Flush
    GoTo conthere
End If
PopStage bstack
bb.Flush
End If
End If
If Not bstack.StaticCollection Is Nothing Then
        If A.StaticCollection Is Nothing Then Set A.StaticCollection = New FastCollection
        If Not A.StaticCollection.ExistKey(n$) Then
            A.StaticCollection.AddKey n$, bstack.StaticCollection
        End If
End If

Next j
conthere:
Set bstack.Sorosref = oldbstack
Set oldbstack = Nothing
If A Is Nothing Then
GoTo conthere1
Else
bstack.soros.drop A.params
End If
Set bb = Nothing
here$ = ohere$
conthere1:
extreme = extr
If tr Then
'If STEXIT Then trace = tr
trace = tr
End If
'Set Basestack1.StaticCollection = bstack.StaticCollection

'bstack.IamAnEvent = oldstatus
escok = olescok
End Function
Public Function CallEventFromGuiOne(gui As GuiM2000, A As mEvent, aString$) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
CallEventFromGuiOne = True
olescok = escok
escok = False
tr = trace
extr = extreme
extreme = True
If tr Then If Rnd * 100 > 3 Then trace = False
Dim n$, f$, F1$, bb As mStiva, uIndex As Long
Dim bstack As basetask
Set bstack = New basetask
Set bstack.Owner = Form1.DIS
'Set bstack.StaticCollection = a.StaticCollection
bstack.IamAnEvent = True
Dim I As Long
If A Is Nothing Then GoTo conthere0
I = A.VarIndex
uIndex = gui.Index
If uIndex >= 0 Then
bstack.soros.DataVal CDbl(uIndex)
uIndex = 1
End If
uIndex = uIndex + 1
F1$ = gui.modulename
bstack.soros.DataObj gui

Dim j As Long, K As Long, s1$, klm As Long, S2$
Dim ohere$
ohere$ = here$
here$ = "EV" & I
If A.enabled Then
            PushStage bstack, False
            FastPureLabel aString$, f$, , , , , False
            n$ = Mid$(aString$, Len(f$) + 1)
            n$ = Left$(n$, Len(n$) - 1)
            If n$ <> "" Then
           If uIndex > 0 Then
            n$ = "Data " + n$ + " : ShiftBack Stack.Size" + str(1 - uIndex) + "," + str$(uIndex) + vbCrLf
            Else
            n$ = "Data " + n$ + " : ShiftBack Stack.Size" + vbCrLf
            End If
            End If
            If F1$ <> "" Then f$ = myUcase(F1$ + "." + f$ + ")", True) Else f$ = myUcase(f$ + ")", True)
            If Not GetSub(f$, klm) Then
            PopStage bstack: CallEventFromGuiOne = False: GoTo conthere
            End If
            s1$ = sbf(klm).sb
            If Left$(s1$, 10) = "'11001EDIT" Then
            SetNextLine s1$
            End If
              If Not A.StaticCollection Is Nothing Then
                If A.StaticCollection.ExistKey(f$) Then
                Set bstack.StaticCollection = A.StaticCollection.ValueObj
                End If
                End If
            If F1$ <> "" Then s1$ = n$ + "Module " + F1$ + vbCrLf + sbf(klm).sb Else s1$ = n$ + sbf(klm).sb
            If Execute(bstack, s1$, False, False) = 0 Then
            If F1$ = vbNullString Then
            MyEr "Problem in Event " + aString$, "пЯЭБКГЛА СТО ЦЕЦОМЭР " + aString$
            Else
            MyEr "Problem in Event " + aString$ + " in module " + F1$, "пЯЭБКГЛА СТО ЦЕЦОМЭР " + aString$ + " СТО ТЛчЛА " + F1$
            End If
            bstack.soros.Flush
                PopStage bstack
                GoTo conthere
            End If
            PopStage bstack
End If
conthere:
If Len(f$) > 0 Then
If Not bstack.StaticCollection Is Nothing Then
        If A.StaticCollection Is Nothing Then Set A.StaticCollection = New FastCollection
        If Not A.StaticCollection.ExistKey(f$) Then
            A.StaticCollection.AddKey f$, bstack.StaticCollection
        End If
End If
End If
Set bstack = Nothing
here$ = ohere$
conthere0:
If tr Then
'If STEXIT Then
trace = tr
End If
extreme = extr
escok = olescok
End Function
Public Function CallEventFromGuiNow(gui As GuiM2000, A As mEvent, aString$, vrs()) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
olescok = escok
escok = False
CallEventFromGuiNow = True
extr = extreme
extreme = True
tr = trace
If tr Then If Rnd * 100 > 3 Then trace = False
Dim n$, f$, F1$, bb As mStiva, oldbstack As mStiva, nowtotal As Long
Dim bstack As basetask
Set bstack = New basetask
Set bstack.Owner = Form1.DIS
bstack.IamAnEvent = True
Dim I As Long
If A Is Nothing Then GoTo conthere0
I = A.VarIndex
F1$ = gui.modulename
Set oldbstack = bstack.soros
Dim j As Long, K As Long, s1$, klm As Long, S2$
Dim ohere$
ohere$ = here$
here$ = "EV" & I
If A.enabled Then
A.ReadVar 0, n$, f$
If f$ <> "" Then
Set bb = New mStiva
Set bstack.Sorosref = bb
            PushStage bstack, False
            For K = LBound(vrs()) To UBound(vrs()) - 1
            If VarType(vrs(K)) = vbString Then
            globalvarGroup "EV" & (I + K) & "$", vrs(K)
            bb.DataStr here$ & ".EV" & (I + K) & "$"
            Else
            globalvarGroup "EV" & (I + K), vrs(K)
            bb.DataStr here$ & ".EV" & (I + K)
            End If
            
            
            Next K
            bb.DataObj gui
             
            FastPureLabel aString$, f$, , , , , False
            n$ = Mid$(aString$, Len(f$) + 1)
            If Len(n$) > 0 Then
            
            n$ = Left$(n$, Len(n$) - 1)
            If n$ <> "" Then n$ = "Push " + n$ + vbCrLf
         End If
            If F1$ <> "" Then f$ = myUcase(F1$ + "." + f$ + ")", True) Else f$ = myUcase(f$ + ")", True)
  
            If Not GetSub(f$, klm) Then PopStage bstack: bb.Flush: CallEventFromGuiNow = False: GoTo conthere
            '' look for '11001EDIT
            s1$ = sbf(klm).sb
            If Left$(s1$, 10) = "'11001EDIT" Then
            SetNextLine s1$
            End If
            If F1$ <> "" Then s1$ = n$ + "Module " + F1$ + vbCrLf + sbf(klm).sb Else s1$ = n$ + sbf(klm).sb
            
          Dim nn As Long
                If Not A.StaticCollection Is Nothing Then
                If A.StaticCollection.ExistKey(f$) Then
                Set bstack.StaticCollection = A.StaticCollection.ValueObj
                End If
                End If
            If Execute(bstack, s1$, False, False) = 0 Then
           MyEr "Problem in Event " + aString$, "пЯЭБКГЛА СТО ЦЕЦОМЭР " + aString$
            
            
                PopStage bstack
                bb.Flush
                GoTo conthere
            End If
                  here$ = "EV" & I
       For K = LBound(vrs()) To UBound(vrs()) - 1
        If VarType(vrs(K)) = vbString Then
            GetlocalVar "EV" & (I + K) & "$", j
            vrs(K) = var(j)
        Else
            GetlocalVar "EV" & (I + K), j
             vrs(K) = var(j)
            End If
           
            Next K
            PopStage bstack

            bb.Flush
End If
End If

conthere:

Set bstack.Sorosref = oldbstack
here$ = ohere$
conthere0:
If Len(f$) > 0 Then
If Not bstack.StaticCollection Is Nothing Then
        If A.StaticCollection Is Nothing Then Set A.StaticCollection = New FastCollection
        If Not A.StaticCollection.ExistKey(f$) Then
            A.StaticCollection.AddKey f$, bstack.StaticCollection
        End If
End If
End If
Set oldbstack = Nothing
Set bb = Nothing

If tr Then
'If STEXIT Then trace = tr
trace = tr
End If
extreme = extr
escok = olescok
End Function

Sub ProcMethodArray(bstack As basetask, pppp As mArray, Index As Long, co$, rest$, Lang As Long, ifier0 As Boolean, groupok As Boolean, prive As Boolean)
Dim VR(1)
Set VR(0) = pppp.item(Index)
On Error Resume Next
ProcMethod bstack, VR(), 0, co$, rest$, Lang, ifier0, groupok, prive
 ifier0 = (Err = 0) And ifier0
          Err.Clear
End Sub
Sub ProcPropertyArray(bstack As basetask, pppp As mArray, Index As Long, co$, rest$, Lang As Long, ifier0 As Boolean, Optional usethis As Long)
        Dim VR(1)
        If VarType(pppp.item(Index)) <> vbEmpty Then
        
        Set VR(0) = pppp.item(Index)
        On Error Resume Next
          ProcProperty bstack, VR(), 0, co$, rest$, Lang, True, usethis
  ifier0 = Err = 0
          Err.Clear
          Else
          NoObjectFound
          End If
End Sub
Private Function ProcPtr(ByVal nAddress As Long) As Long
    ProcPtr = nAddress
End Function

Function CallByPtr(nSubAddress As Long, basestack As basetask, rest$, Lang As Long) As Boolean
Dim resp As Boolean
'If TaskMaster.PlayMusic Then
'    TaskMaster.OnlyMusic = True
'    TaskMaster.TimerTick
'    TaskMaster.OnlyMusic = False
'End If
CallWindowProc nSubAddress, VarPtr(basestack), VarPtr(rest$), VarPtr(Lang), VarPtr(resp)
CallByPtr = resp
End Function

Sub NeoWait(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim basestack As basetask, p As Variant
Set basestack = ObjFromPtr(basestackLP)
If IsExp(basestack, rest$, p) Then
mywait basestack, p
Else
mywait basestack, 0
End If
Set basestack = Nothing
resp = True
End Sub

Sub CallNext(basestack As basetask, rest$, resp As Boolean, V1 As Variant, V2 As String)
Dim I As Long, p As Variant, par As Boolean, f As Long, b$
Dim flag As Boolean, it As Long, what$, s$, x1 As Long, ss$, bs As basetask, vvl As Variant, X As Double
s$ = V2
I = Abs(IsLabel(basestack, s$, what$))
GoTo there
reenter1:

I = Abs(IsLabel(basestack, rest$, what$))
there:
If I = 3 And Len(rest$) > 0 Then
If AscW(rest$) = 46 Then
If Not IsStrExp(basestack, (what$), what$) Then MissPar:  Exit Sub
rest$ = what$ + rest$
GoTo reenter1
End If
End If
' call function as module
'**********************************************************

    ss$ = what$ + ")"
    
     If FastSymbol(rest$, ",") Then
    
    End If
    ''ss$ = myucase(ss$)

    resp = True
    MakeThisSub basestack, ss$
    it = CLng(GetSub(ss$, x1))
    
    If Not it Then it = CLng(GetlocalSub(ss$, x1))
 
    If it Then
        Set bs = New basetask
        Set bs.Parent = basestack
        If basestack.IamThread Then Set bs.Process = basestack.Process
        If Not TheSame(here$, ss$) Then Set bs.Sorosref = basestack.soros
        Set bs.Owner = basestack.Owner
             bs.OriginalCode = x1
             If flag Then
             bs.UseGroupname = basestack.UseGroupname
             bs.GroupName = basestack.GroupName
             bs.SetV
             Call GoFunc(bs, ss$, rest$, vvl, , x1)
            
             Else
             bs.UseGroupname = sbf(x1).sbgroup
             bs.tpointer = sbf(x1).tpointer
             bs.SetV
        Call GoFunc(bs, ss$, rest$, vvl)
        End If
            If Not bs.StaticCollection Is Nothing Then
        basestack.SetVarobJ "%_" + bs.StaticInUse, bs.StaticCollection
        End If
        Set bs = Nothing
        If Not par Then
        If myVarType(vvl, vbEmpty) Then resp = False: Exit Sub
        If InStr(ss$, "$") > 0 Then
   
        V2 = CStr(vvl)
        Else
        
            V1 = CDbl(vvl)
   
        End If
        End If
        Else
        ' ??
        End If
End Sub

Sub NeoCall(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim basestack As basetask, I As Long, p As Variant, par As Boolean, f As Long, Op As Object, Op1 As Object
Dim flag As Boolean, it As Long, what$, s$, x1 As Long, ss$, bs As basetask, vvl As Variant, X As Double
Dim c As Constant, myl As lambda, A As Group, usethis As stdCallFunction
Set basestack = ObjFromPtr(basestackLP)
If Fast2VarNoTrim(rest$, "текестг", 7, "OPERATOR", 8, 9, f) Then
    If ISSTRINGA(rest$, s$) Then
contoper:
        If ThisPointer(basestack, x1) Then
            If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p) Then
                    If basestack.lastobj Is Nothing Then
                        NeedAGroupFromExpression
                        Set basestack.lastobj = Nothing
                        Exit Sub
                    End If
                    If TypeOf basestack.lastobj Is Group Then
                        basestack.soros.PushObj basestack.lastobj
                        Set basestack.lastobj = Nothing
                        
                        NeoCall2 basestack, var(x1).Patch + "." + ChrW(&H1FFF) + s$ + "()", (True)
                        resp = True
                    Else
                        NeedAGroupFromExpression
                    End If
                Else
                    MissNumExpr
                End If
            Else
                NeoCall2 basestack, "." + ChrW(&H1FFF) + s$ + "()", (True)
                resp = True
            End If
            Set basestack.lastobj = Nothing
            Exit Sub
        Else
            OnlyInAGroup
            Exit Sub
        End If
    ElseIf IsLabelSymbolNew(rest$, "ломадиаио", "UNARY", Lang) Then
        s$ = "-:": GoTo contoper
    Else
        SyntaxError
        Exit Sub
    End If
End If

    resp = True
    If FastSymbol(rest$, "!") Then basestack.nokillvars = True
    par = False: f = 0
    ss$ = vbNullString
    
    If IsLabelSymbolNewExp(rest$, "йемг", "VOID", Lang, ss$) Then par = True
    If IsLabelSymbolNewExp(rest$, "енытеяийг", "EXTERN", Lang, ss$) Then
        basestack.nokillvars = False
        If IsExp(basestack, rest$, p) Then
            I = CLng(p)
            If I >= 0 Or I <= p Then
                If Not MyIsObject(var(I)) Then
                InternalError
                ElseIf TypeOf var(I) Is stdCallFunction Then
                    Set usethis = var(I)
                    On Error Resume Next
                    Err.Clear
                    CallByObject basestack, Not par, usethis
                    Set basestack = Nothing
                    If Err.Number <> 0 Then
                        MyEr Err.Description, Err.Description
                    End If
                    Exit Sub
                Else
                    If TypeOf var(I) Is Constant Then
                        Set c = var(I)
                        If Not c.flag Then
                            InternalError
                            resp = False
                            Exit Sub
                        End If
                        Set myl = c.Value
                    End If
                    If (TypeOf var(I) Is lambda) Or Not myl Is Nothing Then
                        ' call lamda
                        If myl Is Nothing Then Set myl = var(I)
                        PushStage basestack, False
                        flag = False
                        it = 1
                        rest$ = vbNullString
                        myl.Name = here$
                        myl.CopyToVar basestack, here$ = vbNullString, var()
                        basestack.OriginalCode = -I
                        basestack.FuncRec = subHash.LastKnown
                        ss$ = myl.code$
                        Call executeblock(it, basestack, ss$, False, flag, , True)
                        myl.CopyFromVar basestack, var()
                        If it = 0 Then
                            Set basestack.lastobj = Nothing
                            Set basestack.FuncObj = Nothing
                            basestack.ThrowThreads
                            MyErMacro rest$, Chr(0) + "Problem in lambda", Chr(0) + "пЯЭБКГЛА СТГ КэЛДА"
                            FK$(13) = "EDIT " & sbf(var(I).OriginalCode).goodname & "," & (-var(I).lastlen - Len(ss$) + 1)
                            myl.lastlen = Len(ss$)
                            PopStage basestack
                            Set basestack = Nothing
                            resp = False
                            Exit Sub
                        End If
                        If c Is Nothing Then Set var(I) = myl ' not allow change when running
                        PopStage basestack
                        Set basestack = Nothing
                        Exit Sub
                    Else
                        InternalError
                        ' INVALID FUNCTION HANDLE
                    End If
                End If
            Else
                ' INVALID FUNCTION HANDLE
                InternalError
            End If
        End If
    ElseIf IsLabelSymbolNewExp(rest$, "цецомос", "EVENT", Lang, ss$) Then
        I = Abs(IsLabel(basestack, rest$, what$))
        If I = 1 Then
            If Not GetVar(basestack, basestack.GroupName + what$, I) Then
                MissPar
            Else
                If VarTypeName(var(I)) <> "mEvent" Then
                    MyEr "Can't find Event", "дЕМ ЛПОЯЧ МА БЯЫ ТО цЕЦОМЭР"
                Else
                    resp = CallEvent(basestack, rest$, Lang, I)
                End If
            End If
        ElseIf I = 5 Then
            If GetEventFromArray(basestack, rest$, what$) Then
                resp = CallEvent(basestack, rest$, Lang, -1)
            End If
        ElseIf I = 0 Then
            If ISSTRINGA(rest$, s$) Then
                If ThisPointer(basestack, I) Then
                    s$ = myUcase(s$)
                    Set Op = var(I)
                    Set A = Op
                    Set Op = Nothing
                    If Not A.EventFuncPos(s$, ss$, x1) Then
                    ' check parent
                        If Len(basestack.UseGroupname) > 0 Then
                            what$ = Mid$(basestack.UseGroupname, 1, Len(basestack.UseGroupname) - 1)
                            If GetVar(basestack, what$, x1) Then
                                If Len(what$) > Len(var(x1).GroupName) Then what$ = Left$(what$, Len(what$) - Len(var(x1).GroupName))
                            End If
                            Do While GetVar(basestack, what$, x1)
                                If Typename$(var(x1)) <> mGroup Then Exit Do
                                Set A = var(x1)
                                If A.EventFuncPos(s$, ss$, x1) Then
                                    If sbf(x1).goodname = ss$ Then GoTo contcallhere
                                End If
                               If Len(what$) > Len(var(x1).GroupName) Then
                               what$ = Left$(what$, Len(what$) - Len(var(x1).GroupName))
                               Else
                               what$ = ""
                               End If
                            Loop
                        End If
                        Set A = Nothing
ThrowPar:
                        ' THROW PARAMETERS HERE
                        Set bs = New basetask
                        Set bs.Owner = basestack.Owner
                        If bs Is Nothing Then Set bs = basestack
                        Set bs.Parent = basestack
                        it = IsLabelSymbolNew(rest$, "диадовийо", "CASCADE", Lang)
                        bs.Look2Parent = True
                        
                        FastSymbol rest$, ","
                        If Not PushParamGeneralV70(bs, rest$, "") Then Exit Sub
                        Set bs = Nothing
                    ElseIf Not sbf(x1).goodname = ss$ Then
                        GoTo ThrowPar
                    Else
contcallhere:
                    Set bs = New basetask
                    Set bs.Owner = basestack.Owner
                    If bs Is Nothing Then Set bs = basestack
                    bs.UseGroupname = sbf(x1).sbgroup
                    bs.tpointer = sbf(x1).tpointer
                    bs.OriginalCode = x1
                    Set bs.Parent = basestack
                    it = IsLabelSymbolNew(rest$, "диадовийо", "CASCADE", Lang)
                    If it Then Set bs.Sorosref = basestack.soros
                    bs.Look2Parent = True
                    FastSymbol rest$, ","
                    If Not PushParamGeneralV70(bs, rest$, "") Then
                        bs.Look2Parent = False
                        Exit Sub
                    End If
                    bs.strg = False
                    bs.fHere = Left$(ss$, rinstr(ss$, ".") - 1)
                    s$ = here$
                    here$ = bs.fHere
                    bs.Look2Parent = False
                    PushStage basestack, False
                    bs.SetSkip
                    executeblock (0), bs, (sbf(x1).sb), (False), (flag)
                    PopStage basestack
                    here$ = s$
                    Set bs = Nothing
                    Exit Sub
                End If
            End If
        End If
    Else
        MissPar
    End If
    Set basestack = Nothing
    Exit Sub
Else
    flag = IsLabelSymbolNew(rest$, "топийа", "LOCAL", Lang)
    If IsLabelSymbolNew(rest$, "сумаятгсг", "FUNCTION", Lang) Then f = 3
reenter1:
    I = Abs(IsLabel(basestack, rest$, what$))

    If I = 3 And Len(rest$) > 0 Then
reenter0:
        If AscW(rest$) = 46 Then
            If Not IsStrExp(basestack, (what$), what$) Then MissPar: Set basestack = Nothing:  Exit Sub
            I = Abs(IsLabel(basestack, rest$, s$))
            what$ = what$ + "." + s$
            If I = 3 And Len(rest$) > 0 Then GoTo reenter0
            s$ = vbNullString
        End If
    End If
reenter1Skip:
    If I = 0 Or I = 2 Then
        If I = 0 Then
            If Not IsStrExp(basestack, rest$, what$) Then MissPar: Set basestack = Nothing:  Exit Sub
        End If
        s$ = what$
        I = Abs(IsLabel(basestack, s$, what$))
        If I = 0 Then
            If FastSymbol(s$, "{") Then
reenter2:
                ss$ = block(s$)
                If FastSymbol(s$, "}") And ss$ <> "" Then
                    PushStage basestack, False
                    x1 = ModuleSubAsap("A_()", ss$, Trim$(s$))
                    Set bs = New basetask
                    Set bs.Parent = basestack
                    If basestack.IamThread Then Set bs.Process = basestack.Process
                    Set bs.Sorosref = basestack.soros  ' same stack
                    Set bs.Owner = basestack.Owner
                    bs.UseGroupname = sbf(x1).sbgroup
                    bs.tpointer = sbf(x1).tpointer
                    bs.OriginalCode = x1
                    bs.SetV
                    If par Then
                        Call GoFunc(bs, what$, rest$, vvl, , x1)
                    Else
                        '' no static for this type of call
                        bs.originalname = "()"
                        Call GoFunc(bs, what$, rest$, vvl, , x1)
                        If Not vvl = Empty And Not flag Then
                            vvl = CStr(vvl)
                            X = InStr(vvl, "|")
                            If X = 0 Then
                                MyEr "ERROR " + vvl, "кахос " + vvl
                            Else
                                MyEr "ERROR " + Left$(vvl, X - 1), "кахос " + Mid$(vvl, X + 1)
                            End If
                            resp = False
                            PopStage basestack   ' this always kill vars
                            Set basestack = Nothing:  Exit Sub
                        End If
                    End If
                    Set bs = Nothing
                    basestack.nokillvars = False
                    If LastErNum = -1 Then
                        Set basestack = Nothing
                        resp = False: Set basestack = Nothing: Exit Sub
                    End If
                    resp = True
                    PopStage basestack   ' this always kill vars
                    Set basestack = Nothing:  Exit Sub
                Else
                    s$ = "Error{Bad Call}, {СТГ ЙКчСГ}"
                End If
            Else
                s$ = "Error{Bad Call}, {СТГ ЙКчСГ}"
            End If
        End If
        ' 2
       If Len(s$) > 0 Then basestack.restpart = s$
    End If
    If f > 0 And I < 5 Then I = I + 4: what$ = what$ + "("
    If I = 1 Then
        If Right$(what$, 1) = ChrW(&H1FFF) Then
            I = InStr(rest$, "()")
            If I > 0 And I < 4 Then
                what$ = what$ + Left$(rest$, I + 1)
                rest$ = Mid$(rest$, I + 1)  ' leave last )
            End If
        End If
        FastSymbol rest$, ","
        MakeThisSub basestack, what$
        it = GetlocalSub(what$, x1)
        If Not it Then
            If SecureNames And basestack.IamChild Then
            x1 = InStrRev(here$, "╩╚")
            If x1 > 0 Then
             x1 = val(Mid$(here$, x1 + 2))
             End If
             End If
            If here$ = what$ Then
            ElseIf x1 > 0 Then
                If Not InStr(sbf(x1).goodname, what$) - 2 = Len(here$) And Not Right$(sbf(x1).goodname, Len(what$) + 1) = "." + what$ Then
                    I = x1
                    s$ = what$
                    If Replace(here$, ChrW(&HFFBF), "") = what$ Then
                        it = True: x1 = basestack.OriginalCode
                    ElseIf Len(basestack.UseGroupname) > 0 Then
                        If InStr(what$, basestack.UseGroupname) = 1 Then
                            what$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
                            it = GetSub(what$, x1)
                        End If
                    End If
                    If it = 0 Then
                        what$ = s$
                        If basestack.fHere <> "" Then
                            If sbf(I).goodname = StripThis2(basestack.fHere + "╚") + "." + s$ Then
                                x1 = I: it = True
                            End If
                        Else
                            If sbf(I).goodname = StripThis2(here$ + "╚") + "." + s$ Then
                                x1 = I: it = True
                            Else
                                it = subHash.Find(what$, x1)
                            End If
                        End If
                    End If
                    If it = 0 Then it = GetSub(what$, x1)
                Else
                     it = True
                End If
            ElseIf Left$(basestack.fHere$, InStr(basestack.fHere$ + "╚", "╚") - 1) = what$ Then  ' GetStrUntil("╚", basestack.fHere$ + "╚")
                it = True: x1 = basestack.OriginalCode
            ElseIf Not SecureNames Then
                If iRVAL(here$, 0) > 0 Then
                    For I = -iRVAL(here$, 0) To -1
                        it = GetSub(RVAL2(here$, I) + what$, x1)
                        If it Then Exit For
                    Next I
                End If
                If it = 0 Then it = GetSub(what$, x1)
            Else
                it = GetSub(what$, x1)
            End If
            If it = 0 Then
                If Replace(here$, ChrW(&HFFBF), "") = what$ Then
                    it = True: x1 = basestack.OriginalCode
                ElseIf Len(basestack.UseGroupname) > 0 Then
                    If InStr(what$, basestack.UseGroupname) = 1 Then
                        s$ = what$
                        If Len(basestack.UseGroupname) > 0 Then what$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
                        it = GetSub(what$, x1)
                        If it = 0 Then it = GetSub(s$, x1): what$ = s$
                    End If
                End If
            End If
        End If
        If it Then
            resp = True
            Set bs = New basetask
            Set bs.Parent = basestack
            If basestack.IamThread Then Set bs.Process = basestack.Process
            Set bs.Sorosref = basestack.soros  ' same stack
            Set bs.Owner = basestack.Owner
            bs.UseGroupname = sbf(x1).sbgroup
            bs.tpointer = sbf(x1).tpointer
            bs.OriginalCode = x1
            bs.SetV
             If Len(here$) = 0 Then
               ' bs.StaticInUse = what$
                here$ = what$
                Call GoFunc(bs, what$, rest$, vvl, , x1)
                here$ = vbNullString
            ElseIf x1 >= 0 Then
                If flag Then
                    bs.UseGroupname = basestack.UseGroupname
                    bs.GroupName = basestack.GroupName
                    bs.StaticInUse = basestack.StaticInUse
                    Set bs.StaticCollection = basestack.StaticCollection
                    bs.CallLocalLast = True
                    bs.strfunnum = basestack.strfunnum
                    bs.strnum = basestack.strnum
                    bs.numnum = basestack.numnum
                    bs.numfunnum = basestack.numfunnum
                    bs.commnum = basestack.commnum
                    Call GoFunc(bs, "()", rest$, vvl, , x1)
                    basestack.FuncValue = vvl
                    Set basestack.FuncObj = bs.lastobj
                    
                    If LastErNum Then
                        MyEr Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        resp = False
                        GoTo exitHere
                    End If
                Else
                    bs.UseGroupname = sbf(x1).sbgroup
                    bs.tpointer = sbf(x1).tpointer
                     If Left$(what$, 1) <> "_" Then
                        If SecureNames And basestack.IamThread Then
                            what$ = "_" + what$ + LTrim$(basestack.Process.id)
                        End If
                    End If
                    bs.StaticInUse = what$
                    Call GoFunc(bs, "", rest$, vvl, , x1)
                    If LastErNum Then
                        MyEr Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        resp = False
                        GoTo exitHere
                    End If
                End If
            Else
                Call GoFunc(bs, what$, rest$, vvl)
            End If
myerror1:
            Set bs = Nothing
            basestack.nokillvars = False
            If LastErNum = -1 Then
                Set basestack = Nothing
                resp = False: Set basestack = Nothing: Exit Sub
            End If
        Else
            resp = True
            ' new :    MyEr "not found " + what$, "ДЕМ БЯщХГЙЕ ТО " + what$
            If Len(rest$) = 0 Then
                rest$ = what$
            Else
                basestack.tmpstr = "@" + what$ + Left$(rest$, 1)
                BackPort rest$
            End If
            'rest$ =  rest$
        End If
        Set basestack = Nothing:  Exit Sub
    ElseIf I = 3 Then
        If IsStrExp(basestack, what$, s$) Then
            If Len(s$) > 0 Then
                If FastSymbol(s$, "{") Then GoTo reenter2
                I = Abs(IsLabel(basestack, s$, what$))
                If Len(s$) > 0 Then basestack.restpart = s$
                s$ = vbNullString
                If I = 3 And Len(rest$) > 0 Then
                GoTo reenter0
                End If
                GoTo reenter1Skip
            Else
                basestack.nokillvars = False
                resp = False
                Set basestack = Nothing:  Exit Sub
            End If
        Else
            ' error
            basestack.nokillvars = False
            resp = False
            Set basestack = Nothing:  Exit Sub
        End If
    ElseIf I > 3 Then
    ' call function as module
    '**********************************************************
        ss$ = what$ + ")"
        FastSymbol rest$, ","
        MakeThisSub basestack, ss$
        it = CLng(GetSub(ss$, x1))
        If Not it Then it = CLng(GetlocalSub(ss$, x1))
        If it = 0 Then
            If StripThis(here$) = ss$ Then
                it = True: x1 = basestack.OriginalCode
            ElseIf Replace(here$, ChrW(&HFFBF), "") = ss$ Then
                it = True: x1 = basestack.OriginalCode
            ElseIf InStr(what$, basestack.UseGroupname) = 1 And Not basestack.UseGroupname = vbNullString Then
                If Len(basestack.UseGroupname) > 0 Then ss$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(ss$, Len(basestack.UseGroupname) + 1)
                it = GetSub(ss$, x1)
            Else
                If Left$(what$, 1) = "T" Or Left$(what$, 1) = "а" Then
                    If Left$(what$, 5) = "THIS." Or Left$(what$, 5) = "ауто." Then
                        ss$ = Left$(what$, 5) + ChrW(&HFFBF) + Mid$(what$, 6) + ")"
                        MakeThisSub basestack, ss$
                        it = GetSub(ss$, x1)
                    End If
                Else
                    If Lang = 1 Then
                        If what$ = "LAMBDA(" Then
again111:
                            If basestack.IamLambda Then
                            ss$ = basestack.FuncRec
                            it = GetSub(ss$, x1)
                            Else
                                ss$ = Mid$(here$, rinstr(here$, "╩.") + 2)
                                If Right$(here$, 2) = "()" Then
                                    If Right$(here$, 2) = "()" And basestack.UseGroupname = vbNullString Then
                                        ss$ = sbf(basestack.OriginalCode).goodname
                                        x1 = basestack.OriginalCode
                                        it = 1
                                    Else
                                        it = GetSub(ss$, x1)
                                        If Not it Then
                                            If here$ Like "*." + ss$ Then
                                                x1 = basestack.OriginalCode
                                                it = 1
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        ElseIf what$ = "LAMBDA$(" Then
                            GoTo again111
                        End If
                    Else
                        If what$ = "калда(" Then
                            GoTo again111
                        ElseIf what$ = "калда$(" Then
                            GoTo again111
                        End If
                    End If
                End If
            End If
        End If
        If it Then
            Set bs = New basetask
            Set bs.Parent = basestack
            bs.IamAnEvent = basestack.IamAnEvent
            If basestack.IamThread Then Set bs.Process = basestack.Process
            If Not TheSame(here$, ss$) Then Set bs.Sorosref = basestack.soros
            Set bs.Owner = basestack.Owner
            bs.OriginalCode = x1
            bs.SetV
            If flag Then
                bs.UseGroupname = basestack.UseGroupname
                bs.GroupName = basestack.GroupName
                bs.CallLocalLast = True
                bs.strfunnum = basestack.strfunnum
                bs.strnum = basestack.strnum
                bs.numnum = basestack.numnum
                bs.numfunnum = basestack.numfunnum
                bs.commnum = basestack.commnum
                Set bs.StaticCollection = basestack.StaticCollection
                Call GoFunc(bs, ss$, rest$, vvl, , x1)
                    basestack.FuncValue = vvl
                    Set basestack.FuncObj = bs.lastobj
                    vvl = Empty
            Else
                bs.UseGroupname = sbf(x1).sbgroup
                bs.tpointer = sbf(x1).tpointer
                Call GoFunc(bs, ss$, rest$, vvl, True, x1)
            End If
            Set bs = Nothing
            If Not par Then
                If InStr(ss$, "$") > 0 Then
                    If vvl <> "" Then  ' no zero we have error
                        X = InStr(vvl, "|")
                        If X = 0 Then
                            MyEr "ERROR " + vvl, "кахос " + vvl
                        Else
                            MyEr "ERROR " + Left$(vvl, X - 1), "кахос " + Mid$(vvl, X + 1)
                        End If
                        resp = False
                        basestack.nokillvars = False
                        Set basestack = Nothing: Exit Sub
                    End If
                Else
                    If val(vvl) <> 0 Then  ' no zero we have error
                        MyEr "ERROR " & Int(val(vvl)), "кахос " & Int(val(vvl))
                        resp = False
                        basestack.nokillvars = False
                        Set basestack = Nothing:  Exit Sub
                    End If
                End If
            End If
        Else
            If Not flag Then
                MyEr "Nothing to call", "тъПОТА ЦИА МА ЙАКщСЫ"
                resp = False
            Else
                rest$ = vbNullString
            End If
        End If
    ElseIf IsStrExp(basestack, rest$, s$) Then
        If f = 3 Then s$ = s$ + "("
        FastSymbol rest$, ","
        If s$ <> "" Then
            If InStr(s$, ").") > 0 And f <> 3 Then
                If Right$(s$, 1) = ")" Then
                    rest$ = s$ + " " + rest$
                    GoTo reenter1
                Else
                    rest$ = ": " + s$ + " " + rest$
                End If
            Else
                If Right$(s$, 1) = ")" Then
                    rest$ = Left$(s$, Len(s$) - 1) + " " + rest$
                Else
                    rest$ = s$ + " " + rest$
                End If
                GoTo reenter1
            End If
        End If
    Else
        rest$ = ": " + rest$
    End If
End If
exitHere:
basestack.nokillvars = False
Set basestack = Nothing

End Sub
Sub NeoCall2(basestack As basetask, rest$, resp As Boolean)
Dim I As Long, p As Variant, par As Boolean, f As Long
Dim flag As Boolean, it As Long, what$, s$, x1 As Long, ss$, bs As basetask, vvl As Variant, X As Double
resp = True
I = Abs(IsLabel(basestack, rest$, what$))
If I = 1 Then

If Right$(what$, 1) = ChrW(&H1FFF) Then
I = InStr(rest$, "()")
If I > 0 And I < 4 Then
what$ = what$ + Left$(rest$, I + 1)
Mid$(rest$, 1, I) = space(I)
End If

End If
JUMPHERE:
    MakeThisSub basestack, what$
   it = GetlocalSub(what$, x1)
  
    If Not it Then it = GetSub(what$, x1)
 If Not it Then
 If here$ = what$ Then
  it = True: x1 = basestack.OriginalCode
 Else
 For I = -iRVAL(here$, 0) To -1
 
    it = GetSub(RVAL2(here$, I) + what$, x1)
    If it Then Exit For
    Next I
   End If
  If it = 0 Then
 If StripThis(here$) = what$ Then
 it = True: x1 = basestack.OriginalCode
 ElseIf Replace(here$, ChrW(&HFFBF), "") = what$ Then
 it = True: x1 = basestack.OriginalCode
 ElseIf InStr(what$, basestack.UseGroupname) = 1 Then
 what$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
 it = GetSub(what$, x1)
 End If
 End If
 End If

    If it Then
       
        resp = True
        Set bs = New basetask
        Set bs.Parent = basestack
        If basestack.IamThread Then Set bs.Process = basestack.Process
        Set bs.Sorosref = basestack.soros  ' same stack
        Set bs.Owner = basestack.Owner
        bs.UseGroupname = sbf(x1).sbgroup
        bs.tpointer = sbf(x1).tpointer
        bs.OriginalCode = x1
        bs.SetV
        If LenB(here$) = 0 Then
            here$ = what$
            Call GoFunc(bs, what$, rest$, vvl, , x1)
            here$ = vbNullString
        ElseIf x1 >= 0 Then
               ' bs.UseGroupname = sbf(x1).sbgroup
                'bs.tpointer = sbf(x1).tpointer
                bs.StaticInUse = what$
                Call GoFunc(bs, "", rest$, vvl, , x1)
        Else
            Call GoFunc(bs, what$, rest$, vvl)
        End If
myerror1:
       ' If Not bs.StaticCollection Is Nothing Then
       '     basestack.Parent.SetVarobJ "%_" + bs.StaticInUse, bs.StaticCollection
       ' End If
        Set bs = Nothing
       
        If LastErNum = -1 Then
    
            resp = False: Exit Sub
        End If
    Else
        resp = False
        rest$ = ":" + what$ + " " + rest$
    End If
ElseIf I = 7 Then
what$ = what$ + ")"
GoTo JUMPHERE
End If

 


End Sub

Function myStructure(basestack As basetask, rest$, Lang As Long) As Boolean
Dim Base As String
If IsStrExp(basestack, rest$, Base) Then
    myStructure = TABLENAMES(Base, basestack, rest$, Lang)
     
Else
    myStructure = makestruct(basestack, rest$, Lang, here$ = "", False)
End If
End Function

Private Function Between(A, b, c, Optional exclude) As Boolean
If IsMissing(exclude) Then
Between = A >= b And A <= c
Else
Between = (A >= b And A <= c) And Not A = exclude
End If
End Function
Function StructPage(basestack As basetask, rest$, Lang As Long, ByVal Offset As Long, ByRef offset2 As Long, offsetlist As FastCollection, ByVal lasthead$) As Boolean
Dim what$, offset1 As Long, I As Long, s$, b$, p As Variant, w2 As Long, maxOffset As Long, probeoffset As Long, usehandler As mHandler, localList As FastCollection
Dim itisSingle As Boolean, itisCur As Boolean
    b$ = NLtrim$(block(rest$))
    If Not FastSymbol(rest$, "}") Then Exit Function
    If FastSymbol(b$, vbCrLf, , 2) Then
        GoTo cont567
    Else
        GoTo again1
    End If
again:
    If FastSymbol(b$, vbCrLf, , 2) Then
cont567:
    Do
        While FastSymbol(b$, vbCrLf, , 2)
        Wend
    Loop Until Not NocharsInLine(b$) Or b$ = vbNullString
again1:
    Set localList = Nothing
    itisSingle = False
    itisCur = False
    If MaybeIsSymbol(b$, "/\'") Then
    
    SetNextLineNL b$
    Do
        While FastSymbol(b$, vbCrLf, , 2)
        Wend
    Loop Until Not NocharsInLine(b$) Or b$ = vbNullString
 
    GoTo again1
    ElseIf FastSymbol(b$, "{") Then
    ' IS A NEW PAGE
    probeoffset = 0
    If StructPage(basestack, b$, Lang, Offset, probeoffset, offsetlist, lasthead$) Then
        If probeoffset > maxOffset Then maxOffset = probeoffset
        FastSymbol b$, ","
        ' leave offset as is
    GoTo cont567
    Else
    Exit Function
    End If
    ElseIf Between(FastPureLabel(b$, what$), 1, 3, 2) Then
    Do
    '' check type, or by default use 2
    If IsLabelSymbolNew(what$, "долг", "STRUCTURE", Lang) Then
    If FastPureLabel(b$, what$) = 1 Then
    If FastSymbol(b$, "{") Then
        probeoffset = 0
        If offsetlist.ExistKey(lasthead$ + what$) Then
        MyEr "double name is same struct", "ДИПКч ЕИСАЦЫЦч ОМЭЛАТОР"
        StructPage = False
        Set offsetlist = Nothing
        Exit Function
        End If

        If StructPage(basestack, b$, Lang, Offset, probeoffset, offsetlist, lasthead$ + what$ + ".") Then
            If FastSymbol(b$, "*") Then
                p = 1&
                If Not IsExp(basestack, b$, p) Then MissNumExpr: Exit Function
                p = MyRound(p)
                If p * (probeoffset - Offset) + Offset > &H1FFFFFFF Then ' half gigabyte for struct (is very big too)
                    GoTo err111
                ElseIf p <= 0 Then
                    GoTo err222
                End If
                probeoffset = p * (probeoffset - Offset) + Offset
            End If
            
            
            If probeoffset > maxOffset Then maxOffset = probeoffset

            ' leave offset as is
    
            offsetlist.AddKeyStruct myUcase(lasthead$ + what$, True), Offset, 1&, Nothing
            'offsetlist.AddKeyS myUcase(lasthead$ + what$, True), offset ', 1&, Nothing
            If offsetlist.Done Then
            offsetlist.sValue = probeoffset - Offset
            If FastSymbol(b$, ";") Then
            Offset = probeoffset
            End If
            ' keytype not used for strucrures except for single values
            ' so Eval() can read single from 4 bytes
            If itisSingle Then offsetlist.KeyTypeValue = CInt(vbSingle): itisSingle = False
            If itisCur Then offsetlist.KeyTypeValue = CInt(vbCurrency): itisCur = False
            End If
            FastSymbol b$, ","
        GoTo cont567
        Else
        Exit Function
        End If
    Else
        Exit Function
    End If
        Else
        Exit Function
    End If

    ElseIf IsLabelSymbolNew(b$, "ыс", "AS", Lang) Then
            itisSingle = False
            itisCur = False
                            If IsLabelSymbolNew(b$, "ьгжио", "BYTE", Lang) Then
                                     offset1 = 1
                                ElseIf IsLabelSymbolNew(b$, "айеяаиос", "INTEGER", Lang) Then
                                     offset1 = 2
                                ElseIf IsLabelSymbolNew(b$, "лайяус", "LONG", Lang) Then
                                    If IsLabelSymbolNew(b$, "лайяус", "LONG", Lang) Then
                                    offset1 = -8  ' negative for long long?
                                    Else
                                    offset1 = 4
                                    End If
                                ElseIf IsLabelSymbolNew(b$, "коцистийос", "CURRENCY", Lang) Then
                                    offset1 = 8
                                    itisCur = True
                                ElseIf IsLabelSymbolNew(b$, "апкос", "SINGLE", Lang) Then
                                     offset1 = 4
                                     itisSingle = True
                                ElseIf IsLabelSymbolNew(b$, "цяалла", "STRING", Lang) Then
                                     offset1 = -4
                                ElseIf IsLabelSymbolNew(b$, "дипкос", "DOUBLE", Lang) Then
                                     offset1 = 8
                                Else
                                If Abs(IsLabel(basestack, b$, s$)) = 1 Then
                                If GetVar3(basestack, basestack.GroupName + s$, I) Then
                                If IsExp(basestack, basestack.GroupName + s$, p) Then
                                    If basestack.lastobj Is Nothing Then GoTo comehere
                                    If Not TypeOf basestack.lastobj Is mHandler Then GoTo comehere
                                    Set usehandler = basestack.lastobj
                                    If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                    Set localList = usehandler.objref
                                    If localList.structLen = 0 Then GoTo comehere
                                    offset1 = localList.structLen
                                    Set usehandler = Nothing
                                    Set basestack.lastobj = Nothing
                                    Else
                                    GoTo comehere
                                End If
                                Else
                                If IsExp(basestack, s$, p) Then
                                    If basestack.lastobj Is Nothing Then GoTo comehere
                                    If Not TypeOf basestack.lastobj Is mHandler Then GoTo comehere
                                    Set usehandler = basestack.lastobj
                                    If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                    If usehandler.objref.structLen = 0 Then GoTo comehere
                                offset1 = usehandler.objref.structLen
                                    Set basestack.lastobj = Nothing
                                    Set usehandler = Nothing
                                    Else
                                    GoTo comehere
                                End If
                                End If
                                Else
comehere:
                                    SyntaxError
                 
                                   Exit Function
                                   End If
                                   End If
    
    Else
        offset1 = 2
        End If
        w2 = offset1  ' negative offset for strings
        p = 1
        If FastSymbol(b$, "*") Then
            If Not IsExp(basestack, b$, p) Then
                MissNumExpr
            Exit Function
        Else
            p = MyRound(p)
            If p * Abs(offset1) + Offset > &H1FFFFFFF Then  ' half gigabyte for struct (is very big too)
err111:
                MyEr "Too big size for struct", "лЕЦэКО ЛщЦЕХОР ЦИА ДОЛч"
                Exit Function
            ElseIf p <= 0 Then
err222:
                MyEr "size is zero or less for struct", "лЕЦэКО МОЩЛЕЯО ЦИА ДОЛч"
                Exit Function
            Else
                offset1 = offset1 * CLng(p)
            End If
        End If
    End If
    If offsetlist.ExistKey(lasthead$ + what$) Then
    MyEr "double name is same struct", "ДИПКч ЕИСАЦЫЦч ОМЭЛАТОР"
    StructPage = False
    Set offsetlist = Nothing
    Exit Function
    End If
    
    'offsetlist.AddKey myUcase(lasthead$ + what$, True), CVar(offset)
    If p <= 0 Then p = 1
    offsetlist.AddKeyStruct myUcase(lasthead$ + what$, True), Offset, CLng(p), localList
    If offsetlist.Done Then offsetlist.sValue = w2
    If itisSingle Then offsetlist.KeyTypeValue = CInt(vbSingle): itisSingle = False
    If itisCur Then offsetlist.KeyTypeValue = CInt(vbCurrency): itisCur = False
    Offset = Offset + Abs(offset1)
    If FastSymbol(b$, ",") Then
    If NocharsInLine(b$) Or b$ = vbNullString Then
    GoTo cont147
    End If
    While FastSymbol(b$, vbCrLf, , 2)
    Wend
    Else
    SetNextLineNL b$
    Do
        While FastSymbol(b$, vbCrLf, , 2)
        Wend
    Loop Until Not NocharsInLine(b$) Or b$ = vbNullString
    End If
cont147:
    If MaybeIsSymbol(b$, "{") Then GoTo a192929
    Loop Until Not Between(FastPureLabel(b$, what$), 1, 3, 2)
a192929:
    If maxOffset < Offset Then
        offset2 = Offset
    Else
        offset2 = maxOffset
    End If
    StructPage = True
    GoTo again1
   End If
    If maxOffset < Offset Then
    offset2 = Offset
    Else
    offset2 = maxOffset
    End If
    StructPage = True
   
    If offset2 < maxOffset Then
        offset2 = maxOffset
        StructPage = True
    End If
    End If
    

End Function

Function MyLet(bstack As basetask, rest$, Lang As Long) As Boolean
Dim what$, ss$, s$, I As Long, x1 As Long, flag As Boolean
MyLet = True
Dim whatplus$, x2 As Long
Do
    whatplus$ = vbNullString
    x1 = Abs(IsLabelBig(bstack, rest$, what$))
    If x1 <> 0 Then
        If x1 = 8 Then
            ss$ = BlockParamSq(rest$)
            I = Len(ss$)
            If I = 0 Then SyntaxError: MyLet = False: Exit Function
            Mid$(rest$, 1, I) = space(I)
            I = I + 1
            If Mid$(rest$, I, 2) = "][" Then
                While Mid$(rest$, I, 2) = "]["
                    Mid$(rest$, I, 2) = "  "
                    s$ = BlockParamSq(rest$)
                    If Len(s$) - I < 2 Then SyntaxError: MyLet = False: Exit Function
                    Mid$(rest$, 1, Len(s$)) = space(Len(s$))
                    ss$ = ss$ + "][" + Trim(s$)
                    I = 1 + Len(s$)
                Wend
            End If
            If Mid$(rest$, I, 1) <> "]" Then SyntaxError: MyLet = False: Exit Function
            Mid$(rest$, I, 1) = " "
            what$ = what$ + "[" + ss$ + "]"
            
            
            
        ElseIf x1 > 4 Then
j4:
            ss$ = BlockParam(rest$)
            If x1 > 4 Then
            what$ = what$ + ss$ + ")"
            Else
            whatplus$ = whatplus$ + ss$ + ")"
            End If
            Mid$(rest$, 1, Len(ss$) + 1) = space(Len(ss$) + 1)
            Do While IsSymbol(rest$, ".")
                x1 = IsLabel(bstack, rest$, ss$)
                If x1 > 0 Then what$ = what$ + "." + ss$ Else Exit Do
                If x1 > 4 Then
                    ss$ = BlockParam(rest$)
                    what$ = what$ + ss$ + ")"
                    Mid$(rest$, 1, Len(ss$) + 1) = space(Len(ss$) + 1)
                End If
            Loop
        End If
j0:
        If FastSymbol(rest$, "=") Then
            I = 1
            aheadstatus rest$, False, I
            If I > 1 Then
                ss$ = Left$(rest$, I - 1)
                flag = MyPush(bstack, ss$)
                If LastErNum = -2 Then
                    rest$ = ss$ + Mid$(rest$, I)
                    MyLet = flag
                    Exit Function
                ElseIf NLtrim(ss$) <> vbNullString Then
                    SyntaxError
                    Exit Function
                End If
                If MyLet Then
                '    If x1 = 8 Then
                 '       MyLet = MyRead(6, bstack, s$, 1, s$, x1)
                  '  Else
                  If Len(whatplus$) > 0 Then
                        If x1 = 1 Then
                        MyLet = MyRead(6, bstack, whatplus$, Lang, what$, x1)
                        Else
                        MyLet = MyRead(6, bstack, what$ + whatplus$, Lang, what$, x1)
                        End If
                    Else
                        MyLet = MyRead(6, bstack, what$, Lang, what$, x1)
                    End If
                    rest$ = Mid$(rest$, I)
                Else
                    MyEr "Nothing to assign", "тъПОТА ЦИА МА ДЧСЫ"
                    Exit Function
                End If
            Else
                MyEr "Expecting expression", "пЕЯъЛЕМА щЙЖЯАСГ"
                MyLet = False
            End If
        ElseIf FastSymbol(rest$, "|") Then
            x2 = Abs(IsLabelBig(bstack, rest$, whatplus$))
            If x2 > 0 Then
                
                If x2 > 4 Then
                    If x1 < 5 Then
                    whatplus$ = "|" + whatplus$
                    Else
                    what$ = what$ + "|" + whatplus$
                    whatplus$ = ""
                    End If
                    GoTo j4
                End If
                whatplus$ = "|" + whatplus$
                GoTo j0

            End If
            
        End If
    End If
Loop Until Not FastSymbol(rest$, ",")
End Function
Function MyThread(bstack As basetask, rest$, Lang As Long) As Boolean
Dim frm$, ss$, what$, I As Long, p As Variant, X As Double, par As Boolean, bs As basetask
MyThread = True
If FastSymbol(rest$, "{") Then
    frm$ = NLtrim$(block(rest$))
    If FastSymbol(rest$, "}") Then
        par = False
        If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
        Else
            MyEr "can't find clause AS variable_name", "ДЕМ ЛПОЯЧ МА БЯЧ ТО ЛщЯОР ыс ОМОЛА_ЛЕТАБКГТчР"
            MyThread = False
            Exit Function
        End If
        Select Case Abs(IsLabel(bstack, rest$, what$)) ' is Ifier
        Case 1
            p = GetTaskId + 20000
            If GetVar(bstack, what$, I) Then ' if exist
                var(I) = p
            Else
                globalvar what$, p     ' or make one
            End If
            Set bs = New basetask   ' bs is the basetask of the thread but thread process class arn't constructed yet
            Set bs.Parent = bstack  ' link to current basestask
            bstack.PushThread CLng(p), what$  'push thread id and Ifier to threads collection in current basetask
            sThreadInternal bs, p, 0, frm$, -1&, here$, False ' thread construction - also we have a connection to
            Set bs = Nothing
            ss$ = vbNullString
            If IsLabelSymbolNewExp(rest$, "йахе", "INTERVAL", Lang, ss$) Then
                GoTo chekInterval
            ElseIf IsLabelSymbolNewExp(rest$, "ейтекесг", "EXECUTE", Lang, ss$) Then
                If FastSymbol(rest$, "{") Then
                    frm$ = NLtrim$(block(rest$))
                    If FastSymbol(rest$, "}") Then
                        TaskMaster.Message CLng(p), 5, , frm$
                    Else
                        SyntaxError
                        MyThread = False
                    End If
                Else
                    TaskMaster.Message CLng(p), 4, , rest$
                End If
            End If
        Case Else
            MissingnumVar
            MyThread = False
            Exit Function
        End Select
    End If
ElseIf IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
    ss$ = vbNullString
    If IsLabelSymbolNewExp(rest$, "сбгсе", "ERASE", Lang, ss$) Then
        If Not bstack.ThrowOne(CLng(p)) Then
            TaskMaster.ThrowOne (CLng(p))
        End If
    ElseIf IsLabelSymbolNewExp(rest$, "йяата", "HOLD", Lang, ss$) Then
        TaskMaster.Message CLng(p), 0
    ElseIf IsLabelSymbolNewExp(rest$, "ейтекесг", "EXECUTE", Lang, ss$) Then
        If FastSymbol(rest$, "{") Then
            frm$ = NLtrim$(block(rest$))
            If FastSymbol(rest$, "}") Then
                TaskMaster.Message CLng(p), 5, , frm$
            Else
                SyntaxError
                MyThread = False
            End If
        Else
            TaskMaster.Message CLng(p), 4, , rest$
        End If
    ElseIf IsLabelSymbolNewExp(rest$, "нейима", "RESTART", Lang, ss$) Then
        TaskMaster.Message CLng(p), 2
    ElseIf IsLabelSymbolNewExp(rest$, "йахе", "INTERVAL", Lang, ss$) Then
chekInterval:
        If IsExp(bstack, rest$, X, flatobject:=True, nostring:=True) Then
            If X < 2 Then X = 2
            TaskMaster.Message CLng(p), 3, CLng(X)
        Else
            MisInterval
            MyThread = False
        End If
    Else
        NoClauseInThread
        MyThread = False
    End If
End If
what$ = vbNullString
End Function
Function ObjFromPtr(ByVal Ptr As Long) As Object
    ObjSetAddRef ObjFromPtr, Ptr
End Function
Function AssignTypeNumeric(v, ByVal I As Integer) As Boolean
If myVarType(v, I) Then AssignTypeNumeric = True: Exit Function
On Error GoTo there
Select Case I
Case vbBoolean
v = CBool(v)
Case vbCurrency
v = CCur(v)
Case vbDecimal
v = CDec(v)
Case vbLong
v = CLng(v)
Case vbSingle
v = CSng(v)
Case vbInteger
v = CInt(v)
Case 20
v = cInt64(v)
Case vbDouble
v = CDbl(v)
Case vbByte
v = CByte(v)
Case vbDate
v = CDate(v)
Case vbUserDefinedType
'If MemInt(VarPtr(v)) <> I Then
'MissType
'Exit Function
'End If
Case vbString
MissStringExpr
Exit Function
End Select

AssignTypeNumeric = True
Exit Function
there:
If Err = 6 Then
Err.Clear
OverflowValue CInt(I)
Exit Function
End If
MyEr "Can't convert value", "дЕМ ЛПОЯЧ МА ЛЕТАТЯщЬЫ ТГМ ТИЛч"
End Function
Function AssignTypeNumeric2(v, ByVal I As Integer) As Boolean
If myVarType(v, I) Then AssignTypeNumeric2 = True: Exit Function
On Error GoTo there
Select Case I
Case vbBoolean
v = CBool(v)
Case vbCurrency
v = CCur(v)
Case vbDecimal
v = CDec(v)
Case vbLong
v = CLng(v)
Case vbSingle
v = CSng(v)
Case vbInteger
v = CInt(v)
Case 20
v = cInt64(v)
Case vbByte
v = CByte(v)
Case vbDate
v = CDate(v)
Case vbUserDefinedType
If MemInt(VarPtr(v)) <> I Then
MissType
Exit Function
End If
Case vbString
v = vbNullString
Case Else
v = CDbl(v)
End Select
AssignTypeNumeric2 = True
Exit Function
there:
End Function
Function MyPush(bstack As basetask, rest$) As Boolean
Dim s$, p As Variant, usehandler As mHandler
MyPush = True
Do
    If FastSymbol(rest$, "!") Then
        If IsExp(bstack, rest$, p, nostring:=True) Then
            If bstack.lastobj Is Nothing Then
                bstack.soros.PushValLong CLng(p)
            ElseIf TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                If TypeOf usehandler.objref Is mStiva Then
                    bstack.soros.MergeTop usehandler.objref
                ElseIf TypeOf usehandler.objref Is mArray Then
                    bstack.soros.MergeTopCopyArray usehandler.objref
                Else
myp123:
                    MyPush = False
                    MyEr "Expected Stack Object or Array after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО сЫЯЭ ч ПъМАЙА ЛЕТэ ТО !"
                    Set bstack.lastobj = Nothing
                    Exit Function
                End If
                Set bstack.lastobj = Nothing
                Set usehandler = Nothing
            ElseIf TypeOf bstack.lastobj Is mArray Then
                bstack.soros.MergeTopCopyArray bstack.lastobj
                Set bstack.lastobj = Nothing
            Else
                GoTo myp123
            End If
        End If
    ElseIf IsExp(bstack, rest$, p) Then
        If bstack.lastobj Is Nothing Then
            If myVarType(p, vbString) Then
                SwapString2Variant s$, p
                bstack.soros.PushStr s$
            Else
                bstack.soros.PushVal p
            End If
        Else
            If TypeOf bstack.lastobj Is mStiva Then
                Set bstack.Sorosref = bstack.lastobj
            ElseIf TypeOf bstack.lastobj Is VarItem Then
                bstack.soros.PushObjVarItem bstack.lastobj
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                bstack.soros.PushObj bstack.lastobj
                Set bstack.lastpointer = Nothing
            End If
            Set bstack.lastobj = Nothing
        End If
    ElseIf IsStrExp(bstack, rest$, s$, False) Then
        If bstack.lastobj Is Nothing Then
            bstack.soros.PushStr s$
        Else
            If TypeOf bstack.lastobj Is Group Then
                bstack.lastobj.ToDelete = False
            End If
            bstack.soros.PushObj bstack.lastobj
            Set bstack.lastobj = Nothing
            Set bstack.lastpointer = Nothing
        End If
    Else
        MyPush = LastErNum1 = 0
        Exit Do
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
Loop
End Function
Function MyData(bstack As basetask, rest$) As Boolean
Dim s$, p As Variant, usehandler As mHandler
MyData = True
Do
    If FastSymbol(rest$, "!") Then
        If IsExp(bstack, rest$, p, nostring:=True) Then
            If bstack.lastobj Is Nothing Then
                bstack.soros.DataValLong p
            ElseIf TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                If TypeOf usehandler.objref Is mStiva Then
                    bstack.soros.MergeBottom usehandler.objref
                ElseIf TypeOf usehandler.objref Is mArray Then
                    bstack.soros.MergeBottomCopyArray usehandler.objref
                Else
myd123:
                    MyData = False
                    MyEr "Expected Stack Object or Array after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО сЫЯЭ ч ПъМАЙА ЛЕТэ ТО !"
                    Set bstack.lastobj = Nothing
                    Exit Function
                End If
                Set bstack.lastobj = Nothing
                Set usehandler = Nothing
            ElseIf TypeOf bstack.lastobj Is mArray Then
                bstack.soros.MergeBottomCopyArray bstack.lastobj
                Set bstack.lastobj = Nothing
            Else
                GoTo myd123
            End If
        End If
    ElseIf IsExp(bstack, rest$, p) Then
        If bstack.lastobj Is Nothing Then
            If myVarType(p, vbString) Then
                SwapString2Variant s$, p
                bstack.soros.DataStr s$
            Else
                bstack.soros.DataVal p
            End If
        Else
            If TypeOf bstack.lastobj Is mStiva Then
                Set bstack.Sorosref = bstack.lastobj
            ElseIf TypeOf bstack.lastobj Is VarItem Then
                bstack.soros.DataObjVaritem bstack.lastobj
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                bstack.soros.DataObj bstack.lastobj
                Set bstack.lastpointer = Nothing
            End If
            Set bstack.lastobj = Nothing
        End If
    ElseIf IsStrExp(bstack, rest$, s$, False) Then
        If bstack.lastobj Is Nothing Then
            bstack.soros.DataStr s$
        Else
            If TypeOf bstack.lastobj Is Group Then
                bstack.lastobj.ToDelete = False
            End If
            bstack.soros.DataObj bstack.lastobj
            Set bstack.lastobj = Nothing
            Set bstack.lastpointer = Nothing
        End If
    Else
        MyData = LastErNum1 = 0
        Exit Do
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
Loop
End Function
Function MyClear(bstack As basetask, rest$) As Boolean
Dim curbstack As basetask, I As Long, y1 As Long, what$, it As Long, pppp As mArray, myobject As mStiva
Dim usehandler As mHandler
MyClear = True
Do
    y1 = Abs(IsLabel(bstack, rest$, what$))
    If y1 = 3 Then
        If GetVar(bstack, what$, I) Then
            If VarTypeName(var(I)) = doc Then
                Set var(I) = New Document
                var(I).LCID = LCID_DEF
                var(I).textDoc = vbNullString
            Else
                var(I) = vbNullString
            End If
        Else
            globalvar what$, ""
        End If
    ElseIf y1 < 5 And y1 > 0 Then
        If GetVar(bstack, what$, I) Then
            If MyIsObject(var(I)) Then
            ' PUT ZERO TO VARIABLES INSIDE GROUP
                If Typename(var(I)) = "lambda" Then
                    Set var(I) = Nothing
                    Dim ok As Boolean
                    var(I) = 0&
                ElseIf Typename(var(I)) = mGroup Then
                    If Not var(I).IamCleared Then
                        CallClear bstack, what$, var(I)
                        If var(I).IamApointer Then
                            Set var(I) = New Group
                        Else
                            var(I).ResetGroup
                        End If
                    End If
                ElseIf Typename(var(I)) = mHdlr Then
                    Set usehandler = var(I)
                    If usehandler.T1 = 1 Then
                        If usehandler.ReadOnly Then
                            ReadOnly
                            MyClear = False
                            Exit Function
                        End If
                        If usehandler.UseIterator Then
                            ReadOnly
                            MyClear = False
                            Exit Function
                        End If
                        If usehandler.objref.IsQueue Then
                            Set var(I) = Nothing
                            MakeitObjectInventory var(I), True
                        Else
                            Set var(I) = Nothing
                            MakeitObjectInventory var(I)
                        End If
                    ElseIf usehandler.T1 = 2 Then
                        Set usehandler = New mHandler
                        Set var(I) = usehandler
                        usehandler.T1 = 2
                        Set usehandler.objref = New MemBlock
                    ElseIf usehandler.UseIterator Then
                        Set var(I) = Nothing
                        var(I) = 0&
                    ElseIf Typename$(usehandler.objref) = myArray Then
                        Set usehandler.objref = New mArray
                    ElseIf Typename$(usehandler.objref) = "mStiva" Then
                         Set usehandler.objref = New mStiva
                    End If
                Else
                     var(I) = Empty
                End If
            ElseIf myVarType(var(I), vbLong) Then
                var(I) = 0&
            ElseIf myVarType(var(I), vbString) Then
                var(I) = vbNullString
            Else
                var(I) = 0#
            End If
        Else
            globalvar what$, it
        End If
    ElseIf y1 = 5 Or y1 = 7 Then
        If neoGetArray(bstack, what$, pppp) Then
            If Not pppp.Arr Then NotArray: MyClear = False: Exit Function
            If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then MyClear = False: Exit Function
                If pppp.ItemType(it) = mGroup Then
                    Set pppp.item(it) = Nothing
                    EmptyVariantArrayItem pppp, it
                ElseIf pppp.ItemType(it) = "lambda" Then
                    Set pppp.item(it) = Nothing
                    EmptyVariantArrayItem pppp, it
                Else
                    SyntaxError
                    MyClear = False
                End If
            Else
                SyntaxError
                MyClear = False
            End If
    ElseIf y1 = 6 Then
        If neoGetArray(bstack, what$, pppp) Then
            If Not pppp.Arr Then NotArray: MyClear = False: Exit Function
            If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then MyClear = False: Exit Function
            If pppp.ItemType(it) = mGroup Then
                Set pppp.item(it) = Nothing
                EmptyVariantArrayItem pppp, it
            ElseIf pppp.ItemType(it) = doc Then
                Set pppp.item(it) = New Document
                pppp.item(it).textDoc = vbNullString
            ElseIf pppp.ItemType(it) = "lambda" Then
                Set pppp.item(it) = Nothing
                EmptyVariantArrayItem pppp, it
            Else
                pppp.item(it) = vbNullString
            End If
        Else
            SyntaxError
            MyClear = False
        End If
    ElseIf y1 > 0 Then
        SyntaxError
        MyClear = False
    Else
        Form1.List1.Clear
        If bstack.IamThread Then
            If Not bstack.StaticCollection Is Nothing Then
                Set bstack.StaticCollection = Nothing
            End If
        ElseIf bstack.IamAnEvent Then
            If Not bstack.StaticCollection Is Nothing Then
                If Not bstack.Parent Is Nothing Then
                    If Not bstack.Parent.StaticCollection Is Nothing Then
                        If bstack.Parent.StaticCollection.ExistKey("%_" + here$) Then
                            bstack.Parent.StaticCollection.RemoveWithNoFind
                        End If
                    End If
                End If
                Set bstack.StaticCollection = Nothing
  
            Else
                MyEr "Only static variables can clear in an event", "лЭМО СТАТИЙщР ЛПОЯЧ МА СБчСЫ СЕ щМА ЦЕЦОМЭР"
            End If
        Else
            bstack.clearbasket
            Set curbstack = bstack
again1234:
            If curbstack.IamChild Then
                If curbstack.IamThread Then Set curbstack = Nothing: Exit Function
                If Not curbstack.Parent.IamChild And Not curbstack.Parent.IamAnEvent Then
                    Set EventStaticCollection = New FastCollection
                End If
                If curbstack.IamAnEvent Then Set curbstack = Nothing: Exit Function
                With curbstack
                    If .SkipClear > 0 Then Set curbstack = Nothing: Exit Function
                    var2used = curbstack.Vars
                    varhash.ReduceHash curbstack.Vname, var()
                End With
                Exit Function
            End If
            GarbageFlush
            Set curbstack = Nothing
            Set EventStaticCollection = New FastCollection
            Set bstack.StaticCollection = Nothing
            varhash.ReduceHash 0, var()
            varhash.BigSize 3000
            var2used = 0
            ReDim var(3000) As Variant
            Set curbstack = bstack
again12345:
            If curbstack.IamChild Then
                With curbstack
                    If .Vars = 0 Then Set curbstack = Nothing: Exit Function
                    .Vars = 0
                End With
                Set curbstack = curbstack.Parent
                GoTo again12345
            End If
            Set curbstack = Nothing
        End If
        Exit Do
    End If
    If Not MyClear Then Exit Do
Loop Until Not FastSymbol(rest$, ",")
End Function
Function MyMethod(bstack As basetask, rest$, Lang As Long, groupok As Boolean, prive As Boolean) As Boolean

Dim I As Long, s$, pppp As mArray, pa$, ok As Boolean, r As Variant, j As Integer
Dim s1$
I = Abs(IsLabel(bstack, rest$, s$))
'I = Abs(innerIsLabel(bstack, rest$, s$, , True, True))

If Not groupok Then
Else
    s1$ = bstack.GroupName + ChrW(&HFFBF) + s$
    s$ = bstack.GroupName + s$
End If
MyMethod = True
ok = True
If I = 1 Or I = 3 Then
If GetVar(bstack, s$, I) Then
CONT1234:
        j = MemInt(VarPtr(var(I)))
        If j = 9 Or j = 13 Then
            If var(I) Is Nothing Then
                MissingObj
            Else
                Dim p
                IsSymbol3 rest$, ","
                If IsExp(bstack, rest$, p) Then
                'If IsStrExp(bstack, rest$, pa$) Then
                      If Not bstack.lastobj Is Nothing Then
                      
                      Exit Function
                      End If
                      If MemInt(VarPtr(p)) = vbString Then
                          SwapString2Variant pa$, p
                          ProcMethod bstack, var(), I, pa$, rest$, Lang, ok, groupok, prive
                      Else
                          MyEr "not ready yet", "ДЕМ ДОУКЕЩЕИ АЙЭЛА"
                      End If
                    
                
                ElseIf IsStrExp(bstack, rest$, pa$, False) Then
                    ProcMethod bstack, var(), I, pa$, rest$, Lang, ok, groupok, prive
                End If
                MyMethod = ((Err = 0) And ok)
                Err.Clear
            End If
        Else
            MyMethod = False
            MissingObjRef
        End If
        Exit Function
        Else
        If GetVar(bstack, s1$, I) Then
        GoTo CONT1234
        End If
  Nosuchvariable s$
 End If
 ElseIf I = 5 Or I = 6 Then
  If neoGetArray(bstack, s$, pppp) Then
again11:
    If NeoGetArrayItem(pppp, bstack, s$, I, rest$) Then
    If FastSymbol(rest$, "(") Then
    If MyIsObject(pppp.item(I)) Then
    Dim pppp1 As mArray
    If TypeOf pppp.itemObject(I) Is mArray Then
        Set pppp = pppp.item(I)
    Else
        pppp1.Arr = False
        Set pppp1.GroupRef = pppp.item(I)
        Set pppp = pppp1
        Set pppp1 = Nothing
    End If
    GoTo again11
    End If
    End If
             IsSymbol3 rest$, ","
            If IsStrExp(bstack, rest$, pa$) Then
                ProcMethodArray bstack, pppp, I, pa$, rest$, Lang, MyMethod, groupok, prive
              End If
     End If
  Else
   MyMethod = False
      MissingObj
  End If

End If

End Function
Function GetEventFromArray(basestack As basetask, rest$, what$) As Boolean
Dim pppp As mArray, x1 As Long
 If neoGetArray(basestack, what$, pppp) Then
  If Not NeoGetArrayItem(pppp, basestack, what$, x1, rest$, True) Then Exit Function
    If MyIsObject(pppp.item(x1)) Then
    GetEventFromArray = True
    Set basestack.lastobj = pppp.item(x1)
    Exit Function
    Else
    MyEr "Not an Event object", "╪ВИ щМА АМТИЙЕъЛЕМО цЕЦОМЭР"
 Exit Function
    End If
 End If
End Function
Function myEvent(basestack As basetask, rest$, Lang As Long, Optional alocal As Boolean)
Dim x1 As Long, what$, I As Long
myEvent = True
 x1 = Abs(IsLabel(basestack, rest$, what$))
 If x1 <> 1 Then
 If x1 = 5 Then
 Dim pppp As mArray
 If neoGetArray(basestack, what$, pppp) Then
  If Not NeoGetArrayItem(pppp, basestack, what$, x1, rest$, True) Then Exit Function
    If MyIsObject(pppp.item(x1)) Then
    Set basestack.lastobj = pppp.item(x1)
    myEvent = ProcEvent(basestack, rest$, Lang, -1)
    Exit Function
    Else
    MyEr "Not an Event object", "╪ВИ щМА АМТИЙЕъЛЕМО цЕЦОМЭР"
    myEvent = False: Exit Function
    End If
 End If
 Else
    myEvent = False: Exit Function
 End If
 End If
 If basestack.priveflag Then what$ = ChrW(&HFFBF) + what$
 If alocal Then
 I = globalvar(basestack.GroupName + what$, Empty)
 MakeitObjectEvent var(I)
 ElseIf GetlocalVar(basestack.GroupName + what$, I) Then
 ' we found it
  ElseIf GetVar(basestack, basestack.GroupName + what$, I) Then
  ' we found it
  Else
   I = globalvar(basestack.GroupName + what$, Empty)
   MakeitObjectEvent var(I)
 End If
 myEvent = ProcEvent(basestack, rest$, Lang, I)
End Function
Function MyReport(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, prive As Long, X As Double, Y As Double, y1 As Long, x1 As Long, it As Long
Dim s$, I As Long, pa$, sX As Double
MyReport = False
prive = GetCode(bstack.Owner)
If FastSymbol(rest$, "!") Then
    If IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then
        ReportTabWidth = Abs(p)
        players(prive).ReportTab = ReportTabWidth
        MyReport = True
    End If
    Exit Function
End If
If IsExp(bstack, rest$, p, , True) Then
If MemInt(VarPtr(p)) = vbString Then s$ = p: p = 0: GoTo there123
    If Not FastSymbol(rest$, ",") Then MissPar:: Exit Function
Else
    p = 0
End If
If IsStrExp(bstack, rest$, s$, False) Then
there123:
    X = bstack.Owner.Width
    If lookOne(rest$, ";") Then SyntaxError: Exit Function
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, X) Then: Exit Function
        With players(prive)
            If X <= .mX Then
                X = X * .Xt - 2 * dv15
                bstack.Owner.currentX = bstack.Owner.currentX + dv15
            End If
        End With
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, Y) Then: Exit Function
        y1 = Y - 1
        If IsLabelSymbolNew(rest$, "цяаллг", "LINE", Lang) Then
            If Not IsExp(bstack, rest$, sX) Then Exit Function
            x1 = sX - 1
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), x1, , , True
                bstack.tmpstr = "@READ " + Left$(rest$, 1)
                BackPort rest$
                If Not executeblock(I, bstack, rest$, True, False, , True) Then
                ' error ??
                End If
            Else
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), x1
            End If
        Else
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), , it, , True
                bstack.tmpstr = "@READ " + Left$(rest$, 1)
                BackPort rest$
                If Not executeblock(I, bstack, rest$, True, False, , True) Then
                ' error ?
                End If
            Else
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), , it
            End If
        End If
        players(prive).LastReportLines = CDbl(it)
    Else
        wwPlain bstack, players(prive), s$, CLng(X), 100000, True, , CLng(p), , it
        players(prive).LastReportLines = -1
    End If
    MyReport = True
Else
    If LastErNum <> 0 Then LastErNum = 0: Exit Function      'ifier=true
End If

End Function
Function MyInput(bstack As basetask, rest$, Lang As Long) As Boolean
Dim I As Long, p As Variant, pp As Variant, s$, ss$, what$, f As Long, x1 As Long, Y As Double, X As Double
Dim frm$, par As Boolean, pppp As mArray, prive As Long, it As Long, W$, mystack As mStiva
If IsLabelSymbolNew(rest$, "ле", "WITH", Lang) Then
    
    If IsExp(bstack, rest$, p, , True) Then
        If MemInt(VarPtr(p)) = vbString Then
            SwapString2Variant s$, p
            p = Empty
            GoTo wehavestring
        Else
            MissStringExpr
        End If
    ElseIf IsStrExp(bstack, rest$, s$, False) Then
wehavestring:
        inpcsvsep$ = Left$(s$, 1)
        If FastSymbol(rest$, ",") Then
        
        If IsExp(bstack, rest$, p, , True) Then
            If MemInt(VarPtr(p)) = vbString Then
                SwapString2Variant s$, p
                p = Empty
                GoTo wehavestring2
            Else
                MissStringExpr
            End If
        ElseIf IsStrExp(bstack, rest$, s$, False) Then
wehavestring2:
            inpcsvDec$ = Left$(s$, 1): MyInput = True
        End If
        
        End If
        inpcsvuseescape = False
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then inpcsvuseescape = CBool(p): MyInput = True
         If FastSymbol(rest$, ",") Then MyInput = False: If IsExp(bstack, rest$, p) Then inpcleanstrings = CBool(p): MyInput = True
    Else
        MissStringExpr
    End If
    Exit Function
End If
Fkey = 0
If inpcsvsep$ = vbNullString Then inpcsvsep$ = ","
If inpcsvDec$ = vbNullString Then inpcsvDec$ = "."

MyInput = True
With players(GetCode(bstack.Owner))
If IsLabelSymbolNew(rest$, "текос", "END", Lang) Then
    
    If Not NOEDIT Then
    
    NOEDIT = True
    Else
    If QRY Then QRY = False  ''INK$ = Chr$(13) '
    If GFQRY Then GFQRY = False
    End If
    Exit Function
End If
prive = GetCode(bstack.Owner)
If Not releasemouse Then If Not Form1.Visible Then newshow Basestack1
MyInput = False '*************
rest$ = NLtrim$(rest$)

If FastSymbol(rest$, "!") Then
        x1 = 0
        frm$ = vbNullString
        If bstack.toprinter = True Then oxiforPrinter:   Exit Function
        If prive > 32 Then
            If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
            If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
            If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
        End If
        
        f = Abs(IsLabel(bstack, rest$, what$))
        Select Case f
        Case 1, 4
                If f = 1 Then
                    If GetVar(bstack, what$, I) Then
                        If Not MyIsNumeric(var(I)) Then
                            GoTo jumpthere2
                        End If
                    End If
                End If
                     If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                     If Not IsExp(bstack, rest$, p) Then p = .mX
                     X = p
                     
                             Y = 0
                    If FastSymbol(rest$, ",") Then
                     If Not IsExp(bstack, rest$, p) Then x1 = 29
                     x1 = p
                     If x1 < 1 Or x1 > 29 Then x1 = 29
                     Else
                     x1 = 29
                    End If
                    
                     Form1.ShadowMarks = True
                    
                    If Y < 1 And x1 = 0 Then Y = 1
                     If GetVar(bstack, what$, I) Then
                     If VarType(var(I)) = 20 Then
                        s$ = CStr(var(I))
                     ElseIf VarType(var(I)) = vbString Then
                        s$ = LTrim$(var(I))
                     Else
                        s$ = LTrim$(str(var(I)))
                     End If
                     If VarType(var(I)) = vbLong Or VarType(var(I)) = vbInteger Or VarType(var(I)) = 20 Then f = 4
                     If VarType(var(I)) = vbBoolean Then f = 4: x1 = 1: s$ = LTrim$(str(Abs(CLng(var(I)))))
                       If Not NoUseDec Then
                                If OverideDec Then
                                    s$ = Replace(s$, ".", NowDec$)
                                 End If
                            Else
                                s$ = Replace(s$, ".", QueryDecString)
                            End If
       
                     p = var(I)
                     Do
                     s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 4)
                     Loop Until ValidNum(s$, True, f = 4, VarType(p))
                            If Not NoUseDec Then
                                If OverideDec Then
                                   s$ = Replace(s$, NowDec$, ".")
                                 End If
                            Else
                                s$ = Replace(s$, QueryDecString, ".")
                            End If
                            
                              ValidNumberOnly s$, p, f = 4
                             Select Case VarType(var(I))
                             Case 20
                                var(I) = cInt64(p)
                             Case vbInteger
                                var(I) = CInt(p)
                             Case vbLong
                                var(I) = CLng(p)
                             Case vbSingle
                                var(I) = CSng(p)
                             Case vbCurrency
                                var(I) = CCur(p)
                             Case vbDouble
                                var(I) = CDbl(p)
                             Case vbDecimal
                                var(I) = CDec(p)
                             Case vbBoolean
                                var(I) = CBool(p)
                             Case Else
                                var(I) = p
                             End Select
                             
                     Else
                     If I = -1 Then
                     If f = 4 Then
                      s$ = LTrim$(str(ReadVarInt(bstack, what$)))
                     Else
                     
                      s$ = LTrim$(str(ReadVarDouble(bstack, what$)))
                      End If
                      p = ReadVarDouble(bstack, what$)
                      If VarType(p) = vbLong Or VarType(p) = vbInteger Then f = 4
                                       If Not NoUseDec Then
                                If OverideDec Then
                                    s$ = Replace(s$, ".", NowDec$)
                                 End If
                            Else
                                s$ = Replace(s$, ".", QueryDecString)
                            End If
                      Do
                     s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 4)
                     Loop Until ValidNum(s$, True, f = 4)
                           If Not NoUseDec Then
                                If OverideDec Then
                                   s$ = Replace(s$, NowDec$, ".")
                                 End If
                            Else
                                s$ = Replace(s$, QueryDecString, ".")
                            End If
                            If VarType(p) = vbLong Or VarType(p) = vbInteger Then
                            ValidNumberOnly s$, p, f = 4
                            On Error Resume Next
                            p = CLng(p)
                            If Err.Number = 6 Then
                                    OverflowValue
                                    MyInput = False
                               End If
                            Else
                              ValidNumberOnly s$, p, f = 4
                              End If
                             bstack.SetVar what$, p
                             
                     Else
                     s$ = vbNullString
                      Do
                     s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 4)
                     Loop Until ValidNum(s$, True, f = 4)
                           If Not NoUseDec Then
                                If OverideDec Then
                                   s$ = Replace(s$, NowDec$, ".")
                                 End If
                            Else
                                s$ = Replace(s$, QueryDecString, ".")
                            End If
                              ValidNumberOnly s$, p, f = 4
                             globalvar what$, (p)
                     End If
                     End If
                     MyInput = True
                     Form1.ShadowMarks = False
        Case 3
jumpthere2:
                     If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                     If Not IsExp(bstack, rest$, p) Then p = .mX
                     X = p
                     If Not FastSymbol(rest$, ",") Then
                             Y = 0
                             x1 = 50
                             If IsLabelSymbolNew(rest$, "лгйос", "LEN", Lang) Then
                                     If FastSymbol(rest$, "=") Then
                                             If IsExp(bstack, rest$, p) Then
                                                     x1 = Abs(MyRound(p))
                                             Else
                                                     MissNumExpr
                                                     Exit Function
                                             End If
                                     Else
                                             MissSymbol "="
                                             Exit Function
                                     End If
                             End If
                             p = -1&
                     ElseIf Not IsExp(bstack, rest$, Y) Then
                             MissPar
                             Exit Function
                     Else
                            p = -1&
                            If FastSymbol(rest$, ",") Then
                                If FastSymbol(rest$, ",") Then
comehere:
                                    If Not IsExp(bstack, rest$, p, flatobject:=True, nostring:=True) Then MissPar: Exit Function
                                    p = MyRound(p)
                                Else
                                    If Not IsStrExp(bstack, rest$, frm$) Then MissPar: Exit Function
                                    If FastSymbol(rest$, ",") Then GoTo comehere
                                End If
                            Else
                                If Len(var(I)) > 0 Then x1 = -Len(var(I))
                            End If
                           
                     End If
                     Form1.ShadowMarks = True
                     Form1.TEXT1.TabWidth = ReportTabWidth
                     Form1.TabControl = ReportTabWidth
                     If Y < 1 And x1 = 0 Then Y = 1
                     If GetVar(bstack, what$, I) Then
                             var(I) = iText(bstack, var(I), (X), (Y), frm$, x1, , , p)
                     Else
                     If I = -1 Then

                     bstack.SetVar what$, iText(bstack, ReadVarStr(bstack, what$), (X), (Y), frm$, x1, , , p)
                     Else
                             globalvar what$, iText(bstack, "", (X), (Y), frm$, x1, , , p)
                     End If
                     End If
                     MyInput = True
                     Form1.ShadowMarks = False
        Case 5, 7 ' NUMBER IN ARRAY
        
                    If neoGetArray(bstack, what$, pppp) Then
                            If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Exit Function
                    Else
                        MyEr "No such Array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                            Exit Function
                    End If
                    If pppp.IsStringItem(it) Then
                    GoTo jumpthere3
                    End If
                    If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                    If Not IsExp(bstack, rest$, p) Then p = .mX
                    X = p
                     Y = 0
                     
                    If FastSymbol(rest$, ",") Then
                     If Not IsExp(bstack, rest$, p) Then x1 = 29
                     x1 = p
                     If x1 < 1 Or x1 > 29 Then x1 = 29
                     Else
                     x1 = 29
                    End If
                Form1.ShadowMarks = True
                If Y < 1 And x1 = 0 Then Y = 1
                    s$ = LTrim$(str(pppp.itemnumeric(it)))
                    p = pppp.itemnumeric(it)
                    If VarType(p) = vbLong Or VarType(p) = vbInteger Then f = 7
                    If VarType(var(I)) = vbBoolean Then f = 7: x1 = 1: s$ = LTrim$(str(Abs(CLng(pppp.itemnumeric(it)))))
                    Do
                        s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 7)
                    Loop Until ValidNum(s$, True, f = 7, VarType(p))
                        If Not NoUseDec Then
                            If OverideDec Then
                                s$ = Replace(s$, NowDec$, ".")
                            End If
                        Else
                            s$ = Replace(s$, QueryDecString, ".")
                        End If
                        ValidNumberOnly s$, p, f = 7
                        Select Case VarType(pppp.item(it))
                        Case 0
                            pppp.item(it) = cInt64(p)
                        Case vbInteger
                            pppp.item(it) = CInt(p)
                        Case vbLong
                            pppp.item(it) = CLng(p)
                        Case vbSingle
                            pppp.item(it) = CSng(p)
                        Case vbCurrency
                            pppp.item(it) = CCur(p)
                        Case vbDouble
                            pppp.item(it) = CDbl(p)
                        Case vbDecimal
                            pppp.item(it) = CDec(p)
                        Case vbBoolean
                            pppp.item(it) = CBool(p)
                        Case Else
                            pppp.item(it) = p
                        End Select
           
                        Form1.ShadowMarks = False
                        MyInput = True
                Case 6
                    If neoGetArray(bstack, what$, pppp) Then
                        If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then
                            Exit Function
                        End If
                    Else
                        MyEr "No such Array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                        Exit Function
                    End If
jumpthere3:
                    If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                    If Not IsExp(bstack, rest$, p) Then p = .mX
                    X = p
                    If Not FastSymbol(rest$, ",") Then
                        Y = 0
                        x1 = 50
                        If IsLabelSymbolNew(rest$, "лгйос", "LEN", Lang) Then
                                If FastSymbol(rest$, "=") Then
                                        If IsExp(bstack, rest$, p) Then
                                            x1 = Abs(MyRound(p))
                                        Else
                                            MissNumExpr
                                            Exit Function
                                        End If
                                Else
                                        MissSymbol "="
                                        Exit Function
                                End If
                        ElseIf Not IsExp(bstack, rest$, Y) Then
                                MissPar
                                Exit Function
                        Else
                                If FastSymbol(rest$, ",") Then
                                        If Not IsStrExp(bstack, rest$, frm$) Then MissPar: Exit Function
                                        Else
                            If Len(CStr(pppp.item(it))) > 0 Then x1 = -Len(CStr(pppp.item(it)))
                        
                                End If
                        End If
                End If
                Form1.ShadowMarks = True
                ' look here to change it with values from Edit !
                    Form1.TEXT1.TabWidth = ReportTabWidth
                     Form1.TabControl = ReportTabWidth
                If Y < 1 And x1 = 0 Then Y = 1
                If VarType(pppp.item(it)) = vbString Then
                    s$ = iText(bstack, LTrim$(pppp.item(it)), (X), (Y), frm$, x1)
                Else
                    s$ = iText(bstack, LTrim$(str(pppp.item(it))), (X), (Y), frm$, x1)
                End If
                Form1.ShadowMarks = False
                If pppp.ItemType(it) = doc Then
                        Set pppp.item(it) = New Document
                        If s$ <> "" Then pppp.item(it).textDoc = s$
                Else
                        pppp.item(it) = s$
                End If
                MyInput = True
        End Select
        Exit Function
                    '********************************************
ElseIf FastSymbol(rest$, "#") Then
    If Not IsExp(bstack, rest$, p) Then MissPar: Exit Function
    If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
    f = CLng(p)
    If Fkind(f) = FnoUse Or Fkind(f) = Foutput Or Fkind(f) = Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": MyInput = False: Exit Function
    par = True
Else
    If bstack.toprinter = True Then oxiforPrinter:   Exit Function
    If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
    End If
        If ISSTRINGA(rest$, frm$) Then
            If Not Fast2Symbol(rest$, ",", 1, ";", 1) Then MissPar: Exit Function
        Else
            frm$ = "?"
        End If
        par = False
    End If
    W$ = vbNullString
    Fkey = -1
    If bstack.toprinter = True And Not par Then
        oxiforPrinter
        Fkey = 0
        Exit Function
    End If
    If (Left$(Typename(bstack.Owner), 3) = "Gui") And Not par Then oxiforforms: Fkey = 0: Exit Function
    If (TypeOf bstack.Owner Is MetaDc) And Not par Then oxiforMetaFiles: Exit Function
    MyInput = False
    Do
        Select Case Abs(IsLabel(bstack, rest$, what$))
        Case 1
            If GetVar(bstack, what$, I) Then
            If Not MyIsNumeric(var(I)) Then
            GoTo jumpthere
            End If
            End If
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = 0#
            If p <> 0 Then p = p - p
            If par Then
                If uni(f) Then
                        getUniRealComma f, s$
                Else
                        getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                    W$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!@#$|\{}[]'~`%^&()=_:;", True)
                    If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False: Fkey = 0: Exit Function
                End If
                If GetVar(bstack, what$, I) Then
                    If MyIsObject(var(I)) Then
                        If VarTypeName(var(I)) = mGroup Then
                            If var(I).HasSet Then
                                Set mystack = bstack.soros
                                Select Case VarType(p)
                                Case vbLong
                                    s$ = s$ + "&"
                                Case vbCurrency
                                    s$ = s$ + "#"
                                Case vbDecimal
                                    s$ = s$ + "@"
                                Case vbSingle
                                    s$ = s$ + "~"
                                Case vbInteger
                                    s$ = s$ + "%"
                                Case 20
                                    s$ = s$ + "&&"
                                End Select
                                If par Then
                                    If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                                Else
                                    If Not IsNumberCheck(s$, pp) Then pp = p
                                End If
                                bstack.soros.PushVal pp
                                Set bstack.lastobj = Nothing
                                NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + ":=()", MyInput
                                Set bstack.Sorosref = mystack
                                Set mystack = Nothing
                            Else
                                BadGroupHandle
                                MyInput = False
                                Fkey = 0: Exit Function
                                End If
                        ElseIf VarTypeName(var(I)) = "Constant" Then
                                CantAssignValue
                        End If
                    Else
                        
                        Select Case VarType(var(I))
                                Case vbLong
                                    s$ = s$ + "&"
                                Case vbCurrency
                                    s$ = s$ + "#"
                                Case vbDecimal
                                    s$ = s$ + "@"
                                Case vbSingle
                                    s$ = s$ + "~"
                                Case vbInteger
                                    s$ = s$ + "%"
                                Case 20
                                    s$ = s$ + "&&"
                                End Select
                        If par Then
                            If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                        Else
                            If Not IsNumberCheck(s$, pp) Then pp = p
                        End If
                        If VarTypeName(var(I)) = "Boolean" Then
                            var(I) = pp <> 0
                        Else
                            var(I) = pp
                        End If
                    End If
                Else
                    If I = -1 Then
                        bstack.ReadVar what$, pp
                        Select Case VarTypeName(pp)
                        Case "Long"
                            s$ = s$ + "&"
                        Case "Currency"
                            s$ = s$ + "#"
                        Case "Decimal"
                            s$ = s$ + "@"
                        Case "Single"
                            s$ = s$ + "~"
                        Case "Integer"
                            s$ = s$ + "%"
                        Case 20
                            s$ = s$ + "&&"
                        End Select
                        If IsNumberCheck(s$, p) Then bstack.SetVar what$, pp
                    Else
                        Select Case VarType(pp)
                                Case vbLong
                                    s$ = s$ + "&"
                                Case vbCurrency
                                    s$ = s$ + "#"
                                Case vbDecimal
                                    s$ = s$ + "@"
                                Case vbSingle
                                    s$ = s$ + "~"
                                Case vbInteger
                                    s$ = s$ + "%"
                                Case 20
                                    s$ = s$ + "&&"
                                End Select
                        If par Then
                            If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                        Else
                            If Not IsNumberCheck(s$, pp) Then pp = p
                        End If
                        globalvar what$, pp
                    End If
                End If
                MyInput = True
        Case 3
jumpthere:
            If par Then
                If uni(f) Then
                    getUniStringComma f, s$, inpcleanstrings
                Else
                    getAnsiStringComma f, s$, inpcleanstrings
                End If
                If inpcsvuseescape Then s$ = EscapeStrToString(s$)
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                    QUERY bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), IIf(lookOne(rest$, ","), ",", Chr$(0)) + Chr$(34) + "{}"
            End If
            If GetVar(bstack, what$, I) Then
                If MyIsObject(var(I)) Then
                    If Typename(var(I)) = mGroup Then
                        If var(I).HasSet Then
                            Set mystack = bstack.soros
                            If bstack.lastobj Is Nothing Then
                                bstack.soros.PushStr s$
                            Else
                                If TypeOf bstack.lastobj Is Group Then
                                    bstack.lastobj.ToDelete = False
                                End If
                                bstack.soros.PushObj bstack.lastobj
                                Set bstack.lastobj = Nothing
                            End If
                            If Right$(what$, 1) <> "$" Then
                                NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + ":=()", MyInput
                            Else
                                NeoCall2 bstack, Left$(what$, Len(what$) - 1) + "." + ChrW(&H1FFF) + ":=()", MyInput
                            End If
                            Set bstack.Sorosref = mystack
                            Set mystack = Nothing
                        Else
                            BadGroupHandle
                            MyInput = False
                            Fkey = 0: Exit Function
                        End If
                    ElseIf Typename(var(I)) = "Constant" Then
                        CantAssignValue
                    End If
                Else
                    CheckVar var(I), s$
                End If
            Else
                If I = -1 Then
                    bstack.SetVar what$, s$
                Else
                    globalvar what$, s$
                End If
            End If
            MyInput = True
        Case 4
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = 0#
            If p <> 0 Then p = p - p
            If par Then
                If uni(f) Then
                    getUniRealComma f, s$
                Else
                    getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                W$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!.@#$|\{}[]'~`%^&()=_:;", True)
                If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False:    Fkey = 0: Exit Function
            End If
            If GetVar(bstack, what$, I) Then
                Select Case VarType(var(I))
                Case vbLong
                    s$ = s$ + "&"
                Case vbCurrency
                    s$ = s$ + "#"
                Case vbDecimal
                    s$ = s$ + "@"
                Case vbSingle
                    s$ = s$ + "~"
                Case vbInteger
                    s$ = s$ + "%"
                Case 20
                    s$ = s$ + "&&"
                End Select
                If par Then
                    If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                Else
                    If Not IsNumberCheck(s$, pp) Then pp = p
                End If
                var(I) = MyRound(pp)
            Else
                If I = -1 Then
                    bstack.ReadVar what$, pp
                    Select Case VarType(pp)
                    Case vbLong
                        s$ = s$ + "&"
                    Case vbCurrency
                        s$ = s$ + "#"
                    Case vbDecimal
                        s$ = s$ + "@"
                    Case vbSingle
                        s$ = s$ + "~"
                    Case vbInteger
                        s$ = s$ + "%"
                    Case 20
                        s$ = s$ + "&&"
                    End Select
                If IsNumberCheck(s$, p) Then bstack.SetVar what$, pp
                    bstack.SetVar what$, MyRound(pp)
                Else
                    Select Case VarType(p)
                    Case vbLong
                        s$ = s$ + "&"
                    Case vbCurrency
                        s$ = s$ + "#"
                    Case vbDecimal
                        s$ = s$ + "@"
                    Case vbSingle
                        s$ = s$ + "~"
                    Case vbInteger
                        s$ = s$ + "%"
                    Case 20
                        s$ = s$ + "&&"
                    End Select
                    If par Then
                        If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                    Else
                        If Not IsNumberCheck(s$, pp) Then pp = p
                    End If
                    If VarTypeName(p) <> VarTypeName(pp) Then
                        OverflowValue VarType(p)
                    Else
                        globalvar what$, MyRound(pp)
                    End If
                End If
            End If
            MyInput = True
        Case 5
            If neoGetArray(bstack, what$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Fkey = 0: Exit Function
            Else
                MyEr "No such array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                Fkey = 0:  Exit Function
            End If
            If pppp.IsStringItem(it) Then
                GoTo jumpthere4
            End If
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = 0#
            MyInput = True
            If par Then
                If uni(f) Then
                    getUniRealComma f, s$
                Else
                    getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                W$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!@#$|\{}[]'~`%^&()=_:;", True)
                If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False: Fkey = 0: Exit Function
            End If
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = pppp.item(it)
            p = p - p
                    Select Case VarType(p)
                    Case vbLong
                        s$ = s$ + "&"
                    Case vbCurrency
                        s$ = s$ + "#"
                    Case vbDecimal
                        s$ = s$ + "@"
                    Case vbSingle
                        s$ = s$ + "~"
                    Case vbInteger
                        s$ = s$ + "%"
                    Case 20
                        s$ = s$ + "&&"
                    End Select
            If par Then
                If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
            Else
                If Not IsNumberCheck(s$, pp) Then pp = p
            End If
            pppp.item(it) = pp
            MyInput = True
        Case 6
            If neoGetArray(bstack, what$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Fkey = 0: Exit Function
            Else
                MyEr "No such array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                Fkey = 0: Exit Function
            End If
jumpthere4:
            MyInput = True
            If par Then
                If uni(f) Then
                    getUniStringComma f, s$, inpcleanstrings
                Else
                    getAnsiStringComma f, s$, inpcleanstrings
                End If
                If inpcsvuseescape Then s$ = EscapeStrToString(s$)
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                    QUERY bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), IIf(lookOne(rest$, ","), ",", Chr$(0)) + Chr$(34) + "{}"
            End If
            If MyIsObject(pppp.item(it)) Then
                If pppp.ItemType(it) = mGroup Then
                    If pppp.item(it).HasSet Then
                        what = Left$(what$, Len(what$) - 2)
                        Set mystack = bstack.soros
                        PushParamGeneral bstack, rest$
                        If Not FastSymbol(rest$, ")", True) Then
                            Set bstack.Sorosref = mystack
                            MyInput = False: Exit Function
                        End If
                        bstack.soros.DataStr s$
                        NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + ":=()", MyInput
                        Set bstack.Sorosref = mystack
                        Set mystack = Nothing
                Else
                    GroupCantSetValue
                End If
            ElseIf pppp.ItemType(it) = doc Then
                Set pppp.item(it) = New Document
                    If s$ <> "" Then pppp.item(it).textDoc = s$
                End If
            Else
                pppp.item(it) = s$
            End If
            MyInput = True
        Case 7
            If neoGetArray(bstack, what$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Fkey = 0: Exit Function
            Else
                MyEr "No such array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                Exit Function
            End If
            If par Then
                If uni(f) Then
                    getUniRealComma f, s$
                Else
                    getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                W$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!@#$|\{}[.]'~`%^&()=_:;", True)
                If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False: Fkey = 0: Exit Function
            End If
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = pppp.item(it)
            p = p - p
                    Select Case VarType(p)
                    Case vbLong
                        s$ = s$ + "&"
                    Case vbCurrency
                        s$ = s$ + "#"
                    Case vbDecimal
                        s$ = s$ + "@"
                    Case vbSingle
                        s$ = s$ + "~"
                    Case vbInteger
                        s$ = s$ + "%"
                    Case 20
                        s$ = s$ + "&&"
                    End Select
            If par Then
                If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
            Else
                If Not IsNumberCheck(s$, pp) Then pp = p
            End If
            pppp.item(it) = MyRound(pp)
            MyInput = True
        End Select
        If FastSymbol(rest$, ",") Then
            W$ = vbNullString
            If Not par Then frm$ = " "
        ElseIf FastSymbol(rest$, ";") Then
            If Not par Then
                W$ = ";"
                frm$ = " "
            End If
        Else
            If Not par Then If Not W$ = ";" Then crNew bstack, players(prive)
            W$ = vbNullString
            Fkey = 0: Exit Function
        End If
    Loop
    Fkey = 0
    Exit Function
End With

End Function
Function MyCopy(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, Scr As Object, photo As cDIBSection, s$, it As Long, what$
MyCopy = True
Dim x1 As Long, y1 As Long, x2 As Long, y2 As Long, pppp As mArray, y22 As Single

If IsExp(bstack, rest$, p, , True) Then
    If MemInt(VarPtr(p)) = vbString Then
        SwapString2Variant s$, p
        p = Empty
        GoTo wehavestring
    Else
        x1 = p
        GoTo wehavenumber
    End If
ElseIf IsStrExp(bstack, rest$, s$, False) Then
wehavestring:
    If Left$(s$, 4) = "cDIB" And Len(s$) > 12 Then
        Set photo = New cDIBSection
        If cDib(s$, photo) Then
            If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
                If IsStrExp(bstack, rest$, s$) Then
                   photo.SaveDib s$
                   Set photo = Nothing
               End If
            End If
            Exit Function
        Else
            noImage s$
            Exit Function
        End If
    Else
        If ExtractType(s$) = vbNullString Then s$ = s$ + ".bmp"
        FixPath s$
        If Not CanKillFile(s$) Then FilePathNotForUser:  Exit Function
        On Error Resume Next
        Set photo = New cDIBSection
        photo.CopyPicture bstack.Owner
        photo.SaveDib s$
        Set photo = Nothing
        Exit Function
    End If
Else
wehavenumber:
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p
    If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
        Select Case Abs(IsLabel(bstack, rest$, s$))
        Case 3, 1
            If GetVar(bstack, s$, it) Then
                Set photo = New cDIBSection
                Set Scr = bstack.Owner
                With players(GetCode(Scr))
                    x1 = Scr.ScaleX(x1 + .XGRAPH, 1, 3) - Scr.ScaleX(.XGRAPH, 1, 3)
                    y1 = Scr.ScaleX(y1 + .YGRAPH, 1, 3) - Scr.ScaleX(.YGRAPH, 1, 3)
                    If photo.create(CLng(x1), CLng(y1)) Then
                        photo.LoadPictureBlt Scr.Hdc, CLng(Scr.ScaleX(.XGRAPH, 1, 3)), CLng(Scr.ScaleX(.YGRAPH, 1, 3))
                        If photo.bitsPerPixel <> 24 Then Conv24 photo
                        var(it) = DIBtoSTR(photo)
                    End If
                End With
                Set photo = Nothing
                Set Scr = Nothing
                Exit Function
            Else
                what$ = s$
                MyCopy = False
                Exit Function
            End If
        Case 6, 5
            Dim W6 As Long
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, W6, rest$) Then Exit Function
                Set photo = New cDIBSection
                Set Scr = bstack.Owner
                With players(GetCode(Scr))
                    x1 = Scr.ScaleX(x1 + .XGRAPH, 1, 3) - Scr.ScaleX(.XGRAPH, 1, 3)
                    y1 = Scr.ScaleX(y1 + .YGRAPH, 1, 3) - Scr.ScaleX(.YGRAPH, 1, 3)
                    If photo.create(CLng(x1), CLng(y1)) Then
                        photo.LoadPictureBlt Scr.Hdc, CLng(Scr.ScaleX(.XGRAPH, 1, 3)), CLng(Scr.ScaleX(.YGRAPH, 1, 3))
                        If photo.bitsPerPixel <> 24 Then Conv24 photo
                        If MyIsObject(pppp.item(W6)) Then
WrongItemType:
                            MyEr "can't copy image to " + pppp.ItemType(W6), "ДЕМ ЛПОЯЧ МА АМТИЦЯэЬЫ ЕИЙЭМА СЕ " + pppp.ItemType(W6)
                            MyCopy = False
                        Else
                            On Error Resume Next
                            pppp.item(W6) = DIBtoSTR(photo)
                            If Err Then
                            Err.Clear
                            GoTo WrongItemType
                            End If
                        End If
                    End If
                End With
                Set photo = Nothing
                Set Scr = Nothing
                Exit Function
            Else
                what$ = s$
                MyCopy = False
                Exit Function
            End If
        End Select
    ElseIf IsLabelSymbolNew(rest$, "ле", "USE", Lang) Then
    
        If IsExp(bstack, rest$, p, , True) Then
            If MemInt(VarPtr(p)) = vbString Then
                SwapString2Variant s$, p
                p = Empty
                GoTo wehavestring2
            Else
                MissStringExpr
            End If
        ElseIf IsStrExp(bstack, rest$, s$, False) Then
wehavestring2:
            Set photo = New cDIBSection
            If cDib(s$, photo) Then
                y22 = 0!
                Set Scr = bstack.Owner
                If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y22 = p
                If y2 = 0 Then y2 = 100
                If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y2 = p Else y2 = 100
                If Not (y22 = 0 And y2 = 100) Then
                    RotateDib1 bstack, photo, y22, y2, Scr.BackColor
                End If
                photo.PaintPicture Scr.Hdc, CLng(Scr.ScaleX(x1, 1, 3)), CLng(Scr.ScaleX(y1, 1, 3))
            End If
            Set photo = Nothing
            Set Scr = Nothing
        Else
            MyCopy = False: Exit Function
        End If
    ElseIf IsLabelSymbolNew(rest$, "епамы", "TOP", Lang) Then
        If IsExp(bstack, rest$, p, , True) Then
            If MemInt(VarPtr(p)) = vbString Then
                SwapString2Variant s$, p
                p = Empty
                GoTo wehavestring3
            Else
                MissStringExpr
            End If
        ElseIf IsStrExp(bstack, rest$, s$, False) Then
wehavestring3:
            Set photo = New cDIBSection
            Set Scr = bstack.Owner
            If cDib(s$, photo) Then
                y22 = 0!
                If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y22 = p
                If y2 = 0 Then y2 = 100
                If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y2 = p Else y2 = 100
                If Not (y22 = 0 And y2 = 100) Then
                    RotateDib1 bstack, photo, y22, y2, , CLng(x1), CLng(y1)
                End If
                photo.PaintPicture Scr.Hdc, MyRound((Scr.ScaleX(x1, 1, 3)), 0), MyRound((Scr.ScaleX(y1, 1, 3)), 0) '', photo.Width * y2 \ 100, photo.Height * y2 \ 100
            End If
            Set photo = Nothing
            Set Scr = Nothing
        Else
            MyCopy = False: MissNumExpr: Exit Function
        End If
    Else
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then x2 = p
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y2 = p Else MyCopy = False: MissNumExpr: Exit Function
        If x2 = 0 Or y2 = 0 Then MyCopy = False: MissNumExpr: Exit Function
        ICOPY bstack.Owner, x1, y1, x2, CLng(y2)
    End If
End If
MyDoEvents1 bstack.Owner
End Function
Function MyFunction(entrypoint As Long, bstack As basetask, rest$, Lang As Long, Optional noskipcommand = False, Optional MakeNew As Boolean, Optional addlen As Long = 0, Optional ByPass As Boolean) As Boolean
Dim y1 As Long, par As Boolean, what$, s$, ss$, pa$, x1 As Long, I As Long, frm$
Dim ohere$, ox As Long
ohere$ = here$
MyFunction = True
If entrypoint = 1 Then
    par = True
    y1 = True
ElseIf entrypoint = 2 Then
    ' operators
    par = IsLabelSymbolNew(rest$, "меа", "NEW", Lang)
    I = InStr(rest$, " ")
    If I = 1 Then
        I = InStr(2, rest$, " ")
        what$ = Mid$(rest$, 2, I - 2) ' + "()"
    Else
        what$ = Left$(rest$, I - 1) ' + "()"
    End If
    rest$ = Mid$(rest$, I + 1)
    GoTo operators
ElseIf entrypoint = -1 Then
    par = Len(ohere$) = 0
    GoTo alocal
Else
    y1 = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", Lang)
    par = IsLabelSymbolNew(rest$, "меа", "NEW", Lang)
End If
If y1 <> 0 Then
            ' FUNCTION GLOBAL "ALFA[212].other" {definition} so we can place [ ] in a definition..
            ' FOR INTERNAL USE..
    If lookOne(rest$, Chr(34)) Then
        ISSTRINGA rest$, what$
            x1 = 1
        If Right$(what$, 1) = "$" Then
            x1 = 3
        ElseIf Right$(what$, 1) = "%" Then
            x1 = 4
        End If
        what$ = what$ + "()"
        If FastSymbolNoTrimAfter(rest$, "{") Then
            ss$ = block(rest$)
            If Len(ss$) = 0 Then
                ss$ = blockString(rest$, Asc("}"))
            End If
            I = Len(rest$) + addlen
            If Not FastSymbol(rest$, "}") Then
                MyFunction = False
            Else
                If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                    If InStr(here$, ChrW(&H1FFF)) > 0 Then
                        s$ = vbNullString
                    Else
                        pa$ = sbf(Abs(bstack.OriginalCode)).sb
                        If Not Left$(ss$, 10) = "'11001EDIT" Then
                            s$ = GetNextLine(pa$) + "-" + CStr(I - 2) + vbCrLf
                        End If
                    End If
                ElseIf Not bstack.LoadOnly Then
                    If Left$(ss$, 10) <> "'11001EDIT" Then
                        s$ = "'11001EDIT " + GetModuleName(bstack, ohere$) + "," + str(-(I + addlen - 2)) + vbCrLf
                    End If
                End If
                bstack.IndexSub = ModuleSub(what$, s$ + ss$)
            End If
            Exit Function
        Else
            GoTo missdef
        End If
    End If
End If
alocal:
x1 = Abs(IsLabelF(rest$, what$))
        
If x1 = 1 Or x1 = 3 Or x1 = 4 Then   ' C() C%() C$()
operators:
    If Not noskipcommand Then
        If x1 = 1 Then
            If funid.Find(what$ + "(", I, bstack.numfunnum) Then
                    If I > 0 Then funid.ItemCreator what$ + "(", -Abs(I)
                End If
            ElseIf x1 = 3 Then
                If strfunid.Find(what$ + "(", I, bstack.strfunnum) Then
                    If I > 0 Then strfunid.ItemCreator what$ + "(", -Abs(I)
                End If
            End If
        End If
        what$ = what$ + "()"
        MakeThisSub bstack, what$
        If y1 Then  ' We have a global function
            If Not GetGlobalSubAfterHere(bstack, what$, x1) Then
                If FastSymbol(rest$, "(") Then
                    frm$ = BlockParam(rest$)
                    If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                    If Not FastSymbol(rest$, ")", True) Then
                        MyFunction = False
                        Exit Function
                    End If
                    frm$ = Trim$(frm$)
                End If
            If FastSymbolNoTrimAfter(rest$, "{") Then
                ss$ = block(rest$)
                If Len(ss$) = 0 Then
                    ss$ = blockString(rest$, Asc("}"))
                End If
                y1 = Len(rest$) + addlen
                If Not FastSymbol(rest$, "}") Then
                    MyFunction = False
                Else
                    If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                            s$ = vbNullString
                        Else
                            pa$ = sbf(Abs(bstack.OriginalCode)).sb
                            If Not Left$(ss$, 10) = "'11001EDIT" Then
                                s$ = GetNextLine(pa$) + "-" + CStr(y1 - 2 + addlen) + vbCrLf
                            End If
                        End If
                    ElseIf bstack.OriginalCode > 0 And Not bstack.LoadOnly And here$ <> "" Then
                        If Left$(ss$, 10) <> "'11001EDIT" Then
                            s$ = "'11001EDIT " + GetModuleName(bstack, ohere$) + "," + str(-(y1 - 2 + addlen)) + vbCrLf
                        End If
                    End If
                    If frm$ <> "" Then
                        If Lang = 1 Then
                            s$ = s$ + "Read " + frm$ + vbCrLf
                        Else
                            s$ = s$ + "дИэБАСЕ " + frm$ + vbCrLf
                        End If
                    End If
                    If I < 0 And Len(here$) <> 0 Then
                        bstack.IndexSub = ModuleSub(here$ + "." + what$, s$ + ss$)
                    Else
                        bstack.IndexSub = ModuleSub(what$, s$ + ss$)
                    End If
                End If
            Else
missdef:
                MyEr what$ + " missing definition", what$ + " КЕъПЕИ О ОЯИСЛЭР"
            End If
        Else
            If FastSymbol(rest$, "(") Then
                frm$ = BlockParam(rest$)
                If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                If Not FastSymbol(rest$, ")", True) Then
                    MyFunction = False
                    Exit Function
                End If
                frm$ = Trim$(frm$)
            End If
            If FastSymbolNoTrimAfter(rest$, "{") Then
                what$ = block(rest$)
                If Len(what$) = 0 Then
                    what$ = blockString(rest$, Asc("}"))
                End If
                If Len(frm$) <> 0 Then
                    If Lang = 1 Then
                        what$ = "Read " + frm$ + vbCrLf + what$
                    Else
                        what$ = "дИэБАСЕ " + frm$ + vbCrLf + what$
                    End If
                    frm$ = vbNullString
                End If
                If Not FastSymbol(rest$, "}") Then
                        MyFunction = False
                Else
                        If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                        sbf(x1).sb = what$: bstack.IndexSub = x1
                        Set sbf(x1).subs = Nothing
                End If
            Else
                MyEr what$ + " missing definition", what$ + " КЕъПЕИ О ОЯИСЛЭР"
            End If
        End If
        Exit Function
  Else
    If par Then
        If entrypoint = 2 Then
            x1 = ModuleSub(what$, "")
        Else
            If Len(here$) = 0 Then
                x1 = ModuleSub(what$, "")
            Else
                x1 = ModuleSub(here$ + "." + bstack.GroupName + what$, "")
            End If
        End If
        GoTo jump1
    ElseIf here$ = vbNullString And subHash.Find(what$, x1) And Not MakeNew Then
          
jump1:
        If x1 >= lckfrm And lckfrm <> 0 Then   ' when we load a scrabled program..we have locked functions/modules
            rest$ = vbNullString
            MyFunction = False: Exit Function
        End If
        If FastSymbol(rest$, "(") Then
            frm$ = BlockParam(rest$)
            If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
            If Not FastSymbol(rest$, ")", True) Then
                MyFunction = False
                Exit Function
            End If
            frm$ = Trim$(frm$)
        Else
            frm$ = vbNullString
        End If
        If FastSymbolNoTrimAfter(rest$, "{") Then
            what$ = block(rest$) + " "
            If Len(what$) = 1 Then
                what$ = blockString(rest$, Asc("}")) + " "
            End If
            If Len(frm$) <> 0 Then
                If Lang = 1 Then
                    what$ = "Read " + frm$ + vbCrLf + what$
                Else
                    what$ = "дИэБАСЕ " + frm$ + vbCrLf + what$
                End If
                frm$ = vbNullString
            End If
            If Not FastSymbol(rest$, "}") Then
                MyFunction = False
            Else
                If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                    sbf(x1).Changed = True
                    sbf(x1).sb = what$: bstack.IndexSub = x1
                    Set sbf(x1).subs = Nothing
                End If
            Else
                MyFunction = False
            End If
            Exit Function
        ElseIf GetlocalSub(bstack.GroupName + what$, x1) And Not MakeNew Then
            If FastSymbol(rest$, "(") Then
                ox = 1
                frm$ = BlockParam(rest$)
                If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                If Not FastSymbol(rest$, ")", True) Then
                    MyFunction = False
                    Exit Function
                End If
                frm$ = Trim$(frm$)
            Else
                frm$ = vbNullString
            End If
            If FastSymbolNoTrimAfter(rest$, "{") Then
                If sbf(x1).locked Or sbf(x1).Extern > 0 Then
                    what$ = block(rest$)
                    If Len(what$) = 0 Then
                        what$ = blockString(rest$, Asc("}"))
                    End If
                    bstack.IndexSub = x1
                    FastSymbol rest$, "}", True
                    Exit Function
                End If
                If Len(frm$) <> 0 Then
                    If Lang = 1 Then
                        rest$ = "Read " + frm$ + vbCrLf + rest$
                    Else
                        rest$ = "дИэБАСЕ " + frm$ + vbCrLf + rest$
                    End If
                    frm$ = vbNullString
                End If
                I = Len(rest$)
                what$ = block(rest$) + " "
                If Len(what$) = 1 Then
                    what$ = blockString(rest$, Asc("}")) + " "
                End If
                While Left$(what$, 10) = "'11001EDIT"
                    SetNextLine what$
                Wend
                If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                what$ = "'11001EDIT " + GetModuleName(bstack, ohere$) + "," + str(-(I - 2 + addlen)) + vbCrLf + what$
                If Not FastSymbol(rest$, "}") Then
                    MyFunction = False
                Else
                    If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                    sbf(x1).Changed = True
                    sbf(x1).sb = what$
                    bstack.IndexSub = x1
                    Set sbf(x1).subs = Nothing
                End If
            Else
                '' or MyFunction=false
                If bstack.IndexSub = x1 Then
                    bstack.IndexSub = 0
                End If
                If ox = 0 Then
                    GoTo missdef
                Else
                    rest$ = vbNullString
                End If
            End If
            Exit Function
        ElseIf FastSymbol(rest$, "(") Then
            frm$ = BlockParam(rest$)
            If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
            If Not FastSymbol(rest$, ")", True) Then
                MyFunction = False
                Exit Function
            End If
            frm$ = Trim$(frm$)
            If FastSymbolNoTrimAfter(rest$, "{") Then GoTo jumpheretoo
            rest$ = ""
        ElseIf FastSymbolNoTrimAfter(rest$, "{") Then
jumpheretoo:
            If here$ = vbNullString Then
                s$ = block(rest$)
                If Len(s$) = 0 Then
                    s$ = blockString(rest$, Asc("}"))
                End If
                If frm$ <> "" Then
                    s = "READ " + frm$ + vbCrLf + s$
                End If
                If Right$(s$, 2) <> vbCrLf Then s$ = s$ + vbCrLf
                bstack.IndexSub = ModuleSub(what$, s$)
            Else
                ss$ = block(rest$)
                If Len(ss$) = 0 Then
                    ss$ = blockString(rest$, Asc("}"))
                End If
                I = Len(rest$)
                If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                    If InStr(here$, ChrW(&H1FFF)) > 0 Then
                        s$ = vbNullString
                    Else
                        pa$ = sbf(Abs(bstack.OriginalCode)).sb
                        If Not Left$(ss$, 10) = "'11001EDIT" Then
                            s$ = GetNextLine(pa$) + "-" + CStr(I + addlen) + vbCrLf
                        End If
                    End If
                ElseIf Not bstack.LoadOnly Then
                    If Left$(ss$, 10) <> "'11001EDIT" Then
                        s$ = "'11001EDIT " + GetModuleName(bstack, ohere$) + "," + str(-(I + addlen + 2 * (Len(bstack.UseGroupname) > 0))) + vbCrLf
                    End If
                End If
                If frm$ <> "" Then
                    If Lang = 1 Then
                        s$ = s$ + vbCrLf + "Read " + frm$ + vbCrLf
                    Else
                        s$ = s$ + vbCrLf + "дИэБАСЕ " + frm$ + vbCrLf
                    End If
                End If
                If Not ByPass Then
                    If Len(here$) = 0 Then
                        bstack.IndexSub = ModuleSub(bstack.GroupName + what$, s$ + ss$)
                    Else
                        bstack.IndexSub = ModuleSub(here$ + "." + bstack.GroupName + what$, s$ + ss$)
                    End If
                End If
            End If
            If Not FastSymbol(rest$, "}") Or ByPass Then MyFunction = False
            If FastSymbol(rest$, ChrW(8189) + ChrW(8189), False, 2) Then
                sbf(bstack.IndexSub).IamAClass = True
                sbf(bstack.IndexSub).locked = True
            End If
            Exit Function
        Else
            MyFunction = False
            If entrypoint = 2 Then
                MyEr "missing definition", "КЕъПЕИ О ОЯИСЛЭР"
                Exit Function
            End If
            GoTo missdef
        End If
    End If
Else
    rest$ = what$ + " " + rest$
    MyFunction = False
End If
End Function


Function ProcView(bstack As basetask, rest$, Lang As Long) As Boolean
If bstack.toprinter Then oxiforPrinter: Exit Function
If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
If TypeOf bstack.Owner Is VB.PictureBox Then
On Error GoTo ttt
If CLng("0" & bstack.Owner.Tag) > 33 Then
oxiforImages: Exit Function
End If
End If
Err.Clear
ttt:
GetNames bstack, rest$, Form1.List1, Lang
mywait bstack, CDbl(100)
If Not FastSymbol(rest$, ";") Then ProcView = MyMenu(2, bstack, rest$, Lang) Else ProcView = True
End Function


Function ProcProto(bstack As basetask, rest$, Lang As Long) As Boolean
ProcProto = True
Dim s$, W$, v As Long, hastype As Boolean
If FastSymbol(rest$, "{") Then
s$ = block(rest$)
If Right$(s$, 1) = " " Then
v = Len(s$) - MyTrimRStr(s$)
If v > 0 Then s$ = Replace$(s$, Chr$(10) + space(v), Chr$(10))
ElseIf Right$(s$, 1) = vbTab Then
v = Len(s$) - MyTrimRNoCr(s$)
If v > 0 Then s$ = Replace$(s$, Chr$(10) + String$(v, vbTab), Chr$(10))

End If
v = 0
Else
MissingCodeBlock
ProcProto = False
Exit Function
End If
If FastSymbol(rest$, "}", True) Then
    If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
        v = FastPureLabel(rest$, W$, , , True)
        If v = 3 Or v = 1 Then
            W$ = myUcase(W$, True)
            If GetVar(bstack, W$, v, True, , , , hastype) Then
                
            GoTo cont1
            ElseIf GetlocalVar(W$, v) Then
            hastype = varhash.vType(varhash.Index)
cont1:
            
            If CheckVarOnlyNo(var(v), s$, hastype) Then
                If VarTypeName(var(v)) = "Constant" Then
                    CantAssignValue
                ElseIf LastErNum = 0 Then
                    NoObjectAssign
                End If
                ProcProto = False
                Exit Function
            End If
            
            Else
            v = globalvar(W$, v, , True)
            var(v) = s$
            End If
            
        Else
        MyEr "No string name (using $)", "дЕМ БЯчЙА ЭМОЛА АКЖАЯИХЛГТИЙОЩ"
        
        End If
    Else
        MyEr "Missing AS", "кЕъПЕИ ТО ыР"
        ProcProto = False
        Exit Function
    End If
    Else
    ProcProto = False
End If
End Function
Function ProcBuffer(bstack As basetask, rest$, Lang As Long, Optional alocal As Boolean) As Boolean
ProcBuffer = True
Dim s$, what$, I As Long, p As Variant, pp As Long, par As Long, what2$, Runnable As Boolean, itisSingle As Boolean, itisCur As Boolean
Dim usehandler As mHandler, useBuffer As MemBlock
If IsLabelSymbolNew(rest$, "йыдийа", "CODE", Lang) Then Runnable = True
If IsLabelSymbolNew(rest$, "йемг", "CLEAR", Lang) Then par = &H8

     Do While Abs(IsLabel(bstack, rest$, what$)) = 1
     If bstack.priveflag Then what$ = ChrW(&HFFBF) + what$
                    If alocal Then
                        GoTo makeitnow
                    ElseIf GetlocalVar(bstack.GroupName + what$, I) Then
                        If Not MyIsObject(var(I)) Then MakeitObjectBuffer var(I)
                    ElseIf GetVar(bstack, bstack.GroupName + what$, I, True) Then
                        If Not MyIsObject(var(I)) Then MakeitObjectBuffer var(I)
                    Else
makeitnow:
                        I = globalvar(bstack.GroupName + what$, Empty)
                        MakeitObjectBuffer var(I)
                    End If
                    If TypeOf var(I) Is mHandler Then
                        Set usehandler = var(I)
                        If TypeOf usehandler.objref Is MemBlock Then GoTo contok
                    
                    End If
                        Expected "Buffer", "дИэЯХЯЫСГ ЛМчЛГР"
                        Exit Function
                    
contok:
                    Set usehandler = var(I)
                    Set useBuffer = usehandler.objref
                    ' GET TYPE OF  BUFFER
                    ' Char (1 byte) String (2 bytes)  Long (4 Bytes)
                    pp = 1
                    If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                        If IsLabelSymbolNew(rest$, "ьгжио", "BYTE", Lang) Then
                            pp = 1
                        ElseIf IsLabelSymbolNew(rest$, "айеяаиос", "INTEGER", Lang) Then
                            pp = 2
                        ElseIf IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang) Then
                            If IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang) Then
                            pp = -8
                            Else
                            pp = 4
                            End If
                        ElseIf IsLabelSymbolNew(rest$, "коцистийос", "CURRENCY", Lang) Then
                            pp = 8
                            itisCur = True
                        ElseIf IsLabelSymbolNew(rest$, "апкос", "SINGLE", Lang) Then
                            itisSingle = True
                            pp = 4
                        ElseIf IsLabelSymbolNew(rest$, "цяалла", "STRING", Lang) Then
                            
                            pp = -4
                        ElseIf IsLabelSymbolNew(rest$, "дипкос", "DOUBLE", Lang) Then
                            pp = 8
                        ElseIf Abs(IsLabel(bstack, rest$, what2$)) = 1 Then
                        If GetVar3(bstack, bstack.GroupName + what2$, I) Then
                        
                        If IsExp(bstack, bstack.GroupName + what2$, p) Then
                                If bstack.lastobj Is Nothing Then GoTo comehere
                                If Not TypeOf bstack.lastobj Is mHandler Then GoTo comehere
                                Set usehandler = bstack.lastobj
                                If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                If usehandler.objref.structLen = 0 Then GoTo comehere
                               pp = usehandler.objref.structLen
                               Set useBuffer.structref = usehandler.objref
                               useBuffer.UseStruct = True
                               Set bstack.lastobj = Nothing
                               Set usehandler = Nothing
                        End If
                        
                        Else
                            If IsExp(bstack, what2$, p) Then
                                If bstack.lastobj Is Nothing Then GoTo comehere
                                If Not TypeOf bstack.lastobj Is mHandler Then GoTo comehere
                                Set usehandler = bstack.lastobj
                                If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                If usehandler.objref.structLen = 0 Then GoTo comehere
                               pp = usehandler.objref.structLen
                               Set useBuffer.structref = usehandler.objref
                               useBuffer.UseStruct = True
                               Set bstack.lastobj = Nothing
                               Set usehandler = Nothing
                        End If
                        End If
                        Else
comehere:
                        SyntaxError
                            ProcBuffer = False
                                Exit Function
                        End If
                    
                    If FastSymbol(rest$, "*") Then
                        If IsExp(bstack, rest$, p) Then
                        ' we get the size here
                        If p <= 0 Then
                            MyEr "No Zero or Negative number for size", "╪ВИ ЛГДщМ ч АЯМГТИЙЭ АЯИХЛЭ ЦИА ЛчЙОР"
                            ProcBuffer = False
                            Exit Function
                        Else
                         '' MAKE IT
                    If useBuffer.ItemSize <> 0 Then
                    If useBuffer.ItemSize = Abs(pp) Then
                    useBuffer.ResizeItems CLng(p), par
                    End If
                    Else
                    useBuffer.ClearError
                        If itisSingle Then
                            useBuffer.Construct pp, CLng(p), par, Runnable, vbSingle
                        ElseIf itisCur Then
                            useBuffer.Construct pp, CLng(p), par, Runnable, vbCurrency
                        ElseIf pp = -8 Then
                            useBuffer.Construct pp, CLng(p), par, Runnable, 20
                        Else
                            useBuffer.Construct pp, CLng(p), par, Runnable
                        End If
                        End If
                        End If
                        Else
                            MissPar
                            ProcBuffer = False
                            Exit Function
                        End If
                        
                    Else
                    If useBuffer.status = 0 Then
                        If itisSingle Then
                            useBuffer.Construct pp, 1, par, Runnable, vbSingle
                        ElseIf itisCur Then
                            useBuffer.Construct pp, 1, par, Runnable, vbCurrency
                        ElseIf pp = -8 Then
                            useBuffer.Construct pp, 1, par, Runnable, 20
                        Else
                            useBuffer.Construct pp, 1, par, Runnable ', useBuffer.ItemSize
                        End If
                        End If
                    End If
                End If
     
     
     If Not FastSymbol(rest$, ",") Then Exit Do
     Loop

End Function
Function ProcInventory(bstack As basetask, rest$, Lang As Long, Optional alocal As Boolean) As Boolean
ProcInventory = True
Dim s$, what$, I As Long, p As Variant, queue As Boolean, serr As Boolean, usehandler As mHandler
    queue = IsLabelSymbolNew(rest$, "оуяа", "QUEUE", Lang)
     Do While Abs(IsLabel(bstack, rest$, what$)) = 1
     serr = False
conthere:
     If bstack.priveflag Then what$ = ChrW(&HFFBF) + what$
     If Not FastSymbol(rest$, "<") Then  ' get local var first
            If alocal Then
            I = globalvar(bstack.GroupName + what$, Empty) ' MAKE ONE
             GoTo makeitnow1
            ElseIf GetlocalVar(bstack.GroupName + what$, I) Then
       
            If Not MyIsObject(var(I)) Then GoTo makeitnow1
            If FastSymbol(rest$, "=") Then
             GoTo there12
             Else
                If MyIsObject(var(I)) Then
                If TypeOf var(I) Is mHandler Then
                Set usehandler = var(I)
                    If usehandler.T1 = 1 Then
                        If Not usehandler.objref Is Nothing Then
                            usehandler.objref.drop 0
                        End If
                    End If
                    End If
                End If
             GoTo makeitnow1
             End If
           ' use global inventory for global ' change from revision 19-version 8.7
            ElseIf here$ = vbNullString Then
            If Not GetVar(bstack, bstack.GroupName + what$, I) Then
            ' If Not MyIsObject(var(i)) Then GoTo makeitnow1
            'GoTo there12
            GoTo lookglobal
            End If
             GoTo makeitnow1
            Else
lookglobal:
            I = globalvar(bstack.GroupName + what$, Empty)     ' MAKE ONE  '
                    If Not MyIsObject(var(I)) Then GoTo makeitnow1
             If FastSymbol(rest$, "=") Then
             GoTo there12
             Else
             GoTo makeitnow1
             End If
            End If
            ElseIf GetVar(bstack, bstack.GroupName + what$, I, True) Then
            
            If MyIsObject(var(I)) Then
                If TypeOf var(I) Is mHandler Then
                 Set usehandler = var(I)
                    If usehandler.T1 = 1 Then
                        If Not usehandler.objref Is Nothing Then
                            usehandler.objref.drop 0
                        End If
                    End If
                Set usehandler = Nothing
                End If
            End If
             GoTo makeitnow1
            Else
        
                I = globalvar(bstack.GroupName + what$, Empty) ' MAKE ONE
                If I <> 0 Then
makeitnow1:
                    MakeitObjectInventory var(I), queue
' here look for block
                    If FastSymbol(rest$, "=") Then
there12:
                    
                        Set bstack.lastobj = var(I)
                        ' new addition we can change an inventory to a queue inventory
                        ' but not the other way
                        Set usehandler = bstack.lastobj
                       If queue Then usehandler.objref.AllowAnyKey
                       Set usehandler = Nothing
                       serr = True
                        ProcInventory = AddInventory(bstack, rest$, serr)
                        If serr Then Exit Function
                        serr = Not Abs(IsLabel(bstack, rest$, what$)) = 1
                        If serr Then Exit Do
                        GoTo conthere

                    Else
                    ' nothing
                    End If
                End If
            End If
     
     If Not FastSymbol(rest$, ",") Then Exit Do
     serr = True

     Loop
If serr Then SyntaxError: ProcInventory = False
End Function


Function ProcThreadPlan(bstack As basetask, rest$, Lang As Long) As Boolean
Dim r
If IsLabelSymbolNew(rest$, "таутовяомо", "CONCURRENT", Lang) Then
IsExp bstack, rest$, r, , , True
If TaskMaster.QueueCount <> 0 Then
If Not Interrupted Then MyEr "Threads exist, can't change thread plan", "уПэЯВОУМ МчЛАТА, ДЕМ ЛПОЯЕъР МА АККэНЕИР СВщДИО"
Else
plan = CLng(r)
Interrupted = True
End If

ElseIf IsLabelSymbolNew(rest$, "диадовийо", "SEQUENTIAL", Lang) Then
If TaskMaster.QueueCount <> 0 Then
If Interrupted Then MyEr "Threads exist, can't change thread plan", "уПэЯВОУМ МчЛАТА, ДЕМ ЛПОЯЕъР МА АККэНЕИР СВщДИО"
Else
plan = 0
Interrupted = False
End If
End If
ProcThreadPlan = True
End Function

Function ProcOpen(bstack As basetask, rest$, Lang As Long) As Boolean
Dim s$, what$, it As Long, p As Variant, x1 As Long, I As Long, skip As Boolean, excl As Boolean
Dim id$, mUni As Long
If IsExp(bstack, rest$, p, , True) Then
    If MemInt(VarPtr(p)) = vbString Then
        SwapString2Variant s$, p
        p = Empty
        GoTo wehavestring
    Else
        MissStringExpr
    End If
ElseIf IsStrExp(bstack, rest$, s$, False) Then
wehavestring:
    If s$ <> "" Then
        FixPath s$
    Else
        skip = True
        I = -2
    End If
    If IsLabelSymbolNew(rest$, "циа", "FOR", Lang) Then
        If skip Then
            id$ = vbNullString
            If Not IsLabelSymbolNewExp(rest$, "еуяиа", "WIDE", Lang, id$) Then
                IsLabelSymbolNewExp rest$, "еуяеиа", "WCHAR", Lang, id$
            End If
        Else
            id$ = vbNullString
            mUni = IsLabelSymbolNewExp(rest$, "еуяиа", "WIDE", Lang, id$)
            'SPELLING CORRECTION FOR GREEK WORD..
            If Not mUni Then mUni = IsLabelSymbolNewExp(rest$, "еуяеиа", "WCHAR", Lang, id$)
            If mUni Then id$ = vbNullString
        End If
        If IsLabelSymbolNewExp(rest$, "еисацыцг", "INPUT", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If skip Then BadFilename: Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If GetVar(bstack, what$, it) Then
                    Else
                        it = globalvar(what$, I)
                    End If
                    If CFname(GetDosPath(s$)) <> "" Then
                        On Error Resume Next
                        var(it) = MyOpenFile(s$, Finput, Abs(excl), 1, mUni)
                        If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                    End If
                End If
            Else
                MissClause "AS", "ыс"
            End If
        ElseIf IsLabelSymbolNewExp(rest$, "сулпкгяысг", "APPEND", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If Not skip Then If Not CanKillFile(s$) Then FilePathNotForUser:  Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If GetVar(bstack, what$, it) Then
                    Else
                        it = globalvar(what$, I)
                    End If
                    If Not skip Then
                    If CFname(GetDosPath(s$)) <> "" Then
                        On Error Resume Next
                        If Not WeCanWrite(GetDosPath(s$)) Then ProcOpen = False: Exit Function
                        var(it) = MyOpenFile(s$, Fappend, Abs(excl), 1, mUni)
                        If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                    End If
                    End If
                Else
                    ExpectedVariable
                    Exit Function
                End If
            Else
                MissClause "AS", "ыс"
                Exit Function
            End If
        ElseIf IsLabelSymbolNewExp(rest$, "енацыцг", "OUTPUT", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If Not skip Then If Not CanKillFile(s$) Then FilePathNotForUser:  Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If GetVar(bstack, what$, it) Then
                    Else
                        it = globalvar(what$, I)
                    End If
                    On Error Resume Next
                    If Not skip Then
                       If Not NeoUnicodeFile(s$) Then NoCreateFile: Exit Function
                       On Error Resume Next
                       var(it) = MyOpenFile(s$, Foutput, Abs(excl), 1, mUni)
                       If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                    End If
                Else
                    ExpectedVariable
                    Exit Function
                End If
            Else
                Exit Function
            End If
        ElseIf IsLabelSymbolNewExp(rest$, "педиа", "RANDOM", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If skip Then BadFilename: Exit Function
            If Not CanKillFile(s$) Then FilePathNotForUser: Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If Not GetVar(bstack, what$, it) Then it = globalvar(what$, I)
                    If IsLabelSymbolNew(rest$, "лгйос", "LEN", Lang) Then
                        If FastSymbol(rest$, "=", True) Then
                            If IsExp(bstack, rest$, p) Then
                                p = Abs(p)
                                If mUni Then p = p * 2
                                If p > 32767 Then p = 32767
                                x1 = p
                            Else
                                Exit Function
                            End If
                        Else
                            MissNumExpr
                            Exit Function
                        End If
                        On Error Resume Next
                        If CFname(s$) = vbNullString Then
                            If Not NeoUnicodeFile(s$) Then NoCreateFile: Exit Function
                        End If
                        var(it) = MyOpenFile(s$, Frandom, Abs(excl), x1, mUni)
                        If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                    Else
                        MissNumExpr
                        Exit Function
                    End If
                Else
                    ExpectedVariable
                    Exit Function
                End If
            Else
                MissClause "AS", "ыс"
                Exit Function
            End If
        Else
            MyEr "Choose a way to open  file", "дИэКЕНЕ щМАМ ТЯЭПО ЦИА МА АМОъНЕИР ТО АЯВЕъО"
            Exit Function
        End If
        ProcOpen = True
    Else
        SyntaxError
    End If
Else
    MissStringExpr
End If
End Function
Function ProcItalic(bstack As basetask, rest$) As Boolean
Dim p As Variant
If IsExp(bstack, rest$, p) Then
    bstack.myitalic = (p <> 0)
Else
    bstack.myitalic = Not bstack.myitalic
    p = CDbl(bstack.myitalic)
End If
players(GetCode(bstack.Owner)).italics = Abs(p <> 0)
bstack.Owner.Font.Italic = (p <> 0)
ProcItalic = True
End Function
Function ProcEditDoc(bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, s$, sX As Double, I As Long, dum As Boolean, frm$
Dim x1 As Long, y1 As Long, p As Variant, Col As Long, OldValue As Boolean
Dim pppp As mArray
prive = GetCode(bstack.Owner)
If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
    End If
With players(prive)

                Form1.EditTextWord = Not IsLabelSymbolNew(rest$, "йыдийа", "CODE", Lang)
                dum = False
                    y1 = Abs(IsLabel(bstack, rest$, s$))
                     
                    If y1 = 6 Then
                                If neoGetArray(bstack, s$, pppp) Then
                                 If Not NeoGetArrayItem(pppp, bstack, s$, I, rest$) Then Exit Function
                                Else
                                MissingDoc
                                
                                Exit Function
                                End If
                    End If
                    If FastSymbol(rest$, ",") Then
                        If Not IsExp(bstack, rest$, sX) Then    ' FROM
                      If FastSymbol(rest$, ",") Then
                      GoTo conteditdoc
                      Else
                             MissNumExpr
                            
                            Exit Function
                      End If
                        End If
                    Else
                
                    
                 sX = 0
                    End If
                    If FastSymbol(rest$, ",") Then
conteditdoc:
                        If Not IsStrExp(bstack, rest$, frm$) Then
                        If FastSymbol(rest$, ",") Then GoTo conteditdoc2
                        End If
                          Else
                 '   Form1.ResetMarks
                     frm$ = vbNullString
                    
                    End If
                    If FastSymbol(rest$, ",") Then
conteditdoc2:
                        If Not IsExp(bstack, rest$, p) Then    ' FROM
                            MissStringExpr
                            
                            Exit Function
                            Else
                            Col = CLng(p)
                            dum = True
                        End If
                        
                    'Else
                    'Form1.ResetMarks
                    End If
                        If y1 = 3 Then
                            If GetVar(bstack, s$, I) Then
                                If VarTypeName(var(I)) = doc Then
                                If var(I).LastSelStart > 0 And sX = 0 Then
                                x1 = var(I).LastSelStart
                                    Else
                                    If sX = 0 Then sX = -1
                                    x1 = sX
                                End If
                                   Form1.TEXT1.Title = frm$ + " "
                                    Form1.TEXT1.TabWidth = ReportTabWidth + 2 * dum
                                    Form1.TabControl = ReportTabWidth + 2 * dum
                                      OldValue = Form1.nobypasscheck
                                  Form1.nobypasscheck = False
                                  ScreenEditDOC bstack, var(I), 0, .mysplit, .mX - 1, .mY - 1, x1, dum, Col
                                  Form1.nobypasscheck = OldValue
                                    var(I).LastSelStart = x1
                                    var(I).ColorEvent = False
                                    ProcEditDoc = True
                                Else
                                    MissingDoc
                                    
                                End If
                            Else
                                   MissFuncParameterStringVar
                                    
                            End If
                        ElseIf y1 = 6 Then
                                    If pppp.ItemType(I) = doc Then
                                                  If pppp.item(I).LastSelStart > 0 And sX = 0 Then
                                x1 = pppp.item(I).LastSelStart
                               
                                    Else
                                    If sX = 0 Then sX = -1
                                    x1 = sX
                                End If
                                    Form1.TEXT1.Title = frm$ + " "
                                    Form1.TEXT1.TabWidth = ReportTabWidth + 2 * dum
                                    Form1.TabControl = ReportTabWidth + 2 * dum
                                    OldValue = Form1.nobypasscheck
                                  Form1.nobypasscheck = False
                                  ScreenEditDOC bstack, pppp.item(I), 0, .mysplit, .mX - 1, .mY - 1, x1, dum, Col
                                  Form1.nobypasscheck = OldValue
                                    pppp.item(I).LastSelStart = x1
                                     pppp.item(I).ColorEvent = False
                                    ProcEditDoc = True
                                    
                                      Else
                                      MissingDoc
                                      
                                      End If
                               
                                    
                    Else
                          MissPar
                          
                    End If
End With
End Function

Function ProcStack(bstack As basetask, rest$, Lang As Long) As Boolean
Dim ss$, frm$, ps As mStiva, it As Long, X As Variant, x0 As Double, s$, once As Boolean, prive As Long
Dim x1 As Long, pa$, what$, I As Long, pppp As mArray, f As Long, myobject As Object, nd&, usehandler As mHandler
ProcStack = True
   If IsLabelSymbolNew(rest$, "меос", "NEW", Lang) Then
   If FastSymbol(rest$, "{") Then
        ss$ = block(rest$)
        Set ps = bstack.soros
        Set bstack.Sorosref = New mStiva
        TraceStore bstack, nd&, rest$, 0
        rest$ = Mid$(rest$, 2)
        Call executeblock(it, bstack, ss$, False, once, , True)
        bstack.addlen = nd&
        Set bstack.Sorosref = ps
        Set ps = Nothing
        If it = 2 Then
            If ss$ = "" Then
                If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
            Else
                rest$ = ": Goto " + ss$
                If trace Then WaitShow = 2: TestShowSub = rest$
            End If
            it = 1
        End If
        If it <> 1 Then ProcStack = False: rest$ = ss$ + rest$
    Else
    ProcStack = False
    MissingBlockCode
    End If
    Exit Function
   Else
If FastSymbol(rest$, "!") Then
If VALIDATEpart(rest$, s$) Then
X = Empty
Do While s$ <> ""
If ISSTRINGA(s$, pa$) Then
bstack.soros.DataStr pa$
ElseIf IsNumberD2fix(s$, X) Then
bstack.soros.DataVal X
X = Empty
Else
Exit Do
End If
Loop
Else
again:

If IsExp(bstack, rest$, X) Then
If bstack.lastobj Is Nothing Then
    'SyntaxError
Else
If TypeOf bstack.lastobj Is mHandler Then
    Set usehandler = bstack.lastobj
    If TypeOf usehandler.objref Is mArray Then
        
        bstack.soros.MergeBottomCopyArray usehandler.objref
    ElseIf TypeOf usehandler.objref Is mStiva Then
        bstack.soros.MergeBottom usehandler.objref
    End If
    Set usehandler = Nothing
ElseIf TypeOf bstack.lastobj Is mArray Then
    bstack.soros.MergeBottomCopyArray bstack.lastobj
End If
Set bstack.lastobj = Nothing
If FastSymbol(rest$, ",") Then FastSymbol rest$, "!": GoTo again

    Exit Function
End If
End If
ProcStack = False
End If
Exit Function
Else
' STACK A$
' stack a$, "NN"
If lookOne(rest$, ".") Then
If IsStrExp(bstack, rest$, ss$) Then
    GoTo isAstring
ElseIf IsExp(bstack, rest$, X) Then
    GoTo isAnobject
Else
    SyntaxError
    ProcStack = False
End If
Exit Function
Else
I = 0
If IsLabelSYMB33(rest$, what$, I) Then
    If Mid$(rest$, I, 2) = "$(" Then
        x1 = 6
        what$ = myUcase(what$, True) + "$("
        Mid$(rest$, 1, I + 1) = space$(I + 1)
    ElseIf Mid$(rest$, I, 1) = "(" Then
        x1 = 6
        what$ = myUcase(what$, True) + "("
        Mid$(rest$, 1, I) = space$(I)
    ElseIf Mid$(rest$, I, 1) = "$" Then
        x1 = 3
        what$ = myUcase(what$, True) + "$"
        Mid$(rest$, 1, I) = space$(I)
    Else
        what$ = myUcase(what$, True)
        If GetVar(bstack, what$, it) Then
            If myVarType(var(it), vbString) Then
                x1 = 3
                Mid$(rest$, 1, I - 1) = space$(I - 1)
            Else
                x1 = 0
            End If
            it = 0
        End If
    End If
Else
x1 = 0
End If
If x1 = 3 Then
    If Not FastSymbol(rest$, "+") Then
        If GetVar(bstack, what$, it) Then
            ss$ = var(it)
            If FastSymbol(rest$, ",") Then
                If Not IsStrExp(bstack, rest$, pa$) Then ProcStack = False: Exit Function
            End If
            If VALIDATE(ss$, pa$, frm$) Then
                IsSymbol3 pa$, ","
                    If VarTypeName(var(it)) = doc Then
                        Set var(it) = New Document
                        var(it).textDoc = pa$
                    Else
                        var(it) = pa$
                    End If
                    Set ps = New mStiva
                I = 1
                Do While I <= Len(frm$) And ss$ <> ""
                    If Mid$(frm$, I, 1) = "S" Then
                        If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                    Else
                        X = vbEmpty
                        If IsNumberD2fix(ss$, X) Then ps.DataVal X
                    End If
                    IsSymbol ss$, ","
                    I = I + 1
                Loop
                With bstack
                    If .SorosNothing Then
                        Set .Sorosref = ps
                    Else
                        .soros.MergeTop ps
                    End If
                End With
            Else
                MyEr "Stack can't read choosen types", "о СЫЯЭР ДЕМ ЛПОЯЕъ МА ДИАБэСЕИ ТОУР ЕПИКЕЦЛщМОУР ТЩПОУР"
                ProcStack = False
            End If
            Exit Function
        Else
            Nosuchvariable what$
        End If
    Else
        If Not GetVar(bstack, what$, it) Then ProcStack = False: Exit Function
        what$ = var(it)
        
        If IsStrExp(bstack, rest$, ss$) Then
            pa$ = vbNullString
            ss$ = what$ + ss$
            If VALIDATE(ss$, pa$, frm$) Then
                Set ps = New mStiva
                I = 1
                Do While I <= Len(frm$) And ss$ <> ""
                    If Mid$(frm$, I, 1) = "S" Then
                        If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                    Else
                        X = vbEmpty
                        If IsNumberD2fix(ss$, X) Then ps.DataVal X
                    End If
                    IsSymbol ss$, ","
                    I = I + 1
                Loop
                With bstack
                     If .SorosNothing Then
                        Set .Sorosref = ps
                     Else
                        .soros.MergeTop ps
                     End If
                End With
            End If
        Else
            ProcStack = False
            Exit Function
        End If
    End If
ElseIf x1 = 6 Then
    frm$ = what$
    If neoGetArray(bstack, what$, pppp) Then
        If Not NeoGetArrayItem(pppp, bstack, what$, f, rest$) Then ProcStack = False: Exit Function
        If pppp.ItemIsObject(f) Then
            Set myobject = pppp.itemObject(f)
            GoTo isAnobject2
        End If
        ss$ = pppp.item(f)
        If FastSymbol(rest$, ",") Then
            If Not IsStrExp(bstack, rest$, pa$) Then ProcStack = False: Exit Function
        End If
        
        If VALIDATE(ss$, pa$, frm$) Then
            IsSymbol3 pa$, ","
            If pppp.ItemType(f) = doc Then
                s$ = pppp.item(f)
                Set pppp.item(f) = New Document
                If s$ <> "" Then
                    pppp.item(f).textDoc = s$
                End If
            Else
                pppp.item(f) = pa$
            End If
            Set ps = New mStiva
            I = 1
            Do While I <= Len(frm$) And ss$ <> ""
                If Mid$(frm$, I, 1) = "S" Then
                    If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                Else
                    X = vbEmpty
                    If IsNumberD2fix(ss$, X) Then ps.DataVal X
                End If
                IsSymbol ss$, ","
                I = I + 1
            Loop
            With bstack
                If .SorosNothing Then
                    Set .Sorosref = ps
                Else
                    .soros.MergeTop ps
                End If
            End With
        
        Exit Function
        Else
            MyEr "String has no valid stack", "тО АКЖАЯИХЛГТИЙЭ ДЕМ щВЕИ щЦЙУЯА СТОИВЕъА СЫЯОЩ"
        End If
    Else
    If Len(frm$) > 0 Then Mid$(rest$, 1, Len(frm$)) = frm$: frm$ = vbNullString
    GoTo conthere
    End If
Else
conthere:
    If IsStrExp(bstack, rest$, ss$) Then
isAstring:
        pa$ = vbNullString
        If VALIDATE(ss$, pa$, frm$) Then
                Set ps = New mStiva
                I = 1
                Do While I <= Len(frm$) And ss$ <> ""
                If Mid$(frm$, I, 1) = "S" Then
                    If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                Else
                    X = vbEmpty
                    If IsNumberD2fix(ss$, X) Then ps.DataVal X
                    ''If IsNumberD(ss$, x0) Then ps.DataVal x0
                End If
                IsSymbol ss$, ","
                I = I + 1
                Loop
                With bstack
                    If .SorosNothing Then
                        Set .Sorosref = ps
                    Else
                        .soros.MergeTop ps
                    End If
                End With
                'stack$(bstack) = ss$ & stack$(bstack)
        
        Else
            ProcStack = False

        End If
                    Exit Function
    ElseIf IsExp(bstack, rest$, X) Then
        If myVarType(X, vbString) Then
            SwapString2Variant ss$, X
            GoTo isAstring
        End If
isAnobject:
        Set myobject = bstack.lastobj
        Set bstack.lastobj = Nothing
isAnobject2:
        If Err Then MyEr "Not a stack", "дЕМ ЕъМАИ СЫЯЭР": Exit Function
        If CheckDeepAny(myobject) Then
            If Not TypeOf myobject Is mStiva Then MyEr "Not a stack", "дЕМ ЕъМАИ СЫЯЭР": Exit Function
            If FastSymbol(rest$, "{") Then
                ss$ = block(rest$)
                TraceStore bstack, nd&, rest$, 0
                If FastSymbol(rest$, "}") Then
                    Set ps = bstack.soros
                    Set bstack.Sorosref = myobject
                    it = 0
                    Call executeblock(it, bstack, ss$, False, once, , True, True)
                    
                    Set bstack.Sorosref = ps
                    Set ps = Nothing
                    If it = 2 Then
                        If ss$ = "" Then
                        If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                        Else
                        rest$ = ": Goto " + ss$
                        If trace Then WaitShow = 2: TestShowSub = rest$
                        End If
                        
                        it = 1
                        End If
                    If it <> 1 Then ProcStack = False: rest$ = ss$ + rest$
            
                End If
                bstack.addlen = nd&
            Else
            bstack.soros.MergeBottom myobject
                'MyEr "No Block {}", "дЕМ УПэЯВЕИ ЛПКОЙ ЕМТОКЧМ { }"
            End If
        Else
            MyEr "Nothing found", "дЕМ БЯчЙА ТъПОТА"
        End If
        Exit Function
    End If
End If
    I = 0
    With bstack.soros
    s$ = vbNullString
    Do
    I = I + 1
    If .Total < I Then Exit Do
    
    Select Case .StackItemType(I)
    Case "?"
    s$ = s$ + "(?) "
    Case "N", "L", "D"
    s$ = s$ + Trim$(str(.StackItem(I))) + " "
    Case "S"
    ss$ = .StackItem(I)
        If Len(ss$) > 78 Then
        s$ = s$ + Chr(34) + Left$(ss$, 75) + ".." + Chr(34)
        Else
        s$ = s$ + Chr(34) + ss$ + Chr(34)
        End If
    Case ">"
    If Lang = 1 Then
    ss$ = "[Optional]"
    Else
    ss$ = "[пЯОАИЯЕТИЙЭ]"
    End If
        
        s$ = s$ + ss$
        
    
    Case Else
        Set myobject = .StackItem(I)
        If Not myobject Is Nothing Then
            If TypeOf myobject Is mHandler Then
                Set usehandler = myobject
                If usehandler.indirect > -1 Then
                    If MyIsObject(var(usehandler.indirect)) Then
                        If usehandler.indirect <= var2used Then
                            s$ = s$ + "*[" + VarTypeName(var(usehandler.indirect)) + "]"
                        Else
                            s$ = s$ + "*[Error]"
                        End If
                    Else
                        s$ = s$ + "*[Nothing]"
                    End If
                Else
                    Select Case usehandler.T1
                    Case 1
                        s$ = s$ + "*[Inventory]"
                    Case 2
                        s$ = s$ + "*[Buffer]"
                    Case Else
                        s$ = s$ + "*[" + Typename(usehandler.objref) + "]"
                    End Select
                End If
            Else
                s$ = s$ + "*[" + Typename(myobject) + "]"
            End If
        Else
        s$ = s$ + "*[Nothing]"
        End If
    End Select
    Set usehandler = Nothing
    Loop
    
    Set myobject = Nothing
    End With
    prive = GetCode(bstack.Owner)
    PlainBaSket bstack.Owner, players(prive), s$
    crNew bstack, players(prive)
   ' PlainBaSket bstack.Owner, players(prive), "cash:" + Str$(TrushCount)
    'crNew bstack, players(prive)
    Exit Function
    End If
End If
End If

End Function

Function ProcDrop(basestack As basetask, rest$, Lang As Long) As Boolean
Dim X As Double, usehandler As mHandler, tmp As FastCollection

If Not IsExp(basestack, rest$, X) Then

X = 1
Else
If Not basestack.lastobj Is Nothing Then
If TypeOf basestack.lastobj Is mHandler Then
Set usehandler = basestack.lastobj
    If usehandler.ReadOnly Then
        ReadOnly
        ProcDrop = False
        Exit Function
    End If
    If usehandler.T1 <> 1 Then OnlyForInventory: Exit Function
    If TypeOf usehandler.objref Is FastCollection Then
        Set tmp = usehandler.objref
        If IsLabelSymbolNew(rest$, "еыс", "TO", Lang) Then
            If IsExp(basestack, rest$, X) Then
                tmp.drop X + 1
                ProcDrop = True
            Else
                MissNumExpr
            End If
        Else
            FastSymbol rest$, ","  ' optional
            If IsExp(basestack, rest$, X) Then
                tmp.drop tmp.count - X + 1
                ProcDrop = True
            Else
                tmp.drop tmp.count
                ProcDrop = True
            End If
        End If
    End If
End If
Exit Function
End If
End If

If X < 0 Then
     
        MyEr "No many items to drop from stack", "дЕМ УПэЯВОУМ ТИЛщР МА ПЕТэНЫ АПЭ ТО СЫЯЭ"
Exit Function
End If

If X = 0 Then
    ' do nothing
    ProcDrop = True
Else
If X > basestack.soros.Total Then
MissStackItem
Exit Function
    ElseIf X = basestack.soros.Total Then
    basestack.soros.Flush
    Else
    basestack.soros.drop CLng(X)
    End If
    ProcDrop = True
    End If

End Function
Function ProcShift(basestack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, I As Long
ProcShift = True
If Not IsExp(basestack, rest$, X) Then X = basestack.soros.Total
If X <= 0 Then
     
        MyEr "No negatives or zero", "╪ВИ АЯМГТИЙОъ ч ЛГДщМ"
Exit Function
End If
If X > basestack.soros.Total Then
MissStackItem

Exit Function
    Else

    If FastSymbol(rest$, ",") Then
        If IsExp(basestack, rest$, Y) Then
        Y = Int(Y)
        If Y < 0 Then
        Y = Abs(Y)
        X = X - 1
        If CLng(X + Y) > basestack.soros.count Then Y = basestack.soros.count - X
        For I = X + 1 To X + Y
        
         basestack.soros.MakeTopItem CLng(I)
      
        Next I
        Else
           'y = y - 1
If CLng(X + Y - 1) > basestack.soros.count Then Y = basestack.soros.count - X + 1

        For I = Y To 1 Step -1
        
         basestack.soros.MakeTopItem CLng(X + Y - 1)
      
        Next I

        End If
    End If
    Else
        basestack.soros.MakeTopItem CLng(X)
    End If
    End If


End Function
Function ProcShiftBack(basestack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, I As Long
ProcShiftBack = True
If Not IsExp(basestack, rest$, X) Then X = basestack.soros.Total
If X <= 0 Then
     
        MyEr "No negatives or zero", "╪ВИ АЯМГТИЙОъ ч ЛГДщМ"

Exit Function
End If
If X > basestack.soros.Total Then
MissStackItem

Exit Function
    Else
    
    
        If FastSymbol(rest$, ",") Then
        If IsExp(basestack, rest$, Y) Then
        If Y < 0 Then
        Y = Abs(Int(Y))
        X = X - 1
          If CLng(X + Y) > basestack.soros.count Then Y = basestack.soros.count - X
        For I = Y To 2 Step -1
        
         basestack.soros.MakeTopItemBack CLng(I + X)
      
        Next I
        If X > 0 Then basestack.soros.MakeTopItemBack CLng(I + X)
        Else
        Y = Int(Y)
        If CLng(X + Y - 1) > basestack.soros.count Then Y = basestack.soros.count - X + 1

        For I = 1 To Y
        basestack.soros.MakeTopItemBack CLng(X + Y - 1)
        Next I
     
        End If
    End If
    Else
    basestack.soros.MakeTopItemBack CLng(X)
    End If
    End If
End Function
Function ProcOver(basestack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, I As Long
ProcOver = True
If Not IsExp(basestack, rest$, X) Then X = 1
    If X <= 0 Then
         
            MyEr "No negatives or zero", "╪ВИ АЯМГТИЙОъ ч ЛГДщМ"
    Exit Function
    End If
    If X > basestack.soros.Total Then
        MissStackItem
        
        Exit Function
    Else
        If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, Y) Then
            Y = Int(Y)
                For I = 1 To Y
                    basestack.soros.Copy2TopItem CLng(X)
                Next I
            Else
                MissPar
            End If
        Else
            basestack.soros.Copy2TopItem CLng(X)
        End If
    End If

End Function
Function ProcFlush(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pppp As mArray, what$, it As Long, y1 As Long
If IsLabelSymbolNew(rest$, "кахос", "ERROR", Lang) Then
         NOEXECUTION = False
         NERR = False
           LastErNum1 = 0
         LastErNum = 0
            LastErName = vbNullString
            LastErNameGR = vbNullString
ElseIf IsLabelSymbolNew(rest$, "сйоупидиа", "GARBAGE", Lang) Then
    GarbageFlush2
Else
Do
    y1 = Abs(IsLabel(basestack, rest$, what$))
    If y1 = 0 Then
     If it = 0 Then basestack.soros.Flush
    Else
        If y1 = 3 Then
            If GetVar(basestack, what$, it) Then
                If VarTypeName(var(it)) = doc Then
                    var(it).EmptyDoc
                Else
                      SyntaxError
                        Exit Function
                End If
            Else
                  SyntaxError
                        Exit Function
            End If
        ElseIf y1 = 6 Then
        If neoGetArray(basestack, what$, pppp) Then
        If Not pppp.Arr Then NotArray: Exit Function
                If Not NeoGetArrayItem(pppp, basestack, what$, it, rest$) Then Exit Function
                         If pppp.ItemType(it) = doc Then
                         Set pppp.item(it) = New Document
                         pppp.item(it).EmptyDoc
                         Else
                      SyntaxError
                        Exit Function
                         End If
                 
       Else
       SyntaxError
        Exit Function
       End If
        End If
    End If
    Loop Until Not FastSymbol(rest$, ",")
End If
ProcFlush = True
End Function
Function ProcRelease(basestack As basetask) As Boolean
' make this for each Guim2000 form also
If basestack.Owner.Name = "DIS" Then
    Form1.MY_BACK.PaintPicture Form1.DIS.Hdc
ElseIf Typename(basestack.Owner) = "GuiM2000" Then
    Dim A As GuiM2000
    Set A = basestack.Owner
    If A.Sizable Then
        MyEr "Not for User forms with resize function", "╪ВИ ЦИА ЖЭЯЛЕР ВЯчСТГ ЛЕ ДУМАТЭТГТА АККАЦчР ЛЕЦщХОУР"
    Else
    
        A.MY_BACK.PaintPicture A.Hdc
    End If
    Set A = Nothing
ElseIf basestack.Owner Is Form1 Then
Form1.Back_Back.PaintPicture Form1.Hdc
ElseIf TypeOf basestack.Owner Is VB.PictureBox Then
    On Error GoTo there1
    Dim p As Long
    p = GetCode(basestack.Owner)
    If p > 32 Then
        If getvar2(basestack, players(p).ControlName, p, True) Then
            Dim b As GuiImage
            Set b = var(p)
            If Not b.MY_BACK Is Nothing Then
                With b
                    .MY_BACK.PaintPicture .pbox.Hdc
                    Set b = Nothing
                End With
            End If
        End If
    End If
End If
ProcRelease = True
Exit Function
there1:
Err.Clear
End Function
Function ProcHold(basestack As basetask) As Boolean
' make this for each Guim2000 form also
Dim p As Long
If basestack.Owner.Name = "DIS" Then
    Form1.MY_BACK.ClearUp
    If Form1.MY_BACK.create(Form1.DIS.Width / DXP, Form1.DIS.Height / DYP) Then
        Form1.MY_BACK.LoadPictureBlt Form1.DIS.Hdc
        If Form1.MY_BACK.bitsPerPixel <> 24 Then Conv24 Form1.MY_BACK
    End If
ElseIf Typename(basestack.Owner) = "GuiM2000" Then
    Dim A As GuiM2000
    Set A = basestack.Owner
    If A.MY_BACK Is Nothing Then Set A.MY_BACK = New cDIBSection
        If A.Sizable Then
            MyEr "Not for User forms with resize function", "╪ВИ ЦИА ЖЭЯЛЕР ВЯчСТГ ЛЕ ДУМАТЭТГТА АККАЦчР ЛЕЦщХОУР"
        Else
            With A
            .MY_BACK.ClearUp
                If .MY_BACK.create(.Width / DXP, .Height / DYP) Then
                    .MY_BACK.LoadPictureBlt .Hdc
                    If .MY_BACK.bitsPerPixel <> 24 Then Conv24 .MY_BACK
                End If
                Set A = Nothing
            End With
    End If
ElseIf basestack.Owner Is Form1 Then
    Form1.Back_Back.ClearUp
    If Form1.Back_Back.create(Form1.Width / DXP, Form1.Height / DYP) Then
        Form1.Back_Back.LoadPictureBlt Form1.Hdc
        If Form1.Back_Back.bitsPerPixel <> 24 Then Conv24 Form1.Back_Back
    End If
ElseIf TypeOf basestack.Owner Is VB.PictureBox Then
On Error GoTo there1
p = GetCode(basestack.Owner)
If p > 32 Then
If getvar2(basestack, players(p).ControlName, p, True) Then
    Dim b As GuiImage
    Set b = var(p)
    If b.MY_BACK Is Nothing Then Set b.MY_BACK = New cDIBSection
    With b
    .MY_BACK.ClearUp
        If .MY_BACK.create(.pbox.Width / DXP, .pbox.Height / DYP) Then
            .MY_BACK.LoadPictureBlt .pbox.Hdc
            If .MY_BACK.bitsPerPixel <> 24 Then Conv24 .MY_BACK
        End If
        Set b = Nothing
    End With
End If
End If
End If
ProcHold = True
Exit Function
there1:
Err.Clear
End Function
Function ProcGet(basestack As basetask, rest$) As Boolean
Dim pppp As iBoxArray, it As Long, what$, p As Variant, f As Variant, par As Boolean, s$, Arr As Boolean
Dim flag As Boolean, usehandler As mHandler, pp As Variant, RF As refArray
IsSymbol3 rest$, "#"

If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
    f = Int(p)
    If Fkind(f) = FnoUse Or Fkind(f) = Foutput Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": ProcGet = False: Exit Function
    If Not FastSymbol(rest$, ",") Then GoTo ex123
    Select Case IsLabel(basestack, rest$, what$)
    Case 1  ' check to see if is a handler
        If GetVar(basestack, what$, it) Then
            pp = 0
            If VarTypeName(var(it)) = mHdlr Then
                If var(it).ReadOnly Then
                    ReadOnly
                    GoTo ex123
                End If
            Set usehandler = var(it)
            flag = True
            ElseIf myVarType(var(it), vbObject) Then
            If Not var(it) Is Nothing Then
                If TypeOf var(it) Is refArray Then
                        GoTo checkRF
                End If
            End If
            End If
            
        End If
        par = False
    Case 5  'check for handler
        what$ = Left$(what$, Len(what$) - 1)
        If GetVar(basestack, what$, it) Then
            pp = 0
                If IsExp(basestack, rest$, pp, flatobject:=True, nostring:=True) Then
                    ' nothing here
                    Arr = True
                End If
                If Not FastSymbol(rest$, ")") Then GoTo ex123
                If Not VarTypeName(var(it)) = mHdlr Then GoTo ex123
                
                Set usehandler = var(it)
                If usehandler.T1 <> 2 Then
                    MissType
                    GoTo ex123
                End If
                If usehandler.ReadOnly Then
                    ReadOnly
                    GoTo ex123
                End If
                flag = True
            End If
            par = False
        Case 3
            If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": ProcGet = False: Exit Function
            par = True: If Not GetVar(basestack, what$, it) Then it = globalvar(what$, "")
        Case 6
            If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": ProcGet = False: Exit Function
            par = False: If neoGetArray(basestack, what$, pppp) Then If Not NeoGetArrayItem(pppp, basestack, what$, it, rest$) Then GoTo ex123
        Case 8
        If GetVar(basestack, what$, it) Then
            If myVarType(var(it), vbObject) Then
                If TypeOf var(it) Is refArray Then
                If Not IsExp(basestack, rest$, pp, flatobject:=True, nostring:=True) Then
                    pp = 0
                End If
                If FastSymbol(rest$, "]", True) Then
checkRF:
                    Set RF = var(it)
                    If RF.MarkTwoDimension Then GoTo err11
                    Select Case RF.ItemType(0)
                    Case vbObject, vbVariant, vbString
err11:
                        MissType
                        GoTo ex123
                        
                    Case Else
                    If FastSymbol(rest$, ",") Then
                            If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                                FileSeek(f) = (Int(p) - 1@) * Fstep(f) + 1@
                            End If
                        End If
                        If FastSymbol(rest$, ",") Then
                            If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                                p = Int(Abs(p))
                            Else
                                GoTo ok112
                            End If
                        Else
                            p = 0
                        End If
                        RF.GetData (f), CLng(pp), CLng(p)
                        GoTo ok112
                    End Select
                End If
                End If
            End If
        End If
        
            MissingStrVar
            GoTo ex123
        Case Else
            MissingStrVar
            GoTo ex123
        End Select
        If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                FileSeek(f) = (Int(p) - 1@) * Fstep(f) + 1@
            ElseIf Not flag Then
                MissNumExpr
                GoTo ex123
            End If
        End If
        If flag Then
            If usehandler.T1 = 1 Then
                MissType
                GoTo ex123
            End If
            Dim buf As MemBlock
            Dim aa() As Byte
            Set buf = usehandler.objref
            With buf
                ' pp is offset
                If Fstep(f) = 1 Then
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                            p = Int(Abs(p))
                        If FastSymbol(rest$, ",") Then
                            If IsExp(basestack, rest$, pp, flatobject:=True, nostring:=True) Then
reenter1:
                            
                                pp = Int(Abs(pp))
                                If pp = 0 Then GoTo wrong
                                If .ValidArea(p, CLng(pp)) Then
                                    .GetData (f), p, CLng(pp)
                                Else
                                    GoTo wrong
                                End If
                            Else
                                MissNumExpr
                                ProcGet = False
                                GoTo ex123
                            End If
                        Else
                            SwapVariant pp, p
                            p = .GetPtr(p)
                            GoTo reenter1
                        End If
                    Else
                        MissNumExpr
                        ProcGet = False
                        GoTo ex123
                    End If
                Else
                    On Error Resume Next
                    .GetData (f), .GetBytePtr(0), .SizeByte
                End If
            Else
                If Arr Then
                    p = 1
                    If FastSymbol(rest$, ",") Then
                        If Not IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                            MissNumExpr
                            GoTo ex123
                        End If
                    End If
                    p = Int(Abs(p))
                    If p = 0 Then GoTo wrong
                    If .ValidArea2(pp, Fstep(f) * p) Then
                        .GetData (f), .GetPtr(pp), Fstep(f) * p
                    Else
wrong:
                        MyEr "Wrong size-position for loading the buffer", "кэХОР ЛщЦЕХОР-ХщСГ ЦИА МА ЖОЯТЫХЕъ Г дИэЯХЯЫСГ"
                        GoTo ex123
                    End If
                Else
                    .GetData (f), .GetPtr(0), .SizeByte
                End If
            End If
        End With
    Else
        Dim FH As Long
        FH = Module10.ReadFileHandler(CLng(f))
        If FH = 0 Then Exit Function
        FileReadString FH, s$, Fstep(f)
        If Not uni(f) Then
            If FastSymbol(rest$, ",") Then
                If Not IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then MissPar: Exit Function
                On Error Resume Next
                s$ = StrConv(s$, vbUnicode, CLng(p))
                If Err Then Err.Clear: NoValidLocale: Exit Function
            Else
                s$ = StrConv(s$, vbUnicode, Clid)
            End If
        End If
        If par Then
            CheckVar var(it), s$
        Else
            If pppp Is Nothing Then
            NotArray
            ProcGet = False
            GoTo ex123
            ElseIf pppp.ItemType(it) = doc Then
                Set pppp.item(it) = New Document
                If s$ <> "" Then pppp.item(it).textDoc = s$
            Else
                pppp.item(it) = s$
            End If
        End If
    End If
End If
ok112:
ProcGet = True
ex123:
Set pppp = Nothing
Set usehandler = Nothing
Set basestack.lastobj = Nothing
End Function
Function ProcPipe(basestack As basetask, rest$) As Boolean
Dim stac1$, ss$, p As Variant, s$
If IsStrExp(basestack, rest$, ss$) Then
If FastSymbol(rest$, ",") Then
stac1$ = vbNullString
Do
If IsExp(basestack, rest$, p, , True) Then
    If MemInt(VarPtr(p)) = 20 Then
        stac1$ = stac1$ + " " + CStr(p)
    ElseIf VarType(p) = vbString Then
        stac1$ = stac1$ + " " + LTrim$(p)
    Else
        stac1$ = stac1$ + " " + LTrim$(str(p))
    End If

ElseIf IsStrExp(basestack, rest$, s$) Then
stac1$ = stac1$ + Sput(s$)
Else
Exit Do
End If
If Not FastSymbol(rest$, ",") Then Exit Do
Loop

If VALIDATE(stac1$, "", s$) Then
ProcPipe = Trans2pipe(ss$, Sput(ss$) + Sput(s$) + stac1$)
Exit Function
End If
End If
End If
ProcPipe = True

End Function

Function ProcGroup(entrypoint As Long, basestack As basetask, rest$, Lang As Long) As Boolean
Dim s$, x1 As Long, y1 As Long, what$, flag As Boolean, ss$, I As Long, par As Boolean
Dim p As Variant, HasStrName As Boolean, strName$, NewStat As Boolean, addlen As Long
ProcGroup = True

Dim Y3 As Long
If entrypoint = -1 Then NewStat = True: entrypoint = 0
If entrypoint < 199 Then
If entrypoint = 1 Then flag = True
Y3 = IsLabelSymbolNew(rest$, "лецецомота", "WITHEVENTS", Lang)
If IsLabelSymbolNew(rest$, "ауто", "THIS", Lang) Then
    If Len(basestack.UseGroupname) > 0 Then
        MyEr "Not in a Group Definition: Remove Group This { }", "╪ВИ СЕ ОЯИСЛЭ ОЛэДАР: аЖАъЯЕСЕ ТГМ оЛэДА аУТЭ {} "
        Exit Function
    Else
    s$ = vbNullString
' s$ = "."
     If basestack.GetDotNew(s$, 1) Then
 
            If Len(s$) = 0 Then: Exit Function '' why

            what$ = Left$(s$, Len(s$) - 1)
            x1 = 1
        Else
            MyEr "Used in a For statement, For Group { this= or =this }", "вЯГСИЛОПОИЕъТАИ ЕМТЭР ЕМЭР циа ОЛэДА { АУТЭ= ч =АУТЭ} "
            Exit Function
        End If
    End If
Else
    x1 = Abs(IsLabel(basestack, rest$, what$))
End If

Else
what$ = rest$
If Right$(what$, 1) = "$" Then
HasStrName = True
strName$ = what$
what$ = Left$(what$, Len(what$) - 1)
End If
flag = entrypoint = 199
If GetVar(basestack, basestack.GroupName + rest$, I, flag) Then
If MyIsObject(var(I)) Then
    If Not TypeOf var(I) Is Group Then
        SyntaxError
        Exit Function
    End If
Else
  Set var(I) = New Group
End If
ElseIf Not GetVar(basestack, basestack.GroupName + what$, I, flag) Then
  I = globalvar(basestack.GroupName + what$, 0&, False, flag)
  Set var(I) = New Group
Else
If MyIsObject(var(I)) Then
    If Not TypeOf var(I) Is Group Then
        SyntaxError
        Exit Function
    End If
Else
  Set var(I) = New Group
End If

End If
If entrypoint = 199 Then

                                var(I).IamGlobal = True
                                UnFloatGroupReWriteVars basestack, basestack.GroupName + what$, I, basestack.lastobj
  

                                Set basestack.lastobj = Nothing
ElseIf entrypoint = 200 Then
                          If basestack.lastobj.IamApointer Then
                          If Not basestack.lastobj.link.IamFloatGroup Then
                          CopyPointerRef basestack, basestack.lastobj
                          End If
                          End If
                                UnFloatGroup basestack, basestack.GroupName + what$, I, basestack.lastobj, var(I).IamGlobal
                            
                                Set basestack.lastobj = Nothing
                                If Len(basestack.UseGroupname) <> 0 Then
                                 var(I).IamRef = True
                            
                                 globalvar what$, CVar(I), True, True
                                 
                             
                                 End If
End If
ProcGroup = True
Exit Function
End If
If x1 = 8 Then ProcGroup = False: SyntaxError: Exit Function
again:
If x1 = 3 Then
HasStrName = True
strName$ = what$
what$ = Left$(what$, Len(what$) - 1)
x1 = 1
End If
If x1 = 1 Then
    If IsLabelSymbolNew(rest$, "тупос", "TYPE", Lang) Then
        If IsStrExp(basestack, rest$, ss$) Then
            s$ = basestack.GroupName
            prepareGroup basestack, what$, y1, flag, HasStrName
            var(y1).IamGlobal = flag
            ProcGroup = ExecuteGroupStruct(basestack, basestack.GroupName + what$, y1, ss$, 0, Lang) <> 0
            basestack.GroupName = s$
        End If
        
    Else
        par = Not FastSymbol(rest$, "+")
        If FastSymbol(rest$, "{") Then
            If par Then
            '' GROUP
              
                
                prepareGroup basestack, what$, y1, flag, HasStrName, NewStat

                var(y1).IamGlobal = flag
                
                If flag Then ss$ = here$: here$ = vbNullString
                addlen = Len(rest$)
                s$ = block(rest$)
                addlen = addlen - Len(s$)
                If ExecuteGroupStruct(basestack, basestack.GroupName + what$, y1, s$, addlen, Lang, flag, NewStat) = 0 Then
                    If flag Then here$ = ss$
                    
                    var(y1).edittag = "'11001EDIT " & here$ & ", " & (Len(rest$) - addlen - Len(s$))
                    ProcGroup = False
                    Exit Function
                End If
                If flag Then here$ = ss$
                ProcGroup = FastSymbol(rest$, "}")
            var(y1).FlushEvents
                  If Y3 = -1 Then
          On Error Resume Next
            
            MakeThunk what$, y1, basestack.UseGroupname, basestack.tpointer
        
        
        End If
               
            Else
            '' CLASS
                    ss$ = block(rest$)
                    s$ = basestack.GroupName
                    
                    prepareGroup basestack, what$, y1, flag, HasStrName
                    var(y1).IamGlobal = flag
                    If ExecuteGroupStruct(basestack, basestack.GroupName + what$, y1, ss$, 0, Lang, flag) = 0 Then
                       rest$ = ss$ + rest$
                    Else
                        ProcGroup = FastSymbol(rest$, "}")
                    End If
            End If
            basestack.GroupName = s$
            If var(y1).IamApointer Then
            Set var(y1) = CopyGroup0Obj(var(y1), p)
            
            PopStage basestack
            End If
       Else
            If GetVar(basestack, basestack.GroupName + what$, I, flag) Then
            ProcGroup = True
            Else
contthere:
''what$ = basestack.GroupName & what$
                I = globalvar(basestack.GroupName + what$, 0&, False, flag)
                Set var(I) = New Group
                var(I).IamGlobal = flag
                If FastSymbol(rest$, "=") Then
                    If IsExp(basestack, rest$, p) Then
                        If Not basestack.lastobj Is Nothing Then
                            If Typename(basestack.lastobj) = mGroup Then
                                If basestack.lastobj.IamApointer Then
     
                                    If basestack.lastobj.link.IamFloatGroup Then
                                    Set basestack.lastobj = basestack.lastobj.link
                                    Else
                                    Dim ohere$, w2 As Long
                            
                                    ohere$ = here$
                                        here$ = basestack.lastobj.lasthere
                                        If GetVar(basestack, basestack.lastobj.GroupName, w2, , , True) Then
                                        
                                        CopyGroup2 var(w2), basestack
                                        End If
                                    here$ = ohere$
   
                                    End If
                                    Set basestack.lastpointer = Nothing
                                End If
                               
                                UnFloatGroup basestack, basestack.GroupName + what$, I, basestack.lastobj, flag
                               Set basestack.lastobj = Nothing
                            End If
                        End If
                    End If
                    If Len(basestack.UseGroupname) <> 0 Then
                                 var(I).IamRef = True
                            
                                 If Not flag Then globalvar what$, CVar(I), True, True
                                 
                             
                                 End If
                    var(I).FlushEvents
                    If Y3 = -1 Then
                    On Error Resume Next
                    MakeThunk what$, I, basestack.UseGroupname, basestack.tpointer
                    End If
                ElseIf FastSymbol(rest$, "->", , 2) Then
                    If Y3 = -1 Then
                    If IsExp(basestack, rest$, p) Then
                        If Not basestack.lastobj Is Nothing Then
                            If Typename(basestack.lastobj) = mGroup Then
                                
                               
                                UnFloatGroup basestack, basestack.GroupName + what$, I, basestack.lastobj, flag
                               Set basestack.lastobj = Nothing
                            End If
                        End If
                    End If
                    var(I).ResetEvents
                    On Error Resume Next
                    MakeThunk what$, I, basestack.UseGroupname, basestack.tpointer
                    Else
                    MyEr "Used only with Group WithEvents", "вЯГСИЛОПОИЕъТАИ ЛЭМО ЛЕ ТГМ оЛэДА лЕцЕЦОМЭТА"
                    ProcGroup = False
                    End If
                    
                ElseIf entrypoint = 99 Then

                                var(I).IamGlobal = True
                                UnFloatGroup basestack, basestack.GroupName + what$, I, basestack.lastobj, True
  

                                Set basestack.lastobj = Nothing
                ElseIf entrypoint = 100 Then
                          If basestack.lastobj.IamApointer Then
                          If Not basestack.lastobj.link.IamFloatGroup Then
                          CopyPointerRef basestack, basestack.lastobj
                          End If
                          End If
                                UnFloatGroup basestack, basestack.GroupName + what$, I, basestack.lastobj, here$ = vbNullString
                            
                                Set basestack.lastobj = Nothing
                Else
                             var(I).GroupName = what$ + "."
                             If HasStrName Then
                             
                             GlobalVarRefLink what$ + "$", I, flag
                             End If
                             If FastSymbol(rest$, ",") Then
                             x1 = Abs(IsLabel(basestack, rest$, what$))
                            If x1 = 1 Or x1 = 3 Then GoTo again
                            SyntaxError
                            ProcGroup = False
                            Exit Function
                            End If
                            If Len(var(I).Patch) = 0 Then
                            If flag Then
                            
                            Else
                            var(I).Patch = here$ + "." + basestack.GroupName + what$
                            End If
                            End If
                End If
            
                Exit Function
            End If
      
        End If
        
    End If
End If
  
End Function
Sub MakeThunk(where$, vvv As Long, ByVal GroupName$, ByVal tpointer As Long)
Dim EventObj As FastCollection, M As Group, it As Long
Set M = var(vvv)
Set EventObj = M.Events
If EventObj Is Nothing Then Exit Sub
Dim I As Long, j As Long, part$
If here$ <> "" Then where$ = here$ + "." + where$
With EventObj
    For I = 0 To .count - 1
        .Index = I
        .Done = True
        If .Value = vbNullString Then
            .Value = where$ + "_" + .KeyToString + "()"
            If GetSub(.Value, it) Then
                .sValue = it
            Else
                .sValue = ModuleSub(.Value, "", GroupName$)
                sbf(.sValue).tpointer = tpointer
            End If
        End If
    Next I
    .Done = False
End With
End Sub
Function MyModule(basestack As basetask, rest$, Lang As Long, Optional noskipcommand = False, Optional MakeNew As Boolean, Optional addlen As Long = 0, Optional skipglob As Boolean = False, Optional ByPass As Boolean) As Boolean
Dim s$, pa$, ss$, x1 As Long, par As Boolean, what$, ohere$, I As Long, X3 As Long, frm$
ohere$ = here$
MyModule = True
If skipglob Then
        par = Len(ohere$) = 0
Else
        x1 = IsLabelSymbolNew(rest$, "цемийо", "GLOBAL", Lang)
        par = IsLabelSymbolNew(rest$, "мео", "NEW", Lang)
End If
If x1 <> 0 Then
        If lookOne(rest$, Chr(34)) Then
                ISSTRINGA rest$, what$
                GoTo bypass1
        End If
End If
X3 = IsLabelF(rest$, what$)
If X3 = 1 Then
If Right$(what$, 1) = "(" Then
If FastSymbol(rest$, ")") Then what$ = what$ + ")"
End If

        If x1 Then
bypass1:

                If Not GetGlobalSubAfterHere(basestack, what$, x1) Then
                    If noskipcommand Then
                        x1 = ModuleSub(what$, "")
                    Else
                        x1 = GlobalSub(what$, "", , what$)
                    End If
                    basestack.IndexSub = x1
                    sbf(x1).sbc = 1
                End If
                If FastSymbol(rest$, "(") Then
                                frm$ = BlockParam(rest$)
                             If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                            If Not FastSymbol(rest$, ")", True) Then
                                MyModule = False
                                Exit Function
                            End If
                           frm$ = Trim$(frm$)

                        End If
                        
                If FastSymbolNoTrimAfter(rest$, "{") Then
             '   i = blockLen(rest$) - 1
                ss$ = block(rest$)
                
                
              '  If i < 0 Then
                If Len(ss$) = 0 Then
                    ss$ = blockString(rest$, Asc("}"))
                 
                End If
               ' Else
               ' ss$ = Mid$(rest$, 1, i)
                'rest$ = Mid$(rest$, i + 1)
                'End If
                   I = Len(rest$)
                
                'If Right$(ss$, 2) <> vbCrLf Then ss$ = ss$ + vbCrLf
                If Left$(sbf(Abs(basestack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                                s$ = vbNullString
                        Else
                                pa$ = sbf(Abs(basestack.OriginalCode)).sb
                                If Not Left$(ss$, 10) = "'11001EDIT" Then
                                            s$ = GetNextLine(pa$) & "-" & CStr(I) + vbCrLf
                                End If
                        End If
                Else
                        If Left$(ss$, 10) <> "'11001EDIT" Then
                                If LenB(here$) = 0 Then
                                ElseIf basestack.OriginalCode > 0 And Not basestack.LoadOnly Then
                                s$ = "'11001EDIT " + GetModuleName(basestack, ohere$) + "," + str(-(I + addlen - 2)) + vbCrLf
                                End If
                        End If
                End If
                            If frm$ <> "" Then
                                If Lang = 1 Then
                                s$ = s$ + vbCrLf + "Read " + frm$ + vbCrLf
                                Else
                                s$ = s$ + vbCrLf + "дИэБАСЕ " + frm$ + vbCrLf
                                End If
                                End If
                
                 sbf(x1).sb = s$ + ss$: basestack.IndexSub = x1
                 Set sbf(x1).subs = Nothing
                         If Not FastSymbol(rest$, "}") Then MyModule = False
                        
                Else
                        MyEr what$ + " missing definition", what$ + " КЕъПЕИ О ОЯИСЛЭР"
                End If
                Exit Function
        Else
          If par Then
                If noskipcommand Then
                    x1 = ModuleSub(what$, "")
                    sbf(x1).sbc = 1
                Else
                If Len(here$) = 0 Then
                
                    x1 = GlobalSub(what$, "", , what$)
                    Else
                    x1 = GlobalSub(here$ + "." + what$, "", , what$)
                    GoTo jump1
                    End If
                End If
                GoTo JUMP0
                ElseIf here$ = vbNullString And GetSub(what$, x1) And Not MakeNew Then
JUMP0:
                        If x1 >= lckfrm And lckfrm <> 0 Then
                                MyEr what$ + " is locked", what$ + " ЕъМАИ ЙКЕИДЫЛщМО"
                                rest$ = vbNullString
                                MyModule = False: Exit Function
                        End If
                        If FastSymbolNoTrimAfter(rest$, "{") Then
                            what$ = block(rest$)
                            If Len(what$) = 0 Then
                                what$ = blockString(rest$, Asc("}"))
                            End If
                        If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                   If Not FastSymbol(rest$, "}") Then
                                           MyModule = False
                                      Else
                                    If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                            sbf(x1).Changed = True
                                            sbf(x1).sb = what$: basestack.IndexSub = x1
                                            Set sbf(x1).subs = Nothing
                                End If
                               
                                        
                        Else
                                rest$ = ":" + what$ + " " + rest$      ''why
                        End If
                        Exit Function
                ElseIf GetlocalSub(basestack.GroupName + what$, x1) And Not MakeNew Then
jump1:
                 If FastSymbol(rest$, "(") Then
                                frm$ = BlockParam(rest$)
                                If Len(frm$) = 0 Then
                                    frm$ = blockString(rest$, Asc("}"))
                                End If
                             If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                            If Not FastSymbol(rest$, ")", True) Then
                                MyModule = False
                                Exit Function
                            
                            End If
                           frm$ = Trim$(frm$)

                        End If
                        If FastSymbolNoTrimAfter(rest$, "{") Then
                        If x1 >= lckfrm And lckfrm <> 0 Then
                                MyEr what$ + " is locked", what$ + " ЕъМАИ ЙКЕИДЫЛщМО"
                                rest$ = vbNullString
                                MyModule = False: Exit Function
                        End If
                                I = Len(rest$) ''
                                what$ = block(rest$) + " "
                                  If Len(what$) = 1 Then
                                    what$ = blockString(rest$, Asc("}")) + " "
                                End If
                                ' here for locked
                                If Not sbf(x1).locked Then
                                While Left$(what$, 10) = "'11001EDIT"
                                        SetNextLine what$
                                Wend
                                If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                s$ = "'11001EDIT " + GetModuleName(basestack, ohere$) + "," + str(-(I + addlen - 2))
                                  If frm$ <> "" Then
                                If Lang = 1 Then
                                what$ = s$ + vbCrLf + "Read " + frm$ + vbCrLf + what$
                                Else
                                what$ = s$ + vbCrLf + "дИэБАСЕ " + frm$ + vbCrLf + what$
                                End If
                                Else
                                what$ = s$ + vbCrLf + what$
                                End If
                                If Not FastSymbol(rest$, "}") Then
                                        MyModule = False
                                Else
                                sbf(x1).Changed = True
                                sbf(x1).sb = what$
                                basestack.IndexSub = x1
                                Set sbf(x1).subs = Nothing
                                
                                End If
                                Else
                                If Not FastSymbol(rest$, "}") Then
                                        MyModule = False
                                Else
                                      basestack.IndexSub = x1
                                End If
                                End If
                        Else
                                rest$ = ":" + basestack.GroupName + what$ + " " + rest$
                        End If
                        Exit Function
                        ElseIf FastSymbol(rest$, "(") Then
                            frm$ = BlockParam(rest$)
                             If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                            If Not FastSymbol(rest$, ")", True) Then
                                MyModule = False
                                Exit Function
                            End If
                            frm$ = Trim$(frm$)
                            If FastSymbolNoTrimAfter(rest$, "{") Then GoTo jumpheretoo
                ElseIf FastSymbolNoTrimAfter(rest$, "{") Then
jumpheretoo:
                        If here$ = vbNullString Then
                                pa$ = block(rest$)
                            If Len(pa$) = 0 Then
                                pa$ = blockString(rest$, Asc("}"))
                            End If
                                If frm$ <> "" Then pa$ = "READ " + frm$ + vbCrLf + pa$
                                If Right$(pa$, 2) <> vbCrLf Then pa$ = pa$ + vbCrLf
                                
                                If noskipcommand Then
                                    basestack.IndexSub = ModuleSub(what$, pa$)
                                Else
                                    basestack.IndexSub = GlobalSub(what$, pa$, , what$)
                                End If
                        Else
                                ss$ = block(rest$)
                                If Len(ss$) = 0 Then
                                    ss$ = blockString(rest$, Asc("}"))
                                End If

                                I = Len(rest$)
                              '  If Right$(ss$, 2) <> vbCrLf Then ss$ = ss$ + vbCrLf
                                If Left$(sbf(Abs(basestack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                                                s$ = vbNullString
                                        Else
                                                pa$ = sbf(Abs(basestack.OriginalCode)).sb
                                                If Not Left$(ss$, 10) = "'11001EDIT" Then
                                                            s$ = GetNextLine(pa$) + "-" + CStr(I) + vbCrLf
                                                End If
                                        End If
                                ElseIf Not basestack.LoadOnly Then
                                        If Left$(ss$, 10) <> "'11001EDIT" Then
                                        If addlen = 0 Then addlen = -1
                                                s$ = "'11001EDIT " + GetModuleName(basestack, ohere$) + "," + str(-(I + addlen)) + vbCrLf
                                        End If
                                End If
                                If frm$ <> "" Then
                                If Lang = 1 Then
                                s$ = s$ + "Read " + frm$ + vbCrLf
                                Else
                                s$ = s$ + "дИэБАСЕ " + frm$ + vbCrLf
                                End If
                                End If
                                If noskipcommand Then
                                If Not ByPass Then
                                    If basestack.GroupName = vbNullString Then
                                        basestack.IndexSub = ModuleSub(here$ + "." + what$, s$ + ss$)
                                    Else
                                        basestack.IndexSub = ModuleSub(here$ + "." + basestack.GroupName + what$, s$ + ss$)
                                    End If
                                    sbf(basestack.IndexSub).sbc = 1
                                    End If
                                Else
                                    If basestack.GroupName = vbNullString Then
                                        basestack.IndexSub = GlobalSub(here$ + "." + what$, s$ + ss$, , what$)
                                    Else
                                        basestack.IndexSub = ModuleSub(here$ + "." + basestack.GroupName + what$, s$ + ss$)
                                    End If
                                End If
                               
                        End If
                        If Not FastSymbol(rest$, "}") Or ByPass Then MyModule = False
                        Exit Function
                Else
                    If basestack.StaticCollection Is Nothing Then ConnectStatic basestack, myUcase(what$)
                    basestack.connectnow = True
                    here$ = what$
                End If
        End If
Else
        If what$ <> "" Then rest$ = what$ + " :" + rest$
        If IsStrExp(basestack, rest$, s$) Then
         
                    If basestack.StaticCollection Is Nothing Then ConnectStatic basestack, myUcase(s$)
                    basestack.connectnow = True
                    here$ = myUcase(s$)
        Else
                rest$ = what$ + " " + rest$
                MyModule = False
        End If
End If
End Function
Function MyEscape(rest$, Lang As Long) As Boolean
MyEscape = True
If Lang = 1 Then
If IsLabelSymbolLatin(rest$, "ON") Then
escok = True
ElseIf IsLabelSymbolLatin(rest$, "OFF") Then
escok = False
Else
MyEscape = False
End If
Else
If IsLabelSymbol(rest$, "маи") Then
escok = True
ElseIf IsLabelSymbol(rest$, "ови") Then
escok = False
Else
MyEscape = False
End If
End If
End Function
Function MyPut(basestack As basetask, rest$) As Boolean
Dim s$, f As Long, p As Variant, I As Long, pp As Variant, it As Long, flag As Boolean, Arr As Boolean
Dim usehandler As mHandler, what$, RF As refArray
MyPut = False
 IsSymbol3 rest$, "#"
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
    f = CLng(p)
    If Fkind(f) = FnoUse Or Fkind(f) = Finput Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": Exit Function
If Not FastSymbol(rest$, ",") Then Exit Function
    I = 1
    what$ = aheadstatus(rest$, , I)
    If Left$(what$, 1) = "N" Then
Select Case IsLabel(basestack, rest$, what$)
    Case 1  ' check to see if is a handler
    If GetVar(basestack, what$, it) Then
        pp = 0
        If VarTypeName(var(it)) = mHdlr Then
            If var(it).ReadOnly Then
                ReadOnly
                GoTo ex123
            End If
            Set usehandler = var(it)
        ElseIf myVarType(var(it), vbObject) Then
            If Not var(it) Is Nothing Then
                If TypeOf var(it) Is refArray Then
                        GoTo checkRF
                End If
            End If
        End If
        
        flag = True
    
    End If

    Case 5  'check for handler
    what$ = Left$(what$, Len(what$) - 1)
    If GetVar(basestack, what$, it) Then
    pp = 0
    If IsExp(basestack, rest$, pp, flatobject:=True, nostring:=True) Then
    ' nothing here
    Arr = True
    End If
    If Not FastSymbol(rest$, ")") Then GoTo ex123
    If Not VarTypeName(var(it)) = mHdlr Then GoTo ex123
        
           If var(it).ReadOnly Then
                        ReadOnly
                                GoTo ex123
                        End If
        Set usehandler = var(it)
        flag = True
    Else
    basestack.tmpstr = what$ + "(" + Left$(rest$, 1)
    BackPort rest$
    If IsExp(basestack, rest$, p) Then

    If MemInt(VarPtr(p)) = vbString Then
    SwapString2Variant s$, p
    
    GoTo JUMPHERE
    End If
    End If
    End If
    Case 8
    If GetVar(basestack, what$, it) Then
            If myVarType(var(it), vbObject) Then
                If TypeOf var(it) Is refArray Then
                If Not IsExp(basestack, rest$, pp, flatobject:=True, nostring:=True) Then
                    pp = 0
                End If
                If FastSymbol(rest$, "]", True) Then
checkRF:
                    Set RF = var(it)
                    If RF.MarkTwoDimension Then GoTo err11
                    Select Case RF.ItemType(0)
                    Case vbObject, vbVariant, vbString
err11:
                        MissType
                        GoTo ex123
                        
                    Case Else
                    If FastSymbol(rest$, ",") Then
                            If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                                FileSeek(f) = (Int(p) - 1@) * Fstep(f) + 1@
                            End If
                        End If
                        If FastSymbol(rest$, ",") Then
                            If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                                p = Int(Abs(p))
                            Else
                                GoTo ok112
                            End If
                        Else
                            p = 0
                        End If
                        RF.putData (f), CLng(pp), CLng(p)
                        GoTo ok112
                    End Select
                
                    
                    
                End If
                End If
            End If
    Else
        SyntaxError
        GoTo ex123
    End If
    Case Else
        SyntaxError
        GoTo ex123
    End Select
    
    Else
    If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": MyPut = False: Exit Function
     If Not IsStrExp(basestack, rest$, s$) Then GoTo ex123
    End If
JUMPHERE:
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
      FileSeek(f) = (CCur(p) - 1@) * Fstep(f) + 1@
ElseIf Not flag Then
    GoTo ex123
End If
End If

If flag Then
Dim buf As MemBlock
Dim aa() As Byte
Set buf = usehandler.objref

With buf
If Fstep(f) = 1 Then
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
p = Int(Abs(p))
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, pp, flatobject:=True, nostring:=True) Then
pp = Int(Abs(pp))
If .ValidArea(p, CLng(pp)) Then
    .putData f, p, CLng(pp)
Else
GoTo wrong
End If

Else
MissNumExpr
GoTo ex123
End If
Else
MissNumExpr
GoTo ex123
End If
Else
MissNumExpr
GoTo ex123
End If
Else
.putData f, .GetBytePtr(0), .SizeByte
End If

Else
    If Arr Then
    p = 1
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                MissNumExpr
                MyPut = False
                GoTo ex123
        End If
    End If
    p = Int(Abs(p))
    If p = 0 Then GoTo wrong
        If .ValidArea2(pp, Fstep(f) * p) Then
            .putData f, .GetPtr(pp), Fstep(f) * p
        Else
wrong:
            MyEr "Wrong size-position for loading the buffer", "кэХОР ЛщЦЕХОР-ХщСГ ЦИА МА ЖОЯТЫХЕъ Г дИэЯХЯЫСГ"
            GoTo ex123
        End If
    Else
        .putData f, .GetPtr(0), .SizeByte
    End If
End If
End With
' use pp for
Else
If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": MyPut = False: Exit Function
If uni(f) Then
s$ = Left$(s$, Fstep(f) \ 2)
s$ = s$ + space$(Fstep(f) \ 2 - Len(s$))
Else
s$ = Left$(s$, Fstep(f))
s$ = s$ + space$(Fstep(f) - Len(s$))
End If
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
FileSeek(f) = (CCur(p) - 1@) * Fstep(f) + 1@
Else
GoTo ex123
End If
End If
If Not uni(f) Then
If FastSymbol(rest$, ",") Then
    If Not IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then MissPar: Exit Function
    On Error Resume Next
    s$ = StrConv(s$, vbFromUnicode, CLng(p))
    If Err Then Err.Clear: NoValidLocale: Exit Function
Else
    s$ = StrConv(s$, vbFromUnicode, Clid)
    End If
End If
I = Module10.ReadFileHandler(CLng(f))
Module10.FileWriteString I, s$
End If
ok112:
MyPut = True
End If
ex123:
Set usehandler = Nothing
Set basestack.lastobj = Nothing
End Function

Function ProcDir(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pa$, W$, par As Boolean, s$, ss$, I As Long, p As Variant, what$, x1 As Long
If IsLabelSymbolNew(rest$, "вягстг", "USER", Lang) Then
If IsSupervisor Then
dset
Else
    mcd = userfiles
    End If
    ProcDir = True
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "йуяио", "MASTER", Lang) Then

    userfiles = GetSpecialfolder(CLng(26)) + "\M2000\"
    ProcDir = True
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "упокоцистг", "COMPUTER", Lang) Then
 If IsSupervisor Then pa$ = "#" Else BadCommand: ProcDir = False: Exit Function
Else
    pa$ = vbNullString
End If
If FastSymbol(rest$, "?") Or pa$ <> "" Then
If IsSelectorInUse Then
ProcDir = False
SelectorInUse
Exit Function
End If
ProcDir = True
    If pa$ = "#" Then
    W$ = "#"
    pa$ = vbNullString
    Else
    p = CBool(IsStrExp(basestack, rest$, W$))
    End If
    If pa$ = vbNullString Then If FastSymbol(rest$, ",") Then p = CBool(IsStrExp(basestack, rest$, pa$))
    olamazi
    DialogSetupLang Lang
    par = False
    If W$ <> "" Then
    
        If Right$(W$, 1) = "?" Then
            W$ = Trim$(Left$(W$, Len(W$) - 1))
    mcd = W$ '' userfiles = W$
            par = True
        End If
    Else
    If IsSupervisor Then W$ = "\" Else W$ = userfiles
    End If

s$ = vbNullString
    If Form1.Visible Then
    If W$ = "#" Then
        If IsSupervisor Then
          If FolderSelector(basestack, "", "*", pa$, False) Then
            s$ = ReturnFile
        End If
        Else
        BadCommand
        ProcDir = False
        Exit Function
        End If
    Else
    If W$ <> "" Then If Not isdir(W$) Then BadPath: ProcDir = False: Exit Function
    If Not CanKillFile(W$) Then FilePathNotForUser: ProcDir = False: Exit Function
        If FolderSelector(basestack, mcd, W$, pa$, par) Then
            s$ = ReturnFile
        End If
    End If
    ElseIf form5iamloaded Then
      If W$ <> "" Then If Not isdir(W$) Then BadPath: ProcDir = False: Exit Function

      If Not CanKillFile(W$) Then FilePathNotForUser: ProcDir = False: Exit Function
        If FolderSelector(basestack, mcd, W$, pa$, par) Then
           s$ = ReturnFile
        End If
    End If
    s$ = mylcasefILE(s$)
            If s$ <> "" Then
            AddDirSep s$
    
                If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
                      Select Case Abs(IsLabel(basestack, rest$, what$))
                        Case 3
                        ProcDir = True
                            If GetVar(basestack, what$, I) Then
                            CheckVar var(I), s$
                            Else
                            globalvar what$, s$
                    
                            End If
                        Case Else
                            MissingStrVar
                            ProcDir = True
                            Exit Function
                        End Select
                 Else
                   mcd = s$
        
                   ProcDir = True
                   Exit Function
                End If
            End If
Else
x1 = IsLabelFileName(basestack, rest$, W$)
If x1 = 1 Then
    SwapStrings ss$, W$
Else
    x1 = IsStrExp(basestack, rest$, ss$, False)
End If

'If Left$(ss$, 1) = "." Then x1 = 1
If Left$(ss$, 2) = ".." And mcd = userfiles And Not IsSupervisor Then ProcDir = True: Exit Function ' no error
FixPath ss$
If x1 = 0 Then
IsSymbol3 rest$, "."
If FastSymbol(rest$, "*") Then
rest$ = Chr(34) + "*" + Chr(34) + rest$
ElseIf Not FastSymbol(rest$, "!") Then
rest$ = Chr(34) + "GSB" + Chr(34) + rest$
End If
 x1 = 1: ss$ = mcd
 par = True
End If
If x1 <> 0 Then
AddDirSep ss$
    If isdir(ss$) Then
        If Right(ss$, 1) <> "\" Then ss$ = ss$ + "\"
        If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
                Select Case Abs(IsLabel(basestack, rest$, what$))
                Case 3
                ProcDir = True
                    If GetVar(basestack, what$, I) Then
                    CheckVar var(I), ss$
                    Else
                    globalvar what$, ss$
            
                    End If
                Case Else
               MissingStrVar
               ProcDir = False
            Exit Function
                End Select
          
        Else
        If CanKillFile(ss$) Then
            mcd = ss$
            ProcDir = True
            If par = True Then
            'GOTO FILES
            If UserPath = "." Then
            If Lang Then
            ss$ = Chr(34) + "Dir User: " + Tcase(Originalusername) + Chr(34)
                Else
            ss$ = Chr(34) + "йАТэКОЦОР вЯчСТГ: " + Tcase(Originalusername) + Chr(34)
            End If
            Else
            If IsSupervisor Then
            If Lang Then
            ss$ = Chr(34) + "Dir: " + UserPath2 + Chr(34)
                Else
            ss$ = Chr(34) + "йАТэКОЦОР: " + UserPath2 + Chr(34)
            End If
            Else
            If Lang Then
            ss$ = Chr(34) + "Dir User: " + Tcase(Originalusername) + ": " + mylcasefILE(UserPath2) + Chr(34)
                Else
            ss$ = Chr(34) + "йАТэКОЦОР вЯчСТГ: " + Tcase(Originalusername) + ": " + mylcasefILE(UserPath2) + Chr(34)
            End If
            End If
            End If
          
            par = MyReport(basestack, ss$, Lang)
            par = ProcFiles(basestack, rest$, Lang)
            par = ProcCat(basestack, "", Lang)
            End If
            Else
            
         mcd = ss$
            ProcDir = True
            If par Then
            If Lang Then
            ss$ = "{Read Only Folder: " + mcd + "}"
            Else
            ss$ = "{йАТэКОЦОР ЛЭМО ЦИА АМэЦМЫСГ: " + mcd + "}"
            End If
            par = MyReport(basestack, ss$, Lang)
            par = ProcFiles(basestack, rest$, Lang)
            par = ProcCat(basestack, "", Lang) Or par
            
            End If
            End If
            Exit Function
          
        End If
     Else
     BadPath
            ProcDir = False
            Exit Function
    End If
    End If
End If

End Function

Function ProcClass(basestack As basetask, rest$, Lang As Long, super As Boolean) As Boolean
Dim I As Long, ss$, y1 As Long, what$, W$, ohere$, w2$, subs As Long, snames As Long, s$, pre$
Dim K As Long, M As Long, once As Boolean, Skipfirsttype As Boolean, wt$
If super Then
    subs = sb2used: snames = subHash.count:
    Dim r As Variant
    Dim SuperGroup As Object
    
End If
once = True
ohere$ = here$
ProcClass = True
y1 = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", Lang)



Select Case IsLabelA("", rest$, W$)
Case 1
If comhash.Find2(W$, M, I) Then
If M > 0 Then
    MyEr "bad class name", "ЛГ АПОДЕЙТЭ ЭМОЛА ЙКэСГР"
    ProcClass = False
Exit Function
End If
End If
againhere:
            If FastSymbol(rest$, "{") Then
            ' new code for finding position on error using shift+f1
            ss$ = block(rest$)
            If once Then
            If UCase(Left$(ss$, 5)) = "TYPE:" Or myUcase(Left$(ss$, 6), True) = "тупос:" Then
            Skipfirsttype = True
            End If
            once = False
            End If
              I = Len(rest$)
              If Skipfirsttype Then
                wt$ = vbNullString
              Else
                If Lang = 1 Then
                  wt$ = "type:" + W$ + vbCrLf
                Else
                  wt$ = "ТЩПОР:" + W$ + vbCrLf
                End If
              End If
              If here$ = vbNullString Or basestack.LoadOnly Then
                If Lang = 1 Then
                    s$ = vbCrLf + "if module(" + W$ + "." + W$ + ") then call! " + W$ + "." + W$ + vbCrLf + "=group(" + W$ + ")"
                    rest$ = W$ + "{" + vbCrLf + "group " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                 Else
                    s$ = vbCrLf + "аМ тЛчЛА(" + W$ + "." + W$ + ") тЭТЕ йэКЕСЕ! " + W$ + "." + W$ + vbCrLf + "=оЛэДА(" + W$ + ")"
                    rest$ = W$ + "{" + vbCrLf + "ОЛэДА " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                  End If
              Else
              If Lang = 1 Then
              s$ = vbCrLf + "if module(" + W$ + "." + W$ + ") then call! " + W$ + "." + W$ + vbCrLf + "=group(" + W$ + ")"
                     rest$ = W$ + "{'11001EDIT " + GetModuleName(basestack, ohere$) + "," + str$(-I) + "'" + str$(Len(s$) + 2) + vbCrLf + "group " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                Else
                s$ = vbCrLf + "аМ тЛчЛА(" + W$ + "." + W$ + ") тЭТЕ йэКЕСЕ! " + W$ + "." + W$ + vbCrLf + "=оЛэДА(" + W$ + ")"
                      rest$ = W$ + "{'11001EDIT " + GetModuleName(basestack, ohere$) + "," + str$(-I) + "'" + str$(Len(s$) + 2) + vbCrLf + "ОЛэДА " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                End If
                End If
                If MyFunction(1, basestack, rest$, Lang) Then
                    ProcClass = True
                    sbf(basestack.IndexSub).IamAClass = True
                    y1 = basestack.IndexSub
                    comhash.ItemCreator2 W$, 0, 44
                End If
                Skipfirsttype = False
         ElseIf IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                I = IsLabelA("", rest$, what$)
                If I < 5 Then
                If GetSub(what$ + "()", I) Then
                                 If sbf(I).Extern > 0 Or Not sbf(I).IamAClass Then
                                    W$ = what$
                                    GoTo conterror
                                 Else
         
                                    K = InStr(sbf(I).sb, vbCrLf)
                                    M = rinstr(sbf(I).sb, vbCrLf + vbCrLf)
                                    If M > K And Len(sbf(I).sb) > M Then
                                        s$ = Mid$(sbf(I).sb, K + 2, M - K)
                                        K = InStr(s$, "{")
                                        If K > 0 Then
                                        
                                        If Lang = 1 Then
                                            pre$ = block(Mid$(s$, K + 1)) + vbCrLf + "Public:" + vbCrLf + pre$
                                        Else
                                            pre$ = block(Mid$(s$, K + 1)) + vbCrLf + "дглосио:" + vbCrLf + pre$
                                        End If
                                        GoTo againhere
                                        Else
                                        s$ = ""
                                        End If
                                    Else
                                        W$ = what$
                                        GoTo conterror
                                    End If
                                 End If
                Else
                W$ = what$
                GoTo conterror
                End If
                Else
                W$ = what$
                GoTo conterror
                End If
         End If
Case 3
w2$ = Left$(W$, Len(W$) - 1)
If comhash.Find2(w2$, M, I) Then
If M > 0 Then
    MyEr "bad class name", "ЛГ АПОДЕЙТЭ ЭМОЛА ЙКэСГР"
    ProcClass = False
Exit Function
End If
End If
M = 0
I = 0
againhere1:
        If FastSymbol(rest$, "{") Then
            ss$ = block(rest$)
            If once Then
            If UCase(Left$(ss$, 5)) = "TYPE:" Or myUcase(Left$(ss$, 6), True) = "тупос:" Then
            Skipfirsttype = True
            End If
            once = False
            End If
                
            I = Len(rest$)
              If Skipfirsttype Then
                wt$ = vbNullString
              Else
                If Lang = 1 Then
                  wt$ = "type:" + w2$ + vbCrLf
                Else
                  wt$ = "ТЩПОР:" + w2$ + vbCrLf
                End If
              End If
                
                If here$ = vbNullString Or basestack.LoadOnly Then
                If Lang = 1 Then
               s$ = "if module(" + w2$ + "." + w2$ + ") then call! " + w2$ + "." + w2$ + vbCrLf + "=group$(" + w2$ + ")"
                        rest$ = W$ + "{" + vbCrLf + "group " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
               Else
                s$ = "аМ тЛчЛА(" + w2$ + "." + w2$ + ") тЭТЕ йэКЕСЕ! " + w2$ + "." + w2$ + vbCrLf + "=оЛэДА$(" + w2$ + ")"
                      rest$ = W$ + "{" + vbCrLf + "ОЛэДА " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                End If
                Else
               If Lang = 1 Then
               s$ = "if module(" + w2$ + "." + w2$ + ") then call! " + w2$ + "." + w2$ + vbCrLf + "=group$(" + w2$ + ")"
                        rest$ = W$ + "{'11001EDIT " + GetModuleName(basestack, ohere$) + "," + str$(-I) + "'" + str$(Len(s$) + 2) + vbCrLf + "group " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
               Else
                s$ = "аМ тЛчЛА(" + w2$ + "." + w2$ + ") тЭТЕ йэКЕСЕ! " + w2$ + "." + w2$ + vbCrLf + "=оЛэДА$(" + w2$ + ")"
                      rest$ = W$ + "{'11001EDIT " + GetModuleName(basestack, ohere$) + "," + str$(-I) + "'" + str$(Len(s$) + 2) + vbCrLf + "ОЛэДА " + W$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                End If
                End If
                If MyFunction(1, basestack, rest$, Lang) Then
                    ProcClass = True
                    sbf(basestack.IndexSub).IamAClass = True
                    comhash.ItemCreator2 w2$, 0, 44
                End If
                Skipfirsttype = False
         ElseIf IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                I = IsLabelA("", rest$, what$)
                If I < 5 Then
                If GetSub(what$ + "()", I) Then
                                 If sbf(I).Extern > 0 Or Not sbf(I).IamAClass Then
                                    W$ = what$
                                    GoTo conterror
                                 Else

                                    K = InStr(sbf(I).sb, vbCrLf)
                                    M = rinstr(sbf(I).sb, vbCrLf + vbCrLf)
                                    If M > K And Len(sbf(I).sb) > M Then
                                        s$ = Mid$(sbf(I).sb, K + 2, M - K)
                                        K = InStr(s$, "{")
                                        If K > 0 Then
                                        
                                        If Lang = 1 Then
                                            pre$ = block(Mid$(s$, K + 1)) + vbCrLf + "Public:" + vbCrLf + pre$
                                        Else
                                            pre$ = block(Mid$(s$, K + 1)) + vbCrLf + "дглосио:" + vbCrLf + pre$
                                        End If
                                        GoTo againhere1
                                        Else
                                        s$ = ""
                                        End If
                                    Else
                                        W$ = what$
                                        GoTo conterror
                                    End If
                                 End If
                Else
                W$ = what$
                GoTo conterror
                End If
                Else
                W$ = what$
                GoTo conterror
                End If
                '
        End If

Case Else
conterror:
        MyEr "No proper name " + W$ + " for class in class definition", "аМТИЙАМОМИЙЭ ЭМОЛА " + W$ + " ЦИА ЙКэСГ СТОМ ОЯИСЛЭ ЙКэСГР"
        ProcClass = False
End Select
If super Then

' make a variable

If Right$(W$, 1) = "$" Then
'Dim s As String
If IsStrExp(basestack, W$ + "()", s) Then
GoTo conthere
End If
ElseIf IsExp(basestack, W$ + "()", r) Then
conthere:
If basestack.lastobj Is Nothing Then
' error
Else

                sb2used = subs
                    subHash.ReduceHash snames, sbf()
                     If UBound(sbf()) / 3 > sb2used And UBound(sbf()) > 499 Then
                               ReDim Preserve sbf(UBound(sbf()) / 2 + 1) As modfun
                       End If
                       
If TypeOf basestack.lastobj Is Group Then
' make a pointet to group
Set SuperGroup = basestack.lastobj
Set basestack.lastobj = Nothing

Dim mm As Variant

If y1 Then
        I = globalvar(W$, mm, , True)
        Set var(I) = New Group
        
        Set var(I).SuperClassList = SuperGroup
        var(I).IamSuperClass = True
Else
        I = globalvar(W$, mm)
         Set var(I) = New Group
        Set var(I).SuperClassList = SuperGroup
        var(I).IamSuperClass = True

End If

Else
' something wrong

End If
End If
End If
End If

End Function
Function ProcDef(basestack As basetask, rest$, Lang As Long) As Boolean
Dim I As Long, what$, y1 As Long, ss$, s$, p, ps$, first
Dim notypes As Boolean, notypes0 As Boolean
ProcDef = True
y1 = IsLabel(basestack, rest$, what$)
If y1 >= 5 Then
s$ = BlockParam(rest$)
rest$ = Mid$(rest$, Len(s$) + 1)
If FastSymbol(rest$, ")", True) Then
If FastSymbol(rest$, "=", True) Then
ss$ = vbNullString
Dim ch As String
Do
I = 1
ch = aheadstatus(rest$, False, I)
If Len(ch) = 0 Then SyntaxError: ProcDef = False: Exit Function
ss$ = ss$ + Left$(rest$, I - 1)
rest$ = Mid$(rest$, I)
If Not FastSymbol(rest$, ",") Then Exit Do
ss$ = ss$ + ", "
Loop
If Trim$(s$) = vbNullString Then
ProcDef = MyFunction(0, basestack, Left$(what$, Len(what$) - 1) + " { =" + ss$ + "}", 1)
Else
ProcDef = MyFunction(0, basestack, Left$(what$, Len(what$) - 1) + " {  @read " + s$ + vbCrLf + "=" + ss$ + "}", 1)
End If
Exit Function
End If
End If
ElseIf y1 > 0 Then
first = 0#
'MyEr "Need name for function with parenthesis", "хщКЫ ЭМОЛА СУМэЯТГСГР ЛЕ ПАЯЕМХщСЕИР"
If LenB(here$) = 0 Or basestack.IamThread Then MyEr "Def make Variables only in Modules and Functions", "г йэМЕ ЖТИэВМЕИ ЛЕТАБКГТщР ЛЭМО СЕ тЛчЛАТА ЙАИ сУМАЯТчСЕИР": ProcDef = False: Exit Function
Dim that As Variant, oldthat As Variant, ByPass As Boolean, lcl As Boolean, notdef As Boolean, notdefone As Boolean
lcl = IsLabelSymbolNew(what$, "топийа", "LOCAL", Lang)
If lcl Then y1 = IsLabel(basestack, rest$, what$)
If y1 < 5 Then
I = 0
    If y1 = 3 Then
        that = vbNullString
        GoTo jumpnow
    ElseIf IsLabelSymbolNew(what$, "аяихло", "DECIMAL", Lang, I) Then
    that = CDec(0)
    ElseIf IsLabelSymbolNew(what$, "дипко", "DOUBLE", Lang, I) Then
    that = 0#
    ElseIf IsLabelSymbolNew(what$, "апко", "SINGLE", Lang, I) Then
    that = 0!
    ElseIf IsLabelSymbolNew(what$, "коцийо", "BOOLEAN", Lang, I) Then
    that = False
    ElseIf IsLabelSymbolNew(what$, "лайяу", "LONG", Lang, I) Then
        If IsLabelSymbolNew(rest$, "лайяу", "LONG", Lang) Then
            that = cInt64(0)
        Else
            that = 0&
        End If
    ElseIf IsLabelSymbolNew(what$, "айеяаио", "INTEGER", Lang, I) Then
    that = 0
    ElseIf IsLabelSymbolNew(what$, "коцистийо", "CURRENCY", Lang, I) Then
    that = 0@
    ElseIf IsLabelSymbolNew(what$, "цяалла", "STRING", Lang, I) Then
    that = vbNullString
    ElseIf IsLabelSymbolNew(what$, "атупо", "VARIANT", Lang, I) Then
    notypes = True
    that = Empty
    ElseIf IsLabelSymbolNew(what$, "ьгжио", "BYTE", Lang, I) Then
    that = CByte(0)
    ElseIf IsLabelSymbolNew(what$, "глеяолгмиа", "DATE", Lang, I) Then
    that = CDate(0)
    '"лецакосайеяаиос", "BIGINTEGER",
    ElseIf IsLabelSymbolNew(what$, "лецакосайеяаиос", "BIGINTEGER", Lang, I) Then
    Set that = New BigInteger
    Else
    ByPass = True
    that = 0#
    GoTo jumpnow
    End If
    notypes0 = Not notypes
    If MyIsObject(that) Then
    Set first = that
    Else
    first = that
    End If
    ByPass = True
    notdefone = True
    notdef = True
    y1 = IsLabel(basestack, rest$, what$)
jumpnow:
    If MyIsObject(that) Then
    Set oldthat = that
    Else
    oldthat = that
    End If
    Do While y1 < 5
    
    If ByPass Then
        notdef = True
        If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
        I = 0
            notypes = False
            If IsLabelSymbolNew(rest$, "аяихлос", "DECIMAL", Lang, I) Then
                that = CDec(0)
            ElseIf IsLabelSymbolNew(rest$, "дипкос", "DOUBLE", Lang, I) Then
                that = 0#
            ElseIf IsLabelSymbolNew(rest$, "апкос", "SINGLE", Lang, I) Then
                that = 0!
            ElseIf IsLabelSymbolNew(rest$, "коцийос", "BOOLEAN", Lang, I) Then
                that = False
            ElseIf IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang, I) Then
                If IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang, 0) Then
                    that = cInt64(0)
                Else
                    that = 0&
                End If
            ElseIf IsLabelSymbolNew(rest$, "айеяаиос", "INTEGER", Lang, I) Then
                that = 0
            ElseIf IsLabelSymbolNew(rest$, "коцистийос", "CURRENCY", Lang, I) Then
                that = 0@
            ElseIf IsLabelSymbolNew(rest$, "цяалла", "STRING", Lang, I) Then
                that = vbNullString
            ElseIf IsLabelSymbolNew(rest$, "атупос", "VARIANT", Lang, I) Then
                notypes = True
                that = CVar(0)
            ElseIf IsLabelSymbolNew(rest$, "ьгжио", "BYTE", Lang, I) Then
                that = CByte(0)
            ElseIf IsLabelSymbolNew(rest$, "глеяолгмиа", "DATE", Lang, I) Then
                that = CDate(0)
            ElseIf IsLabelSymbolNew(rest$, "лецакосайеяаиос", "BIGINTEGER", Lang, I) Then
                Set that = New BigInteger
                
            ElseIf Not IsEnumAs(basestack, rest$, that) Then
                ExpectedEnumType
                Exit Function
            End If
        ElseIf y1 = 3 Then
            that = vbNullString
        Else
            notdef = notdefone
        End If
    ElseIf y1 <> 3 Then
    If VarType(that) = vbEmpty Then
    that = 0#
    End If
    End If
    
    If Not lcl Then If GetlocalVar(what$, I) Then MyEr "Variable " + what$ + " already defined", "уПэЯВЕИ чДГ Г ЛЕТАБКГТч " + what$: ProcDef = False: Exit Function
    I = AllocVar()
    If y1 = 3 Then
    that = vbNullString
    If strid.Find(what$, (I), (I)) Then
        strid.ItemCreator what$, -2
    End If
    ElseIf y1 = 1 Then
    If numid.Find(what$, (I), (I)) Then
        numid.ItemCreator what$, -2
    End If
    End If
    varhash.ItemCreator here$ + "." + what$, I, deftype:=Not notypes
    
    
    If MyIsObject(that) Then
        Set p = that
    Else
        p = that
    End If
    If Not MyIsNumeric(that) Then
        If MyIsObject(first) Then
        Set that = first
        ElseIf Not MyIsObject(that) Then
        that = first
        ElseIf FastSymbol(rest$, "=") Then
        GoTo cont11112
        End If
    End If

    If FastSymbol(rest$, "=") Then
    
    If notypes Or VarType(first) = vbString Then
    If VarType(that) = vbDate Then GoTo cont11112
    If ISSTRINGA(rest$, ps$) Then
        
        p = vbNullString
        SwapString2Variant ps$, p
        GoTo cont1023
    End If
    End If
cont11112:
    If MyIsNumeric(p) Then
    
        If Not IsNumberD2(rest$, p, notdef And Not notypes, True) Then
            If VarType(p) = vbDate Then
                If ISSTRINGA(rest$, ps$) Then
                    p = CDate(ps$)
                Else
                    ProcDef = False
                    missNumber
                    Exit Function
                End If
            ElseIf ByPass And Not notdef Then
            If ISSTRINGA(rest$, ps$) Then
                    p = vbNullString
                    SwapString2Variant ps$, p
                Else
                    ProcDef = False
                    missNumber
                    Exit Function
                End If
            Else
                ProcDef = False
                missNumber
                Exit Function
            End If
            
        End If
            On Error Resume Next
            If MyIsObject(oldthat) Then
                Set that = oldthat
            Else
                that = oldthat
             End If
        If Err.Number > 0 Then
            If Err.Number = 6 Then
                OverflowValue CInt(VarType(that))
                ProcDef = False
            Exit Function
        End If
    End If
cont1023:
    Else
    If Typename(p) = "BigInteger" Then
    If ISSTRINGA(rest$, ps$) Then
        Set p = Module13.CreateBigInteger(ps$)
    ElseIf Not IsNumberD2(rest$, p, notdef And Not notypes, True) Then
    ProcDef = False
    SyntaxError
    Exit Function
    Else
        Set p = Module13.CreateBigInteger(CStr(p))
    End If
    Else
        If Not ISSTRINGA(rest$, ps$) Then
            If VarType(first) = vbString Then
            MissString
            Else
            missNumber
            End If
            ProcDef = False
            Exit Function
        End If
    p = ""
    SwapString2Variant ps$, p
    End If
   End If
    End If
    If MyIsObject(p) Then
    Set var(I) = p
    p = vbEmpty
    If MyIsObject(oldthat) Then
        Set that = oldthat
    Else
        that = oldthat
    End If
    ElseIf y1 = 4 Then
        var(I) = MyRound(p)
    Else
    var(I) = p
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
    DropCommentOrLine rest$
    y1 = IsLabel(basestack, rest$, what$)
    If MyIsObject(that) Then
        Set that = Nothing
    End If
    If MyIsObject(first) Then
        Set that = first
    Else
        that = first
    End If
    Loop
End If
If y1 > 4 Then MyEr "Not arrays for def", "╪ВИ ПъМАЙЕР ЛЕ ТГМ йэМЕ": ProcDef = False: Exit Function
Else
SyntaxError
ProcDef = False
Exit Function
End If
If ProcDef Then
If Len(rest$) > 0 Then
If Not MaybeIsSymbol(rest$, b1234) Then
If Trim(rest$) <> "" Then
PlaceAcommaBefore
ProcDef = False
End If
End If
End If
End If
End Function
Function CheckTwoVal(A, b, c)
CheckTwoVal = A = b Or A = c
End Function
Function MyLink(basestack As basetask, rest$, Lang As Long) As Boolean
MyLink = True
Dim myobject As mStiva, dummy$, s$, ss$, x1 As Long, it As Long, rest1$
Set myobject = basestack.soros
Set basestack.Sorosref = New mStiva
s$ = vbNullString
Do
    If IsLabelSymbolNew(rest$, "исвмг", "WEAK", Lang) Then
        If IsStrExp(basestack, rest$, ss$) Then
            If GetSub(ss$, x1) Then
                If sbf(x1).Extern > 0 Then
                basestack.soros.DataStr "{CALL EXTERN" + str$(sbf(x1).Extern) + "'" + ChrW(&H1FFD) + "}" + sbf(x1).sbgroup: x1 = 1: GoTo contlink2
                Else
                basestack.soros.DataStr "{" + sbf(x1).sb + "}" + sbf(x1).sbgroup: x1 = 1: GoTo contlink2
                End If
            Else
                basestack.soros.DataStr ss$: x1 = 1: GoTo contlink2
            End If
        End If
        MissStringExpr
        MyLink = False
        Exit Function
    ElseIf IsLabelSymbolNew(rest$, "цомийо", "PARENT", Lang) Then
    
        If Len(basestack.UseGroupname) > 0 Then
            ss$ = Mid$(basestack.UseGroupname, 1, Len(basestack.UseGroupname) - 1)
            
            If GetVar(basestack, ss$, x1) Then
            ss$ = Left$(ss$, Len(ss$) - Len(var(x1).GroupName))
            Dim sss$, sss1$, bck$
            bck$ = CopyUntilEndOfLine(rest$)
            sss$ = NLtrim(bck$)
            Do
            If sss$ = vbNullString Then x1 = 0: Exit Do
            sss1$ = "&" + ss$ + "." + sss$
            sss$ = "&" + ss$ + "." + ChrW(&HFFBF) + sss$
            basestack.NoError = True
            s$ = vbNullString
            If IsStr1(basestack, sss1$, s$) Then
                If GetSub(s$, x1) Then
                    basestack.soros.DataStr "{" + sbf(x1).sb + "}": x1 = 1
                Else
                    basestack.soros.DataStr s$: x1 = 1
                End If
                If Len(bck$) > Len(sss1$) Then
                    Mid$(rest$, 1, Len(bck$) - Len(sss1$)) = space(Len(bck$) - Len(sss1$))
                Else
                    x1 = 0: Exit Do
                End If
                SwapStrings sss1$, sss$
            ElseIf IsStr1(basestack, sss$, s$) Then
           
                If GetSub(s$, x1) Then
                    basestack.soros.DataStr "{" + sbf(x1).sb + "}": x1 = 1
                Else
                    basestack.soros.DataStr s$: x1 = 1
                End If
            
            Else
                basestack.NoError = 0
                'rest$ = bck$ + rest$
                MyEr "No such variable", "дЕМ УПэЯВЕИ ТщТОИА ЛЕТАБКГТч"
                MyLink = False
                Exit Function
            End If
        
            Loop Until Not FastSymbol(sss$, ",")
            If Len(bck$) > Len(sss$) Then
                Mid$(rest$, 1, Len(bck$) - Len(sss$)) = space(Len(bck$) - Len(sss$))
            Else
                x1 = 0
            End If
            If x1 = 1 Then GoTo contlink2
            basestack.NoError = 0
            MyEr "Parent group problem", "пЯЭБКГЛА ЦОМИЙчР ОЛэДАР"
    
            Exit Function
            End If
    Else

            MyEr "No parent found", "дЕМ БЯчЙА ЦОМИЙЭ"
         MyLink = False
        Exit Function
            End If
    End If
        
    If Len(rest$) < 129 Then
        it = IsLabelDot(dummy$, rest$, ss$)
    Else
        rest1$ = Left$(rest$, 128)
        it = IsLabelDot(dummy$, rest1$, ss$)
        If Len(rest1$) = 0 Then
            it = IsLabelDot(dummy$, rest$, ss$)
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
    If it = 2 Then
        If Len(rest$) < 129 Then
            it = IsLabelDot(dummy$, rest$, ss$)
        Else
            rest1$ = Left$(rest$, 128)
            it = IsLabelDot(dummy$, rest1$, ss$)
            If Len(rest1$) = 0 Then
                it = IsLabelDot(dummy$, rest$, ss$)
            Else
                rest$ = Mid$(rest$, 129 - Len(rest1$))
            End If
        End If
    End If
    If it = 0 Then IsStr1 basestack, rest$, ss$
    If Len(ss$) > 0 Then
            If Left$(ss$, 1) = "&" Then ss$ = Mid$(ss$, 2)
            If it < 0 Then IsLabel basestack, (ss$), ss$
            If it > 4 Then
                ss$ = ss$ + ")"
                If Not FastSymbol(rest$, ")") Then it = 0
            End If
                    '   x1 = 1
                    '   aheadstatus rest$, False, x1
            basestack.NoError = True
            ss$ = "&" + ss$
            bck$ = ss$
            If IsStr1(basestack, ss$, s$) Then
                 basestack.soros.DataStr s$
                 GoTo contLoop
            Else
                If it > 4 Then
                    it = rinstr(bck$, ".")
                    bck$ = Left$(bck$, it) + ChrW(&HFFBF) + Mid$(bck$, it + 1)
                    If IsStr1(basestack, bck$, s$) Then
                        If basestack.UseGroupname = vbNullString Then
                            MyLink = False
                            MyEr "Can't make reference, it's hidden", "дЕМ ЛПОЯЧ МА ЖТИэНЫ АМАЖОЯэ, ЕъМАИ ЙЯУЛЛщМО"
                            Exit Function
                        End If
                        basestack.soros.DataStr s$
                        GoTo contLoop
                    End If
                Else
                    it = rinstr(bck$, ".")
                    ss$ = Left$(bck$, it) + ChrW(&HFFBF) + Mid$(bck$, it + 1)
                End If
                If IsStr1(basestack, ss$, s$) Then
                    If basestack.UseGroupname = vbNullString Then
                        MyLink = False
                        MyEr "Can't make reference, it's hidden", "дЕМ ЛПОЯЧ МА ЖТИэНЫ АМАЖОЯэ, ЕъМАИ ЙЯУЛЛщМО"
                        Exit Function
                    End If
                End If
            End If
            basestack.NoError = False
            basestack.soros.DataStr s$
    End If
contLoop:
Loop While FastSymbol(rest$, ",")
contlink2:
basestack.NoError = False
If basestack.soros.Total = 0 Then
    MyEr "Nothing to link", "тъПОТА ЦИА МА ЕМЧСЫ"
    
ElseIf IsLabelSymbolNew(rest$, "топийа", "LOCAL", Lang) Then
If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
    MyLink = MyRead(8, basestack, rest$, Lang)
ElseIf IsLabelSymbolNew(rest$, "стг", "TO", Lang) Then
    MyLink = MyRead(8, basestack, rest$, Lang)
Else
    MissClause "TO", "сто"
End If
Else
If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
    MyLink = MyRead(2, basestack, rest$, Lang)
ElseIf IsLabelSymbolNew(rest$, "стг", "TO", Lang) Then
    MyLink = MyRead(2, basestack, rest$, Lang)
Else
    MissClause "TO", "стг"
End If
End If
exitlink:
Set basestack.Sorosref = myobject
Set myobject = Nothing
End Function

Function MyDim(basestack As basetask, rest$, Lang As Long, Optional ByVal dNew As Boolean, Optional ByVal fromthere As Long = 0) As Boolean
Dim par As Boolean, pppp As mArray, it As Long, K As Long, usehandler As mHandler
Dim p As Variant, W$, s$, X As Variant, I As Long, f As Long, Reverse As Boolean, ss$, uselocalbase As Boolean, usethisbase As Long
Dim oldbase As Long, common As Boolean, rest1$, zeroitem As Object

MyDim = True
Reverse = IsLabelSymbolNew(rest$, "OLE", "OLE", Lang)
If dNew Then
par = True
Else
par = IsLabelSymbolNew(rest$, "мео", "NEW", Lang)
End If
common = IsLabelSymbolNew(rest$, "йоимос", "COMMON", Lang)
If Not common Then common = IsLabelSymbolNew(rest$, "йоимои", "COMMON", Lang)
uselocalbase = IsLabelSymbolNew(rest$, "басг", "BASE", Lang)
If uselocalbase Then
If FastSymbol(rest$, "1") Then
    oldbase = ArrBase
    ArrBase = 1
ElseIf FastSymbol(rest$, "0") Then
    oldbase = ArrBase
    ArrBase = 0
End If
If Not par Then
If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
Do
usethisbase = ArrBase

    If Len(rest$) < 129 Then
        it = Abs(IsLabelDIM(basestack, rest$, W$))
    Else
        rest1$ = Left$(rest$, 128)
        it = Abs(IsLabelDIM(basestack, rest1$, W$))
        If Len(rest1$) = 0 Then
            it = Abs(IsLabelDIM(basestack, rest$, W$))
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
    If it = 0 Then MissArrayName: Exit Function
    If basestack.priveflag Then
    W$ = ChrW(&HFFBF) + W$
    End If
    If Not IsSymbol(rest$, ")") Then GoTo ex1
    
    
    If neoGetArray(basestack, W$, pppp, here$ <> "") Then
        If Not pppp.Arr Then Set pppp = Nothing: GoTo ex1
        If pppp.IhaveClass And pppp.GroupRef Is Nothing Then Set pppp = Nothing: GoTo ex1
        pppp.SerialItem 0, -usethisbase, 12
        pppp.common = common
   End If
   Loop Until Not FastSymbol(rest$, ",")
   GoTo ex1
End If
End If
If Not FastSymbol(rest$, ",") Then MyDim = True: GoTo ex1
End If
' for security
usethisbase = ArrBase
Do
ArrBase = usethisbase
    If Len(rest$) < 129 Then
        it = Abs(IsLabelDIM(basestack, rest$, W$))
    Else
        rest1$ = Left$(rest$, 128)
        it = Abs(IsLabelDIM(basestack, rest1$, W$))
        If Len(rest1$) = 0 Then
            it = Abs(IsLabelDIM(basestack, rest$, W$))
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
    If it = 0 Then MissArrayName: Exit Function
    If basestack.priveflag Then
    W$ = ChrW(&HFFBF) + W$
    ElseIf Len(basestack.UseGroupname) > 0 Then
    If it = 6 Then
        If strfunid.Find(W$, I) Then
            If I > 0 Then strfunid.ItemCreator W$, -I
        End If
    ElseIf it = 5 Then
        If funid.Find(W$, I) Then
            If I > 0 Then funid.ItemCreator W$, -I
        End If
    End If
    Else
    
    End If
    
    K = MyTrimL(rest$)
    If Mid$(rest$, K, 1) = ")" Then Mid$(rest$, K, 1) = ChrW(8)
   If neoGetArray(basestack, W$, pppp, True, , , , , fromthere) And Not par Then
    If Not pppp.Arr Then
    conflictname
    
    Set pppp = Nothing: GoTo ex1
    End If
    
    If pppp.IhaveClass And pppp.GroupRef Is Nothing Then Set pppp = Nothing: GoTo ex1
    pppp.common = common
   ' If reverse Then pppp.RevOrder = True
   If uselocalbase Then pppp.myarrbase = -ArrBase
    Select Case it
    Case 5, 6, 7
   If Len(here$) = 0 Then
   GlobalArrResize pppp, basestack, basestack.GroupName + W$, rest$, I
   Else
   GlobalArrResize pppp, basestack, W$, rest$, I
   End If
   
   p = I
    If I < 0 Then it = 0
    
    Case Else
    it = 0
    End Select
   Else
    Select Case it
    Case 5, 6, 7
    f = -1
    If Len(here$) = 0 Then
    GlobalArr basestack, basestack.GroupName + W$, rest$, I, f, , Reverse
    Else
    GlobalArr basestack, W$, rest$, I, f, , Reverse
    End If
    
    var(f).common = common
    
    p = I
    If I < 0 Then it = 0
    
    Case Else
    it = 0
    End Select
    End If
    
    Select Case it
    Case 5
    X = 0
    If FastSymbol(rest$, "=") Then
        If IsExp(basestack, rest$, X) Then
        
        Set zeroitem = basestack.lastobj
        
enter1234:
        If neoGetArray(basestack, W$, pppp) Then
   
        pppp.common = common
                    If Not basestack.lastobj Is Nothing Then
                        If Typename(basestack.lastobj) = mGroup Then
                            If basestack.lastobj.IamSuperClass Then
                                pppp.CopyGroupObj basestack.lastobj.SuperClassList, pppp.GroupRef
                                Set pppp.GroupRef = basestack.lastobj.SuperClassList
                                Set pppp.GroupRef.SuperClassList = basestack.lastobj.SuperClassList
                            Else
                                Set pppp.GroupRef = basestack.lastobj
                            End If
                            pppp.IhaveClass = True
                            Set basestack.lastobj = Nothing
                            pppp.SerialItem 0, 0, 3
                        ElseIf Typename(basestack.lastobj) = "lambda" Then
                            pppp.FillLambda basestack
                        ElseIf Typename(basestack.lastobj) = mHdlr Then
                            Set usehandler = basestack.lastobj
                            If usehandler.T1 = 4 Then pppp.Fillobj basestack Else Set basestack.lastobj = Nothing
                            Set usehandler = Nothing
                        Else
                            Set basestack.lastobj = Nothing
                            If Not zeroitem Is Nothing Then GoTo cont95959
                        End If
                    Else
                        If Not zeroitem Is Nothing Then
cont95959:
                        If pppp.MyTypeToBe <> 0 And pppp.MyTypeToBe <> 12 Then
                        If pppp.MyTypeToBe = 9 Then
                            Set X = zeroitem
                            Set zeroitem = Nothing
                            pppp.SerialItem X, 0, 3
                        Else
w1112:
                            WrongType
                            MyDim = False
                            Exit Function
                        End If
                        Else
                            Set basestack.lastobj = zeroitem
                            Set zeroitem = Nothing
                            
                            pppp.Fillobj basestack
                            Set basestack.lastobj = Nothing
                            End If
                        Else
                            If pppp.MyTypeToBe = 9 Then
                                If Typename(pppp.item(0)) = "BigInteger" Then
                                    Set X = Module13.CreateBigInteger(CStr(Int(X)))
                                Else
                                GoTo w1112
                                End If
                                pppp.SerialItem X, 0, 3
                            ElseIf pppp.MyTypeToBe = 12 Then
                                If Typename(pppp.item(0)) = "BigInteger" Then
                                    Set basestack.lastobj = Module13.CreateBigInteger(CStr(Int(X)))
                                    pppp.Fillobj basestack
                                    Set basestack.lastobj = Nothing
                                Else
                                    pppp.SerialItem X, 0, 3
                                End If
                            Else
                                pppp.SerialItem X, 0, 3
                            End If
                            
                        End If
                    End If
            Else
            it = 0
        End If
        Else
            If IsStrExp(basestack, rest$, s$, False) Then
                X = vbNullString
                SwapString2Variant s$, X
                GoTo enter1234
            Else
                MissNumExpr
                MyDim = False
                GoTo ex1
            End If
        End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, W$, pppp) Then
                pppp.common = common
                        For I = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                                        If Not basestack.lastobj Is Nothing Then
                                                 If Typename(basestack.lastobj) = mGroup Then
                                                     Set pppp.GroupRef = Nothing
                                                     pppp.IhaveClass = False
                                                     If basestack.lastobj.IamSuperClass Then
                                                    Dim MyObj As Object
                                          pppp.CopyGroupObj basestack.lastobj.SuperClassList, MyObj
                        
                                              Set MyObj.SuperClassList = basestack.lastobj.SuperClassList
                                              Set pppp.item(I) = MyObj
                                              Set MyObj = Nothing
                                             
                                               Else
                                                  
                                                       Set pppp.item(I) = basestack.lastobj
                                                       pppp.item(I).ToDelete = False
                                                      End If
                                        ElseIf Typename(basestack.lastobj) = mHdlr Then
                                        Set pppp.item(I) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                        Set pppp.item(I) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = myArray Then
                                        Set pppp.item(I) = basestack.lastobj
                                                    Else
                                                        Set basestack.lastobj = Nothing
                                                        badsupport
                                                        MyDim = False
                                                        GoTo ex1
                                                        Exit For
                                                     End If
                                                     
                                        Else
                                                pppp.item(I) = X
                                        End If
                                        
                        Else
                          Set basestack.lastobj = Nothing
                            MyDim = False
                            MissNumExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next I
                          Set basestack.lastobj = Nothing
            Else
            it = 0
                End If
          End If
     
    
     End If
    Case 7
    X = 0
    If FastSymbol(rest$, "=") Then
    If IsExp(basestack, rest$, X) Then
   If neoGetArray(basestack, W$, pppp) Then ''basestack.GroupName &
   pppp.common = common
    If Typename(basestack.lastobj) = "lambda" Then
                                pppp.FillLambda basestack
                             
   Else
    pppp.SerialItem Int(X), 0, 3
    End If
    End If
    Else
                MissNumExpr
                MyDim = False
                GoTo ex1
    End If
   ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, W$, pppp) Then
                pppp.common = common
                        For I = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                            If Typename(basestack.lastobj) = "lambda" Then
                                    Set pppp.item(I) = basestack.lastobj
                            ElseIf basestack.lastobj Is Nothing Then
                                    pppp.item(I) = Int(X)
                            Else
                                                     Set basestack.lastobj = Nothing
                                                        MyEr "Only Lambda objects here", "лЭМО КэЛДА АМТИЙЕъЛЕМА ЕДЧ"
                                                        MyDim = False
                                                        GoTo ex1
                                                        Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            MyDim = False
                                            MissNumExpr
                            GoTo ex1
                       
                        End If
                        Next I
                        Set basestack.lastobj = Nothing
            Else
            MissNumExpr
            GoTo ex1
                        it = 0
            End If
          End If
     End If
    Case 6
        s$ = vbNullString
    If FastSymbol(rest$, "=") Then
    If IsStrExp(basestack, rest$, s$) Then
   If neoGetArray(basestack, W$, pppp) Then '' basestack.GroupName &
   pppp.common = common
   If Typename(basestack.lastobj) = "lambda" Then
                                pppp.FillLambda basestack
    ElseIf Typename(basestack.lastobj) = mGroup Then
                                   If basestack.lastobj.IamSuperClass Then
                              pppp.CopyGroupObj basestack.lastobj.SuperClassList, pppp.GroupRef
                                Set pppp.GroupRef = basestack.lastobj.SuperClassList
                                Set pppp.GroupRef.SuperClassList = basestack.lastobj.SuperClassList
                            Else
                                Set pppp.GroupRef = basestack.lastobj
                                End If
                                 pppp.IhaveClass = True
                                  Set basestack.lastobj = Nothing
                                 pppp.SerialItem 0, 0, 3
                                         
   Else
    pppp.SerialItem s$, 0, 3
       End If
    End If
    Else
    MissStringExpr
    MyDim = False
    GoTo ex1
    End If
   ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, W$, pppp) Then
                pppp.common = common
                        For I = 0 To pppp.UpperMonoLimit
                        If IsStrExp(basestack, (s$), ss$) Then
                            If Typename(basestack.lastobj) = mGroup Then
                                    Set pppp.GroupRef = Nothing
                                    pppp.IhaveClass = False
                                    Set pppp.item(I) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = "lambda" Then
                                    Set pppp.item(I) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = mHdlr Then
                                        Set pppp.item(I) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                        Set pppp.item(I) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = myArray Then
                                        Set pppp.item(I) = basestack.lastobj
                                    
                            ElseIf basestack.lastobj Is Nothing Then
                                    pppp.item(I) = ss$
                            Else
                                                     Set basestack.lastobj = Nothing
                                                        badsupport
                                                        MyDim = False
                                                        GoTo ex1
                                                        Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            MyDim = False
                            MissStringExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next I
                        Set basestack.lastobj = Nothing
            Else
                it = 0
                MyDim = False
                MissStringExpr
                GoTo ex1
            End If
          End If
     End If
    End Select
    If it = 0 Then
      BadDim

    rest$ = basestack.GroupName + W$ + rest$
    MyDim = False
    GoTo ex1
    End If
    If Not pppp Is Nothing Then
    If basestack.finalFlag Then pppp.Final = True
    ElseIf f > 0 Then
    var(f).Final = basestack.finalFlag
    End If
Loop Until Not FastSymbol(rest$, ",")
ex1:
If uselocalbase Then
ArrBase = oldbase
End If
Set basestack.lastobj = Nothing
Set basestack.lastpointer = Nothing
End Function
Function MySeek(basestack As basetask, rest$) As Boolean
Dim X As Variant, t As Ftypes
MySeek = True
IsSymbol3 rest$, "#"   ' OPTIONAL   ...SEEK #I, 10020  буте
If IsExp(basestack, rest$, X, , True) Then
X = Int(X)
t = Fkind(X)
If t = FnoUse Then
MySeek = False
MyEr "not valid file number", "КэХОР АЯИХЛЭР АЯВЕъОУ"
Exit Function
End If
If t = Frandom Then
MySeek = False
MyEr "not valid file type", "КэХОР тупос АЯВЕъОУ"
Exit Function
End If
If Not FastSymbol(rest$, ",") Then
MissNumExpr
Else
Dim p
If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
    FileSeek(X) = Int(p)
Else
MissNumExpr
End If
End If
End If

End Function
Function MyClose(basestack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, p As Variant, ss$
MyClose = True
If Not IsLabelSymbolNew(rest$, "басг", "BASE", Lang) Then
    par = False
    Do
        IsSymbol3 rest$, "#" ' optional
        If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
            If p < 0 Then
            Else
             p = Int(p)
            If Fkind(p) <> FnoUse Then
            CloseHandler p
            End If
            End If
        Else
            If par Then
                MyClose = False
            Else
                closeAll
            End If
        Exit Do
        End If
        par = True
    Loop Until Not FastSymbol(rest$, ",")
Else
Do
If IsStrExp(basestack, rest$, ss$) Then
On Error Resume Next
If (ss$ Like "*.mdb") Or (ss$ Like "*:\*") Then
ss$ = mylcasefILE(ss$)
End If

 RemoveOneConn ss$
End If
Loop Until Not FastSymbol(rest$, ",")
End If

End Function

Function MyClipboard(basestack As basetask, rest$, Lang As Long) As Boolean
Dim s$, photo As cDIBSection, r As Variant
Dim Width As Long, Height As Long

Dim p

On Error GoTo alfa
If FastSymbol(rest$, "!") Then
    ClearClipBoard
alfa:
MyClipboard = True
Exit Function
End If
If IsExp(basestack, rest$, r) Then
    If MemInt(VarPtr(r)) = vbString Then
        SwapString2Variant s$, r
        r = Empty
        GoTo wehavestring
    Else
        GoTo wehavenumber
    End If
ElseIf IsStrExp(basestack, rest$, s$, False) Then
wehavestring:
    If (Left$(s$, 4) = "cDIB" And Len(s$) > 12) Then         ' MAGIC LETTERS cDIB choose the bitmap
        Set photo = New cDIBSection
        If Not cDib(s$, photo) Then  ' copy from string to cDIBSection
            Set photo = Nothing
            MissCdibStr
            Exit Function
        Else
            photo.GetDpi 96, 96
            photo.CopyToClipboard
            Set photo = Nothing
        End If
    Else
       SetTextData CF_UNICODETEXT, s$   'set as unicode text
    End If
Else
wehavenumber:
    If basestack.lastobj Is Nothing Then
        If FastSymbol(rest$, ",") Then
            IsStrExp basestack, rest$, s$
            SetTextData CF_UNICODETEXT, Num2Str(r, s$)
        Else
            SetTextData CF_UNICODETEXT, Num2Str(r, "")
        End If
    Else
        If TypeOf basestack.lastobj Is BigInteger Then
            SetTextData CF_UNICODETEXT, basestack.lastobj.ToString
        ElseIf TypeOf basestack.lastobj Is mHandler Then
            Dim mm As mHandler, mb As MemBlock
            Set mm = basestack.lastobj
            Set basestack.lastobj = Nothing
            If mm.T1 = 2 Then
                Set mb = mm.objref
                If Not IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                    If mb.SubType = 0 Then
                        If mb.IsEmf Then
                            mb.SubType = 2
                        ElseIf mb.IsWmf Then
                            mb.SubType = 2
                        End If
                    End If
                    If FastSymbol(rest$, ",") Then
                        Dim W, h
                        If IsExp(basestack, rest$, W, , True) Then
                            If Not FastSymbol(rest$, ",") Then
                                mb.SentToClipBoard CLng(W), , , True, True
                                MyClipboard = True
                            ElseIf IsExp(basestack, rest$, h, , True) Then
                                mb.SentToClipBoard CLng(W), CLng(h), , True, True
                                MyClipboard = True
                            Else
                                MissParam rest$
                                MyClipboard = False
                                Exit Function
                            End If
                        Else
                            MissParam rest$
                            MyClipboard = False
                        End If
                        Exit Function
                    ElseIf mb.SubType <> 2 Then
                        mb.SentToClipBoard , , , , True
                    Else
                        If mb.IsWmf Then
                            mb.SentWmfToClipBoard
                        Else
                            mb.SentEmfToClipBoard
                        End If
                    End If
                ElseIf IsStrExp(basestack, rest$, s$) Then
                    s$ = UCase(s$)
                    Select Case s$
                    Case "EMF"
                        If mb.IsWmf Then
                            mb.SubType = 2
                            mb.SentWmfToClipBoard
                        ElseIf mb.SubType = 2 Then
                            mb.SentEmfToClipBoard
                        ElseIf mb.IsEmf Then
                            mb.SubType = 2
                            mb.SentEmfToClipBoard
                        Else
                            MyEr "Not an emf type", "кэХОР ТЩПОР ЕИЙЭМАР"
                        End If
                    Case "BMP"
                        If FastSymbol(rest$, ",") Then
                            If IsExp(basestack, rest$, r) Then
cont1:
                                Width = -1
                                Height = -1
                                If FastSymbol(rest$, ",") Then
                                    If IsExp(basestack, rest$, p) Then Width = Abs(p)
                                    If FastSymbol(rest$, ",") Then
                                        If IsExp(basestack, rest$, p) Then
                                            Height = Abs(p)
                                        Else
                                            MissParam rest$
                                        Exit Function
                                    End If
                                End If
                            End If
                            mb.SentToClipBoard Width, Height, mycolor(r), , True
                        Else
                            If MaybeIsSymbol(rest$, ",") Then r = 15: GoTo cont1
                            MissParam rest$
                        End If
                    Else
                        GoTo cont3
                    End If
                Case "EXT"  ' OLD ROUTINE
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, r) Then
cont2:
                            Width = -1
                            Height = -1
                            If FastSymbol(rest$, ",") Then
                                If IsExp(basestack, rest$, p) Then Width = Abs(p)
                                If FastSymbol(rest$, ",") Then
                                    If IsExp(basestack, rest$, p) Then Height = Abs(p)
                                Else
                                    MissParam rest$
                                    Exit Function
                                End If
                            End If
                            If mm.T1 = 2 Then
                                Set photo = New cDIBSection
                                photo.emfSizeFactor = 1
                                photo.CreateFromPicture mb.GetStdPicture(, , mycolor(r), , True)
                                photo.CopyToClipboard
                            Else
                                mb.SentToClipBoard Width, Height, mycolor(r), , True
                            End If
                        Else
                            If MaybeIsSymbol(rest$, ",") Then r = 15: GoTo cont2
                            MissParam rest$
                        End If
                    Else
cont3:
                        If mm.T1 = 2 Then
                            mb.SentToClipBoard , , mycolor(r), , True
                        Else
                            mb.SentToClipBoard , , , , True
                        End If
                    End If
                    End Select
                End If
            End If
        End If
    End If
End If
MyClipboard = True
End Function

Private Function MyMod(r1, po) As Variant
MyMod = r1 - Fix(r1 / po) * po
End Function
Function Appfields(basestack As basetask, rest$) As Boolean
Dim s$, p As Variant

If IsExp(basestack, rest$, p) Then
Appfields = AddInventory(basestack, rest$)
ElseIf IsStrExp(basestack, rest$, s$) Then
Appfields = True
append_table basestack, s$, rest$, False
Else
SyntaxError
Appfields = False
End If
Set basestack.lastobj = Nothing
Exit Function
End Function
Function rValue(bstack As basetask, ob As Object) As Variant
    If ob Is Nothing Or TypeOf ob Is Group Then
        Set bstack.lastobj = ob
        rValue = 0
    ElseIf TypeOf ob Is PropReference Then
        rValue = ob.Value
        Set bstack.lastobj = ob.lastobjfinal
        If Not bstack.lastobj Is Nothing Then rValue = 0
    ElseIf TypeOf ob Is mEvent Then
        CopyEvent ob, bstack
        rValue = 0
    ElseIf TypeOf ob Is lambda Then
        CopyLambda ob, bstack
        rValue = 0
    ElseIf TypeOf ob Is mHandler Then
        CopyHandler ob, bstack
        rValue = 0
    ElseIf TypeOf ob Is mArray Then
        Set bstack.lastobj = CopyArray(ob)
        rValue = 0
    ElseIf TypeOf ob Is Document Then
        rValue = ob.textDoc
        Set bstack.lastobj = Nothing
    Else
        Set bstack.lastobj = ob
        rValue = 0
    End If
End Function
Sub refreshGui()
   Dim X As Form
                    For Each X In Forms
             
                    If Typename$(X) = "GuiM2000" Then
                    If X.enabled Then X.Refresh
                    End If
                    Next
                    Set X = Nothing
End Sub

Sub MouseShow(Yes As Boolean)
Dim K As Long, b1 As Boolean
If Yes Then
K = ShowCursor(True)
k1 = K = -1
If K < 0 Then
K = ShowCursor(True)
Do While K < 0
If K = -1 And k1 Then Exit Sub ' no mouse found
K = ShowCursor(True)
Loop
End If
Else

K = ShowCursor(False)
Do While K >= 0
K = ShowCursor(False)
Loop
End If
End Sub

Function GetAnewEvent() As Variant

Dim aa As New ComShinkEvent, bb As New mHandler
'Set aa.Callback = Form1
Set bb.objref = aa
 bb.T1 = 3
Set GetAnewEvent = bb
End Function
Public Function CallEventFromCOM1(evCom As ComShinkEvent, aString$, what$, NumVar As Long, vrs(), ref() As Long, exclude As Boolean, ItemIndex As Long) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
Dim f$, F1$, klm As Long, ohelp As Object
'olescok = escok
'escok = False
CallEventFromCOM1 = True
F1$ = evCom.modulename$
f$ = UCase(F1$ + "_" + aString$ + "()") ' No greek
If Not subHash.Find(f$, klm) Then exclude = True: Exit Function
extr = extreme
extreme = True
tr = trace
trace = False
Dim n$, bb As mStiva, oldbstack As mStiva, nowtotal As Long
Dim bstack As basetask
Set bstack = New basetask
Set bstack.Owner = Form1.DIS
bstack.IamAnEvent = True
Dim I As Long
I = evCom.VarIndex
'F1$ = evCom.modulename$
If Not evCom.StaticCollection Is Nothing Then
If evCom.StaticCollection.ExistKey(aString$) Then
Set bstack.StaticCollection = evCom.StaticCollection.ValueObj
End If
End If
Set oldbstack = bstack.soros
Dim j As Long, K As Long, s1$, S2$
Dim ohere$
ohere$ = here$
here$ = vbNullString

If evCom.Attached Then
Set bb = New mStiva
Set bstack.Sorosref = bb
            PushStage bstack, False
            If ItemIndex > -1 Then
                bb.DataVal CVar(ItemIndex)
            End If
            For K = 1 To NumVar
            'If VariantIsRef(VarPtr(vrs(k))) Then
            If ref(K) Then
            Select Case VarType(vrs(K))
            Case vbString
            globalvarGroup "EV" & (I + K) & "$", vrs(K)
            bb.DataStr "EV" & (I + K) & "$"
            Case Is >= vbArray
            ' make it normal
            globalvarGroup "EV" & (I + K) & "(", RetM2000array(vrs(K))
            bb.DataStr "EV" & (I + K)
            Case Else
            globalvarGroup "EV" & (I + K), vrs(K)
            bb.DataStr "EV" & (I + K)
            End Select
            Else
            Select Case VarType(vrs(K))
            Case vbString
            bb.DataStr CStr(vrs(K))
            Case Is >= vbArray
            ' make it normal
                Set ohelp = RetM2000array(vrs(K))
                bb.DataObj ohelp
                Set ohelp = Nothing
            Case Else
                If MyIsObject(vrs(K)) Then
                    Set ohelp = vrs(K)
                    bb.DataObj ohelp
                    Set ohelp = Nothing
                Else
                    bb.DataVal vrs(K)
                End If
            End Select
            End If
            Next K
            '''bb.DataObj evCom
            '' last is the second name, the class name??
            bb.DataStr (what$)
     
            bb.DataObj MakeitObjectGeneric(evCom.VarIndex)
  
            'f$ = aString$
            
           '' WE ARE GOING TO OUR MODULE
           
            here$ = evCom.modulenameonly

            If FastCallModule(bstack, klm) <> 1 Then
            
            
            
                PopStage bstack
                bb.Flush
                GoTo conthere
            End If
                  here$ = vbNullString
                  If NumVar > 0 Then
       For K = LBound(vrs()) To UBound(vrs()) - 1 + LBound(vrs())
       If ref(K) Then
       Select Case VarType(vrs(K))
       Case vbString
            varhash.Find2 "EV" & (I + K) & "$", j, True
           vrs(K) = var(j)

       Case Is >= vbArray
            varhash.Find2 "EV" & (I + K) & "(", j, True
            RetComArray var(j), vrs(K)
        Case Else
            varhash.Find2 "EV" & (I + K), j, True
             vrs(K) = var(j)
            End Select
           End If
            Next K
            End If
            PopStage bstack

            bb.Flush

End If

conthere:
If Not bstack.StaticCollection Is Nothing Then
        If evCom.StaticCollection Is Nothing Then Set evCom.StaticCollection = New FastCollection
        If Not evCom.StaticCollection.ExistKey(aString$) Then
            evCom.StaticCollection.AddKey aString$, bstack.StaticCollection
        End If
End If


Set bstack.Sorosref = oldbstack
here$ = ohere$
Set oldbstack = Nothing
Set bb = Nothing
extreme = extr
trace = tr

'escok = olescok
End Function
Sub RetComArray(varFrom As Variant, varTo As Variant)
Dim Ar As mArray, v()
Set Ar = varFrom
Ar.CopyBackSerialize v()
varTo = v()
End Sub

Function FastCallModule(bstack As basetask, mod_id As Long) As Long
Dim I As Long, frm$
 'If checkbreakEsc(bstack) Then FastCallModule = 0: Exit Function
 frm$ = Mid$(sbf(mod_id).sb, 1)
 FastCallModule = Execute(bstack, frm$, False, False)
 
 
End Function

Function MakeATypeLib(v As Variant, Optional usetypelib As Boolean = False) As FastCollection
    Dim obj             As Object, vv As FastCollection
    ' create the requested object
    
    Set obj = v
    If TypeOf obj Is ExtControl Then Set obj = obj.Value

    If usetypelib Then
            ' find typelib and load it
    Set MakeATypeLib = New FastCollection
    Else
    
    If Not GetAllMembers(vv, obj) Then Err.Raise &H80004002
    Set MakeATypeLib = vv
    Set vv = Nothing
    End If
    Set obj = Nothing
End Function

Function FindPrevOriginal(bstack As basetask) As Long
Dim curparent As basetask, cur As basetask
'If bstack.IamThread Then
'FindPrevOriginal = bstack.Parent.OriginalCode
'Exit Function
'End If
Set cur = bstack
Set curparent = cur.Parent
If curparent Is Nothing Then FindPrevOriginal = cur.OriginalCode: Exit Function
If curparent.OriginalCode = 0 Then FindPrevOriginal = cur.OriginalCode: Exit Function
Do While curparent.OriginalCode = cur.OriginalCode And curparent.OriginalCode <> 0
Set cur = curparent
Set curparent = cur.Parent
If curparent Is Nothing Then FindPrevOriginal = cur.OriginalCode: Exit Function
Loop
FindPrevOriginal = curparent.OriginalCode
End Function
Function iter(bstack As basetask, rest$, Lang As Long) As Boolean
' each( array or inventory, start: 1 by default, or -1 for end of list,  end: -1 to end (optional), or we can set it)
    Dim pppp As mArray, w1 As Long, s$, num As Long, st As Variant, en As Variant, usehandler As mHandler, usehandler1 As mHandler
    
    w1 = Abs(IsLabel(bstack, rest$, s$))
    If w1 > 4 Then
    If neoGetArray(bstack, s$, pppp) Then
        If pppp.Arr Then
            If FastSymbol(rest$, ")") Then
            If Not IsSymbol(rest$, ",") Then
            ' READ KEYWORDS
                st = 1: en = -1
                If IsLabelSymbolNew(rest$, "аявг", "START", Lang) Then
                    st = 1
                ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang) Then
                    st = -1
                ElseIf IsExp(bstack, rest$, st, , True) Then
                    st = Int(st)
                Else
                    st = 1
                End If
                If IsLabelSymbolNew(rest$, "еыс", "TO", Lang) Then
                    If IsLabelSymbolNew(rest$, "аявг", "START", Lang) Then
                        en = 1
                    ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang) Then
                        en = -1
                    ElseIf IsExp(bstack, rest$, en, , True) Then
                        en = Int(en)
                    Else
                        MyEr "To where?", "╦ЫР ПОУ;"
                        Exit Function
                    End If
                Else
                    en = -1
                End If
            Else
                If Not IsExp(bstack, rest$, st) Then st = 1
                If Not IsSymbol(rest$, ",") Then
                    en = -1
                ElseIf Not IsExp(bstack, rest$, en) Then
                    MissNumExpr
                    Exit Function
                End If
            End If
          
            Set usehandler = New mHandler
            
           Set usehandler.objref = pppp
           Set bstack.lastobj = usehandler
            PlaceIteratorData bstack, var(0), st, en
            iter = True
            Exit Function
            End If
            
        End If
        End If
    ElseIf GetVar(bstack, s$, w1) Then
        If VarTypeName(var(w1)) = mHdlr Then
conthere111:
         
       If Not IsSymbol(rest$, ",") Then
                st = 1: en = -1
        If IsLabelSymbolNew(rest$, "аявг", "START", Lang) Then
                    st = 1
                ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang) Then
                    st = -1
                ElseIf IsExp(bstack, rest$, st, , True) Then
                    st = Int(st)
                Else
                    st = 1
                End If
                If IsLabelSymbolNew(rest$, "еыс", "TO", Lang) Then
                
                    If IsLabelSymbolNew(rest$, "аявг", "START", Lang) Then
                        en = 1
                    ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang) Then
                        en = -1
                    ElseIf IsExp(bstack, rest$, en, , True) Then
                        en = Int(en)
                    Else
                        MyEr "To where?", "╦ЫР ПОУ;"
                        Exit Function
                    End If
                Else
                    en = -1
                End If
            Else
                If Not IsExp(bstack, rest$, st, , True) Then st = 1
                If Not IsSymbol(rest$, ",") Then
                    en = -1
                ElseIf Not IsExp(bstack, rest$, en, , True) Then
                    MissNumExpr
                    Exit Function
                End If
                Set usehandler = New mHandler
                Set bstack.lastobj = usehandler
                Set usehandler1 = var(w1)
                usehandler.T1 = usehandler1.T1
                GoTo con12345
            End If
            
        If VarTypeName(var(w1)) <> mHdlr Then
        On Error GoTo there1
          If VarTypeName(var(w1).objref) <> myArray Then
           
           Set bstack.lastobj = Nothing
           MyEr "Not proper object for iterator", "дЕМ ЕъМАИ СЫСТЭ АМТИЙЕъЛЕМО ЦИА ЕПАМэКГЬГ"
           Exit Function
           End If
          End If
there1:
          Err.Clear
          
           Set bstack.lastobj = New mHandler
con12345:
            PlaceIteratorData bstack, var(w1), st, en
            iter = True
        End If
    End If


End Function
Function ClearLabels()
If sb2used > 0 Then
Dim I As Long
For I = 1 To sb2used
Set sbf(I).subs = Nothing
Next I
End If
End Function
Function MyIsNumericPointer(v As Variant) As Boolean
Dim n As Integer
GetMem2 VarPtr(v), n
If n < 8 Then MyIsNumericPointer = True: Exit Function
MyIsNumericPointer = (n = 11) Or (n = 17) Or (n = 14) Or (n = 36)
End Function
Function CheckInt64(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
CheckInt64 = n = 20
End Function
Function MyIsNumeric(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
If n < 8 Then MyIsNumeric = True: Exit Function
MyIsNumeric = (n = 11) Or (n = 17) Or (n = 14) Or (n = 20) Or (n = 36)
End Function
Function MyIsNumeric2(v As Variant, n As Integer) As Boolean
GetMem2 VarPtr(v), n
If n < 8 Then MyIsNumeric2 = True: Exit Function
MyIsNumeric2 = (n = 11) Or (n = 17) Or (n = 14) Or (n = 20) ' no  Or (n = 36)
End Function
Function IsNumericPrint(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
If n = 0 Then Exit Function
If n < 8 Then IsNumericPrint = True: Exit Function
IsNumericPrint = (n = 11) Or (n = 17) Or (n = 14) Or (n = 20) Or (n = 36)
End Function
Function MyIsUnknown(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
MyIsUnknown = n = 13
End Function
Function MyIsObject(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
MyIsObject = n = 9
End Function
Function MyVal(v As Variant) As Variant
On Error GoTo there1245
MyVal = v
Exit Function
there1245:
On Error GoTo there1246
MyVal = val(v)
there1246:
End Function
Function ThisPointer(bstack As basetask, w3 As Long) As Boolean ' return var(r)
Dim s1$
    Set bstack.lastobj = Nothing
     If Len(bstack.UseGroupname) > 0 Then
     s1$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
     If GetVar(bstack, s1$, w3) Then
          ThisPointer = True
     ElseIf Len(bstack.fHere) = 0 Then
  
     ElseIf GetVar(bstack, bstack.fHere + "." + s1$, w3) Then
          ThisPointer = True
          ElseIf GetVar(bstack, s1$, w3, True) Then
          ThisPointer = True
    End If
    Else
there:
    's1$ = "."
    s1$ = vbNullString
    If bstack.GetDotNew(s1$, 1) Then
    If Len(s1$) = 0 Then Exit Function
    s1$ = Left$(s1$, Len(s1$) - 1)
        If GetVar(bstack, s1$, w3) Then
            ThisPointer = True
    End If
    End If
    End If
    
    
    

End Function

Function This1(bstack As basetask, original$, r As Variant) As Boolean  ' return a copy
Dim s1$, w3 As Long
    Set bstack.lastobj = Nothing
     If Len(bstack.UseGroupname) > 0 Then
     If bstack.tpointer > 0 Then
     If var(bstack.tpointer).GroupName = bstack.UseGroupname Then
     Set bstack.lastobj = CopyGroupObj(var(bstack.tpointer))
     Else
     GoTo cont1001
     End If
     
     Else
cont1001:
     s1$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
     If GetVar(bstack, s1$, w3) Then
          Set bstack.lastobj = CopyGroupObj(var(w3))
     ElseIf GetVar(bstack, bstack.fHere + "." + s1$, w3) Then
          Set bstack.lastobj = CopyGroupObj(var(w3))
          ElseIf GetVar(bstack, s1$, w3, True) Then
           Set bstack.lastobj = CopyGroupObj(var(w3))
          
    End If
    End If
    Else
there:
    s1$ = vbNullString
    If bstack.GetDotNew(s1$, 1) Then
    If Len(s1$) = 0 Then
        If GetVar(bstack, original$, w3) Then
            If MyIsObject(var(w3)) Then
            Set bstack.lastobj = var(w3)
            r = 0
            Else
            r = var(w3)
            End If
            This1 = True
        Else
        MyEr "Not Defined variable " + original$, "дЕМ щВЕИ ОЯИСТЕъ ЛЕТАБКГТч " + original$
        This1 = False
         End If
    Exit Function
    Else
    s1$ = Left$(s1$, Len(s1$) - 1)
        If GetVar(bstack, s1$, w3) Then
        If MyIsObject(var(w3)) Then
            If TypeOf var(w3) Is Group Then
                Set bstack.lastobj = CopyGroupObj(var(w3))
            Else
                Set bstack.lastobj = var(w3)
            End If
            r = 0
            Else
            r = var(w3)
            End If
            This1 = True
           Exit Function
        
    End If
    End If
    End If
    End If
    
     r = 0
    This1 = True

End Function
Function StackItem(bstack As basetask, A$, r) As Boolean
Dim p As Variant, w3 As Long, anything1 As Object, anything As mStiva
w3 = 1
If IsExp(bstack, A$, p) Then
    If bstack.lastobj Is Nothing Then
        Set anything1 = bstack.soros
        w3 = Abs(CLng(Fix(p)))
    ElseIf Not CheckStackObj(bstack, anything1, w3) Then
        MyEr "Not a stack object", "дЕМ ЕъМАИ АМТИЙЕъЛЕМО СЫЯОЩ"
        Exit Function
    ElseIf FastSymbol(A$, ",") Then
        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
            w3 = Abs(CLng(Fix(p)))
        End If
    End If
Set anything = anything1
backitem:
    If anything.Total < w3 Then
    
            MyErMacro A$, "Stack item not found at position " + CStr(w3), "дЕМ УПэЯВЕИ ТИЛч СЫЯОЩ СТГ ХщСГ " + CStr(w3)
        Set bstack.lastobj = Nothing
        StackItem = False: Exit Function

    ElseIf anything.StackItemType(w3) = "N" Then
    
    r = anything.StackItem(w3)
    
    StackItem = FastSymbol(A$, ")", True)
    Exit Function
    ElseIf anything.StackItemType(w3) = "L" Then
    
    r = anything.StackItem(w3)

    
    StackItem = FastSymbol(A$, ")", True)
    Exit Function
    ElseIf anything.StackItemType(w3) = "*" Then
    r = 0
    
    Set bstack.lastobj = anything.StackPickRef(w3).ObjectRef
    
    StackItem = FastSymbol(A$, ")", True)
    Exit Function
    Else
     
            MyErMacro A$, "Stack item isn't number at position " + CStr(w3), "г ТИЛч ТОУ СЫЯОЩ ДЕМ ЕъМАИ АЯИХЛЭР СТГ ХщСГ " + CStr(w3)
  
    StackItem = False
    End If
    Exit Function

Else
w3 = 1
Set anything = bstack.soros
GoTo backitem
End If
End Function
Public Function LambdaList(bstack As basetask) As String
On Error Resume Next
LambdaList = var(-bstack.OriginalCode).code$
End Function
Sub PrepareLabel(bstack As basetask)

   If Not bstack.IamLambda Then
  Dim mmm$


If SecureNames Then
mmm$ = sbf(bstack.OriginalCode).goodname
Else
mmm$ = here$
End If
 mmm$ = CleanStr(mmm$, ChrW(-65))
    If InStr(mmm$, "╩.") > 0 Then
        mmm$ = Mid$(mmm$, InStr(mmm$, "╩.") + 2)
    End If
   ' If AscW(MMM$) = 8191 Then MMM$ = Mid$(MMM$, 8)
    If bstack.fHere <> "" And InStr(bstack.fHere, "(") > 0 Then mmm$ = bstack.fHere + "." + mmm$
    End If
    If InStr(mmm$, ChrW(8191)) > 0 Then
    DropLeft ChrW(8191), mmm$
    If InStr(mmm$, ChrW(8191)) > 0 Then
    DropLeft ChrW(8191), mmm$
    End If
    If InStr(mmm$, ".") > 0 Then
    DropLeft ".", mmm$
    GoTo conthere
    Else
    If Right$(mmm$, 2) = "()" Then
        mmm$ = Left$(mmm$, Len(mmm$) - 2)
    End If
    
     If pagio$ = "GREEK" Then
         Form2.Label1prompt(0) = "тЕКЕСТчР "
     Else
            Form2.Label1prompt(0) = "Operator "
     End If
     End If
    Else
conthere:
    If bstack.IamThread Then
  If pagio$ = "GREEK" Then
  Form2.Label1prompt(0) = "мгла(" & (bstack.Process.id) & "): "
  Else
  Form2.Label1prompt(0) = "THREAD(" & (bstack.Process.id) & "): "
  End If
  
    Else
    If pagio$ = "GREEK" Then
        If bstack.fHere <> "" Or Right$(mmm$, 2) = "()" Then
        If bstack.IamLambda Then
        If Right$(here$, 3) = "$()" Then
            Form2.label1(0) = "калда$()"
            Else
            Form2.label1(0) = "калда()"
            End If
            Exit Sub
        Else
            Form2.Label1prompt(0) = "сУМэЯ.: "
        End If
        Else
            Form2.Label1prompt(0) = "тЛчЛА: "
        End If
  Else
        If bstack.fHere <> "" Or Right$(mmm$, 2) = "()" Then
         If bstack.IamLambda Then
         If Right$(here$, 3) = "$()" Then
            Form2.label1(0) = "LAMBDA$()"
            Else
            Form2.label1(0) = "LAMBDA()"
            End If
            Exit Sub
         Else
        Form2.Label1prompt(0) = "Func.: "
        End If
  Else
  Form2.Label1prompt(0) = "Module: "
  End If
  End If
 End If
    
    
    
    End If
    If GetThisModuleName(mmm$) Then
    If Left$(mmm$, 1) = "▀" Then
    Form2.label1(0) = GetName$(mmm$)
    Else
    Form2.label1(0) = mmm$
    End If
    Else
    Form2.label1(0) = GetName$(mmm$)
     End If
     
    
    
  
End Sub


Private Function CompareStr2(A$, b$) As Long
On Error GoTo comperr

If UserCodePage = DefCodePage Then
CompareStr2 = StrComp(A$, b$, vbTextCompare)
Else
CompareStr2 = -2 + CompareString(Clid, &H1001, StrPtr(A$), Len(A$), StrPtr(b$), Len(b$))
End If
Exit Function
comperr:
CompareStr2 = -2 + CompareString(0, 0, StrPtr(A$), Len(A$), StrPtr(b$), Len(b$))

End Function
Private Function CompareStr3(A As Variant, b As Variant) As Long
On Error GoTo comperr
If Not mTextCompare Then
CompareStr3 = StrComp(A, b)
ElseIf UserCodePage = DefCodePage Then
CompareStr3 = StrComp(A, b, vbTextCompare)
Else
CompareStr3 = -2 + CompareString(Clid, &H1001, StrPtr(A), Len(A), StrPtr(b), Len(b))
End If
Exit Function
comperr:
Err.Clear


If mTextCompare Then
If MyIsObject(A) Or MyIsObject(b) Then
Else
CompareStr3 = -2 + CompareString(0, 0, StrPtr(A), Len(A), StrPtr(b), Len(b))

Exit Function
End If
End If
MyEr "Not string found", "дЕМ БЯчЙА АКЖАЯИХЛГТИЙЭ"
End Function

Function CheckTwo(V1&, V2&) As Boolean
Dim one As Group, two As Group
If VarTypeName(var(V1&)) <> mGroup Then
    Dim a1 As Variant, b1 As Variant
    If VarTypeName(var(V1&)) = mHdlr Then
        Dim A As Object
        Set A = var(V1&)
        CheckLastHandler A
        If A.indirect >= 0 And A.indirect <= var2used Then
            Set A = var(A.indirect)
        End If
        Set a1 = A
    Else
    If MyIsObject(var(V1&)) Then
        Set a1 = var(V1&)
    Else
        a1 = var(V1&)
    End If
    
    End If
    If VarTypeName(var(V2&)) = mHdlr Then
        Dim b As Object
        Set b = var(V2&)
        CheckLastHandler b
        If b.indirect >= 0 And b.indirect <= var2used Then
            Set b = var(b.indirect)
        End If
        Set b1 = b
    Else
    If MyIsObject(var(V2&)) Then
        Set b1 = var(V2&)
    Else
        b1 = var(V2&)
    End If
    End If
    
    CheckTwo = Typename(a1) = Typename(b1)

ElseIf VarTypeName(var(V2&)) = mGroup Then
Set one = var(V1&)
If one.IamApointer Then
Set one = one.link
End If
Set two = var(V2&)
If two.IamApointer Then
Set two = two.link
End If
If one.IamSuperClass Then
If two.IamSuperClass Then
    CheckTwo = False ' no two superclass as the same, (maybe they have the same kind of members)
    ' because superclass may have unique members, but also have unique values
Else
' check if second is kind of superclass
    CheckTwo = one.SuperClassList Is two.SuperClassList
End If
Else ' check first if has the same superclass
If one.SuperClassList Is two.SuperClassList Then
If two.IamSuperClass Then
    ' so v1& as V2& if v2& is a superclass (same as before)
    CheckTwo = True
Else
' so now we have to check lists
Dim ms As mStiva2, ms2 As mStiva2
Set ms = one.PrepareSorosToCompare(var())
Set ms2 = two.PrepareSorosToCompare(var())
' check ms2 against ms
' every time we found one in ms2 we remove it from both
Dim I As Long, j As Long
again:
For I = 1 To ms2.Total
For j = 1 To ms.Total
If ms.StackItem(j) = ms2.StackItem(I) Then
If I > 1 Then ms2.MakeTopItem I
If j > 1 Then ms.MakeTopItem j
    ms.drop 1
    ms2.drop 1
GoTo again
End If
Next j
Next I
CheckTwo = ms2.Total = 0

End If
End If

End If

End If

End Function

Function ProcessIf(flag As Variant, bstack As basetask, rest$, r As Variant) As Boolean

Dim Mode As Boolean, usehandler As mHandler
Mode = flag < 1
If bstack.lastobj Is Nothing Then
flag = Int(Abs(flag > 0) * (flag - 1) - (flag <= 0) * (flag + 1) + 1)
Else
If TypeOf bstack.lastobj Is mHandler Then
Set usehandler = bstack.lastobj
If usehandler.T1 = 4 Then
Set bstack.lastobj = Nothing
Set usehandler = Nothing
flag = Int(Abs(flag > 0) * (flag - 1) - (flag <= 0) * (flag + 1) + 1)
End If
Else
flag = 1
End If
End If
Dim nowpos As Double, w1 As Long, s$
nowpos = 1
ProcessIf = True
 If Not FastSymbol(rest$, "->", True, 2) Then Exit Function
Do
    If flag = nowpos Then
        If MaybeIsSymbol(rest$, ",)") Then
            If Mode Then
            r = flag = 1
            Else
            r = 0
            End If
        Else
            If Not IsExp(bstack, rest$, r) Then
                MissNumExpr
                ProcessIf = False
                Exit Function
            End If
        End If
        ProcessIf = True
    Else
        If Not MaybeIsSymbol(rest$, ",)") Then
        w1 = 1
        s$ = aheadstatus(rest$, True, w1)
        If s$ = vbNullString Then Exit Do
        Mid$(rest$, 1, w1 - 1) = space$(w1 - 1)
        End If
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
    nowpos = nowpos + 1
    If Mode Then If nowpos > 2 Then MyEr "To many expressions", "пОККщР ЕЙЖЯэСЕИР"
Loop
If nowpos = 1 Then MyEr "Need two expressions", "вЯЕИэФОЛАИ ДУО ЕЙЖЯэСЕИР"
If Not FastSymbol(rest$, ")") Then ProcessIf = False
End Function
Function ProcessIfStr(ByVal flag As Double, bstack As basetask, rest$, ss As String) As Boolean
Dim Mode As Boolean
Mode = flag < 1
flag = Int(Abs(flag > 0) * (flag - 1) - (flag <= 0) * (flag + 1) + 1)
'Set bstack.lastobj = Nothing
Dim nowpos As Double, w1 As Long, s$
nowpos = 1
ProcessIfStr = True
 If Not FastSymbol(rest$, "->", True, 2) Then Exit Function
Do
    If flag = nowpos Then
        If MaybeIsSymbol(rest$, ",)") Then
            ss = vbNullString
        Else
            If Not IsStrExp(bstack, rest$, ss) Then
                MissStringExpr
                ProcessIfStr = False
                Exit Function
            End If
        End If
        ProcessIfStr = True
    Else
        If Not MaybeIsSymbol(rest$, ",)") Then
        w1 = 1
        s$ = aheadstatus(rest$, True, w1)
        If s$ = vbNullString Then Exit Do
        Mid$(rest$, 1, w1 - 1) = space$(w1 - 1)
        End If
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
    nowpos = nowpos + 1
    If Mode Then If nowpos > 2 Then MyEr "To many expressions", "пОККщР ЕЙЖЯэСЕИР"
Loop
If nowpos = 1 Then MyEr "Need two xpressions", "вЯЕИэФОЛАИ ДУО ЕЙЖЯэСЕИР"
If Not FastSymbol(rest$, ")") Then ProcessIfStr = False
End Function
Function GETarrayFROMstr(A$, b$) As mHandler
Dim pppp As mArray, aa() As String
aa = Split(A$, b$)
Set pppp = New mArray
If UBound(aa) = -1 Then

Else
Dim I As Long
pppp.PushDim UBound(aa) + 1
pppp.PushEnd
For I = 0 To UBound(aa)
pppp.item(I) = aa(I)
Next I
End If
Set GETarrayFROMstr = New mHandler
GETarrayFROMstr.T1 = 3
Set GETarrayFROMstr.objref = pppp

End Function
Function CheckThis(bstack As basetask, W$, b$, v As Long, Lang As Long) As Long
Dim bb$
If Len(W$) > 3 Then
    If Lang = 1 Then
        If Left$(W$, 1) = "T" Then
            If Left$(W$, 4) = "THIS" Then
                If Len(W$) = 4 Then
                    bb$ = vbNullString
                    If bstack.GetDotNew(bb$, 1) < 0 Then
                        If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                         If GetGlobalVar(Left$(bb$, Len(bb$) - 1), v) Then W$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetlocalVar(Left$(bb$, Len(bb$) - 1), v) Then W$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetGlobalVar(W$, v) Then GoTo found
                    End If
                ElseIf Mid$(W$, 5, 1) = "." Then
                    If Len(bstack.UseGroupname) > 0 Then
                        bb$ = bstack.UseGroupname + Mid$(W$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings W$, bb$: GoTo found
                        bb$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(W$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings W$, bb$: GoTo found
                        
                    Else
                        bb$ = vbNullString
                        If bstack.GetDotNew(bb$, 1) < 0 Then
                            If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                            W$ = Left$(bb$, Len(bb$) - 1) + Mid$(W$, 5)
                            If GetGlobalVar(W$, v) Then GoTo found
                        End If
                    End If
                End If
            End If
        End If
    Else
        If Left$(W$, 1) = "а" Then
            If Left$(W$, 4) = "ауто" Then
                If Len(W$) = 4 Then
                    If bstack.GetDotNew(bb$, 1) < 0 Then
                        If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                         If GetGlobalVar(Left$(bb$, Len(bb$) - 1), v) Then W$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetlocalVar(Left$(bb$, Len(bb$) - 1), v) Then W$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetGlobalVar(W$, v) Then GoTo found
                    End If
                ElseIf Mid$(W$, 5, 1) = "." Then
                     If Len(bstack.UseGroupname) > 0 Then
                        bb$ = bstack.UseGroupname + Mid$(W$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings W$, bb$: GoTo found
                        bb$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(W$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings W$, bb$: GoTo found
                    Else
                        bb$ = vbNullString
                        If bstack.GetDotNew(bb$, 1) < 0 Then
                            If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                            W$ = Left$(bb$, Len(bb$) - 1) + Mid$(W$, 5)
                            If GetGlobalVar(W$, v) Then GoTo found
                        End If
                    End If
                End If
            End If
        End If
    End If
End If
Exit Function
found:
CheckThis = 1
If FastSymbol(b$, "=") Then Exit Function
If FastSymbol(b$, "<=", , 2) Then Exit Function
If FastSymbol(b$, "->", , 2) Then CheckThis = 3: Exit Function
CheckThis = 2
End Function
Function myHwnd(bstack As basetask) As Double
If Typename(bstack.Owner) = "GuiM2000" Then
myHwnd = bstack.Owner.hWnd
Else
If ttl Then
myHwnd = Form3.hWnd
Else
myHwnd = bstack.Owner.hWnd
End If
End If
End Function
Function GetName(ByVal part$) As String
again:
If InStrRev(part$, ChrW(&H1FFF)) > 0 Then
If InStr(part$, ".") > 0 Then
    part$ = Mid$(part$, InStr(part$, ".") + 1)
    GoTo again
End If
End If
If LenB(part$) = 0 Then Exit Function
If InStr(part$, "╩.") > 0 Then
part$ = Mid$(part$, InStr(part$, "╩.") + 2)
If InStr(part$, ChrW(&H1FFF)) > 0 Then
If InStr(part$, ".") > 0 Then
    part$ = Mid$(part$, InStr(part$, ".") + 1)
    GoTo again
End If
End If
ElseIf InStr(part$, "⌡") > 0 Then
If Left$(part$, 1) = "▀" Then
part$ = sbf(val(Mid$(part$, 2))).goodname + Mid$(part$, InStr(part$, "⌡") + 1)
End If
ElseIf iRVAL22(part$) > 0 Then
If InStr(part$, "╩╚") = 0 Then
GetName = vbNullString 'part$
Exit Function
Else
part$ = sbf(iRVAL22(part$)).goodname
End If
If Left$(part$, 1) = "▀" Then
part$ = sbf(val(Mid$(part$, 2))).goodname + Mid$(part$, InStr(part$, "⌡") + 1)
End If
GoTo again
End If
GetName = part$

End Function
Sub FeedArray(pppp As mArray, v As Long, fromthis As Object, Optional convert As Boolean = False)
Dim mm As mStiva, myobject As Object, p As Variant, usehandler As mHandler
Set mm = fromthis
Do While Not mm.IsEmpty
If v >= pppp.count Then Exit Do
If mm.PopType = ">" Then
mm.drop 1
pppp.item(v) = 0&
v = v + 1
ElseIf mm.StackItemTypeIsObject(1) Then
        pppp.item(v) = -1
        Set myobject = mm.PopObj
            
        If Typename$(myobject) = mGroup Then
              If myobject.IamFloatGroup Then
                     Set pppp.item(v) = myobject
              Else
                           BadGroupHandle
                           Set myobject = Nothing
                           Exit Sub
              End If
         ElseIf Typename$(myobject) = "lambda" Then
                  Set pppp.item(v) = myobject
          ElseIf Typename$(myobject) = myArray Then
              If myobject.Arr Then
                      Set pppp.item(v) = CopyArray(myobject)
                  Else
                      Set pppp.item(v) = myobject
                  End If
         ElseIf Typename$(myobject) = mHdlr Then
               If myobject.indirect > -0 Then
                   Set pppp.item(v) = myobject
               Else
                   p = myobject.T1
                   If CheckDeepAny(myobject) Then
                       If TypeOf myobject Is mHandler Then
                           Set pppp.item(v) = myobject
                       Else
                        Set usehandler = New mHandler
                           Set pppp.item(v) = usehandler
                           usehandler.T1 = p
                           Set usehandler.objref = myobject
                       End If
                       
                   End If
              End If
          ElseIf Typename$(myobject) = mProp Then
                  Set pppp.item(v) = myobject
          End If
          Set myobject = Nothing
        '  mm.drop 1
Else
If pppp.ItemType(v) = doc Then
    If mm.PopType = "S" Then
        CheckVar pppp.item(v), mm.PopStr
    Else
    ' ERROR
        Set pppp.item(v) = New Document
        mm.drop 1
    End If
ElseIf Not mm.PopType = "S" Then
If convert Then
pppp.item(v) = MyRound(mm.StackItem(1), 0)
mm.drop 1
Else
pppp.item(v) = mm.StackItem(1)
mm.drop 1
End If
Else
pppp.item(v) = mm.StackItem(1)
mm.drop 1
End If


End If
v = v + 1
Loop
Set fromthis = Nothing

End Sub
Function CurrentStackSize() As Double
'If IsWine Then Exit Function
On Error GoTo 1000
Dim endaddress As Long
ua = startaddress
UB = VarPtr(endaddress)
' IN IDE USING BREAK ON ALL ERROR STOP HERE - THIS IS OK
' CHANGE THE ERROR LEVEL AND AFTER THAT CHANGE IT AGAIN
CurrentStackSize = uintnew(ua) - uintnew(UB) - 300 ' - (1 - m_bInIDE) * 93
Exit Function
1000
Err.Raise 8000
End Function
Function ClaimStack() As Long
If IsWine Then Exit Function
Static once11 As Boolean
ClaimStack = findstack
If once11 Then Exit Function
once11 = True
repeatme
ClaimStack = findstack
End Function
Function repeatme()
On Error GoTo there
findstack = CurrentStackSize()
On Error GoTo there
repeatme
there:
End Function
Function GetModuleName(b As basetask, where$) As String
If SecureNames Then
If b.OriginalCode < 0 Then
    If var2used <= -b.OriginalCode Then Exit Function
    GetModuleName = GetName(var(-b.OriginalCode).Name)
Else
    GetModuleName = GetName(sbf(b.OriginalCode).goodname)
    End If
Else
    GetModuleName = GetName(StripRVAL(where$))
End If
End Function
Private Function compareStr4(A$, b$) As Long   ' here is not byval as in fastcollection
Dim I As Long, j As Long, a1$, b1$, P1 As Variant, P2 As Variant, n$, K As Long, k1 As Long
If CompareString(Clid, &H1000, StrPtr(A$), Len(A$), StrPtr(b$), Len(b$)) = 2 Then Exit Function
n$ = "[-0-9.]"
K = Sgn(Len(A$) - Len(b$))
k1 = K
again:
j = IIf(Len(A$) >= Len(b$), Len(b$), Len(A$))

For I = 1 To j

    If Mid$(A$, I, 1) Like n$ Then
    a1$ = Mid$(A$, I)
    b1$ = Mid$(b$, I)
        IsNumberD2 a1$, P1
       
        If IsNumberD2(b1$, P2) Then
            compareStr4 = Sgn(MyRound(P1, 8) - MyRound(P2, 8))
            If compareStr4 = 0 Then
                If Len(a1$) * Len(b1$) <> 0 Then
                    If Len(n$) > 6 Then n$ = "[-0-9]"
                    K = Sgn(Len(a1$) - Len(b1$))
                     
                    A$ = a1$
                    b$ = b1$
                   
                    GoTo again
                End If
                If Len(a1$) + Len(b1$) = 0 Then
                    compareStr4 = K
                Else
                    compareStr4 = Sgn(Len(a1$) - Len(b1$))
                End If
                Exit Function
             End If
            Exit Function
        Else
        A$ = Mid$(A$, I)
    b$ = Mid$(b$, I)
    IsNumberD2 A$, P1
       
          If Len(A$) > 0 Then
       
            Select Case CompareString(Clid, &H1000, StrPtr(A$), Len(A$), StrPtr(b$), Len(b$))
                Case 1, 3
                compareStr4 = -1
                Case 2
                If K > 0 Then
                compareStr4 = -1
                Else
                compareStr4 = 1
                End If
            End Select
        Else
        compareStr4 = -1
        End If
        End If
        Exit Function
    ElseIf Mid$(b$, I, 1) Like n$ Then
    A$ = Mid$(A$, I)
    b$ = Mid$(b$, I)
    IsNumberD2 b$, P1
    If Len(b$) > 0 Then
       
            Select Case CompareString(Clid, &H1000, StrPtr(A$), Len(A$), StrPtr(b$), Len(b$))
                Case 3
                compareStr4 = 1
                Case 1, 2
                If K < 0 Then
                compareStr4 = 1
                Else
                compareStr4 = -1
                End If
                
                
            End Select
        Else
        compareStr4 = 1
        End If
        Exit Function
    End If
    compareStr4 = -2 + CompareString(Clid, 0, StrPtr(A$) + I * 2 - 2, 1, StrPtr(b$) + I * 2 - 2, 1)
    If compareStr4 <> 0 Then
    Exit Function
    End If
Next I
compareStr4 = Sgn(Len(A$) - Len(b$))
If compareStr4 = 0 Then compareStr4 = k1
End Function
Private Function checkbreak(bstack As basetask, b$, once As Boolean) As Boolean
Static Busy As Boolean
checkbreak = NOEXECUTION
If lckfrm > 0 Then Exit Function
Dim btimer As Long
Call GetSystemTimeAsFileTime(basictimer)
btimer = MemLong(VarPtr(basictimer))
If (btimer And &H28000) = (timestamp And &H28000) Then Exit Function
timestamp = btimer
If Forms.count > 5 Then Exit Function
If Busy Then Exit Function
If Not bstack.IamAnEvent Then
If bstack.TaskMain Then Exit Function
If KeyPressed2(&H11, &H43) Then
Busy = True
Form1.EXECSTOP
timestamp = basictimer
Busy = False
checkbreak = NOEXECUTION
Exit Function
ElseIf KeyPressedLong(&H13) = 0 Then
Exit Function
End If
Busy = True
ResetBreak
If Form1.mybreak1() Then
    Modalid = 0
    If Not TaskMaster Is Nothing Then TaskMaster.Dispose
    NOEXECUTION = True
    MOUT = True
    MKEY$ = "@Start" + Chr$(13)
    b$ = " "
    MyEr "", ""
    once = False
    Prefresh(GetCode(bstack.Owner)).k1 = 0
    MyDoEvents0 bstack.Owner
    checkbreak = True
    End If
End If
ResetBreak
Call GetSystemTimeAsFileTime(basictimer)
timestamp = MemLong(VarPtr(basictimer))
Busy = False
End Function
Private Function checkbreakEsc(bstack As basetask) As Boolean
Static Busy As Boolean, tmstp As Long
If bstack Is Nothing Then checkbreakEsc = True: Exit Function
If lckfrm > 0 Then
If TaskMaster Is Nothing Then Exit Function
If TaskMaster.OnlyMusic Then TaskMaster.TimerTick
checkbreakEsc = NOEXECUTION 'Or checkbreakEsc
Exit Function
End If
Call GetSystemTimeAsFileTime(basictimer)
tmstp = MemLong(VarPtr(basictimer))
If Not TaskMaster Is Nothing Then
    If (tmstp And &H380) = (timestamp And &H380) Then
        If TaskMaster.OnlyMusic Then
            TaskMaster.TimerTick
        End If
    End If
End If
If Not extreme Then
    If (tmstp And &H3800) = (timestamp And &H3800) Then Exit Function
    If escok Then If myexit2(bstack) Then checkbreakEsc = True: Exit Function
Else
    If (tmstp And &H3000) = (timestamp And &H3000) Then Exit Function
End If
timestamp = tmstp
If Forms.count > 5 Then Exit Function
If Busy Then Exit Function
If Not bstack.IamAnEvent Then
If bstack.TaskMain Then Exit Function
If KeyPressed2(&H11, &H43) Then
Busy = True
Form1.EXECSTOP
Call GetSystemTimeAsFileTime(basictimer)
timestamp = MemLong(VarPtr(basictimer))
Busy = False
checkbreakEsc = NOEXECUTION
Exit Function
ElseIf KeyPressedLong(&H13) = 0 Then
Exit Function
End If
Busy = True
ResetBreak
If Form1.mybreak1() Then
    Modalid = 0
    If Not TaskMaster Is Nothing Then TaskMaster.Dispose
    NOEXECUTION = True
    MOUT = True
    MKEY$ = "@Start" + Chr$(13)
    'b$ = " "
    MyEr "", ""
    'once = False
    Prefresh(GetCode(bstack.Owner)).k1 = 0
    MyDoEvents0 bstack.Owner
    checkbreakEsc = True
    End If
End If
ResetBreak
Call GetSystemTimeAsFileTime(basictimer)
timestamp = MemLong(VarPtr(basictimer))
Busy = False
End Function
Public Sub ClearStr(A$)
Dim I As Long, j As Long
                While FastSymbol(A$, vbCrLf, , 2)
                I = 1
                While FastOperator(A$, vbCrLf, I, 2)
                Wend
                j = Len(A$)
                If j = 0 Then Exit Sub
                I = MyTrimL(A$)
                If I > j Then Exit Sub
                Wend
End Sub
Private Function IsRandom(bstack As basetask, A$, r As Variant) As Boolean
If FastSymbol(A$, "!") Then
If IsExp(bstack, A$, r, , True) Then
'' CHOOSE SEED AND SAVEIT TO BASESTACK
On Error Resume Next
simplestack1 = rndbase
RandomizeIt rndbase, CLng(r)

If Err Then
Err.Clear
r = 0
End If

Else
rndbase = simplestack1
End If
     
ElseIf IsExp(bstack, A$, r, , True) Then
    r = Int(r)
    
        If FastSymbol(A$, ",") Then
        Dim p As Variant
        If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then IsRandom = False: Exit Function
        p = MyRound(p)
        Dim pp As Variant
        If p > r Then pp = p: p = r: r = pp
        Else
        p = 0
        
        End If
    
    r = Int((r - p + 1) * RndM(rndbase) + p)
     On Error GoTo 0
    IsRandom = True
    Else
    Call GetSystemTimeAsFileTime(basictimer)
      RandomizeIt rndbase, MemLong(VarPtr(basictimer))
     r = True
      
    End If
    IsRandom = FastSymbol(A$, ")", True)

End Function
Private Function IsArrayFun(bstack As basetask, A$, r As Variant) As Boolean
Dim s$, w1 As Long, pppp As mArray, anything As Object, p As Variant, ms As mStiva, usehandler As mHandler, RF As refArray
If IsStrExp(bstack, A$, s$) Then
        If bstack.lastobj Is Nothing Then
            If Right$("!!" + s$, 2) = "()" Then
                Mid$(s$, Len(s$), 1) = " "
                s$ = RTrim$(s$)
             Else
                w1 = InStr("!" + s$, "(") - 1
                If w1 > 0 And w1 <= Len(s$) Then
                    s$ = Left$(s$, w1)
                ElseIf neoGetArray(bstack, s$, pppp) Then
                GoTo check123678
                Else
                s$ = s$ + "("
                End If
            End If
            If neoGetArray(bstack, s$, pppp) Then
check123678:
                If Not pppp.Arr Then NotArray: Exit Function
                If FastSymbol(A$, ",") Then
                    IsArrayFun = NeoGetArrayItem(pppp, bstack, s$, w1, A$)
                Else
                    IsArrayFun = FastSymbol(A$, ")", True)
                    w1 = 0
                    
                   ' w1 = pppp.index
                End If
checkIterator:
                If Not pppp.IsEmpty Then
                    If MyIsObject(pppp.item(w1)) Then
                        Set anything = pppp.item(w1)
                        If Not anything Is Nothing Then
                        If TypeOf anything Is Group Then
                            bstack.soros.CopyGroupObj pppp.item(w1), anything
                            Set bstack.lastobj = anything
                        Else
                            Set bstack.lastobj = anything
                        End If
                        
                        Else
                            Set bstack.lastobj = Nothing
                        End If
                        r = 0
                    Else
                        Set bstack.lastobj = Nothing
                        
                        r = pppp.itemnumeric(w1)
                    End If
                Else
                    
                    mEmptyArray
                End If
            Else
                 Set bstack.lastobj = Nothing
                NotArray
            End If

                 Exit Function
            
        ElseIf TypeOf bstack.lastobj Is mArray Then
                Set pppp = bstack.lastobj
                GoTo check123678
        Else
            Set bstack.lastobj = Nothing
            SyntaxError
        End If
    ElseIf IsExp(bstack, A$, p, nostring:=True) Then
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                If usehandler.indirect >= 0 Then
                    Set pppp = var(usehandler.indirect)
                    If usehandler.UseIterator Then
                    pppp.Index = usehandler.index_cursor
                    End If
                    GoTo check123678
                ElseIf TypeOf usehandler.objref Is mArray Then
                    Set pppp = usehandler.objref
                    If usehandler.UseIterator Then
                    pppp.Index = usehandler.index_cursor
                    End If
                    If usehandler.UseIterator Then
                    If Not pppp.Arr Then NotArray: Exit Function
                    If FastSymbol(A$, ",") Then
                        Set bstack.lastobj = Nothing
                        Set usehandler = Nothing
                        IsArrayFun = IsExp(bstack, A$, r, , True)
                        IsArrayFun = FastSymbol(A$, ")", True)
                        w1 = r
                    Else
                        IsArrayFun = FastSymbol(A$, ")", True)
                        w1 = pppp.Index
                    End If
                    If Not IsArrayFun Then Exit Function
                    GoTo checkIterator
                    Else
                    GoTo check123678
                    End If
                ElseIf TypeOf usehandler.objref Is mStiva Then
                    Set ms = usehandler.objref
                    Set bstack.lastobj = Nothing
                    Set usehandler = Nothing
                    If FastSymbol(A$, ",") Then
                    If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                    Set bstack.lastobj = ms.ExportArray(CLng(MyRound(p)))
                    End If
                    Else
                        Set bstack.lastobj = ms.ExportArray(ms.count)
                        
                    End If
                    Set ms = Nothing
                    IsArrayFun = FastSymbol(A$, ")", True)
                    Exit Function
                Else
                     Set bstack.lastobj = Nothing
                    NotArray
                End If
            ElseIf TypeOf bstack.lastobj Is mArray Then
                If FastSymbol(A$, ")") Then
                IsArrayFun = True
                Exit Function
                End If
                Set pppp = bstack.lastobj
                
                GoTo check123678
            ElseIf TypeOf bstack.lastobj Is refArray Then
                Set pppp = New mArray
                Set RF = bstack.lastobj
                pppp.SupportRefArray CVar(RF)
                Set bstack.lastobj = pppp
                IsArrayFun = FastSymbol(A$, ")", True)
                
            End If
        End If
    Else
        Set bstack.lastobj = New mArray
        IsArrayFun = FastSymbol(A$, ")", True)
    End If
End Function
Private Function IsStackObj(v$, bstack As basetask, A$, r As Variant) As Boolean
Dim anything As Object, anything2 As Object, p As Variant, usehandler As mHandler, ms As mStiva
    Set usehandler = New mHandler
    Set anything = usehandler
    usehandler.T1 = 3
    
    If FastSymbol(A$, ":=", , 2) Then
        
        If Not GetData(bstack, A$, anything2) Then
            Exit Function
        End If
        Set usehandler.objref = anything2
        Set anything2 = Nothing
    ElseIf IsLabelSymbolNew(A$, "йаты", "DOWN", Abs(AscW(v$) = 83)) Then
    
        If IsExp(bstack, A$, p) Then
            If Not bstack.lastobj Is Nothing Then
                Set anything2 = bstack.lastobj
                If TypeOf anything2 Is mHandler Then
                    Set usehandler = anything2
                    If usehandler.T1 = 3 Then
                        If Not usehandler.objref Is Nothing Then
                            If TypeOf usehandler.objref Is mStiva Then
                                Set ms = New mStiva
                                FastSymbol A$, ","
                                If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                                    ms.SplitStackBottom anything2, CLng(Fix(p))
                                End If
                                Set usehandler = anything
                                Set usehandler.objref = ms
                                GoTo normalexit
                            End If
                        End If
                    End If
                End If
            End If
        End If
        NoStackObjectFound A$
    ElseIf IsLabelSymbolNew(A$, "амы", "UP", Abs(AscW(v$) = 83)) Then
        If IsExp(bstack, A$, p) Then
            If Not bstack.lastobj Is Nothing Then
                Set anything2 = bstack.lastobj
                If TypeOf anything2 Is mHandler Then
                    Set usehandler = anything2
                    If usehandler.T1 = 3 Then
                        If Not usehandler.objref Is Nothing Then
                            If TypeOf usehandler.objref Is mStiva Then
                                Set ms = New mStiva
                                FastSymbol A$, ","
                                If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                                    ms.SplitStackTop anything2, CLng(Fix(p))
                                End If
                                Set usehandler = anything
                                Set usehandler.objref = ms
                                GoTo normalexit
                            End If
                        End If
                    End If
                End If
            End If
        End If
        NoStackObjectFound A$
    Else
        Set usehandler.objref = New mStiva
    End If
normalexit:
    Set bstack.lastobj = anything
    r = 0
    IsStackObj = True

End Function
Private Function IsStack(bstack As basetask, A$, r As Variant) As Boolean
Dim anything As Object, pppp As mArray, p As Variant, anything2 As Object, usehandler As mHandler, usestiva As mStiva
If IsExp(bstack, A$, r) Then
    If CheckStackObj(bstack, anything) Then
            If TypeOf anything Is mArray Then
                Set pppp = anything
                Set usestiva = New mStiva
                usestiva.MergeBottomCopyArray pppp
                Set usehandler = New mHandler
                Set bstack.lastobj = usehandler
                usehandler.T1 = 3
                Set usehandler.objref = usestiva
                Set usestiva = Nothing
                Set usehandler = Nothing
                IsStack = FastSymbol(A$, ")", True)
                Exit Function
            End If
            If Not TypeOf anything Is mStiva Then GoTo stack12948
            If FastSymbol(A$, ",") Then
stack99981:
                Set usestiva = anything
                If IsExp(bstack, A$, p) Then
                    If p <> 0 Then
                        Set anything = usestiva.CopyMe2(CLng(Fix(p)))
                    Else
                        If Not bstack.lastobj Is Nothing Then
                            If CheckStackObj(bstack, anything2) Then
                                    Set usestiva = anything2
                                    Set anything2 = usestiva.CopyMe()
                                    Set usestiva = anything
                                    Set anything = usestiva.MergeFromOther(anything2)
                                    If FastSymbol(A$, ",") Then GoTo stack99981
                                    
                                Else
                                    GoTo stack129481
                                End If
                        Else
stack129481:
                         NoStackObjectToMerge
                        End If
                        
                    End If
                Else
                MissParam A$
                Exit Function
                End If
            Else
                Set usestiva = anything
                Set anything = usestiva.CopyMe()
            End If
            Set usehandler = New mHandler
            usehandler.T1 = 3
            Set usehandler.objref = anything
            Set bstack.lastobj = usehandler
            Set anything = Nothing
            Set usehandler = Nothing
            Set usestiva = Nothing
        Else
stack12948:
        MyEr "Not a stack object", "дЕМ БЯчЙА АМТИЙЕъЛЕМО СЫЯОЩ"
        End If
        IsStack = FastSymbol(A$, ")", True)
        Exit Function
Else
        MissParam A$
End If
End Function
Private Function IsCeil(bstack As basetask, A$, r As Variant) As Boolean
Dim pp As Variant
    If IsExp(bstack, A$, r, , True) Then
    ''On Error Resume Next
    If FastSymbol(A$, ")") Then
            r = IIf(Fix(r) = r, r, Int(r) + 1)
            IsCeil = True
    Else
            MissParam A$
    End If
    End If
 
 End Function
Private Function IsFloor(bstack As basetask, A$, r As Variant) As Boolean
Dim pp As Variant
    If IsExp(bstack, A$, r, , True) Then
    ''On Error Resume Next
    If FastSymbol(A$, ")") Then
            r = Int(r)
            IsFloor = True
    Else
            MissParam A$
    End If
    End If
 
 End Function
Private Function IsRound(bstack As basetask, A$, r As Variant) As Boolean
Dim pp As Variant, I As Integer
    If IsExp(bstack, A$, r, , True) Then
    On Error Resume Next
    If FastSymbol(A$, ")") Then
            If TypeOf r Is cxComplex Then
                r.r = MyRound(r.r, 13)
                r.I = MyRound(r.I, 13)
            Else
                r = MyRound(r, 13)
            End If
            IsRound = True
    ElseIf FastSymbol(A$, ",", True) Then
        If IsExp(bstack, A$, pp, , True) Then
            I = CInt(pp)
            If TypeOf r Is cxComplex Then
                r.r = MyRound(r.r, I)
                r.I = MyRound(r.I, I)
            Else
                r = MyRound(r, I)
            End If
          If Err.Number > 0 Then Err.Clear
     IsRound = FastSymbol(A$, ")", True)
     End If
    Else
        MissParam A$
    End If
    End If
End Function
Private Function IsInt(bstack As basetask, A$, r As Variant) As Boolean
    If IsExp(bstack, A$, r, , True) Then
    On Error Resume Next
    Set bstack.lastobj = Nothing
    r = Int(r)
    If Err.Number > 0 Then
    
    MyErMacro A$, "long conversion failed", "г ЛЕТАТЯОПч СЕ АЙщЯАИО АПщТУВЕ"
    Exit Function
    End If
    On Error GoTo 0
    IsInt = FastSymbol(A$, ")", True)
    Else
                    
                MissParam A$
    
    
    End If
 
End Function
Private Function IsUint(bstack As basetask, A$, r As Variant) As Boolean
Dim z As Integer, I As Long
If IsExp(bstack, A$, r, , True) Then
z = VarType(r)
 If z = vbInteger Then
     On Error Resume Next
    
        r = UINT(r)
     
        On Error GoTo 0
ElseIf z = 20 Then
If r < 0 Then
r = CDec(r) + maxlonglong
Else
r = CDec(r)

End If
ElseIf z = vbLong Then
I = r
r = Zero64
PutMem4 VarPtr(r) + 8, I

Else
    On Error Resume Next
        If r > 2147483647# Then
         MyErMacro A$, "Overflow long, expect lower than (2147483648)", "уПЕЯВЕъКИСГ АЙЕЯАъОУ, ПЕЯИЛщМЫ ЛИЙЯЭТЕЯО АПЭ (2147483648)"
          
        Exit Function
    ElseIf r < -2147483648# Then
        MyErMacro A$, "Overflow long, expect greater than (-2147483649)", "уПЕЯВЕъКИСГ АЙЕЯАъОУ, ПЕЯИЛщМЫ ЛЕЦАКЩТЕЯО АПЭ (-2147483649)"
         IsUint = False
        Exit Function
    End If
    
    r = uintnew(r)
    If Err.Number > 0 Then
        MyErMacro A$, "Sign to Unsigned long failed", "г ЛЕТАТЯОПч АЙЕЯАъОУ ЛЕ ПЯЭСГЛО СЕ АЙщЯАИО ВЫЯъР ПЯЭСГЛО АПщТУВЕ"
        IsUint = False
        Exit Function
    End If
    On Error GoTo 0
End If
    IsUint = FastSymbol(A$, ")", True)
    Exit Function
       Else
                    
                MissParam A$
    End If
End Function
Private Function IsSint(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant, rB As Byte, ri As Integer, dn As Long, rd As Double, usehandler As mHandler
p = 4
 If IsExp(bstack, A$, r) Then
 If Not bstack.lastobj Is Nothing Then
If Not TypeOf bstack.lastobj Is mHandler Then: Exit Function
Set usehandler = bstack.lastobj
 With usehandler
    If .T1 = 4 Then Set bstack.lastobj = Nothing: GoTo conthere
    If .T1 <> 2 Then GoTo err1256
    If Not TypeOf .objref Is MemBlock Then GoTo err1256
    If Not FastSymbol(A$, ",") Then GoTo err1256
    If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then GoTo err1256

            Select Case .objref.ItemSize
            Case 1
                If .objref.ValidArea2(p, 1) Then
                GetMem1 .objref.GetPtr(p), rB
                r = CInt(cUbyte(rB))
                   Else
                    GoTo err1256
                End If
            Case 2
                If .objref.ValidArea2(p, 2) Then
                GetMem2 .objref.GetPtr(p), ri
                    r = ri
   
                Else
                    GoTo err1256
                End If
            Case 8
                If .objref.ValidArea2(p, 8) Then
                GetMem8 .objref.GetPtr(p), rd
                r = rd
                Else
                    GoTo err1256
                End If
            Case 4
                If .objref.ValidArea2(p, 4) Then
                GetMem4 .objref.GetPtr(p), dn
                r = dn
                
            Else
err1256:
                Set bstack.lastobj = Nothing
                Set usehandler = Nothing
                MyErMacro A$, "Wrong Size-Position for reading buffer", "кэХОР лщЦЕХОР-ХщСГ, ЦИА ДИэБАСЛА дИэЯХЯЫСГР"
                
                Exit Function
                End If
            End Select
            
 End With
 Set bstack.lastobj = Nothing
 Set usehandler = Nothing
  IsSint = FastSymbol(A$, ")", True)
    Exit Function
 End If
conthere:
 If FastSymbol(A$, ",") Then
 If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
 If p = 4 Then GoTo contsint1
 
 On Error Resume Next
    If r < 0 Then
    
      MyErMacro A$, "Unsigned Integer can't be negative", "о ВЫЯъР ПЯЭСГЛО АЙщЯАИОР ДЕМ ЛПОЯЕъ МА ЕъМАИ АЯМГТИЙЭР"
   
    Exit Function
    End If
    If p = 8 Then
        r = SignInt64(r)
    ElseIf p = 2 Then
        r = cUint(signlong(r))
    Else
        r = cUbyte(signlong(r))
    End If
    If Err.Number > 0 Then
    If p <= 4 Then
        Err.Clear
        r = SignInt64(r)
    End If
    If Err.Number > 0 Then
     Unsignlongfailed A$
    IsSint = False
    Exit Function
    End If
    End If
    On Error GoTo 0
  IsSint = FastSymbol(A$, ")", True)
    Exit Function
    
 End If
 Else
contsint1:
    On Error Resume Next
    If r < 0 Then
        Unsignlongnegative A$
    Exit Function
    End If
    r = signlong(r)
    If Err.Number > 0 Then
     Err.Clear
        r = SignInt64(r)
    If Err.Number > 0 Then
    
    
    Unsignlongfailed A$

    IsSint = False
    Exit Function
    End If
    End If
    End If
    On Error GoTo 0
  IsSint = FastSymbol(A$, ")", True)
    Exit Function
      Else
                    
                MissParam A$
    End If
End Function
Private Function IsUsgn(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, , True) Then
 
    On Error Resume Next
    If r > Pow2minusOne(32) Then r = Pow2minusOne(32)
    r = Fix(r)
    If r < 0 Then r = 0
    On Error GoTo 0
IsUsgn = FastSymbol(A$, ")", True)
    Exit Function
       Else
                    
                MissParam A$
    End If
End Function
Private Function IsLOWORD(bstack As basetask, A$, r As Variant) As Boolean
If IsExp(bstack, A$, r, , True) Then
    On Error Resume Next
    
    r = Int((r - Int(r / 65536#) * 65536#))
    If Err.Number > 0 Then
    
    WrongArgument A$
        Exit Function
    
    End If
    On Error GoTo 0
    
   IsLOWORD = FastSymbol(A$, ")", True)
        Else
                
                MissParam A$
 End If
End Function
Private Function IsHIWORD(bstack As basetask, A$, r As Variant) As Boolean
  If IsExp(bstack, A$, r, , True) Then
    On Error Resume Next
    
    r = Int(Int(r / 256) / 256)
    If Err.Number > 0 Then
    
    WrongArgument A$
  
    IsHIWORD = False
    Exit Function
    End If
    On Error GoTo 0
    
IsHIWORD = FastSymbol(A$, ")", True)
      Else
                
                MissParam A$
    
    End If
End Function
Private Function IsLen(bstack As basetask, A$, r As Variant) As Boolean
Dim anything As Object, p As Variant, s$, usehandler As mHandler, rA As refArray
    If IsExp(bstack, A$, p) Then
len1234:
        If bstack.lastobj Is Nothing Then GoTo bypass1
        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
            While Typename$(usehandler.objref) = mHdlr
            Set usehandler = bstack.lastobj
            Set bstack.lastobj = usehandler.objref
            Wend
            
            Set bstack.lastobj = Nothing
            With usehandler
                If .indirect < 0 Then
                
                    If .T1 = 1 Then
                            If .objref.structLen > 0 Then
                                r = .objref.structLen
                            Else
                                r = .objref.count
                            End If
                            IsLen = FastSymbol(A$, ")", True)
                        Exit Function
                    ElseIf .T1 = 2 Then
                        r = .objref.SizeByte()
                        IsLen = FastSymbol(A$, ")", True)
                        Exit Function
                    ElseIf .T1 = 3 Then
                        ' if CheckDeepAny
                        Set anything = usehandler
                        If CheckDeepAny(anything) Then
                            If Typename(anything) = mHdlr Then
                                Set usehandler = anything
                                r = usehandler.objref.count
                            Else
                                r = anything.count
                            End If
                        Else
                            r = 0
                        End If
                        IsLen = FastSymbol(A$, ")", True)
                        Exit Function
                    ElseIf .T1 = 0 Then
                        r = 0
                        IsLen = FastSymbol(A$, ")", True)
                        Exit Function
                    ElseIf .T1 = 4 Then
                        r = usehandler.index_start
                        IsLen = FastSymbol(A$, ")", True)
                        Exit Function
                    End If
                Else
                    IsLen = FastSymbol(A$, ")", True)
                    r = -1
                End If
            End With
        ElseIf TypeOf bstack.lastobj Is mArray Then
                r = bstack.lastobj.count
                IsLen = FastSymbol(A$, ")", True)
                Set bstack.lastobj = Nothing
                Exit Function
        ElseIf TypeOf bstack.lastobj Is refArray Then
                
                Set rA = bstack.lastobj
                If rA.MarkTwoDimension Then
                    If FastSymbol1(A$, ",") Then
                        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                            p = Abs(Int(p))
                            r = rA.count(p)
                        Else
                            MissParam A$
                            Exit Function
                        End If
                    Else
                        r = rA.count
                    End If
                Else
                    r = rA.count(0)
                End If
                IsLen = FastSymbol(A$, ")", True)
                Set bstack.lastobj = Nothing
                Exit Function
        Else
bypass1:
                If VarType(p) = vbString Then
                    r = CDbl(Len(p) - (LenB(p) Mod 2 = 1) / 2#)
                    IsLen = FastSymbol(A$, ")", True)
                    Exit Function
                ElseIf MemInt(VarPtr(p)) = 36 Then
                    r = LenB(p)
                    IsLen = FastSymbol(A$, ")", True)
                    Exit Function
                Else
                r = -1
                End If
                IsLen = FastSymbol(A$, ")", True)
                Set bstack.lastobj = Nothing
        End If
        MissParam A$
    ElseIf IsStrExp(bstack, A$, s$) Then
        If bstack.lastobj Is Nothing Then
            
            r = CDbl(Len(s$) - (LenB(s$) Mod 2 = 1) / 2#)
        Else
            GoTo len1234
        End If
        IsLen = FastSymbol(A$, ")", True)
    Else
        MissParam A$
    End If

End Function
Private Function IsLenDisp(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant, s$, usehandler As mHandler

    If IsExp(bstack, A$, p) Then
    If Typename(bstack.lastobj) = mHdlr Then
    ' check this please
    Set usehandler = bstack.lastobj
    If usehandler.T1 = 4 Then wronguseofenum A$: Exit Function
    
    With usehandler
    If .indirect < 0 Then
    If TypeOf .objref Is FastCollection Then
        r = .objref.count
        Set bstack.lastobj = Nothing
        IsLenDisp = FastSymbol(A$, ")", True)
        Exit Function
    ElseIf TypeOf .objref Is MemBlock Then
        r = .objref.items
        Set bstack.lastobj = Nothing
        IsLenDisp = FastSymbol(A$, ")", True)
        Exit Function
    End If
    Else
        
     
            r = -1
     
     IsLenDisp = FastSymbol(A$, ")", True)
        Exit Function
    ' length of object???
    End If
    End With
    End If
    If VarType(p) = vbString Then
        s$ = p
        r = RealLen(s$)
        IsLenDisp = FastSymbol(A$, ")", True)
        Exit Function
        Else
    MissParam A$
    End If
    ElseIf IsStrExp(bstack, A$, s$) Then
    r = RealLen(s$)
    
    
    IsLenDisp = FastSymbol(A$, ")", True)
    Else
                    
                MissParam A$
    End If

End Function
Private Function IsDocLen(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                    r = var(w1).SizeCRLF
                Else
                    r = Len(var(w1))
                End If
                
                IsDocLen = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      r = pppp.item(w2).SizeCRLF
                      Else
                      r = Len(pppp.item(w2))
                      End If
                Else
                
                End If
                    
                IsDocLen = FastSymbol(A$, ")", True)
    Else
                    
                MissParam A$
    End If
End Function
Private Function IsDocWords(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                    r = var(w1).WordCount
                Else
                MissFuncParammeterdOCVar A$
               End If
                
                IsDocWords = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      r = pppp.item(w2).WordCount
                      Else
                       MissFuncParammeterdOCVar A$
                
                      End If
                Else
                
                End If
                    
                IsDocWords = FastSymbol(A$, ")", True)
    Else
                    
                MissParam A$
    End If
End Function
Private Function IsDocUniqueWords(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                    r = var(w1).UniqueWords
                Else
                MissFuncParammeterdOCVar A$
               End If
                
                IsDocUniqueWords = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      r = pppp.item(w2).UniqueWords
                      Else
                       MissFuncParammeterdOCVar A$
                
                      End If
                Else
                
                End If
                    
                IsDocUniqueWords = FastSymbol(A$, ")", True)
    Else
                    
                MissParam A$
    End If
End Function

Private Function IsCompMinMax(ByVal dn As Long, bstack As basetask, A$, r As Variant) As Boolean
Dim s$, w1 As Long, ow1 As Long, w2 As Long, s1$, dd As Long, w3 As Long, pppp As mArray, pppp1 As mArray
    w1 = Abs(IsLabel(bstack, A$, s$))
    ow1 = w1
    If w1 = 1 Or w1 = 4 Then dd = 1  'WE NEED NUMBERS
    If w1 = 5 Or w1 = 7 Then dd = 2 'WE NEED NUMBERS
    If w1 = 0 Then MissingnumVar:: Exit Function
    
    If dd = 1 Then
        If GetVar(bstack, s$, w1) Then
            If Not FastSymbol(A$, ",") Then MissingnumVar:: Exit Function
            w3 = Abs(IsLabel(bstack, A$, s1$))
            If w3 = 1 Or w3 = 4 Then
                If GetVar(bstack, s1$, w2) Then
                If myVarType(var(w1), vbString) Then
                    If Not myVarType(var(w2), vbString) Then
                        NeedString
                        IsCompMinMax = False
                        Exit Function
                    End If
                    Select Case dn
                    Case 1
                        If CompareStr3(var(w1), var(w2)) = -1 Then r = var(w1) Else r = var(w2)
                    Case 2
                        If CompareStr3(var(w1), var(w2)) = 1 Then r = var(w1) Else r = var(w2)
                    Case Else
                    If w1 <> w2 Then r = CompareStr3(var(w1), var(w2))
                    End Select
                Else
                Select Case dn
                Case 1
                    If var(w1) < var(w2) Then
                    
                        r = var(w1)
                        
                    Else
                        r = var(w2)
                        
                    End If
                Case 2
                    
                    If var(w1) > var(w2) Then
                        r = var(w1)
                        
                    Else
                        r = var(w2)
                        
                    End If
                Case Else

                    If var(w1) = 0 Then
                        If var(w2) = 0 Then
                            r = 0
                        Else
                        r = Sgn(0 - MyRound(var(w2), 10))
                        
                        End If
                    Else
                        If MyRound((var(w2) - var(w1)) / var(w1), 10) = 0 Then
                            r = 0
                        ElseIf var(w1) > var(w2) Then
                            r = 1
                        Else
                            r = -1
                        End If
                    End If
                End Select
                End If
                    
                    IsCompMinMax = FastSymbol(A$, ")", True)
                Exit Function
                Else
                    Nosuchvariable s1$
                    
                    Exit Function
                End If
            ElseIf w3 = 5 Or w3 = 7 Then
                If neoGetArray(bstack, s1$, pppp) Then
                    If Not NeoGetArrayItem(pppp, bstack, s1$, w2, A$) Then Exit Function
                    If myVarType(var(w1), vbString) Then
                        r = CVar(pppp.item(w2))
                        If myVarType(r, vbString) Then
                            If dn = 1 Then
                                If CompareStr3(var(w1), r) = -1 Then r = var(w1)
                            ElseIf dn = 2 Then
                                If CompareStr3(var(w1), r) = 1 Then r = var(w1)
                            Else
                            r = CompareStr3(var(w1), r)
                            End If
                        Else
                            r = 0
                            NeedString
                            IsCompMinMax = False
                            Exit Function
                        End If
                    Else
                    Select Case dn
                    Case 1
                        If var(w1) < pppp.itemnumeric(w2) Then
                            r = var(w1)
                        Else
                            r = pppp.itemnumeric(w2)
                        End If
                    Case 2
                        If var(w1) > pppp.itemnumeric(w2) Then
                            r = var(w1)
                        Else
                            r = pppp.itemnumeric(w2)
                        End If
                    Case Else
                        If var(w1) = 0 Then
                            If pppp.itemnumeric(w2) = 0 Then
                                r = 0
                            Else
                                r = Sgn(0 - MyRound(pppp.itemnumeric(w2), 10))
                            End If
                        Else
                            r = Sgn(MyRound(((var(w1) - pppp.itemnumeric(w2)) / var(w1)), 10))
                        End If
                    End Select
                    End If
                    IsCompMinMax = FastSymbol(A$, ")", True)
                Else
                    Nosuchvariable s1$
                    
                    Exit Function
                End If
            ElseIf w3 = 3 And ow1 = 1 Then
                If myVarType(var(w1), vbString) Then
                    GoTo s12
                End If
                MissingStrVar
            ElseIf w3 = 6 And ow1 = 1 Then
                If myVarType(var(w1), vbString) Then
                    GoTo s11
                End If
                MissingStrVar
            Else
                MissingnumVar
                
                Exit Function
            End If
        Else
            Nosuchvariable s$
            
            Exit Function
        End If
        
    ElseIf dd = 2 Then
        If neoGetArray(bstack, s$, pppp) Then
            If Not NeoGetArrayItem(pppp, bstack, s$, w1, A$) Then Exit Function
            If Not FastSymbol(A$, ",") Then MissingnumVar: Exit Function
                w3 = Abs(IsLabel(bstack, A$, s1$))
            If w3 = 1 Or w3 = 3 Or w3 = 4 Then
                    If GetVar(bstack, s1$, w2) Then
                    Select Case dn
                    Case 1
                        If myVarType(var(w2), vbString) Then
                            r = pppp.item(w1)
                            If myVarType(r, vbString) Then
                                If r > var(w2) Then
                                    r = var(w2)
                                End If
                            Else
                                r = 0
                                NeedString
                                IsCompMinMax = False
                                Exit Function
                            End If
                        ElseIf pppp.itemnumeric(w1) < var(w2) Then
                            r = pppp.itemnumeric(w1)
                            
                        Else
                            r = var(w2)
                            
                        End If
                    Case 2
                        
                        If myVarType(var(w2), vbString) Then
                            r = pppp.item(w1)
                        If myVarType(r, vbString) Then
                            
                            If r < var(w2) Then
                                r = var(w2)
                            End If
                        Else
                            r = 0
                            NeedString
                            IsCompMinMax = False
                            Exit Function
                        End If
                        ElseIf pppp.itemnumeric(w1) > var(w2) Then
                            r = pppp.itemnumeric(w1)
                            
                        Else
                            r = var(w2)
                            
                        End If
                    Case Else
                    
                    
                       If myVarType(var(w2), vbString) Then
                            r = pppp.item(w1)
                            If myVarType(r, vbString) Then
                            r = CompareStr3(r, var(w2))
                            Else
                            r = 0
                            NeedString
                            IsCompMinMax = False
                            Exit Function
                            End If
                        ElseIf pppp.itemnumeric(w1) = 0 Then
                            If var(w2) = 0 Then
                            r = 0
                            Else
                            r = Sgn(0 - MyRound(var(w2), 10))
                            
                            End If
                    Else
                            r = Sgn(MyRound(((pppp.item(w1) - var(w2)) / pppp.item(w1)), 10))
                            
                    End If
                        
                    End Select
                        
                        IsCompMinMax = FastSymbol(A$, ")", True)
                    Else
                        MissingnumVar
                        
                        Exit Function
                    End If
            ElseIf w3 > 5 And w3 < 8 Then
                    If neoGetArray(bstack, s1$, pppp1) Then
                        If Not NeoGetArrayItem(pppp1, bstack, s1$, w2, A$) Then Exit Function
                        If pppp.ItemTypeNum(w1) = vbString And w3 = 6 Then
                            GoTo st12321
                        Else
                            Select Case dn
                            Case 1
                                If pppp.itemnumeric(w1) < pppp1.itemnumeric(w2) Then
                                    r = pppp.itemnumeric(w1)
                                    
                                Else
                                    r = pppp1.itemnumeric(w2)
                                    
                                End If
                            Case 2
                                If pppp.itemnumeric(w1) > pppp1.itemnumeric(w2) Then
                                    r = pppp.itemnumeric(w1)
                                    
                                Else
                                    r = pppp1.itemnumeric(w2)
                                    
                                End If
                            Case Else
                                If pppp.itemnumeric(w1) = 0 Then
                                    If pppp1.itemnumeric(w2) = 0 Then
                                    r = 0
                                    Else
                                    r = Sgn(0 - MyRound(pppp1.itemnumeric(w2), 10))
                                    
                                    End If
                            Else
                                    r = Sgn(MyRound(((pppp.itemnumeric(w1) - pppp1.itemnumeric(w2)) / pppp.itemnumeric(w1)), 10))
                                    
                            End If
                            End Select
                        End If
                        IsCompMinMax = FastSymbol(A$, ")", True)
                    Else
                        MissingnumVar
                        
                        Exit Function
                    End If
            Else
                MissingnumVar
                
                Exit Function
            End If
        Else
            MissingnumVar
            
            Exit Function
        End If
    ElseIf w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
            If Not FastSymbol(A$, ",") Then MissingnumVar: Exit Function
                
                w3 = Abs(IsLabel(bstack, A$, s1$))
                If w3 = 6 Then
s11:
                    If Not neoGetArray(bstack, s1$, pppp) Then MissingStrVar::   Exit Function
                    If Not NeoGetArrayItem(pppp, bstack, s1$, w2, A$) Then Exit Function
                    
                    r = pppp.item(w2)
                    If dn = 1 Then
                        If CompareStr3(var(w1), r) = -1 Then r = var(w1)
                    ElseIf dn = 2 Then
                        If CompareStr3(var(w1), r) = 1 Then r = var(w1)
                    Else
                        r = CompareStr3(var(w1), r)    'StrComp(var(w1), CStr(pppp.item(w2)))
                    End If
                ElseIf w3 = 1 Then
                If Not GetVar(bstack, s1$, w2) Then MissingStrVar: Exit Function
                If Not myVarType(var(w2), vbString) Then MissingStrVar: Exit Function
                GoTo s13
                ElseIf w3 = 3 Then
s12:
                    If Not GetVar(bstack, s1$, w2) Then MissingStrVar: Exit Function
s13:
                    If dn = 1 Then
                        If var(w1) < var(w2) Then r = var(w1) Else r = var(w2)
                    ElseIf dn = 2 Then
                        If var(w1) > var(w2) Then r = var(w1) Else r = var(w2)
                    Else
                    If w1 <> w2 Then r = CompareStr3(var(w1), var(w2))   ' StrComp(var(w1), var(w2))
                    End If
            ElseIf w3 = 5 Then
                GoTo s11
            Else
                
                MissFuncParameterStringVarMacro A$
                Exit Function
                End If
                
                IsCompMinMax = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
            End If
    ElseIf w1 = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, w1, A$) Then Exit Function
                If Not FastSymbol(A$, ",") Then MissingnumVar:: Exit Function
                w3 = Abs(IsLabel(bstack, A$, s1$))
                If w3 = 6 Or w3 = 5 Then
                    If Not neoGetArray(bstack, s1$, pppp1) Then MissingStrVar: Exit Function
                    If Not NeoGetArrayItem(pppp1, bstack, s1$, w2, A$) Then Exit Function
                    
                    If pppp.ItemTypeNum(w1) = vbString And pppp1.ItemTypeNum(w2) = vbString Then
st12321:
                        If dn = 1 Then
                            If CompareStr3(pppp.item(w1), pppp1.item(w2)) = -1 Then
                                r = pppp.item(w1)
                            Else
                                r = pppp1.item(w2)
                            End If
                        ElseIf dn = 2 Then
                            If CompareStr3(pppp.item(w1), pppp1.item(w2)) = 1 Then
                                r = pppp.item(w1)
                            Else
                                r = pppp1.item(w2)
                            End If
                        Else
                        r = CompareStr3(pppp.item(w1), pppp1.item(w2))
                        End If
                    Else
                        MissingStrVar
                        Exit Function
                    End If
                    
                ElseIf w3 = 1 Then
                    If Not GetVar(bstack, s1$, w3) Then MissingStrVar: Exit Function
                    If Not myVarType(var(w3), vbString) Then MissingStrVar: Exit Function
                    GoTo s14
                ElseIf w3 = 3 Then
                    If Not GetVar(bstack, s1$, w3) Then: Exit Function
s14:
                    r = pppp.item(w1)
                    If Not myVarType(r, vbString) Then MissingStrVar: Exit Function
                    If dn = 1 Then
                        If r > var(w3) Then r = var(w3)
                    ElseIf dn = 2 Then
                        If r < var(w3) Then r = var(w3)
                    Else
                    r = CompareStr3(r, var(w3))
                    End If
                Else
                
                MissFuncParameterStringVarMacro A$
                Exit Function
                End If
                
                IsCompMinMax = FastSymbol(A$, ")", True)
            Else
                
                MissParam A$
            End If
    Else
                 
                MissParam A$
    End If

End Function
Private Function IsEval(v$, bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant, anything As Object, w3 As Long, w2 As Long, w1 As Long, pp As Variant, rB As Byte, ri As Integer, dn As Long, s$, ss$
Dim db As Double, pppp As iBoxArray, IsGroupOnly As Group, ReadAsSingle As Boolean, ReadInt64 As Boolean, ds As Single
Dim ThisGroup As Group, t$, usehandler As mHandler, usehandler1 As mHandler, ReadAsCurrency As Boolean
w1 = 1
t$ = aheadstatus(A$, False, w1)
s$ = Left$(A$, w1)
ss$ = s$
    If CheckGroupOrPointer(bstack, s$, IsGroupOnly, pppp, w2) Then
    
            If Not IsGroupOnly Is Nothing Then
               
                If Not pppp Is Nothing And w2 <> -2 Then
reentry1:
                    A$ = Mid$(A$, w1 + 1 - Len(s$))
                    If IsGroupOnly.HasParameters Then
                        If Mid$(A$, 1, 1) <> "," Then
                       
                        IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, w2) = 1
                        r = bstack.LastValue
                        If lookOne(A$, ",") And Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        Exit Function
                        Else
                        Mid$(A$, 1, 1) = "("
                        IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, w2) = 1
                        r = bstack.LastValue
                        End If

                    Else
                        IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, w2) = 1
                        r = bstack.LastValue
                        If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        If lookOne(A$, ",") And Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        IsEval = FastSymbol(A$, ")", True) And IsEval
                    End If
                    
                Else
                    If IsGroupOnly.HasParameters Then
                        If Mid$(A$, w1 - Len(s$) + 1, Len(s$)) <> ")" Then
                            ri = False
                            If Mid$(A$, w1, 1) = "," Then Mid$(A$, w1 - Len(s$) + 1, Len(s$)) = "(" + space$(Len(s$) - 1): ri = True
                            If IsGroupOnly.HasStrValue And Left$(t$, 1) <> "N" Then
                            If IsStr1(bstack, A$, ss$) Then
                                If ri Then
                                    IsEval = IsExp(bstack, ss$, r)
                                ElseIf FastSymbol(A$, ")") Then
                                    IsEval = IsExp(bstack, ss$, r)
                                End If
                            Else
                                Exit Function
                            End If
                        Else
                            If ri Then
                                IsEval = IsNumber(bstack, A$, r)
                            ElseIf IsNumber(bstack, A$, r) Then
                                IsEval = FastSymbol(A$, ")")
                            End If
                            Exit Function
                        End If
                        
                        
                        Else
                        If IsGroupOnly.HasStrValue And Left$(t$, 1) <> "N" Then
                            If IsStr1(bstack, A$, ss$) Then
                                IsEval = IsExp(bstack, ss$, r)
                            Else
                                Exit Function
                            End If
                        Else
                        
                        IsEval = IsNumber(bstack, A$, r)
                        End If
                        If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        IsEval = FastSymbol(A$, ")", True) And IsEval
                        End If
                    Else
                        If IsGroupOnly.HasStrValue And Left$(t$, 1) <> "N" Then
                            If IsStr1(bstack, A$, ss$) Then
                                If FastSymbol(A$, ")") Then
                                    IsEval = IsExp(bstack, ss$, r)
                                    If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                                End If
                            End If
                        ElseIf IsGroupOnly.HasValue Then
                                Set pppp = New ppppLight
                                pppp.PushDim 1
                                pppp.PushEnd
                                pppp.Arr = True
                                Set pppp.item(0) = IsGroupOnly
                                w2 = 0
                                GoTo reentry1
                        Else
                            IsEval = IsNumber(bstack, A$, r)
                            If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                            IsEval = FastSymbol(A$, ")", True) And IsEval
                        End If
                    End If
                End If
                
             '   If Not bstack.lastobj Is Nothing Then GoTo conthere
                Exit Function
            Else
            A$ = Mid$(A$, w1 + 1 - Len(s$))
            GoTo getgroup
            End If
    ElseIf IsExp(bstack, ss$, p) Then
    If Len(ss$) > 0 Then Mid$(A$, w1 + 1 - Len(ss$), Len(ss$)) = ss$
    Mid$(A$, 1, w1 + 1 - Len(ss$)) = space$(w1 - Len(ss$))
handlehandlers:
        w1 = 0
        s$ = vbNullString
        If Typename(bstack.lastobj) = mHdlr Then
            Set anything = bstack.lastobj
            Set usehandler = bstack.lastobj
            If usehandler.IamEnum Then
                     r = usehandler.index_cursor
                     
                     If usehandler.T1 = 0 Then
                     If IsObject(usehandler.objref) Then
                     Set bstack.lastobj = usehandler.objref
                     Else
                      Set bstack.lastobj = Nothing
                     End If
                     Else
                      Set bstack.lastobj = Nothing
                     End If
                    
                      IsEval = FastSymbol(A$, ")", True)
                     Exit Function
                     ElseIf Not CheckLastHandlerOrIterator(anything, w3) Then
                     InternalError
                     IsEval = False
                     Exit Function
            End If
            Set usehandler = anything
            With usehandler
                If .T1 = 1 Then
                        If FastSymbol(A$, ",") Then
                        If IsExp(bstack, A$, pp, flatobject:=True, nostring:=True) Then
                            w3 = CLng(pp)
                            If w3 < 0 Or w3 >= .objref.count Then
                            indexout A$
                            Exit Function
                            End If
                        w1 = True
                        End If
                        End If
                    On Error GoTo there12
                    If w3 >= 0 Then
                        .objref.Index = w3
                        .objref.Done = True
                    End If
                    If .objref.Done Then
                        If w1 Then
                        r = .objref.KeyToNumber
                        
                        Set bstack.lastobj = Nothing
                        ElseIf FastSymbol(A$, "!") Then
                            r = .objref.Index
                            
                            Set bstack.lastobj = Nothing
                        Else
                            If .objref.IsObj Then
                                r = rValue(bstack, usehandler.objref.ValueObj)
                                
                                '' bstack.lastobj is .objref.ValueObj
                                
                            Else
                                r = MyVal(.objref.Value)
                                
                                Set bstack.lastobj = Nothing
                            End If
                        End If
                        
                        IsEval = FastSymbol(A$, ")", True)
                    End If
there12:
                    On Error GoTo 0
                    Set anything = Nothing
                    Exit Function
                ElseIf .T1 = 2 Then
                    ' p is offset for items not bytes
                    If FastSymbol(A$, ",") Then
                        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                            w1 = Abs(Asc(v$) < 128)
                            If IsLabelSymbolNew(A$, "ыс", "AS", w1) Then
                                If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w1) Then
                                    pp = 1
                                ElseIf IsLabelSymbolNew(A$, "айеяаиос", "INTEGER", w1) Then
                                    pp = 2
                                ElseIf IsLabelSymbolNew(A$, "лайяус", "LONG", w1) Then
                                    If IsLabelSymbolNew(A$, "лайяус", "LONG", w1) Then
                                        pp = 8
                                        ReadInt64 = True
                                    Else
                                        pp = 4
                                    End If
                                ElseIf IsLabelSymbolNew(A$, "дипкос", "DOUBLE", w1) Then
                                    pp = 8
                                ElseIf IsLabelSymbolNew(A$, "коцистийос", "CURRENCY", w1) Then
                                    pp = 8
                                    ReadAsCurrency = True
                                ElseIf IsLabelSymbolNew(A$, "апкос", "SINGLE", w1) Then
                                    pp = 4
                                    ReadAsSingle = True
                                Else
                                    SyntaxError
                                    
                                    Exit Function
                                End If
                                ' use another itemsize
                                ' p is byte offset
                                w2 = .objref.GetBytePtr(p)
absolute:
                                pp = Abs(pp)
                                If .objref.ValidArea(w2, pp) Then
                                
                                    Select Case pp
                                    Case 1
                                        GetMem1 w2, rB
                                        r = CCur(rB)
                                    Case 2
                                        GetMem2 w2, ri
                                        r = CCur(UINT(CLng(ri)))
                                    Case 4
                                        If ReadAsSingle Then
                                            GetMemS w2, ds
                                            
                                                r = ds
                                        Else
                                            GetMem4 w2, dn
                                            r = CCur(uintnew1(dn))
                                        End If
                                        
                                    Case 8
                                        If ReadAsCurrency Then
                                            r = MemCur(w2)
                                        ElseIf ReadInt64 Then
                                            r = cInt64(0)
                                            CopyMemory ByVal VarPtr(r) + 8, ByVal w2, 8
                                            r = CDec(r)
                                            If r < 0 Then r = r + maxlonglong
                                            
                                        Else
                                        GetMem8 w2, db
                                        r = db
                                        End If
                                        
                                      
                                    Case 16
                                    ' ????
                                    End Select
                                Else
                                    GoTo errortext
                                End If
                            
                            Else
firstpram:
                                Set anything = .objref
                                With anything
                                    pp = .ItemSize
                                    ReadAsSingle = .WhatIsBasicItem = vbSingle
                                    ReadInt64 = .WhatIsBasicItem = 20
                                    ReadAsCurrency = .WhatIsBasicItem = vbCurrency
                                    If FastSymbol(A$, "!") Then
                                        If FastPureLabel(A$, s$) Then
                                            If .structref Is Nothing Then
                                                MyEr "No structure exist for buffer", "дЕМ УПэЯВЕИ ДОЛч ЦИА ТГМ ДИэЯХЯЫСГ"
                                                IsEval = False
                                                Exit Function
                                            End If
                                            If .structref.Find(myUcase(s$, True)) Then
                                                pp = Abs(.structref.sValue)
                                                If pp = 4 Then
                                                    ReadAsSingle = .structref.KeyTypeValue = vbSingle
                                                ElseIf pp = 8 Then
                                                    ReadInt64 = .structref.sValue < 0
                                                    ReadAsCurrency = .structref.KeyTypeValue = vbCurrency
                                                End If
                                                If FastSymbol(A$, "!") Then
                                                    If Not IsExp(bstack, A$, r, , True) Then
                                                        GoTo errortext1
                                                    ElseIf r >= 0 Then
                                                        w2 = cUlng(uintnew(.GetPtr(p)) + .structref.StructOffset + Int(r) * pp)
                                                        GoTo absolute
                                                    Else
                                                        NegativeIndex A$
                                                        GoTo errortext1
                                                    End If
                                                Else
                                                    w2 = cUlng(uintnew(.GetPtr(p)) + .structref.StructOffset)
                                                    GoTo absolute
                                                End If
                                            Else
                                                unknownoffset A$, s$
                                                GoTo errortext1
                                            End If
                                        End If
                                    Else
                                    If Not .structref Is Nothing Then
                                    If .structref.count > 0 Then
                                        .structref.ToStart
                                        pp = .structref.sValue
                                        ReadAsCurrency = .structref.KeyTypeValue = vbCurrency
                                    End If
                                    End If
                                    End If
                                    Select Case Abs(pp)
                                    Case 1
                                        If .ValidArea2(p, 1) Then
                                            GetMem1 .GetPtr(p), rB
                                            r = CCur(rB)
                                        Else
                                            GoTo errortext
                                        End If
                                    Case 2
                                        If .ValidArea2(p, 2) Then
                                            GetMem2 .GetPtr(p), ri
                                            r = CCur(UINT(CLng(ri)))
                                        Else
                                            GoTo errortext
                                        End If
                                    Case 8
                                        If .ValidArea2(p, 8) Then
                                            If ReadAsCurrency Then
                                            w2 = .GetPtr(p)
                                            r = MemCur(w2)
                                            ElseIf ReadInt64 Or pp < 0 Then
                                            w2 = .GetPtr(p)
                                            r = cInt64(0)
                                            CopyMemory ByVal VarPtr(r) + 8, ByVal w2, 8
                                            r = CDec(r)
                                            If r < 0 Then r = r + maxlonglong
                                                                                        
                                            
                                            Else
                                            GetMem8 .GetPtr(p), db
                                            r = db
                                            End If
                                        Else
                                            GoTo errortext
                                        End If
                                    Case 4
                                        If .ValidArea2(p, 4) Then
                                        If ReadAsSingle Then
                                           GetMemS .GetPtr(p), ds
                                            r = ds
                                        Else
                                            GetMem4 .GetPtr(p), dn
                                            r = CCur(uintnew1(dn))
                                        End If
                                    Else
errortext:
                                         wrongsizeOrposition A$
errortext1:
                                        Set anything = Nothing
                                        
                                        
                                        Exit Function
                                    End If
                                End Select
                                
               
                                End With
                            End If
                                           IsEval = FastSymbol(A$, ")", True)
                                
                                Set anything = Nothing
                                Exit Function
                        End If
                    Else
                    p = 0
                    GoTo firstpram
                    End If
            ElseIf .T1 = 3 Then
                If CheckDeepAny(anything) Then
                'If TypeOf anything Is mStiva Then
                
                'End If
                End If
                GoTo there1234459
            ElseIf .T1 = 4 Then
                Set usehandler1 = New mHandler
                If w3 = -1 Then
                    usehandler1.index_cursor = usehandler.index_cursor
                    Set usehandler1.objref = usehandler.objref
                    usehandler1.index_start = usehandler.index_start
                    usehandler1.sign = usehandler.sign
                    If myVarType(usehandler1.index_cursor, vbString) Then
                        r = usehandler1.index_cursor
                    Else
                        r = usehandler1.index_cursor * usehandler1.sign
                    End If
                Else
                    usehandler1.index_cursor = usehandler.objref.Value
                    Set usehandler1.objref = usehandler.objref
                    usehandler1.index_start = usehandler.objref.Index
                    r = usehandler1.index_cursor
                End If
                usehandler1.T1 = 4
                Set bstack.lastobj = usehandler1
                IsEval = FastSymbol(A$, ")", True)
                Exit Function
            Else
there1234459:
                ' eval for objects???
                r = 0
                IsEval = FastSymbol(A$, ")", True)
                Exit Function
            End If
            Set anything = Nothing
        End With
        Set usehandler = Nothing
    ElseIf Not bstack.lastpointer Is Nothing Then
getgroup:
            If Not bstack.lastpointer.IamApointer Then Set bstack.lastpointer = bstack.lastobj
            If bstack.lastpointer.link Is Nothing Then
            If bstack.lastpointer.IamFloatGroup Then
                Set pppp = New ppppLight
                pppp.PushDim 1
                pppp.PushEnd
                pppp.Arr = True
                Set pppp.item(0) = bstack.lastpointer
                Set bstack.lastpointer = Nothing
                 If pppp.item(0).HasParameters Then
                    FastSymbol A$, ","
                    IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, 0) = 1
                    r = bstack.LastValue
                    Exit Function
                Else
                    FastSymbol A$, ","
                    IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, 0) = 1
                    r = bstack.LastValue
                    GoTo conthere
                End If
                End If
                SyntaxError
                IsEval = False
                Exit Function
            ElseIf bstack.lastpointer.link.IamFloatGroup Then
getgroup2:
            Set pppp = New ppppLight
            pppp.PushDim 1
            pppp.PushEnd
            pppp.Arr = True
            Set pppp.item(0) = bstack.lastpointer
            Set bstack.lastpointer = Nothing
            If pppp.item(0).link.HasParameters Then
            FastSymbol A$, ","
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, 0) = 1
            r = bstack.LastValue
             Exit Function
            Else
            FastSymbol A$, ","
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, 0) = 1
            r = bstack.LastValue
            GoTo conthere
            End If
                Exit Function
            Else
            'Set bstack.lastpointer = bstack.lastobj
            If lookOne(A$, ",") Then
            Mid$(A$, 1, 1) = Chr(0)
            If IsNumber(bstack, A$, r) Then
            
                       IsEval = True
                       
                       Exit Function
                       End If
            Else
            If IsNumber(bstack, Chr$(0) + "'", r) Then
                GoTo conthere
            End If
            End If
          End If
        ElseIf Typename(bstack.lastobj) = mGroup Then
        Set ThisGroup = bstack.lastobj
        If ThisGroup.IamApointer Then
                Set bstack.lastobj = ThisGroup
                Set bstack.lastpointer = ThisGroup
                GoTo getgroup
        ElseIf ThisGroup.HasValue Then
        Set bstack.lastobj = Nothing
        Set pppp = New ppppLight
            pppp.PushDim 1
            pppp.PushEnd
            pppp.Arr = True
            Set pppp.item(0) = ThisGroup
        If ThisGroup.HasParameters Then
        
            FastSymbol A$, ","
            
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, 0) = 1
            r = bstack.LastValue
             Exit Function
        Else
        FastSymbol A$, ","
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", A$, 0) = 1
            r = bstack.LastValue
            GoTo conthere
        End If
        Else
                   r = r - r
                   IsEval = FastSymbol(A$, ")")
                    Exit Function
        End If
        End If
        MissParam A$
    ElseIf IsStrExp(bstack, ss$, s$) Then
    If Len(ss$) > 0 Then Mid$(A$, w1 + 1 - Len(ss$), Len(ss$)) = ss$
    Mid$(A$, 1, w1 + 1 - Len(ss$)) = space$(w1 - Len(ss$))
    If FastSymbol(A$, ".") Then
    If lookOne(A$, ")") Then
        
            If Not IsExp(bstack, s$, r) Then
          
            wrongweakref A$
        Else
            
            
            IsEval = FastSymbol(A$, ")", True)
        End If
            
        Else
        A$ = s$ + "." + A$
        
        If Not IsExp(bstack, A$, r) Then
          
            wrongweakref A$
        Else
        
            
            IsEval = FastSymbol(A$, ")", True)
        End If
        End If
    Else
    
            If Not IsExp(bstack, s$, r) Then
            
            wrongexprinstring A$
            Else
conthere:
            
            IsEval = FastSymbol(A$, ")", True)
            End If
    End If
    Else
        MissParam A$
    End If
End Function
Private Function IsVal(bstack As basetask, A$, r As Variant, Eng As Boolean) As Boolean
Dim s$, ex$, dd As Long, pp As Variant, Lang As Long
    If Eng Then Lang = 1
   If IsStrExp(bstack, A$, s$) Then
enterasstring:
    On Error Resume Next
    
    If FastSymbol(A$, "!", False) Then
    dd = ValidNumberOnly(s$, r, False)
    
    IsVal = FastSymbol(A$, ")", True)
    Err.Clear
    Exit Function
    ElseIf FastSymbol(A$, ",") Then
      If IsStrExp(bstack, A$, ex$) Then
      If Len(ex$) <> 1 Then
      If Len(ex$) = 0 Then dd = 46 Else dd = AscW(NowDec$)
      Else
          dd = AscW(ex$)
          End If
       If InStr(s$, ".") > 0 And dd <> 46 Then
        s$ = Replace(s$, ".", "*", 1, 1)
        End If
        s$ = Replace(s$, ChrW(dd), ".", 1, 1)
        dd = 46
    ElseIf IsExp(bstack, A$, pp, flatobject:=True, nostring:=True) Then
        pp = Fix(pp)
        dd = AscW(GetlocaleString2(14, CLng(pp)))
        If InStr(s$, ".") > 0 And dd <> 46 Then
        s$ = Replace(s$, ".", "*", 1, 1)
        End If
        s$ = Replace(s$, ChrW(dd), ".", 1, 1)
        dd = 46
    Else
    If lookOne(A$, ",") Then
        s$ = Replace(s$, ChrW(dd), ".", 1, 1)
        dd = 46
    Else
    expecteddecimal A$
    Err.Clear
    Exit Function
    End If
      End If
    Else
    dd = AscW(GetDeflocaleString(14))
    End If
    If MaybeIsSymbol(s$, "аАьЬTtFf") Then
    If CDbl(pp) = 0 Then
    If Fast3NoSpace(s$, "акгхес", 6, "акгхгс", 6, "TRUE", 4, 6) Then
        r = CBool(True)
        
    ElseIf Fast3NoSpace(s$, "ьеудес", 6, "ьеудгс", 6, "FALSE", 5, 6) Then
       r = CBool(False)
        
    Else
    r = 0
   End If
    Else
        If pp = 1032 Then
                 If Fast3NoSpace(s$, "акгхес", 6, "акгхгс", 6, vbNullString, 0, 6) Then
                     r = CBool(True)
                     
                 ElseIf Fast3NoSpace(s$, "ьеудес", 6, "ьеудгс", 6, vbNullString, 0, 6) Then
                    r = CBool(False)
                     
                 Else
                 r = 0
                End If
        Else
             If Fast3NoSpace(s$, "TRUE", 4, vbNullString, 0, vbNullString, 0, 4) Then
                 r = CBool(True)
                 
             ElseIf Fast3NoSpace(s$, "FALSE", 5, vbNullString, 0, vbNullString, 0, 5) Then
                r = CBool(False)
                 
             Else
             r = 0
            End If
     End If
     End If
    ElseIf dd = 46 Then
    If Not VALFUNC((s$), r) Then
    
    r = val(s$)
    
    'If Err.Number = 13 Then
    dd = ValidNumberOnlyClean(s$, r, False)
    ElseIf Abs(r) = 1 Then
    If InStr(UCase(s$), ".#INF") > 0 Then
    dd = ValidNumberOnlyClean(Replace(s$, ChrW(dd), "."), r, False)
    If dd = -1 Then
    Else
    If r < 0 Then
    r = -Infinity
    Else
    r = Infinity
    End If
    End If
    End If
    End If
    
    
    Else
    If Not VALFUNC(Replace(s$, ChrW(dd), "."), r) Then
    
    'If Err.Number = 13 Then
    dd = ValidNumberOnlyClean(Replace(s$, ChrW(dd), "."), r, False)
    ElseIf Abs(r) = 1 Then
    If InStr(UCase(s$), ".#INF") > 0 Then
    dd = ValidNumberOnlyClean(Replace(s$, ChrW(dd), "."), r, False)
    If dd = -1 Then
    Else
    If r < 0 Then
    r = -Infinity
    Else
    r = Infinity
    End If
    End If
    End If
    End If
    
    End If
    If Err.Number > 0 Then
    Err.Clear
    WrongArgument A$
    Exit Function
    End If
    On Error GoTo a100
    If FastSymbol(A$, ",") Then
    
    Dim mm As mStiva
   Set mm = New mStiva
    Dim oldm As mStiva
    Set oldm = bstack.soros
    Set bstack.Sorosref = mm
    dd = ValidNumberOnlyClean(s$, r, Len(ex$) > 1)
    If dd > 2 And Abs(r) = 1 Then
    If Mid$(s$, dd - 1, 2) = ".#" Then
    If UCase(Mid$(s$, dd + 1, 3)) = "INF" Then
    If r >= 0 Then
    r = Infinity()
    Else
    r = -Infinity()
    End If
    dd = dd + 4
    End If
    End If
    End If
    mm.PushVal dd
    FastSymbol A$, "&"
    If Not MyRead(1, bstack, A$, Lang) Then
    IsVal = False
    Set bstack.Sorosref = oldm
    Exit Function
    End If
    Set bstack.Sorosref = oldm
    End If
    IsVal = FastSymbol(A$, ")", True)
    ElseIf IsExp(bstack, A$, r) Then
    If FastSymbol(A$, "->", False, 2) Then
    Set bstack.lastobj = Nothing
    Set bstack.lastpointer = Nothing
    If FastSymbol(A$, "0@", , 2) Then
        On Error GoTo a500
        r = CDec(r)
        
        IsVal = FastSymbol(A$, ")", True)
    ElseIf FastSymbol(A$, "0#", , 2) Then
        On Error GoTo a400
        r = CCur(r)
        
        IsVal = FastSymbol(A$, ")", True)
    ElseIf FastSymbol(A$, "0&&", , 3) Then
        On Error GoTo a102
        r = cInt64(r)
        
        IsVal = FastSymbol(A$, ")", True)
    ElseIf FastSymbol(A$, "0%", , 2) Then
        On Error GoTo a100
        r = CLng(r)
        
        IsVal = FastSymbol(A$, ")", True)
    ElseIf FastSymbol(A$, "0&", , 2) Then
        On Error GoTo a101
        r = CLng(r)
        
        IsVal = FastSymbol(A$, ")", True)
    ElseIf FastSymbol(A$, "0~", , 2) Then
        On Error GoTo a200
        r = CSng(r)
        
        IsVal = FastSymbol(A$, ")", True)
    ElseIf FastSymbol(A$, "0") Then
        On Error GoTo a300
        r = CDbl(r)
        
        IsVal = FastSymbol(A$, ")", True)
    Else
    
        If IsLabelSymbolNew(A$, "аяихлос", "DECIMAL", Lang) Then
            On Error GoTo a500
            r = CDec(r)
            
            IsVal = FastSymbol(A$, ")", True)
        ElseIf IsLabelSymbolNew(A$, "дипкос", "DOUBLE", Lang) Then
            On Error GoTo a300
            r = CDbl(r)
            
            IsVal = FastSymbol(A$, ")", True)
        ElseIf IsLabelSymbolNew(A$, "апкос", "SINGLE", Lang) Then
            r = CSng(r)
            
            IsVal = FastSymbol(A$, ")", True)
        ElseIf IsLabelSymbolNew(A$, "коцийос", "BOOLEAN", Lang) Then
            r = CBool(r)
            IsVal = FastSymbol(A$, ")", True)
        ElseIf IsLabelSymbolNew(A$, "лайяус лайяус", "LONG LONG", Lang) Then
            On Error GoTo a102
            r = cInt64(r)
            
            IsVal = FastSymbol(A$, ")", True)
        ElseIf IsLabelSymbolNew(A$, "лайяус", "LONG", Lang) Then
            On Error GoTo a101
            r = CLng(r)
            
            IsVal = FastSymbol(A$, ")", True)
         ElseIf IsLabelSymbolNew(A$, "айеяаиос", "INTEGER", Lang) Then
            On Error GoTo a100
            r = CInt(r)
            
            IsVal = FastSymbol(A$, ")", True)
        ElseIf IsLabelSymbolNew(A$, "коцистийос", "CURRENCY", Lang) Then
            On Error GoTo a400
            r = CCur(r)
            
            IsVal = FastSymbol(A$, ")", True)
        Else
    
        CantFind "0@ 0# 0&& 0& 0~ 0% 0"
        End If
        Set bstack.lastobj = Nothing
    End If
    Else
        On Error GoTo a300
        If myVarType(r, vbString) Then
        SwapString2Variant s$, r
        GoTo enterasstring
        Else
        r = CDbl(r)
        End If
        
        IsVal = FastSymbol(A$, ")", True)
    End If
    
    Else
        MissParam A$
    End If
 Exit Function
a100:
 IsVal = False
 If Err.Number = 6 Then
 
   OverflowValue vbInteger
 Else
    MyEr Err.Description, Err.Description
 End If
 Err.Clear
 Exit Function
a101:
 IsVal = False
 If Err.Number = 6 Then
 
   OverflowValue vbLong
 Else
    MyEr Err.Description, Err.Description
 End If
 Err.Clear
 Exit Function
a102:
 IsVal = False
 If Err.Number = 6 Then
 
   OverflowValue 20
 Else
    MyEr Err.Description, Err.Description
 End If
 Err.Clear
 Exit Function

a200:
 IsVal = False
 If Err.Number = 6 Then
 
    OverflowValue vbSingle
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear
Exit Function
a300:
 IsVal = False
 If Err.Number = 6 Then
    OverflowValue vbDouble
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear
Exit Function
a400:
 IsVal = False
 If Err.Number = 6 Then
    OverflowValue vbCurrency
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear
Exit Function
a500:
 IsVal = False
 If Err.Number = 6 Then
 
    MyEr "Overflow Decimal", "УПЕЯВЕъКИСГ дЕЙАДИЙОЩ"
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear

End Function
Private Function IsRinstr(bstack As basetask, A$, r As Variant, sg As Variant, Lang As Long) As Boolean
Dim s$, s1$, par As Boolean
    If IsStrExp(bstack, A$, s$) Then
        If FastSymbol(A$, ",") Then
        
            If IsStrExp(bstack, A$, s1$) Then
                If FastSymbol(A$, ",") Then
                    If Not IsExp(bstack, A$, r, , True) Then
                        MissParam A$
                        Exit Function
                    End If
                    par = True
                End If
           
             If IsLabelSymbolNew(A$, "ыс", "AS", Lang) Then
        If IsLabelSymbolNew(A$, "ьгжио", "BYTE", Lang) Then
                 If par Then
                 If r < 0 Then r = LenB(s$) + r + 1
                If r < 0 Then r = 1
                r = LenB(s$) - r + 1
                If r < 0 Then r = 1
                If r > LenB(s$) Then r = LenB(s$)
        Else
        r = LenB(s$)
        End If
           r = rinstrb(s$, s1$, r)
        Else
           SyntaxError
            Exit Function
        End If
        Else
        If par Then
        If r < 0 Then r = Len(s$) + r + 1
                If r < 0 Then r = 1
                r = Len(s$) - r + 1
                If r < 0 Then r = 1
                If r > Len(s$) Then r = Len(s$)
        Else
        r = Len(s$)
        End If
     r = InStrRev(s$, s1$, r)
    End If
            
            
            IsRinstr = FastSymbol(A$, ")", True)
    Else
        MissParam A$
    End If
        Else
            MissParam A$
    End If
        Else
            MissParam A$
    End If

End Function
Private Function IsInstr(bstack As basetask, A$, r As Variant, sg As Variant, Lang As Long) As Boolean
Dim s$, s1$
    If IsStrExp(bstack, A$, s$, False) Then
    If FastSymbol(A$, ",") Then
    If IsStrExp(bstack, A$, s1$, False) Then
        If FastSymbol(A$, ",") Then
        If Not IsExp(bstack, A$, r, , True) Then
          
                MissParam A$
         Exit Function
        End If
        Else
        r = 1
        End If
      If IsLabelSymbolNew(A$, "ыс", "AS", Lang) Then
        If IsLabelSymbolNew(A$, "ьгжио", "BYTE", Lang) Then
           
           r = InStrB(r, s$, s1$)
        Else
           SyntaxError
            Exit Function
        End If
        Else
    r = InStr(r, s$, s1$)
    End If
    
    
    IsInstr = FastSymbol(A$, ")", True)
    Else
            MissParam A$
    End If
        Else
            MissParam A$
    End If
        Else
            MissParam A$
    End If
    
End Function

Private Function IsGroupCount(bstack As basetask, A$, r As Variant) As Boolean
Dim s$, w2 As Long, pppp As mArray
Select Case Abs(IsLabelBig(bstack, A$, s$))
Case 1
    If getvar2(bstack, s$, w2) Then
        If VarTypeName(var(w2)) = mGroup Then
            If var(w2).IamApointer Then
            
            Else
                r = var(w2).PrepareSoros(var(), "").Total
                
            End If
        Else
            MissingGroup
            Exit Function
        End If
        IsGroupCount = FastSymbol(A$, ")", True)
        Exit Function
    Else
        Nosuchvariable s$
    End If
Case 5
    If Not neoGetArray(bstack, s$, pppp) Then Exit Function
    If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
    If pppp.Arr Then
        If pppp.ItemType(w2) = mGroup Then
            r = 0
            If pppp.item(w2).IamApointer Then
            Else
                r = pppp.item(w2).PrepareSoros(var(), "").Total
                
            End If
        Else
            MissingGroup
            Exit Function
        End If
    End If
    IsGroupCount = FastSymbol(A$, ")")
Case Else
    MissingGroup
End Select
End Function
Private Function IsParIndex(bstack As basetask, A$, r As Variant) As Boolean
Dim s$, w1 As Long, w2 As Long, dn As Long, pppp As mArray
    w1 = Abs(IsLabel(bstack, A$, s$))
                  
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                        If Not FastSymbol(A$, ",") Then: MissParam A$: Exit Function
                         w2 = Abs(IsLabel(bstack, A$, s$)) ' ONLY AN ARITHMETIC VAR.
    
                        If w2 = 1 Or w2 = 4 Then
                                If GetVar(bstack, s$, w2) Then
                                dn = var(w2)
                              r = var(w1).ParagraphOrder(dn)           ''
                                 
                            
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsParIndex = False
                                        Exit Function
                                 End If
                         
                        Else
                                        MissingnumVar
                                        
                                        IsParIndex = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsParIndex = False
                                        Exit Function
                End If
                
                IsParIndex = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                                If Not FastSymbol(A$, ",") Then: MissParam A$: Exit Function
                         w1 = Abs(IsLabel(bstack, A$, s$)) ' ONLY AN ARITHMETIC VAR..
                        If w1 = 1 Or w1 = 2 Then
                                If GetVar(bstack, s$, w1) Then
                                dn = var(w1)
                                 r = pppp.item(w2).ParagraphOrder(dn)
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsParIndex = False
                                        Exit Function
                                 End If
                         
                        Else
                                        Nosuchvariable s$
                                        
                                        IsParIndex = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsParIndex = False
                                        Exit Function
                End If
                    
                IsParIndex = FastSymbol(A$, ")", True)
    Else
                    
                MissFuncParameterStringVarMacro A$
    End If

End Function
Private Function IsForwBack(ByVal dd As Long, bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, w2 As Long, s$, dn As Long, pppp As mArray


w1 = Abs(IsLabel(bstack, A$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                        If Not FastSymbol(A$, ",") Then: MissParam A$: Exit Function
                         w2 = Abs(IsLabel(bstack, A$, s$)) ' ONLY AN ARITHMETIC VAR..
                        If w2 = 1 Or w2 = 4 Then
                                If GetVar(bstack, s$, w2) Then
                                dn = var(w2)
                                If dd = 1 Then
                                var(w1).BackStep dn
                                var(w1).BackMove = True
                                Else
                                var(w1).BackMove = False
                                var(w1).Advance dn
                                End If
                                 r = Not var(w1).IsEmpty
                                 '    r = var(w1).ParagraphOrder(dn)          ''
                                 
                                 var(w2) = dn
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsForwBack = False
                                        Exit Function
                                 End If
                         
                        Else
                                        MissingnumVar
                                        
                                        IsForwBack = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsForwBack = False
                                        Exit Function
                End If
                
                IsForwBack = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                                If Not FastSymbol(A$, ",") Then: MissParam A$: Exit Function
                         w1 = Abs(IsLabel(bstack, A$, s$)) ' ONLY AN ARITHMETIC VAR..
                         If w1 = 1 Or w1 = 2 Then
                                If GetVar(bstack, s$, w1) Then
                                dn = var(w1)
                                 If dd = 1 Then
                                pppp.item(w2).BackStep dn
                                pppp.item(w2).BackMove = True
                                Else
                              pppp.item(w2).BackMove = False
                                 pppp.item(w2).Advance dn
                                End If
                                r = Not pppp.item(w2).IsEmpty
                                '' r = pppp.item(w2).ParagraphOrder(dn)
                                
                                 var(w1) = dn
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsForwBack = False
                                        Exit Function
                                 End If
                         
                        Else
                                        Nosuchvariable s$
                                        
                                        IsForwBack = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsForwBack = False
                                        Exit Function
                End If
                    
                IsForwBack = FastSymbol(A$, ")", True)
    Else
                    
                MissFuncParameterStringVarMacro A$
    End If
End Function
Private Function IsDocPar(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, w2 As Long, s$, pppp As mArray
w1 = Abs(IsLabel(bstack, A$, s$))

        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If VarTypeName(var(w1)) = doc Then
                    r = var(w1).DocParagraphs
                Else
                    r = 0
                End If
                
                IsDocPar = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      r = pppp.item(w2).DocParagraphs
                      Else
                      r = 0
                      End If
                Else
                
                End If
                    
                IsDocPar = FastSymbol(A$, ")", True)
    Else
                    
                MissFuncParameterStringVarMacro A$
    End If
End Function
Private Function IsMaxData(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant, s$
If IsExp(bstack, A$, r, flatobject:=True) Then
If myVarType(r, vbString) Then GoTo there
Do While FastSymbol(A$, ",")
    If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then MissNumExpr: Exit Function
    If p > r Then r = p
Loop
IsMaxData = FastSymbol(A$, ")", True)
 
ElseIf IsStrExp(bstack, A$, s$, False) Then
r = vbNullString
SwapString2Variant s$, r
there:
Do While FastSymbol(A$, ",")
    If Not IsStrExp(bstack, A$, s$, False) Then MissStringExpr: Exit Function
    If s$ > r Then SwapString2Variant s$, r
Loop
IsMaxData = FastSymbol(A$, ")", True)
Else
    SyntaxError
End If
End Function
Private Function IsMinData(bstack As basetask, A$, r As Variant) As Boolean
Dim p As Variant, s$
If IsExp(bstack, A$, r, flatobject:=True) Then
If myVarType(r, vbString) Then GoTo there
Do While FastSymbol(A$, ",")
    If Not IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then MissNumExpr: Exit Function
    If p < r Then r = p
Loop
IsMinData = FastSymbol(A$, ")", True)
 
ElseIf IsStrExp(bstack, A$, s$, False) Then
r = vbNullString
SwapString2Variant s$, r
there:
Do While FastSymbol(A$, ",")
    If Not IsStrExp(bstack, A$, s$, False) Then MissStringExpr: Exit Function
    If s$ < r Then SwapString2Variant s$, r
Loop
IsMinData = FastSymbol(A$, ")", True)
Else
    SyntaxError
End If
End Function
Private Function IsProperty(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, A$, s$))
If w1 = 1 Or w1 = 5 Then
    If w1 = 5 Then If Not FastSymbol(A$, ")", True) Then Exit Function
    If Not GetVar(bstack, s$, w2) Then GoTo jmp147811
    If w1 = 5 Then
        If Not VarTypeName(var(w2)) = myArray Then GoTo jmp147811
        Set pppp = var(w2)
        If pppp.Arr Then GoTo jmp147811
        If Not pppp.ItemType(-1) = mProp Then GoTo jmp147811
        Set bstack.lastobj = pppp.GroupRef
    Else
        If Not VarTypeName(var(w2)) = mProp Then GoTo jmp147811
        Set bstack.lastobj = var(w2)
    End If
    r = 0
    IsProperty = FastSymbol(A$, ")", True)
    Exit Function
Else
jmp147811:
MyErMacro A$, "Expected a property name", "пЕЯъЛЕМА ЭМОЛА ИДИЭТГТАР"
End If

End Function

Private Function IsGroup(bstack As basetask, A$, r As Variant) As Boolean
Dim w1 As Long, s$, ohere$, w2 As Long, myGroup As Object, mygroup2 As Object, aGroup As Group
w1 = Abs(IsLabel(bstack, A$, s$))
If w1 = 1 Or w1 = 3 Then
If Not GetVar(bstack, s$, w1) Then GoTo jmp1478
If Not VarTypeName(var(w1)) = mGroup Then GoTo jmp1478
If var(w1).IamApointer Then
    If var(w1).link.IamFloatGroup Then
    '  var(w1).link
      Set bstack.lastpointer = Nothing
      If var(w1).link Is NullGroup Then
      Set aGroup = New Group
      aGroup.BeginFloat 0
      aGroup.EndFloat
      Set myGroup = aGroup
      
      Else
     bstack.soros.CopyGroupObj var(w1).link, myGroup
     Set aGroup = myGroup
     End If
     aGroup.ToDelete = True
     Set bstack.lastobj = myGroup
    Else  ' need to make a copy group using
        ohere$ = here$
        here$ = var(w1).lasthere
        If GetVar(bstack, var(w1).GroupName, w2, , , True) Then
            CopyGroup2 var(w2), bstack
        End If
        here$ = ohere$
    End If
Else
    CopyGroup2 var(w1), bstack
    End If
    r = 0
    
    IsGroup = FastSymbol(A$, ")", True)
    Exit Function
ElseIf w1 > 4 Then
If Not GetVar(bstack, s$, w1) Then GoTo jmp1478
Dim p
If ProcessArray(bstack, A$, s$ + ")", var(w1), p) Then
If VarTypeName(p) = mGroup Then
 Set aGroup = p
 
If aGroup.IamApointer Then
    If aGroup.link.IamFloatGroup Then
           Set bstack.lastpointer = Nothing
           If aGroup.link Is NullGroup Then
      Set aGroup = New Group
      aGroup.BeginFloat 0
      aGroup.EndFloat
      Set myGroup = aGroup
      Else
           Set myGroup = aGroup.link
           End If
     bstack.soros.CopyGroupObj myGroup, mygroup2
        Set aGroup = mygroup2
        aGroup.ToDelete = True
        Set bstack.lastobj = mygroup2
    Else  ' need to make a copy group using
        ohere$ = here$
        here$ = aGroup.lasthere
       
        If GetVar(bstack, aGroup.GroupName, w2, , , True) Then
        Set myGroup = aGroup.link
        CopyGroup2 myGroup, bstack
        End If
        here$ = ohere$
    End If

Else
    Set myGroup = aGroup
     Set bstack.lastobj = CopyGroupObj(myGroup)
    End If
    IsGroup = FastSymbol(A$, ")", True)
    Exit Function
End If
    
End If

Else
jmp1478:
MyErMacro A$, "Expected a group name", "пЕЯъЛЕМА ЭМОЛА ОЛэДАР"
End If
Exit Function
End Function
Public Function GetPointer(bstack As basetask, A$) As Boolean
Dim w1 As Long, s$, pppp As mArray, ppppL As iBoxArray, w2 As Long, p, nbstack As basetask, MyObj As Object, I As Long
Dim Glob As Boolean, rempar As Long, waspointer As Boolean, usehandler As mHandler
If MaybeIsSymbol(A$, ")") Then
p = 0
GoTo checkagain
End If
again:
w1 = Abs(IsLabel(bstack, A$, s$))

If w1 = 1 Or w1 = 3 Then
    w2 = w1
cont11:
    If Not GetVar(bstack, s$, w1, , , , , , Glob) Then GoTo jmp1478
    If Not VarTypeName(var(w1)) = mGroup Then GoTo jmp1478
    If var(w1).IamApointer Then
            Set bstack.lastobj = var(w1)
            Set bstack.lastpointer = var(w1)
    Else
                            If var(w1).IamSuperClass Then
                            PushStage bstack, False
                        
                                I = globalvarGroup("_1", 0, , True)
                                Set MyObj = var(w1)
                                UnFloatGroup bstack, "_1", I, MyObj, True
                                
                            Set p = CopyGroupObj(var(I))
                            PopStage bstack
                                MakeGroupPointer bstack, p
                            ElseIf w2 = 1 Then
                                
                                MakeGroupPointer bstack, var(w1), s$, Glob
                            ElseIf w2 = 3 Then
                                MakeGroupPointer bstack, var(w1), Left$(s$, Len(s$) - 1), Glob
                            End If
    
    
    
        
    End If
        GetPointer = True
        GoTo exitHere
    ElseIf w1 > 4 And w1 < 8 Then
        If Not GetVar(bstack, s$, w1) Then
            If GetSub(s$ + ")", w2) Then
                Set nbstack = New basetask
                Set nbstack.Parent = bstack
                If bstack.IamThread Then Set nbstack.Process = bstack.Process
                Set nbstack.Owner = bstack.Owner
                nbstack.OriginalCode = w2
                nbstack.UseGroupname = sbf(w2).sbgroup
                nbstack.tpointer = sbf(w2).tpointer
                nbstack.SetV
                If GoFunc(nbstack, s$ + ")", A$, p) Then
                If Not nbstack.StaticCollection Is Nothing Then
                    bstack.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                End If
                Set p = bstack.lastobj
                If Not p Is Nothing Then
                    If VarTypeName(p) = mGroup Then
                        If p.IamApointer Then
                            Set bstack.lastpointer = p
                        Else
                            If p.IamSuperClass Then
                                PushStage bstack, False
                                I = globalvarGroup("_1", 0, , True)
                                Set MyObj = p
                                UnFloatGroup bstack, "_1", I, MyObj, True
                                Set p = CopyGroupObj(var(I))
                                PopStage bstack
                            End If
                            MakeGroupPointer bstack, p
                        End If
                        GetPointer = True
                        GoTo exitHere
                        End If
                    End If
                End If
        ElseIf neoGetArray(bstack, s$, ppppL) Then

            
            If Not ppppL.Arr Then
                If NeoGetArrayItem(ppppL, bstack, s$, w2, A$) Then
                    GoTo conthere
                End If
            End If
        Else  '"", "POINTER("
            If IsLabelSymbolNew(s$, "POINTER(", "POINTER(", 1 - (Asc(s$) < 128)) Then
                rempar = rempar + 1
                GoTo again
            Else
                bstack.tmpstr = s$ + Left$(A$, 1)
                BackPort A$
                If IsNumberNew(bstack, A$, p, False) Then
                    If Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is Group Then
                            Set p = bstack.lastobj
                            If Not p.IamApointer Then
                                MakeGroupPointer bstack, p
                                
                                Else
                               Set bstack.lastpointer = p
                            Set bstack.lastobj = p
                            End If
                            
                            GetPointer = True
                        End If
                    End If
                    Exit Function
                End If
            End If
        End If
        Set nbstack = Nothing
        GoTo jmp1478
    End If
    Set p = var(w1)
again99:
        Set usehandler = Nothing
        If GetArrayReference(bstack, A$, s$ + ")", p, pppp, w2) Then
            Set ppppL = pppp
conthere:
            Set usehandler = Nothing
            If ppppL.ItemType(w2) = mGroup Then
                Set p = ppppL.item(w2)
                If p.IamApointer Then
                    Set bstack.lastobj = p
                    Set bstack.lastpointer = p
                Else
                    MakeGroupPointer bstack, p
                    Set ppppL.item(w2) = bstack.lastpointer  ' this is my idea
                End If
                GetPointer = True
                GoTo exitHere
            Else
                If MyIsObject(pppp.item(w2)) Then
                    Set p = pppp.item(w2)
                    If Left$(A$, 1) = "(" Then
                        Mid$(A$, 1, 1) = " "
                        Set usehandler = p
                        With usehandler
                            If Typename(.objref) = myArray Then Set pppp = .objref: Set p = pppp: GoTo again99
                            If FindItem(bstack, p, A$, VarTypeName(p), w2) Then
                                Set ppppL = p
                                GoTo conthere
                            End If
                        End With
                    End If
                End If
            End If
        End If
    ElseIf w1 = 8 Then
        bstack.tmpstr = s$ + "[" + Left$(A$, 1)
        BackPort A$
        If IsNumberNew(bstack, A$, p, False) Then
        If bstack.lastobj Is Nothing Then
er66876:
                MyErMacro A$, "Not group found at array " + s$, "ДЕМ БЯчЙА ОЛэДА СТО ПъМАЙА " + s$
                Exit Function
        ElseIf Not TypeOf bstack.lastobj Is Group Then
            Set bstack.lastobj = Nothing
            GoTo er66876
        End If
                Set bstack.lastpointer = bstack.lastobj
                GetPointer = True
                GoTo exitHere
        End If
        GoTo er66876
    
        
        ElseIf FastSymbol(A$, "(") Then
                                
                If IsExp(bstack, A$, p) Then
                    If Not bstack.lastpointer Is Nothing Then
                    waspointer = bstack.lastobj.IamApointer  ' reverse order if pointer is a reference
                        Set bstack.lastobj = bstack.lastpointer
                        Set bstack.lastpointer = Nothing
                    End If
                    rempar = rempar + 1
checkagain:
                    If bstack.lastobj Is Nothing Then
                        If p = 0 Then
                            Set p = NullGroup
                            If Not p.GroupName = "NULL" Then
                            p.BeginFloat 2
                            NullGroup.GroupName = "NULL"
                            NullGroup.PutIs = "NULL"
                            NullGroup.PutIs = "лгдемийос"
                            End If
                            MakeGroupPointer bstack, p
                            GetPointer = True
                            GoTo exitHere
                        Else
                            GoTo jmp1478
                        End If
                    Else
                        If TypeOf bstack.lastobj Is Group Then
getgroup:
                            Set p = bstack.lastobj
                            If p.IamSuperClass Then
                                PushStage bstack, False
                                I = globalvarGroup("_1", 0, , True)
                                Set MyObj = p
                                UnFloatGroup bstack, "_1", I, MyObj, True
                                Set p = CopyGroupObj(var(I))
                                PopStage bstack
                            ElseIf p.IamApointer Then
                                If Not p.link Is Nothing Then
                                    Set p = p.link
                                Else
                                Set bstack.lastpointer = p
                                End If
                            ElseIf p.IamFloatGroup Then
                               ' Set bstack.lastpointer = p
                               ' bstack.soros.CopyGroupObj bstack.lastpointer, myobj
                                'Set p = myobj
                            ElseIf waspointer Then
                                   Set p = CopyGroupObj(p)
                            End If
                            MakeGroupPointer bstack, p
                            GetPointer = True
                            GoTo exitHere
                        End If
                    End If
                                 
                End If
                                
jmp1478:
                If s$ = "THIS" Or s$ = "ауто" Then
                         
                If Len(bstack.UseGroupname) > 0 Then
                    s$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
                    If GetVar(bstack, s$, w1) Then
                        If IsBadCodePtr(var(w1).PointerPtr) = 0 Then
                        ObjSetAddRef MyObj, var(w1).PointerPtr
                        Set p = MyObj
                                p.link.lasthere = var(w1).lasthere
                                p.link.LastOpen = var(w1).LastOpen
                                Set bstack.lastobj = MyObj
                                Set bstack.lastpointer = MyObj
                                GetPointer = True
                            GoTo exitHere
                        End If
                        s$ = vbNullString
                        SwapStrings s$, here$
                            If (Len(bstack.UseGroupname) - Len(var(w1).GroupName) - 1) > 0 Then
                                here$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - Len(var(w1).GroupName) - 1)
                            Else
                                here$ = vbNullString
                            End If
                            MakeGroupPointer bstack, var(w1)
                        SwapStrings s$, here$
                            GetPointer = True
                            GoTo exitHere
                        End If
                         End If
                       ElseIf s$ = "GROUP" Or s$ = "олада" Then
                       If bstack.soros.Total = 0 Then
                               EmptyStack A$
  
                        GetPointer = False: GoTo exitHere

                        ElseIf bstack.soros.StackItemTypeObjectType(1) = mGroup Then
                            Set bstack.lastobj = bstack.soros.PopObj
                            
                            If bstack.lastobj.IamApointer Then
                            GetPointer = True
                            Set bstack.lastpointer = bstack.lastobj
                            GoTo exitHere
                            Else
                            GoTo getgroup
                            End If
                              Else
                              StackTopNotGroup A$
                            GetPointer = False: GoTo exitHere
                              End If
                       
                       
                        Else
er1234:
                        MyErMacro A$, "Expected a group name", "пЕЯъЛЕМА ЭМОЛА ОЛэДАР"
                        Exit Function
                        End If
    ElseIf IsNumber(bstack, A$, p, False) Then
            GoTo checkagain
End If
exitHere:
Do While rempar > 0
If Not FastSymbol(A$, ")", True) Then Exit Do
rempar = rempar - 1
Loop
End Function

Private Function CheckGroupOrPointer(bstack As basetask, A$, IsGroupOnly As Group, pppp As iBoxArray, w2 As Long) As Boolean
Dim w1 As Long, s$, p

w1 = Abs(IsLabel(bstack, A$, s$))
If w1 = 1 Or w1 = 3 Then
        If Not GetVar(bstack, s$, w1) Then Exit Function
        If Not VarTypeName(var(w1)) = mGroup Then Exit Function
        If var(w1).IamApointer Then
                Set bstack.lastobj = var(w1)
                Set bstack.lastpointer = var(w1)
                Else
                Set IsGroupOnly = var(w1)
        End If
        CheckGroupOrPointer = True
        Exit Function
ElseIf w1 > 4 Then
    If Not GetVar(bstack, s$, w1) Then
        
        If neoGetArray(bstack, s$, pppp) Then
            If Not pppp.Arr Then
                If NeoGetArrayItem(pppp, bstack, s$, w2, A$) Then GoTo conthere
            End If
        End If
        Exit Function
    End If
If GetArrayReference(bstack, A$, s$ + ")", var(w1), pppp, w2) Then
conthere:
        If pppp.ItemType(w2) = mGroup Then
            Set p = pppp.item(w2)
            If p.IamApointer Then
                Set bstack.lastobj = p
                Set bstack.lastpointer = p
              Else
              Set IsGroupOnly = p
            End If
            CheckGroupOrPointer = True
            Exit Function
        End If
    End If
Else
    If IsExp(bstack, A$, p) Then
        If bstack.lastobj Is Nothing Then
            Exit Function
        Else
            If TypeOf bstack.lastobj Is Group Then
                If Not bstack.lastobj.IamApointer Then
                    Set IsGroupOnly = bstack.lastobj
                    Set bstack.lastobj = Nothing
                End If
                CheckGroupOrPointer = True
            End If
        End If
    End If
End If
End Function

Private Function IsChrCode(bstack As basetask, A$, r As Variant) As Boolean
Dim s$, W As Long
   If IsStrExp(bstack, A$, s$, False) Then
    If s$ = vbNullString Then
        r = CInt(-1)
    Else
        W = AscW(s$)
        If W > -10241 And W < -9216 Then
            If Len(s$) > 1 Then
            r = CCur((&H10000 + (UINT(W) - &HD800&) * &H400 + UINT(AscW(Mid$(s$, 2, 1))) - &HDC00&))
            Else
             r = CInt(W)
                On Error Resume Next
                
            End If
        Else
        r = CInt(W)
        On Error Resume Next
        
        End If
        
    End If
    IsChrCode = FastSymbol(A$, ")", True)
    Else
        MissParam A$
    End If
End Function
Private Function IsAsc(bstack As basetask, A$, r As Variant) As Boolean
Dim s$
    If IsStrExp(bstack, A$, s$, False) Then
    If s$ = vbNullString Then
    r = -1
    Else
    'cLid
    r = Asc(StrConv(StrConv(s$, vbFromUnicode, Clid), vbUnicode))
    End If
        IsAsc = FastSymbol(A$, ")", True)
    Else
        MissParam A$
    End If

End Function
Private Function IsCons(bstack As basetask, A$, r As Variant) As Boolean
Dim anything As Object, pppp As mArray, s$

    If IsExp(bstack, A$, r) Then
        If myVarType(r, vbString) Then
            r = 0
        End If
        Set anything = bstack.lastobj
        
        If CheckIsmArray(anything) Then
        
a13410:

            Set pppp = anything
            
            If FastSymbol(A$, ",") Then
againcons:
                Set bstack.lastobj = Nothing
                If IsExp(bstack, A$, r) Then
                    If myVarType(r, vbString) Then
                        r = 0
                    End If
                    Set anything = bstack.lastobj
                    If CheckIsmArray(anything) Then
a13415:
                        pppp.processAppend anything
                       
                        Set pppp = Nothing
                        Set bstack.lastobj = anything
                        r = 0


                    Else
                        Set pppp = Nothing
                        Set anything = Nothing
                        NotArray
                        Exit Function
                    End If
                ElseIf IsStrExp(bstack, A$, s$, False) Then
                    Set anything = bstack.lastobj
                    If CheckIsmArray(anything) Then GoTo a13415
                Else
                        Set pppp = Nothing
                        Set anything = Nothing
                        Set bstack.lastobj = anything
                        NotArray
                        Exit Function
                End If
            Else
            Dim pppp1 As New mArray
            Set pppp = anything
            pppp.CopyArray pppp1
                Set bstack.lastobj = pppp1
                Set pppp = Nothing
                Set anything = Nothing
                 IsCons = FastSymbol(A$, ")", True)
                Exit Function
            End If
        Else
            Set anything = Nothing
            Set bstack.lastobj = anything
            NotArray
            Exit Function
        End If
        If FastSymbol(A$, ",") Then Set pppp = anything: GoTo againcons
        Set anything = Nothing
        
        IsCons = FastSymbol(A$, ")", True)
    ElseIf IsStrExp(bstack, A$, s$, False) Then
            Set anything = bstack.lastobj
            If CheckIsmArray(anything) Then GoTo a13410
    Else
        MissParam A$
    End If
End Function
Private Function IsCar(bstack As basetask, A$, r As Variant) As Boolean
Dim anything As Object, pppp As mArray, s$, usehandler As mHandler
    If IsExp(bstack, A$, r) Then
car1023:
        If myVarType(r, vbString) Then
            r = 0
        End If
        Set anything = bstack.lastobj
        If CheckIsmArray(anything) Then
            Set pppp = anything
            pppp.Car anything
            If TypeOf anything Is mArray Then
                Set pppp = anything
                Set usehandler = New mHandler
                usehandler.T1 = 3
                Set usehandler.objref = pppp
                Set anything = usehandler
                Set usehandler = Nothing
            End If
            Set bstack.lastobj = anything
            Set pppp = Nothing
            Set anything = Nothing
            
        Else
            NotArray
            Exit Function
        End If
        Set anything = Nothing
        IsCar = FastSymbol(A$, ")", True)
    ElseIf IsStrExp(bstack, A$, s$, False) Then
        GoTo car1023
    Else
        MissParam A$
    End If

End Function
Private Function IsCdr(bstack As basetask, A$, r As Variant) As Boolean
Dim anything As Object, pppp As mArray, s$, usehandler As mHandler
    If IsExp(bstack, A$, r) Then
cdr1022:
        If myVarType(r, vbString) Then
            r = 0
        End If
        Set anything = bstack.lastobj
        If CheckIsmArray(anything) Then
            Set pppp = anything
            pppp.Cdr anything
            Set pppp = anything
            Set usehandler = New mHandler
            usehandler.T1 = 3
            Set usehandler.objref = pppp
            Set bstack.lastobj = usehandler
            Set pppp = Nothing
            Set anything = Nothing
            Set usehandler = Nothing
        ElseIf IsStrExp(bstack, A$, s$, False) Then
        GoTo cdr1022
        Else
            NotArray
            Exit Function
        End If
        IsCdr = FastSymbol(A$, ")", True)
    Else
        MissParam A$
    End If

End Function
Private Function IsTest(bstack As basetask, A$, r As Variant) As Boolean
Dim s$
If IsExp(bstack, A$, r, , True) Then
    If trace Then
        bypassST = r = 0
        STbyST = Not bypassST
         STq = False
        IsTest = FastSymbol(A$, ")", True)
    Else
        r = 0
    End If
    ElseIf IsStrExp(bstack, A$, s$, False) Then
    If trace Then
    If s$ = vbNullString Then s$ = Chr$(1)
    r = (Mid$(Form2.gList2.HeadLine, 10) Like s$)
        bypassST = r <> 0
    Else
    r = 0
    End If
    IsTest = FastSymbol(A$, ")", True)
    
    Else
    
                MissParam A$
    End If
End Function
' if ExecuteVar=0 then continue
' if ExecuteVar=1 then Exit do (after exit)
' if ExecuteVar=2 then GoTo autogosub (after exit)
' if ExecuteVar=3 then goto loopagain  (after exit)
' if ExecuteVar=4 then GoTo contVarNew (after exit)
' if ExecuteVar=5 then GoTo again3 (after exit)
' if ExecuteVar=6 then GoTo parsecommand (after exit)
' if ExecuteVar=7 then GoTo loopcontinue (after exit)
'if ExecuteVar=8 then  goto exitfunc

Sub CopyPointerRef(basestack As basetask, thisobj As Object)
            Dim ohere$, w2 As Long
                            
                                    ohere$ = here$
                                        here$ = thisobj.lasthere
                                        If GetVar(basestack, thisobj.GroupName, w2, , , True) Then
                                        
                                        CopyGroup2 var(w2), basestack
                                        End If
                                    here$ = ohere$
End Sub
Sub CallClear(bstack As basetask, what$, z1 As Variant, Optional minusone As Long = 0)
Dim myobject As Object, ok As Boolean, z As Group

Set z = z1

   If z.IamApointer Then
   ' compiled has minus one reference ??
   'MsgBox z.refcount1 - MinusOne
   If z.refcount1 - minusone > 1 Then Exit Sub
   If z.link Is Nothing Then
   
                    ElseIf z.link.IamFloatGroup Then
                    If minusone < 0 Then
                    If z.LinkGroup.refcount1 - 1 = 0 Then Exit Sub
                    Else
                    If z.LinkGroup.refcount1 = 0 Then Exit Sub
                    End If
                        If z.LinkGroup.HasRemove Then
                            Set bstack.lastobj = z.link
                             z.link.ToDelete = True
                             ProcessOper bstack, myobject, "_%", (0), 1, True
                        End If
                        GoTo conthere
                    End If
                
                ElseIf z.IamFloatGroup Then
                Set bstack.lastobj = z
                z.ToDelete = True
                ProcessOper bstack, myobject, "_%", (0), 1
                
                 Set bstack.lastobj = Nothing
                Else
                
                Set myobject = bstack.soros
                Set bstack.Sorosref = New mStiva
                    NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + "_%()", ok
                     Set bstack.Sorosref = myobject
                 Set myobject = Nothing
                 End If
conthere:
End Sub
Sub SwapStrings(A$, b$)
Dim I As Long, j As Long
GetMem4 VarPtr(A$), I
GetMem4 VarPtr(b$), j
PutMem4 VarPtr(A$), j
PutMem4 VarPtr(b$), I
End Sub

Function FastPureLabel(b$, A$, Optional Pos As Long = 1, Optional convert As Boolean, Optional retdot As Boolean, Optional countdot As Long, Optional trimit As Boolean = True, Optional gr As Boolean) As Long
Dim I&, L As Long, one As Boolean, convat As Boolean, nospace As Boolean, pres As Long
Dim P2 As Long, P1 As Integer, p4 As Long, counter As Long
    A$ = vbNullString
    countdot = 0
    gr = False
    L = Len(b$): If L = 0 Then Exit Function
    If Pos > L Then Exit Function
    P2 = StrPtr(b$) + Pos * 2 - 2: L = L - 1
    p4 = P2 + L * 2
    For I = P2 To p4 Step 2
    GetMem2 I, P1
    Select Case P1
      Case 32, 160, 7, 9
        If nospace Then pres = 0: GoTo exitHere
        If counter = 0 Then
            Pos = Pos + 1
        Else
            Exit Function
        End If
      Case Else
      Select Case P1
        Case 38
            Pos = Pos + 1
            If I < p4 Then
                I = I + 2
                GetMem2 I, P1
                If P1 = 72 Or P1 = 104 Then
                    I = I + 2
                    If I <= p4 Then
                        GetMem2 I, P1
                        If (P1 >= 48 And P1 <= 57) Then
                            I = I - 4
                            Pos = Pos - 1
                            GoTo exitHere
                        ElseIf (P1 >= 97 And P1 <= 102) Then
                            I = I - 4
                            Pos = Pos - 1
                            GoTo exitHere
                        ElseIf (P1 >= 48 And P1 <= 70) Then
                            I = I - 4
                            Pos = Pos - 1
                            GoTo exitHere
                        End If
                    End If
                    I = I - 2
                End If
                I = I - 2
            End If
            FastPureLabel = 2
            GoTo exitHere
        Case 46
            pres = 0
            countdot = countdot + 1
            If retdot Then counter = counter + 1
            If Not retdot Then Pos = Pos + 1
            nospace = True

        Case 64
            FastPureLabel = 0
            If retdot Then
            pres = Pos + 1
            counter = counter + 1
            Else
            If countdot > 0 Then pres = 1
             Pos = Pos + 1
            End If
            convat = True
            nospace = True
        Case 65 To 91, 93 To 122, Is > 191
            counter = counter + 1
            If convert Then
                If P1 > 901 And P1 < 975 Then gr = True
            End If
            GoTo aName
        Case 123
            Pos = Pos + 1
            FastPureLabel = 2
            GoTo exitHere
        Case Else
            GoTo TrimThis
        End Select
    End Select
    Next I
    Pos = Len(b$) + 1
    Exit Function
TrimThis:
    'If pres = 0 Then
    If countdot > 0 And FastPureLabel = 1 Then
        
        A$ = String$(countdot, ".")
    ElseIf pres = 1 Then
        Pos = Pos - 1
    End If
    GoTo exitHere
aName:
    If retdot Then
        If pres = 0 Then countdot = counter - 1
    End If
    P2 = I + 2
    FastPureLabel = 1
    For I = P2 To p4 Step 2
        GetMem2 I, P1
        Select Case P1
            Case 36 ' 3 or 6
                If one Then Exit For
                FastPureLabel = 3
                counter = counter + 1
                one = True
            Case 37  ' 4 or 7
                If one Then Exit For
                FastPureLabel = 4
                counter = counter + 1
                one = True
            Case 40 ' add 3
                If I + 4 <= p4 Then
                    GetMem2 I + 2, P1
                    If P1 = 41 Then
                        GetMem2 I + 4, P1
                        If P1 = 64 Then
                            convat = True
                            If FastPureLabel = 1 Then
                                counter = counter + 4
                                I = I + 6
                                GoTo conthere
                            Else
                                counter = counter + 3
                                L = I + 6
                                For L = L To p4 Step 2
                                    GetMem2 L, P1
                                    If P1 = 64 Then counter = counter + 1 Else Exit For
                                Next L
                                Exit For
                            End If
                        End If
                    End If
                End If
                If FastPureLabel = 1 Then
                    FastPureLabel = 5
                Else
                    FastPureLabel = FastPureLabel + 3
                End If
                counter = counter + 1
                Exit For
conthere:
            Case 902 To 976
                If one Then Exit For
                If Not gr And convert Then gr = True
                counter = counter + 1
            Case 64
                convat = True
                If FastPureLabel = 3 Then
                    counter = counter + 1
                    GetMem2 I + 2, P1
                    Exit For
                End If
                If one Then Exit For
                counter = counter + 1
            Case 46, 48 To 57, 65 To 91, 93 To 122, Is > 191, Is < 0
                If one Then Exit For
                counter = counter + 1
            Case Else
                Exit For
        End Select
    Next I
    If convat Then
        If convert Then
            If gr Then
                A$ = myUcase(Replace$(Mid$(b$, Pos, counter), "@", "."), gr)
            Else
                A$ = UCase(Replace$(Mid$(b$, Pos, counter), "@", "."))
            End If
        Else
            A$ = Replace$(Mid$(b$, Pos, counter), "@", ".")
        End If
    ElseIf convert Then
        If gr Then
            A$ = myUcase(Mid$(b$, Pos, counter), gr)
        Else
            A$ = UCase(Mid$(b$, Pos, counter))
        End If
    Else
        A$ = Mid$(b$, Pos, counter)
    End If
    If retdot Then If pres > 0 Then Mid$(A$, pres - Pos, 1) = "@"
    pres = 0
exitHere:
    If trimit Then
        b$ = Mid$(b$, Pos + counter)
        If pres > 0 Then Mid$(b$, 1, 1) = "."
        Pos = 1
    Else
        Pos = Pos + counter
    End If
End Function
Public Sub aheadstatusANY(A$, Pos As Long)
Dim pos2 As Long
If Len(A$) = 0 Then Exit Sub
Dim V1 As Integer
If Pos = 0 Then Pos = 1
Do While Pos <= Len(A$)
    V1 = AscW(Mid$(A$, Pos, 1))
    If Not (V1 > 0 And V1 < 32) Then
    If V1 = 34 Then
        Pos = Pos + 1
        Do While Pos <= Len(A$)
            V1 = AscW(Mid$(A$, Pos, 1))
            If V1 = 34 Then Exit Do
            If V1 > 0 And V1 < 32 And Not V1 = 9 Then Exit Do
            Pos = Pos + 1
        Loop
    ElseIf V1 = 40 Then
again22:
      Pos = Pos + 1
        If Not BlockParam2p(A$, Pos) Then Exit Do
        If Mid$(A$, Pos + 1, 1) = "#" Then
            Pos = Pos + 1
            GoTo conthere
        ElseIf Mid$(A$, Pos + 1, 1) = "(" Then
            Pos = Pos + 1: GoTo again22
        End If
    ElseIf V1 = 91 Then  ' "["
        Pos = Pos + 1
        If Not BlockParam2s(A$, Pos) Then Exit Do
    ElseIf V1 = 123 Then
        If Pos <= Len(A$) Then
            Pos = blockLen2(A$, Pos + 1)
            If Pos = 0 Then Pos = Len(A$): Exit Do
        End If
    Else
        Select Case V1
        Case Is < 0
        Case 41, 125, Is < 32, 39, 92
        Exit Do
        End Select
        End If
    Else
        If V1 <> 8 And V1 <> 9 Then Exit Do
    End If
        Pos = Pos + 1
        
  
conthere:
  
Loop

End Sub
Function Funcweak(basestack As basetask, s$, Optional W As Long, Optional lastname As String) As String
' no validation of names
' check for "dot"
Dim ww$, original$, s1$, ww1$, p As Variant, w1 As Long
again:
W = IsLabel(basestack, s$, lastname)
ww$ = lastname$
ww1$ = ww$
If W = 8 Then

s1$ = "&" + lastname$
w1 = IsLabel(basestack, s1$, ww$)
If Len(s1$) = 0 Then Exit Function
If ISSTRINGA(s1$, ww$) Then
If IsExp(basestack, s$, p, flatobject:=True, nostring:=True) Then
    If CheckInt64(p) Then
        ww$ = ww$ + "[" + CStr(p) + "]"
    Else
        ww$ = ww$ + "[" + LTrim$(str(p)) + "]"
    End If
End If
If FastSymbol(s$, "][", , 2) Then
    If IsExp(basestack, s$, p, flatobject:=True, nostring:=True) Then
        If CheckInt64(p) Then
            ww$ = ww$ + "[" + CStr(p) + "]"
        Else
            ww$ = ww$ + "[" + LTrim$(str(p)) + "]"
        End If
    End If
End If
If FastSymbol(s$, "]") Then
'If here$ = vbNullString Then
If FastSymbol(s$, "|") Then
W = IsLabel(basestack, s$, lastname)
If W = 1 Then
Funcweak = ww$ + "|" + lastname
ElseIf W = 5 Then
    ww$ = ww$ + "|" + lastname
    If IsExp(basestack, s$, p) Then
        If CheckInt64(p) Then
            ww$ = ww$ + CStr(p)
        ElseIf MemInt(VarPtr(p)) = vbBoolean Then
            ww$ = ww$ + Format$(p, DefBooleanString)
        ElseIf VarType(p) = vbString Then
            ww$ = ww$ + LTrim$(p)
        Else
            p = Int(p)
            ww$ = ww$ + fixthis(p)
        End If
    End If
    If FastSymbol(s$, ")") Then
        Funcweak = ww$ + ")"
    End If
End If
Else
Funcweak = ww$
End If
'Else
'Funcweak = here$ + "." + ww$
'End If

End If
End If
Exit Function
ElseIf W >= 5 Then
s1$ = "&" + ww$ + ")"
w1 = IsLabel(basestack, s1$, ww$)
If w1 = 2 Then
' IT IS A FUNCTION
 ww1$ = ww1$ + ")"
GetSubFullName ww1$, ww$
If FastSymbol(s$, ")") Then
If here$ = vbNullString Then
Funcweak = ww1$
Else
Funcweak = here$ + "." + ww1$
End If
End If
ElseIf w1 = 0 Then
If ISSTRINGA(s1$, ww$) Then
If FastSymbol(s$, ")") Then
Funcweak = ww$
Else
' check parameters
'ww$ = ww$ + "("
again12:
Do

If IsExp(basestack, s$, p) Then
If CheckInt64(p) Then
    ww$ = ww$ + CStr(p)
ElseIf MemInt(VarPtr(p)) = vbBoolean Then
    ww$ = ww$ + Format$(p, DefBooleanString)
ElseIf VarType(p) = vbString Then
    ww$ = ww$ + LTrim$(p)
Else
    p = Int(p)
    ww$ = ww$ + fixthis(p)
End If
ElseIf IsStrExp(basestack, s$, ww1$) Then
ww$ = ww$ + Chr$(34) + ww1$ + Chr$(34)
End If

If Not FastSymbol(s$, ",") Then Exit Do
ww$ = ww$ + ","
Loop
If FastSymbol(s$, ")") Then ww$ = ww$ + ")"
    If FastSymbol(s$, ".") Then ' ............
        If AscW(s$) > 64 Then
            If FastPureLabel(s$, ww1$) > 3 Then
            ww$ = ww$ + "." + ww1$
            GoTo again12
            Else
             ww$ = ww$ + "." + ww1$
            End If
        End If
    
    End If

Funcweak = ww$
End If
End If
End If
Else

s1$ = "&" + ww$
If IsLabel(basestack, s1$, ww1$) = 0 Then

If s1$ = vbNullString Then

GetSubFullName ww$, ww1$
Funcweak = ww1$
Else

If ISSTRINGA(s1$, ww1$) Then
If FastSymbol(s$, ".") Then

If Right$(ww1$, 1) = "$" Then
If IsStrExp(basestack, ww1$, ww$) Then
s$ = ww$ + "." + s$
GoTo again
End If
End If
End If
Funcweak = ww1$
End If
End If
End If
End If

End Function
Function RevisionPrint(basestack As basetask, rest1$, xa As Long, Lang As Long) As Boolean
Dim Scr As Object, oldcol As Long, oldFTEXT As Long, oldFTXT As String, oldpen As Long
Dim par As Boolean, I As Long, f As Long, p As Variant, w4 As Boolean, pn&, s$, dlen As Long
Dim o As Long, w3 As Long, x1 As Long, y1 As Long, X As Double, ColOffset As Long, anyBigInteger As BigInteger
Dim work As Boolean, work2 As Long, skiplast As Boolean, ss$, ls As Long, myobject As Object, counter As Long, Counterend As Long, countDir As Long
Dim bck$, clearline As Boolean, ihavecoma As Boolean, isboolean As Boolean, usehandler As mHandler
Set Scr = basestack.Owner
Dim rest$, where As Long, Final As Boolean

w3 = -1
Dim basketcode As Long, prive As basket
basketcode = GetCode(Scr)
prive = players(basketcode)
With prive
    
If .MAXXGRAPH = 0 Then

MyEr "No form to print", "ДЕМ УПэЯВЕИ ЖЭЯЛА ЦИА ЕЙТЩПЫСГ": Exit Function
End If
PlaceBasketPrive Scr, prive
Scr.FontTransparent = True
On Error GoTo 0
Dim opn&
where = 1
aheadstatusANY rest1$, where
If where > 1 Then
rest$ = Left$(rest1$, where - 1)
Else
.lastprint = False
par = True
GoTo JUMPHERE
End If



par = True
If MaybeIsSymbol3(rest$, "#", f) Then
   If Mid$(rest$, f + 1, 6) Like "[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]" Then
   
   Else
  Mid$(rest$, 1, f) = space$(f)
        If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
        If p < 0 Then
        If p < -1 Then
        
                     .lastprint = False
                     par = False
        End If
        f = p
                     If Not FastSymbol(rest$, ",") Then
                     s$ = vbNullString
                     pn& = 2
                     GoTo isAstring
                     End If
        Else
                     f = CLng(p)
                     If Fkind(f) = FnoUse Or Fkind(f) = Finput Or Fkind(f) = Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": RevisionPrint = False: GoTo exit2
                     Dim clearprive As basket
                     prive = clearprive
                     .lastprint = False
                     par = False
                     If Not FastSymbol(rest$, ",") Then
                     s$ = vbNullString
                     pn& = 2
                     GoTo isAstring
                     End If
                     
                     
            End If
             
       Else
       MyEr "expected file number", "ПЕЯъЛЕМА АЯИХЛЭ АЯВЕъОУ"
       End If
    End If
Else
ss$ = Left$(rest$, MyTrimL(rest$) + 5)
ls = Len(ss$)
If Not IsLabelSYMB3(ss$, s$) Then
                    f = 0
                    
Else
Select Case Lang
Case 1
If Len(s$) > 3 Then
If InStr("BOUP", UCase(Left$(s$, 1))) > 0 Then

Select Case UCase(s$)
        Case "BACK"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 4
        Case "OVER"
        f = 1
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        Case "UNDER"
        f = 2
         Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        Case "PART"
        f = 3
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        Case Else
        ''rest$ = s$ + rest$
        f = 0
        End Select
        Else
        f = 0
        End If
        Else
        f = 0
End If
Case 0, 2
If Len(s$) > 2 Then
If InStr("жпул", myUcase(Left$(s$, 1))) > 0 Then
        Select Case myUcase(s$, True)
        Case "жомто"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 4
        Case "памы"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 1
        Case "упо"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 2
        Case "леяос"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 3
        Case Else
        f = 0
        End Select
        Else
        f = 0
        End If
        Else
        f = 0
End If
Case -1   '' this is for ?
If Len(s$) > 2 Then
If InStr("BOUPжпул", myUcase(Left$(s$, 1))) > 0 Then
Select Case myUcase(s$)
        Case "жомто", "BACK"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 4
        Case "памы", "OVER"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 1
        Case "упо", "UNDER"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 2
        Case "леяос", "PART"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 3
        Case Else
        f = 0
        End Select
        Else
        f = 0
        End If
        Else
        f = 0
        End If
        Lang = 0
        End Select
        
        If f > 0 And .lastprint Then
        .lastprint = False
        
        GetXYb Scr, prive, x1&, y1&
        If f <> 2 Then If x1& > 0 Or y1& >= .mX Then crNew basestack, prive
        End If
If f = 1 Then  ''
    work = True
    oldcol = .Column
    If TypeOf Scr Is MetaDc Then
        Scr.Line2 0&, .currow * .Yt, .mX * .Xt, (.currow) * .Yt + .Yt - 2 * DYP, .Paper, True
    Else
        Scr.Line (0&, .currow * .Yt)-((.mX - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 2 * DYP), .Paper, BF
    End If
    LCTbasket Scr, prive, .currow, 0&
    .Column = .mX - 1
    w4 = True
    oldFTEXT = .FTEXT
    oldFTXT = .FTXT
    oldpen = .mypen
    pn& = 2
    .FTEXT = 4
ElseIf f = 2 Then
    work = True
    oldcol = .Column
    If TypeOf Scr Is MetaDc Then
           Scr.Line2 0&, .currow * .Yt + .Yt - DYP, .mX * .Xt, (.currow) * .Yt + .Yt - DYP, .mypen, True
    Else
         Scr.Line (0&, .currow * .Yt + .Yt - DYP)-((.mX - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - DYP), .mypen, BF
    
    End If
    crNew basestack, prive
    LCTbasketCur Scr, prive
    w4 = True
    oldFTEXT = .FTEXT
    oldFTXT = .FTXT
    oldpen = .mypen
    .FTEXT = 4
    pn& = 2
ElseIf f = 3 Then
' we print in a line with lost chars, so controling the start of printing
' we can render text, like from a view port Some columns are hidden because they went out of screen;
work = True
oldcol = .Column
LCTbasket Scr, prive, .currow, 0&
w4 = True
oldFTEXT = .FTEXT
oldFTXT = .FTXT
.FTEXT = 4
oldpen = .mypen
ElseIf f = 4 Then
    work = True
    clearline = True
    ' LCTbasketCur scr, prive
    If .curpos > 0 Then
    crNew basestack, prive
    LCTbasketCur Scr, prive
    End If
    If TypeOf Scr Is MetaDc Then
        Scr.Line2 0&, .currow * .Yt, (.mX - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP, .Paper, True
    Else
    Scr.Line (0&, .currow * .Yt)-((.mX - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP), .Paper, BF
    End If
      LCTbasketCur Scr, prive
    pn& = 2
End If

f = 0
End If

End If
If w4 Then pn& = 2 Else pn& = 0

s$ = vbNullString
If par Then
    If .FTEXT > 3 And .curpos >= .mX And Not w4 Then
    crNew basestack, prive
    w3 = 0
End If
End If
If par Then
If FastSymbol(rest$, ";") Then

            If .lastprint Then
            .lastprint = False
            LCTbasketCur Scr, prive
            crNew basestack, prive
            End If
         
ElseIf .lastprint Then
If .FTEXT > 3 Then pn& = 7: GoTo newntrance

End If
End If


Do
             If Final Then
             If myobject Is Nothing Then GoTo there1
            End If
   If FastSymbol(rest$, "~(", , 2) Then ' means combine
        ' get the color and then look for @( parameters)
        w3 = -1
    If par Then  ' par is false when we print in files, we can't use color;
   
                 If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then .mypen = CLng(mycolor(p))
                 TextColor Scr, .mypen
                 
                     If FastSymbol(rest$, ",") Then
                     
                                If w4 Or Not work Then
                                  If prive.lastprint Then
                                   prive.lastprint = False
                                   GetXYb Scr, prive, .curpos, .currow
                                                   If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                 If w4 Then LCTbasketCur Scr, prive
                       End If
                                  End If
                               
                              LCTbasketCur Scr, prive
                             
                                Else
                                 If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                 If w4 Then LCTbasketCur Scr, prive
                       End If
                               '' LCTbasketCur scr, prive
                                End If
                                
                                
'                                         GetXYb scr, prive, .curpos, .currow
                   ''  LCTbasketCur scr, prive
                x1 = .Column + .curpos + 1
                y1 = .currow + 1
                
                                pn& = 99
                             GoTo pthere   ' background and border and or images
            
            
                 End If
                         If Not FastSymbol(rest$, ")") Then RevisionPrint = False: Set Scr = Nothing: GoTo exit2
                         pn& = 99
    End If
    ElseIf FastSymbol(rest$, "@(", , 2) Then
    clearline = False
    w3 = -1
               'If Not par Then RevisionPrint = False: Set scr = Nothing: Exit Function
                If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then

                If par Then .curpos = CLng(Fix(p))
                End If
                
                If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                If CLng(Fix(p)) >= .mY Then
                If par Then .currow = .mY - 1
                Else
                If par Then .currow = CLng(Fix(p))
                End If
                End If
                End If

                If FastSymbol(rest$, ",") Then
                
                If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then x1 = CLng(Fix(p))
                Else
                x1 = 1
                End If
                
                If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then y1 = CLng(Fix(p))
                Else
                y1 = 1
                End If

                If FastSymbol(rest$, ",") Then
             '   On Error Resume Next
pthere:
                   
                If par Then LCTbasketCur Scr, prive
                If IsStrExp(basestack, rest$, s$) Then
jmpstr1222:
                p = 0
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, p, , True) Then
                        If MemInt(VarPtr(p)) = vbString Then s$ = p: GoTo jmpstr1222
                            If p <> 0 Then p = True
                        Else
                        p = True
                        End If
                    End If
             
                    x1 = Abs(x1 - .curpos)
                    y1 = Abs(y1 - .currow)
                    
                    If par Then BoxImage Scr, prive, x1, y1, s$, 0, (p)
                    'If P <> 0 Then .currow = y1 + .currow
                ElseIf IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
         
                    If par Then BoxColorNew Scr, prive, x1 - 1, y1 - 1, (p)
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, X, , True) Then
                            If par Then BoxBigNew Scr, prive, x1 - 1, y1 - 1, (X)
                        Else
                            RevisionPrint = False
                            Set Scr = Nothing
                            GoTo exit2
                        End If
                    End If
                Else
                    RevisionPrint = False
                    Set Scr = Nothing
                    GoTo exit2
                
                End If

                End If
             If par Then LCTbasket Scr, prive, .currow, .curpos
                
        If Not FastSymbol(rest$, ")") Then
        RevisionPrint = False
        Set Scr = Nothing
        GoTo exit2
        End If
        work = False
        pn& = 99
        ElseIf LastErNum <> 0 Then
      RevisionPrint = LastErNum = -2
      Set Scr = Nothing
    GoTo exit2
    
    ElseIf FastSymbol(rest$, "$(", , 2) Then
conthere:
w3 = -1
        If IsExp(basestack, rest$, p, , True) Then
        If MemInt(VarPtr(p)) = vbString Then .FTXT = p: GoTo str123456
        If Not par Then p = 0
            .FTEXT = Abs(p) Mod 10
            ' 0 STANDARD LEFT chars before typed beyond the line are directed to the next line
            ' 1  RIGHT
            ' 2 CENTER
            ' 3 LEFT
            ' 4 LEFT PROP....expand to next .Column......
            ' 5 RIGHT PROP
            ' 6 CENTER PROP
            ' 7 LEFT PROP
            ' 8 left and right justify
            ' 9 New in version 8 Left justify(like 7) without word wrap (cut excess)
        ElseIf IsStrExp(basestack, rest$, s$) Then

            .FTXT = s$
        End If
str123456:
        
        If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, flatobject:=True, nostring:=True) Then
                    If par Then
                        p = p - 1
                        If Abs(Int(p Mod (.mX + 1))) < 2 Then
                            MyEr ".Column minimum width is 4 chars", "лИЙЯЭТЕЯО ЛщЦЕХОР СТчКГР ЕъМАИ ОИ ТщССЕЯИР ВАЯАЙТчЯЕР"
                        Else
                            If w4 Or Not work Then
                                LCTbasketCur Scr, prive
                            Else
                                GetXYb Scr, prive, .curpos, .currow
                            End If
                            If w4 Then ColOffset = .curpos    ' now we have columns from offset ColOffset
                                .Column = Abs(Int(p Mod (.mX + 1)))
                            End If
                    End If
                    
                Else
                    RevisionPrint = False
                    Set Scr = Nothing
                    GoTo exit2
                End If
         End If
      
            If Not FastSymbol(rest$, ")") Then
            RevisionPrint = False
            Set Scr = Nothing
            GoTo exit2
            End If
        
        
        If par Then pn& = 99
        ElseIf LastErNum <> 0 Then
       RevisionPrint = LastErNum <> -2
       Set Scr = Nothing
    GoTo exit2
    ElseIf Not myobject Is Nothing Then
takeone:
    '' for arrays only
    If countDir >= 0 Then
    If counter = myobject.count Or (counter > Counterend And Counterend > -1) Or countDir = 0 Then
        Set myobject = Nothing
              SwapStrings rest$, bck$
            '  rest$ = bck$
            ' bck$ = vbNullString
        GoTo taketwo
    End If
Else
        If counter < 0 Or (counter < Counterend And Counterend > -1) Then
        Set myobject = Nothing
            SwapStrings rest$, bck$
             ' rest$ = bck$
            ' bck$ = vbNullString
        GoTo taketwo
    End If
    End If
    
    myobject.Index = counter
    If myobject.IsEmpty Then
        s$ = " "
        counter = counter + countDir
        GoTo isAstring
    Else
            If Not IsNumericPrint(myobject.Value) Then
                If TypeOf myobject Is Enumeration Then
                    
                    
                    
                    s$ = myobject.Value
                    counter = counter + countDir
                   GoTo isAstring
                ElseIf myobject.IsObj Then
                    If myobject.IsEnum(p) Then
                    counter = counter + countDir
                    GoTo isanumber
                    ElseIf myobject.IsObjAt(counter, p) Then
                        
                        If TypeOf p Is BigInteger Then
                        Set anyBigInteger = p
                        p = anyBigInteger.ToString
                        Set anyBigInteger = Nothing
                        counter = counter + countDir
                        GoTo isanumber
                        Else
                        s$ = " "
                        End If
                    Else
                    s$ = " "
                    End If
                Else
                    s$ = myobject.Value
                End If

                
                counter = counter + countDir
                GoTo isAstring
            Else
                If TypeOf myobject Is Enumeration Then
                p = myobject.Value
                Else
                On Error Resume Next
                If Not myobject.IsEnum(p) Then
                p = myobject.Value
                isboolean = VarType(p) = vbBoolean
                
                End If
                If Err.Number > 0 Then p = myobject.Value
                End If
                counter = counter + countDir
                GoTo isanumber
            End If
    End If

    
    ElseIf IsExp(basestack, rest$, p) Then
            If Not basestack.lastobj Is Nothing Then
                
                If Typename(basestack.lastobj) = myArray Then
                Set myobject = basestack.lastobj
                Set basestack.lastobj = Nothing
                Counterend = -1
                counter = 0
                countDir = 1
                bck$ = vbNullString
                SwapStrings rest$, bck$
                'bck$ = rest$
                'rest$ = vbNullString
                GoTo takeone
                ElseIf Typename(basestack.lastobj) = mHdlr Then
                    Set myobject = basestack.lastobj
                    Set usehandler = myobject
                    Set basestack.lastobj = Nothing
                    With myobject
                    If usehandler.UseIterator Then
                        If TypeOf usehandler.objref Is Enumeration Then
                        p = usehandler.objref.Value
                        Set usehandler = Nothing
                        Set myobject = Nothing
                        GoTo isanumber
                        Else
                        Counterend = usehandler.index_End
                        If Counterend = -1 Then
                        Set usehandler = Nothing
                        Set myobject = Nothing
                        GoTo isAstring
                        Else
                        counter = usehandler.index_start
                        If counter <= Counterend Then countDir = 1 Else countDir = -1
                        End If
                        End If
                    Else
                        Counterend = -1
                        counter = 0
                        countDir = 1
                       If usehandler.T1 = 4 Then
                       
                            Set usehandler = Nothing
                            Set myobject = Nothing
                            If MemInt(VarPtr(p)) = vbString Then
                            s$ = p
                                GoTo isAstring
                            Else
                                GoTo isanumber
                            End If
                        ElseIf usehandler.T1 = 2 Then
                            p = 0
                            Set usehandler = Nothing
                            GoTo isanumber
                        ElseIf Not CheckIsmArrayOrStackOrCollection(myobject) Then
                            Set myobject = Nothing
                            Set usehandler = Nothing
                        Else
                                SwapStrings rest$, bck$
                                GoTo takeone
                        End If
                        
                    End If
                    End With
                    If Not CheckLastHandler(myobject) Then
                    NoProperObject
                    rest$ = bck$: RevisionPrint = False: GoTo exit2
                    End If
                    Set usehandler = myobject
                    If Typename(usehandler.objref) = "FastCollection" Then
                             Set myobject = usehandler.objref
                             SwapStrings rest$, bck$
                        GoTo takeone
                    ElseIf Typename(usehandler.objref) = "mStiva" Then
                        Set myobject = usehandler.objref
                        SwapStrings rest$, bck$
                        GoTo takeone

                    ElseIf Typename(usehandler.objref) = myArray Then
                        If usehandler.objref.Arr Then
                            Set myobject = usehandler.objref
                            SwapStrings rest$, bck$
                        GoTo takeone
                        End If
                   ElseIf Typename(usehandler.objref) = "Enumeration" Then
                 
                            Set myobject = usehandler.objref
                 
                            SwapStrings rest$, bck$
                       GoTo takeone
                        End If
                ElseIf TypeOf basestack.lastobj Is VarItem Then
                    p = basestack.lastobj.ItemVariant
                ElseIf TypeOf basestack.lastobj Is BigInteger Then
                    Set anyBigInteger = basestack.lastobj
                    p = ""
                    SwapString2Variant anyBigInteger.ToString, p
                End If
                Set basestack.lastobj = Nothing
            ElseIf VarType(p) = vbBoolean Then
            If opn& = 5 Then
                If ShowBooleanAsString Then
                    s$ = Format$(p, DefBooleanString)
                    GoTo isAstring
                Else
                    p = p * 1
                End If
            
            Else
                isboolean = True
            End If
            ElseIf myVarType(p, vbString) Then
            s$ = p
            GoTo isAstring
            End If
isanumber:
        If par Then
            If .lastprint Then opn& = 5

            pn& = 1
            If .Column = 1 Then
            
            pn& = 6
            End If
            Else
            .lastprint = False
            pn& = 1
           End If
    ElseIf LastErNum <> 0 Then
            .lastprint = False
            RevisionPrint = LastErNum = -2
            Set Scr = Nothing
            GoTo exit2
    ElseIf IsStrExp(basestack, rest$, s$, False) Then    ' was Len(basestack.tmpstr) = 0
     If Not basestack.lastobj Is Nothing Then
                If Typename(basestack.lastobj) = myArray Then
                Set myobject = basestack.lastobj
                Set basestack.lastobj = Nothing
                Counterend = -1
                counter = 0
                countDir = 1
                SwapStrings rest$, bck$
                'bck$ = rest$
                'rest$ = vbNullString
                GoTo takeone
                End If
                
            End If
isAstring:
If par Then

    If .lastprint Then opn& = 5
            pn& = 2
            
      If .Column = 1 Then
            
            pn& = 7
            End If
            Else
             .lastprint = False
            pn& = 2
            End If
    ElseIf LastErNum <> 0 Then
             RevisionPrint = LastErNum = -2
             Set Scr = Nothing
                GoTo exit2
    Else
there1:
    If pn& <> 0 And pn& < 5 And Not .lastprint Then
        If par Then
            If Not w4 Then


If Not (.curpos = 0) Then
GetXYb Scr, prive, .curpos, .currow
If pn& = 1 Then
crNew basestack, prive: skiplast = True
ElseIf pn& = 2 Then

If Abs(w3) = 1 And .curpos = 0 And Not (.FTEXT = 9 Or .FTEXT = 5 Or .FTEXT = 6) Then
If .FTEXT = 7 Then
crNew basestack, prive: skiplast = True
End If
Else
crNew basestack, prive: skiplast = True
End If
End If
End If


            End If
        Else
        If f < 0 Then
            crNew basestack, prive
        ElseIf uni(f) Then
            putUniString f, vbCrLf
            Else
            putANSIString f, vbCrLf
            End If
        End If
    End If
 
        Exit Do
    End If
conthere2:
If .lastprint And opn& > 4 Then .lastprint = False
    If FastSymbol(rest$, ";") Then
'' LEAVE W3
If par Then
   If opn& = 0 And (Not work) And (Not .lastprint) Then

   LCTbasket Scr, prive, .currow, .curpos
   End If
  
   ' IF  WORK THEN opn&=5
   opn& = 5
  End If
newntrance:
work = True
.lastprint = True
        
         Do While FastSymbol(rest$, ";")
         Loop
    ElseIf Not FastSymbol(rest$, ",") Then
    
    pn& = pn& + opn&
  opn& = 0
  rest$ = NLtrim$(rest$)
   '  final = True   ERROR - WHEN myobject is an array/inventory to iterate
    Final = myobject Is Nothing
    Else
If par Then
ihavecoma = True ' 'rest$ = "," & rest$
End If
    End If
    pn& = pn& + opn&
    Select Case pn&
    Case 0
    Exit Do
    Case 1
        If .FTXT = vbNullString Then
        If xa Then
        s$ = PACKLNG2$(p)
        Else
        If isboolean Then
            If ShowBooleanAsString Then
                s$ = Format$(p, DefBooleanString)
                isboolean = False
                GoTo contboolean2
            Else
                p = p * 1
                isboolean = False
                GoTo contboolean2
            End If
        Else
            On Error Resume Next
            Select Case MemByte(VarPtr(p))
             Case 20
                s$ = CStr(p)
             Case vbString
                s$ = LTrim$(p)
             Case 9, 13
                s$ = "*" + Typename$(p)
             Case Else
                s$ = fixthis(p)
             End Select
        
        If Err.Number > 0 Then
                If VarTypeName(p) = "Null" Then
                    s$ = "NULL"
                    Err.Clear
                Else
                    s$ = VarTypeName(p)
                    Err.Clear
                End If
        End If

            
        On Error GoTo 0
    End If
    

contboolean2:
      If .FTEXT < 4 Then
            If InStr(s$, ".") > 0 Then
                 If InStr(s$, ".") <= .Column Then
                        If RealLen(s$) > .Column + 1 Then
                                 If .FTEXT > 0 Then s$ = Left$(s$, .Column + 1)
                        End If
                End If
            ElseIf .FTEXT > 0 Then
                 If RealLen(s$) > .Column + 1 Then s$ = String$(.Column, "?")
            End If
          End If
    End If
        Else
        If TypeOf p Is cxComplex Then
            If p.I = 0 Then
                s$ = Format$(p.r, .FTXT)
            ElseIf p.r = 0 Then
                s$ = "(" & Format$(p.I, .FTXT) & "i)"
            Else
            If p.I < 0 Then s$ = "" Else s$ = "+"
            s$ = "(" & Format$(p.r, .FTXT) & s$ & Format$(p.I, .FTXT) & "i)"
            End If
        Else
            s$ = Format$(p, .FTXT)
        End If
        If Not NoUseDec Then
            If mNoUseDec Then
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                If InStr(s$, "#IN") > 0 Then s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND) + "#", Chr(2) + "#")
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                s$ = Replace$(s$, Chr(2), NowDec$)
                s$ = Replace$(s$, Chr(3), NowThou$)
            ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                s$ = Replace$(s$, ",", Chr(2))
                s$ = Replace$(s$, ".", ",")
                s$ = Replace$(s$, Chr(2), ".")
            End If
          Else
                If InStr(s$, "#IN") > 0 Then s$ = Replace$(s$, ".#", NowDec$ + "#")
            End If
        
        End If
     If par Then
        If .Column > 2 Then   ' .Column 3 means 4 chars width
        If opn& < 5 Then
    '                    ensure that we are align in .Column  (.Column is based zero...)
    skiplast = False
            If Not TypeOf Scr Is MetaDc Then
               If .currow >= .mY And Not TypeOf Scr Is MetaDc Then
               If Not w4 Then crNew basestack, prive: skiplast = True
               End If
                End If
                        If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                 If w4 Then LCTbasketCur Scr, prive
                       End If
                       work = True
    End If
            If .curpos >= .mX Then
    '' ???
                    Else
            If clearline And .curpos = 0 Then
                If Not TypeOf Scr Is MetaDc Then
                    Scr.Line (0&, .currow * .Yt)-((.mX - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP), .Paper, BF
                End If
            End If
            Select Case .FTEXT
            Case 0
            
                       
                       PlainBaSket Scr, prive, space$(.Column - (RealLen(s$) - 1) Mod (.Column + 1)) + s$, w4, w4, , clearline
                       
            Case 3
                        PlainBaSket Scr, prive, Right$(space$(.Column - (RealLen(s$) - 1) Mod (.Column + 1)) + Left$(s$, .Column + 1), .Column + 1), w4, w4, , clearline
            Case 2
                        If RealLen(s$) > .Column + 1 Then s$ = "????"
                        PlainBaSket Scr, prive, Left$(space$((.Column + 1 - RealLen(s$)) \ 2) + Left$(s$, .Column + 1) + space$(.Column), .Column + 1), w4, w4, , clearline
            Case 1
                        PlainBaSket Scr, prive, Left$(s$ + space$(.Column), .Column + 1), w4, w4, , clearline
            Case 5
                        x1 = .curpos
                        y1 = .currow
                        If Not (.mX - 1 <= .curpos And w4 <> 0) Then
                        LCTbasketCur Scr, prive
                        Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                        wwPlain basestack, prive, s$, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2, 0, , True, 0, , CBool(w4), True, , True
                        .currow = y1
        

                        .curpos = x1 + .Column + 1
                        
                        End If
                     If .curpos >= .mX And Not w4 Then
                   
                         .currow = .currow + 1
                         .curpos = 0
                         End If
              If .lastprint Then
                If Not TypeOf Scr Is MetaDc Then
                 If .curpos = 0 Then
                 If .currow >= .mY And Not TypeOf Scr Is MetaDc Then
                 crNew basestack, prive
                 Else
                 LCTbasketCur Scr, prive
                 End If
                 End If
                 End If
                 
     Scr.currentX = .curpos * .Xt
                
                  Scr.currentY = .currow * .Yt + .uMineLineSpace
             
         
                   End If
            Case 4, 7, 8
                         wwPlain basestack, prive, s$ + vbCrLf, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2, 0, , , 1, , , pn& < 5, , True
                        .curpos = .curpos + .Column + 1
                        If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1

                        End If
                        If .lastprint Then
                        
                            If .curpos = 0 Then
                            
                                If .currow >= .mY And Not TypeOf Scr Is MetaDc Then
                                crNew basestack, prive
                             
                              
                                Else
                                LCTbasketCur Scr, prive

                                End If
                            
                            End If
                            If .curpos > 0 Then Scr.currentX = .curpos * .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2 Else Scr.currentX = .curpos * .Xt
                            Scr.currentY = .currow * .Yt + .uMineLineSpace
                        End If
            Case 6
                            
                        wwPlain basestack, prive, s$, .Column * .Xt + .Xt, 0, , False, 2, , , pn& < 5, , True
                        .curpos = .curpos + .Column + 1
                        If .curpos >= .mX And Not w4 Then
                            .curpos = 0
                            .currow = .currow + 1
                        End If
                        If .lastprint Then
                            If .curpos = 0 Then
                                If .currow >= .mY And Not TypeOf Scr Is MetaDc Then
                                crNew basestack, prive
                                Else
                                LCTbasketCur Scr, prive
                                End If
                            End If
                            Scr.currentX = .curpos * .Xt
                            Scr.currentY = .currow * .Yt + .uMineLineSpace
                        End If
                            
            Case 9
                            LCTbasketCur Scr, prive
                            wPlain Scr, prive, s$, 1000, 0, True
                             GetXYb Scr, prive, .curpos, .currow
                           .curpos = .curpos + 1
                            If (.curpos Mod (.Column + 1)) <> 0 Then
                     .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                             '     .curpos = .curpos + .Column + 1
                            If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                                                               If .lastprint Then
     
                 If .curpos = 0 Then
                 If .currow >= .mY And Not TypeOf Scr Is MetaDc Then
                 crNew basestack, prive
                 Else
                 LCTbasketCur Scr, prive
                 End If
                 End If
                If .curpos > 0 Then Scr.currentX = .curpos * .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2 Else Scr.currentX = .curpos * .Xt
                  Scr.currentY = .currow * .Yt + .uMineLineSpace
             
         
                   End If
            End Select
End If
            
            
            
        Else
        ' no way to use this any more...7 rev 20
        PlainBaSket Scr, prive, s$
        End If
 
        Else
          If f < 0 Then
            PlainBaSket Scr, prive, s$
        ElseIf uni(f) Then
            putUniString f, s$
            Else
            putANSIString f, s$
        'Print #f, S$;
        End If
        End If
    Case 2
    '' for string.....................................................................................................................
        If .FTXT <> "" Then
        s$ = Format$(s$, .FTXT)
        End If
        If par Then
        If .Column > 0 Then
                             x1 = .curpos: y1 = .currow
                skiplast = False
                                If .currow >= .mY And Not w4 And Not TypeOf Scr Is MetaDc Then
                                crNew basestack, prive
                                skiplast = True
                                End If
                        If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                     
                      End If
                      '' LCTbasket scr, prive,   y1, X1
                       If w4 Then LCTbasketCur Scr, prive
                       End If
                       work = True
          If s$ = vbNullString Then s$ = " "
          
                 If .curpos >= .mX Then
                 y1 = 1
                    Else
                               If clearline And .curpos = 0 Then
                               If Not TypeOf Scr Is MetaDc Then
                               Scr.Line (0&, .currow * .Yt)-((.mX - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP), .Paper, BF
                               End If
                               End If

            Select Case .FTEXT
                Case 1
                           '' GetXY scr, X1, y1
                          ''  If s$ = VbNullString Then s$ = " "
                          dlen = RealLen(s$)
                          PlainBaSket Scr, prive, Left$(s$ + space$(Len(s$) - dlen + .Column - (dlen - 1) Mod (.Column + 1)), .Column + 1 + Len(s$) - dlen), w4, w4, , clearline
                Case 2
                            dlen = RealLen(s$)
                            If dlen > (.Column + 1 + Len(s$) - dlen) Then s$ = Left$(s$, .Column + 1 + Len(s$) - dlen):  dlen = RealLen(s$)
                            
                            PlainBaSket Scr, prive, Left$(space$((.Column + 1 + Len(s$) - dlen - dlen) \ 2) + s$ + space$(.Column), .Column + 1 + Len(s$) - dlen), w4, w4, , clearline
                Case 3
                            dlen = RealLen(s$)
                            PlainBaSket Scr, prive, Right$(space$(.Column + Len(s$) - dlen - (dlen - 1) Mod (.Column + 1)) + s$, .Column + 1 + Len(s$) - dlen), w4, w4, , clearline
                Case 0
                           '' If s$ = VbNullString Then s$ = " "
                        
                            PlainBaSket Scr, prive, s$ + space$(.Column - (RealLen(s$) - 1) Mod (.Column + 1)), w4, w4, , clearline
                Case 4
                            
                            LCTbasketCur Scr, prive
                            Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                            
                            w3 = 0
                            wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3, True
                            w3 = w3 \ .Xt + 1
                            ' go to next .Column...
                            
                            .curpos = (.Column + 1) * ((w3 + .Column + 1) \ (.Column + 1))
                        If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 5
                           '' GetXY scr, X1, y1
                            LCTbasketCur Scr, prive
                            Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                            wwPlain basestack, prive, s$, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2, 0, , True, 3, , , True
                            .curpos = .curpos + .Column + 1
                            If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 6
                        ''    LCTbasketCur scr, prive
                            wwPlain basestack, prive, s$, .Column * .Xt + .Xt, 0, , False, 2, , , True
                                        .curpos = .curpos + .Column + 1
                            If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                             End If
                Case 7
                            
                            LCTbasketCur Scr, prive
                    work2 = Scr.currentY
                            
                            wwPlain basestack, prive, s$ + vbCrLf, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2, 0, , True, 1, , , True, , True
                       Scr.currentY = work2
                            .curpos = .curpos + .Column + 1
                            If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 8
                            LCTbasketCur Scr, prive
                            Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                            If Not (.mX - 1 <= x1 And w4 <> 0) Then
                                    wwPlain basestack, prive, s$, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2, 0, , True, 0, , , True
                            End If
                            .curpos = .curpos + .Column + 1
                            If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 9
                            LCTbasketCur Scr, prive

              wPlain Scr, prive, s$, .Column + 1, 0, True
                GetXYb Scr, prive, .curpos, .currow
                          .curpos = .curpos + 1
                            If (.curpos Mod (.Column + 1)) <> 0 Then
                     .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                            If .curpos >= .mX And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                End Select
                End If
        Else
            PlainBaSket Scr, prive, s$
        
        End If
        Else
              If f < 0 Then
            PlainBaSket Scr, prive, s$, , , , , True
        ElseIf uni(f) Then
            putUniString f, s$
            Else
            putANSIString f, s$
        'Print #f, S$;
        End If
        End If
    Case 6
        If par Then
                If .FTEXT > 3 Then
            w3 = 0
             x1 = .curpos
             y1 = .currow
                        If .FTXT <> "" Then
                        If TypeOf p Is cxComplex Then
                            If p.I = 0 Then
                                s$ = Format$(p.r, .FTXT)
                            ElseIf p.r = 0 Then
                                s$ = "(" & Format$(p.I, .FTXT) & "i)"
                            Else
                            If p.I < 0 Then s$ = "" Else s$ = "+"
                            s$ = "(" & Format$(p.r, .FTXT) & s$ & Format$(p.I, .FTXT) & "i)"
                            End If
                        Else
                            s$ = Format$(p, .FTXT)
                        End If
            If Not NoUseDec Then
               If mNoUseDec Then
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                If InStr(s$, "#IN") > 0 Then s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND) + "#", Chr(2) + "#")
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                s$ = Replace$(s$, Chr(2), NowDec$)
                s$ = Replace$(s$, Chr(3), NowThou$)
                ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                s$ = Replace$(s$, ",", Chr(2))
                s$ = Replace$(s$, ".", ",")
                s$ = Replace$(s$, Chr(2), ".")
          
                End If
            Else
            If InStr(s$, "#IN") > 0 Then s$ = Replace$(s$, ".#", NowDec$ + "#")
            End If
                               
                                If .FTEXT > 4 And Not work Then Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                                If Scr.currentX < .mX * .Xt Then
                            
                                wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3
                                
                                End If
                            Else
                                If xa Then
                                    s$ = PACKLNG2$(p)
                                Else
                                    If CheckInt64(p) Then
                                        s$ = CStr(p)
                                    ElseIf VarType(p) = vbString Then
                                        s$ = LTrim$(p)
                                    Else
                                        s$ = fixthis(p)
                                    End If

                            End If

                                If .FTEXT > 4 And Not work Then Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                                      If Scr.currentX < 0 Then
                             
                                
                                
                                End If
                                wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3
                                work = True
                                Scr.currentX = w3
                         
                                            
                        End If
                      '' Then LCTbasket scr, prive, y1, W3 \ .Xt + 1
                Else
                        If .FTXT = vbNullString Then
                            If xa Then
                                PlainBaSket Scr, prive, PACKLNG2$(p)
                            Else

                                If CheckInt64(p) Then
                                    s$ = CStr(p)
                                ElseIf VarType(p) = vbString Then
                                    s$ = LTrim$(p)
                                Else
                                    s$ = fixthis(p)
                                End If
                            PlainBaSket Scr, prive, s$
                        End If
                    Else
                          If TypeOf p Is cxComplex Then
                            If p.I = 0 Then
                                s$ = Format$(p.r, .FTXT)
                            ElseIf p.r = 0 Then
                                s$ = "(" & Format$(p.I, .FTXT) & "i)"
                            Else
                            If p.I < 0 Then s$ = "" Else s$ = "+"
                            s$ = "(" & Format$(p.r, .FTXT) & s$ & Format$(p.I, .FTXT) & "i)"
                            End If
                        Else
                            If Left$(.FTXT, 1) = "#" Then
                            s$ = space$(Len(.FTXT))
                            RSet s$ = Format$(p, .FTXT)
                            Else
                            s$ = Format$(p, .FTXT)
                            End If
                        End If
                        If Not NoUseDec Then
                            If mNoUseDec Then
                                s$ = Replace$(s$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                                If InStr(s$, "#IN") > 0 Then s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND) + "#", Chr(2) + "#")
                                s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                                s$ = Replace$(s$, Chr(2), NowDec$)
                                s$ = Replace$(s$, Chr(3), NowThou$)
                            ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                                s$ = Replace$(s$, ",", Chr(2))
                                s$ = Replace$(s$, ".", ",")
                                s$ = Replace$(s$, Chr(2), ".")
                            End If
                        Else
                        If InStr(s$, "#IN") > 0 Then s$ = Replace$(s$, ".#", NowDec$ + "#")
                        End If
                        PlainBaSket Scr, prive, s$
                    End If
                
                End If
            Else
                If f < 0 Then
                    PlainBaSket Scr, prive, s$
                ElseIf uni(f) Then
                    putUniString f, s$
                Else
                    putANSIString f, s$
                End If
            End If
    Case 7
        If par Then
        If s$ <> "" Then
           If .FTEXT > 3 Then
            w3 = 0
             x1 = .curpos
             y1 = .currow
            If Not work Then LCTbasketCur Scr, prive
              If .FTXT <> "" Then s$ = Format$(s$, .FTXT)
                        If .FTEXT > 4 And Not work Then Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                        wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3
                        work = True
                       Scr.currentX = w3
            Else
                If .FTXT <> "" Then
                PlainBaSket Scr, prive, Format$(s$, .FTXT), , , , clearline, , True
                Else
                
                
                PlainBaSket Scr, prive, s$, , , , clearline, , True
                End If
                
            End If
        Else

          
        End If
  
            
        Else
              If f < 0 Then
            PlainBaSket Scr, prive, s$
        ElseIf uni(f) Then
            putUniString f, s$
            Else
            putANSIString f, s$
        ' Print #f, S$;
        End If
        End If
    End Select
taketwo:
If ihavecoma Then
ihavecoma = False
GoTo cont12344
    ElseIf FastSymbol(rest$, ",") Then
cont12344:
        w3 = 1
        pn& = 0
      ''  skiplast = False
        If opn& > 4 Then
            Scr.currentX = Scr.currentX + .Xt - dv15
            GetXYb Scr, prive, .curpos, .currow
            If work Then
                .curpos = .curpos - ColOffset
                If (.curpos Mod (.Column + 1)) <> 0 Then
                    .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                Else
                    .curpos = .curpos + ColOffset
                End If
                If w4 Then LCTbasketCur Scr, prive
            End If
            work = True
        Else
            work = False
        End If
        opn& = 0
        Do While FastSymbol(rest$, ",")
            If par Then
            ' ok I want that
            If .Column > .mX And .FTEXT < 4 Then
            Else
                If Not w4 Then
                    If Not skiplast Then crNew basestack, prive
                End If
            End If
            Else
                If f < 0 Then
                    crNew basestack, prive
                    
                ElseIf uni(f) Then
                    putUniString f, vbCrLf
                Else
                    putANSIString f, vbCrLf
            'Print #f,
                End If
            End If

        Loop
    End If
If par Or f < 0 Then players(basketcode) = prive

Loop
there:
If w4 <> 0 And par Then
        .FTEXT = oldFTEXT
        .FTXT = oldFTXT
        .Column = oldcol
        If .mypen <> oldpen Then .mypen = oldpen: TextColor Scr, oldpen
        ElseIf par Then
        If pn& > 4 And opn& = 0 Then
        
                 If pn& < 99 Then
                 If work Then
                 .lastprint = False
                 End If
                 If Not skiplast Then crNew basestack, prive
                 End If
        ElseIf (.currow >= .mY And Not TypeOf Scr Is MetaDc) Or (w3 < 0 And pn& = 0) Then
JUMPHERE:
              crNew basestack, prive
              LCTbasketCur Scr, prive
        ElseIf pn& > 4 Then
       
        End If

End If
EXITNOW:
If basestack.IamThread Then
' let thread do the refresh
ElseIf par Or f < 0 Then
    If Not extreme Then
    PrintRefresh basestack, Scr
    End If
End If
RevisionPrint = True
If par Or f < 0 Then
    
    players(basketcode) = prive
    If basketcode > 32 Then
     If .ShowCaret Then
           'nomoveLCTC Scr, prive, .currow, .curpos, 0
            LCTCnew Scr, prive, .currow, .curpos
            ShowCaret Scr.hWnd
            players(basketcode) = prive
     End If
    End If
End If

End With

exit2:
If Len(rest$) > 0 Then
    If Len(rest$) < where Then
     
        If where - Len(rest$) = 1 Then
            Mid$(rest1$, 1, Len(rest$)) = rest$
        ElseIf where - Len(rest$) <= Len(rest1$) Then
            Mid$(rest1$, where - Len(rest$), Len(rest$)) = rest$
            rest1$ = Mid$(rest1$, where - Len(rest$))
        End If
    Else
        rest1$ = rest$ + rest1$
    End If
Else
    rest1$ = Mid$(rest1$, where)
End If
If SLOW Then

End If
End Function



Public Function CheckStackObj(bstack As basetask, anything As Object, Optional counter As Long) As Boolean
Dim usehandler As mHandler
If TypeOf bstack.lastobj Is mHandler Then
        Set usehandler = bstack.lastobj
        If usehandler.T1 <> 3 Then Exit Function
        counter = usehandler.index_cursor + 1
        Set anything = bstack.lastobj
        Set bstack.lastobj = Nothing
        If CheckDeepAny(anything) Then CheckStackObj = True
End If
        
End Function

Function IsEnumLabelOnly(bstack As basetask, b$) As Boolean
Dim usehandler0 As mHandler, usehandler As mHandler, ss$, I As Long, that, once As Boolean
    If lookOne(b$, ".") Then
        If IsNumber(bstack, b$, that) Then
            If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is mHandler Then
                    Set usehandler0 = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    GoTo conthere1012
                End If
            End If
        End If
    ElseIf FastPureLabel(b$, ss$) = 1 Then
        If GetVar(bstack, myUcase(ss$), I) Then
            If TypeOf var(I) Is mHandler Then
                Set usehandler0 = var(I)
conthere1012:
                If usehandler0.T1 = 4 Then
                        
                        Set usehandler = New mHandler
                        usehandler.T1 = 4
                        Set usehandler.objref = usehandler0.objref
                        usehandler.index_start = usehandler0.index_start
                        usehandler.index_cursor = usehandler0.index_cursor
                        usehandler.sign = 1
                        Set bstack.lastobj = usehandler
                        IsEnumLabelOnly = True
                        Exit Function
                End If
            End If
        End If
    End If

End Function
Function IsEnumAs(bstack As basetask, b$, p, Optional initval As Boolean, Optional part$) As Boolean
initval = False

Dim usehandler0 As mHandler, usehandler As mHandler, ss$, I As Long, that, once As Boolean
    If lookOne(b$, ".") Then
        If IsNumber(bstack, b$, that) Then
            If bstack.lastobj Is Nothing Then GoTo aa2
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler0 = bstack.lastobj
                Set bstack.lastobj = Nothing
                GoTo conthere1001
            End If
        End If
        GoTo aa2
    ElseIf FastPureLabel(b$, ss$) = 1 Then
backhere:
        If GetVar(bstack, myUcase(ss$), I) Then
            If MyIsObject(var(I)) Then
                If TypeOf var(I) Is mHandler Then
                    Set usehandler0 = var(I)
conthere1001:
                    If usehandler0.T1 = 4 And usehandler0.IamEnum = False Then
                        Set usehandler = New mHandler
                        usehandler.T1 = 4
                        Set usehandler.objref = usehandler0.objref
                        usehandler.index_start = 0
                        usehandler.index_cursor = usehandler0.objref.ZeroValue
                        If p < 0 Then
                            usehandler.sign = -1
                        Else
                            usehandler.sign = 1
                        End If
                        Set p = usehandler
                        If Len(part$) = 0 Then
                            If FastSymbol(b$, "=") Then
                                If lookOne(b$, ".") Then
                                    If IsNumber(bstack, b$, that) Then
                                        If Not bstack.lastobj Is Nothing Then
                                            If TypeOf bstack.lastobj Is mHandler Then
                                                Set usehandler0 = bstack.lastobj
                                                Set bstack.lastobj = Nothing
                                                GoTo conthere1012
                                            End If
                                        End If
                                    End If
                                ElseIf FastPureLabel(b$, ss$) = 1 Then
                                    If GetVar(bstack, myUcase(ss$), I) Then
                                        If TypeOf var(I) Is mHandler Then
                                            Set usehandler0 = var(I)
conthere1012:
                                            If usehandler0.T1 = 4 Then
                                                If usehandler0.objref.EnumName = usehandler.objref.EnumName Then
                                                    initval = True
                                                    usehandler.index_start = usehandler0.index_start
                                                    usehandler.index_cursor = usehandler0.index_cursor
                                                    usehandler.sign = 1
                                                    IsEnumAs = True
                                                    Exit Function
                                                Else
                                                    usehandler0.CopyTo usehandler0
                                                    If usehandler.objref.ExistFromOther2(usehandler0) Then
                                                        Set usehandler0.objref = usehandler.objref
                                                        usehandler0.index_start = usehandler.objref.Index
                                                        initval = True
                                                        Set usehandler = usehandler0
                                                        usehandler.sign = 1
                                                        Set p = usehandler
                                                        IsEnumAs = True
                                                        Exit Function
                                                    End If
                                                End If
                                            End If
                                        End If
                                    End If
                                End If
                            Else
                                IsEnumAs = True
                                Exit Function
                            End If
                        ElseIf FastSymbol(part$, "=") Then
                            If lookOne(part$, ".") Then

                                If IsNumber(bstack, part$, that) Then
checknow:
                                    If Not bstack.lastobj Is Nothing Then
                                        If TypeOf bstack.lastobj Is mHandler Then
                                            Set usehandler0 = bstack.lastobj
                                            Set bstack.lastobj = Nothing
                                            GoTo conthere1002
                                        End If
                                    End If
                                End If
                            ElseIf FastPureLabel(part$, ss$) = 1 Then
                                If GetVar(bstack, myUcase(ss$), I) Then
                                    If TypeOf var(I) Is mHandler Then
                                        Set usehandler0 = var(I)
conthere1002:
                                        If usehandler0.T1 = 4 Then
                                            If usehandler0.objref.EnumName = usehandler.objref.EnumName Then
                                                initval = True
                                                usehandler.index_start = usehandler0.index_start
                                                usehandler.index_cursor = usehandler0.index_cursor
                                                usehandler.sign = 1
                                                initval = True
                                                IsEnumAs = True
                                                Exit Function
                                            Else
                                                usehandler0.CopyTo usehandler0
                                                If usehandler.objref.ExistFromOther2(usehandler0) Then
                                                    Set usehandler0.objref = usehandler.objref
                                                    usehandler0.index_start = usehandler.objref.Index
                                                    initval = True
                                                    Set usehandler = usehandler0
                                                    usehandler.sign = 1
                                                    Set p = usehandler
                                                    IsEnumAs = True
                                                    Exit Function
                                                End If
                                            End If
                                        End If
                                    End If
                                Else
                                If Len(bstack.UseGroupname) > 0 Then
                                    If IsNumber(bstack, "." + ss$, that) Then
                                    GoTo checknow
                                    End If
                                End If
                                End If
                            End If
                        Else
                            IsEnumAs = True
                            Exit Function
                        End If
                    End If
                End If
            End If
        ElseIf once Then
        
        ElseIf Len(bstack.UseGroupname) > 0 Then
        ss$ = bstack.UseGroupname + ss$
        once = True
        GoTo backhere
        End If
    Else
aa2:
        ExpectedEnumType
    End If
End Function

Public Function exeSelect(ExecuteLong, once As Boolean, bstack As basetask, b$, v As Long, Lang As Long) As Boolean
Dim ok As Boolean, x1 As Long, y1 As Long, sp As Variant, st As Variant, sw$, slct As Long, ss$
Dim x2 As Long, y2 As Long, p As Variant, W$, dum As Boolean, I As Long, nd&, lbl$, usehandler As mHandler
Dim checkenum As Boolean, enumindex As Long, EnumName As String, that As BigInteger
exeSelect = True
x1 = 0 ' mode numbers using p, sp and st
If IsLabelSymbolNew(b$, "ле", "CASE", Lang) Then

    If IsExpBig(bstack, b$, sp, , Not checkenum) Then
        If myVarType(sp, vbString) Then
            sw$ = sp
            x1 = 2
        Else
            If Not bstack.lastobj Is Nothing Then
                If TypeOf bstack.lastobj Is BigInteger Then
                    Set that = bstack.lastobj
                End If
            End If
            Set bstack.lastobj = Nothing
             x1 = 1
        End If
    ElseIf IsStrExp(bstack, b$, sw$) Then
        x1 = 2
    End If
secondentry:
    If x1 > 0 Then ' SELECT CASE NUMBER or STRING
        SetNextLine b$
        While MaybeIsSymbol(b$, RemChar)
            SetNextLine b$
        Wend
        slct = 1
        If NocharsInLine(b$) Then
            ExpectedCaseorElseorEnd
            ExecuteLong = 0
            Exit Function
        End If
        Do
            If NocharsInLine(b$) Then Exit Do
            IsNumberLabel b$, lbl$
            If IsLabelSymbolNew(b$, "ле", "CASE", Lang) Then  ' WE HAVE CASE
jumphere1:
                If IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then GoTo case1else
                If ok Then
                    ExpectedEndSelect
                    ExecuteLong = 0
                    Exit Function
                End If
                If slct > 0 Then         ' WE ARE IN SEARCH
                    Do
                        x2 = 0
                        If x1 = 1 Then
                            If IsExpBig(bstack, b$, p, , Not checkenum) Then
                                If Not that Is Nothing Then

                                If bstack.lastobj Is Nothing Then
                                    Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(p)))
                                ElseIf Not TypeOf bstack.lastobj Is BigInteger Then
                                    Set bstack.lastobj = Nothing
                                    GoTo err001101
                                End If
                                    If IsLabelSymbolNew(b$, "еыс", "TO", Lang) Then
                                    Dim that1 As BigInteger
                                        Set that1 = bstack.lastobj
                                        If IsExpBig(bstack, b$, p, , Not checkenum) Then

                                        If bstack.lastobj Is Nothing Then
                                            Set bstack.lastobj = Module13.CreateBigInteger(CStr(Int(p)))
                                        ElseIf Not TypeOf bstack.lastobj Is BigInteger Then
                                            Set bstack.lastobj = Nothing
                                            GoTo err001101
                                        End If
                                        If (that.compare(that1) > -1 And that.compare(bstack.lastobj) < 1) Or slct = -1 Then
                                            Set that1 = Nothing
                                            Set bstack.lastobj = Nothing
                                            If slct = 1 Then slct = 0: GoTo selslct0
                                             GoTo contLoop
                                        End If
                                       
                                        Set that1 = Nothing
                                        Set bstack.lastobj = Nothing
                                         GoTo contLoop
                                        Else
                                            Set bstack.lastobj = Nothing
                                            GoTo err001101
                                        End If
                                    ElseIf that.compare(bstack.lastobj) = 0 Or slct = -1 Then
                                        Set bstack.lastobj = Nothing
                                        If slct = 1 Then slct = 0: GoTo selslct0
                                        GoTo contLoop
                                    End If
                                    Set bstack.lastobj = Nothing
                                    GoTo contLoop
                                ElseIf checkenum Then
                                    If bstack.lastobj Is Nothing Then GoTo cont00123
                                    If Not TypeOf bstack.lastobj Is mHandler Then GoTo err001101
                                    Set usehandler = bstack.lastobj
                                    Set bstack.lastobj = Nothing
                                    If usehandler.T1 <> 4 Then GoTo err001101
                                    usehandler.objref.Index = usehandler.index_start
                                    If EnumName = usehandler.objref.KeyToString() Or slct = -1 Then
                                        Set usehandler = Nothing
                                        If slct = 1 Then slct = 0: GoTo selslct0
                                        GoTo contLoop
                                    End If
                                ElseIf Not bstack.lastobj Is Nothing Then
                                    If Not TypeOf bstack.lastobj Is BigInteger Then
                                        GoTo err001101
                                    End If
                                    Set that = bstack.lastobj
                                    
                                    If that.compare(Module13.CreateBigInteger(CStr(Int(sp)))) = 0 Or slct = -1 Then
                                        Set bstack.lastobj = Nothing
                                        Set that = Nothing
                                        If slct = 1 Then slct = 0: GoTo selslct0
                                        GoTo contLoop
                                    End If
                                    Set bstack.lastobj = Nothing
                                    Set that = Nothing
                                    
                                Else
cont00123:
                                    If MemInt(VarPtr(p)) = vbString Then SwapString2Variant W$, p: x2 = 2 Else x2 = 1
                                End If
                            ElseIf IsStrExp(bstack, b$, W$) Then
                                x2 = 2
                            End If
                        Else
                            If IsExp(bstack, b$, p, , Not checkenum) Then
                                If MemInt(VarPtr(p)) = vbString Then
                                    W$ = p: x2 = 2
                                Else
                                            y1 = UINT(p)
                                            If y1 >= &H10000 And y1 <= &H10FFFF Then
                                                y1 = y1 - &H10000
                                                W$ = ChrW(UINT(y1 \ &H400& + &HD800&)) + ChrW(UINT((y1 And &H3FF&) + &HDC00&))
                                            Else
                                                W$ = ChrW$(y1)
                                            End If
                                            y1 = 0
                                
                                
                                
                                    x2 = 2
                                End If
                                
                            ElseIf IsStrExp(bstack, b$, W$, False) Then
                                x2 = 2
                            End If
                        End If
                        If x2 > 0 Then 'WE HAVE NUMBER OR STRING
                            If checkenum Then
                            ' do nothing
                            GoTo CONT1234
                            ElseIf IsLabelSymbolNew(b$, "еыс", "TO", Lang) Then   ' range ?
                                y1 = 0
                                If x1 = 1 Then
                                    If IsExp(bstack, b$, st, , True) Then
                                        If MemInt(VarPtr(st)) = vbString Then
                                            st = 0
                                        End If
                                        y1 = 1
                                    
                                    Else
                                    
                                    End If
                                Else
                                    If IsStrExp(bstack, b$, ss$) Then
                                    
                                    y1 = 2
                                    ElseIf IsExp(bstack, b$, st, , True) Then
                                        If MemInt(VarPtr(st)) = vbString Then
                                            SwapString2Variant ss$, st
                                            y1 = 2
                                        Else
                                            y1 = UINT(st)
                                            If y1 >= &H10000 And y1 <= &H10FFFF Then
                                                y1 = y1 - &H10000
                                                ss$ = ChrW(UINT(y1 \ &H400& + &HD800&)) + ChrW(UINT((y1 And &H3FF&) + &HDC00&))
                                            Else
                                                ss$ = ChrW$(y1)
                                            End If
                                            y1 = 2
                                        End If
                                    End If
                                End If
                                If y1 > 0 Then
                                    y2 = 0
                                    If x1 = 1 Then
                                        If (sp >= p And sp <= st) Then y2 = 1
                                    Else
                                        If sw$ >= W$ And sw$ <= ss$ Then y2 = 2
                                    End If
                                    If y2 > 0 Or slct = -1 Then 'slct=-1 from break
                                        If slct = 1 Then slct = 0   ' slct=0 we found
                                        ' start ExecuteLong command or block
                                    End If
                                Else
                                    MyEr "Wrong expression type in To clause in Case", "кэХОР ТЩПОР щЙЖЯАСГР СТГМ ╦ЫР СТГМ лЕ"
                                    ExecuteLong = 0
                                    Exit Function
                                End If
                            Else
CONT1234:
                                ' NO WE HAVE ONE VALUE...X1 MASTER, X2 ONE VALUE  Y2 FOR LAST CHECK
                                y2 = 0
                                If x1 = 1 Then
                                    If sp = p And x2 = 1 Then y2 = 1
                                Else
                                    If W$ = sw$ Then y2 = 2
                                End If
                                If y2 > 0 Or slct = -1 Then ' ONE VALUE
                                    If slct = 1 Then slct = 0
                                End If
                            End If
                        ElseIf Not checkenum Then
                            
                            If Not that Is Nothing Then Set p = that Else p = sp
                            If IsHalfLogic(bstack, b$, p) Then
                                If p <> 0 Or slct = -1 Then
                                    If slct = 1 Then slct = 0
                                    ' start ExecuteLong command or block
                                End If
                            Else
                                MyEr "Expected logic half expression in Case", "пЕЯъЛЕМА КОЦИЙч ЛИСч щЙЖЯАСГ СТГМ лЕ"
                                ExecuteLong = 0
                                Exit Function
                            End If
                        End If
                        If slct = 0 Then
selslct0:
                            If Left$(b$, 4) = vbCrLf + vbCrLf Then
                                ExpectedCaseorElseorEnd
                                b$ = Mid$(b$, 3)
                                ExecuteLong = 0: Exit Function
                            End If
                            SetNextLine b$
conthere:
                            If FastSymbol(b$, "{") Then  ' block
                                ss$ = block(b$)
                                dum = False
                                I = 1
                                ' #3 call a block
                                TraceStore bstack, nd&, b$, 0
                                Call executeblock(I, bstack, ss$, False, dum, , True)
                                TraceRestore bstack, nd&
                                If I = 1 Then
                                    FastSymbol b$, "}"
                                    If Not MaybeIsSymbol(b$, RemChar) Then
                                        If Not Left$(b$, 2) = vbCrLf Then
                                            ExpectedCommentsOnly
                                            ExecuteLong = 0: Exit Function
                                        End If
                                    End If
                                Else
                                    If I = 0 Then
                                        b$ = ss$ + b$
                                        ExecuteLong = 0: Exit Function
                                    ElseIf I = 2 Then
                                        If Len(ss$) > 0 Then b$ = ss$
                                        If dum = True And b$ <> "" Then
                                            slct = -1
                                        Else
                                            GoTo ContGoto
                                        End If
                                    ElseIf I = 3 Then
                                        If Len(ss$) > 0 Then b$ = ss$
                                        If dum = True And b$ <> "" Then slct = 0
                                    End If
                                End If
                            Else   ' or line
                                dum = True
                                I = 1
                                IsNumberLabel b$, lbl$
                                While IsLabelSymbolNew(b$, "ле", "CASE", Lang)
                                    SetNextLine b$
                                    IsNumberLabel b$, lbl$
                                Wend
                                ' #4 call one command
                                If lookOne(b$, "{") Then
                                    GoTo conthere
                                End If
                                once = True
                                ss$ = GetNextLine(b$) + vbCrLf + "'"
                                TraceStore bstack, nd&, b$, 3
                                Call executeblock(I, bstack, ss$, once, dum, True, True)
                                bstack.addlen = nd&
                                If I = 0 Then
                                    ExecuteLong = 0: Exit Function
                                ElseIf I = 1 And ss$ = vbNullString And once Then 'this is an exit ой3
                                    b$ = vbNullString
                                    ExecuteLong = 1
                                    Exit Function
                                ElseIf I = 2 Then
                                    If dum = True And Len(ss$) > 0 Then
                                        slct = -1
                                    ElseIf Len(ss$) > 0 Then
                                        b$ = ss$
                                        ExecuteLong = 2
                                        once = False
                                        Exit Function
                                    Else
                                        ExecuteLong = I
                                        b$ = ss$
                                        exeSelect = dum
                                    End If
                                ElseIf I = 3 Then
                                    If dum = True And ss$ <> "" Then
                                        slct = 0
                                    Else
                                        I = 2
                                        b$ = vbNullString
                                        exeSelect = True
                                    End If
                                ElseIf I = 5 Then
                                    ExecuteLong = 2
                                    exeSelect = False
                                End If
                            End If
                            Exit Do
                        End If
contLoop:
                    Loop While FastSymbol(b$, ",")
                End If
                SetNextLine b$
                If Left$(b$, 2) = vbCrLf Then
                    ExpectedCaseorElseorEnd
                    ExecuteLong = 0
                    Exit Function
                End If
                ' drop case
                IsNumberLabel b$, lbl$
                If IsLabelSymbolNew(b$, "ле", "CASE", Lang) Then
                    GoTo jumphere1
                ElseIf IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then
                    GoTo jumphere2
                ElseIf IsLabelSymbolNew(b$, "текос", "END", Lang) Then
                    GoTo jumphere3
                Else
                    If FastSymbol(b$, "{") Then
                        If slct >= 0 Then
                            ss$ = block(b$) + "}"
                            b$ = NLtrim$(Mid$(b$, 2))
                        Else
                            ss$ = block(b$)
                            dum = False
                            I = 1
                            ' #7 call block inside Case (Break) ok
                            TraceStore bstack, nd&, b$, 0
                            Call executeblock(I, bstack, ss$, False, dum, , True)
                            TraceRestore bstack, nd&
                            If I = 1 Then
                                FastSymbol b$, "}"
                                If Not MaybeIsSymbol(b$, RemChar) Then
                                    If Not Left$(b$, 2) = vbCrLf Then
                                        ExpectedCommentsOnly
                                        ExecuteLong = 0: Exit Function
                                    End If
                                End If
                            Else
                                If I = 0 Then
                                    b$ = ss$ + b$
                                    ExecuteLong = 0: Exit Function
                                ElseIf I = 2 Then
                                    If Len(ss$) > 0 Then b$ = ss$
                                    If dum = True And b$ <> "" Then
                                        slct = -1
                                    Else
                                        GoTo ContGoto
                                    End If
                                ElseIf I = 3 Then
                                    If Len(ss$) > 0 Then b$ = ss$
                                    If dum = True And b$ <> "" Then slct = 0
                                End If
                            End If
                        End If
                        SetNextLine b$
                    ElseIf slct < 0 Then
                        dum = True
                        I = 1
                        ' #8 call one command inside Case (Break) ok
                        once = True
                        ss$ = GetNextLine(b$) + vbCrLf + "'"
                        TraceStore bstack, nd&, b$, 3
                        Call executeblock(I, bstack, ss$, once, dum, True, True)
                        bstack.addlen = nd&
                        If I = 0 Then
                            ExecuteLong = 0: Exit Function
                        ElseIf I = 1 And ss$ = vbNullString And once Then  'this is an exit ой3
                            b$ = vbNullString
                            ExecuteLong = 1
                            Exit Function
                        ElseIf I = 2 Then
                            If dum = True And Len(ss$) > 0 Then
                                slct = -1
                            ElseIf Len(ss$) > 0 Then
                                b$ = ss$
                                ExecuteLong = 2
                                once = False
                                Exit Function
                            Else
                                ExecuteLong = I
                                b$ = ss$
                                exeSelect = dum
                            End If
                        ElseIf I = 3 Then
                            If dum = True And ss$ <> "" Then
                                slct = 0
                            Else
                                I = 2
                                b$ = vbNullString
                                exeSelect = True
                            End If
                        ElseIf I = 5 Then
                            ExecuteLong = 2
                            exeSelect = False
                        End If
                        SetNextLine b$
                    Else
                        SetNextLine b$
                    End If
                End If
            ElseIf IsLabelSymbolNew(b$, "аккиыс", "ELSE", Lang) Then
jumphere2:
                IsLabelSymbolNew b$, "ле", "CASE", Lang
case1else:
                If ok Then
                    ExpectedEndSelect
                    ExecuteLong = 0
                    Exit Function
                Else
                    ok = True
                End If
                SetNextLine b$
                If FastSymbol(b$, "{") Then
                    ss$ = block(b$)
                    If slct > 0 Then
                        dum = False
                        I = 1
                        ' #9 call block inside Else
                        TraceStore bstack, nd&, b$, 0
                        Call executeblock(I, bstack, ss$, False, dum, , True)
                        TraceRestore bstack, nd&
                        If I = 1 Then
                            FastSymbol b$, "}"
                            If Not MaybeIsSymbol(b$, RemChar) Then
                                If Not Left$(b$, 2) = vbCrLf Then
                                    ExpectedCommentsOnly
                                    ExecuteLong = 0: Exit Function
                                End If
                            End If
                        Else
                            If I = 0 Then
                                b$ = ss$ + b$
                                ExecuteLong = 0: Exit Function
                            ElseIf I = 2 Then
                                If Len(ss$) > 0 Then b$ = ss$
                                If dum = True And b$ <> "" Then
                                    slct = -1
                                ElseIf b$ <> "" Then
                                    GoTo ContGoto
                                Else
                                    once = True
                                    Exit Function
                                End If
                            ElseIf I = 3 Then
                                If Len(ss$) > 0 Then b$ = ss$
                                If dum = True And b$ <> "" Then slct = 0: b$ = Mid$(b$, 2): GetNextLine (ss$)
                            End If
                        End If
                    Else
                        b$ = NLtrim$(Mid$(b$, 2))
                    End If
                Else
                    If slct > 0 Then
                        dum = True
                        I = 1
                        ' #10 call one command inside ELSE
                        once = True
                        dum = True
                        'TraceStore bstack, nd&, b$, 0
                        ss$ = GetNextLine(b$) + vbCrLf + "'"
                        TraceStore bstack, nd&, b$, 3
                        Call executeblock(I, bstack, ss$, once, dum, True, True)
                        TraceRestore bstack, nd&
                        If I = 0 Then
                            ExecuteLong = 0: Exit Function
                        ElseIf I = 1 And ss$ = vbNullString And once Then  'this is an exit
                            b$ = vbNullString
                            ExecuteLong = 1
                            Exit Function
                        ElseIf I = 2 Then
                            If dum = True And Len(ss$) > 0 Then
                                slct = -1
                            ElseIf Len(ss$) > 0 Then
                                b$ = ss$
                                ExecuteLong = 2
                                once = False
                                Exit Function
                            Else
                                ExecuteLong = I
                                b$ = ss$
                                exeSelect = dum
                                Exit Function
                            End If
                        ElseIf I = 3 Then
                            If dum = True And ss$ <> "" Then
                                slct = 0
                            Else
                                I = 2
                                b$ = vbNullString
                                exeSelect = True
                            End If
                        ElseIf I = 5 Then
                            ExecuteLong = 2
                            exeSelect = False
                        End If
                    End If
                End If
                SetNextLine b$
                slct = 0
            ElseIf IsLabelSymbolNew(b$, "текос", "END", Lang) Then
jumphere3:
                If IsLabelSymbolNew(b$, "епикоцгс", "SELECT", Lang) Then
                    slct = 0
                    Exit Do
                Else
                    ExpectedEndSelect
                    ExecuteLong = 0
                    Exit Function
                End If
            Else
                If ok Then
                    ExpectedEndSelect2
                Else
                    ExpectedCaseorElseorEnd2
                End If
                ExecuteLong = 0
                Exit Function
            End If
        Loop
        If slct > 0 Then
            ExecuteLong = 0: Exit Function
        End If
    Else
        ExecuteLong = 0
        Exit Function
    End If
ElseIf IsLabelSymbolNew(b$, "апая", "ENUM", Lang) Then
here12002:
    If IsExp(bstack, b$, sp) Then
        If bstack.lastobj Is Nothing Then GoTo err001101
        If Not TypeOf bstack.lastobj Is mHandler Then GoTo err001101
        Set usehandler = bstack.lastobj
        Set bstack.lastobj = Nothing
        If usehandler.T1 <> 4 Then GoTo err001101
        sp = usehandler.index_cursor
        
        If myVarType(sp, vbString) Then
            sw$ = sp
            x1 = 2
        Else
             x1 = 1
        End If
        
        enumindex = usehandler.index_start
        usehandler.objref.Index = enumindex
        EnumName = usehandler.objref.KeyToString()
        checkenum = True
        Set usehandler = Nothing
        
        GoTo secondentry
    End If
    GoTo err001101
ElseIf IsLabelSymbolNew(b$, "апаяихлгсг", "ENUMERATION", Lang) Then
    GoTo here12002
Else
err001101:
    ExecuteLong = 0
    Exit Function
End If
exeSelect = False
Exit Function
ContGoto:
If MyTrim$(b$) = vbNullString Or FastSymbol(b$, ":") Then
    ExecuteLong = 0
    MissingLabel
    Exit Function
Else
' GET OUT FOR NEXT
    I = FastPureLabel(b$, W$)
    If I = 1 Then
        once = False
        b$ = W$
        ExecuteLong = 2
        Exit Function
    ElseIf I = 0 Then
        If IsNumberLabel(b$, W$) Then
            once = False
            b$ = W$
            ExecuteLong = 2
            Exit Function
        Else
            b$ = W$ + b$
        End If
    Else
        b$ = W$ + b$
    End If
End If
End Function

Function GetArrayReference(bstack As basetask, A$, v$, pp, result As mArray, Index As Long) As Boolean
Dim dn As Long, dd As Long, p, w3, w2 As Long, pppp As mArray, usehandler As mHandler
If pp Is Nothing Then Exit Function
If Not TypeOf pp Is mArray Then
If TypeOf pp Is mHandler Then
Set usehandler = pp
With usehandler
If .T1 = 3 Then If Not .objref Is Nothing Then If TypeOf .objref Is mArray Then Set pp = .objref: GoTo cont
End With
End If
Exit Function
End If
cont:
Set usehandler = Nothing
Set pppp = pp

If pppp.Arr Then
dn = 0

pppp.SerialItem (0), dd, 5
dd = dd - 1
If dd < 0 Then If Typename(pppp.GroupRef) = mProp Then Exit Function
            
            
p = 0
    GetArrayReference = True
    w2 = 0



        Do While dn <= dd
                    pppp.SerialItem w3, dn, 6
                    
                        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                        If dn < dd Then
                            If Not FastSymbol(A$, ",") Then: MyErMacro A$, "need index for " + v$ + ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " + v$ + ")": GetArrayReference = False: Exit Function
                           
                            Else
                         If FastSymbol(A$, ",") Then
                        GetArrayReference = False
                        MyErMacro A$, "too many indexes for array " + v$ + ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " + v$ + ")"
                        Exit Function
                         
                         End If
                            If Not FastSymbol(A$, ")") Then: MissSymbol ")": GetArrayReference = False: Exit Function
                            
                         
                        End If
                            On Error Resume Next
                            If p < -pppp.myarrbase Then
                            GetArrayReference = False
                              MyErMacro A$, "index too low for array " + v$ + ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " + v$ + ")"
                            Exit Function
                            End If
                            
                        If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
                                GetArrayReference = False
                                MyErMacro A$, "index too high for array " + v$ + ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " + v$ + ")"
                                GetArrayReference = False
                            Exit Function
                            End If
                            On Error GoTo 0
                        Else
                        
                         GetArrayReference = False
                        If LastErNum = -2 Then
                        Else
                        
                        MyErMacro A$, "missing index for array " + v$ + ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " + v$ + ")"
                        End If
                        Exit Function
                        End If
                    dn = dn + 1
                    Loop
                    
                    
                        Set result = pppp
                        Index = w2
    End If
End Function

Function ProcessArray(bstack As basetask, A$, v$, pp, result) As Boolean
Dim dn As Long, dd As Long, p, w3, w2 As Long, pppp As mArray
If Not Typename$(pp) = myArray Then Exit Function
Set pppp = pp

If pppp.Arr Then
dn = 0

pppp.SerialItem (0), dd, 5
dd = dd - 1
If dd < 0 Then If Typename(pppp.GroupRef) = mProp Then Exit Function
            
            
p = 0
    ProcessArray = True
    w2 = 0



        Do While dn <= dd
                    pppp.SerialItem w3, dn, 6
                    
                        If IsExp(bstack, A$, p, flatobject:=True, nostring:=True) Then
                        If dn < dd Then
                            If Not FastSymbol(A$, ",") Then: MyErMacro A$, "need index for " + v$ + ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " + v$ + ")": ProcessArray = False: Exit Function
                           
                            Else
                         If FastSymbol(A$, ",") Then
                        ProcessArray = False
                        MyErMacro A$, "too many indexes for array " + v$ + ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " + v$ + ")"
                        Exit Function
                         
                         End If
                            If Not FastSymbol(A$, ")") Then: MissSymbol ")": ProcessArray = False: Exit Function
                            
                         
                        End If
                            On Error Resume Next
                            If p < -pppp.myarrbase Then
                            ProcessArray = False
                              MyErMacro A$, "index too low for array " + v$ + ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " + v$ + ")"
                            Exit Function
                            End If
                            
                        If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
                                ProcessArray = False
                                MyErMacro A$, "index too high for array " + v$ + ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " + v$ + ")"
                                ProcessArray = False
                            Exit Function
                            End If
                            On Error GoTo 0
                        Else
                        
                         ProcessArray = False
                        If LastErNum = -2 Then
                        Else
                        
                        MyErMacro A$, "missing index for array " + v$ + ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " + v$ + ")"
                        End If
                        Exit Function
                        End If
                    dn = dn + 1
                    Loop
                    If MyIsObject(pppp.item(w2)) Then
                        Set result = pppp.item(w2)
                    Else
                        result = pppp.item(w2)
                    End If
    End If
End Function
Function ReplaceCRLFSPACE(A$) As Boolean
Dim I As Long
For I = 1 To Len(A$)
Select Case AscW(Mid$(A$, I, 1))
Case 13
ReplaceCRLFSPACE = True
Case 32, 10, 160, 9
Case Else
Exit For
End Select
Next I
If I = 1 Then Exit Function
If I > Len(A$) Then A$ = vbNullString: Exit Function
Mid$(A$, 1, I - 1) = String$(I - 1, Chr(7))
End Function
Sub NeoLet(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyLet(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub Resettimestamp()
timestamp = -1
End Sub
Function check2(s$, A$, b$) As Boolean
If s$ = A$ Then check2 = True: Exit Function
If s$ = b$ Then check2 = True
End Function
Function FastSymbolNoTrimAfter(A$, c$) As Boolean
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function  ' this is not good
If j - I < 0 Then Exit Function
If c$ = Mid$(A$, I, 1) Then
A$ = Mid$(A$, I + 1)
FastSymbolNoTrimAfter = True
End If
End Function
Function FastSymbolAt(I As Long, A$, c$, Optional cl As Long = 1) As Boolean
Dim j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimLi(A$, I)
If I > j Then Exit Function
If j - I < cl - 1 Then Exit Function
If c$ = myUcase(Mid$(A$, I, cl)) Then I = I + cl: FastSymbolAt = True
End Function
Function FastSymbolAtNoSpace(I As Long, A$, c$, Optional cl As Long = 1) As Boolean
Dim j As Long
j = Len(A$)
If j = 0 Then Exit Function
If I > j Then Exit Function
If j - I < cl - 1 Then Exit Function
If c$ = myUcase(Mid$(A$, I, cl)) Then I = I + cl: FastSymbolAtNoSpace = True
End Function

Function NocharsInLine(A$) As Boolean
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then NocharsInLine = True: Exit Function
I = MyTrimL(A$)
If I > j Then NocharsInLine = True: Exit Function

End Function
Function DropCommentOrLine(A$, Optional keepfirstcrlf As Boolean = False) As Boolean
Dim I As Long, j As Long, prev As Long
I = 1
j = Len(A$)
If j = 0 Then A$ = vbNullString:  Exit Function
again:
I = MyTrimLi2(A$, I): If I > j Then A$ = vbNullString: Exit Function
Select Case AscW(Mid$(A$, I, 1))
Case 47
    If Mid$(A$, I + 1, 1) = "/" Then I = I + 1: GoTo a1111
Case 39, 92
a1111:
    ' drop line
    I = InStr(I, A$, vbLf)
    If I = 0 Then
        I = j + 1
    Else
        prev = I - 1
        I = I + 1
        GoTo again
    End If
Case 13
    prev = I
    I = I + 2
    GoTo again
End Select
'If i > 1 Then Mid$(a$, 1, i - 1) = space$(i - 1)
If I > 1 Then
    DropCommentOrLine = CBool(prev)
    If keepfirstcrlf And prev > 0 Then I = MyTrimLi2(A$, prev)
    If I > 1 Then A$ = Mid$(A$, I)
End If
End Function
Function MaybeIsTwoSymbol(A$, c$, Optional L As Long = 2) As Boolean
Dim I As Long
If A$ = vbNullString Then Exit Function
I = MyTrimL(A$)
If I > Len(A$) Then Exit Function
MaybeIsTwoSymbol = c$ = Mid$(A$, I, 2)

End Function
Sub MakeArray(basestack As basetask, frm$, o As Long, rest$, pppp As mArray, Optional lcl As Boolean = False, Optional globalonly As Boolean = False) 'global
Dim p As Variant, X As Variant, I As Long, f As Long, s$, ss$
    I = MyTrimL(rest$)
    If Mid$(rest$, I, 1) = ")" Then Mid$(rest$, I, 1) = ChrW(8)
    I = 0
    Select Case o
    Case 5, 6, 7
    If lcl Then
    
      GlobalArr basestack, here$ + "." + basestack.GroupName + frm$, rest$, I, f, True
    Else
    GlobalArr basestack, basestack.GroupName + frm$, rest$, I, f, True, , globalonly
    End If
    p = I
    If I < 0 Then o = 0
    Case Else
    o = 0
    End Select

    
    Select Case o
    Case 5
        X = 0
      If FastSymbol(rest$, "=") Then
            If IsExp(basestack, rest$, X) Then
            
                        If neoGetArray(basestack, frm$, pppp, , globalonly, Not lcl) Then   '' basestack.GroupName & f
                             If Not basestack.lastobj Is Nothing Then
                                    If Typename(basestack.lastobj) = mGroup Then
                                        If basestack.lastobj.IamSuperClass Then
                                    Set pppp.GroupRef = basestack.lastobj.SuperClassList
                                Else
                                    Set pppp.GroupRef = basestack.lastobj
                                    End If
                                     pppp.IhaveClass = True
                                    Set basestack.lastobj = Nothing
                                    pppp.SerialItem 0, 0, 3
                                    End If
                         Else
                                pppp.SerialItem X, 0, 3
                        End If
                        End If
            ElseIf IsStrExp(basestack, rest$, s$) Then
            If neoGetArray(basestack, frm$, pppp, , globalonly, Not lcl) Then   '' basestack.GroupName & f
            X = s$
            pppp.SerialItem X, 0, 3
            End If

            Else
                o = 0
            End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
    
   f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, frm$, pppp) Then
                      For I = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                                        If Not basestack.lastobj Is Nothing Then
                                                 If Typename(basestack.lastobj) = mGroup Then
                                                     Set pppp.GroupRef = Nothing
                                                     pppp.IhaveClass = False
                                                     If basestack.lastobj.IamSuperClass Then
                                                    Dim MyObj As Object
                                          pppp.CopyGroupObj basestack.lastobj.SuperClassList, MyObj
                        
                                              Set MyObj.SuperClassList = basestack.lastobj.SuperClassList
                                              Set pppp.item(I) = MyObj
                                              Set MyObj = Nothing
                                             
                                               Else
                                                  
                                                       Set pppp.item(I) = basestack.lastobj
                                                      End If
                                        ElseIf Typename(basestack.lastobj) = mHdlr Then
                                        Set pppp.item(I) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                        Set pppp.item(I) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = myArray Then
                                        Set pppp.item(I) = basestack.lastobj
                                                    Else
                                                        Set basestack.lastobj = Nothing
                                                        badsupport
                                                        GoTo ex1
                                                        Exit For
                                                     End If
                                                     
                                        Else
                                                pppp.item(I) = X
                                        End If
                                        
                        Else
                          Set basestack.lastobj = Nothing

                            MissNumExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next I
                          Set basestack.lastobj = Nothing
            Else
         '   it = 0
                End If
          End If
     
    End If

    Case 7
    X = 0
    If FastSymbol(rest$, "=") Then
    If IsExp(basestack, rest$, X) Then
   If neoGetArray(basestack, frm$, pppp, , Not lcl) Then  '' basestack.GroupName &
    pppp.SerialItem Int(X), 0, 3
    End If
    Else
    o = 0
    End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, frm$, pppp) Then
                        For I = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                            If Typename(basestack.lastobj) = "lambda" Then
                                    Set pppp.item(I) = basestack.lastobj
                            ElseIf basestack.lastobj Is Nothing Then
                                    pppp.item(I) = Int(X)
                            Else
                                Set basestack.lastobj = Nothing
                                   MyEr "Only Lambda objects here", "лЭМО КэЛДА АМТИЙЕъЛЕМА ЕДЧ"
                                   
                                   GoTo ex1
                                   Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            
                                            MissNumExpr
                            GoTo ex1
                       
                        End If
                        Next I
                        Set basestack.lastobj = Nothing
            Else
            MissNumExpr
            GoTo ex1
           End If
          End If
    End If
    Case 6
        s$ = vbNullString
    If FastSymbol(rest$, "=") Then
    If IsStrExp(basestack, rest$, s$) Then
    If neoGetArray(basestack, frm$, pppp, , Not lcl) Then ''basestack.GroupName &
    pppp.SerialItem s$, 0, 3
    End If
    End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
    f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, frm$, pppp) Then
               
                        For I = 0 To pppp.UpperMonoLimit
                        If IsStrExp(basestack, (s$), ss$) Then
                            If Typename(basestack.lastobj) = mGroup Then
                                Set pppp.GroupRef = Nothing
                                pppp.IhaveClass = False
                                Set pppp.item(I) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = "lambda" Then
                                Set pppp.item(I) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = mHdlr Then
                                Set pppp.item(I) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                Set pppp.item(I) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = myArray Then
                                Set pppp.item(I) = basestack.lastobj
                            ElseIf basestack.lastobj Is Nothing Then
                                pppp.item(I) = ss$
                            Else
                                Set basestack.lastobj = Nothing
                                badsupport
                                GoTo ex1
                                Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            MissStringExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next I
                        Set basestack.lastobj = Nothing
            Else

                MissStringExpr
                GoTo ex1
            End If
        End If
    End If
    End Select
    If o = 0 Then
      BadDim
    rest$ = basestack.GroupName + frm$ + rest$
    End If
ex1:
    Set basestack.lastpointer = Nothing
    
End Sub
Sub MarkIf(bstack As basetask, A As Long, b As Boolean)
Dim s As mStiva2
Set s = bstack.RetStack
s.PushVal b
s.PushVal A
s.PushVal -3  ' mark for IF
End Sub

Function lookOne(s, c$) As Boolean
Dim I&, L As Long, cc As Integer
Dim P2 As Long, P1 As Integer
  L = Len(s): If L = 0 Then Exit Function
  P2 = StrPtr(s): L = L - 1: GetMem2 StrPtr(c$), cc

  For I = P2 To P2 + L * 2 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case cc
    lookOne = True
    Case Else
   Exit Function
  End Select
  Next I
End Function
Function lookTwoSame(s, c$) As Boolean
Dim I&, L As Long, cc As Integer, cc2 As Integer
Dim P2 As Long, P1 As Integer, n As Integer
    If Len(c$) <> 1 Then Exit Function
  L = Len(s): If L = 0 Then Exit Function
  P2 = StrPtr(s): L = L - 1: GetMem2 StrPtr(c$), cc
  For I = P2 To P2 + L * 2 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
        If n <> 0 Then Exit Function
    Case cc
        If n = 1 Then lookTwoSame = True: Exit Function
        If n = 0 Then n = 1
    Case Else
        Exit Function
  End Select
  Next I
End Function
Function MaybeIsSymbol(A$, c$) As Boolean
Dim I As Long
If A$ = vbNullString Then Exit Function
I = MyTrimL(A$)
If I > Len(A$) Then Exit Function
MaybeIsSymbol = InStr(c$, Mid$(A$, I, 1)) > 0
End Function
Function MaybeIsSymbol2(A$, c$, I As Long) As Boolean
'' for isnumber
If A$ = vbNullString Then Exit Function
I = MyTrimL(A$)
If I > Len(A$) Then Exit Function
MaybeIsSymbol2 = InStr(c$, Mid$(A$, I, 1)) > 0
End Function
Function MaybeIsSymbol3lot(A$, c$, I As Long) As Boolean
If A$ = vbNullString Then Exit Function
I = MyTrimLi(A$, IIf(I, I, 1))
If I > Len(A$) Then Exit Function
MaybeIsSymbol3lot = InStr(c$, Mid$(A$, I, 1)) > 0
End Function
Function MaybeIsSymbol3(A$, c$, I As Long) As Boolean
If A$ = vbNullString Then Exit Function
I = MyTrimLi(A$, IIf(I, I, 1))
If I > Len(A$) Then Exit Function
MaybeIsSymbol3 = c$ = Mid$(A$, I, 1)
End Function

Function MaybeIsSymbolNoSpace(A$, c$) As Boolean
MaybeIsSymbolNoSpace = Left$(A$, 1) Like c$
End Function
Function IsLabelSymbolLatin(A$, c$, Optional I As Long) As Boolean
    Dim M As Long
    M = Len(c$)
    If I = 0 Then I = MyTrimLi(A$, 1)
    If UCase(Mid$(A$, I, M)) = c$ Then
        If Len(A$) >= I + M Then
            Select Case AscW(Mid$(A$, I + M, 1))
            Case Is < 36, 47, 58, 92, 160
            Case Else
                Exit Function
            End Select
        End If
        A$ = Mid$(A$, I + M)
        IsLabelSymbolLatin = True
    End If
End Function
Function IsLabelSymbol(A$, c$, Optional I As Long) As Boolean
    Dim M As Long
    M = Len(c$)
    If I = 0 Then I = MyTrimLi(A$, 1)
    If myUcase(Mid$(A$, I, M), True) = c$ Then
        
        If Len(A$) >= I + M Then
            Select Case AscW(Mid$(A$, I + M, 1))
            Case Is < 36, 47, 58, 92, 160
            Case Else
                Exit Function
            End Select
        End If
        A$ = Mid$(A$, I + M)
        IsLabelSymbol = True
    End If
End Function
Function IsLabelSymbolNewExp(A$, gre$, Eng$, code As Long, usethis$, Optional I As Long) As Boolean
' code 2  gre or eng, set new value to code 1 or 0
' 0 for gre
' 1 for eng
' return true if we have label
Dim M As Long
M = Len(usethis$)
If I = 0 Then I = MyTrimLi(A$, 1)
If M = 0 Then
    If code = 1 Then
        M = Len(Eng$)
            If Not UCase(Mid$(A$, I, M)) = Eng$ Then
                If IsLabelSYMB33(A$, usethis, M) Then usethis = myUcase(usethis, True)
                Exit Function
            End If
    Else
        M = Len(gre$)
        If Not myUcase(Mid$(A$, I, M), True) = gre$ Then
            If IsLabelSYMB33(A$, usethis, M) Then usethis = myUcase(usethis, True)
            Exit Function
        End If
        
    End If
    If Len(A$) >= I + M Then
        Select Case AscW(Mid$(A$, I + M, 1))
        'Case Is < 36, 47, 58, 92, 123, 160
        Case Is < 36, 39, 41 To 45, 47, 58, 61, 92, 123, 125, 160
        'Case 36, 37, 46, 48 To 58, 94, 95  ' _ . 0123456789
        Case Else '36, 37, 40, 46, 48 To 58, 64, 91, 93 To 95
            If IsLabelSYMB33(A$, usethis, M) Then usethis = myUcase(usethis, True)
            usethis = Mid$(A$, I, M)
            Exit Function
        End Select
    End If
    
    A$ = Mid$(A$, I + M)
    IsLabelSymbolNewExp = True

Else
    Select Case code
    Case 0, 2
    If Len(gre$) = Len(usethis) Then IsLabelSymbolNewExp = gre$ = usethis$
    Case 1
    If Len(Eng$) = Len(usethis) Then IsLabelSymbolNewExp = Eng$ = usethis$
    End Select
    If IsLabelSymbolNewExp Then A$ = Mid$(A$, I + M)
End If
If IsLabelSymbolNewExp Then usethis$ = vbNullString

End Function
Function IsLabelSymbolNew(A$, gre$, Eng$, code As Long, Optional I As Long = 0) As Boolean
' code 2  gre or eng, set new value to code 1 or 0
' 0 for gre
' 1 for eng
' return true if we have label
    Dim M As Long
    
    If I = 0 Then I = MyTrimLi(A$, 1)
    If code = 1 Then
        M = Len(Eng$)
        If Not UCase(Mid$(A$, I, M)) = Eng$ Then
            Exit Function
        End If
    Else
        M = Len(gre$)
        If Not myUcase(Mid$(A$, I, M), True) = gre$ Then
            Exit Function
        End If
    End If
    If Len(A$) >= I + M Then
        Select Case AscW(Mid$(A$, I + M, 1))
        Case Is < 36, 39, 41 To 45, 47, 58 To 61, 92, 93, 123, 125, 160
        Case Else ' 36, 37, 40, 46, 48 To 58, 64, 91, <<93 old>> To 95 ' _ . 0123456789
            Exit Function
        End Select
    End If
    A$ = Mid$(A$, I + M)
    IsLabelSymbolNew = True
End Function


Private Function FastSymbol(A$, c$, Optional mis As Boolean = False, Optional cl As Long = 1) As Boolean
Dim I As Long, j As Long
j = Len(A$)
If j = 0 Then Exit Function
I = MyTrimL(A$)
If I > j Then Exit Function  ' this is not good
If j - I < cl - 1 Then
If mis Then MissSymbol c$
Exit Function
End If
If c$ = Mid$(A$, I, cl) Then
A$ = Mid$(A$, MyTrimLi(A$, I + cl))
FastSymbol = True
ElseIf mis Then
MissSymbol c$
End If
End Function

Private Function MyTrimL(s$) As Long
Dim I&, L As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s): If L = 0 Then MyTrimL = 1: Exit Function
  P2 = StrPtr(s): L = L - 1
  p4 = P2 + L * 2
  For I = P2 To p4 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case Else
     MyTrimL = (I - P2) \ 2 + 1
   Exit Function
  End Select
  Next I
 MyTrimL = L + 2
End Function
Public Function RealLen(s$, Optional checkone As Boolean = False) As Long
Dim I&, LL As Long, n As Long
LL = Len(s): If LL = 0 Then Exit Function
If checkone Then LL = 1
Dim a1() As Integer, A2() As Integer
ReDim a1(LL + 6)
ReDim A2(LL + 6)
Dim skip As Boolean
skip = GetStringTypeExW(&HB, 4, StrPtr(s$), LL, a1(0)) = 0
skip = GetStringTypeExW(&HB, 2, StrPtr(s$), LL, A2(0)) = 0 Or skip
If skip Then
RealLen = LL
Else
  I& = LL - 1
  LL = LL * 2
  For n = 0 To I&
  If a1(n) = 2048 And A2(n) = 1 Then
    LL = LL - 1
  ElseIf a1(n) = 4096 And A2(n) = 0 Then
     LL = LL - 1
   ElseIf a1(n) = 3 And A2(n) = 11 Then
    LL = LL - 2
   ElseIf a1(n) = 0 And A2(n) = 0 Then
   LL = LL - 2
   ElseIf a1(n) = 1 Then
   LL = LL - 2
   End If
  Next n
RealLen = LL \ 2
End If

End Function
Public Function CheckIsmArray(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.T1 = 3 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If

    End If
    
End If
If Not obj Is Nothing Then
If TypeOf obj Is mArray Then If obj.Arr Then CheckIsmArray = True: Set oldobj = Nothing: Exit Function
End If
Set obj = oldobj
End Function
Public Function CheckIsmStiva(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.T1 = 3 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If

    End If
    
End If
If Not obj Is Nothing Then
If TypeOf obj Is mStiva Then CheckIsmStiva = True: Set oldobj = Nothing: Exit Function
End If
Set obj = oldobj
End Function
Public Function CheckIsmArrayOrStackOrCollection(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.T1 <> 2 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If
   
    End If
    
End If
If Not obj Is Nothing Then
If TypeOf obj Is mArray Then If obj.Arr Then CheckIsmArrayOrStackOrCollection = True: Set oldobj = Nothing: Exit Function
If TypeOf obj Is mStiva Then CheckIsmArrayOrStackOrCollection = True: Set oldobj = Nothing: Exit Function
If TypeOf obj Is FastCollection Then CheckIsmArrayOrStackOrCollection = True: Set oldobj = Nothing: Exit Function
End If
Set obj = oldobj
End Function
Public Function CheckDeepAny(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.T1 = 3 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If

    End If
    
End If
If Not obj Is Nothing Then Set oldobj = Nothing: CheckDeepAny = True: Exit Function
Set obj = oldobj
End Function

Function getindexes(bstack As basetask, obj1 As Object, A$) As Boolean
Dim s$, p, idx As New mIndexes, dn As Long, aProp As PropReference
Set aProp = obj1
Do
        If IsExp(bstack, A$, p) Then
                idx(dn) = p
                aProp.Index = p
            ElseIf IsStrExp(bstack, A$, s$) Then
                idx(dn) = s$
                aProp.Index = s$
            ElseIf FastSymbol(A$, "?") Then
                idx.IndexOpt dn
                aProp.IndexOpt
            Else
                If dn = 0 Then
                If MaybeIsSymbol(A$, ")") Then
                    getindexes = True
                End If
                End If
                idx.IndexOpt dn
                aProp.IndexOpt
            End If
            dn = dn + 1
Loop Until Not FastSymbol(A$, ",")
aProp.PushIndexes idx
End Function
Public Sub MyDoEventsNoRefresh()
On Error GoTo there
If TaskMaster Is Nothing Then
    DoEvents
    Exit Sub
ElseIf Not TaskMaster.Processing And TaskMaster.QueueCount = 0 Then
    DoEvents
    Exit Sub
Else
    If TaskMaster.PlayMusic Then
        TaskMaster.OnlyMusic = True
        TaskMaster.TimerTick
        TaskMaster.OnlyMusic = False
    End If
    TaskMaster.StopProcess
    TaskMaster.TimerTick
    DoEvents
    TaskMaster.StartProcess
End If
Exit Sub
there:
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd1
End Sub
Private Function lookB123(s As String, Optional ByVal Pos As Long = 1) As Boolean
Dim I&, L As Long
Dim P2 As Long, P1 As Integer, p4 As Long
  L = Len(s): If L = 0 Then Exit Function
  If Pos > L Then Exit Function
  P2 = StrPtr(s) + (Pos - 1) * 2: L = L - 1
  For I = P2 To P2 + L * 2 Step 2
  GetMem2 I, P1
  Select Case P1
    Case 32, 160, 7, 9
    Case 13, 47, 39, 92
     lookB123 = True
    Case Else
   Exit Function
  End Select
  Next I

End Function
Sub StaticWork(basestack As basetask, mystack As basetask, ByVal where$)
    Dim vvv
    where$ = "%_" + where$
    If basestack.StaticCollection.ExistKey(where$) Then
        basestack.ReadStaticCol2 where$, vvv
        If MyIsObject(vvv) Then Set mystack.StaticCollection = vvv
    End If
End Sub
Private Function Addr(ByVal p As Long) As Long
    'If m_bInIDE Then
    '    addr = CLNG(add32(uintnew1(p), 12@))
    'Else
        Addr = p
    'End If
End Function
Public Function VarTypeName(v) As String
    namesVT MemInt(VarPtr(v)), v, VarTypeName
End Function
Private Sub namesVT(n As Integer, v, ret As String)
Select Case n And &H7FF
        Case 0
            ret = "Empty"
        Case 1
            ret = "Null"
        Case 2
            ret = "Integer"
        Case 3
            ret = "Long"
        Case 4
            ret = "Single"
        Case 5
            ret = "Double"
        Case 6
            ret = "Currency"
        Case 7
            ret = "Date"
        Case 8
            ret = "String"
        Case 10
            ret = "Error"
        Case 9, 13
            ret = Typename(v)
        Case 11
            ret = "Boolean"
        Case 12, 1
            ret = "Variant"
        Case 14
            ret = "Decimal"
        Case 17
            ret = "Byte"
        Case 20
            ret = "Long Long"
        Case 36
            ret = Typename(v)
        Case Is > 8192
            ret = ArrayDescBare(v)
        Case Else
            ret = "type" & VarType(v)
    End Select
End Sub
Public Function ArrayDesc(vArray As Variant) As String
    Dim lPtr            As Long
    Const VT_BYREF      As Long = &H4000
    If IsArray(vArray) Then
        lPtr = MemLong(UnsignedAdd(VarPtr(vArray), 8))
        If (MemLong(VarPtr(vArray)) And VT_BYREF) <> 0 Then
            lPtr = MemLong(lPtr)
        End If
        If lPtr <> 0 Then
            Dim I As Long, p As String, aType As String
            Select Case MemInt(VarPtr(vArray)) And &HFFF
            Case 2
                aType = "Integer"
            Case 3
                aType = "Long"
            Case 4
                aType = "Single"
            Case 5
                aType = "Double"
            Case 6
                aType = "Currency"
            Case 7
                aType = "Date"
            Case 8
                aType = "String"
            Case 9, 13  '   VT_DISPATCH = 9, VT_UNKNOWN = 13
                aType = "Object"
            Case 11
                aType = "Boolean"
            Case 12, 1
                aType = "Variant"
            Case 14
                aType = "Decimal"
            Case 17 ' VT_UI1 = 17
                aType = "Byte"
            Case 20
                aType = "Long Long"
            Case 27 '  VT_SAFEARRAY = 27
                aType = "Array"
            Case 29 ' VT_USERDEFINED = 29
                aType = "UDT"
            Case 36
                aType = Typename(vArray)
            End Select
            p = "" & MemLong(UnsignedAdd(lPtr, 16))
            For I = 2 To MemInt(lPtr)
                p = p & ", " & MemLong(UnsignedAdd(lPtr, 8 + I * 8))
            Next I
            ArrayDesc = aType & "(" & p & ")"
            Exit Function
        End If
        ArrayDesc = "EmptyArray"
        Exit Function
    End If
    ArrayDesc = "type" & VarType(vArray)
End Function
Public Function ArrayDescBare(vArray As Variant) As String
    Dim lPtr            As Long
    Const VT_BYREF      As Long = &H4000
    If IsArray(vArray) Then
        lPtr = MemLong(UnsignedAdd(VarPtr(vArray), 8))
        If (MemLong(VarPtr(vArray)) And VT_BYREF) <> 0 Then
            lPtr = MemLong(lPtr)
        End If
        If lPtr <> 0 Then
            Dim aType As String
            Select Case MemInt(VarPtr(vArray)) And &HFFF
            Case 2
                aType = "Integer"
            Case 3
                aType = "Long"
            Case 4
                aType = "Single"
            Case 5
                aType = "Double"
            Case 6
                aType = "Currency"
            Case 7
                aType = "Date"
            Case 8
                aType = "String"
            Case 9, 13  '   VT_DISPATCH = 9, VT_UNKNOWN = 13
                aType = "Object"
            Case 11
                aType = "Boolean"
            Case 12, 1
                aType = "Variant"
            Case 14
                aType = "Decimal"
            Case 17 ' VT_UI1 = 17
                aType = "Byte"
            Case 20
                aType = "Long Long"
            Case 27 '  VT_SAFEARRAY = 27
                aType = "Array"
            Case 29 ' VT_USERDEFINED = 29
                aType = "UDT"
            Case 36
                aType = Typename(vArray)
            End Select
            ArrayDescBare = aType & "()"
            Exit Function
        End If
        ArrayDescBare = "EmptyArray"
        Exit Function
    End If
    ArrayDescBare = "type" & VarType(vArray)
End Function

Function CheckFree(A$) As Boolean
        If Len(A$) = 0 Then CheckFree = True: Exit Function
        Select Case AscW(A$)
        Case Is < 36, 39 To 45, 47, 58 To 62, 64, 92, 94, 123 To 126, 160
        CheckFree = True
        Case Else ' 36, 37, 40, 46, 48 To 58, 64, 91, 93 To 95 ' _ . 0123456789
        End Select
End Function
Function CheckFreeExecute(A$) As Boolean
        If Len(A$) = 0 Then CheckFreeExecute = True: Exit Function
        Select Case AscW(A$)
        Case Is < 33, 39, 47, 58, 92, 94, 125, 160
        CheckFreeExecute = True
        Case Else
        End Select
End Function
Public Function myVarType(z, j As Integer) As Boolean
myVarType = MemInt(VarPtr(z)) = j
End Function
Public Function IntExp(n, X, ByVal r)
On Error GoTo 100
    While X > 0: If X Mod 2 = 1 Then X = X - 1: r = r * n
    X = X \ 2: If X > 0 Then n = n * n
    Wend
    IntExp = r
    Exit Function
100: Err.Clear
    r = 0.5
End Function
    
Function strLiterals(w1 As Long, bstackstr As basetask, A$, r$) As Boolean
Dim p
On w1 GoTo lit1, lit2, lit3, lit4, lit5, lit6, lit7, lit8, lit9, lit10, lit11, lit12, lit13, lit14, lit15, lit16, lit17, lit18, lit19, lit20, lit21, lit22, lit23, lit24, lit25, lit26, lit27, lit28, lit29, lit30, lit31, lit32, lit33, lit34, lit35, lit36, lit37
    ' "ABOUT$", "пеяи$"
lit1:
    r$ = feedback$
    feedback$ = vbNullString
    strLiterals = True
    Exit Function
lit2: '    Case "CONTROL$"
    Str1nControls r$
    strLiterals = True
    Exit Function
lit32:   ' Case "жояла$"
    Str1nControlsGR r$
    strLiterals = True
    Exit Function
lit3: '   Case "THREADS$"
    r$ = bstackstr.Parent.ThreadsStr(1)
    strLiterals = True
    Exit Function
lit33: '  Case "мглата$"
    r$ = bstackstr.Parent.ThreadsStr
    strLiterals = True
    Exit Function
lit38: ' Case "INTERNET$", "диадийтуо$"
    r$ = GetExternalIP
    strLiterals = True
    Exit Function
lit37: ' Case "INTERNET$", "диадийтуо$"
    r$ = GetExternalIP
    strLiterals = True
    Exit Function
lit4: '   Case "LAN$", "дийтуо$"
    r$ = getIP
    strLiterals = True
    Exit Function
lit5: '    Case "GRABFRAME$", "паяейаяе$"
    r$ = grabfrm$()
    strLiterals = True
    Exit Function
lit6: '    Case "емаомола$", "TEMPNAME$"
    r$ = GetTempFileName
    strLiterals = True
    Exit Function
lit7: ' "TEMPORARY$", "пяосыяимо$"  ' бя╦хгйе дуо жояес то пяосыяимо$
    r$ = strTemp  'аутос еимаи о жайекос
    strLiterals = True
    Exit Function
lit8: '    Case "USER.NAME$", "омола.вягстг$"
                             r$ = Originalusername
                            strLiterals = True
                            Exit Function
lit9: '    Case "COMPUTER$", "упокоцистгс$"
                             r$ = strMachineName
                            strLiterals = True
                            Exit Function
lit10: '    Case "CLIPBOARD$", "пяовеияо$"
                            Sleep 10
                            r$ = GetTextData(CF_UNICODETEXT)
                            If r$ = vbNullString Then r$ = Clipboard.GetText
                            strLiterals = True
                            Exit Function
lit11: '    Case "CLIPBOARD.IMAGE$", "пяовеияо.еийома$"
                        Sleep 10
                        r$ = GetImage()
                         strLiterals = True
                         Exit Function

lit12: '    Case "паяалетяои$", "PARAMETERS$"
                        r$ = para$
                        strLiterals = True
                        Exit Function
lit13: '    Case "OS$", "кс$"
                        r$ = os
                        strLiterals = True
                        Exit Function
lit14: '    Case "емтокг$", "COMMAND$"
                        r$ = LASTPROG$
                    strLiterals = True
                    Exit Function
lit15: '   Case "кахос$"
        If Left$(LastErNameGR, 1) = Chr(0) Then LastErNameGR = Mid$(LastErNameGR, 2)
                     r$ = LastErNameGR
                      LastErNum1 = 0
                        LastErNameGR = vbNullString
                     LastErName = vbNullString
                    strLiterals = True
                    Exit Function
lit34: '    Case "ERROR$"
    If Left$(LastErName, 1) = Chr(0) Then LastErName = Mid$(LastErName, 2)
                     r$ = LastErName
                      LastErNum1 = 0
                     LastErNameGR = vbNullString
                     LastErName = vbNullString
                    strLiterals = True
                    Exit Function
lit36: ' case "MODULE.NAME$", "омола.тлглатос$"
            If SecureNames Then
             strLiterals = GetThisModuleName(r$)
            Else
                r$ = here$
                strLiterals = True
            End If
             Exit Function
lit16: '    Case "MODULE$", "тлгла$"
                    r$ = here$
                    strLiterals = True
                    Exit Function

lit17: '    Case "PRINTERNAME$", "ейтупытгс$"  ' ДЕМ ПАъФЕИ ЯЭКО ПИА Г ПЭЯТА
                    r$ = pname & " (" & Port & ")"
                    strLiterals = True
                    Exit Function
lit18: '    Case "PROPERTIES$", "идиотгтес$"
                If ThereIsAPrinter Then
                If UBound(MyDM) = 1 Then
                    PrinterDim pw, ph, psw, psh, pwox, phoy
                End If
                r$ = ARRAYtoStr(MyDM())
                Else
                r$ = vbNullString
                End If
                    strLiterals = True
                    Exit Function
lit19: '    Case "MOVIE.STATUS$", "йатастасг.таимиас$"
                   r$ = MediaPlayer1.getStatus
                strLiterals = True
                Exit Function
lit20: '    Case "MOVIE.DEVICE$", "сусйеуг.пяобокгс$"
                   r$ = MediaPlayer1.getDeviceName
                strLiterals = True
                Exit Function
lit21: '    Case "MOVIE.ERROR$", "кахос.таимиас$"
                   r$ = MediaPlayer1.checkError
                strLiterals = True
                Exit Function
lit22: '    Case "PLATFORM$", "пкатжояла$"
                r$ = Platform
                strLiterals = True
                Exit Function

lit23: '    Case "FONTNAME$", "цяаллатосеияа$"
    With bstackstr
                 If .tolayer > 0 And .tolayer < 32 Then
                 r$ = Form1.dSprite(.tolayer).Font.Name
                 ElseIf .tolayer >= 32 Then
                 r$ = players(.tolayer).FontName
                 ElseIf .toback Then
                 r$ = Form1.Font.Name
                 ElseIf .toprinter Then
                 r$ = Form1.PrinterDocument1.Font.Name
                 Else
                r$ = Form1.DIS.Font.Name
                End If
                End With
                 strLiterals = True
                 Exit Function
lit24: '    Case "BROWSER$", "амакоцио$"
                r$ = Form1.view1.LocationURL
                strLiterals = True
                Exit Function

lit25: '    Case "SPRITE$", "диажамеиа$"
                r$ = BACKSPRITE
                BACKSPRITE = vbNullString
                strLiterals = True
                Exit Function
lit26: '    Case "APPDIR$", "ежаялоцг.йат$"
                r$ = GetLongName(App.path)
                If Right(r$, 1) <> "\" Then r$ = r$ + "\"
                strLiterals = True
                Exit Function
lit27: '    Case "DIR$", "йат$"
    
                r$ = UserPath
    
                strLiterals = True
                Exit Function
lit28: '    Case "KEY$", "йол$"
    If GetCode(bstackstr.Owner) > 32 Then
        r$ = INKEY$
    Else
        If Not Form1.Visible Then newshow Basestack1: MyDoEvents
            r$ = UINKEY$  ' look if we have some keys here
            If r$ = vbNullString Or r$ = Chr(0) + Chr(0) Then
                Do
                    ProcTask2 bstackstr
                    If Not Form1.KeyPreview Then Form1.KeyPreview = True
                    MyRefresh bstackstr
                    r$ = INKEY$  ' (inkey$ has autorepeat...)
                Loop Until r$ <> "" Or LastErNum <> 0
                If LastErNum <> 0 And LenB(r$) = 0 Then r$ = Chr$(0)
            End If
    End If
    strLiterals = True
    Exit Function
lit29: '    Case "INKEY$", "емйол$"
    If GetCode(bstackstr.Owner) > 32 Then
        r$ = INKEY$
    Else
        If Not releasemouse Then
            If Not Form1.Visible Then newshow Basestack1
            MyDoEvents2 bstackstr.Owner
        Else
            MyRefresh bstackstr
            If Not bstackstr.IamThread Then MyDoEvents
        End If
        r$ = UINKEY$
        If r$ = vbNullString Then
          r$ = INKEY$
        End If
    End If
    strLiterals = True
    Exit Function
lit30: '    Case "LETTER$", "цяалла$"
    If bstackstr.soros.Total = 0 Then
        strLiterals = False
    ElseIf bstackstr.soros.PopType = "S" Then
        r$ = bstackstr.soros.PopStr
        strLiterals = True
    End If
    Exit Function
lit35: '    Case "калда$"
    Set bstackstr.lastobj = ProcLambda(bstackstr, A$, 0)
    r$ = vbNullString
    If FastSymbol(A$, "(") Then
        If Not CallLambdaASAP(bstackstr, A$, p, True) Then strLiterals = False: Exit Function
        r$ = CStr(p)
        strLiterals = True
    Else
        strLiterals = Not bstackstr.lastobj Is Nothing
    End If
    Exit Function
lit31: ' "LAMBDA$"
    Set bstackstr.lastobj = ProcLambda(bstackstr, A$, 1)
    r$ = vbNullString
    If FastSymbol(A$, "(") Then
        p = vbNullString
        If Not CallLambdaASAP(bstackstr, A$, p, True) Then strLiterals = False: Exit Function
        r$ = CStr(p)
        strLiterals = True
    Else
        strLiterals = Not bstackstr.lastobj Is Nothing
    End If
End Function
Function strFunctions(w2 As Long, q$, bstackstr As basetask, A$, r$) As Boolean
Dim p As Variant, pp As Variant, pppp As mArray, ms As mStiva2, usehandler As mHandler
Dim s$, par As Boolean, ms1 As mStiva, ppppL As iBoxArray
Dim q1$, q2$, w1 As Long, w3 As Long, dd As Long
Dim anything As Object

    On w2 GoTo fstr1, fstr2, fstr3, fstr4, fstr5, fstr6, fstr7, fstr8, fstr9, fstr10, fstr11, fstr12, fstr13, fstr14, fstr15, fstr16, fstr17, fstr18, fstr19, fstr20, fstr21, fstr22, fstr23, fstr24, fstr25, fstr26, fstr27, fstr28, fstr29, fstr30, fstr31, fstr32, fstr33, fstr34, fstr35, fstr36, fstr37, fstr38, fstr39, fstr40, fstr41, fstr42, fstr43, fstr44, fstr45, fstr46, fstr47, fstr48, fstr49, fstr50, fstr51, fstr52, fstr53, fstr54, fstr55, fstr56, fstr57, fstr58, fstr59, fstr60, fstr61, fstr62, fstr63, fstr64, fstr65, fstr66, fstr67, fstr68, fstr69, fstr70
fstr68: ' "амап$(","STRREV$("
    If IsStrExp(bstackstr, A$, q1$, False) Then
        r$ = StrReverse(q1$)
    Else
        MissNumExpr
        Exit Function
    End If
    strFunctions = FastSymbol(A$, ")", True)
    Exit Function
fstr67: '"леяос$(", "PIECE$("
    strFunctions = StrToArray(bstackstr, A$, r$)
    Exit Function
fstr66: '"IF$(","ам("
strFunctions = False
If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then strFunctions = ProcessIfStr(p, bstackstr, A$, r$)
Exit Function
fstr1: '"FORMAT$(", "лояжг$("
    r$ = enthesi(bstackstr, A$)
    strFunctions = FastSymbol(A$, ")", True)
    Exit Function
fstr2: '"EVAL$(", "ейжя$(", "ейжяасг$("
    strFunctions = mEval(q$, bstackstr, A$, r$)
        
    Exit Function
fstr3: ' "STACKTYPE$(", "сыяоутупос$("
    w3 = 1
    If IsExp(bstackstr, A$, p) Then
        If bstackstr.lastobj Is Nothing Then
            Set anything = bstackstr.soros
            w3 = Abs(CLng(Fix(p)))
        ElseIf Not CheckStackObj(bstackstr, anything, w3) Then
            MyEr "Not a stack object", "дЕМ ЕъМАИ АМТИЙЕъЛЕМО СЫЯОЩ"
            Exit Function
        ElseIf FastSymbol(A$, ",") Then
            If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                w3 = Abs(CLng(Fix(p)))
            End If
        End If
        Set ms1 = anything
backitem1:
        Set anything = Nothing
        If ms1.Total < w3 Then
            MyErMacroStr A$, "Stack item not found at position " & (w3), "дЕМ УПэЯВЕИ СТОИВЕъО СЫЯОЩ СТГ ХщСГ " & (w3)
            strFunctions = False: Exit Function
        ElseIf ms1.StackItemType(w3) = "*" Then
            Set anything = ms1.StackItem(w3)
            CheckDeepAny anything
            r$ = Typename$(anything)
            If r$ = mHdlr Then
                Set usehandler = anything
                Select Case usehandler.T1
                Case 1
                    r$ = "Inventory"
                Case 2
                    r$ = "Buffer"
                Case 3
                    w3 = usehandler.indirect
                    If w3 > -1 And w3 <= var2used Then
                        r$ = VarTypeName(var(w3))
                    Else
                        r$ = Typename(usehandler.objref)
                    End If
                Case Else
                    r$ = Typename(usehandler.objref)
                End Select
                Set usehandler = Nothing
            End If
            strFunctions = FastSymbol(A$, ")", True)
        ElseIf ms1.StackItemType(w3) = "?" Then
            r$ = "(?)"
        ElseIf ms1.StackItemType(w3) = "S" Then
            r$ = vbNullString
            Select Case Abs(IsLabel(bstackstr, CStr(ms1.StackItem(w3)), q1$))
            Case 1, 3, 4
                If varhash.ExistKey(q1$) Then
                    r$ = "ReferVar"
                ElseIf varhash.ExistKey(q1$ + "(") Then
                    r$ = "ReferArray"
                End If
            Case 5, 6, 7
        End Select
        If r$ = vbNullString Then r$ = "String"
            strFunctions = FastSymbol(A$, ")", True)
        ElseIf ms1.StackItemType(w3) = "N" Then
            r$ = "Number"
            strFunctions = FastSymbol(A$, ")", True)
        ElseIf ms1.StackItemType(w3) = "L" Then
            r$ = "Long"
            strFunctions = FastSymbol(A$, ")", True)
        Else
            MyErMacroStr A$, "Stack item isn't known object at position " & (w3), "To СТОИВЕъО ТОУ СЫЯОЩ ДЕМ ЕъМАИ ЦМЫСТЭ АМТИЙЕъЛЕМО СТГ ХщСГ " & (w3)
            strFunctions = False
        End If
        Exit Function
    Else
        Set ms1 = bstackstr.soros
        GoTo backitem1
    End If
    Exit Function
fstr4: 'STACKITEM$(", "тилгсыяоу$("
    w3 = 1
    If IsExp(bstackstr, A$, p) Then
        If bstackstr.lastobj Is Nothing Then
            Set anything = bstackstr.soros
            w3 = Abs(CLng(Fix(p)))
        ElseIf Not CheckStackObj(bstackstr, anything, w3) Then
            MyEr "Not a stack object", "дЕМ ЕъМАИ АМТИЙЕъЛЕМО СЫЯОЩ"
            Exit Function
        ElseIf FastSymbol(A$, ",") Then
            If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                w3 = Abs(CLng(Fix(p)))
            End If
        End If
        Set ms1 = anything
backitem2:
        Set anything = Nothing
            If ms1.Total < w3 Then
                MyErMacroStr A$, "Stack item not found at position " & (w3), "дЕМ УПэЯВЕИ ТИЛч СЫЯОЩ СТГ ХщСГ " & (w3)
                strFunctions = False: Exit Function
            ElseIf ms1.StackItemType(w3) = "S" Then
                r$ = ms1.StackItem(w3)
                strFunctions = FastSymbol(A$, ")", True)
            Exit Function
        ElseIf ms1.StackItemType(w3) = "*" Then
            r = 0
            Set bstackstr.lastobj = ms1.StackPickRef(w3).ObjectRef
            strFunctions = FastSymbol(A$, ")", True)
            Exit Function
        Else
            MyErMacroStr A$, "Stack item isn't string at position " & (w3), "г ТИЛч ТОУ СЫЯОЩ ДЕМ ЕъМАИ ЦЯэЛЛА СТГ ХщСГ " & (w3)
            strFunctions = False
        End If
        Exit Function
    Else
        Set ms1 = bstackstr.soros
        GoTo backitem2
    End If
fstr5: ' "исвмг$(", "WEAK$("
                r$ = Funcweak(bstackstr, A$)

                 strFunctions = FastSymbol(A$, ")") And r$ <> ""
             If Not strFunctions Then
             MyErMacroStr A$, "No variable found or is static", "дЕМ УПэЯВЕИ ЛЕТАБКГТч ч ЕъМАИ СТАТИЙч"
             End If
                Exit Function
fstr6: '"коцос$(", "SPEECH$("
           If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                       
                        r$ = VoiceName(p)
                       
                        End If
                        strFunctions = FastSymbol(A$, ")")
             
                Exit Function
fstr7: ' "ASK$(", "яыта$("
If IsStrExp(bstackstr, A$, AskText$, False) Then
If UCase(q$) = "ASK$(" Then
DialogSetupLang 1
Else
DialogSetupLang 0
End If
If AskText$ = vbNullString Then ZeroParam A$: strFunctions = False: Exit Function
If FastSymbol(A$, ",") Then IsStrExp bstackstr, A$, AskTitle$, False
    If FastSymbol(A$, ",") Then
        IsStrExp bstackstr, A$, s$, False 'AskOk$
        If s$ = "" Then
        AskOk$ = ""
        ElseIf s$ = "*" Then
            AskOk$ = "*" + AskOk$
        Else
            AskOk$ = s$
        End If
    End If
    If FastSymbol(A$, ",") Then
        IsStrExp bstackstr, A$, s$, False ' AskCancel$
        If s$ = "" Then
        AskCancel$ = ""
        ElseIf s$ = "*" Then
            AskCancel$ = "*" + AskCancel$
        Else
            AskCancel$ = s$
        End If
    End If

If FastSymbol(A$, ",") Then IsStrExp bstackstr, A$, AskDIB$, False
If FastSymbol(A$, ",") Then IsStrExp bstackstr, A$, AskStrInput$, False: AskInput = True

olamazi

Form1.NeoASK bstackstr
r$ = AskResponse$
AskInput = False
    strFunctions = FastSymbol(A$, ")", True)
End If
Exit Function
fstr8: ' "LOCALE$(", "топийо$("
         If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then

    r$ = GetlocaleString(CLng(Fix(p)))
     strFunctions = FastSymbol(A$, ")")
       End If
       
        Exit Function
 
fstr9: ' "SHORTDIR$(", "лийяос.йатакоцос$("
         If IsStrExp(bstackstr, A$, q$, False) Then
      

    r$ = GetDosPath(q$)
     strFunctions = FastSymbol(A$, ")")
       End If
       
        Exit Function
 
fstr10: '"FILTER$(", "жиктяо$("
     If IsStrExp(bstackstr, A$, q$, False) Then
       If FastSymbol(A$, ",") And IsStrExp(bstackstr, A$, q1$, False) Then
        r$ = CleanStr(q$, q1$)
        strFunctions = True
        Else
        MissStringExpr
       End If
       Else
       MissStringExpr
    End If
    If strFunctions Then If Not FastSymbol(A$, ")") Then strFunctions = False
    Exit Function
fstr11: '"коцос$(", "SPEECH$("
           If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                       
                        r$ = VoiceName(p)
                       
                        End If
                        strFunctions = FastSymbol(A$, ")")
             
                Exit Function
   
    
fstr12: ' "аявеио$(", "FILE$("
     If Left$(UCase(q$), 1) = "F" Then
        DialogSetupLang 1
    Else
        DialogSetupLang 0
    End If
    If IsStrExp(bstackstr, A$, r$, False) Then
        If IsSelectorInUse Then
            strFunctions = False
            MyErMacroStr A$, "File/Folder Selector in Use", "о ЕПИКОЦщАР АЯВЕъЫМ/ЖАЙщКЫМ ЕъМАИ СЕ ВЯчСГ"
            Exit Function
        End If
        If r$ = vbNullString Then
            r$ = LoadFileCaption
        End If
        If FastSymbol(A$, ",") Then
            If IsStrExp(bstackstr, A$, q1$, False) Then
            ' ok
            Else
                strFunctions = False
                MissParam A$
                Exit Function
            End If
        Else
            q1$ = "GSB"
        End If
        r$ = mylcasefILE(GetFile(bstackstr, r$, mcd, q1$))
    Else
        r$ = mylcasefILE(GetFile(bstackstr, r$, mcd, "GSB"))
    End If
    strFunctions = FastSymbol(A$, ")")
    Exit Function
fstr13: ' "PARAM$(", "паяал$("
    q1$ = vbNullString
    If IsStrExp(bstackstr, A$, q2$, False) Then
        Do
            w2 = Len(q2$)
            If IsNumberD2(q2$, p) Then
                If q1$ = vbNullString Then Exit Do Else q1$ = q1$ + "," + str(p)
            Else
                ISSTRINGA q2$, s$
                If q1$ = vbNullString Then
                    r$ = s$
                    q1$ = ","
                Else
                    q1$ = q1$ + ",{" + s$ + "}"
                End If
            End If
            FastSymbol q2$, ","
        Loop Until Trim$(q2$) = vbNullString Or w2 = Len(q2$)
    End If
    strFunctions = FastSymbol(A$, ")", True)
    ' FIX THIS a$=....
    A$ = Mid$(q1$, 2) + A$
    Exit Function
fstr14: ' "LAZY$(", "ойм$("
    If FastSymbol(A$, "&") Then
        If Abs(IsLabelBig(bstackstr, A$, q2$, par)) < 5 Then    ''IsLabelDot(HERE$, A$, q2$)
            Exit Function
        End If
        par = False
        If GetSub(q2$ + ")", dd) Then
            If sbf(dd).sbgroup = vbNullString Then
                r$ = sbf(dd).sb + "}"
            Else
                r$ = sbf(dd).sb + "}" + sbf(dd).sbgroup
                par = True
            End If
        End If
        If Not FastSymbol(A$, ")") Then
            strFunctions = False
            MyErMacroStr A$, "No parameters allowed here ()", "дЕМ ЕПИТЯщПОМТАИ ПАЯэЛЕТЯОИ ЕДЧ ()"
            Exit Function
        End If
        If Left$(r$, 10) = "'11001EDIT" Then
            s$ = GetNextLine(r$) + vbCrLf
        Else
            s$ = vbNullString
        End If
            q2$ = vbNullString
    Else
        par = False
        dd = 1
        q1$ = aheadstatus(A$, , dd)
        If dd > 0 Then q2$ = Left$(A$, dd - 1) Else q2$ = "0"
            A$ = Mid$(A$, dd)
            While FastSymbol(A$, ",")
                dd = 1
                q1$ = aheadstatus(A$, , dd)
                If dd > 0 Then q2$ = q2$ + "," + Left$(A$, dd - 1) Else q2$ = q2$ + ",0"
                A$ = Mid$(A$, dd)
            Wend
            r$ = "=" + q2$: q2$ = "}" + bstackstr.UseGroupname
            s$ = vbNullString
        End If
        If Trim$(r$ + q2$) <> "" Then
            If par Then
                r$ = "{" + s$ + r$ + q2$
            Else
            If q$ = "ойм$(" Then
                If here$ = vbNullString Then
                    r$ = "{" + s$ + "тлгла {}" + vbCrLf + r$ + q2$
                Else
                    r$ = "{" + s$ + "тлгла " + here$ + vbCrLf + r$ + q2$
                End If
            Else
                If here$ = vbNullString Then
                r$ = "{" + s$ + "MODULE {}" + vbCrLf + r$ + q2$
   Else
    r$ = "{" + s$ + "MODULE " + here$ + vbCrLf + r$ + q2$
    End If
    End If
    End If
    Else
    r$ = "{}"
    End If
     strFunctions = FastSymbol(A$, ")")
       
       
        Exit Function
fstr15: ' "INPUT$(", "еисацыцг$("
    IsSymbol3 A$, "#"  ' drop it
    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
        p = Int(Abs(p))
        w2 = Fkind(p)
        If w2 = FnoUse Or w2 = Foutput Or w2 = Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": strFunctions = False: Exit Function
        w2 = Fstep(p)
        If uni(p) And w2 = 1 Then w2 = 2
        dd = CLng(p)
        p = Empty
        If FastSymbol(A$, ",", True) Then
            If Not IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
g12367:
                MyErMacroStr A$, "missing parameter for length in chars", "КЕъПЕИ ПАЯэЛЕТЯОР ЦИА ЛчЙОР СЕ ВАЯАЙТчЯЕР"
                strFunctions = True: Exit Function
            End If
        Else
        GoTo g12367
        End If
        On Error Resume Next
        If w2 = 2 Then
            w2 = Module10.ReadFileHandler(dd)
            If w2 = 0 Then strFunctions = False: Exit Function
            Module10.FileReadString w2, r$, CLng(MyRound(Int(p * 2)))
            If FastSymbol(A$, ",") Then
                SwapStrings r$, q1$
                GoTo jump001
            End If
        Else
            w2 = Module10.ReadFileHandler(dd)
            If w2 = 0 Then strFunctions = False: Exit Function
            Module10.FileReadString w2, q1$, CLng(Abs(Int(p / 2)))
            If FastSymbol(A$, ",") Then
jump001:
                If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                        If p < 0 Then
                        r$ = utf8decode(q1$)
                        
                        Else
                        If GetCodePage(CLng(Fix(p))) = 0 Then
                            NoValidLocale
                            Exit Function
                        End If
                        r$ = StrConv(q1$, vbUnicode, CLng(Fix(p)))
                        End If
                Else
                    MissPar
                    Exit Function
                End If
            Else
                r$ = StrConv(q1$, vbUnicode, Clid)
            End If
        End If
    End If
    If Err.Number = 0 Then
        strFunctions = FastSymbol(A$, ")")
    End If
    On Error GoTo 0
    Exit Function
fstr16: '"MEMBER.TYPE$(", "лекоус.тупос$("
     If Abs(IsLabel(bstackstr, A$, s$)) = 1 Then
            If getvar2(bstackstr, s$, dd) Then
                If VarTypeName(var(dd)) = mGroup Then
                If FastSymbol(A$, ",") Then
                If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                p = Fix(p)
                Set ms = var(dd).PrepareSoros(var(), "")
                If p < 1 Or p > ms.Total Then
                OutOfLimit
                Exit Function
                
                End If
                s$ = ms.StackItem(CLng(p))
                If Left$(s$, 1) = "*" Then s$ = Mid$(s$, 2)
                q1$ = Split(s$)(1)
                s$ = Split(s$)(0)
                If Right$(s$, 1) = "(" Then
                    If here$ = vbNullString Or var(dd).IamGlobal Then
                    If varhash.ExistKey(s$) Then
                        If Right$(s$, 3) = "$()" Then
                            r$ = "Array String"
                        ElseIf Right$(s$, 3) = "%()" Then
                            r$ = "Array Integer"
                        Else
                             r$ = "Array Double"
                            
                        End If
                    End If
                    Else
                    If varhash.ExistKey(here$ + "." + s$) Then
                        If Right$(s$, 3) = "$()" Then
                            r$ = "Array String"
                        ElseIf Right$(s$, 3) = "%()" Then
                            r$ = "Array Integer"
                        Else
                             r$ = "Array Double"
                            
                        End If
                    End If
                    End If
                Else
                w3 = val(q1$)
                
                    r$ = VarTypeName(var(w3))
                If r$ = mHdlr Then
                        Set usehandler = var(w3)
                       Select Case usehandler.T1
                       Case 1
                           r$ = "Inventory"
                       Case 2
                           r$ = "Buffer"
                       Case Else
                         r$ = Typename(usehandler.objref)
                       End Select
                     End If
                    End If
                Else
                MissNumExpr
                Exit Function
                End If
                Else
                MissNumExpr
                Exit Function
                End If
                Else

                MissingGroup
                Exit Function
                End If
 
                strFunctions = FastSymbol(A$, ")", True)
                Exit Function
            Else
        
            Nosuchvariable s$
            End If
        Else
         MissingGroup
       End If
       Exit Function
fstr17: ' "MEMBER$(", "лекос$("
     If Abs(IsLabel(bstackstr, A$, s$)) = 1 Then
            If getvar2(bstackstr, s$, dd) Then   '' we need s$ if this is a "THIS"
                  If VarTypeName(var(dd)) = mGroup Then
                If FastSymbol(A$, ",") Then
                If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                    p = Fix(p)
                If var(dd).IamGlobal Then
                    Set ms = var(dd).PrepareSoros(var(), Left$(s$, Len(s$) - Len(var(dd).GroupName) + 1))
                ElseIf Len(here$) > 0 Then
                    If Len(bstackstr.UseGroupname) > 0 Then
                        Set ms = var(dd).PrepareSoros(var(), bstackstr.UseGroupname)
                    Else

                        s$ = var(dd).Patch
                        Set ms = var(dd).PrepareSoros(var(), Left$(s$, Len(s$) - Len(var(dd).GroupName) + 1))
                    End If
                Else

                    Set ms = var(dd).PrepareSoros(var(), Left$(s$, Len(s$) - Len(var(dd).GroupName) + 1))
                End If
                If p < 1 Or p > ms.Total Then
                OutOfLimit
                Exit Function
                
                End If
                 s$ = ms.StackItem(CLng(p))
                If Left$(s$, 1) = "*" Then s$ = Mid$(s$, 2)
                         r$ = Split(s$)(0)
                 If InStr(r$, ChrW(&HFFBF)) > 0 Then r$ = Replace$(r$, ChrW(&HFFBF), "")
                Else
                MissNumExpr
                Exit Function
                End If
                Else
                MissNumExpr
                Exit Function
                End If
                Else

                MissingGroup
                Exit Function
                End If
 
                strFunctions = FastSymbol(A$, ")", True)
                Exit Function
            Else
        
            Nosuchvariable s$
            End If
        Else
         MissingGroup
       End If
       Exit Function
    
    
fstr18: '"PIPENAME$(", "аукос$("
                strFunctions = pipename(bstackstr, A$, r$)
                Exit Function
fstr19: '"DRIVE$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        r$ = DriveTypee(Left$(r$, 3))
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
                Exit Function
fstr20: '"FILE.TYPE$(", "тупос.аявеиоу$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        r$ = ExtractType(r$)
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
                Exit Function
fstr21: ' "FILE.NAME.ONLY$(", "омола.аявеиоу.ломо$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        r$ = ExtractNameOnly(r$, True)
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
                Exit Function
fstr22: ' "FILE.NAME$(", "омола.аявеиоу$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        r$ = ExtractName(r$, True)
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
                Exit Function
fstr23: ' "FILE.PATH$(", "топос.аявеиоу$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        r$ = ExtractPath(r$)  ' ДъМЕИ ВЫЯъР МА ЙОИТэЕИ АМ УПэЯВЕИ!
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
                Exit Function
fstr24: ' "одгцос$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        r$ = DriveType(Left$(r$, 3))  'greek response
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
                Exit Function
fstr25: '"титкос.аявеиоу$(", "FILE.TITLE$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        If r$ <> "" Then r$ = FileNameType(r$)
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
fstr26: '"ежаялоцг.аявеиоу$(", "FILE.APP$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                        If r$ <> "" Then r$ = myRegister(r$)
                        strFunctions = FastSymbol(A$, ")")
                        Exit Function
                End If
fstr27: '"HIDE$(", "йяужо$("
                If IsStrExp(bstackstr, A$, r$, False) Then
                    If FastSymbol(A$, ",") Then
                        If IsStrExp(bstackstr, A$, q$, False) Then
                            If FastSymbol(A$, ",") Then
                                If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                                    r$ = mycoder.encryptline(r$, q$, CLng(Fix(p)))
                                    strFunctions = FastSymbol(A$, ")")
                                    Exit Function
                                End If
                            End If
                        End If
                    End If
                End If
                Exit Function
fstr28: ' "LEFTPART$(", "аяистеяолеяос$("
    strFunctions = False
    If IsStrExp(bstackstr, A$, s$, False) Then
        If FastSymbol(A$, ",") Then
            If IsStrExp(bstackstr, A$, q$, False) Then
                r$ = GetStrUntil(q$, s$)
                strFunctions = FastSymbol(A$, ")")
            ElseIf IsExp(bstackstr, A$, p, , True) Then
                If MemInt(VarPtr(p)) = vbString Then
                    q$ = p
                    r$ = GetStrUntil(q$, s$)
                Else
                    r$ = GetStrUntil(ChrW$(CLng(p)), s$)
                End If
                strFunctions = FastSymbol(A$, ")")
            End If
        End If
    End If
    Exit Function
fstr29: '"RIGHTPART$(", "денилеяос$("
    strFunctions = False
    If IsStrExp(bstackstr, A$, r$, False) Then
        If FastSymbol(A$, ",") Then
            If IsStrExp(bstackstr, A$, q$, False) Then
                DropLeft q$, r$
                strFunctions = FastSymbol(A$, ")")
            ElseIf IsExp(bstackstr, A$, p, , True) Then
                If MemInt(VarPtr(p)) = vbString Then
                    q$ = p
                    DropLeft q$, r$
                Else
                    DropLeft ChrW$(CLng(p)), r$
                End If
                strFunctions = FastSymbol(A$, ")")
            End If
        End If
    End If
    Exit Function
fstr30: ' "ARRAY$(", "пимайас$("
    
    If IsStrExp(bstackstr, A$, q1$) Then
isStr0021:
        If bstackstr.lastobj Is Nothing Then
            If Right$("!!" + q1$, 2) = "()" Then
                Mid$(q1$, Len(q1$), 1) = " "
                q1$ = RTrim$(q1$)
            Else
                dd = InStr("!" + q1$, "(") - 1
                If dd > 0 And dd <= Len(q1$) Then
                    q1$ = Left$(q1$, dd)
                ElseIf neoGetArray(bstackstr, q1$, ppppL) Then
                GoTo check1236789
                Else
                q1$ = q1$ + "("
                End If
                                
            End If
            If neoGetArray(bstackstr, q1$, ppppL) Then
check1236789:
                If Not ppppL.Arr Then NotArray: Exit Function
                
                If FastSymbol(A$, ",") Then
                    strFunctions = NeoGetArrayItem(ppppL, bstackstr, q1$, dd, A$)
                Else
                    strFunctions = FastSymbol(A$, ")", True)
                    dd = 0
                End If
                Set pppp = ppppL
check999100:
                If Not pppp.IsEmpty Then
                    If MyIsObject(pppp.item(dd)) Then
                        If TypeOf pppp.itemObject(dd) Is Document Then
                            r$ = pppp.item(dd)
                            Set bstackstr.lastobj = Nothing
                        Else
                            Set bstackstr.lastobj = pppp.item(dd)
                           r$ = vbNullString
                        End If
                        
                    Else
                        r$ = CStr(pppp.item(dd))
                        Set bstackstr.lastobj = Nothing
                    End If
                    
                Else
                    Set bstackstr.lastobj = Nothing
                    MyEr "Empty Array", "╒ДЕИОР пъМАЙАР"
                End If
                
            Else
                Set bstackstr.lastobj = Nothing
                NotArray
            End If
            
            Exit Function
        ElseIf TypeOf bstackstr.lastobj Is mArray Then
                Set ppppL = bstackstr.lastobj
                GoTo check1236789
        Else
            SyntaxError
            Set bstackstr.lastobj = Nothing
        End If
    ElseIf IsExp(bstackstr, A$, p) Then
        If VarType(p) = vbString Then q1$ = p: GoTo isStr0021
        If Not bstackstr.lastobj Is Nothing Then
            If TypeOf bstackstr.lastobj Is mHandler Then
            Set usehandler = bstackstr.lastobj
            
                If usehandler.indirect >= 0 Then
               If VarTypeName(var(usehandler.indirect)) = myArray Then
                    Set ppppL = var(usehandler.indirect)
                    GoTo check1236789
                    Else
     
                    End If
                    
                ElseIf TypeOf usehandler.objref Is mArray Then
                    Set ppppL = usehandler.objref
                    If bstackstr.lastobj.UseIterator Then
                        If Not ppppL.Arr Then NotArray: Exit Function
                        Set pppp = ppppL
                        If FastSymbol(A$, ",") Then
                            strFunctions = IsExp(bstackstr, A$, r, , True)
                            strFunctions = FastSymbol(A$, ")", True)
                            dd = r
                        Else
                            strFunctions = FastSymbol(A$, ")", True)
                            dd = pppp.Index
                        End If
                        If Not strFunctions Then Exit Function
                        GoTo check999100
                    Else
                        GoTo check1236789
                    End If
                ElseIf TypeOf usehandler.objref Is mStiva Then
                Set ms1 = usehandler.objref
                Set bstackstr.lastobj = Nothing
                    If FastSymbol(A$, ",") Then
                    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                    Set bstackstr.lastobj = ms1.ExportArray(CLng(MyRound(p)))
                    
                    End If
                    Else
                        Set bstackstr.lastobj = ms1.ExportArray(ms1.count)
                        
                    End If
                    Set ms1 = Nothing
                    strFunctions = FastSymbol(A$, ")", True)
                    
                    Exit Function
                Else
                 Set bstackstr.lastobj = Nothing
                NotArray
                End If
            ElseIf TypeOf bstackstr.lastobj Is mArray Then
                Set ppppL = bstackstr.lastobj
                GoTo check1236789
            End If
        End If
    Else
      SyntaxError
    Set bstackstr.lastobj = Nothing
      strFunctions = False
    End If
    Exit Function
fstr31: '"TYPE$(", "тупос$("
    dd = Abs(IsLabel(bstackstr, A$, s$))
    If dd > 4 And dd < 8 Then
    
        If neoGetArray(bstackstr, s$, ppppL) Then
            w2 = 0
            If Not NeoGetArrayItem(ppppL, bstackstr, s$, w2, A$) Then
                If Not ppppL.Arr Then
                    If Typename(ppppL.GroupRef) = mHdlr Then
                        Set p = ppppL.GroupRef
                        strFunctions = CheckItemType(bstackstr, p, A$, r$)
                        Exit Function
                    End If
                End If
                If FastSymbol(A$, ")") Then
                    If Not ppppL Is Nothing Then
                        r$ = myArray
                        strFunctions = FastSymbol(A$, ")")
                    End If
                Else
                    NotExistArray
                End If
                Exit Function
            End If
            If ppppL.Arr Then
                Set pppp = ppppL
                If pppp.ItemIsObject(w2) Then
                    Set p = pppp.item(w2)
                    strFunctions = CheckItemType(bstackstr, p, A$, r$)
                    Exit Function
                Else
                    r$ = pppp.ItemType(w2)
                End If
            Else
                If Typename(ppppL.GroupRef) = mHdlr Then
                    Set p = ppppL.GroupRef
                    strFunctions = CheckItemType(bstackstr, p, A$, r$, True)
                    Exit Function
                Else
                    r$ = Typename(ppppL.GroupRef)
                End If
            End If
            If r$ = "VarItem" Then r$ = "Optional"
            strFunctions = FastSymbol(A$, ")")
        Else
            Nosuchvariable s$
        End If
    ElseIf dd > 0 Then
        If GetVar(bstackstr, s$, w3) Then
            If dd = 8 Then
                If Typename(var(w3)) = "RefArray" Then
                    bstackstr.tmpstr = s$ + "[" + Left$(A$, 1)
                    BackPort A$
                    If IsNumberNew(bstackstr, A$, p, False) Then
                        If bstackstr.lastobj Is Nothing Then
                        If var(w3).count > 0 And var(w3).vtType() = 8204 Then
                        If var(w3).vtType(0) = 9 Then
                        
                            r$ = "Nothing"
                            
                            strFunctions = FastSymbol(A$, ")")
                            Exit Function
                        End If
                        End If
                        strFunctions = CheckItemType(bstackstr, p, A$, r$)
                        Else
                            Set p = bstackstr.lastobj
                            Set bstackstr.lastobj = Nothing
                            If Typename(p) = "RefArray" Then
                            If MyIsObject(p(0)) Then
                            
                            Set p = p(0)
                            Else
                                p = p(0)
                            End If
                            End If
                        strFunctions = CheckItemType(bstackstr, p, A$, r$)
                        
                        End If
                    Else
                        SyntaxError
                    End If
                ElseIf Typename(var(w3)) = "mHandler" Then
                    Set usehandler = var(w3)
                    If usehandler.T1 = 2 Then
                    w1 = 1
                   If BlockParam2s(A$, w1) Then
                   A$ = Mid$(A$, w1 + 1)
                   GoTo contaaaa
                   
                   End If
                   
                   End If
                   MissingObj
                
                Else
                
                    MissingObj
                End If
                Exit Function
            Else
contaaaa:
                strFunctions = CheckItemType(bstackstr, var(w3), A$, r$)
            End If
            Exit Function
        ElseIf bstackstr.ExistVar2(s$) Then
            bstackstr.ReadVar s$, p
            strFunctions = CheckItemType(bstackstr, p, A$, r$)
            Exit Function
        Else
            Nosuchvariable s$
        End If
    ElseIf IsStrExp(bstackstr, A$, s$, False) Then
        r$ = strProgIDfromSrting(s$)
        strFunctions = FastSymbol(A$, ")")
    Else
        SyntaxError
    End If
    Exit Function
fstr32: ' "PARAGRAPH$(", "паяацяажос$("
 
        w1 = Abs(IsLabel(bstackstr, A$, s$))
        If w1 = 3 Then
            If GetVar(bstackstr, s$, w1) Then
                    ' GET PARAGRAPH ORDER NUMBER
                    If Not FastSymbol(A$, ",") Then
                        MissParam A$
                        Exit Function
                    End If
                    If FastSymbol(A$, "(") Then
                    
                    w3 = Abs(IsLabel(bstackstr, A$, s$))
                    If w3 = 1 Or w3 = 4 Then
                    If Not GetVar(bstackstr, s$, w3) Then Nosuchvariable s$: Exit Function
                    If Not FastSymbol(A$, ")") Then SyntaxError: Exit Function
                    dd = 1
                    Else
                    MissingnumVar
                     Exit Function
                    End If
                    ElseIf Not IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                      MissNumExpr
                      Exit Function
                    End If
                        If VarTypeName(var(w1)) = doc Then
                        r$ = var(w1).TextParagraphOrder(CLng(Fix(p)))
                        If FastSymbol(A$, ",") Then
                            If Not IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then MissNumExpr: Exit Function
                            If pp < 0 Then
                                If dd = 1 Then
                                        dd = var(w3)
                                        p = dd
                                             If var(w1).InvalidPara(CLng(p)) Then
                                        MissingDocRef
                                        Exit Function
                                        End If
                                         If var(w1).BackMove Then
                                        var(w3) = var(w1).BackStep(dd)
                                        Else
                                        var(w3) = var(w1).Advance(dd)
                                        End If
                                 
                                        
                                        r$ = var(w1).RemoveDocParaIndex(CLng(p))
                                Else
                                        r$ = var(w1).TextParagraphOrderRemove(CLng(p))
                                End If
                            Else
                                 If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                      If var(w1).InvalidPara(dd) Then
                                        MissingDocRef
                                        Exit Function
                                        End If
                                            If var(w1).BackMove Then
                                            var(w3) = var(w1).BackStep(dd)
                                            Else
                                            var(w3) = var(w1).Advance(dd)
                                            End If
                                            
                                                r$ = Mid$(var(w1).TextParagraph(CLng(p)), CLng(pp))
                                    Else
                                
                                r$ = Mid$(var(w1).TextParagraphOrder(CLng(Fix(p))), CLng(pp))
                                End If
                            End If
                        Else
                                        If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                               If var(w1).InvalidPara(dd) Then
                                        MissingDocRef
                                        Exit Function
                                        End If
                                            If var(w1).BackMove Then
                                            var(w3) = var(w1).BackStep(dd)
                                            Else
                                            var(w3) = var(w1).Advance(dd)
                                            End If
                                                r$ = var(w1).TextParagraph(CLng(p))
                                    Else
                        
                        r$ = var(w1).TextParagraphOrder(CLng(Fix(p)))
                        End If
                        End If
                        Else
                            MissingDoc
                            Exit Function
                        End If
                    
                    strFunctions = FastSymbol(A$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro A$
                    Exit Function
            End If
        ElseIf w1 = 6 Then
            If neoGetArray(bstackstr, s$, ppppL) Then
                    If Not NeoGetArrayItem(ppppL, bstackstr, s$, w2, A$) Then Exit Function
                    If Not FastSymbol(A$, ",") Then
                    MissParam A$
                    Exit Function
                    End If
                    
                    If FastSymbol(A$, "(") Then
                    
                    w3 = Abs(IsLabel(bstackstr, A$, s$))
                    If w3 = 1 Or w3 = 4 Then
                    If Not GetVar(bstackstr, s$, w3) Then Nosuchvariable s$: Exit Function
                     If Not FastSymbol(A$, ")") Then SyntaxError: Exit Function
                    dd = 1
                    Else
                    MissingnumVar
                     Exit Function
                    End If
                    ElseIf Not IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                      MissNumExpr
                      Exit Function
                    End If
                        If ppppL.ItemType(w2) = doc Then
                         If FastSymbol(A$, ",") Then
                            If Not IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then MissNumExpr: Exit Function
                                If pp < 0 Then
                                        If dd = 1 Then
                                                dd = var(w3)
                                                p = dd
                                                   If ppppL.item(w2).InvalidPara(dd) Then
                                                    MissingDocRef
                                                    Exit Function
                                                    End If
                                                If ppppL.item(w2).BackMove Then
                                                var(w3) = ppppL.item(w2).BackStep(dd)
                                                Else
                                                var(w3) = ppppL.item(w2).Advance(dd)
                                                End If
                                                r$ = ppppL.item(w2).RemoveDocParaIndex(CLng(p))
                                        Else
                                                r$ = ppppL.item(w2).TextParagraphOrderRemove(CLng(Fix(p)))
                                        End If
                                Else
                                   If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                                 If ppppL.item(w2).InvalidPara(dd) Then
                                                    MissingDocRef
                                                    Exit Function
                                                    End If
                                            If ppppL.item(w2).BackMove Then
                                            var(w3) = ppppL.item(w2).BackStep(dd)
                                            Else
                                            var(w3) = ppppL.item(w2).Advance(dd)
                                            End If
                                        r$ = Mid$(ppppL.item(w2).TextParagraph(CLng(p)), CLng(pp))
                                    Else
                                r$ = Mid$(ppppL.item(w2).TextParagraphOrder(CLng(Fix(p))), CLng(pp))
                                End If
                                End If
                            Else
                            If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                                 If ppppL.item(w2).InvalidPara(dd) Then
                                                    MissingDocRef
                                                    Exit Function
                                                    End If
                                            If ppppL.item(w2).BackMove Then
                                            var(w3) = ppppL.item(w2).BackStep(dd)
                                            Else
                                            var(w3) = ppppL.item(w2).Advance(dd)
                                            End If
                                r$ = ppppL.item(w2).TextParagraph(CLng(p))
                                            Else
                                r$ = ppppL.item(w2).TextParagraphOrder(CLng(Fix(p)))
                                End If
                            End If
                        Else
                            MissingDoc
                            Exit Function
                        End If
                    
                    strFunctions = FastSymbol(A$, ")", True)
            Else
                    MissParam A$
            End If
        End If
    Exit Function
fstr33: '"UNION.DATA$(", "емысг.сеияас$("
    strFunctions = uniondata(bstackstr, A$, r$)
    Exit Function
fstr34: ' "MAX.DATA$(", "лецако.сеияас$("

  If IsStrExp(bstackstr, A$, r$, False) Then
  
  Do While FastSymbol(A$, ",")
  If Not IsStrExp(bstackstr, A$, s, False) Then MissStringExpr: Exit Function
  If r$ < s Then r$ = s
  
  Loop

    strFunctions = FastSymbol(A$, ")", True)
        Else
      MissStringExpr
        End If
    Exit Function
fstr35: ' "MIN.DATA$(", "лийяо.сеияас$("
 strFunctions = False
  If IsStrExp(bstackstr, A$, r$, False) Then
  
  Do While FastSymbol(A$, ",")
  If Not IsStrExp(bstackstr, A$, s, False) Then MissStringExpr: Exit Function
  If r$ > s Then r$ = s
  
  Loop

    strFunctions = FastSymbol(A$, ")", True)
        Else
      MissStringExpr
        End If
    Exit Function
fstr36: ' "FUNCTION$(", "сумаятгсг$("
    If IsStrExp(bstackstr, A$, s$, False) Then
        If IsSymbolBracket(s$) Then
            PushStage bstackstr, False
            GlobalSub "A$()", block(s$)
            IsSymbol3 A$, ","
            ' fix this a$=...
              A$ = "A$(*" + A$
            strFunctions = IsStrExp(bstackstr, A$, r$, False)
            
            PopStage bstackstr
            Else
            If lookOne(A$, ".") Then
                dd = 1
                      q1$ = aheadstatus(A$, , dd)
                s$ = s$ + Left$(A$, dd - 1)
                A$ = Mid$(A$, dd)
            End If
                 If FastSymbol(A$, ",") Then
                End If
                
              
                    If Right$(s$, 1) = ")" Then
                       ' fix this a$=...
                        A$ = Left$(s$, Len(s$) - 1) + A$
                   ElseIf InStr(s$, ").") > 0 Then     ''''''Or A$ Like ".*"
                   FastSymbol A$, ")"
                      ' fix this a$=...
                     A$ = s$ + A$
                    Else
               If Right$("!" + s$, 1) = "$" Then
                  ' fix this a$=...
                    A$ = s$ + "(*" + A$  '' w1 put a @ from 102
                Else
                  ' fix this a$=...
                 A$ = s$ + "$(" + A$
                    End If
                End If
        strFunctions = IsStrExp(bstackstr, A$, r$, False)
     End If
     End If
    Exit Function
fstr37: '"HEX$(", "дейаен$("
    strFunctions = mHex(bstackstr, A$, r$)
    Exit Function
fstr38: '"SHOW$(", "жамеяо$("
    If IsStrExp(bstackstr, A$, r$, False) Then
        If FastSymbol(A$, ",") Then
            If IsStrExp(bstackstr, A$, q$, False) Then
                If FastSymbol(A$, ",") Then
                    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                        r$ = mycoder.decryptline(r$, q$, CLng(Fix(p)))
                        strFunctions = True
                         If Not FastSymbol(A$, ")") Then strFunctions = False
                        Exit Function
                    End If
                End If
            End If
        End If
    End If
    Exit Function
fstr39: '"MENU$(", "епикоцг$(", "епикоцес$("
    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
    p = Abs(CLng(Fix(p)))
    With Form1.List1
        If p > 0 And .listcount >= p Then
            r$ = .list(CLng(p) - 1)
            strFunctions = True
            Else
            MyErMacroStr A$, "index out of limits", "О ДЕъЙТГР ЕъМАИ ЕЙТЭР ОЯъЫМ"
        End If
    End With
    Else
    ' return a copy
    Set pppp = New mArray: pppp.PushDim (Form1.List1.listcount): pppp.PushEnd: pppp.Arr = True
    For w2 = 0 To Form1.List1.listcount - 1
    pppp.item(w2) = Form1.List1.list(w2)
    Next w2
               Set usehandler = New mHandler
                usehandler.T1 = 3
                Set usehandler.objref = pppp
                Set bstackstr.lastobj = usehandler
                Set pppp = Nothing
                Set usehandler = Nothing
                r$ = vbNullString
                strFunctions = True
    End If
    If Not FastSymbol(A$, ")") Then strFunctions = False
    Exit Function
fstr40: '"REPLACE$(", "аккацг$("
    
    If IsStrExp(bstackstr, A$, q$, False) Then
       If FastSymbol(A$, ",") And IsStrExp(bstackstr, A$, q1$, False) Then
            If FastSymbol(A$, ",") And IsStrExp(bstackstr, A$, q2$, False) Then
     strFunctions = True
      If FastSymbol(A$, ",") And IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
            p = Int(p)
            If p < 0 Then p = 1
        If FastSymbol(A$, ",") And IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then
        pp = Abs(Int(pp))
        If p > 1 Then
        r$ = Left$(q2$, p - 1) + Replace$(q2$, q$, q1$, p, pp)
        Else
        r$ = Replace$(q2$, q$, q1$, p, pp)
        End If
        Else
        If p = 1 Then
            r$ = Replace$(q2$, q$, q1$, p)
            
        Else
            r$ = Left$(q2$, p - 1) + Replace$(q2$, q$, q1$, p)
        End If
      End If
      Else
    r$ = Replace$(q2$, q$, q1$)
    End If
       End If
       End If
    End If
    If Not FastSymbol(A$, ")") Then strFunctions = False
    Exit Function
fstr41: '"PATH$(", "топос$("
      If IsExp(bstackstr, A$, p, , True) Then
      If MemInt(VarPtr(p)) = vbString Then
        q$ = p
        r$ = ExtractPath$(q$)
      Else
        r$ = GetSpecialfolder(CLng(Fix(p)))
        AddDirSep r$
    End If
    strFunctions = True
    
    ElseIf IsStrExp(bstackstr, A$, q$, False) Then
     strFunctions = True
     
    r$ = ExtractPath$(q$)
    End If
    If Not FastSymbol(A$, ")") Then strFunctions = False
    Exit Function
fstr42: '"UCASE$(", "йеж$("
    
    If IsStrExp(bstackstr, A$, r$, False) Then
      strFunctions = True
      If FastSymbol(A$, ",") And IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
            If Fix(p) <> 0 Then
            If GetCodePage(CLng(Fix(p))) = 0 Then
                NoValidLocale
                Exit Function
            End If
            r$ = kUpper(Convert3(r$, CLng(Fix(p))), Fix(p))
            Else
            r$ = kUpper(Convert3(r$, CLng(Clid)), CDbl(Clid))
            End If
      Else
      myUcase2 r$
     End If
    End If
    If Not FastSymbol(A$, ")") Then strFunctions = False
    Exit Function
fstr43: '"LCASE$(", "пеф$("
     If IsStrExp(bstackstr, A$, r$, False) Then
   strFunctions = True
      If FastSymbol(A$, ",") And IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
      If Fix(p) <> 0 Then
        If GetCodePage(CLng(Fix(p))) = 0 Then
            NoValidLocale
            Exit Function
        End If
      r$ = klower(Convert3(r$, CLng(Fix(p))), Fix(p))
      Else
      r$ = klower(Convert3(r$, CLng(Clid)), CDbl(Clid))
      End If
      Else
      myLcase2 r$
     
     End If
    
    End If
    
    
    If Not FastSymbol(A$, ")") Then strFunctions = False
    Exit Function
fstr44: '"STRING$(", "епам$("
    w2 = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, A$, q$, False) Then
        If FastSymbol(A$, ",") Then
            If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                p = Int(Abs(p))
                If LenB(q$) > 0 Then
                    On Error Resume Next
                    If LenB(q$) Mod 2 = 0 Then
                        w2 = Len(q$)
                        r$ = space$(p * w2)
                        While p > 0
                            p = p - 1
                            Mid$(r$, p * w2 + 1, w2) = q$
                        Wend
                    Else
                        While p > 0
                            r$ = r$ + q$
                            p = p - 1
                        Wend
                    End If
                End If
                strFunctions = True
            End If
        Else
            If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
                If IsSymbol(A$, "JSON", 4) Then
                    r$ = StringToEscapeStr(q$, True)
                ElseIf IsSymbol(A$, "ENCODE64", 8) Then
                    If FastSymbol(A$, ",") Then
                        If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                            p = Int(Abs(p))
                            If p = 0 Then
                                If FastSymbol(A$, ",") Then
                                    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                                        r$ = Encode64(q$, False, CLng(p))
                                    Else
                                        MissParam A$
                                        Exit Function
                                    End If
                                Else
                                    r$ = Encode64(q$, CBool(p))
                                End If
                            Else
                                r$ = Encode64(q$, CBool(p))
                            End If
                        Else
                            MissParam A$
                            Exit Function
                        End If
                    Else
                        r$ = Encode64(q$)
                    End If
                ElseIf IsSymbol(A$, "DECODE64", 8) Then
                    While FastSymbol(q$, vbCrLf, , 2)
                    Wend
                    r$ = Decode64(q$, par)
                    If Not par Then MyEr "No base 64 encoding string", "тО АКЖАЯИХЛГТИЙЭ ДЕМ щВЕИ ДЕДОЛщМА СЕ БэСГ 64": strFunctions = False: Exit Function
                ElseIf IsSymbol(A$, "UTF8", 4) Then
                    If IsSymbolNoSpace(A$, "DEC", 3) Then
                        r$ = utf8decode(q$)
                    ElseIf IsSymbolNoSpace(A$, "ENC", 3) Then
                        r$ = utf8encode(q$)
                    Else
                        SyntaxError
                        strFunctions = False
                        Exit Function
                    End If
                ElseIf IsSymbol(A$, "URL", 3) Then
                    If IsSymbolNoSpace(A$, "ENC", 3) Then
                        dd = 0
                        If FastSymbol(A$, "1") Then
                            dd = 1
                        ElseIf IsSymbolNoSpace(A$, "RFC3986", 7) Then
                            dd = 1
                        ElseIf FastSymbol(A$, "2") Then
                            dd = 2
                        ElseIf IsSymbolNoSpace(A$, "HTML5", 5) Then
                            dd = 2
                        ElseIf IsSymbolNoSpace(A$, "SYS", 3) Then
                            dd = 3
                        End If
                        If dd = 3 Then
                            r$ = URLEncode(q$, IsSymbol(A$, "+"))
                        Else
                            r$ = URLEncodeEsc(q$, IsSymbol(A$, "+"), dd)
                        End If
                    ElseIf IsSymbolNoSpace(A$, "DEC", 3) Then
                        r$ = DecodeEscape(q$, IsSymbol(A$, "+"))
                    ElseIf IsSymbolNoSpace(A$, "HOST", 4) Then
                        r$ = GetHost(q$)
                    ElseIf IsSymbolNoSpace(A$, "PATH", 4) Then
                        r$ = GetUrlPath(q$)
                    ElseIf IsSymbolNoSpace(A$, "PORT", 4) Then
                        r$ = GetDomainName(q$, True)
                        If r$ <> vbNullString Then
                            If Left$(r$, 1) = "[" Then
                                dd = InStr(r$, "]") + 1
                                r$ = Mid$(r$, dd)
                            Else
                                dd = InStr(r$, "@")
                                If dd > 0 Then r$ = Mid$(r$, dd + 1)
                            End If
                            If r$ <> vbNullString Then
                                dd = InStr(r$, ":")
                                If dd > 0 Then r$ = Mid$(r$, dd + 1) Else r$ = ""
                            End If
                        End If
                        If r$ = "" Then
                            Select Case UCase(GetUrlParts(q$, 1))
                            Case "HTTP", "TELNET"
                                r$ = "80"
                            Case "FTP"
                                r$ = "21"
                            Case "HTTPS"
                                r$ = "443"
                            Case "LDAP"
                                r$ = "389"
                            Case "SOCKS5"
                                r$ = "1080"
                            End Select
                        End If
                    ElseIf IsSymbolNoSpace(A$, "PART", 4) Then
                        If IsExp(bstackstr, A$, p, True, True, False) Then
                            dd = CLng(p)
                        Else
                            dd = 1
                        End If
                        r$ = GetUrlParts(q$, p)
                    ElseIf IsSymbolNoSpace(A$, "SCHEME", 6) Then
                        If IsExp(bstackstr, A$, p, True, True, False) Then
                        dd = CLng(p)
                    Else
                        dd = 1
                    End If
                    r$ = GetUrlParts(q$, dd, 1)
                ElseIf IsSymbolNoSpace(A$, "FRAGMENT", 8) Then
                    r$ = DecodeEscape(q$, IsSymbol(A$, "+"))
                    If r$ <> vbNullString Then
                        dd = InStr(r$, "#")
                        If dd > 0 Then r$ = Mid$(r$, dd + 1) Else r$ = vbNullString
                    End If
                ElseIf IsSymbolNoSpace(A$, "USERINFO", 8) Then
                    r$ = GetDomainName(q$, True)
                    If r$ <> vbNullString Then
                        dd = InStr(r$, "@")
                        If dd > 0 Then r$ = Left$(r$, dd - 1) Else r$ = vbNullString
                    End If
                ElseIf IsSymbolNoSpace(A$, "AUTHORITY", 9) Then
                    r$ = GetDomainName(q$, True)
                    If r$ <> vbNullString Then
                        If Left$(r$, 1) = "[" Then
                            dd = InStr(r$, "]")
                            r$ = Mid$(r$, 2, dd - 2)
                        End If
                    End If
                Else
                    SyntaxError
                    strFunctions = False
                    Exit Function
                End If
            Else
                SyntaxError
                strFunctions = False
                Exit Function
            End If
        Else
        
         r$ = StringToEscapeStr(q$)
         End If
         strFunctions = True
    End If
    If Not FastSymbol(A$, ")") Then strFunctions = False
        Exit Function
    End If
    strFunctions = False
    Exit Function
fstr45: ' "MID$(", "лес$("
    w2 = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, A$, q$, False) Then
    If FastSymbol(A$, ",") Then
    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
    p = Abs(p)
    If p = 0 Then
        MyErMacroStr A$, "Zero pos in mid$ not allowed", "лГДЕМИЙч ХщСГ СТГМ лес$ ДЕМ ЕПИТЯщПЕТАИ)"
        strFunctions = False
        Exit Function
    Else
      If FastSymbol(A$, ",") Then
          If IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then
                pp = Abs(pp)
                If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
                    If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w2) Then
                        r$ = MidB$(q$, p, pp)
                    Else
                        SyntaxError
                        Exit Function
                    End If
                Else
                    r$ = Mid$(q$, p, pp)
                End If
            Else
                MissParam A$
                Exit Function
            End If
        Else
            If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
                If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w2) Then
                    r$ = MidB$(q$, p)
                Else
                    SyntaxError
                    Exit Function
                End If
            Else
                r$ = Mid$(q$, p)
            End If
        End If
        strFunctions = True
        End If
        Else
            MissParam A$
            Exit Function
        End If
    End If
    If Not FastSymbol(A$, ")", True) Then strFunctions = False
    Else
    MissStringExpr
    strFunctions = False
    Exit Function
    End If
    strFunctions = True
    Exit Function
    
fstr46: ' "LEFT$(", "аяис$("
    w2 = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, A$, q$, False) Then
    If FastSymbol(A$, ",") And IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
    p = Abs(p)
    If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
        If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w2) Then
            r$ = LeftB$(q$, p)
        Else
        SyntaxError
        Exit Function
        End If
    Else
        r$ = Left$(q$, p)
    End If
    strFunctions = True
    End If
    If Not FastSymbol(A$, ")", True) Then strFunctions = False
    Else
    MissStringExpr
    strFunctions = False
    Exit Function
    End If
    Exit Function
fstr47: ' "RIGHT$(", "дени$("
    w2 = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, A$, q$, False) Then
    If FastSymbol(A$, ",") And IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
    p = Abs(p)
    If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
        If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w2) Then
           r$ = RightB$(q$, p)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        r$ = Right$(q$, p)
    End If
    strFunctions = True
    End If
    If Not FastSymbol(A$, ")", True) Then strFunctions = False
    Else
    MissStringExpr
    strFunctions = False
    Exit Function
    End If
    Exit Function
fstr48: ' "SND$(", "гво$("
     If IsStrExp(bstackstr, A$, q$, False) Then
        r$ = CFname(q$ + ".WAV")
         If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
    Else
        strFunctions = False
    Exit Function
    End If
fstr49: ' "BMP$(", "еий$("
     If IsStrExp(bstackstr, A$, q$, False) Then
        r$ = CFname(q$ + ".BMP")
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
    Else
        strFunctions = False
    Exit Function
    End If
fstr50: '"JPG$(", "жыто$("
     If IsStrExp(bstackstr, A$, q$, False) Then
        r$ = CFname(q$ + ".JPG")
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
    Else
        strFunctions = False
    Exit Function
    End If
fstr69: '"RTRIM$(", "апой.де$("
    w2 = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, A$, q$, False) Then
        If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
        If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w2) Then
           r$ = MyTrimRB$(q$)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        r$ = MyTrimRW$(q$)
    End If
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
    Else

        strFunctions = False
    Exit Function
    End If

fstr70: '"LTRIM$(", "апой.ая$("
    w2 = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, A$, q$, False) Then
        If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
        If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w2) Then
           r$ = MyTrimLB$(q$)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        r$ = MyTrimLW$(q$)
    End If
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
    Else

        strFunctions = False
    Exit Function
    End If

fstr51: '"TRIM$(", "апой$("
    w2 = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, A$, q$, False) Then
        If IsLabelSymbolNew(A$, "ыс", "AS", w2) Then
        If IsLabelSymbolNew(A$, "ьгжио", "BYTE", w2) Then
           r$ = MyTrimB$(q$)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        r$ = MyTrim$(q$)
    End If
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
    Else

        strFunctions = False
    Exit Function
    End If
fstr52: '"QUOTE$(", "паяахесг$("
r$ = vbNullString
q1$ = vbNullString
Do
If IsStrExp(bstackstr, A$, q$) Then
' make q$ as json string
jmp12984657:
 r$ = r$ + q1$ + Chr(34) + q$ + Chr(34)
ElseIf IsExp(bstackstr, A$, p, , True) Then
            If MemInt(VarPtr(p)) = 20 Then
                r$ = r$ + q1$ + CStr(p)
            ElseIf MemInt(VarPtr(p)) = vbString Then
                q$ = p
                GoTo jmp12984657
            Else
                r$ = r$ + q1$ + LTrim$(str(p))
            End If
        Else
        strFunctions = False: Exit Function
        End If
        If Not FastSymbol(A$, ",") Then Exit Do
        q1$ = ","
        Loop
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
 
fstr53: '"сыяос$(", "STACK$("
r$ = vbNullString
Do
If IsStrExp(bstackstr, A$, q$) Then
 r$ = r$ + Sput(q$)
ElseIf IsExp(bstackstr, A$, p) Then
        If Not bstackstr.lastobj Is Nothing Then
        MyEr "Number or and string allowed", "ЕПИТЯщПОМТАИ аЯИХЛОъ ч ЙАИ цЯэЛЛАТА "
        Set bstackstr.lastobj = Nothing
        strFunctions = False: Exit Function
        End If
        Select Case VarType(p)
        Case vbString
        r$ = r$ + Sput(q$)
        Case vbLong
        r$ = r$ + " " + LTrim$(str$(p)) + "&"
        Case vbDecimal
        r$ = r$ + " " + LTrim$(str$(p)) + "@"
        Case vbSingle
        r$ = r$ + " " + LTrim$(str$(p)) + "~"
        Case vbCurrency
        r$ = r$ + " " + LTrim$(str$(p)) + "#"
        Case vbInteger
        r$ = r$ + " " + LTrim$(str$(p)) + "%"
        Case 20
        r$ = r$ + " " + CStr(p) + "&&"
        Case Else
        r$ = r$ + " " + LTrim$(str$(p))
        End Select
        End If
        If Not IsSymbol3(A$, ",") Then Exit Do
        Loop
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
fstr54: '"ADD.LICENSE$(", "баке.адеиа$("
If IsStrExp(bstackstr, A$, q$, False) Then
If FastSymbol(A$, ",") Then
If IsStrExp(bstackstr, A$, q1$, False) Then
Err.Clear
On Error Resume Next
        If q1$ = vbNullString Then
        r$ = Licenses.Add(q$)
        Else
        r$ = Licenses.Add(q$, q1$)
        End If
        If Err.Number > 0 And Err.Number <> 732 Then MissLicense
        Err.Clear
        On Error GoTo 0
       If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
End If
Else
Err.Clear
On Error Resume Next
        r$ = Licenses.Add(q$)
        If Err > 0 And Err.Number <> 732 Then MissLicense
        Err.Clear
        On Error GoTo 0
       If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True


End If
End If

        Exit Function
fstr55: '"ENVELOPE$(", "жайекос$("
If IsStrExp(bstackstr, A$, q$, False) Then
    If FastSymbol(A$, ",") Then
            If Not IsStrExp(bstackstr, A$, q1$, False) Then strFunctions = False: Exit Function
            Else
            q1$ = vbNullString
            End If
            If VALIDATE(q$, UCase$(q1$), q2$) Then ' Only S and N
               r$ = q2$
               Else
               r$ = vbNullString
               End If
    Else
' STACK$(BSTACKSTR)
                If FastSymbol(A$, ",") Then
                If Not IsStrExp(bstackstr, A$, q1$, False) Then strFunctions = False: Exit Function
                Else
                q1$ = vbNullString
                End If

                If VALIDATEmStiva(bstackstr, UCase$(q1$), q2$) Then
                   r$ = q2$
                   Else
                   r$ = vbNullString
                   End If

    End If
         If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
        Exit Function
fstr56: '"FIELD$(", "педио$("
    If IsStrExp(bstackstr, A$, q$, False) Then
        If FastSymbol(A$, ",") Then
           If Not IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
           strFunctions = False
           Exit Function
           End If
           p = Abs(p)
        Else
           strFunctions = False
           Exit Function
        End If
        dd = CLng(p)
        
        r$ = Left$(Trim$(q$), dd)
        dd = dd - Len(r$)
        If dd > 0 Then r$ = r$ + space$(dd)
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True
      
    Else

        strFunctions = False
   
    End If
    Exit Function
fstr57: '"DRW$(", "свд$("
    If IsStrExp(bstackstr, A$, q$, False) Then
        r$ = CFname(q$ + ".WMF")
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
        strFunctions = True

    Else
        strFunctions = False
    End If
    Exit Function
fstr58: '"TIME$(", "вяомос$("
    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
        If FastSymbol(A$, ",") Then
            If Not IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then
                pp = Clid
            End If
            If FastSymbol(A$, ",") Then
                If IsStrExp(bstackstr, A$, s$, False) Then
                    If UCase(s$) = "SHORT TIME" Then
                        s$ = GetlocaleString2(&H5D, pp)
                    ElseIf UCase(s$) = "LONG TIME" Then
                        s$ = GetlocaleString2(&H79, pp)
                    End If
                    strFunctions = True
                    r$ = FormatTimeWithLocale(s$, CDate(p), pp)
                Else
                    MissParam A$
                    strFunctions = False
                    Exit Function
                End If
            Else
                strFunctions = True
                r$ = FormatTimeWithLocale(GetlocaleString2(&H5D, pp), CDate(p), pp)
            End If
       Else
            r$ = Format(p, "SHORT TIME")
            strFunctions = True
       End If
    Else
        strFunctions = True
        r$ = Trim$(GetTimeZoneInfo)
    End If
    If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
    Exit Function
fstr59: ' "DATE$(", "глеяа$("
    strFunctions = mDate(bstackstr, A$, r$)
    Exit Function
fstr60: '"STR$(", "цяажг$("
    If IsExp(bstackstr, A$, p) Then
    
    If Not bstackstr.lastobj Is Nothing Then
        If TypeOf bstackstr.lastobj Is Group Then
            If bstackstr.lastobj.HasValue Then
            
            Else
            MyErMacro A$, "Group has no value", "г ОЛэДА ДЕМ щВЕИ АНъА"
            Exit Function
            End If
        ElseIf TypeOf bstackstr.lastobj Is mHandler Then
        p = 0
        Set usehandler = bstackstr.lastobj
        If usehandler.T1 = 4 Then p = usehandler.index_cursor
        Set bstackstr.lastobj = Nothing
        Set usehandler = Nothing
        ElseIf TypeOf bstackstr.lastobj Is BigInteger Then
            r$ = bstackstr.lastobj.ToString
            Set bstackstr.lastobj = Nothing
            If FastSymbol(A$, ")") Then
                strFunctions = True
                Exit Function
            Else
                p = ""
                SwapString2Variant r$, p
                GoTo KM234
            End If
        End If
    ElseIf MemInt(VarPtr(p)) = vbString Then
        SwapString2Variant r$, p
            GoTo KM234
        End If
        
        If FastSymbol(A$, ",") Then
            If IsExp(bstackstr, A$, pp, flatobject:=True) Then
            If MemInt(VarPtr(pp)) = vbString Then
                SwapString2Variant q$, pp
                GoTo KM123
            ElseIf pp = 0 Then
                If MemInt(VarPtr(p)) = vbBoolean Then
                    r$ = Format$(p, DefBooleanString)
                Else
                    r$ = CStr(p)
                End If
            Else
                q$ = GetlocaleString2(14, pp)
                If VarType(p) = vbBoolean Then
                    If pp = 1032 Then
                        r$ = Format$(p, ";аКГХщР;ьЕУДщР")
                    ElseIf pp = 1033 Then
                        r$ = Format$(p, ";\T\r\u\e;\F\a\l\s\e")
                    Else
                        r$ = Format$(p, DefBooleanString)
                    End If
                Else
                If CheckInt64(p) Then
                    r$ = CStr(p)
                Else
                    r$ = LTrim$(str$(p))
                    Select Case VarType(p)
                    Case vbLong, vbInteger
                    Case Else
                        If Left$(r$, 1) = "." Then
                            If AscW(q$) = 46 Then
                                r$ = "0" + r$
                            Else
                                r$ = "0" + Replace(r$, ".", q$)
                            End If
                        ElseIf Left$(r$, 2) = "-." Then
                            If AscW(q$) = 46 Then
                                r$ = "-0" + Mid$(r$, 2)
                            Else
                                r$ = "-0" + Replace(Mid$(r$, 2), ".", q$)
                            End If
                        ElseIf AscW(q$) <> 46 Then
                            If InStr(r$, ".") > 1 Then
                                r$ = Replace(r$, ".", q$)
                            End If
                        End If
                    End Select
                End If
            End If
                End If
                

            GoTo contstrhere
            ElseIf IsStrExp(bstackstr, A$, q$, False) Then
KM123:
            On Error Resume Next
                If TypeOf p Is cxComplex Then
            If p.I = 0 Then
                r$ = Format$(p.r, q$)
            ElseIf p.r = 0 Then
                r$ = "(" & Format$(p.I, q$) & "i)"
            Else
            If p.I < 0 Then r$ = "" Else r$ = "+"
            r$ = "(" & Format$(p.r, q$) & r$ & Format$(p.I, q$) & "i)"
            End If
                Else
                r$ = Format(p, q$)
                End If
                If Err.Number = 6 Then Overflow
                Err.Clear
                If Not NoUseDec Then
                    If mNoUseDec Then
                        r$ = Replace$(r$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                        If InStr(r$, "#IN") > 0 Then r$ = Replace$(r$, GetDeflocaleString(LOCALE_STHOUSAND) + "#", Chr(2) + "#")
                        r$ = Replace$(r$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                        r$ = Replace$(r$, Chr(2), NowDec$)
                        r$ = Replace$(r$, Chr(3), NowThou$)
                        
                    ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                        r$ = Replace$(r$, ",", Chr(2))
                        r$ = Replace$(r$, ".", ",")
                        r$ = Replace$(r$, Chr(2), ".")

                End If
                Else
                If InStr(r$, "#IN") > 0 Then r$ = Replace$(r$, ".#", NowDec$ + "#")
                    End If
contstrhere:
            If FastSymbol(A$, ",") Then
            If IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then
            If pp > 0 Then
            r$ = Left$(r$ + space$(pp), pp)
            Else
            r$ = Right$(space$(Abs(pp)) + r$, Abs(pp))
            End If
            Else
            strFunctions = False
            Exit Function
            End If
            End If
            
            ElseIf IsExp(bstackstr, A$, pp, , True) Then
                If MemInt(VarPtr(p)) = 20 Then
                    r$ = CStr(p)
                ElseIf VarType(p) = vbString Then
                    r$ = LTrim$(p)
                Else
                    r$ = LTrim$(str(p))
                End If
            If pp > 0 Then
            r$ = Left$(r$ + space$(pp), pp)
            Else
            r$ = Right$(space$(Abs(pp)) + r$, Abs(pp))
            End If
            Else
            strFunctions = False
            Exit Function
            End If
        Else
            If VarType(p) = vbBoolean Then
                r$ = Format$(p, ";\T\r\u\e;\F\a\l\s\e")
            Else
                If TypeOf p Is cxComplex Then
                    If p.I >= 0 Then r$ = "+"
                    r$ = "(" + LTrim$(str(p.r)) + "," + r$ + LTrim$(str(p.I)) + "i)"
                Else
                    r$ = str(p)
                End If
            End If
        End If
        
        If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
    strFunctions = True
    Exit Function
    ElseIf IsStrExp(bstackstr, A$, r$, False) Then
KM234:
        If FastSymbol(A$, ",") Then
            If IsStrExp(bstackstr, A$, q$, False) Then
                r$ = Format(r$, q$)
            ElseIf IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then
                If Fix(pp) = 0 Then
                    r$ = Convert2(r$, Clid)
                Else
                    If GetCodePage(CLng(Fix(pp))) <> 0 Then
                        r$ = Convert2(r$, CLng(Fix(pp)))
                    Else
                        strFunctions = False
                        NoValidLocale
                        Exit Function
                    End If
                End If
            Else
                strFunctions = False
                Exit Function
            End If
        Else
        r$ = StrConv(r$, vbFromUnicode, Clid)
        End If
            If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
    strFunctions = True
    Else
    strFunctions = False
    End If
    Exit Function
   
fstr61: '"CHRCODE$(", "ваяйыд$("
    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
        w3 = UINT(p)
    If w3 >= &H10000 And w3 <= &H10FFFF Then
        w3 = w3 - &H10000
        r$ = ChrW(UINT(w3 \ &H400& + &HD800&)) + ChrW(UINT((w3 And &H3FF&) + &HDC00&))
        Else
    r$ = ChrW$(w3)
    End If
    If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
    strFunctions = True
    Else
    strFunctions = False
    End If
    Exit Function
    
fstr62: ' "CHR$(", "вая$("
    If IsExp(bstackstr, A$, p, , True) Then
        If MemInt(VarPtr(p)) = vbString Then q$ = p: GoTo g131993
        If FastSymbol(A$, ",") Then
                If IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then
                If pp = 0 Then
                    pp = LCID_DEF
                Else
                    If GetCodePage(CLng(Fix(pp))) = 0 Then
                        NoValidLocale
                        Exit Function
                    End If
                End If
                
                     r$ = ChrW$(AscW(StrConv(ChrW$(p Mod 256), 64, CLng(Fix(pp)))))
                Else
                        strFunctions = False: Exit Function
                End If
        Else

                 r$ = ChrW$(AscW(StrConv(ChrW$(Fix(p) Mod 256), 64, Clid)))

        End If
        If InStr(r$, ChrW(&HFFFFF8FB)) > 0 Then r$ = Replace(r$, ChrW(&HFFFFF8FB), ChrW(&H2007))
    If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
    strFunctions = True
    Exit Function
    ElseIf IsStrExp(bstackstr, A$, q$, False) Then 'CONVERT TO ASCII
g131993:
            If FastSymbol(A$, ",") Then
                If IsExp(bstackstr, A$, pp, flatobject:=True, nostring:=True) Then
                If Fix(pp) = 0 Then
                   r$ = Convert3(q$, LCID_DEF)
                ElseIf LCID_DEF = 1032 Then
                    If GetCodePage(CLng(Fix(pp))) = 0 Then
                        NoValidLocale
                        Exit Function
                    End If
                
                
                     r$ = Convert3(q$, CLng(Fix(pp)))
                Else
                    If GetCodePage(CLng(Fix(pp))) = 0 Then
                        NoValidLocale
                        Exit Function
                    End If
                
                  r$ = Convert3(Convert2(q$, LCID_DEF), CLng(Fix(pp)))
     
                   
                     End If
                Else
                        strFunctions = False: Exit Function
                End If
        Else
        r$ = StrConv(q$, vbUnicode, Clid)
        End If
    If Not FastSymbol(A$, ")") Then strFunctions = False: Exit Function
    strFunctions = True
    Else
    strFunctions = False
    End If
    Exit Function
fstr63: ' "GROUP$(", "олада$("
        
r$ = vbNullString
 strFunctions = IsGroup(bstackstr, A$, p)
        
        
Exit Function
fstr64: ' "PROPERTY$(", "идиотгта$("
        dd = Abs(IsLabel(bstackstr, A$, s$))
        If dd = 1 Or dd = 3 Or dd = 6 Then
        If dd = 6 Then If Not FastSymbol(A$, ")", True) Then Exit Function
        If Not GetVar(bstackstr, s$, w2) Then GoTo jmp147811
        If dd = 6 Then
        
         If Not VarTypeName(var(w2)) = myArray Then GoTo jmp147811
         Set pppp = var(w2)
         If pppp.Arr Then GoTo jmp147811
         If Not pppp.ItemType(-1) = mProp Then GoTo jmp147811
         Set bstackstr.lastobj = pppp.GroupRef
        Else
        If Not VarTypeName(var(w2)) = mProp Then GoTo jmp147811
        Set bstackstr.lastobj = var(w2)
        End If
            r$ = vbNullString
            strFunctions = FastSymbol(A$, ")", True)
            Exit Function
                
        Else
jmp147811:
        MyErMacro A$, "Expected a property name", "пЕЯъЛЕМА ЭМОЛА ИДИЭТГТАР"
        End If
Exit Function
fstr65:
    If IsStrExp(bstackstr, A$, q$, False) Then
        strFunctions = True
        r$ = Tcase(q$)
    End If
        If Not FastSymbol(A$, ")") Then strFunctions = False
    Exit Function
    

End Function
Function mEval(ByVal q$, bstackstr As basetask, A$, r$) As Boolean
    Dim myGroup As Group, usehandler As mHandler, w2 As Long, w3 As Long
    Dim p, pp, dd As Long, anything As Object, s$, pppp As mArray
    If IsExp(bstackstr, A$, p) Then
    If MemInt(VarPtr(p)) = vbString Then
        If bstackstr.lastobj Is Nothing Then
    
        q$ = p: GoTo g19383
        End If
    End If
    If bstackstr.lastobj Is Nothing Then Exit Function
    If TypeOf bstackstr.lastobj Is mHandler Then
    
        Set usehandler = bstackstr.lastobj
        Set anything = usehandler
        If usehandler.IamEnum Then
            r$ = usehandler.index_cursor
            Set bstackstr.lastobj = Nothing
            mEval = FastSymbol(A$, ")", True)
            Exit Function
        ElseIf Not CheckLastHandlerOrIterator(anything, dd) Then
            InternalError
            mEval = False
            Exit Function
        End If
        Set usehandler = anything
        With usehandler
            If .T1 = 1 Then
                If FastSymbol(A$, ",") Then
                    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                        p = MyRound(p)
                        If Abs(p) < .objref.count Then
                            If p < 0 Then
                            .objref.Index = .objref.count + MyRound(p)
                            Else
                            .objref.Index = MyRound(p)
                            End If
                            .objref.Done = True
                            r$ = .objref.KeyToString
                        Else
                            MyErMacroStr A$, "Index out of limits", "дЕъЙТГР ЕЙТЭР ОЯъЫМ"
                            mEval = False
                            Exit Function
                        End If
                    Else
                        MissPar
                    End If
                ElseIf .objref.Done Or dd >= 0 Then
                    If dd >= 0 Then
                        .objref.Index = dd
                        .objref.Done = True
                    End If
                    If FastSymbol(A$, "!") Then
                        r$ = .objref.KeyToString
                        Set bstackstr.lastobj = Nothing
                    Else
                        If .objref.IsObj Then
                            rValue bstackstr, usehandler.objref.ValueObj
                            r$ = vbNullString
                        Else
                            Set bstackstr.lastobj = Nothing
                            r$ = CStr(.objref.Value)
                        End If
                    End If
                End If
            ElseIf .T1 = 4 Then
                If dd = -1 Then .objref.Index = .index_start
                r$ = .objref.KeyToString()
                Set bstackstr.lastobj = Nothing
            Else ' IS A MEMBLOCK
                Set bstackstr.lastobj = Nothing
                If FastSymbol(A$, ",") Then
                    If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                        pp = p
                        If FastSymbol(A$, "!") Then
                            If FastPureLabel(A$, s$, , True) Then
                                If .objref.UseStruct Then
                                    If .objref.structref.Find(s$) Then
                                        pp = .objref.structref.sValue
                                        w2 = cUlng(uintnew(.objref.GetPtr(p)) + .objref.structref.StructOffset)
                                        If FastSymbol(A$, "!") Then
                                            If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                                                w2 = cUlng(uintnew(w2) + MyRound(p) * Abs(pp))
                                            End If
                                        End If
                                    Else
                                        MyErMacroStr A$, "Unknown variable " + s$, "╒ЦМЫСТГ ЛЕТАБКГТч " + s$
                                        Exit Function
                                    End If
                                Else
                                    MyErMacroStr A$, "no structure exist", "ДЕМ УПэЯВЕИ ДОЛч"
                                    Exit Function
                                End If
                            Else
                                w2 = .objref.GetBytePtr(p)
                            End If
                        Else
                            w2 = .objref.GetPtr(p)
                        End If
                        If .objref.status = 4 Then
                        MyEr "Buffer locked, wrong use of pointer", "г дИэЯХЯЫСГ ЙКЕИДЧХГЙЕ, ЙАЙч ВЯчСГ ДЕъЙТГ": Exit Function
                        End If
                        dd = 2 + (AscW(q$) < 128)
                        If FastSymbol(A$, ",") Then
                            If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                                ' NOW WE KNOW HOW MANY BYTES WE TAKE (ALWAYS BYTES)
                                p = MyRound(p)
                                If .objref.ValidArea(w2, p) Then
                                    If p Mod 2 = 1 Then
                                        r$ = StrConv(String(p, Chr(0)), vbFromUnicode)
                                    Else
                                        r$ = String$((p + 1) \ 2, Chr(0))
                                    End If
                                    CopyBytes CLng(p), StrPtr(r$), w2
                                Else
                                    MyErMacroStr A$, "Buffer is small, can't get so many bytes", "г дИэЯХЯЫСГ ЕъМАИ ЛИЙЯч, ДЕМ ЛПОЯЧ МА ПэЯЫ ТЭСА ЬГЖъА"
                                End If
                            Else
                                MissPar
                                mEval = False
                                Exit Function
                            End If
                        ElseIf IsLabelSymbolNew(A$, "ыс", "AS", dd) Then
                        w2 = .objref.GetBytePtr(p)
                        If IsLabelSymbolNew(A$, "цяалла", "STRING", dd) Then
                            CopyBytes 4, VarPtr(w3), w2
                             dd = .objref.GetStringFromOffset(w2, r$)
                            If w3 <> dd Then
                                    MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                                    mEval = False
                                    Exit Function
                            End If

                        ElseIf IsLabelSymbolNew(A$, "ваяайтгяес", "UNICODE", dd) Then
                        w2 = .objref.GetBytePtr(p)
                        CopyBytes 4, VarPtr(w3), w2
                        If w3 > &H100000 Then
                        r$ = GetBStrFromBstrPtr(w3)
                        Else
                            MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                            mEval = False
                            Exit Function
                        End If
                        ElseIf IsLabelSymbolNew(A$, "топийо", "LOCALE", dd) Then
                        w2 = .objref.GetBytePtr(p)
                        CopyBytes 4, VarPtr(w3), w2
                        If w3 > &H100000 Then
                            If IsExp(bstackstr, A$, p, flatobject:=True, nostring:=True) Then
                                    If GetCodePage(CLng(Fix(p))) = 0 Then
                                        NoValidLocale
                                        Exit Function
                                    End If
                                r$ = Convert3(Convert2(GetBStrFromPtr(w3, True), LCID_DEF), CLng(Fix(p)))
                            Else
                                r$ = Convert3(Convert2(GetBStrFromPtr(w3, True), LCID_DEF), Clid)
                                End If
                            Else
                                MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                                mEval = False
                                Exit Function
                            End If
                        End If
                    Else
                        If .objref.WhatIsBasicItem = vbString Or pp < 0 Then
                            CopyBytes 4, VarPtr(w3), w2
                            dd = .objref.GetStringFromOffset(w2, r$)
                            If w3 <> dd Then
                                If dd = 0 Then
                                    r$ = vbNullString
                                Else
                                    ' extreme change with Fast ! in console or in code using Set Fast !
                                    If extreme Then
                                        ' unsafe may crash
                                        r$ = GetBStrFromBstrPtr(w3)
                                    Else
                                        MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                                        mEval = False
                                        Exit Function
                                    End If
                                    End If
                                End If
                            Else
                                p = .objref.SizeByte - pp * 2
                                If .objref.SizeByte Mod 2 = 1 Then
                                    r$ = StrConv(String$(.objref.SizeByte - pp * 2, Chr(0)), vbFromUnicode)
                                Else
                                    r$ = String$((.objref.SizeByte - pp * 2 + 1) \ 2, Chr(0))
                                End If
                                CopyBytes CLng(p), StrPtr(r$), w2
                            End If
                        End If
                        mEval = FastSymbol(A$, ")") And .objref.status = 0
                        Exit Function
                    Else
                        MissPar
                        mEval = False
                        Exit Function
                    End If
                    
                Else  ' elval$(alfa)  'copy entire block to r$
                    If .objref.SizeByte > 0 And .objref.status = 0 Then
                        'r$ = String$((.objref.SizeByte + 1) \ 2, Chr(0))
                        r$ = StrConv(String$(.objref.SizeByte, Chr(32)), vbFromUnicode)
                        CopyBytes .objref.SizeByte, StrPtr(r$), .objref.GetPtr(0)
                    Else
                        r$ = vbNullString
                    End If
                End If
            End If
            mEval = FastSymbol(A$, ")", True)
            Exit Function
        End With
        Set anything = Nothing
    ElseIf Typename(bstackstr.lastobj) = "VarItem" Then
                   mEval = FastSymbol(A$, ")", True)
                Exit Function
ElseIf Not bstackstr.lastpointer Is Nothing Then
getgroup:
If TypeOf bstackstr.lastobj Is Group Then
            If Not bstackstr.lastpointer.IamApointer Then Set bstackstr.lastpointer = bstackstr.lastobj
            Set bstackstr.lastobj = Nothing
            If bstackstr.lastpointer.link.IamFloatGroup Then
                Set pppp = New mArray
                pppp.PushDim 1
                pppp.PushEnd
                pppp.Arr = True
                Set pppp.item(0) = bstackstr.lastpointer
                Set bstackstr.lastpointer = Nothing
                If pppp.item(0).link.HasParameters Then Mid$(A$, 1, 1) = "("
                    mEval = SpeedGroup(bstackstr, pppp, "VAL$", "", A$, 0) = 1
                    r$ = bstackstr.LastValue
                    If Not pppp.item(0).link.HasParameters Then mEval = FastSymbol(A$, ")", True)
                        Exit Function
                    Else
                        If lookOne(A$, ",") Then
                            Mid$(A$, 1, 1) = Chr(1)
                            If IsStr1(bstackstr, A$, r$) Then
                                mEval = True  '??? something wrong??
                                Exit Function
                            End If
                        ElseIf IsStr1(bstackstr, Chr$(0) + "$'", r$) Then
                            mEval = FastSymbol(A$, ")", True)
                            Set anything = Nothing
                            Exit Function
                        End If
                    End If
                End If
            End If
            MissParam A$
        Else
            dd = 1
            q$ = aheadstatus(A$, False, dd)
            q$ = Left$(A$, dd)
            
    If CheckGroupOrPointer(bstackstr, (q$), myGroup, Nothing, (0)) Then
        If myGroup Is Nothing Then
        ElseIf Not myGroup.IamApointer Then
                A$ = Mid$(A$, dd)
                Set pppp = New mArray
                pppp.PushDim 1
                pppp.PushEnd
                pppp.Arr = True
                Set pppp.item(0) = myGroup
                If myGroup.HasParameters Then
                    If Left$(A$, 1) <> ")" Then
                        Mid$(A$, 1, 1) = "("
                    Else
                        mEval = SpeedGroup(bstackstr, pppp, "VAL$", "", "", 0) = 1
                        r$ = bstackstr.LastValue
                        mEval = FastSymbol(A$, ")", True)
                        Exit Function
                    End If
                End If
                mEval = SpeedGroup(bstackstr, pppp, "VAL$", "", A$, 0) = 1
                r$ = bstackstr.LastValue
                If Not myGroup.HasParameters Then mEval = FastSymbol(A$, ")", True)
                Exit Function
            Else
            A$ = Mid$(A$, dd + 1)
            GoTo getgroup
            End If
           
    Else
conthere1111:
        If IsStrExp(bstackstr, A$, q$, False) Then
g19383:
            If FastSymbol(A$, ".") Then
                If lookOne(A$, ")") Then
                    A$ = q$ + A$
                Else
                    A$ = q$ + "." + A$
                End If
                If Not IsStrExp(bstackstr, A$, r$, False) Then
                    mEval = False: Exit Function
                End If
            ElseIf CheckGroupOrPointer(bstackstr, (q$), myGroup, Nothing, (0)) Then
            
            If myGroup.HasParameters Then
            Mid$(A$, 1, dd + 1) = " "
            s$ = BlockParam(A$)
            
            Mid$(A$, 1, Len(s$)) = space(Len(s$))
                If Right$(q$, 1) <> "$" Then
                If IsStrExp(bstackstr, q$ + "$(" + s$ + ")", r$) Then
                mEval = FastSymbol(A$, ")", True)
                Exit Function
                End If
                Else
                If IsStrExp(bstackstr, q$ + "(" + s$ + ")", r$) Then
                mEval = FastSymbol(A$, ")", True)
                Exit Function
                End If
                End If
            Else
                If IsStrExp(bstackstr, q$ + "$'", r$) Then
                mEval = FastSymbol(A$, ")", True)
                End If
                Exit Function
            End If
           
            Else
            r$ = q$
            mEval = FastSymbol(A$, ")", True)
            Exit Function
            End If
            
         Else
            r$ = vbNullString
        End If
    End If
End If
mEval = FastSymbol(A$, ")", True)

End Function
Public Function IsLabelDotSub(where$, A$, rrr$, r$, Lang As Long, Optional P1 As Integer = 0) As Long
    ' for left side...no &
    Dim rr&, one As Boolean, br As Integer, c$, firstdot$, gr As Boolean
    rrr$ = vbNullString
    r$ = vbNullString
    Dim I&, L As Long, p3 As Integer
    Dim P2 As Long, p4 As Long  '', excludesp As Long
    L = Len(A$): If L = 0 Then IsLabelDotSub = 0: Lang = 1: Exit Function
    P2 = StrPtr(A$): L = L - 1
    p4 = P2 + L * 2
    For I = P2 To p4 Step 2
        GetMem2 I, P1
        Select Case P1
        Case 13
            If I < p4 Then
                GetMem2 I + 2, p3
                If p3 = 10 Then
                    IsLabelDotSub = 1234
                    If I + 6 > p4 Then
                        A$ = vbNullString
                    Else
                        I = I + 4
                        Do While I < p4
                            GetMem2 I, P1
                            If P1 = 32 Or P1 = 160 Or P1 = 9 Then
                                I = I + 2
                            Else
                                GetMem2 I + 2, p3
                                If P1 <> 13 And p3 <> 10 Then Exit For
                                I = I + 4
                            End If
                        Loop
                        A$ = Mid$(A$, (I + 2 - P2) \ 2)
                    End If
                Else
                    If I > P2 Then A$ = Mid$(A$, (I - 2 - P2) \ 2)
                End If
            Else
                If I > P2 Then A$ = Mid$(A$, (I - 2 - P2) \ 2)
            End If
            Lang = 1
            Exit Function
        Case 0 To 7, 32, 160, 9
        Case 8
            IsLabelDotSub = 8: Exit Function
        Case Else
            Exit For
        End Select
    Next I
    If I > p4 Then A$ = vbNullString: IsLabelDotSub = 0: Exit Function
    For I = I To p4 Step 2
        GetMem2 I, P1
        If P1 < 256 Then
            Select Case P1
            Case 0 To 6
                ' no chars
            Case 7
                If I + 2 <= p4 Then
                    GetMem2 I + 2, P1
                    Select Case P1
                    Case 61, 40
                        If Len(r$) > 1 Then r$ = Left$(r$, Len(r$) - 1)
                    End Select
                End If
            Case 64  '"@"
                    If I < p4 And r$ <> "" Then
                        GetMem2 I + 2, P1
                        If ChrW(P1) <> "(" Then
                            where$ = myUcase(r$, gr)
                            r$ = vbNullString
                            rrr$ = vbNullString
                        Else
                            IsLabelDotSub = 0: A$ = firstdot$ + Mid$(A$, (I - P2) \ 2): Exit Function
                        End If
                    Else
                        If LenB(r$) = 0 And I < p4 Then
                            r$ = r$ + "@"
                        Else
                            IsLabelDotSub = 0: A$ = vbNullString: Exit Function
                        End If
                    End If
            Case 63 '"?"
                    If r$ = vbNullString And firstdot$ = vbNullString Then
                        rrr$ = "?"
                        r$ = rrr$
                        I = I + 4
                        A$ = Mid$(A$, (I - P2) \ 2)
                        IsLabelDotSub = 1
                        Lang = -1
                        Exit Function
                    ElseIf firstdot$ = vbNullString Then
                        IsLabelDotSub = 1
                        Lang = 1 + CLng(gr)
                        If Lang = 1 Then
                            rrr$ = UCase(r$)
                        Else
                            rrr$ = myUcase(r$)
                        End If
                        A$ = Mid$(A$, (I + 2 - P2) \ 2)
                        Exit Function
                    Else
                        IsLabelDotSub = 0
                        A$ = Mid$(A$, (I + 2 - P2) \ 2)
                        Exit Function
                    End If
            Case 46 '"."
                If one Then
                    Exit For
                ElseIf r$ <> "" And I < p4 Then
                    GetMem2 I + 2, P1
                    If ChrW(P1) = "." Or ChrW(P1) = " " Then
                        If ChrW(P1) = "." And I + 2 < p4 Then
                            GetMem2 I + 4, P1
                            If ChrW(P1) = " " Then I = I + 4: Exit For
                        Else
                            I = I + 2
                            Exit For
                        End If
                    End If
                    GetMem2 I, P1
                    r$ = r$ & ChrW(P1)
                    rr& = 1
                Else
                    firstdot$ = firstdot$ + "."
                End If
            Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
                Exit For
            Case 48 To 57, 95 '"0" To "9", "_"
                If one Then
                    Exit For
                ElseIf r$ <> "" Then
                    r$ = r$ + ChrW(P1)
                    rr& = 1 'is an identifier or floating point variable
                Else
                    Exit For
                End If
            Case 91
                If Len(r$) > 0 Then
                    If Len(r$) = 1 Then
                        If r$ <> "[" Then
                            rr& = 10
                            Exit For
                        End If
                    ElseIf Right$(r$, 1) <> "." Then
                        If Right$(r$, 1) <> ChrW(&HFFBF) Then
                            If Left$(r$, 1) <> "[" Then
                                rr& = 10 ' for EXECUTE only
                                Exit For
                            End If
                        End If
                    End If
                    br = br + 1
                    r$ = r$ + "["
                Else
                    r$ = "["
                    br = 1
                    rr& = 1 'is an identifier
                End If
            Case 93
                If Len(r$) = 0 Then Exit For
                If br > 0 Then
                    br = br - 1
                    r$ = r$ + "]"
                Else
                    Exit For
                End If
            Case Is < 0, Is > 64 ' >=A and negative
                If one Then
                    Exit For
                Else
                    r$ = r$ + ChrW(P1)
                    rr& = 1 'is an identifier or floating point variable
                End If
            Case 36 ' "$"
                If one Then Exit For
                If r$ <> "" Then
                one = True
                rr& = 3 ' is string variable
                r$ = r$ & ChrW(P1)
                Else
                Exit For
                End If
            Case 37 ' "%"
                If one Then Exit For
                If r$ <> "" Then
                one = True
                rr& = 4 ' is long variable
                r$ = r$ & ChrW(P1)
                Else
                Exit For
                End If
            Case 40 '"("
                If r$ <> "" Then
                    If I + 4 <= p4 Then
                        GetMem2 I + 2, P1
                        GetMem2 I + 2, p3
                        If ChrW(P1) + ChrW(p3) = ")@" Then
                            r$ = r$ & "()."
                            I = I + 4
                        Else
                            GoTo i123
                        End If
                    Else
i123:
                        Select Case rr&
                        Case 1
                            rr& = 5 ' float array or function
                        Case 3
                            rr& = 6 'string array or function
                        Case 4
                            rr& = 7 ' long array
                        Case Else
                            Exit For
                        End Select
                        GetMem2 I, P1
                        r$ = r$ & ChrW(P1)
                        I = I + 2
                        Exit For
                     End If
                Else
                    Exit For
                End If
            Case Else
                Exit For
            End Select
        Else
            If one Then
                Exit For
            Else
                gr = True
                r$ = r$ + ChrW(P1)
                rr& = 1 'is an identifier or floating point variable
            End If
        End If
    Next I
    If I > p4 Then
        A$ = vbNullString: P1 = 0
    Else
        If (I + 2 - P2) \ 2 > 1 Then A$ = Mid$(A$, (I + 2 - P2) \ 2)
    End If
    rrr$ = firstdot$ + myUcase(r$, gr)
    Lang = 1 + CLng(gr)
    IsLabelDotSub = rr&
End Function
Private Sub Assign(ss$, p)
        Select Case MemInt(VarPtr(p))
        Case vbString
            SwapString2Variant ss$, p
        Case vbBoolean
            ss$ = Format$(p, DefBooleanString)
        Case 20
            ss$ = CStr(p)
        Case vbDate
            ss$ = p
        Case 36
        If TypeOf p Is cxComplex Then
            ss$ = fixthis(p)
        Else
            ss$ = "*" + Typename(p)
        End If
        Case 9, 13
            ss$ = "*" + Typename(p)
        Case Else
            ss$ = fixthis(p)
        End Select
End Sub
Private Function fixthis(p As Variant) As String
        If TypeOf p Is cxComplex Then
            If p.I = 0 Then
                fixthis = fixthis(CVar(p.r))
            ElseIf p.r = 0 Then
                fixthis = "(" & fixthis(CVar(p.I)) & "i)"
            Else
            If p.I < 0 Then fixthis = "" Else fixthis = "+"
            If Abs(p.I) = 1 Then
                If p.I < 0 Then
                    fixthis = "(" & fixthis(CVar(p.r)) & "-i)"
                Else
                    fixthis = "(" & fixthis(CVar(p.r)) & "+i)"
                End If
            Else
                fixthis = "(" & fixthis(CVar(p.r)) & fixthis & fixthis(CVar(p.I)) & "i)"
            End If
            End If
        Else
            fixthis = LTrim$(str(p))
            If Left$(fixthis, 1) = "." Then
            fixthis = "0" + fixthis
            ElseIf Left$(fixthis, 2) = "-." Then
            fixthis = "-0" + Mid$(fixthis, 2)
            End If
            If InStr(fixthis, ".") > 0 Then
            If NoUseDec Then fixthis = Replace(fixthis, ".", NowDec$)
            End If
        End If
End Function
Function AddGroupFromClass(bstack As basetask, rest$, className$, isglobal As Boolean, islocal As Boolean, ohere$) As Boolean
Dim I As Long, W$, v As Long, useType As Boolean, r, part$, ret As Boolean, exist As Boolean, ww$, ss$
Dim isStruct As Boolean, useBuffer As MemBlock, usehandler As mHandler, usehandlerBuffer As mHandler, j As Long

Dim structLen As Long
If GetVar3(bstack, bstack.GroupName + className$, v) Then
    If IsExp(bstack, bstack.GroupName + className$, r) Then
        If Not bstack.lastobj Is Nothing Then
            GoTo Checkit
        End If
End If
ElseIf GetVar3(bstack, bstack.GroupName + className$, v) Then
    If IsExp(bstack, (className$), r) Then
        If Not bstack.lastobj Is Nothing Then
Checkit:
        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
            Set bstack.lastobj = Nothing
            If usehandler.T1 = 1 And usehandler.ReadOnly Then
            If TypeOf usehandler.objref Is FastCollection Then
                If Not usehandler.objref.structLen = 0 Then
                    isStruct = True
                Else
                    MyEr "Zero Length Structure", "лГДЕМИЙОЩ лчЙОУР дОЛч"
                    Exit Function
                End If
            End If
            End If
        End If
        End If
    End If
Else

'Exit Function
End If
Do
exist = False
useType = False
'I = IsLabelA(here$, rest$, W$)
I = IsLabelAnew("", rest$, W$, (0&))
If Len(rest$) = 0 Then
If I = 0 Then SyntaxError: Exit Function
End If
AddGroupFromClass = True
If isStruct Then
If I = 1 Or I = 8 Then
If I = 8 Then
    Mid$(rest$, 1, 1) = " "
    If Not IsExp(bstack, rest$, r) Then
    
    End If
    If Not Left$(rest$, 1) = "]" Then
    
    End If
    Mid$(rest$, 1, 1) = " "
Else
r = 1
End If
If r < 1& Then r = 1&
    If isglobal Or islocal Then
        GoTo CONTGLO
    ElseIf GetVar(bstack, bstack.GroupName + W$, I, , , True, ww$, useType) Then
        If Typename(var(I)) = "mHandler" Then
            Set usehandlerBuffer = var(I)
            If usehandlerBuffer.T1 = 2 And Not usehandlerBuffer.ReadOnly Then
                Set useBuffer = usehandlerBuffer.objref
                If useBuffer.structref Is Nothing Then
                    
                ElseIf useBuffer.structref Is usehandler.objref Then
                v = useBuffer.items
                If v <> r Then
                
                ret = useBuffer.items < r
                useBuffer.ResizeItems CLng(r)
                ' fill zero
                If ret Then
                    Dim K() As Byte
                    ReDim K(useBuffer.ItemSize) As Byte
                    For I = v To CLng(r) - 1&
                        j = useBuffer.GetPtr(v)
                        If j > 0 Then
                        CopyMemory ByVal j, ByVal VarPtr(K(0)), useBuffer.ItemSize
                        End If
                    Next I
                End If
                End If
                    GoTo cont111
                ElseIf useBuffer.structref.Tag = usehandler.objref.Tag Then
                    GoTo cont111
                End If
            End If
        End If
        WrongType
        Exit Function
    Else
CONTGLO:
    
        I = globalvar(bstack.GroupName + W$, Empty, , isglobal, , True)
        MakeitObjectBuffer var(I)
        Set usehandlerBuffer = var(I)
        Set useBuffer = usehandlerBuffer.objref
        v = usehandler.objref.structLen
        Set useBuffer.structref = usehandler.objref
        useBuffer.UseStruct = True
        Set usehandlerBuffer = Nothing
        useBuffer.ClearError
        useBuffer.Construct v, CLng(r), CLng(8)
        Set useBuffer = Nothing
    End If
cont111:
GoTo loophere

Else
SyntaxError
Exit Function
End If
ElseIf I = 1 Then
part$ = className$ + "()"
ElseIf I = 3 Then
part$ = className$ + "$()"
W$ = Left$(W$, Len(W$) - 1)
ElseIf I = 5 Then
W$ = Left$(W$, Len(W$) - 1)
part$ = className$ + "("
ElseIf I = 6 Then
W$ = Left$(W$, Len(W$) - 2)
part$ = className$ + "$("
Else
SyntaxError
AddGroupFromClass = False
Exit Function
End If

    If isglobal Or islocal Then
        GoTo CONTGLO1
    ElseIf GetVar(bstack, bstack.GroupName + W$, v, True, , , ww$, useType) Then
    If Typename(var(v)) <> "Group" Then
        WrongType
        AddGroupFromClass = False
        Exit Function
    End If
    If useType Then
        Dim mm As Group
        Set mm = var(v)
        If Not mm.TypeGroup(className$) Then
            WrongType
            AddGroupFromClass = False
            Exit Function
        End If
    End If
    exist = True
Else
CONTGLO1:
If I = 1 Then
    v = globalvar(bstack.GroupName + W$, 0, , here$ = "", , True)
    Else
    v = globalvar(bstack.GroupName + W$, 0, , here$ = "", , True)
    'ret = globalvar(bstack.GroupName + W$, (v), True, here$ = "", , True)
    End If
End If
If I = 1 Then
    If lookOne(rest$, "=") Then
    ret = IsExp(bstack, part$, r)
    Else
    bstack.tmpstr = part$ + Left$(rest$, 1)
    BackPort rest$
    ret = IsExp(bstack, rest$, r)
    End If
ElseIf I = 3 Then
    If lookOne(rest$, "=") Then
    ret = IsStrExp(bstack, (part$), ss$)
    If Not ret Then
    ret = IsExp(bstack, className$ + "()", r)
    End If
    Else
    bstack.tmpstr = part$ + Left$(rest$, 1)
    BackPort rest$
    ret = IsStrExp(bstack, rest$, ss$)
    If ret = False Then
    bstack.tmpstr = className$ + "()" + Left$(rest$, 1)
    BackPort rest$
    ret = IsExp(bstack, rest$, r)
    End If
    End If
ElseIf I = 5 Then
    bstack.tmpstr = part$ + Left$(rest$, 1)
    BackPort rest$
    ret = IsExp(bstack, rest$, r)
ElseIf I = 6 Then
    bstack.tmpstr = part$ + Left$(rest$, 1)
    BackPort rest$
    ret = IsStrExp(bstack, rest$, ss$)
Else
WrongType
Exit Function
End If
If isglobal Or islocal Then exist = False
If ret Then
    If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is Group Then
            Set mm = bstack.lastobj
            Set bstack.lastobj = Nothing
            If useType Then
                If Not mm.TypeGroup(className$) Then
                WrongType
                AddGroupFromClass = False
                Exit Function
                End If
            End If
            If exist Then
 
                    ss$ = bstack.GroupName
                    If ww$ <> "" Then W$ = ww$
                    If Len(var(v).GroupName) > Len(W$) Then
                        Dim sw$
                            sw$ = here$
                            here$ = vbNullString
                            UnFloatGroupReWriteVars bstack, var(v).Patch, v, mm
                            here = sw$
                            mm.ToDelete = True
                        Else
                            bstack.GroupName = Left$(W$, Len(W$) - Len(var(v).GroupName) + 1)
                            If Len(var(v).GroupName) > 0 Then
                                W$ = Left$(var(v).GroupName, Len(var(v).GroupName) - 1)
                                sw$ = here$
                                here$ = vbNullString
                                UnFloatGroupReWriteVars bstack, W$, v, mm
                                here = sw$
                                mm.ToDelete = True
                            ElseIf var(v).IamApointer Then
                                WrongType
                                Exit Function
                            Else
                                Set mm = Nothing
                                bstack.GroupName = ss$
                                If var(v).IamApointer Then
                                    UseArrow
                                Else
                                    GroupWrongUse
                                End If
                                Exit Function
                            End If
                        End If
                        bstack.GroupName = ss$
                        Set mm = Nothing
            
            Else
            mm.ToDelete = True
            UnFloatGroup bstack, W$, v, mm, here$ = "" Or isglobal, myVarType(var(v), vbEmpty), islocal           ' global??
            If Len(bstack.UseGroupname) <> 0 Then
                var(v).IamRef = True
                If here$ <> "" Then globalvar W$, CVar(v), True, True
               
            End If
            End If
            Set mm = Nothing
            If lookOne(rest$, "=") Then
                If I = 3 Then
                    ExecuteVar I, (I), bstack, W$ + "$", rest$, v, 1, isglobal, islocal, 0, "", 0, ohere$, True
                Else
                    ExecuteVar I, (I), bstack, W$, rest$, v, 1, isglobal, islocal, 0, "", 0, ohere$, True
                End If
            End If
        End If
        Set bstack.lastobj = Nothing
    End If
Else
    WrongType
End If
loophere:
Loop Until Not FastSymbol(rest$, ",")
className$ = ""
End Function
Function chektype1(bstack As basetask, b$, Lang As Long) As Integer
chektype1 = 1
If IsLabelSymbolNew(b$, "дипкос", "DOUBLE", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbDouble, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "айеяаиос", "INTEGER", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbInteger, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "лайяус", "LONG", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbLong, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "апкос", "SINGLE", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbSingle, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "коцийос", "BOOLEAN", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbBoolean, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "аяихлос", "DECIMAL", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbDecimal, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "коцистийос", "CURRENCY", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbCurrency, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "цяалла", "STRING", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbString, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "атупос", "VARIANT", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbVariant, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "олада", "GROUP", Lang) Then
If Not ProcGroup(-1, bstack, b$, Lang) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "ьгжио", "BYTE", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbByte, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "ANTIKEIMENO", "OBJECT", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbObject, True) Then Exit Function
ElseIf IsLabelSymbolNew(b$, "лецакосайеяаиос", "BIGINTEGER", Lang) Then
If Not MyAnyType(bstack, b$, Lang, here$ = "", vbObject, here$ = "", New BigInteger) Then Exit Function
Else
chektype1 = 2
End If

End Function
Function TakeOffset(bstack As basetask, usehandler As mHandler, b$, r, Optional where, Optional NewVal) As Boolean
' just throw offsets
Dim thisHandler As mHandler, useBuffer As MemBlock, otherBuffer As MemBlock, mylist As FastCollection, pp As Long, p As Variant
Dim rB As Byte, ri As Integer, dn As Long, db As Double, ds As Single, w2 As Long, s$
Dim itisSingle As Boolean, itisInt64 As Boolean, itisCur As Boolean
Dim I As Long
Set useBuffer = usehandler.objref
If Not useBuffer.UseStruct Then
pp = useBuffer.ItemSize
    If pp = 4 Then
        itisSingle = useBuffer.WhatIsBasicItem = vbSingle
    ElseIf pp = 8 Then
        itisInt64 = useBuffer.WhatIsBasicItem = 20
        itisCur = useBuffer.WhatIsBasicItem = vbCurrency
    End If
    p = (-OneLongLong And useBuffer.GetPtr(where))
    w2 = MemLong(VarPtr(p) + 8)
    If Not IsMissing(NewVal) Then
    SwapVariant r, p
    r = 0
    If Not bstack.lastobj Is Nothing Then
    If TypeOf bstack.lastobj Is mHandler Then
        Set thisHandler = bstack.lastobj
        If thisHandler.T1 = 2 Then
        Set otherBuffer = thisHandler.objref
        If useBuffer.ValidArea(w2, otherBuffer.SizeByte) Then
            CopyBytes otherBuffer.SizeByte, w2, otherBuffer.GetPtr(0)
            TakeOffset = True
            Exit Function
        Else
           MyEr "this buffer not fit", "ДЕМ ВЫЯэЕИ СТГ ДИэЯХЯЫСГ"
           Exit Function
        End If
        End If
    End If
    End If
    End If
    GoTo contthere

End If
Set mylist = useBuffer.structref
Dim W$, back$
If Left$(b$, 1) = "|" Or IsMissing(NewVal) Then
Mid$(b$, 1, 1) = " "
jumpagain:
I = IsLabelAnew("", b$, W$, (0&))
If I = 1 Or I = 8 Then
If mylist.Find(W$) Then
    pp = Abs(mylist.sValue)
    If pp = 4 Then
        itisSingle = mylist.KeyTypeValue = vbSingle
    ElseIf pp = 8 Then
        itisInt64 = mylist.sValue < 0
        itisCur = mylist.KeyTypeValue = vbCurrency
        
    End If
    If w2 = 0 Then
    With useBuffer
    
    If Not IsMissing(where) Then
        p = (-OneLongLong And .GetPtr(where)) + mylist.StructOffset
    Else
        p = (-OneLongLong And .GetPtr(0&)) + mylist.StructOffset
    End If
    End With
    w2 = MemLong(VarPtr(p) + 8)
    End If
    pp = Abs(pp)
    If I = 8 Then
    
    Mid$(b$, 1, 1) = " "
    
    
    If Not IsExp(bstack, b$, p, , True) Then
     If Left$(b$, 1) = "]" Then
        Mid$(b$, 1, 1) = " "
        Set otherBuffer = New MemBlock

        
        If Not mylist.StructObj Is Nothing Then
        ' WE HAVE A SUB STRUCT
        otherBuffer.Construct pp, mylist.StructMany, , , CLng(r)
        Set otherBuffer.structref = mylist.StructObj
        otherBuffer.UseStruct = True
        Else
            If itisInt64 Then
            r = 20
        ElseIf itisCur Then
            r = vbCurrency
        ElseIf itisSingle Then
            r = vbSingle
        End If
        End If
        otherBuffer.Construct pp, mylist.StructMany, , , CLng(r)
        CopyMemory ByVal otherBuffer.GetPtr(0), ByVal w2, pp * mylist.StructMany
        r = 0
        Set thisHandler = New mHandler
        thisHandler.T1 = 2
        Set thisHandler.objref = otherBuffer
        Set bstack.lastobj = thisHandler
        TakeOffset = True
        
    End If
    Exit Function
    End If
    p = CLng(p)
    If mylist.StructMany <= p Or p < 0 Then
    MyEr "index out of limit for items of " + mylist.KeyToString, "О ДЕъЙТГР ЕъМАИ ЕЙТЭР ОЯъЫМ ЦИА ТО " + mylist.KeyToString
    TakeOffset = False
    Exit Function
    End If
    
    p = w2 + (-OneLongLong And p) * pp
    w2 = MemLong(VarPtr(p) + 8)
    p = 0
    If FastSymbol(b$, ",") Then
    If Not IsExp(bstack, b$, p, , True) Then Exit Function
        pp = Abs(p)
        If pp < 1 Then
        r = ""
        If Not useBuffer.ValidArea(w2, 0&) Then
            MyEr "wrong offset and width for string", "КэХОР ТО ЕПИПКщОМ ЙАИ ТО ЛчЙОР ЦИА АКЖАЯИХЛГТИЙЭ"
        Else
            TakeOffset = True
        End If
        Exit Function
        End If
        If pp Mod 2 = 1 Then
            s$ = StrConv(String(pp, Chr(0)), vbFromUnicode)
        Else
            s$ = String$((pp + 1) \ 2, Chr(0))
        End If
        CopyBytes pp, StrPtr(s$), w2
        r = ""
        SwapString2Variant s$, r
        TakeOffset = FastSymbol(b$, "]")
        Exit Function
    ElseIf Not lookOne(b$, "]") Then
        I = IsLabelAnew("", b$, W$, (0&))
        If I = 1 Then
            dn = Abs(Asc(W$) < 128)
            If dn = 1 Then
                I = W$ = "AS"
            Else
                I = W$ = "ыс"
            End If
            b$ = LTrim$(b$)
            If I Then
                If IsLabelSymbolNew(b$, "ьгжио", "BYTE", dn) Then
                    pp = 1
                ElseIf IsLabelSymbolNew(b$, "айеяаиос", "INTEGER", dn) Then
                    pp = 2
                ElseIf IsLabelSymbolNew(b$, "лайяус", "LONG", dn) Then
                    If IsLabelSymbolNew(b$, "лайяус", "LONG", dn) Then
                        pp = 8
                        itisInt64 = True
                    Else
                        pp = 4
                    End If
                ElseIf IsLabelSymbolNew(b$, "дипкос", "DOUBLE", dn) Then
                    pp = 8
                ElseIf IsLabelSymbolNew(b$, "коцистийос", "CURRENCY", dn) Then
                    pp = 8
                    itisCur = True
                ElseIf IsLabelSymbolNew(b$, "апкос", "SINGLE", dn) Then
                    pp = 4
                    itisSingle = True
                Else
                
                
                    SyntaxError
                    Exit Function
                End If
            Else
                SyntaxError
                Exit Function
            End If
        ElseIf I > 0 Then
                SyntaxError
                Exit Function
        End If
    End If
    If Not FastSymbol(b$, "]") Then Exit Function
    End If
    If Not IsMissing(NewVal) Then
    If lookOne(b$, "=") Then
    FastSymbol b$, "="
    If IsExp(bstack, b$, p) Then
        If MemInt(VarPtr(p)) = vbString Then
            SwapVariant p, r
            p = 0
            Set bstack.lastobj = Nothing
            GoTo contthere
        End If
looklastobj:
    If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mHandler Then
            Set thisHandler = bstack.lastobj
            Set bstack.lastobj = Nothing
            If thisHandler.T1 = 2 Then
            Set otherBuffer = thisHandler.objref
            pp = otherBuffer.SizeByte
            If useBuffer.ValidArea(w2, pp) Then
                CopyMemory ByVal w2, ByVal otherBuffer.GetPtr(0), pp
                TakeOffset = True
                Exit Function
            
            End If
            End If
            MyEr "invalid use of buffer", "ЙАЙч ВЯчСГ ДИэЯХЯЫСГР"
            Exit Function
            
        Else
            Set bstack.lastobj = Nothing
            WrongType
            Exit Function
        End If
    End If
    Else
        If IsStrExp(bstack, b$, s$, False) Then
            r = ""
            SwapString2Variant s$, r
            GoTo contthere
        End If
        Exit Function
    End If
    End If
    End If
    If FastSymbol(b$, "|") Then
    If Not mylist.StructObj Is Nothing Then
    Set mylist = mylist.StructObj
    GoTo jumpagain
    End If
    SyntaxError
    Exit Function
    End If
contthere:
    With useBuffer
    If MemInt(VarPtr(r)) = vbString And Not IsMissing(NewVal) Then

        SwapString2Variant s$, r
        If .ValidArea(w2, CVar(LenB(s$))) Then
        CopyMemory ByVal w2, ByVal StrPtr(s$), LenB(s$)
        TakeOffset = True
        Else
        MyEr "string can't fit to buffer", "ДЕМ ВЫЯэЕИ ТО АКЖАЯИХЛГТИЙЭ СТГ ДИэЯХЯЫСГ"
        End If
        
    ElseIf .ValidArea(w2, pp) Then
                
                    Select Case pp
                    Case 1
                        If Not IsMissing(NewVal) Then
                            PutMem1 w2, CByte(LowWord(signlong(p)) And &HFF)
                        Else
                        GetMem1 w2, rB
                        r = CCur(rB)
                        End If
                        TakeOffset = True
                    Case 2
                        If Not IsMissing(NewVal) Then
                            PutMem2 w2, cUint(LowWord(signlong(p)))
                        Else
                        GetMem2 w2, ri
                        r = CCur(UINT(CLng(ri)))
                        End If
                        TakeOffset = True
                    Case 4
                        If Not IsMissing(NewVal) Then
                                If itisSingle Then
                                        ds = CSng(p)
                                        PutMemS w2, ds
                                Else
                                    PutMem4 w2, signlong(p)
                                End If
                        Else
                            If itisSingle Then
                                GetMemS w2, ds
                                r = ds
                            Else
                                GetMem4 w2, dn
                                r = CCur(uintnew1(dn))
                            End If
                        End If
                        TakeOffset = True
                    Case 8
                    If Not IsMissing(NewVal) Then
                             If itisCur Then
                            MemCur(w2) = CCur(p)
                            ElseIf itisInt64 Or pp < 0 Then
                            p = cInt64(p)
                            CopyMemory ByVal w2, ByVal VarPtr(p) + 8, 8
                            Else
                            PutMem8 w2, p
                            End If
                            TakeOffset = True
                    Else
                        If itisCur Then
                            r = MemCur(w2)
                            TakeOffset = True
                        ElseIf itisInt64 Then
                            r = cInt64(0)
                            CopyMemory ByVal VarPtr(r) + 8, ByVal w2, 8
                            r = CDec(r)
                            If r < 0 Then r = r + maxlonglong
                            TakeOffset = True
                        Else
                        GetMem8 w2, db
                        r = db
                        TakeOffset = True
                            
                        End If
                        
                    End If
                    Case Else
                        If pp Mod 2 = 1 Then
                            s$ = StrConv(String(pp, Chr(0)), vbFromUnicode)
                        Else
                            s$ = String$((pp + 1) \ 2, Chr(0))
                        End If
                        CopyBytes pp, StrPtr(s$), w2
                        r = ""
                        SwapString2Variant s$, r
                        TakeOffset = True
                      
                    
                    ' ????
                    End Select
                End If
    End With
End If
    
    
Else
    Exit Function
End If
Else
If Not IsMissing(NewVal) Then
'If NewVal = 0 Then
If Not IsMissing(where) Then
        p = (-OneLongLong And useBuffer.GetPtr(where))
Else
        p = (-OneLongLong And useBuffer.GetPtr(0&))
End If
w2 = MemLong(VarPtr(p) + 8)
GoTo looklastobj
End If
'End If
End If

End Function

