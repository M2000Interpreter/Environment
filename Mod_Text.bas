Attribute VB_Name = "Module1"
' Author: George Karras, Kallithea Attikis, Greece
' Some code are work of others, and included using info when possible.
' Licensed under the GNU GENERAL PUBLIC LICENSE,  Version 3, 29 June 2007
' Before loading the code in VB6 IDE, change editor's text to a Greek font.
' Also to run greek commands from IDE you have to turn support for Non Unicode Programs to Greek Language
' Local References: File idispatch.tlb
' First run this, and then you have to execute M2000.exe to call it, using a second IDE with the mexe.vbp, or just run M2000.exe
' In 9.3 rev >2 Asc() and Chr$() in M2000 use Locale. In previous versions these functions works for greek ascii.
' In version 10 additional symbols for remarks: //

Option Explicit

Private timestamp As Long
Global OsInfo As New clsOSInfo
Global HaltLevel As Long, errbag As ErrorBag
Global startaddress As Long, stacksize As Long, findstack As Long
Private Const mProp = "PropReference"
Private Const mHdlr = "mHandler"
Private Const mgroup = "Group"
Const a123 = "={-"
Const b123 = vbCr + "'\/"
Const b1234 = vbCr + "'\/:"
Const b12345 = vbCr + "'\/:}"
Const RemChar = "'\/"
Private Const myArray = "mArray"
Const thislabel$ = "[!" + vbCr + "'\//]"
Public rndbase As rndvars, GDILines As Boolean
Public LastUse As Long, cdecimaldot$
Private funcno As Long, ua As Double, UB As Double
Private simplestack1 As rndvars
Private Declare Function ShowCursor Lib "user32" (ByVal bShow As Long) As Long
Private Const lCID_INSTALLED = 1
Public Declare Function IsValidCodePage Lib "kernel32" (ByVal CodePage As Long) As Long
Private Declare Sub GetMem1 Lib "msvbvm60" (ByVal addr As Long, RetVal As Byte)
Public Declare Sub GetMem2 Lib "msvbvm60" (ByVal addr As Long, RetVal As Integer)
Private Declare Sub GetMem4 Lib "msvbvm60" (ByVal addr As Long, RetVal As Long)
Private Declare Sub GetMemS Lib "msvbvm60" Alias "GetMem4" (ByVal addr As Long, RetVal As Single)
Private Declare Sub GetMem8 Lib "msvbvm60" (ByVal addr As Long, RetVal As Double)
Private Declare Sub PutMem1 Lib "msvbvm60" (ByVal addr As Long, ByVal NewVal As Byte)
Public Declare Sub PutMem2 Lib "msvbvm60" (ByVal addr As Long, ByVal NewVal As Integer)
Private Declare Sub PutMem4 Lib "msvbvm60" (ByVal addr As Long, ByVal NewVal As Long)
Private Declare Sub PutMemS Lib "msvbvm60" Alias "PutMem4" (ByVal addr As Long, ByVal NewVal As Single)
Private Declare Sub PutMem8 Lib "msvbvm60" (ByVal addr As Long, ByVal NewVal As Double)
Private Declare Function CopyBytes Lib "msvbvm60.dll" Alias "__vbaCopyBytes" (ByVal ByteLen As Long, ByVal Destination As Long, ByVal Source As Long) As Long
Private Declare Function ObjSetAddRef Lib "msvbvm60.dll" Alias "__vbaObjSetAddref" (ByRef objDest As Object, ByVal pObject As Long) As Long
Public Declare Function IsBadCodePtr Lib "kernel32" (ByVal lpfn As Long) As Long
Private Declare Function GetStringTypeExW Lib "kernel32.dll" (ByVal Locale As Long, ByVal dwInfoType As Long, ByVal lpSrcStr As Long, ByVal cchSrc As Long, ByRef lpCharType As Integer) As Long
Private Declare Function CompareString Lib "kernel32" Alias "CompareStringW" (ByVal Locale As Long, ByVal dwCmpFlags As Long, ByVal lpString1 As Long, ByVal cchCount1 As Long, ByVal lpString2 As Long, ByVal cchCount2 As Long) As Long
Private Declare Function CallWindowProc _
 Lib "user32.dll" Alias "CallWindowProcW" ( _
 ByVal lpPrevWndFunc As Long, _
 ByVal hWnd As Long, _
 ByVal Msg As Long, _
 ByVal wParam As Long, _
 ByVal lParam As Long) As Long
Public NullGroup As New Group
Public Okk As Boolean
Private Declare Sub DisableProcessWindowsGhosting Lib "user32" ()
Public Interrupted As Boolean
Public NoOptimum As Boolean
Dim Zero As basket
 Public Type GenItem
 Key As String
 ndx As String
 firsthash As Long
 lastpos As Long
 Pleft As Long  ' a list
 End Type
' 1 to 32 for layers
' 0 for DIS
Public NowDec$, NowThou$, DefaultDec$
Public ShowBooleanAsString As Boolean, DefBooleanString As String
Public ForLikeBasic As Boolean, DimLikeBasic As Boolean, SecureNames As Boolean, wide As Boolean
Public UseTabInForm1Text1 As Boolean
Public priorityOr As Boolean, NoUseDec As Boolean, mNoUseDec As Boolean, UseIntDiv As Boolean
Public mTextCompare As Boolean
Public csvsep$, csvDec$, csvuseescape As Boolean, cleanstrings As Boolean
Public inpcsvsep$, inpcsvDec$, inpcsvuseescape As Boolean, inpcleanstrings As Boolean
Public Const DisForm = 0
Public Const BackForm = -1
Public Const PrinterPage = -2
Public players(-2 To 1032) As basket  ' tag number not actual number of dsprite()
Public Prefresh(-2 To 1032) As Counters

Private Declare Function GdiFlush Lib "gdi32" () As Long
Public m_bInIDE As Boolean
Public UKEY$
Public TestShowCode As Boolean, TestShowSub As String, TestShowStart As Long, WaitShow As Long
Public TestShowBypass As Boolean
Public feedback$, FeedbackExec$, feednow$ ' for about$
Global Const VerMajor = 11
Global Const VerMinor = 0
Global Const Revision = 4
Private Const doc = "Document"
Public UserCodePage As Long, DefCodePage As Long
Public cLine As String  ' it was public in form1
Public casesensitive As Boolean  ' for filesf
Public userfiles As String
Public TweakLang As Long
Public notweak As Boolean
Public extreme As Boolean
Public taskmainonly As Boolean
Public TaskMain As Boolean

' Directory separator character
Public HelpStack As New basetask ' from 6.5.1

Public REFRESHRATE As Currency
Public RRCOUNTER As Currency
Public BLOCKkey As Boolean
Public Const novalidstr = "+-/*!?_()[]&$#@;" & """"

Public tempList2delete As String
Public nnn$, basickey$, homepage$
Public shortlang As Boolean
Public LEVCOLMENU As Long
 
     

Public taskid As Long, kill2$, para$
Private Declare Function timeGetTime Lib "winmm.dll" () As Long
Public sRec As Object
Public defFontname As String
Public pnum As Long
Public my_system As Enum_OperatingPlatform
Public Declare Function Beeper Lib "kernel32" Alias "Beep" _
  (ByVal dwFreq As Long, ByVal dwDuration As Long) As Long
Public oprinter As New cDIBSection
Public Const MAX_FILENAME_LEN As Long = 260 * 2 - 1
Public beeperBEAT As Long
Public funcdeep As Variant
Public deep As Variant
Private mys As String
Public needset As Boolean
Public cnt As Boolean
Public exWnd As Long

Private Declare Function GetForegroundWindow Lib "user32" () As Long
Public expl As Long

Public l_complete As Boolean
Public s_complete As Boolean
Public ThereIsAPrinter As Boolean
Public MOUT As Boolean
Public DXP As Long
Public DYP As Long
Public SLOW As Boolean
Public pname As String
Public Port As String
Global elevatestatus As Long
Global elevatestatus2 As Long
Public Fkey As Long
Public FK$(1 To 24)
Public strTemp As String
Public STEXIT As Boolean
Public STbyST As Boolean
Public STq As Boolean, bypassST As Boolean
Public pagio$, pagiohtml$
Public subHash As New sbHash
Public varhash As New Hash
Public comhash As New sbHash, numid As New idHash, numidbackup As New idHash, funid As New idHash, funidbackup As New idHash
Public zones As New FastCollection
Public strid  As New idHash, stridbackup As New idHash, strfunid As New idHash, strfunidbackup As New idHash
Public Clid As Long 'current id for app id
Public lastAboutHTitle As String, LastAboutText As String
''
Public Basestack1 As New basetask ' this is the global stack
Public EventStaticCollection As New FastCollection
Public sb2used As Long
Public Type modfun
    Extern As Long
    sb As String
    sbc As Long
    sbgroup As String
    tpointer As Long
    subs As FastCollection
    locked As Boolean
    goodname As String
    Changed As Boolean
    IamAClass As Boolean
End Type
Public sbf() As modfun
Public var2used As Long
Public var() As Variant
Public globalstack As New mStiva

Public IERUN As Boolean
Public IEX As Long
Public IEY As Long
Public IESizeX As Long
Public IESizeY As Long
Public AVIRUN As Boolean
Public AVIUP As Boolean
Public aviX As Long
Public aviY As Long
Public UseAviXY As Boolean
Public UseAviSize As Boolean
Public AviSizeX As Long
Public AviSizeY As Long
Public mycoder As New coder
' play music
Public voices$(0 To 15), BEATS(0 To 15) As Double



Const GFSR_SYSTEMRESOURCES = 0
Const GFSR_GDIRESOURCES = 1
Const GFSR_USERRESOURCES = 2


Declare Function SetLocaleInfo Lib "kernel32" Alias "SetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, ByVal lpLCData As String) As Long
Declare Function GetLocaleInfo Lib "kernel32" Alias "GetLocaleInfoA" (ByVal Locale As Long, ByVal LCType As Long, lpLCData As String, ByVal cchData As Long) As Long
Declare Function GetTempPath Lib "kernel32" Alias "GetTempPathW" (ByVal nBufferLength As Long, ByVal lpBuffer As Long) As Long
Public Declare Function GetWindowsDirectory Lib "kernel32" Alias "GetWindowsDirectoryA" (ByVal lpBuffer As String, ByVal nSize As Long) As Long


Private Const LOCALE_USER_DEFAULT = 0&


Public trace As Boolean, tracecounter As Long, bypasstrace As Boolean




Public Declare Sub Sleep Lib "kernel32" (ByVal dwMilliseconds As Long)

Public Declare Function SetTimer Lib "user32" _
       (ByVal hWnd As Long, ByVal nIDEvent As Long, _
        ByVal uElapse As Long, ByVal lpTimerFunc As Long) As Long

Public Declare Sub KillTimer Lib "user32" _
       (ByVal hWnd As Long, ByVal nIDEvent As Long)
'Public Type tagInitCommonControlsEx
 ' lngSize As Long
  ' lngICC As Long
'End Type
'Public Declare Function InitCommonControlsEx Lib "comctl32.dll" (iccex As tagInitCommonControlsEx) As Boolean
'Public Const ICC_USEREX_CLASSES = &H200
' APPLICATION TASK MASTER
Public MasterTimer As Double, tickTimer As Double
Public TaskMaster As TaskMaster
Public hmidi As Long
Public mute As Boolean
Public beat As Long
Public baseNote As Long
Public Prof As New clsProfiler
Public Declare Function GetACP Lib "kernel32" () As Long  ' 1253 in my computer


Public OverideDec As Boolean
'Valid dwCmpFlags
Public Declare Function LCMapStringW Lib "kernel32.dll" (ByVal Locale As Long, ByVal dwMapFlags As Long, ByVal lpSrcStr As Long, ByVal cchSrc As Long, Optional ByVal lpDestStr As Long, Optional ByVal cchDest As Long) As Long
Private Declare Function SysReAllocStringLen Lib "OleAut32.dll" (ByVal pBSTR As Long, Optional ByVal pszStrPtr As Long, Optional ByVal Length As Long) As Long
Public Modalid As Double
Public Function aheadstatus(a$, Optional srink As Boolean = True, Optional Pos As Long = 1) As String 'ok
Dim B$, part$, w$, pos2 As Long

If a$ = vbNullString Then Exit Function
Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If v1 = 2 Then
        If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        Pos = Pos + CLng("&H" & Mid$(a$, Pos + 1, 8)) + 8
        w$ = """"
   
    
    ElseIf Abs(v1) > 8 Then
    If part$ = vbNullString And w$ = "0" Then
        If Pos + 2 <= Len(a$) Then
            If LCase(Mid$(a$, Pos, 2)) Like "0[xВ]" Then
            'hexadecimal literal number....
                Pos = Pos + 2
                Do While Pos <= Len(a$)
                If Not Mid$(a$, Pos, 1) Like "[0-9a-fA-F]" Then Exit Do
                Pos = Pos + 1
                Loop
                B$ = B$ & "N"
                If Pos <= Len(a$) Then
                    w$ = Mid$(a$, Pos, 1)
                Else
                    Exit Do
                End If
            End If
        End If
    End If

    If w$ = """" Then
        If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
    If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
   
        Pos = Pos + 1
        Loop

    ElseIf w$ = "(" Then
again:
        If part$ <> "" Then
            ' after
            If part$ = "S" Then
            '
             If Mid$(a$, Pos + 1, 1) = ")" Then Pos = Pos + 2: GoTo conthere
             
            End If
            ElseIf Right$(B$, 1) = "a" Then
            B$ = Left$(B$, Len(B$) - 1)
            part$ = vbNullString
            Else
            part$ = "N"
              
        End If
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 2) = "=>" Then
        part$ = ""
        Pos = Pos + 3
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "#" Then
        'b$ = vbNullString
        part$ = ""
        Pos = Pos + 2
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
       If Mid$(a$, Pos + 1, 1) <> "." And Mid$(a$, Pos + 1, 2) <> "=>" Then
       B$ = B$ & part$
       End If
        part$ = vbNullString
        
    ElseIf w$ = "{" Then
Select Case Left$(Right$(B$, 2), 1)
    Case "l"
       Exit Do
    Case "o"
    If Right$(B$, 1) = "N" Then Exit Do
    Case "S"
    If Right$(B$, 1) = "a" Then
    Select Case Left$(Right$(B$, 3), 1)
    Case "l"
        Exit Do
    Case "o"
    Exit Do

    End Select
    
       If Left$(Right$(B$, 3), 1) = "l" Then Exit Do
    End If
    End Select
         
    If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        
If Pos <= Len(a$) Then
            pos2 = Pos
        If Not blockStringAhead(a$, Pos) Then Exit Do
        If Right$(B$, 1) = "N" Then
        If Not MaybeIsSymbol3lot(a$, "+<>=~", (Pos + 1)) Then
        Pos = pos2
        Exit Do
        End If
        End If
        End If
      

    Else
        Select Case w$
        Case ","  ' bye bye
        Exit Do
        Case "%"
            If part$ = vbNullString Then
            End If
        Case "$"
            If part$ = vbNullString Then
                If B$ = vbNullString Then
                    part$ = "N"
                ElseIf Right$(B$, 1) = "o" Then
                    part$ = "N"
                Else
                    aheadstatus = B$
                    Exit Function
                End If
            ElseIf part$ = "N" Then
                    B$ = B$ & "Sa"
                    If Mid$(a$, Pos + 1, 1) = "." Then Pos = Pos + 1
                    part$ = vbNullString
            End If
        Case "+", "-", "|"
                    B$ = B$ & part$
                    If B$ = vbNullString Then
                    Else
                    
                part$ = "o"
                End If
         Case "/"
            If Mid$(a$, Pos + 1, 1) = "/" Then Exit Do
            If part$ <> "o" Then
            B$ = B$ & part$
            End If
            part$ = "o"
        Case "*", "^"
            If part$ <> "o" Then
            B$ = B$ & part$
            End If
            part$ = "o"
        Case " ", ChrW(160), vbTab
            If part$ <> "" Then
            B$ = B$ & part$
            part$ = vbNullString
            Else
            'skip
            End If
        
        Case "0" To "9", "."
            If part$ = "N" Then
            If Len(a$) < Pos Then
                If Mid$(a$, Pos + 1, 1) Like "[&@#%~]" Then Pos = Pos + 1
            End If
            
            ElseIf part$ = "S" Then
            
            Else
            
            B$ = B$ & part$
            part$ = "N"
            End If
        Case "&"
        If part$ = vbNullString Then
        part$ = "S"
        ElseIf part$ = "N" Then
        B$ = B$ + part$
        part$ = vbNullString
        Else
        B$ = part$
        part$ = "S"
        End If
        Case "e", "E", "Е", "е"
            If part$ = "N" Then

            ElseIf part$ = "S" Then
            
            
            Else
            B$ = B$ & part$
            part$ = "N"
            End If
         Case "~"
            GoTo there1
         Case ">", "<"
            If Len(a$) > Pos Then
                If Mid$(a$, Pos + 1, 1) = "=" Then
                    B$ = B$ & part$
                     If Len(B$) > 1 Then
                        part$ = "o"
                        If Mid$(a$, Pos, 3) = "<=>" Then
                            Pos = Pos + 2
                        Else
                            Pos = Pos + 1
                        End If
                    End If
                ElseIf Mid$(a$, Pos, 2) = "<>" Then
                    B$ = B$ & part$
                    If Len(B$) > 1 Then
                        part$ = "o"
                        Pos = Pos + 1
                    End If
                ElseIf w$ = ">" And Pos > 1 Then
                    If Mid$(a$, Pos - 1, 2) = "->" Then ' "->"
                        If Right$(B$, 1) = "S" Then
                            B$ = B$ + part$
                            part$ = "N"
                        End If
                    End If
                End If
                
            End If
            GoTo there1
         Case "="
            If Len(a$) > Pos Then
                If InStr(">=", Mid$(a$, Pos + 1, 1)) > 0 Then
                    Pos = Pos + 2
                    GoTo conthere
                End If
            End If
            
there1:
                If B$ & part$ <> "" Then
               
                w$ = Replace(B$ & part$, "a", "")
            part$ = vbNullString
               If srink Then
                  Do
                B$ = w$
                w$ = Replace(B$, "NN", "N")
                Loop While w$ <> B$
                         Do
                        B$ = w$
                          w$ = Replace(B$, "SlS", "N")
                          Loop While w$ <> B$
                            Do
                          B$ = w$
                          w$ = Replace(B$, "NlN", "N")
                          Loop While w$ <> B$
    
                Do
                B$ = w$
                w$ = Replace(B$, "NoN", "N")
                Loop While w$ <> B$
                
                Do
                B$ = w$
                w$ = Replace(B$, "SoS", "S")
                Loop While w$ <> B$
                Else
              B$ = w$
               End If
               
                If Left$(B$, Len(B$) - 1) <> "l" Then part$ = "l"
                Else
                Exit Do
                End If

        Case ")", "}", Is < " ", ":", ";", "'", "\"
        Exit Do
        Case Else
        If part$ = "N" Then
        ElseIf part$ = "S" Then
        Else
        
     B$ = B$ & part$
     part$ = "N"

            End If
        End Select
        End If
End If
        Pos = Pos + 1
        
conthere:
  
Loop

    w$ = Replace(B$ & part$, "a", "")
    
    B$ = w$
If srink Then
         Do
  B$ = w$

    w$ = Replace(B$, "SlS", "N")
    Loop While w$ <> B$
      Do
    B$ = w$
    w$ = Replace(B$, "NlN", "N")
    Loop While w$ <> B$
    
    Do
    B$ = w$
    w$ = Replace(B$, "NoN", "N")
    Loop While w$ <> B$
    
    Do
    B$ = w$
    w$ = Replace(B$, "SoS", "S")
    Loop While w$ <> B$
End If
    aheadstatus = B$

End Function
Public Function aheadstatusStr(a$) As Long 'ok
Dim w$, pos2 As Long, Pos As Long
If a$ = vbNullString Then Exit Function
Dim v1 As Integer
 Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    
    If v1 = 2 Then
    If pos2 = 0 Then aheadstatusStr = True
    Exit Function
    
    ElseIf Abs(v1) > 8 Then
    
    If v1 = 34 Then
        If pos2 = 0 Then aheadstatusStr = True
        Exit Function

    ElseIf w$ = "(" Then
        
again22:
        Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
       If Mid$(a$, Pos + 1, 1) <> "." And Mid$(a$, Pos + 1, 2) <> "=>" Then
       
       End If
       
        
    ElseIf w$ = "{" Then
         
        aheadstatusStr = True
        Exit Function
    Else
        Select Case w$
        Case " ", ChrW(160), vbTab
        If pos2 > 0 Then Exit Function
        Case "%"
            If Not Mid$(a$, Pos + 1, 1) = "(" Then Exit Function
        Case "$"
            aheadstatusStr = True
            Exit Function
        Case "="
            If Not Mid$(a$, Pos + 1, 1) = ">" Then Exit Function
            Pos = Pos + 1
        Case "-"
            If Not Mid$(a$, Pos + 1, 1) = ">" Then Exit Function
            Pos = Pos + 1
        Case "."
         pos2 = pos2 + 1
        Case "0" To "9"
        If pos2 = 0 Then Exit Function
        Case "&"
        If pos2 = 0 Then aheadstatusStr = True: Exit Function
       
         Case Is < " ", ")", "}", ":", ";", "'", "\", "<", "~", ",", ">", "+", "*", "/", "'", "~", "|"
         Exit Function
        Exit Do
        Case Else
        pos2 = pos2 + 1
        End Select
        End If
End If
        Pos = Pos + 1
        
conthere:
  
Loop



End Function
Public Function aheadstatusFast(a$) As String 'ok
Dim B$, part$, w$, pos2 As Long, Pos As Long

If a$ = vbNullString Then Exit Function
Dim v1 As Integer
Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If v1 = 2 Then
        If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        Pos = Pos + CLng("&H" & Mid$(a$, Pos + 1, 8)) + 8
        w$ = """"
   
    
    ElseIf Abs(v1) > 8 Then
    If part$ = vbNullString And w$ = "0" Then
        If Pos + 2 <= Len(a$) Then
            If LCase(Mid$(a$, Pos, 2)) Like "0[xВ]" Then
            'hexadecimal literal number....
                Pos = Pos + 2
                Do While Pos <= Len(a$)
                If Not Mid$(a$, Pos, 1) Like "[0-9a-fA-F]" Then Exit Do
                Pos = Pos + 1
                Loop
                B$ = B$ & "N"
                If Pos <= Len(a$) Then
                    w$ = Mid$(a$, Pos, 1)
                Else
                    Exit Do
                End If
            End If
        End If
    End If

    If w$ = """" Then
        If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
    If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
   
        Pos = Pos + 1
        Loop

    ElseIf w$ = "(" Then
again:
        If part$ <> "" Then
            ' after
            If part$ = "S" Then
            '
             If Mid$(a$, Pos + 1, 1) = ")" Then Pos = Pos + 2: GoTo conthere
             
            End If
            ElseIf Right$(B$, 1) = "a" Then
            B$ = Left$(B$, Len(B$) - 1)
            part$ = vbNullString
            Else
            part$ = "N"
              
        End If
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 2) = "=>" Then
        'part$ = ""
        Pos = Pos + 3
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "#" Then
        'b$ = vbNullString
        'part$ = "N"
        Pos = Pos + 2
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
       If Mid$(a$, Pos + 1, 1) <> "." And Mid$(a$, Pos + 1, 2) <> "=>" Then
       B$ = B$ & part$
       End If
        part$ = vbNullString
        
    ElseIf w$ = "{" Then
Select Case Left$(Right$(B$, 2), 1)
    Case "l"
       Exit Do
    Case "o"
    If Right$(B$, 1) = "N" Then Exit Do
    Case "S"
    If Right$(B$, 1) = "a" Then
    Select Case Left$(Right$(B$, 3), 1)
    Case "l"
        Exit Do
    Case "o"
    Exit Do

    End Select
    
       If Left$(Right$(B$, 3), 1) = "l" Then Exit Do
    End If
    End Select
         
    If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        
If Pos <= Len(a$) Then
            pos2 = Pos
        If Not blockStringAhead(a$, Pos) Then Exit Do
        If Right$(B$, 1) = "N" Then
        If Not MaybeIsSymbol3lot(a$, "+<>=~", (Pos + 1)) Then
        Pos = pos2
        Exit Do
        End If
        End If
        End If
      

    Else
        Select Case w$
        Case ","  ' bye bye
        Exit Do
        Case "%"
            If part$ = vbNullString Then
            End If
        Case "$"
            If part$ = vbNullString Then
                If B$ = vbNullString Then
                    part$ = "N"
                ElseIf Right$(B$, 1) = "o" Then
                    part$ = "N"
                Else
                    aheadstatusFast = B$
                    Exit Function
                End If
            ElseIf part$ = "N" Then
                    B$ = B$ & "Sa"
                    If Mid$(a$, Pos + 1, 1) = "." Then Pos = Pos + 1
                    part$ = vbNullString
            End If
        Case "+", "-", "|"
                    B$ = B$ & part$
                    If B$ = vbNullString Then
                    Else
                    
                part$ = "o"
                End If
         Case "/"
            If Mid$(a$, Pos + 1, 1) = "/" Then Exit Do
            If part$ <> "o" Then
            B$ = B$ & part$
            End If
            part$ = "o"
        Case "*", "^"
            If part$ <> "o" Then
            B$ = B$ & part$
            End If
            part$ = "o"
        Case " ", ChrW(160), vbTab
            If part$ <> "" Then
            B$ = B$ & part$
            part$ = vbNullString
            Else
            'skip
            End If
        
        Case "0" To "9", "."
            If part$ = "N" Then
            If Len(a$) < Pos Then
                If Mid$(a$, Pos + 1, 1) Like "[&@#%~]" Then Pos = Pos + 1
            End If
            
            ElseIf part$ = "S" Then
            
            Else
            
            B$ = B$ & part$
            part$ = "N"
            End If
        Case "&"
        If part$ = vbNullString Then
        part$ = "S"
        ElseIf part$ = "N" Then
        B$ = B$ + part$
        part$ = vbNullString
        Else
        B$ = part$
        part$ = "S"
        End If
        Case "e", "E", "Е", "е"
            If part$ = "N" Then

            ElseIf part$ = "S" Then
            
            
            Else
            B$ = B$ & part$
            part$ = "N"
            End If
        Case "~"
        GoTo there1
         Case ">", "<"
            If Len(a$) > Pos Then
                If Mid$(a$, Pos + 1, 1) = "=" Then
                    B$ = B$ & part$
                     If Len(B$) > 1 Then
                        part$ = "o"
                        If Mid$(a$, Pos, 3) = "<=>" Then
                            Pos = Pos + 2
                        Else
                            Pos = Pos + 1
                        End If
                    End If
                ElseIf Mid$(a$, Pos, 2) = "<>" Then
                    B$ = B$ & part$
                    If Len(B$) > 1 Then
                        part$ = "o"
                        Pos = Pos + 1
                    End If
                ElseIf w$ = ">" And Pos > 1 Then
                    If Mid$(a$, Pos - 1, 2) = "->" Then ' "->"
                        If Right$(B$, 1) = "S" Then
                            B$ = B$ + part$
                            part$ = "N"
                        End If
                    End If
                End If
            End If
            GoTo there1
         Case "="
            If Len(a$) > Pos Then
                If InStr(">=", Mid$(a$, Pos + 1, 1)) > 0 Then
                    Pos = Pos + 2
                    GoTo conthere
                End If
            End If
there1:
                If B$ & part$ <> "" Then
               
               B$ = Replace(B$ & part$, "a", "")
                part$ = vbNullString
               
                If Left$(B$, Len(B$) - 1) <> "l" Then part$ = "l": Exit Do
                
                Else
                Exit Do
                End If

        Case ")", "}", Is < " ", ":", ";", "'", "\"
        Exit Do
        Case Else
        If part$ = "N" Then
        ElseIf part$ = "S" Then
        Else
        
     B$ = B$ & part$
     part$ = "N"

            End If
        End Select
        End If
End If
        Pos = Pos + 1
        
conthere:
  
Loop
aheadstatusFast = B$ & part$
End Function
'
Public Sub aheadstatusNew(a$, Pos As Long, flag As Boolean)
Dim B$, part$, w$, pos2 As Long
flag = False
If a$ = vbNullString Then Exit Sub

Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    If part$ = vbNullString And w$ = "0" Then
        If Pos + 2 <= Len(a$) Then
            If LCase(Mid$(a$, Pos, 2)) Like "0[xВ]" Then
                Pos = Pos + 2
                Do While Pos <= Len(a$)
                If Not Mid$(a$, Pos, 1) Like "[0-9a-fA-F]" Then Exit Do
                Pos = Pos + 1
                Loop
                B$ = B$ & "N"
                If Pos <= Len(a$) Then
                    w$ = Mid$(a$, Pos, 1)
                Else
                    Exit Do
                End If
            End If
        End If
    End If

    If w$ = """" Then
        If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
    If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
   
        Pos = Pos + 1
        Loop

    ElseIf w$ = "(" Then
again:
        If part$ <> "" Then
            ' after
            If part$ = "S" Then
            '
             If Mid$(a$, Pos + 1, 1) = ")" Then Pos = Pos + 2: GoTo conthere
             
            End If
            ElseIf Right$(B$, 1) = "a" Then
            B$ = Left$(B$, Len(B$) - 1)
            part$ = vbNullString
            Else
            part$ = "N"
              
        End If
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        B$ = vbNullString
        part$ = "N"
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
       If Mid$(a$, Pos + 1, 1) <> "." And Mid$(a$, Pos + 1, 2) <> "=>" Then
       B$ = B$ & part$
       End If
        part$ = vbNullString
        
    ElseIf w$ = "{" Then

Select Case Left$(Right$(B$, 2), 1)
    Case "l"
        Exit Do
    Case "o"
    If Right$(B$, 1) = "N" Then Exit Do
    Case "S"
    If Right$(B$, 1) = "a" Then
    Select Case Left$(Right$(B$, 3), 1)
    Case "l"
         Exit Do
    Case "o"
   Exit Do

    End Select
    
       If Left$(Right$(B$, 3), 1) = "l" Then Exit Do
    End If
    End Select
    If part$ <> "" Then
        B$ = B$ & part$
        End If
        part$ = "S"
        
        
            If Pos <= Len(a$) Then
            pos2 = Pos
        If Not blockStringAhead(a$, Pos) Then Exit Do
        If Right$(B$, 1) = "N" Then
        If Not MaybeIsSymbol3lot(a$, "+<>=~", (Pos + 1)) Then
        Pos = pos2
        Exit Do
        End If
        End If
        End If
      

      

    Else
        Select Case w$
        Case ","  ' bye bye
        Exit Do
        Case "%"
            If part$ = vbNullString Then
            End If
        Case "$"
            If part$ = vbNullString Then
                If B$ = vbNullString Then
                    part$ = "N"
                ElseIf Right$(B$, 1) = "o" Then
                    part$ = "N"
                Else
                    flag = Len(B$) > 0
                    Exit Sub
                End If
            ElseIf part$ = "N" Then
                    B$ = B$ & "Sa"
                    If Mid$(a$, Pos + 1, 1) = "." Then Pos = Pos + 1
                    part$ = vbNullString
            End If
        Case "+", "-", "|"
                    B$ = B$ & part$
                    If B$ = vbNullString Then
                    Else
                    
                part$ = "o"
                End If
        Case "*", "/", "^"
            If part$ <> "o" Then
            B$ = B$ & part$
            End If
            part$ = "o"
        Case " ", ChrW(160), vbTab
            If part$ <> "" Then
            B$ = B$ & part$
            part$ = vbNullString
            Else
            'skip
            End If
        Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        Case "0" To "9", "."
            If part$ = "N" Then
            If Len(a$) < Pos Then
                If Mid$(a$, Pos + 1, 1) Like "[&@#%~]" Then Pos = Pos + 1
            End If
            
            ElseIf part$ = "S" Then
            
            Else
            
            B$ = B$ & part$
            part$ = "N"
            End If
        Case "&"
        If part$ = vbNullString Then
        part$ = "S"
        ElseIf part$ = "N" Then
        B$ = B$ + part$
        part$ = vbNullString
        Else
        B$ = part$
        part$ = "S"
        End If
        Case "e", "E", "Е", "е"
            If part$ = "N" Then

            ElseIf part$ = "S" Then
            
            
            Else
            B$ = B$ & part$
            part$ = "N"
            End If
             Case "~"
        GoTo there1
         Case ">", "<"
            If Len(a$) > Pos Then
                If Mid$(a$, Pos + 1, 1) = "=" Then
                    B$ = B$ & part$
                    If Len(B$) > 1 Then
                        part$ = "o"
                        If Mid$(a$, Pos, 3) = "<=>" Then
                            Pos = Pos + 2
                        Else
                            Pos = Pos + 1
                        End If
                    End If
                ElseIf Mid$(a$, Pos, 2) = "<>" Then
                    B$ = B$ & part$
                    If Len(B$) > 1 Then
                        part$ = "o"
                        Pos = Pos + 1
                    End If
                ElseIf w$ = ">" And Pos > 1 Then
                    If Mid$(a$, Pos - 1, 2) = "->" Then ' "->"
                        If Right$(B$, 1) = "S" Then
                            B$ = B$ + part$
                            part$ = "N"
                        End If
                    End If
                End If
            End If
            GoTo there1
         Case "="
            If Len(a$) > Pos Then
                If InStr(">=", Mid$(a$, Pos + 1, 1)) > 0 Then
                    Pos = Pos + 2
                    GoTo conthere
                End If
            End If
there1:
                If B$ & part$ <> "" Then
               
                w$ = Replace(B$ & part$, "a", "")
            part$ = vbNullString
               
               If Len(B$) > 1 Then If Left$(B$, Len(B$) - 1) <> "l" Then part$ = "l"
                Else
                Exit Do
                End If

        Case ")", "}", Is < " ", ":", ";", "'", "\"
        Exit Do
        Case Else
        If part$ = "N" Then
        ElseIf part$ = "S" Then
        Else
        
     B$ = B$ & part$
     part$ = "N"

            End If
        End Select
        End If
End If
        Pos = Pos + 1
        
conthere:
  
Loop


    flag = Len(B$) <> 0




End Sub

Public Sub aheadstatusDO(a$, Pos As Long, Lang As Long, flag As Boolean)
Dim pos2 As Long, what$, w$, lenA As Long, level2 As Integer
Const second1$ = "епамекабе", len1 = 9
Const second11$ = "епамакабе", len11 = 9
Const second2$ = "DO", len2 = 2
Const second22$ = "REPEAT", len22 = 6
flag = False
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(a$)
Do While Pos <= lenA
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
                Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case w$
        Case "%", "$", "0" To "9", vbLf
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbCr, vbTab
            If Len(what$) > 1 Then
                If Lang = 0 Then
                    v1 = Len(what$)
                    If v1 = 5 Or v1 = 3 Or v1 = len1 Then
                        what$ = myUcase(what$)
                        If what$ = "левяи" Or what$ = "памта" Or what$ = "осо" Then
                                
                                If level2 = 0 Then
                                    Pos = Pos - v1
                                    flag = True
                                    Exit Sub
                                Else
                                    If Left$(what$, 1) <> "п" Then aheadstatusSkipParam a$, Pos
                                    level2 = level2 - 1
                                End If
                        ElseIf what$ = second1$ Or what$ = second11$ Then
                            If MaybeIsSymbol3(a$, "{", Pos) Then
                                aheadstatusSTRUCT a$, Pos
                            Else
                                level2 = level2 + 1
                            End If
                        Else
                            aheadstatusSkipParam a$, Pos
                        End If
                    Else
                        aheadstatusSkipParam a$, Pos
                    End If
                Else
                    v1 = Len(what$)
                    If v1 = 4 Or v1 = 5 Or v1 = len2 Or v1 = len22 Then
                        what$ = UCase(what$)
                        If what$ = "UNTIL" Or what$ = "ALWAYS" Or what$ = "WHEN" Then
                            If level2 = 0 Then
                                Pos = Pos - v1
                                flag = True
                                Exit Sub
                            Else
                                If Left$(what$, 1) <> "A" Then aheadstatusSkipParam a$, Pos
                                level2 = level2 - 1
                            End If
                        ElseIf what$ = second2$ Or what$ = second22$ Then
                            If MaybeIsSymbol3(a$, "{", Pos) Then
                                aheadstatusSTRUCT a$, Pos
                          Else
                                level2 = level2 + 1
                            End If
                        Else
                            aheadstatusSkipParam a$, Pos
                        End If
                    Else
                        aheadstatusSkipParam a$, Pos
                    End If
                End If
          Else
          If Len(what$) > 0 Then aheadstatusSkipParam a$, Pos
          End If
                  Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbCr, vbLf, vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1

                what$ = vbNullString
        Case "/"
            If Mid$(a$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
        
        Case ")", "}", Is < " " ', "'", "\"
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        
        what$ = what$ + w$
        
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
If flag = False Then
If Len(what$) > 0 Then
If level2 = 0 Then
    If Lang = 0 Then
    what$ = myUcase(what$)
        If what$ = "памта" Then
        Pos = Pos - Len(what$)
            flag = True
            Exit Sub
        End If
    Else
    what$ = UCase(what$)
    If what$ = "ALWAYS" Then
        Pos = Pos - Len(what$)
        flag = True
        Exit Sub
    End If
    End If
End If
End If
End If
Pos = lenA + 2

End Sub
Public Sub aheadstatusSTRUCT(a$, Pos As Long)
Dim pos2 As Long, w$, lenA As Long
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
lenA = Len(a$)
If Pos = 0 Then Pos = 1
Do While Pos <= lenA
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    If w$ = """" Then
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
again22:
      Pos = Pos + 1
        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        If MaybeIsSymbol3(a$, ":", Pos) Then Pos = Pos + 1: Exit Do
        End If
    Else
        Select Case w$
        Case "/"
        If Mid$(a$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
' skip line
    Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf

End Sub
Public Sub aheadstatusIFthen(a$, Pos As Long, Lang As Long, w$)
Dim pos2 As Long, what$

If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case w$
        Case ",", ":"
        Exit Do
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbCr, "{", vbTab
                If Len(what$) > 3 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                             If what$ = "тоте" Or what$ = "аккиыс" Then
                             
                                    If lookB123(a$, Pos) Then
                                        w$ = what$
                                        Exit Sub
                                    Else
                                        aheadstatusSkipParam a$, Pos
                                    End If
                                    Exit Do
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                    If lookB123(a$, Pos) Then
                                        w$ = what$
                                        Exit Sub
                                    Else
                                        aheadstatusSkipParam a$, Pos
                                    End If
                                    Exit Do
                            End If
                        End If
                    End If
                    End If
                    If w$ = vbCr Then Exit Do
                    what$ = vbNullString
            If w$ = "{" Then
                     If Pos <= Len(a$) Then
                    Pos = blockLen2(a$, Pos + 1)
                    If Pos = 0 Then Pos = Len(a$): Exit Do
                    End If
            Else
            Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        End If
        Case "/"
        If Mid$(a$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        
        what$ = what$ + w$
        
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
w$ = vbNullString
If Len(what$) > 0 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
         If what$ = "тоте" Or what$ = "аккиыс" Then
            w$ = what$
        ElseIf what$ = "THEN" Or what$ = "ELSE" Then
            w$ = what$
        End If
      End If
        
End If
End Sub

Public Sub aheadstatusIF(a$, Pos As Long, Lang As Long, w$)
Dim pos2 As Long, what$

If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case w$
        Case ",", ":"
        Exit Do
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), "{", vbTab
                If Len(what$) > 3 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                             If what$ = "тоте" Or what$ = "аккиыс" Then
                                w$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                w$ = what$
                                Exit Sub
                            End If
                        End If
                    End If
                    End If
                    what$ = vbNullString
                    If w$ = "{" Then
                     If Pos <= Len(a$) Then
                    Pos = blockLen2(a$, Pos + 1)
                    If Pos = 0 Then Pos = Len(a$): Exit Do
                    End If
                    Else
                 Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        End If
        Case "/"
        If Mid$(a$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        
        what$ = what$ + w$
        
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
w$ = vbNullString
If Len(what$) > 0 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
         If what$ = "тоте" Or what$ = "аккиыс" Then
            w$ = what$
        ElseIf what$ = "THEN" Or what$ = "ELSE" Then
            w$ = what$
        End If
      End If
        
End If
End Sub
Public Sub aheadstatusELSE(a$, Pos As Long, Lang As Long, w$)
Dim pos2 As Long, what$
' in a line like if true then ?"ok" else ?"else"
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case w$
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case vbTab, " ", ChrW(160), "0" To "9", "{"
                If Len(what$) > 1 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                        If what$ = "ам" Or what$ = "аккиыс" Or what$ = "аккиыс.ам" Then 'Or what$ = "тоте"
                            w$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "IF" Or what$ = "ELSE" Or what$ = "ELSE.IF" Then  'Or what$ = "THEN"
                                w$ = what$
                                Exit Sub
                            End If
                        End If
                    End If
                    End If
                    what$ = vbNullString
       
                 If w$ = "{" Then
                     If Pos <= Len(a$) Then
                    Pos = blockLen2(a$, Pos + 1)
                    If Pos = 0 Then Pos = Len(a$): Exit Do
                    End If
                 Else
                Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        End If
        Case "/"
        If Mid$(a$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        If w$ = ":" Then
        what$ = ""
        Else
        what$ = what$ + w$
        End If
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
w$ = vbNullString
If Len(what$) > 1 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
                        If what$ = "ам" Or what$ = "тоте" Or what$ = "аккиыс" Or what$ = "аккиыс.ам" Then
                            w$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "IF" Or what$ = "THEN" Or what$ = "ELSE" Or what$ = "ELSE.IF" Then
                                w$ = what$
                                Exit Sub
                            End If
                        End If
        
End If
End Sub


Public Sub aheadstatusThen(a$, Pos As Long, Lang As Long, w$)
Dim pos2 As Long, what$

If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= Len(a$) Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = Len(a$): Exit Do
        End If
    Else
        Select Case w$
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), "0" To "9", vbTab
                If Len(what$) > 1 Then
                    If Len(what$) > 0 Then
                        what$ = myUcase(what$)
                        If Lang = 0 Then
                        If what$ = "тоте" Or what$ = "аккиыс" Then
                            w$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                w$ = what$
                                Exit Sub
                            End If
                        End If
                    End If
                    End If
                    what$ = vbNullString
                 Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        Case "/"
        If Mid$(a$, Pos + 1, 1) = "/" Then Exit Do
        Case ")", "}", Is < " ", "'", "\"
        Exit Do
        Case Else
        
        what$ = what$ + w$
        
        
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
w$ = vbNullString
If Len(what$) > 1 Then
      what$ = myUcase(what$)
      If Lang = 0 Then
                        If what$ = "тоте" Or what$ = "аккиыс" Then
                            w$ = what$
                                Exit Sub
                            End If
                        Else
                            If what$ = "THEN" Or what$ = "ELSE" Then
                                w$ = what$
                                Exit Sub
                            End If
                        End If
        
End If
End Sub
Public Sub aheadstatusSkipParam2(a$, Pos As Long)
' no block  ' for for next
Dim pos2 As Long, w$
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    If w$ = """" Then
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
again22:
      Pos = Pos + 1
        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    Else
        Select Case w$
        Case "/"
            If Mid$(a$, Pos + 1, 1) = "/" Then GoTo jump1
        Case "'", "\"
        If Pos > 1 Then Pos = Pos - 1
        Exit Do
        Case ":", ")", "{", "}", Is < " ", vbLf
        Exit Do
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Exit Sub
jump1:
If Pos > 1 Then Pos = Pos - 1
End Sub

Public Sub aheadstatusSkipParam(a$, Pos As Long)
Dim pos2 As Long, w$
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    If w$ = """" Then
        Pos = Pos + 1
        Do While Pos <= Len(a$)
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
again22:
      Pos = Pos + 1
        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Pos <= Len(a$) Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = Len(a$): Exit Do
        End If
    Else
        Select Case w$
        Case "/"
        If Mid$(a$, Pos + 1, 1) = "/" Then
        If Pos > 1 Then Pos = Pos - 1
        Exit Do
        End If
        Case "'", "\"
        If Pos > 1 Then Pos = Pos - 1
        Exit Do
        Case ":", ")", "}", Is < " ", vbLf
        Exit Do
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop

End Sub


Public Sub aheadstatusNext(a$, Pos As Long, Lang As Long, flag As Boolean)
Dim pos2 As Long, what$, w$, lenA As Long, level2 As Integer, CM As Integer
CM = 1
Const second1$ = "циа", len1 = 3
Const second2$ = "FOR", len2 = 3
flag = False
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(a$)
Do While Pos <= lenA
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
    
        Select Case w$
        Case vbLf
        CM = 0
        If Len(what$) > 0 Then what$ = vbNullString
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbCr, ":", vbTab
again:
            If Len(what$) > 2 Then
                If Lang = 0 Then
                    If Len(what$) = 7 Or Len(what$) = len1 Then
                        what$ = myUcase(what$)
                        If what$ = "еполемо" Then
                               If MyTrim$(w$) = "" Then aheadstatusSkipParam a$, Pos
                                If level2 = 0 Then
                                    flag = True
                                    Exit Sub
                                Else
                                    level2 = level2 - 1
                                End If
                        ElseIf what$ = second1$ Then
                            aheadstatusSkipParam2 a$, Pos
                            If MaybeIsSymbol3(a$, "{", Pos) Then
                                Pos = blockLen2(a$, Pos + 1)
                                If Pos = 0 Then Pos = Len(a$): Exit Sub
                            ElseIf MaybeIsSymbol3lot(a$, b1234, Pos) Then
                                level2 = level2 + 1
                            End If
                        Else
                            aheadstatusSkipParam a$, Pos
                        End If
                    Else
                        aheadstatusSkipParam a$, Pos
                    End If
                Else
                    If Len(what$) = 4 Or Len(what$) = len2 Then
                        what$ = myUcase(what$)
                        If what$ = "NEXT" Then
                            If MyTrim$(w$) = "" Then aheadstatusSkipParam a$, Pos
                            If level2 = 0 Then
                                flag = True
                                Exit Sub
                            Else
                                level2 = level2 - 1
                            End If
                        ElseIf what$ = second2$ Then
                            aheadstatusSkipParam2 a$, Pos
                            If MaybeIsSymbol3(a$, "{", Pos) Then
                                Pos = blockLen2(a$, Pos + 1)
                                If Pos = 0 Then Pos = Len(a$): Exit Sub
                            ElseIf MaybeIsSymbol3lot(a$, b1234, Pos) Then
                                level2 = level2 + 1
            
                              
                            End If
                        Else
                            aheadstatusSkipParam a$, Pos
                        End If
                    Else
                        aheadstatusSkipParam a$, Pos
                    End If
                End If
          Else
          If Len(what$) > 0 Then aheadstatusSkipParam a$, Pos
          End If
                what$ = vbNullString
                
        Pos = Pos + 1
        Do
        pos2 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos2 > Pos
        Pos = Pos - 1
        Case "/"
            If CM = 0 Or Mid$(a$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        CM = 1
        what$ = what$ + w$
        
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
If Len(what$) > 2 Then GoTo again
Pos = lenA + 2

End Sub


Public Sub aheadstatusELSEIF(a$, Pos As Long, Lang As Long, jump As Boolean, IFCTRL As Long, flag As Boolean)
Dim what$, w$, lenA As Long, level2 As Integer, CM As Integer, pos3 As Long
CM = 1
Const second1$ = "ам", len1 = 2
Const second2$ = "IF", len2 = 2
flag = True
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(a$)
Do While Pos <= lenA
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case w$
        Case "%", "$", "0" To "9", vbLf
            If Len(what$) > 0 Then what$ = vbNullString
        Case vbLf
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 0
        Case " ", ChrW(160), vbCr, vbTab ',  Check Else and IF
                If Len(what$) > 1 Then
                        
                        If Lang = 0 Then
                        
                        
                            what$ = myUcase(what$)
                            If what$ = "аккиыс" Then
                                
                                If lookB123(a$, Pos) Then
                                    If level2 = 0 Then Pos = Pos - 6: Exit Sub
                                Else
                                    aheadstatusSkipParam a$, Pos
                                End If
                            ElseIf what$ = "текос" Then
                                    
                                If FastSymbolAt(Pos, a$, second1$, len1) Then
                                    If level2 = 0 Then IFCTRL = 0: Exit Sub
                                    level2 = level2 - 1
                                Else
                                    aheadstatusSkipParam a$, Pos
                                End If
                            ElseIf what$ = "аккиыс.ам" Then
                                    If (Not jump) Or IFCTRL = 2 Then
                                        aheadstatusSkipParam a$, Pos
                                    Else
                                    
                                    If level2 = 0 Then
                                    Pos = Pos - 9: Exit Sub
                                    Else
                                        aheadstatusSkipParam a$, Pos
                                    End If
                                    End If
                            ElseIf what$ = second1$ Then  ' skip any nested IF
                                aheadstatusThen a$, Pos, 0, what$
                                If what$ <> vbNullString Then
                                    If MaybeIsSymbol3(a$, "{", Pos) Then
                                    aheadstatusSTRUCT a$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(a$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                            Else
                            aheadstatusSkipParam a$, Pos
                            End If
                          
                        Else
                                what$ = UCase(what$)
                                If what$ = "ELSE" Then
                                    If lookB123(a$, Pos) Then
                                        If level2 = 0 Then Pos = Pos - 4: Exit Sub
                                    Else
                                        aheadstatusSkipParam a$, Pos
                                    End If
                                ElseIf what$ = "END" Then
                            
                                    If FastSymbolAt(Pos, a$, second2$, len2) Then
                                        If level2 = 0 Then IFCTRL = 0: Exit Sub
                                        level2 = level2 - 1
                                    Else
                                        aheadstatusSkipParam a$, Pos
                                    End If
                                ElseIf what$ = "ELSE.IF" Then
                                    If (Not jump) Or IFCTRL = 2 Then
                                        aheadstatusSkipParam a$, Pos
                                    Else
                                    
                                    If level2 = 0 Then
                                    Pos = Pos - 7: Exit Sub
                                    Else
                                        aheadstatusSkipParam a$, Pos
                                    End If
                                    End If
                                ElseIf what$ = second2$ Then
                                aheadstatusThen a$, Pos, 1, what$
                                If what$ <> vbNullString Then
                                    If MaybeIsSymbol3(a$, "{", Pos) Then
                                    aheadstatusSTRUCT a$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(a$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                                
                                Else
                                aheadstatusSkipParam a$, Pos
                                End If
                            
                        End If
                    End If
                    what$ = vbNullString
                            Pos = Pos + 1
        Do
        pos3 = Pos + 1
        Select Case Mid$(a$, Pos, 1)
        Case " ", Chr$(160), vbCr, vbLf, vbTab
            Pos = Pos + 1
        End Select
        Loop Until pos3 > Pos
        Pos = Pos - 1

        Case "/"
            If CM = 0 Or Mid$(a$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
         Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        CM = 1
        what$ = what$ + w$
        
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 1
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Sub
'
'
Public Sub aheadstatusENDIF(a$, Pos As Long, Lang As Long, flag As Boolean)
Dim pos2 As Long, what$, w$, lenA As Long, level2 As Integer, CM As Integer
CM = 1
Const second1$ = "ам", len1 = 2
Const second2$ = "IF", len2 = 2
flag = True
If a$ = vbNullString Then Exit Sub
Dim v1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(a$)
Do While Pos <= lenA
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case w$
        Case vbCr, vbLf
            CM = 0
            If Len(what$) > 0 Then what$ = vbNullString
        Case "%", "$", "0" To "9"
            If Len(what$) > 0 Then what$ = vbNullString
        Case " ", ChrW(160), vbTab
                If Len(what$) > 1 Then
                        
                        If Lang = 0 Then
                        If Len(what$) = 5 Or Len(what$) = len1 Then
                            what$ = myUcase(what$)
                            If what$ = "текос" Then
                                    
                                If FastSymbolAt(Pos, a$, second1$, len1) Then
                                If level2 = 0 Then Exit Sub
                                level2 = level2 - 1
                                Else
                                aheadstatusSkipParam a$, Pos
                                End If
                            ElseIf what$ = second1$ Then
                                aheadstatusThen a$, Pos, 0, what$
                                If what$ <> vbNullString Then
                                  If MaybeIsSymbol3(a$, "{", Pos) Then
                                    aheadstatusSTRUCT a$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(a$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                            Else
                            aheadstatusSkipParam a$, Pos
                            End If
                            Else
                            aheadstatusSkipParam a$, Pos
                            End If
                          
                        Else
                            If Len(what$) = 3 Or Len(what$) = len2 Then
                                what$ = UCase(what$)
                                If what$ = "END" Then
                            
                                If FastSymbolAt(Pos, a$, second2$, len2) Then
                                    If level2 = 0 Then Exit Sub
                                    level2 = level2 - 1
                                 Else
                                 aheadstatusSkipParam a$, Pos
                                End If
                                ElseIf what$ = second2$ Then
                                aheadstatusThen a$, Pos, 1, what$
                                If what$ <> vbNullString Then
                                    If MaybeIsSymbol3(a$, "{", Pos) Then
                                    aheadstatusSTRUCT a$, Pos
                                    
                                    ElseIf MaybeIsSymbol3lot(a$, b123, Pos) Then
                                    level2 = level2 + 1
                                    Else 'skip line
                                    Do
                                        Pos = Pos + 1
        
                                    Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
                                    End If
                                Else
                                flag = False
                                SyntaxError
                                Exit Sub
                                End If
                                
                                Else
                                aheadstatusSkipParam a$, Pos
                                End If
                            Else
                            aheadstatusSkipParam a$, Pos
                            
                            End If
                            
                        End If
                    End If
                    what$ = vbNullString
                        Pos = Pos + 1
                        Do
                        pos2 = Pos + 1
                        Select Case Mid$(a$, Pos, 1)
                        Case " ", Chr$(160), vbTab
                            Pos = Pos + 1
                        End Select
                        Loop Until pos2 > Pos
                        Pos = Pos - 1

        Case "/"
            If CM = 0 Or Mid$(a$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        
        what$ = what$ + w$
        CM = 1
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 1
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Sub

Public Function aheadstatusENDSUBorFUN(a$, Pos As Long, Lang As Long, func As Boolean) As Boolean
Dim pos2 As Long, what$, w$, lenA As Long, level2 As Integer, CM As Integer
CM = 1
Const second1$ = "сумаятгсгс", len1 = 10
Const second2$ = "FUNCTION", len2 = 8
Const second11$ = "яоутимас", len11 = 8
Const second22$ = "SUB", len22 = 3
If a$ = vbNullString Then Exit Function
Dim v1 As Long
If Pos = 0 Then Pos = 1
lenA = Len(a$)
Do While Pos <= lenA
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case w$
            Case vbCr, vbLf
                CM = 0
                If Len(what$) > 0 Then what$ = vbNullString
            Case "%", "$", "0" To "9"
                If Len(what$) > 0 Then what$ = vbNullString
            Case " ", ChrW(160), vbTab
                If Len(what$) > 1 Then
                    If Lang = 0 Then
                        If Len(what$) = 5 Then
                            what$ = myUcase(what$)
                            If what$ = "текос" Then
                                If func Then
                                    If FastSymbolAt(Pos, a$, second1$, len1) Then aheadstatusENDSUBorFUN = True: Exit Function
                                Else
                                    If FastSymbolAt(Pos, a$, second11$, len11) Then aheadstatusENDSUBorFUN = True: Exit Function
                                End If
                            End If
                        End If
                    Else
                        If Len(what$) = 3 Then
                            what$ = UCase(what$)
                            If what$ = "END" Then
                                If func Then
                                    If FastSymbolAt(Pos, a$, second2$, len2) Then aheadstatusENDSUBorFUN = True: Exit Function
                                Else
                                    If FastSymbolAt(Pos, a$, second22$, len22) Then aheadstatusENDSUBorFUN = True: Exit Function
                                End If
                            End If
                        End If
                    End If
                aheadstatusSkipParam a$, Pos
                what$ = vbNullString
                End If
                
                
                    Pos = Pos + 1
                    Do
                    pos2 = Pos + 1
                    Select Case Mid$(a$, Pos, 1)
                    Case " ", Chr$(160), vbTab
                        Pos = Pos + 1
                    End Select
                    Loop Until pos2 > Pos
                    Pos = Pos - 1

        Case "/"
            If CM = 0 Or Mid$(a$, Pos, 2) = "//" Then
               GoTo skip1
            End If
        Case "'", "\"
skip1:
            If Len(what$) > 0 Then what$ = vbNullString
        Do
        Pos = Pos + 1
        
        Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
        CM = 0
        Case ")", "}", Is < " "
        
        Exit Do
        Case ".", "A" To "Z", "a" To "z", Is >= "╒"
        
        what$ = what$ + w$
        CM = 1
        Case Else
            If Len(what$) > 0 Then what$ = vbNullString
            CM = 1
        End Select
        End If
End If
        Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Function
Public Sub aheadstatusEND(a$, Pos As Long, Lang As Long, second1$, len1 As Long, second2$, len2 As Long, flag As Boolean, v1 As Long)
Dim pos2 As Long, what$, w$, lenA As Long, level2 As Integer, CM As Integer
flag = False
CM = 1
If a$ = vbNullString Then Exit Sub
If Pos = 0 Then Pos = 1
lenA = Len(a$)
Do While Pos <= lenA
    w$ = Mid$(a$, Pos, 1)
    v1 = AscW(w$)
    If Abs(v1) > 8 Then
    
    If w$ = """" Then
            If Len(what$) > 0 Then what$ = vbNullString
        Pos = Pos + 1
        Do While Pos <= lenA
        If Mid$(a$, Pos, 1) = """" Then Exit Do
        If Abs(AscW(Mid$(a$, Pos, 1))) < 31 Then Exit Do
        Pos = Pos + 1
        Loop
    ElseIf w$ = "(" Then
        If Len(what$) > 0 Then what$ = vbNullString
again22:
      Pos = Pos + 1

        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
        Pos = Pos + 1
        GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
        Pos = Pos + 1: GoTo again22
        End If
    ElseIf w$ = "{" Then
       If Len(what$) > 0 Then what$ = vbNullString
       If Pos <= lenA Then
        'If Not blockStringAhead(a$, pos) Then Exit Do
        Pos = blockLen2(a$, Pos + 1)
        If Pos = 0 Then Pos = lenA: Exit Do
        End If
    Else
        Select Case w$
            Case vbLf
                If Len(what$) > 0 Then what$ = vbNullString
                CM = 0
            Case "%", "$", "0" To "9", vbCr
                If Len(what$) > 0 Then what$ = vbNullString
            Case " ", ChrW(160), vbTab
                If Len(what$) > 1 Then
                    If Lang = 0 Then
                        If Len(what$) = 5 Or Len(what$) = len1 Then
                            what$ = myUcase(what$)
                            If what$ = "текос" Then
                                v1 = Pos - 5
                                If FastSymbolAt(Pos, a$, second1$, len1) Then
                                    If level2 = 0 Then flag = True: Exit Sub
                                    level2 = level2 - 1
                                Else
                                    aheadstatusSkipParam a$, Pos
                                End If
                            ElseIf what$ = second1$ Then
                                Pos = Pos - 1
                                Do
                                    Pos = Pos + 1
                                    pos2 = Pos
                                    aheadstatusNew a$, Pos, flag
                                Loop While flag And MaybeIsSymbol3(a$, ",", Pos)
                                If MaybeIsSymbol3(a$, "{", Pos) Then
                                    aheadstatusSTRUCT a$, Pos
                                ElseIf MaybeIsSymbol3lot(a$, b1234, Pos) Then
                                    level2 = level2 + 1
                                    Pos = Pos + 1
                                End If
                            Else
                                aheadstatusSkipParam a$, Pos
                            End If
                        Else
                            aheadstatusSkipParam a$, Pos
                        End If
                    Else
                        If Len(what$) = 3 Or Len(what$) = len2 Then
                            what$ = UCase(what$)
                            If what$ = "END" Then
                                v1 = Pos - 3
                                If FastSymbolAt(Pos, a$, second2$, len2) Then
                                    If level2 = 0 Then flag = True: Exit Sub
                                    level2 = level2 - 1
                                Else
                                    aheadstatusSkipParam a$, Pos
                                End If
                            ElseIf what$ = second2$ Then
                                Pos = Pos - 1
                                Do
                                    Pos = Pos + 1
                                    pos2 = Pos
                                    aheadstatusNew a$, Pos, flag
                                Loop While flag And MaybeIsSymbol3(a$, ",", Pos)
                                If MaybeIsSymbol3(a$, "{", Pos) Then
                                    aheadstatusSTRUCT a$, Pos
                                ElseIf MaybeIsSymbol3lot(a$, b1234, Pos) Then
                                    level2 = level2 + 1
                                    Pos = Pos + 1
                                End If
                            Else
                                aheadstatusSkipParam a$, Pos
                            End If
                        Else
                            aheadstatusSkipParam a$, Pos
                        End If
                    End If
                End If
                what$ = vbNullString
                Pos = Pos + 1
                Do
                    pos2 = Pos + 1
                    Select Case Mid$(a$, Pos, 1)
                        Case " ", Chr$(160), vbTab
                        Pos = Pos + 1
                    End Select
                Loop Until pos2 > Pos
                Pos = Pos - 1
            Case "/"
                If CM = 0 Or Mid$(a$, Pos, 2) = "//" Then
                   GoTo skip1
                End If
            Case "'", "\"
skip1:
                If Len(what$) > 0 Then what$ = vbNullString
                Do
                Pos = Pos + 1
                Loop While Pos < lenA And Not Mid$(a$, Pos, 1) = vbLf
                CM = 0
            Case ")", "}", Is < " "
                Exit Do
            Case "A" To "Z", "a" To "z", Is >= "╒"
                CM = 1
                what$ = what$ + w$
            Case Else
                If Len(what$) > 0 Then what$ = vbNullString
                CM = 1
            End Select
        End If
    End If
    Pos = Pos + 1
        
  
conthere:
  
Loop
Pos = lenA + 2

End Sub
Function ChangeValuesMem(bstack As basetask, rest$, Lang As Long) As Boolean
Dim aa As mHandler, ah As String, p As Variant, s$, addr As Long, pp As Variant, what$, R As Double
Dim bb1 As MemBlock, w2 As Variant, rs As Single, itissingle As Boolean
Set aa = bstack.lastobj
Set bstack.lastobj = Nothing
Set bb1 = aa.objref

    Do While FastSymbol(rest$, ",")
    
        ChangeValuesMem = False
        pp = bb1.ItemSize
        ah = aheadstatus(rest$, False) + " "
        If InStr(ah, "l") Then
                MyEr "Found logical expression", "бЯчЙА КОЦИЙч щЙЖЯАСГ"
        Else
                If Left$(ah, 1) = "N" Then
                    If Not IsExp(bstack, rest$, p, , True) Then
                        GoTo there
                    End If
                    If FastSymbol(rest$, "!") Then
                    
                    If FastPureLabel(rest$, what$) Then
                        If bb1.UseStruct Then
                                If bb1.structref.Find(myUcase(what$, True)) Then
                                    pp = bb1.structref.sValue
                                    itissingle = bb1.structref.KeyTypeValue = vbSingle
                                    If FastSymbol(rest$, "!") Then
                                        If Not IsExp(bstack, rest$, R, , True) Then
                                                 GoTo there
                                        ElseIf R >= 0 Then
                                                 p = bb1.GetPtr(p) + bb1.structref.Value + Int(R) * Abs(pp)
                                        Else
                                                 MyEr "negative index", "АЯМГТИЙЭР ДЕъЙТГ"
                                                GoTo there
                                        End If
                                    Else
                                    
                                    p = bb1.GetPtr(p) + bb1.structref.Value
                                    End If
                                    
                                Else
                                rest$ = what$ + rest$
                                If IsExp(bstack, rest$, R, , True) Then
                                        p = bb1.GetPtr(p) + R
                                        
                                    Else
                                    MyErMacro rest$, "Unknown Offset " & what$, "╒ЦМЫСТГ лЕТэХЕСГ " & what$
                                    GoTo there
                                End If
                           End If
                        Else
                                If IsExp(bstack, what$, R, , True) Then
                                    p = bb1.GetPtr(p) + R
                                Else
                                    GoTo there
                                End If
                        End If
                        Else
                        p = bb1.GetBytePtr(p)
                        End If
                        
          
                    Else
                                                
                        p = bb1.GetPtr(p)
                        itissingle = bb1.WhatIsBasicItem = vbSingle
                    End If
                    If p = 0 Then
                        MyEr "оffset Null or not for buffer", "дИЕЩХУМСГ 0 ч ЕЙТЭР дИэЯХЯЫСГР"
                          GoTo there
                    End If
                    addr = CLng(Fix(p))
                
                    
                Else

                        MyEr "No Offset found", "дЕМ БЯщХГЙЕ дИЕЩХУМСГ"
                          GoTo there
                
                End If
                If FastSymbol(rest$, ":=", , 2) Then
                    ah = aheadstatus(rest$, False) + " "
                    If Left$(ah, 1) = "N" Or InStr(ah, "l") > 0 Then
                        If Not IsExp(bstack, rest$, p, , True) Then
                            GoTo there
                        End If
                        
                        If addr = 0 Then
                            MyEr "оffset Null or not for buffer", "дИЕЩХУМСГ 0 ч ЕЙТЭР дИэЯХЯЫСГР"
                
                            GoTo there
                        Else
                                ' this ia a part to poke some data to buffer
                            If addr = 0 Then
                                MyEr "оffset Null or not for buffer", "дИЕЩХУМСГ 0 ч ЕЙТЭР дИэЯХЯЫСГР"
                        
                                GoTo there
                            Else
                                ' here is the part where we copy a string to memblock
                                If IsLabelSymbolNew(rest$, "ыс", "AS", Lang, , , , False) Then
                                    If IsLabelSymbolNew(rest$, "ьгжио", "BYTE", Lang, , , , False) Then
                                        pp = 1
                                    ElseIf IsLabelSymbolNew(rest$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                                    pp = 2
                                    ElseIf IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang, , , , False) Then
                                    pp = 4
                                    ElseIf IsLabelSymbolNew(rest$, "апкос", "SINGLE", Lang, , , , False) Then
                                        pp = 4
                                        itissingle = True
                                    ElseIf IsLabelSymbolNew(rest$, "дипкос", "DOUBLE", Lang, , , , False) Then
                                        pp = 8
                                    Else
                                        SyntaxError
                                        GoTo there
                                    End If
                               End If
                                Err.Clear
                                On Error Resume Next
                                Select Case pp
                                Case 1
                                    ChangeValuesMem = True
                                    PutMem1 addr, CByte(LowWord(signlong(p)) And &HFF)
                               Case 2
                                   If bb1.ValidArea(addr, 2) Then
                                        ChangeValuesMem = True
                                        PutMem2 addr, CInt(LowWord(signlong(p)))
                                    Else
                                        MyEr "Buffer is small", "г дИэЯХЯЫСГ ЕъМАИ ЛИЙЯч"
                                        GoTo there
                                    End If
                                Case 4
                                    If bb1.ValidArea(addr, 4) Then
                                        ChangeValuesMem = True
                                        If itissingle Then
                                            rs = CSng(p)
                                            PutMemS addr, rs
                                        Else
                                            PutMem4 addr, signlong(p)
                                        End If
                                    Else
                                        MyEr "Buffer is small", "г дИэЯХЯЫСГ ЕъМАИ ЛИЙЯч"
                                        GoTo there
                                   End If
                                Case 8
                                   If bb1.ValidArea(addr, 8) Then
                                        ChangeValuesMem = True
                                        PutMem8 addr, p
                                   Else
                                        MyEr "Buffer is small", "г дИэЯХЯЫСГ ЕъМАИ ЛИЙЯч"
                                        GoTo there
                                   End If
                                End Select
                                If Err <> 0 Then
                                    MyEr "Overflow. Problem in Buffer", "уПЕЯВЕъКИСГ. пЯЭБКГЛА СТГ дИэЯХЯЫСГ"
                                    GoTo there
                                End If
                            End If
                        End If
                    ElseIf Left$(ah, 1) = "S" Then
                        If Not IsStrExp(bstack, rest$, s$) Then
                            GoTo there
                        End If
                        If IsLabelSymbolNew(rest$, "ыс", "AS", Lang, , , , False) Then
                                If IsLabelSymbolNew(rest$, "цяалла", "STRING", Lang, , , , False) Then
                                    pp = -4
                                Else
                                    SyntaxError
                 
                                   GoTo there
                                End If
                                                          
                            End If
                        
                        If Not bstack.lastobj Is Nothing Then
                        
                         MyEr "No objects for buffer", "╪ВИ АМТИЙЕъЛЕМА ЦИА дИэЯХЯЫСГ"
                            GoTo there
                            
                        Else
                                If addr = 0 Then
                                    MyEr "оffset Null or not for buffer", "дИЕЩХУМСГ 0 ч ЕЙТЭР дИэЯХЯЫСГР"
                                    GoTo there
                                Else
                            ' here is the part where we copy a string to memblock
                            Err.Clear
                            On Error Resume Next
                          If pp < 0 Or bb1.WhatIsBasicItem = vbString Then
                          If bb1.ValidArea(addr, 4) Then
                          ChangeValuesMem = True
                            PutMem4 addr, CLng(bb1.PutStringAtOffset(addr, s$))
                          End If
                          Else
                      
                           If bb1.ValidArea(addr, LenB(s$)) Then
                           ChangeValuesMem = True
                           CopyBytes LenB(s$), addr, StrPtr(s$)
                     
                           Else
                            MyEr "Buffer is small", "г дИэЯХЯЫСГ ЕъМАИ ЛИЙЯч"
                            GoTo there
                           End If
                        End If
                           If Err <> 0 Then
                           ChangeValuesMem = False
                           MyEr "Overflow. Problem in Buffer", "уПЕЯВЕъКИСГ. пЯЭБКГЛА СТГ дИэЯХЯЫСГ"
                           GoTo there
                           End If
                            
                            End If
                        
                        End If
                Else
                        MyEr "No Data found", "дЕМ БЯщХГЙАМ СТОИВЕъА"
                       GoTo there
                End If
                End If
        End If
    Loop


there:

Set bb1 = Nothing
Set aa = Nothing
End Function


Public Function CopyArray(a As Object) As Variant
 Dim pppp1 As mArray
     Set pppp1 = New mArray
     a.CopyArray pppp1
     Set a = Nothing
     Set CopyArray = pppp1
     Set pppp1 = Nothing
End Function



Public Function kUpper(a$, p As Variant) As String
'idea from Bonnie West, FROM VBFORUMS
Dim nSize As Long
    nSize = Len(a$)
    If nSize Then SysReAllocStringLen VarPtr(kUpper), , nSize Else Exit Function
    Const LCMAP_UPPERCASE = &H200&
Dim mLid As Long
If p = 0 Then
mLid = Clid
Else
mLid = p
End If
If p = 1032 Then
If osnum >= System_Windows_Vista Then a$ = Replace(a$, "Р", "с")
Dim i As Long
For i = 1 To Len(a$)
Select Case AscW(Mid$(a$, i, 1))
Case 902
Mid$(a$, i, 1) = ChrW(913)
Case 904
Mid$(a$, i, 1) = ChrW(917)
Case 906
Mid$(a$, i, 1) = ChrW(921)
Case 912
Mid$(a$, i, 1) = ChrW(921)
Case 905
Mid$(a$, i, 1) = ChrW(919)
Case 908
Mid$(a$, i, 1) = ChrW(927)
Case 911
Mid$(a$, i, 1) = ChrW(937)
Case 910
Mid$(a$, i, 1) = ChrW(933)
Case 940
Mid$(a$, i, 1) = ChrW(913)
Case 941
Mid$(a$, i, 1) = ChrW(917)
Case 943
Mid$(a$, i, 1) = ChrW(921)
Case 942
Mid$(a$, i, 1) = ChrW(919)
Case 972
Mid$(a$, i, 1) = ChrW(927)
Case 974
Mid$(a$, i, 1) = ChrW(937)
Case 973
Mid$(a$, i, 1) = ChrW(933)
Case 962
If osnum >= System_Windows_Vista Then
Mid$(a$, i, 1) = ChrW(963)
Else
Mid$(a$, i, 1) = ChrW(931)
End If
End Select

Next i
End If
    nSize = LCMapStringW(mLid, LCMAP_UPPERCASE, StrPtr(a$), nSize, StrPtr(kUpper), nSize)
End Function

Public Function kUpper2(a$, p As Variant) As String
'idea from Bonnie West, FROM VBFORUMS
Dim nSize As Long
    nSize = Len(a$)
    If nSize Then SysReAllocStringLen VarPtr(kUpper2), , nSize Else Exit Function
    Const LCMAP_UPPERCASE = &H200&
Dim mLid As Long
If p = 0 Then
mLid = Clid
Else
mLid = p
End If
If p = 1032 Then
''If osnum >= System_Windows_Vista Then a$ = Replace(a$, "Р", "с")
Dim i As Long
For i = 1 To Len(a$)
 Select Case AscW(Mid$(a$, i, 1))
Case 902
Mid$(a$, i, 1) = ChrW(913)
Case 904
Mid$(a$, i, 1) = ChrW(917)
Case 906
Mid$(a$, i, 1) = ChrW(921)
Case 912
Mid$(a$, i, 1) = ChrW(921)
Case 905
Mid$(a$, i, 1) = ChrW(919)
Case 908
Mid$(a$, i, 1) = ChrW(927)
Case 911
Mid$(a$, i, 1) = ChrW(937)
Case 910
Mid$(a$, i, 1) = ChrW(933)
Case 940
Mid$(a$, i, 1) = ChrW(913)
Case 941
Mid$(a$, i, 1) = ChrW(917)
Case 943
Mid$(a$, i, 1) = ChrW(921)
Case 942
Mid$(a$, i, 1) = ChrW(919)
Case 972
Mid$(a$, i, 1) = ChrW(927)
Case 974
Mid$(a$, i, 1) = ChrW(937)
Case 973
Mid$(a$, i, 1) = ChrW(933)
Case 962
Mid$(a$, i, 1) = ChrW(931)
End Select
Next i


End If
    nSize = LCMapStringW(mLid, LCMAP_UPPERCASE, StrPtr(a$), nSize, StrPtr(kUpper2), nSize)
End Function
Public Function klower(a$, p As Variant) As String
Const LCMAP_LOWERCASE As Long = &H100
Dim nSize As Long
    nSize = Len(a$)
    If nSize Then SysReAllocStringLen VarPtr(klower), , nSize Else Exit Function

Dim mLid As Long
If p = 0 Then
mLid = Clid
Else
mLid = p
End If
nSize = LCMapStringW(mLid, LCMAP_LOWERCASE, StrPtr(a$), nSize, StrPtr(klower), nSize)
a$ = klower
If p = 1032 Then
a$ = a$ & Chr(0)
a$ = Replace(a$, "С" & Chr(0), "Р")
a$ = Replace(a$, Chr(0), "")
a$ = Replace(a$, "С ", "Р ")
a$ = Replace(a$, "С$", "Р$")
a$ = Replace(a$, "С&", "Р&")
a$ = Replace(a$, "С.", "Р.")
a$ = Replace(a$, "С(", "Р(")
a$ = Replace(a$, "С_", "Р_")
a$ = Replace(a$, "С/", "Р/")
a$ = Replace(a$, "С\", "Р\")
a$ = Replace(a$, "С-", "Р-")
a$ = Replace(a$, "С+", "Р+")
a$ = Replace(a$, "С*", "Р*")
a$ = Replace(a$, "С" & vbCr, "Р" & vbCr)
a$ = Replace(a$, "С" & vbLf, "Р" & vbLf)
End If
klower = a$
End Function




Public Sub PushStage(basestack As basetask, dummy As Boolean)
' FROM 5 TO 3 REDUCE STACK USAGE
        With basestack.RetStack
               basestack.SubLevel = basestack.SubLevel + 1
                If dummy Then
                        .Push2long 0&, 0&
                        .Push2long 0&, 0&
                        .PushLong -2&
                        
                Else
                        .Push2long varhash.count, subHash.count
                        .Push2long var2used, sb2used
                        .PushLong -1&
                        numid.pushtop
                        funid.pushtop
                        strfunid.pushtop
                        funid.pushtop
                        basestack.ErrVars = var2used
                        basestack.SetSkip
                End If
        End With
       
End Sub
Public Sub PopStage(basestack As basetask)
        Dim one As Long
        With basestack.RetStack
        If .LookTopVal = -1 Then
        basestack.SubLevel = basestack.SubLevel - 1
           .drop 1
            var2used = .Pop2Long(sb2used)
            basestack.ErrVars = var2used
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            numid.poptop
            funid.poptop
            strfunid.poptop
            strid.poptop
        ElseIf .LookTopVal = -2 Then
        basestack.SubLevel = basestack.SubLevel - 1
        .drop 3  ' not 5
        End If
        End With
End Sub
Public Sub PushErrStage(basestack As basetask)
        With basestack.RetStack
            .Push2long varhash.count, subHash.count
            .Push2long basestack.SubLevel, sb2used
            .PushVal var2used
            .PushVal -4  ' from 6 to 4 entries
             basestack.ErrVars = var2used
        End With
End Sub
Public Sub PopErrStage(basestack As basetask)
Dim nok As Boolean, one As Long
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
            basestack.SubLevel = .Pop2Long(sb2used)
            var2used = basestack.ErrVars
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            Else
            .drop 2  ' not 4
            End If
        Else

        While basestack.RetStackTotal > 0
        Select Case .LookTopVal
        Case -1
            nok = True
        .drop 5  ' 7-2 reduced
        basestack.ResetSkip
        Case -2
            nok = True
            .drop 3 ' 5 - 2 reduced ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
         .drop 2  ' string in topval (gosub to label)
             nok = True
        End Select
        Wend
        End If
        End With
End Sub
Public Sub PopStagePartContinue(basestack As basetask, Parts As Long)
' drop until find a If
Dim nok As Boolean, target As Long, one As Long
        target = basestack.RetStackTotal - Parts
        If target < 0 Then target = 0
        While basestack.RetStackTotal > target
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
            basestack.SubLevel = .Pop2Long(sb2used)
            var2used = basestack.ErrVars
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            Else
            .drop 2 ' not 4
            End If
        Else

        While basestack.RetStackTotal > target
        Select Case .LookTopVal
        Case -1
            nok = True
        .drop 5 ' 7-2 reduced
        basestack.ResetSkip
        Case -2
            nok = True
            .drop 3 '5-2 reduced  ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
            Exit Sub
        End Select
        Wend
        End If
        End With
        Wend
End Sub
Public Sub PopStagePartContinue2(basestack As basetask, Parts As Long)
' drop until find a If
Dim nok As Boolean, target As Long, one As Long
        target = basestack.RetStackTotal - Parts
        If target < 0 Then target = 0
        While basestack.RetStackTotal > target
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
            basestack.SubLevel = .Pop2Long(sb2used)
            var2used = basestack.ErrVars
            varhash.ReduceHash .Pop2Long(one), var()
            subHash.ReduceHash one, sbf()
            basestack.ResetSkip
            basestack.ResetSkip
            Else
            .drop 2
            End If
        Else

        While basestack.RetStackTotal > target
        Select Case .LookTopVal
        Case -1
            Exit Sub
        Case -2
            nok = True
            .drop 3  ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
            Exit Sub
        End Select
        Wend
        End If
        End With
        Wend
End Sub

Public Sub PopStagePart(basestack As basetask, Parts As Long)
Dim nok As Boolean, target As Long
        target = basestack.RetStackTotal - Parts
        If target < 0 Then target = 0
        While basestack.RetStackTotal > target
        With basestack.RetStack
        If .LookTopVal = -4 Then
JUMPHERE:
           .drop 1
           basestack.ErrVars = CLng(.PopVal)
        If nok Then
           basestack.SubLevel = CLng(.PopVal)
            var2used = basestack.ErrVars
            sb2used = CLng(.PopVal)
            varhash.ReduceHash CLng(.PopVal), var()
            subHash.ReduceHash CLng(.PopVal), sbf()
            Else
            .drop 4
            End If
        Else

        While basestack.RetStackTotal > target
        Select Case .LookTopVal
        Case -1
            nok = True
        .drop 7
        Case -2
            nok = True
            .drop 5  ' never happen???
        Case -3
            .drop 3
            basestack.UseofIf = basestack.UseofIf - 1
        Case -4
            GoTo JUMPHERE
        Case Else
         .drop 2  ' string in topval (gosub to label)
             nok = True
        End Select
        Wend
        End If
        End With
        Wend
End Sub


Public Function GetNextLineNoTrim(c$) As String
Dim i, j$
i = InStr(c$, vbCrLf)
If i = 0 Then GetNextLineNoTrim = c$: c$ = vbNullString Else GetNextLineNoTrim = Left$(c$, i - 1): c$ = Mid$(c$, i)
End Function

Function expanddot(bstack As basetask, w$) As Boolean
Dim i As Integer, j As Long
For i = 1 To Len(w$)
If Mid$(w$, i, 1) = "." Then
    j = j + 1
Else
    Exit For
End If
Next i
w$ = Mid$(w$, j + 1)
If bstack.GetDotNew(w$, j) Then
If Len(here$) > 0 Then
If j = 1 Then
If Len(w$) > Len(here$) Then
    If Left$(w$, Len(here$) + 1) = here$ + "." Then w$ = Mid$(w$, Len(here$) + 2)
  
End If
End If
End If
expanddot = True
End If

End Function


Public Sub ProcessOper(bstack As basetask, first As Object, oper$, R As Variant, Lang As Long, Optional skip As Boolean = False)
Dim where As Long, w$, ok As Boolean
Dim soroslen As Long, flag As Boolean, backup As Object, oldkillvars As Boolean
flag = Not first Is Nothing
oldkillvars = bstack.nokillvars
If oper$ = "''" Then
bstack.nokillvars = True
End If
If Not oldkillvars Then PushStage bstack, False

soroslen = bstack.soros.Total
If soroslen < 0 Then SyntaxError: Exit Sub
' if flag Then bstack.soros.PushObj first
' change in Version 9.2 revision 3
 If flag Then
 Set backup = bstack.lastobj
 bstack.soros.PushObj bstack.lastobj
 Set bstack.lastobj = first
 End If
where = AllocVar()  '' var(where)
w$ = ChrW(&H1FFF) + CStr(where)
If here$ <> "" Then
varhash.ItemCreator here$ + "." + bstack.GroupName + w$, where
UnFloatGroup bstack, w$, where, bstack.lastobj, , True
Else
varhash.ItemCreator (w$), where
UnFloatGroup bstack, w$, where, bstack.lastobj, True, True
End If
var(where).FloatGroupName = w$
 If oper$ = "''" Then
    ok = MyRead(1, bstack, (w$), Lang)
 Else
    NeoCall2 bstack, w$ + "." + ChrW(&H1FFF) + oper$ + "()", ok
End If
If soroslen < bstack.soros.Total Then
    If soroslen + 1 = bstack.soros.Total And flag Then
    R = bstack.soros.PopVal
   If ok Or skip Then
   Set bstack.lastobj = Nothing
   ElseIf flag Then
   ' when we add two groups which we don't define operator now set result as the last group
       Set bstack.lastobj = backup
   End If
    bstack.DropNdot 2
    bstack.nokillvars = oldkillvars
    If Not oldkillvars Then PopStage bstack
    Exit Sub
    End If
End If
If ok And Not skip Then Set bstack.lastobj = CopyGroupObj(var(where)) Else Set bstack.lastobj = Nothing
bstack.DropNdot 2
bstack.nokillvars = oldkillvars
If Not oldkillvars Then PopStage bstack
End Sub
Public Sub ProcessOperRemove(first As Group)
Dim where As Long, w$, ok As Boolean
Dim soroslen As Long, flag As Boolean, backup As Object
Dim bstack As New basetask, ohere$
SwapStrings ohere$, here$
Set bstack.Sorosref = New mStiva
Set bstack.Owner = Form1.DIS
PushStage bstack, False
where = AllocVar()  '' var(where)
w$ = ChrW(&H1FFF) + CStr(where)
'If here$ <> "" Then
'varhash.ItemCreator here$ + "." + w$, where
'UnFloatGroup bstack, w$, where, bstack.lastobj, , True
'Else
varhash.ItemCreator (w$), where, , True
Set bstack.lastobj = first
UnFloatGroup bstack, w$, where, bstack.lastobj, True, True
'End If
var(where).FloatGroupName = w$
NeoCall2 bstack, w$ + "." + ChrW(&H1FFF) + "_%()", ok
PopStage bstack
SwapStrings ohere$, here$
End Sub


Function SizeY(bstack As basetask, SG, a$, s$, s1$, R As Variant) As Boolean
Dim r2 As Variant, r3 As Variant, r4 As Variant
    r3 = 0
    r4 = 0
    If IsStrExp(bstack, a$, s$) Then
    If Not FastSymbol(a$, ",") Then: MissParam a$: SizeY = False: Exit Function
    If Not IsStrExp(bstack, a$, s1$) Then: MissParam a$: SizeY = False: Exit Function
    If Not FastSymbol(a$, ",") Then: MissParam a$: SizeY = False: Exit Function
    If Not IsExp(bstack, a$, r2, , True) Then: MissParam a$: SizeY = False: Exit Function
    If FastSymbol(a$, ",") Then
        If Not IsExp(bstack, a$, r3, , True) Then
             MissParam a$: SizeY = False: Exit Function
        End If
            If FastSymbol(a$, ",") Then
                If Not IsExp(bstack, a$, r4, , True) Then
                    MissParam a$: SizeY = False: Exit Function
                End If
                r4 = Abs(Int(r4))
            End If
        End If
    On Error Resume Next
    R = nTextY(bstack, s$, s1$, CSng(r2), r3, r4)
    If Err.Number > 0 Then R = 0
    On Error GoTo 0
    If SG < 0 Then R = -R
    SizeY = FastSymbol(a$, ")", True)
    End If
End Function

Function SizeX(bstack As basetask, SG, a$, s$, s1$, R As Variant) As Boolean
Dim r2 As Variant, r3 As Variant, r4 As Variant
    r3 = 0
    r4 = 0
    If IsStrExp(bstack, a$, s$) Then
    If Not FastSymbol(a$, ",") Then SizeX = False: Exit Function
    If Not IsStrExp(bstack, a$, s1$) Then SizeX = False: Exit Function
    If Not FastSymbol(a$, ",") Then SizeX = False: Exit Function
    If Not IsExp(bstack, a$, r2, , True) Then SizeX = False: Exit Function
    If FastSymbol(a$, ",") Then
        If Not IsExp(bstack, a$, r3, , True) Then
           MissParam a$: SizeX = False: Exit Function
        End If
            If FastSymbol(a$, ",") Then
                If Not IsExp(bstack, a$, r4, , True) Then
                    MissParam a$: SizeX = False: Exit Function
                End If
                r4 = Abs(Int(r4))
            End If
    End If
    On Error Resume Next
    R = nText(bstack, s$, s1$, CSng(r2), r3, r4)
    If Err.Number > 0 Then R = 0
    On Error GoTo 0
    If SG < 0 Then R = -R
    SizeX = FastSymbol(a$, ")", True)
    End If

End Function

Public Function SpeedGroup(bstack As basetask, pppp As mArray, Prefix$, ByVal w$, B$, v As Long) As Long
Dim Vars As Long, Vname As Long, y1 As Long, subs As Long, snames As Long, i As Long, ec$, ohere$, p As Long
Dim depth As Long, loopthis As Boolean, v100 As Boolean, RetStackSize As Long, S3 As Long, rest1$
Dim safegroup As Group
Dim oldjump As Long, oldifctrl As Long, olduseofif As Long
Dim kolpo As Boolean, bb$, once As Boolean, subsfc As FastCollection
Dim Lang As Long, ok As Boolean, rv As Variant
Dim small$, sbi As Long
bstack.SetSkip
Vars = var2used: Vname = varhash.count
subs = sb2used: snames = subHash.count
numid.pushtop
funid.pushtop
strfunid.pushtop
funid.pushtop
Dim mm As mStiva2, tempRef As Object
If Prefix = "VAL" Then
' we stand as right value...
    If pppp Is Nothing Then GoTo fastexit
    ec$ = w$ + ")"
    If v >= 0 Then
        w$ = pppp.CodeName + CStr(v)
    Else
        w$ = pppp.CodeName + CStr(Abs(v))
    End If
    If Len(pppp.item(v).LastOpen) > 0 Then
        If GetVar(bstack, pppp.item(v).LastOpen, i) Then
jmp1995:
            Set safegroup = var(i)
            If safegroup.lasthere = here$ Then
                w$ = safegroup.GroupName
                w$ = Left$(w$, Len(w$) - 1)
            Else
                LinkGroup bstack, w$, var(i)
                makegroup bstack, w$, i
            End If
            bstack.tmpstr = w$ + Left$(B$, 1)
            BackPort B$
            If IsNumberNew(bstack, B$, rv, CLng(1), False) Then
                bstack.LastValue = rv
                SpeedGroup = 1
            End If
            GoTo fastexit
        End If
    End If
    
    If Not MyIsObject(pppp.item(v)) Then
        GoTo fastexit
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
    If safegroup.IamApointer Then
        If Len(safegroup.lasthere) > 0 And Len(safegroup.GroupName) > 0 Then
            w$ = safegroup.lasthere + "." + safegroup.GroupName
            bstack.tmpstr = w$ + Left$(B$, 1)
            BackPort B$
            If Not IsNumberNew(bstack, B$, rv, CLng(1), False) Then SpeedGroup = 0: GoTo fastexit1
            bstack.LastValue = rv
            SpeedGroup = 1
            GoTo fastexit
        End If
        If safegroup.link.LastOpen <> vbNullString Then
            If GetVar(bstack, safegroup.link.LastOpen, i) Then GoTo jmp1995
        ElseIf safegroup.LastOpen <> vbNullString Then
            If GetVar(bstack, (safegroup.LastOpen), y1, True) Then
                If safegroup.lasthere$ = here$ Then
                    w$ = safegroup.LastOpen
                Else
                    If safegroup.lasthere$ = vbNullString Then
                        w$ = safegroup.LastOpen
                    Else
                        w$ = safegroup.lasthere$ + "." + safegroup.LastOpen
                    End If
                End If
                Set safegroup = safegroup.link
                GoTo cont3030
            Else
                safegroup.lasthere = vbNullString
                safegroup.LastOpen = vbNullString
            End If
        End If
        y1 = globalvarGroup(w$, 0#, , here$ = vbNullString)
        Set safegroup = safegroup.link
        UnFloatGroup bstack, w$, y1, safegroup, , True
        globalvarGroup w$, y1, True, True
cont3030:
    Else
        If Len(safegroup.LastOpen) > 0 Then
            If Not GetVar(bstack, safegroup.LastOpen, y1, True) Then
                GoTo fastexit
            End If
            GoTo conthere0001
        End If
        y1 = globalvarGroup(w$, 0#, , here$ = vbNullString)
        If Not safegroup.IamFloatGroup Then
            Set safegroup = CopyGroupObj(safegroup)
        ElseIf safegroup.IamApointer Then
            Set safegroup = CopyGroupObj(safegroup.link)
        End If
        UnFloatGroup bstack, w$, y1, safegroup, , True
        var(y1).FloatGroupName = ec$
        globalvarGroup w$, y1, True, True
    End If
    Set safegroup = pppp.item(v)
conthere0001:
    If Left$(B$, 1) <> "." And Left$(B$, 1) <> "(" And var(y1).HasParameters Then
        bstack.tmpstr = w$ + "(" + Left$(B$, 1)
    Else
        bstack.tmpstr = w$ + Left$(B$, 1)
    End If
    BackPort B$
    If IsNumberNew(bstack, B$, rv, CLng(1), False) Then
        SpeedGroup = 1
        If pppp.Arr Then
            If safegroup.IamApointer Then
                Set tempRef = pppp.GroupRef
                safegroup.link.ToDelete = True
                Set safegroup.LinkRef = CopyGroupObj(var(y1))
                Set safegroup.link.LinkRef = pppp.GroupRef
            Else
                Set tempRef = pppp.GroupRef   'pppp.item(v).Link
                pppp.item(v).ToDelete = True
                Set pppp.item(v) = CopyGroupObj(var(y1))
                If TypeOf pppp.itemObject(v) Is Group Then Set pppp.item(v).LinkRef = pppp.GroupRef
            End If
        Else
            If safegroup.IamApointer Then
                CopyGroup1 var(y1), safegroup.link
                If v >= 0 Then
                    Set bstack.lastpointer = safegroup
                    Set bstack.lastobj = safegroup.link
                End If
            Else
                CopyGroup1 var(y1), safegroup
            End If
        End If
        If bstack.lastobj Is Nothing Then
            bstack.LastValue = rv
        Else
            bstack.LastValue = 0#
            GoTo fastexit
        End If
    End If
    Set bstack.lastobj = Nothing
    GoTo fastexit
ElseIf Prefix = "VAL$" Then
    ec$ = w$ + ")"
    If v >= 0 Then
        w$ = pppp.CodeName + CStr(v)
    Else
        w$ = pppp.CodeName + CStr(Abs(v))
    End If
    If Len(pppp.item(v).LastOpen) > 0 Then
        If GetVar(bstack, pppp.item(v).LastOpen, i) Then
jmp2000:
            Set safegroup = var(i)
            If safegroup.lasthere = here$ Then
                w$ = safegroup.GroupName
                w$ = Left$(w$, Len(w$) - 1)
            Else
                LinkGroup bstack, w$, var(i)
                makegroup bstack, w$, i
            End If
            bstack.tmpstr = w$ + Left$(B$, 1)
            BackPort B$
            If IsStr1(bstack, B$, bb$) Then
                bstack.LastValue = bb$
                SpeedGroup = 1
            End If
            GoTo fastexit
        End If
    End If
    If Not MyIsObject(pppp.item(v)) Then
        GoTo fastexit
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
    If safegroup.IamApointer Then
        If Len(safegroup.lasthere) > 0 And Len(safegroup.GroupName) > 0 Then
            w$ = safegroup.lasthere + "." + safegroup.GroupName
            bstack.tmpstr = w$ + Left$(B$, 1)
            BackPort B$
            If Not IsStr1(bstack, B$, bb$) Then SpeedGroup = 0: GoTo fastexit1
            bstack.LastValue = bb$
            SpeedGroup = 1
            GoTo fastexit
        End If
        If safegroup.link.LastOpen <> vbNullString Then
            If GetVar(bstack, safegroup.link.LastOpen, i) Then GoTo jmp2000
        ElseIf safegroup.LastOpen <> vbNullString Then
            If GetVar(bstack, (safegroup.LastOpen), y1, True) Then
                If safegroup.lasthere$ = here$ Then
                    w$ = safegroup.LastOpen
                Else
                    If safegroup.lasthere$ = vbNullString Then
                        w$ = safegroup.LastOpen
                    Else
                        w$ = safegroup.lasthere$ + "." + safegroup.LastOpen
                    End If
                End If
                Set safegroup = safegroup.link  '' ADDED rev 6 ver 9.8
                GoTo cont5050
            Else
                safegroup.lasthere = vbNullString '' ADDED rev 6 ver 9.8
                safegroup.LastOpen = vbNullString
            End If
        End If
        y1 = globalvarGroup(w$, 0#, , here$ = vbNullString) '' fix it rev 6 ver 9.8
        Set safegroup = safegroup.link
        UnFloatGroup bstack, w$, y1, safegroup, , True
        var(y1).FloatGroupName = w$
        globalvarGroup w$, y1, True, True
cont5050:
    Else
        If Len(safegroup.LastOpen) > 0 Then
            If Not GetVar(bstack, safegroup.LastOpen, y1, True) Then
                GoTo fastexit
            End If
            GoTo conthere000
        End If
        y1 = globalvarGroup(w$, 0#, , here$ = vbNullString)
        If Not safegroup.IamFloatGroup Then
            Set safegroup = CopyGroupObj(safegroup)
        ElseIf safegroup.IamApointer Then
            Set safegroup = CopyGroupObj(safegroup.link)
        End If
        UnFloatGroup bstack, w$, y1, safegroup, , True
        var(y1).FloatGroupName = ec$
        globalvarGroup w$, y1, True, True
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
conthere000:
    If Left$(B$, 1) = "." Then
        bstack.tmpstr = w$ + Left$(B$, 1)
        BackPort B$
        Set bstack.lastpointer = Nothing
        If IsStr1(bstack, B$, bb$) Then GoTo conthere
    ElseIf var(y1).HasValue Then
        If var(y1).HasParameters Then
            If pppp.Arr Then
                If Left$(B$, 1) = "(" Then
                     bstack.tmpstr = w$ + "$" + Left$(B$, 1)
                Else
                    bstack.tmpstr = w$ + "$(" + Left$(B$, 1)
                End If
                BackPort B$
                Set bstack.lastpointer = Nothing
                If IsStr1(bstack, B$, bb$) Then GoTo conthere
            ElseIf FastSymbol(B$, ")(", , 2) Then
                bstack.tmpstr = w$ + "(" + Left$(B$, 1)
                BackPort B$
                 Set bstack.lastpointer = Nothing
                If IsStr1(bstack, B$, bb$) Then GoTo conthere
            Else
                ec$ = w$ + "(" + BlockParam(B$) + ")"
                B$ = Mid$(B$, 2)
                If IsNumber(bstack, ec$, rv) Then GoTo conthere
            End If
        Else
            If IsStr1(bstack, w$ + "$", bb$) Then
            End If
        End If
conthere:
        If pppp.Arr Then
            If safegroup.IamApointer Then
                Set tempRef = pppp.GroupRef   'pppp.item(v).Link
                safegroup.link.ToDelete = True
                Set safegroup.LinkRef = CopyGroupObj(var(y1))
                Set safegroup.link.LinkRef = pppp.GroupRef
            Else
                Set tempRef = pppp.GroupRef   'pppp.item(v).Link
                pppp.item(v).ToDelete = True
                Set pppp.item(v) = CopyGroupObj(var(y1))
                If TypeOf pppp.itemObject(v) Is Group Then Set pppp.item(v).LinkRef = pppp.GroupRef
            End If
        Else
            If safegroup.IamApointer Then
                CopyGroup1 var(y1), safegroup.link
                If v >= 0 Then
                    Set bstack.lastpointer = safegroup
                    Set bstack.lastobj = safegroup.link
                End If
            Else
                CopyGroup1 var(y1), safegroup
            End If
        End If
    End If
    SpeedGroup = 1
    Set bstack.lastobj = Nothing
    If bstack.lastobj Is Nothing Then
        bstack.LastValue = bb$
    Else
        bstack.LastValue = vbNullString
    End If
    GoTo fastexit
ElseIf Prefix = "FOR" Then
        Set mm = New mStiva2
        oldjump = bstack.jump: oldifctrl = bstack.IFCTRL: olduseofif = bstack.UseofIf
        RetStackSize = bstack.RetStackTotal
        If v = -1 Then
            y1 = 0
            If w$ = "THIS" Or w$ = "ауто" Then
                w$ = "THIS"  ' look this other time..
            ElseIf Len(w$) > 5 Then
                If Len(bstack.UseGroupname) > 0 Then
                    If w$ = "SUPERCLASS" Or w$ = "упеяйкасг" Then
                        Set pppp = New mArray: pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
                        v = 0
                        w$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
                        If Right$(here$, 2) = "()" Then
                            If Right$(here$, 3) = ChrW(&H1FFD) + "()" Then
                                If GetVar3(bstack, bstack.fHere + "." + w$, y1) Then
                                    If TypeOf var(y1) Is Group Then
                                        If Not var(y1).SuperClassList Is Nothing Then
                                            Set pppp.item(v) = var(y1).SuperClassList
                                            v100 = True
                                            GoTo CONT104010
                                        End If
                                    End If
                                End If
                            ElseIf GetVar(bstack, bstack.Parent.originalname + "." + w$, y1) Then
                                If TypeOf var(y1) Is Group Then
                                    If Not var(y1).SuperClassList Is Nothing Then
                                        Set pppp.item(v) = var(y1).SuperClassList
                                        v100 = True
                                        GoTo CONT104010
                                    End If
                                End If
                            End If
                        End If
                        If GetVar3(bstack, w$, y1) Then
                            If TypeOf var(y1) Is Group Then
                                If Not var(y1).SuperClassList Is Nothing Then
                                    Set pppp.item(v) = var(y1).SuperClassList
                                    v100 = True
                                    GoTo CONT104010
                                End If
                            End If
                        ElseIf GetVar(bstack, bstack.originalname + "." + w$, y1) Then
                            If TypeOf var(y1) Is Group Then
                                If Not var(y1).SuperClassList Is Nothing Then
                                    Set pppp.item(v) = var(y1).SuperClassList
                                    v100 = True
                                    GoTo CONT104010
                                End If
                            End If
                        Else
                            MyEr "Double use of SuperClass", "дИПКч ВЯчСГ ТГР уПЕЯЙКэСГР"
                            GoTo fastexit
                        End If
                    End If
                End If
            End If
            If GetVar3(bstack, w$, y1) Then
                If TypeOf var(y1) Is Group Then
                    If var(y1).IamApointer Then
                        If Len(var(y1).link.LastOpen) > 0 Then
                            If GetVar(bstack, var(y1).link.LastOpen, i) Then GoTo jmp1998
                        End If
                        Set safegroup = var(y1)
                        If safegroup.link.IamFloatGroup Then
                            v = 0
                            Do While safegroup.link.IamApointer
                                Set safegroup = safegroup.link
                                If safegroup.link Is Nothing Then GoTo fastexit
                            Loop
                            Set pppp = BoxGroupVar(safegroup.link)
                            Set pppp.refgroup = safegroup
                            safegroup.link.PointerPtr = ObjPtr(safegroup)
                            safegroup.PointerPtr = ObjPtr(safegroup)
                            w$ = pppp.CodeName + CStr(Abs(v))
                            GoTo CONT1040102
                        Else
                            If Len(var(y1).lasthere) = 0 Then
                                If var(y1).IamGlobal Then
                                    bstack.MoveNameDot "*" + var(y1).GroupName
                                Else
                                    bstack.MoveNameDot var(y1).GroupName
                                End If
                            Else
                                bstack.MoveNameDot var(y1).lasthere + "." + var(y1).GroupName
                            End If
                            v = -1
                        End If
                    Else
                        If var(y1).IamGlobal Then
                            bstack.MoveNameDot "*" + w$
                        Else
                       ' If Len(var(y1).Patch) = 0 Then
                       '     bstack.MoveNameDot w$
                       ' Else
                            bstack.MoveNameDot var(y1).Patch
                        '    End If
                        End If
                    End If
                Else
                    MissingGroup
                    GoTo fastexit
                End If
            Else
                If w$ = "THIS" Then
                    bstack.MoveNameDot w$
                Else
                    MissingGroup
                    GoTo fastexit
                End If
            End If
        Else
            If pppp.Arr Then
                If pppp.item(v).IamApointer Then
                    Set safegroup = pppp.item(v)
                    If Not safegroup.link.IamFloatGroup Then
                        If Len(safegroup.lasthere) = 0 Then
                            If safegroup.IamGlobal Then
                                bstack.MoveNameDot "*" + safegroup.GroupName
                            Else
                                bstack.MoveNameDot safegroup.GroupName
                            End If
                        Else
                            bstack.MoveNameDot safegroup.lasthere + "." + safegroup.GroupName
                        End If
                        v = -1
                        GoTo contheretoo1
                    End If
                End If
            Else
                Set safegroup = pppp.item(v)
            End If
CONT104010:
            If pppp.refgroup Is Nothing Then
                If v >= 0 Then
                    w$ = pppp.CodeName + CStr(v)
                Else
                    w$ = pppp.CodeName + CStr(Abs(v))
                End If
                If Len(pppp.item(v).LastOpen) > 0 Then
                    If GetVar(bstack, pppp.item(v).LastOpen, i) Then
jmp1998:
                        Set safegroup = var(i)
                        If safegroup.lasthere = here$ Then
                            w$ = safegroup.GroupName
                            w$ = Left$(w$, Len(w$) - 1)
                        Else
                            LinkGroup bstack, w$, var(i)
                            makegroup bstack, w$, i
                        End If
                        y1 = -1
                        Set safegroup = var(i)
                        GoTo conthere145
                    End If
                Else
                    If Not safegroup Is Nothing Then
                        If Not safegroup.link Is Nothing Then
                            If Len(safegroup.link.LastOpen) > 0 Then
                                w$ = safegroup.link.LastOpen
                            End If
                        End If
                    End If
                End If
            Else
                If Not pppp.refgroup.LastOpen = vbNullString Then
                    If pppp.refgroup.lasthere$ = here$ Then
                        w$ = pppp.refgroup.LastOpen
                    Else
                        w$ = pppp.refgroup.lasthere$ + "." + pppp.refgroup.LastOpen
                    End If
                End If
            End If
            If Not MyIsObject(pppp.item(v)) Then GoTo fastexit
            If Not safegroup Is Nothing Then
                Set safegroup = pppp.item(v)
                If safegroup Is Nothing Then GoTo fastexit
                If safegroup.IamApointer Then
                    If safegroup.link.IamFloatGroup Then
                        Set pppp = BoxGroupVar(safegroup.link)
                        Set pppp.refgroup = safegroup
                        safegroup.LastOpen = w$
                        safegroup.lasthere = here$
                        Set safegroup = Nothing
                        v = 0
                    Else
                        bstack.MoveNameDot safegroup.GroupName
                        v = -1
                        GoTo contheretoo1
                    End If
                End If
            End If
CONT1040102:
            On Error Resume Next
    ' check for iamglobal ??
            If Not GetVar3(bstack, w$, y1) Then
                y1 = globalvarGroup(w$, CVar(New Group))
                If pppp.item(v).IamApointer Then
                    UnFloatGroup bstack, w$, y1, pppp.item(v).link, , True
                Else
                    UnFloatGroup bstack, w$, y1, pppp.item(v), , True
                End If
      '          globalvarGroup w$, y1, True, True
                Set safegroup = pppp.item(v)
                
                safegroup.LastOpen = w$
                var(y1).lasthere = here$
                var(y1).LastOpen = w$
                var(y1).PointerPtr = safegroup.PointerPtr
            End If
            If Err.Number > 0 Then
mer123:
                MyEr "This For can't be done", " аУТч Г цИА ДЕМ ЛПОЯЕъ МА ЦъМЕИ"
                Err.Clear
                GoTo fastexit
            End If
           
           
           
           
conthere145:
            If y1 = -1 Then
            If Not safegroup Is Nothing Then
                If safegroup.IamGlobal Then
                    bstack.MoveNameDot "*" + var(i).Patch
                Else
                    bstack.MoveNameDot var(i).Patch
                End If
            Else
                bstack.MoveNameDot var(i).Patch
            End If
            Else
            If Not safegroup Is Nothing Then
                If safegroup.IamGlobal Then
                    bstack.MoveNameDot "*" + var(y1).Patch
                Else
                    bstack.MoveNameDot var(y1).Patch
                End If
            Else
                bstack.MoveNameDot var(y1).Patch
            End If
            
            End If
        '  depth = depth + 1
        End If
contheretoo1:
        mm.DataVal CDbl(y1)
        If v100 Then v = -100: v100 = False
        mm.DataVal CDbl(v)
        mm.DataObj pppp
        Do While FastSymbol(B$, ",")
            y1 = -1
            If Len(B$) < 129 Then
                i = IsLabelDot(vbNullString, B$, w$, y1)
            Else
                rest1$ = Left$(B$, 128)
                i = IsLabelDot(vbNullString, rest1$, w$, y1)
                If Len(rest1$) = 0 Then
                    i = IsLabelDot(vbNullString, B$, w$, y1)
                Else
                    B$ = Mid$(B$, 129 - Len(rest1$))
                End If
            End If
            If y1 > 0 Then
                If Left$(w$, 2) = ".." Then
                    i = -bstack.GetDotNew(w$, y1) * i
                End If
            Else
                y1 = 0
            End If
            If i > 4 Then
                Set safegroup = Nothing
                If neoGetArray(bstack, w$, pppp) Then
                    If NeoGetArrayItem(pppp, bstack, w$, v, B$) Then
                        If pppp.ItemType(v) = mgroup Then
                            If Left$(B$, 1) = "." Then
                                If SpeedGroup(bstack, pppp, "VAL", "", B$, v) = 1 Then
                                    If Typename(bstack.lastobj) = mgroup Then
                                        Set pppp = New mArray
                                        pppp.Arr = False
                                        Set pppp.GroupRef = bstack.lastobj
                                        v = -2
                                    Else
                                        MissingGroup
                                        GoTo fastexit
                                    End If
                                Else
                                GoTo fastexit
                            End If
                        End If
contheretoo:
                        w$ = pppp.CodeName + CStr(Abs(v))
                        If pppp.item(v).IamApointer Then
                            If Len(pppp.item(v).link.LastOpen) > 0 Then
                                If GetVar(bstack, pppp.item(v).link.LastOpen, i) Then
                                    GoTo jmp1998
                                End If
                            End If
                            If pppp.item(v).link.IamFloatGroup Then
                                Set safegroup = pppp.item(v)
                                Set pppp = BoxGroupObj(safegroup.link)
                                Set pppp.refgroup = safegroup
                                v = 0
                            Else
                                w$ = pppp.item(v).GroupName
                                GoTo conthere3
                            End If
                        End If
                        If safegroup Is Nothing Then
                            Set safegroup = pppp.item(v)
                        Else
                            If Not pppp.item(v).IamApointer Then
                            If pppp.refgroup Is Nothing Then
                                Set safegroup = pppp.item(v)
                            End If
                            pppp.item(v).PointerPtr = ObjPtr(safegroup)
                        End If
                    End If
                    If safegroup.LastOpen <> vbNullString Then
                        If GetVar(bstack, safegroup.LastOpen, y1, , , True) Then
                            w$ = safegroup.LastOpen
                            y1 = globalvarGroup(w$, (y1), True)
                            GoTo cont1010
                        Else
                            safegroup.LastOpen = vbNullString
                        End If
                    End If
contheretoo123:
                    y1 = globalvarGroup(w$, CVar(New Group))
                    UnFloatGroup bstack, w$, y1, pppp.item(v), , True
                    'globalvarGroup w$, y1, True, True
                    var(y1).LastOpen = w$
                    var(y1).lasthere = here$
                    safegroup.LastOpen = w$
                    safegroup.lasthere = here$
                    var(y1).PointerPtr = pppp.item(v).PointerPtr
cont1010:
        ' where look for global???
                    bstack.MoveNameDot var(y1).Patch  ' w$ 'myUcase(w$)
                    depth = depth + 1
                    mm.DataVal CDbl(y1)
                    If v100 Then v = -100: v100 = False
                    mm.DataVal CDbl(v)
                    mm.DataObj pppp
                Else
                    MissingGroup
                    GoTo normalexit
                End If
            Else
                SyntaxError
                GoTo normalexit
            End If
        Else
            NotExistArray
            GoTo normalexit
        End If
    ElseIf i = 1 Then
        If w$ = "THIS" Or w$ = "ауто" Then
            w$ = "THIS"
            If bstack.GroupName = vbNullString Then w$ = vbNullString
        Else 'If Len(w$) > 5 Then
            If Len(bstack.UseGroupname) > 0 Then
                If w$ = "SUPERCLASS" Or w$ = "упеяйкасг" Then
                    Set pppp = New mArray: pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
                    v = 0
                    w$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
JUMPTHERE:
                    y1 = 0
                    If GetVar3(bstack, (w$), y1, , , , w$) Then
                        If TypeOf var(y1) Is Group Then
                            If var(y1).IamApointer Then GoTo contpointer
                            If Not var(y1).SuperClassList Is Nothing Then
                                Set pppp.item(v) = var(y1).SuperClassList
                                v100 = True
                                GoTo contheretoo
                            End If
                        End If
                    Else
                        If w$ = "SUPERCLASS" Or w$ = "упеяйкасг" Then
                            MyEr "Double use of SuperClass", "дИПКч ВЯчСГ ТГР уПЕЯЙКэСГР"
                        Else
                            MissVarName
                        End If
                        GoTo fastexit1
                    End If
                Else
                    GoTo JUMPTHERE
                End If
            End If
                If y1 = 0 Then
contpointer:
                    If GetPointer(bstack, (w$)) Then
                        If bstack.lastpointer.link.IamFloatGroup Then
                            Set safegroup = bstack.lastpointer
                            Do While safegroup.link.IamApointer
                                Set safegroup = safegroup.link
                                If safegroup.link Is Nothing Then GoTo fastexit
                            Loop
                            Set pppp = BoxGroupObj(safegroup.link)
                            Set pppp.refgroup = safegroup
                            i = 5
                            v = 0
                            Set bstack.lastobj = Nothing
                            Set bstack.lastpointer = Nothing
                            w$ = pppp.CodeName + CStr(Abs(v))
                            If Len(safegroup.link.LastOpen) > 0 Then
                                If GetVar(bstack, safegroup.link.LastOpen, i) Then GoTo jmp1998
                            End If
                            Set pppp.item(v) = safegroup.link
                            pppp.item(v).PointerPtr = ObjPtr(safegroup)
                            Set pppp.refgroup = safegroup
                            GoTo contheretoo123
                        Else
                            If bstack.lastpointer.lasthere = vbNullString Then
                                w$ = "*" + bstack.lastpointer.GroupName
                            Else
                            w$ = bstack.lastpointer.lasthere + "." + bstack.lastpointer.GroupName
                            If GetVar3(bstack, w$, i) Then
                                If var(i).IamGlobal Then
                                    w$ = "*" + bstack.lastpointer.GroupName
                                End If
                            End If
                            End If
                            Set bstack.lastobj = Nothing
                            Set bstack.lastpointer = Nothing
                        End If
                    End If
                End If
            End If
conthere3:
            mm.DataVal 0#
            mm.DataVal CDbl(-1)
            mm.DataObj pppp
            bstack.MoveNameDot w$
            depth = depth + 1
        ElseIf i = 3 Then
        '' ????
            If IsStrExp(bstack, (w$), w$) Then
            End If
        ElseIf i = 6 Then
            bstack.tmpstr = w$ + Left$(B$, 1)
            BackPort B$
            ' ??????
            If IsStr1(bstack, B$, w$) Then
            End If
        Else
            SyntaxError
            GoTo normalexit
        End If
    Loop

   
    If FastSymbol(B$, "{") Then
    ec$ = block(B$)
    Dim nd&
    Dim oldLL As Long
    TraceStore bstack, nd&, B$, 0
    oldLL = bstack.addlen
    ' delete true here
    If True Then
        SpeedGroup = 1
        kolpo = False
        once = True
        i = 1
        ohere$ = here$
        Do
            bstack.addlen = oldLL
            bb$ = Mid$(ec$, i)
subsentry10:
            kolpo = False
            Select Case Execute(bstack, bb$, kolpo, False, loopthis)   ' this is a major point
            Case 0
faultback:
thh:
            If bstack.RetStackTotal - RetStackSize > 0 Then
                bstack.UseofIf = olduseofif
                bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
            End If
                bstack.addlen = nd&
                If bstack.ErrorOriginal <> 0 Then
                B$ = bb$
                Else
                B$ = bb$ & B$
                
                End If
                SpeedGroup = -1
                Set bstack.lastobj = Nothing
                GoTo normalexit
            Case 1
                bstack.addlen = nd&
                S3 = bstack.OriginalCode
              
                If S3 < 0 Then
                    TestShowSub = var(-S3).code
                Else
                    TestShowSub = sbf(S3).sb
                End If
                TestShowBypass = False
                If LastErNum <> 0 Then B$ = vbNullString
                If FastSymbol(B$, "}") Then
                    If once Then Exit Do
                Else
                    If Len(bb$) > 0 Then B$ = Right$(ec$, Len(bb$)) + B$
                End If
                here$ = ohere$
                Exit Do
            Case 2
                bstack.addlen = 0
                If Not kolpo Then
                    i = 1
                    If bb$ <> "" Then
                        If bb$ = ChrW$(0) Then
                            'If RetStackSize = bstack.RetStackTotal And bstack.RetStackLookTopVal < 0 Then
                                ' this is a return form other block
                            If RetStackSize >= bstack.RetStackTotal Then
                                If bstack.IsDecimal Then
                                SpeedGroup = 2
                                SwapStrings B$, bb$
                                bstack.addlen = nd&
                                GoTo fastexit
                                End If
                            End If
                            'If bstack.IsInRetStackNumberLong(p) Then
                                'If LastErNum = -1 Then
                                 '   bstack.RetStack.PushLong p
                                 '   SpeedGroup = 0
                                 '   bstack.addlen = nd&
                                 '   GoTo fastexit
                                'End If
                                If Not bstack.IsInRetStackString(small$) Then
                                If LastErNum = -1 Then
                                    SpeedGroup = 0
                                    bstack.addlen = nd&
                                    GoTo fastexit
                                End If
                                    p = bstack.isPop3Long(S3, sbi)
                                    If p > 0 Then
                                        If S3 > 0 Then
                                            bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                        ElseIf S3 = 0 Then
                                            bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                        Else
                                            bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                        End If
                                        If trace Then
                                            TestShowBypass = True
                                            If TestShowBypass Then
                                                If S3 < 0 Then
                                                    TestShowSub = var(-S3).code
                                                ElseIf S3 = 0 Then
                                                    TestShowSub = ec$ + B$
                                                    sbi = Len(B$)
                                                Else
                                                    TestShowSub = sbf(S3).sb
                                                End If
                                            End If
                                            bstack.addlen = sbi
                                        End If
                                        PopStage bstack
                                        GoTo subsentry10
                                    Else
fulty:
                                        MyEr "Fault in Return", "кэХОР СТГМ еПИСТЯОЖч"
                                        bstack.Flush
                                        Exit Do
                                    End If
                                Else
                                    If InStr(small$, " ") > 0 Then
                                        bstack.PushSecondThird S3, sbi
                                        If searchsub(bstack.OriginalCode, small$, i, S3, bb$) Then
                                            If Len(small$) <> 0 Then If Not MyRead(7, bstack, small$, 1) Then GoTo thh
                                            GoTo contSub
                                        ElseIf bstack.IamChild Then
                                            If searchsub(FindPrevOriginal(bstack), small$, i, S3, bb$) Then
                                                If Len(small$) <> 0 Then If Not MyRead(7, bstack, small$, 1) Then GoTo thh
contSub:
                                                If Len(bb$) = 0 Then
                                                    If S3 < 0 Then
                                                        bb$ = Mid$(var(-S3).code, i)
                                                    Else
                                                        bb$ = Mid$(sbf(S3).sb, i)
                                                    End If
                                                    sbi = 0
                                                Else
                                                    If S3 < 0 Then
                                                        sbi = Len(var(-S3).code) - i - Len(bb$)
                                                    Else
                                                        sbi = Len(sbf(S3).sb) - i - Len(bb$)
                                                    End If
                                                End If
                                                If trace Then
                                                    TestShowBypass = True
                                                    If TestShowBypass Then
                                                        If S3 < 0 Then
                                                            TestShowSub = var(-S3).code
                                                        Else
                                                            TestShowSub = sbf(S3).sb
                                                        End If
                                                    End If
                                                    bstack.addlen = Len(TestShowSub) - i + 1 - Len(bb$)
                                                End If
                                                GoTo subsentry10
                                            Else
jumpbad:
                                                badSubNotFound
                                                If bstack.IsDecimal Then
                                                    p = bstack.Pop3Long(S3, sbi)
                                                    If S3 > 0 Then
                                                       bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                                    ElseIf S3 = 0 Then
                                                      bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                                    Else
                                                       bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                                    End If
                                                End If
                                                bstack.RetStackDrop 3 ' 5
                                                GoTo thh
                                            End If
                                        Else
                                            'If small$ <> "" Then badSubNotFound
                                            GoTo jumpbad
                                        End If
                                End If
                            End If
                        ElseIf bb$ = "BREAK" Then
                                SpeedGroup = 2
                                GoTo breakexit
                        Else
                            If subsfc Is Nothing Then Set subsfc = New FastCollection
                            If subsfc.ExistKey(bb$) Then
                                i = subsfc.Value
                                If subsfc.sValue = 0 Then
                                    If i = 0 Or i > Len(ec$) Then
                                        SwapStrings B$, bb$
                                        SpeedGroup = 2
                                        bstack.addlen = nd&
                                        Exit Do
                                    Else
                                        bb$ = Mid$(ec$, i)
                                    End If
                                Else
                                    S3 = subsfc.sValue
                                    If S3 < 0 Then
                                        If i = 0 Or i > Len(var(-S3).code$) Then
                                            SwapStrings B$, bb$
                                            SpeedGroup = 2
                                            bstack.addlen = nd&
                                            Exit Do
                                        Else
                                            GoTo AGAINGOTOLAMBDA
                                        End If
                                    Else
                                        If i = 0 Or i > Len(sbf(S3).sb) Then
                                            SwapStrings B$, bb$
                                            SpeedGroup = 2
                                            bstack.addlen = nd&
                                            Exit Do
                                        End If
                                        GoTo AGAINGOTO
                                    End If
                                End If
                               
                                GoTo subsentry10
                            Else
                                If S3 = 0 Then
                                    i = PosLabel(bb$, ec$)
                                    If i = 0 Or i > Len(ec$) Then
                                        GoTo checkother
                                    Else
                                        subsfc.ItemCreator2 bb$, i, 0
                                        bb$ = Mid$(ec$, i)
                                        GoTo subsentry10
                                    End If
                                End If
checkother:
                                If S3 < 0 Then
                                    i = PosLabel(bb$, var(-S3).code$)
                                    If i = 0 Or i > Len(var(-S3).code$) Then
                                        SwapStrings B$, bb$
                                        SpeedGroup = 2
                                        bstack.addlen = nd&
                                        Exit Do
                                    End If
                                    subsfc.ItemCreator2 bb$, i, S3
AGAINGOTOLAMBDA:
                                    If bstack.SubLevel > 0 Then
                                                If Len(var(-S3).code$) - i > sbi Then
                                                    bb$ = Mid$(var(-S3).code$, i, Len(var(-S3).code$) - i - sbi)
                                                Else
                                                    bb$ = Mid$(var(-S3).code$, i)
                                                    sbi = 0
                                                End If
                                            Else
                                                bb$ = Mid$(var(-S3).code$, i)
                                                sbi = 0
                                            End If
                    
                                Else
                                    i = PosLabel(bb$, sbf(S3).sb)
                                    If i = 0 Or i > Len(sbf(S3).sb) Then
                                        SwapStrings B$, bb$
                                        SpeedGroup = 2
                                        bstack.addlen = nd&
                                        Exit Do
                                    End If
                                    subsfc.ItemCreator2 bb$, i, S3
AGAINGOTO:
                                    If bstack.SubLevel > 0 Then
                                                If Len(sbf(S3).sb) - i > sbi Then
                                                    bb$ = Mid$(sbf(S3).sb, i, Len(sbf(S3).sb) - i - sbi)
                                                Else
                                                    bb$ = Mid$(sbf(S3).sb, i)
                                                    sbi = 0
                                                End If
                                            Else
                                                bb$ = Mid$(sbf(S3).sb, i)
                                                sbi = 0
                                            End If
                                End If
                                
                                GoTo subsentry10
                            End If
                        End If
                    Else
                        loopthis = False
                    End If
                Else
                    If kolpo Then B$ = "BREAK"
                    once = kolpo
                    SpeedGroup = 2: Set bstack.lastobj = Nothing
                    bstack.addlen = nd&
                    GoTo breakexit
                End If
            Case Else
                If FastSymbol(B$, "}") Then
                    If once Then bstack.addlen = nd&: Exit Do
                Else
                    If Len(bb$) > 0 Then B$ = Right$(ec$, Len(bb$)) + B$
                End If
                here$ = ohere$
                bstack.addlen = nd&
                Exit Do
            End Select
            here$ = ohere$
            If myexit(bstack) Then SpeedGroup = 1:  bstack.addlen = nd&: Exit Do
        Loop
            Else
            SpeedGroup = Abs(FastSymbol(B$, "}"))
        End If
    End If
breakexit:
    Set bstack.lastobj = Nothing
    While mm.Total > 0
        y1 = mm.PopVal
        v = mm.PopVal
        Set pppp = mm.PopObj
        If y1 < 0 Then
        ElseIf v <> -1 Then
            If v <> -100 Then
                If Not MyIsObject(pppp.item(v)) Then
                    pppp.item(v).ToDelete = True
                    Set pppp.item(v) = CopyGroupObj(var(y1), pppp.IHaveClass)
                Else
                    If Not pppp.refgroup Is Nothing Then
                        Set safegroup = pppp.refgroup
                        safegroup.link.ToDelete = True
                        Set safegroup.LinkRef = CopyGroupObj(var(y1))
                        safegroup.link.PointerPtr = ObjPtr(safegroup)
                       ' pppp.item(v).ToDelete = True
                        safegroup.LastOpen = vbNullString
                        safegroup.lasthere = vbNullString
                        Set safegroup = Nothing
                    Else
                        pppp.item(v).ToDelete = True
                        Set pppp.item(v) = CopyGroupObj(var(y1), Not pppp.item(v).link Is Nothing)
                    End If
                End If
            Else
                If pppp.Arr Then
                    v = 0
                    If Not MyIsObject(pppp.item(v)) Then
                    Set pppp.item(v) = CopyGroupObj(var(y1))
                    Else
                    Set pppp.item(v) = CopyGroup1(var(y1), pppp.item(v))
                    End If
                Else
                    pppp.item(v).ToDelete = True
                    Set pppp.item(v) = CopyGroupObj(var(y1))
                End If
            End If
            Set tempRef = pppp.GroupRef  '  pppp.item(v).Link
            If Not pppp.IsEmpty Then
                If Not tempRef Is Nothing Then If TypeOf pppp.itemObject(v) Is Group Then Set pppp.item(v).LinkRef = tempRef
            End If
        End If
    Wend
normalexit:
    bstack.DropNdot depth + 1
' new
    If SpeedGroup > 1 Then
        If bstack.RetStackTotal - RetStackSize > 0 Then
            bstack.UseofIf = olduseofif
            bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
        End If
    End If
    bstack.jump = oldjump
    bstack.IFCTRL = oldifctrl
Else
    i = w$ = "."
    If v >= 0 Then
        w$ = pppp.CodeName + CStr(v)
    Else
        w$ = pppp.CodeName + CStr(Abs(v))
    End If
    If Len(pppp.item(v).LastOpen) > 0 Then
        If GetVar(bstack, pppp.item(v).LastOpen, i) Then
jump1991:
            Set safegroup = var(i)
            If safegroup.lasthere = here$ Then
                w$ = safegroup.GroupName
                w$ = Left$(w$, Len(w$) - 1)
            Else
                LinkGroup bstack, w$, var(i)
                makegroup bstack, w$, i
            End If
            Set safegroup = Nothing
            GoTo cont2020
        End If
    End If
    Set safegroup = pppp.item(v)
    If safegroup Is Nothing Then GoTo fastexit
    If safegroup.IamApointer Then
        If safegroup.link.IamFloatGroup Then
            If Len(safegroup.link.LastOpen) > 0 Then
                If GetVar(bstack, safegroup.link.LastOpen, i) Then GoTo jump1991
            End If
            Set pppp = BoxGroupVar(safegroup.link)
            pppp.item(0).PointerPtr = ObjPtr(safegroup)
            v = 0
        Else
            If Left$(Prefix$, 1) = "@" Then
                w$ = safegroup.lasthere + "." + safegroup.GroupName
                GoTo cont2020
            Else
                bstack.MoveNameDot safegroup.lasthere + "." + safegroup.GroupName
                v = 0
                GoTo contheretoo1
            End If
        End If
    Else
        y1 = globalvarGroup(w$, CVar(New Group))
    End If
    If safegroup.LastOpen <> vbNullString Then
        If GetVar(bstack, (safegroup.LastOpen), y1, True) Then
            If safegroup.lasthere$ = here$ Then
                w$ = safegroup.LastOpen
            Else
                If safegroup.lasthere$ = vbNullString Then
                    w$ = safegroup.LastOpen
                Else
                    w$ = safegroup.lasthere$ + "." + safegroup.LastOpen
                End If
            End If
            GoTo cont2020
        Else
            If safegroup.link.IamFloatGroup Then
                safegroup.LastOpen = vbNullString
                safegroup.lasthere$ = vbNullString
            End If
        End If
        UnFloatGroup bstack, w$, y1, pppp.item(v), , True
        globalvarGroup w$, y1, True, True
    Else
        If y1 = 0 Then y1 = globalvarGroup(w$, y1)
        UnFloatGroup bstack, w$, y1, pppp.item(v), , True
        globalvarGroup w$, y1, True, True
        var(y1).PointerPtr = pppp.item(v).PointerPtr
        pppp.item(v).lasthere = here
        pppp.item(v).LastOpen = w$
        var(y1).lasthere = here
        var(y1).LastOpen = w$
    End If
cont2020:
    If Len(Prefix) > 0 Then
        If Prefix = "@READ2" Then
            NeoCall2 bstack, w$ + "." + ChrW(&H1FFF) + ":=()", ok
            SpeedGroup = Abs(ok)
            GoTo CONTlastEtnum
        ElseIf Prefix = "@READ" Then
            If i Then
                bstack.tmpstr = w$ + "." + Left$(B$, 1)
                BackPort B$
                SpeedGroup = Abs(MyRead(1, bstack, B$, 1))
                GoTo CONTlastEtnum
            Else
                If var(y1).HasStrValue Then
                    SpeedGroup = Abs(MyRead(1, bstack, w$ + "$", 1))
                    GoTo CONTlastEtnum
                Else
                   SpeedGroup = Abs(MyRead(1, bstack, (w$), 1))
                    GoTo CONTlastEtnum
                End If
            End If
        Else
            If i Then
                bstack.tmpstr = vbCrLf + Prefix + " " + w$ + "." + Left$(B$, 1)
                BackPort B$
            Else
                If var(y1).HasStrValue Then
                    bstack.tmpstr = vbCrLf + Prefix + " " + w$ + "$ " + Left$(B$, 1)
                    BackPort B$
                Else
                    bstack.tmpstr = vbCrLf + Prefix + " " + w$ + " " + Left$(B$, 1)
                    BackPort B$
                End If
            End If
        End If
    Else
        If Left$(B$, 2) = Chr$(3) + "(" Then
           If var(y1).HasStrValue Then
               bstack.tmpstr = w$ + "$( "
               Mid$(B$, 1, 2) = "  "
               BackPort B$
           Else
               bstack.tmpstr = w$ + "( " ''+ Left$(b$, 1)
               Mid$(B$, 1, 2) = "  "
               BackPort B$
           End If
        Else
            If Left$(B$, 1) = Chr$(3) Then Mid$(B$, 1, 1) = " "
            If MaybeIsSymbol(B$, "/*-+=~^&|<>") Then
                bstack.tmpstr = w$ + Left$(B$, 1)
                BackPort B$
            Else
                bstack.tmpstr = w$ + "." + Left$(B$, 1)
                BackPort B$
            End If
        End If
    End If
    SpeedGroup = Execute(bstack, B$, True, , , , , True)
        
CONTlastEtnum:
    If LastErNum <> 0 Then
        If FK$(13) = vbNullString Then FK$(13) = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))
    End If
    If safegroup Is Nothing Then
    ' DO NOTHING
    ElseIf safegroup.IamApointer Then
        If safegroup.LastOpen = vbNullString Then
            If Len(safegroup.lasthere) = 0 Then
                safegroup.link.lasthere = vbNullString
                safegroup.link.LastOpen = vbNullString
                Set tempRef = pppp.GroupRef
                safegroup.link.ToDelete = True
                Set safegroup.LinkRef = CopyGroupObj(var(y1))
                Set safegroup.link.LinkRef = pppp.GroupRef
            End If
        End If
    ElseIf Vars < y1 Then
        Set safegroup.LinkRef = Nothing
        Set tempRef = pppp.GroupRef
        pppp.item(v).ToDelete = True
        Set pppp.item(v) = CopyGroupObj(var(y1))
        Set safegroup.LinkRef = tempRef
        var(y1) = 0&
    End If
End If

fastexit:
If SpeedGroup <= 0 Then SpeedGroup = SpeedGroup + 1

fastexit1:
bstack.ResetSkip
var2used = Vars
varhash.ReduceHash Vname, var()
sb2used = subs
subHash.ReduceHash snames, sbf()
numid.poptop
funid.poptop
strfunid.poptop
strid.poptop

End Function



Public Sub Thing(w$, v$)
'' from w$ input this value V$...
'' general input
On Error Resume Next
Dim it As Long, pppp As mArray
If Len(w$) < 2 Then Exit Sub

If AscW(w$) = 65 Then
On Error Resume Next
Err.Clear
Set pppp = var(Split(Mid$(w$, 2))(0)) ''  "A...16charRef....ItemNo"
If Err.Number > 0 Then Exit Sub
it = val(Split(Mid$(w$, 2))(1))
If pppp.ItemType(it) = doc Then
pppp.item(it).textDoc = v$  ' no checked yet
Else
pppp.item(it) = pppp.item(it) + v$
End If
ElseIf AscW(w$) = 86 Then
it = val("0" & Mid$(w$, 2))          ''"VItemNo"
If Typename(var(it)) = doc Then
var(it).textDoc = v$    ' no checked yet
Else
var(it) = var(it) + v$
End If
Else
' CAN'T READ
End If
End Sub
Function rinstr(a As String, B As String, Optional ByVal fr As Long) As Long
Dim i
i = Len(a)
fr = i - fr
If fr < 0 Or fr > i Then fr = i + 1

If i > 0 Then rinstr = InStrRev(a, B, fr)
End Function
Function rinstrb(a As String, B As String, Optional ByVal fr As Long) As Long
'
Dim i As Long, j As Long
fr = fr - LenB(B) + 1
If fr < 0 Then fr = LenB(a) + 1
Do
j = i
i = InStrB(j + 1, a, B)

Loop Until i = 0 Or i > fr

rinstrb = j
End Function



Function RMAX(ByVal q As Single, ByVal w As Single) As Single
If q > w Then
RMAX = q
Else
RMAX = w
End If
End Function

Function RMIN(ByVal q As Single, ByVal w As Single) As Single
If q < w Then
RMIN = q
Else
RMIN = w
End If
End Function



Public Function GetTaskId() As Long
taskid = taskid + 1
If taskid = 10000 Then taskid = 1
GetTaskId = taskid

End Function
Sub Dispose()
'use strtemp
On Error Resume Next
Dim R$
While ISSTRINGA(kill2$, R$)
KillFile strTemp + R$
Wend
End Sub
'' this is from Trick (VbForums)
Sub Proto1(ByVal addr As Long, basestack As basetask, rest$, Lang As Long, resp As Boolean)
End Sub


Public Sub NeoSubMain()
' need to read registry form sub main
On Error Resume Next
Dim i As Long
For i = 0 To 32
    Pow2(i) = CCur(2 ^ i)
    Pow2minusOne(i) = Pow2(i) - 1
Next i
'' From 9.6 by default we have no round to 13d for double

EditTabWidth = 6
tParam.cbSize = LenB(tParam)
tParam.iTabLength = 6
ReportTabWidth = 8
RoundDouble = False
SetUp64 ' for Encoder64/Decoder64
AskCancelGR = "айуяо"
AskOkGR = "емтанеи"
LoadFileCaptionGR = "жЭЯТЫСЕ аЯВЕъО"
SaveFileCaptionGR = "сЧСЕ аЯВЕъО"
SelectFolderCaptionGR = "еПИКОЦч жАЙщКОУ"
SelectFolderButtonGR = "*СЩЯЕ ДЕНИэ ЦИА ЕПИКОЦч*"
FontSelectorGr = "цЯАЛЛАТОСЕИЯэ"
ColorSelectorGr = "вЯЫЛАТОКЭЦИО"
SetUpGR = "яУХЛъСЕИР"
AskCancelEn = "CANCEL"
AskOkEn = "OK"
SetUpEn = "Set Up"
LoadFileCaptionEn = "Load File"
SaveFileCaptionEn = "Save File"
SelectFolderCaptionEn = "Select Folder"
SelectFolderButtonEn = "*slide right to select*"
FontSelectorEn = "Font Selector"
ColorSelectorEn = "Color Selector"

BigPi = CDec("31415926535897932384626433832") * 1E-28
INK$ = vbNullString
'UINK$ = VbNullString
MINK$ = vbNullString
MKEY$ = vbNullString
RandomizeIt rndbase, 0
ClearCatalog
SetLibHdls
LCID_DEF = LCID_def1() Mod &H10000
DefCodePage = GetCodePage(OsInfo.LangNonUnicodeCode)
UserCodePage = DefCodePage
UseTabInForm1Text1 = True
ShowBooleanAsString = True
Clid = LCID_DEF
If Clid = 1032 Then
    DefBooleanString = ";аКГХщР;ьЕУДщР"
Else
    DefBooleanString = ";\T\r\u\e;\F\a\l\s\e"
End If
    NowDec$ = GetlocaleString(LOCALE_SDECIMAL)
    NowThou$ = GetlocaleString(LOCALE_STHOUSAND)
If dv15 <> 0 Then
l_complete = False
s_complete = False
DisableProcessWindowsGhosting
Set HelpStack = New basetask
Set oprinter = New cDIBSection
Set Basestack1.Sorosref = globalstack
Set subHash = New sbHash
Set varhash = New Hash
Set comhash = New sbHash
Set numid = New idHash
Set funid = New idHash
Set strid = New idHash
Set strfunid = New idHash
GoTo there
End If
dv15 = 1440 / DpiScrX
GetMonitorsNow
DisableProcessWindowsGhosting
With ScrInfo(Console)
If IsWine Then
players(0).MAXXGRAPH = .Width - 1
players(0).MAXYGRAPH = .Height - 1
End If
End With
'' BY DEAFULT IS FALSE
priorityOr = False  '  TRUE OR FALSE AND FALSE GIVE -1 BECAUSE OR AND XOR PROCESS LEFT FIRST TRUE OR ( FALSE AND FALSE)
'' WITH priorityOr = FALSE WE HAVE FLAT SYSTEM.........TRUE OR FALSE AND FALSE GIVE 0
OperatingSystem
 dv20 = 24.5
Randomize uintnew(CCur(timeGetTime))
JetPrefixUser = JetPrefixHelp
JetPostfixUser = JetPostfixHelp
JetPostfix = JetPostfixHelp
JetPrefix = JetPrefixHelp
 
basickey = "Software\m2000v5\"
' by default
'AddTwipsTop = 4 * Screen.TwipsPerPixelY
casesensitive = False
pagio$ = "LATIN"
pagiohtml$ = "DARK"
REFRESHRATE = 40
SizeDialog = 1
helpSizeDialog = 1
Settings = "time,normal,push"
With ScrInfo(Console)
selectorLastX = .Height / 4 + .Left
selectorLastY = .Width / 4 + .Top
AskLastX = .Height / 4 + .Left
AskLastY = .Width / 4 + .Top
End With
sb2used = 0
ReDim sbf(500) As modfun
var2used = 0
ReDim var(3000) As Variant
   StartingRes
   'Dim iccex As tagInitCommonControlsEx
   'With iccex
     ' .lngSize = LenB(iccex)
    '  .lngICC = ICC_USEREX_CLASSES
   'End With
   'InitCommonControlsEx iccex

clickMe2 = -1


''Dim soros As New mStiva
Dim t As Long
ReDim q(0) As target

Set Basestack1.Sorosref = globalstack

taskid = 999
DisableMidi
beat = 400 ' beat of 1/16
baseNote = 23
octava = 4
NOTA = 0
ENTASI = 127   '' volume
voices(0) = "CC#"
there:
Randomize
allcommands comhash
NumberId numid, funid, numidbackup, funidbackup
StringId strid, strfunid, stridbackup, strfunidbackup
TimeZones zones
Set TaskMaster = New TaskMaster
TaskMaster.Interval = 5
beeperBEAT = 300
MediaPlayer1.FileName = vbNullString
defFontname = "Verdana"
my_system = OperatingPlatform
vol = 50
MediaPlayer1.setLeftVolume vol * 10
MediaPlayer1.setRightVolume vol * 10
deep = 10000

ReDim MyDM(1 To 1) As Byte
DXP = Screen.TwipsPerPixelX
DYP = Screen.TwipsPerPixelY
Load Form5

If Not l_complete Then

Exit Sub

Else
Form1.something

End If

End Sub
Sub TerminateM2000()
NoAction = False
DelTemp
'Set DisStack.Owner = Nothing

Set Basestack1.Owner = Nothing
Set LastGlist = Nothing
Set LastGlist2 = Nothing
If form5iamloaded Then
   If IsWine Then
   Form5.BackPort
   Else
   Unload Form5
   End If
End If
End Sub
Public Sub terminatefinal()
RemoveAllFonts
Set globalstack = Nothing
Set Basestack1 = Nothing
CloseAllConnections  ' new for ADO we keep objects not the connections
CleanupLibHandles
Set globalstack = Nothing
Set mycoder = Nothing
Set subHash = Nothing
Set comhash = Nothing
Set numid = Nothing
Set funid = Nothing
Set strid = Nothing
Set strfunid = Nothing
Set Prof = Nothing
Set MediaPlayer1 = Nothing
Set MediaBack1 = Nothing
On Error Resume Next
Erase sbf()
Erase var()
s_complete = False
l_complete = False
ResetTokenFinal  ' sure for GDI release token
End Sub
Function GetArr(bstack As basetask, B$, p As Variant, s$, skip As Long) As Boolean
Dim pppp As mArray, x1 As Long, usehandler As mHandler
x1 = 1
Set pppp = New mArray: pppp.myarrbase = 0: pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
If skip = 1 Then GoTo firstexp Else If skip = 2 Then GoTo firststr
If IsExp(bstack, B$, p) Then
firstexp:
            x1 = x1 + 1
            pppp.SerialItem 0, x1, 10
            If bstack.lastobj Is Nothing Then
                pppp.item(x1 - 2) = p
            Else
                If TypeOf bstack.lastobj Is Group Then
                bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(x1 - 2) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
ElseIf IsStrExp(bstack, B$, s$, Len(bstack.tmpstr) = 0) Then
firststr:
            x1 = x1 + 1
            pppp.SerialItem 0#, x1, 10
            If bstack.lastobj Is Nothing Then
                pppp.item(x1 - 2) = s$
            Else
            If TypeOf bstack.lastobj Is Group Then
                bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(x1 - 2) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
End If
Do While MaybeIsSymbol(B$, ",)")
IsSymbol B$, ","
If lookOne(B$, ")") Then

pppp.SerialItem 0, x1 - 1, 10
Exit Do
ElseIf IsExp(bstack, B$, p) Then
x1 = x1 + 1
            pppp.SerialItem 0, x1, 10
            If bstack.lastobj Is Nothing Then
                pppp.item(x1 - 2) = p
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(x1 - 2) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
ElseIf IsStrExp(bstack, B$, s$, Len(bstack.tmpstr) = 0) Then
x1 = x1 + 1
            pppp.SerialItem 0, x1, 10
            If bstack.lastobj Is Nothing Then
                pppp.item(x1 - 2) = s$
            Else
                If TypeOf bstack.lastobj Is Group Then
                    bstack.lastobj.ToDelete = False
                End If
                Set pppp.item(x1 - 2) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If


End If

Loop
p = 0
Set usehandler = New mHandler
Set bstack.lastobj = usehandler
usehandler.t1 = 3
Set usehandler.objref = pppp
Set usehandler = Nothing
If FastSymbol(B$, ")#", , 2) Then

GetArr = ExpMatrix(bstack, B$, p)
If GetArr Then
If bstack.lastobj Is Nothing Then
            If Typename(p) = "String" Then
            s$ = p
            bstack.soros.PushStr s$
            bstack.tmpstr = "@LETTER$ " + Left$(B$, 1)
            Else
            bstack.soros.PushVal p
            bstack.tmpstr = "@NUMBER " + Left$(B$, 1)
            End If
            BackPort B$
ElseIf TypeOf bstack.lastobj Is mHandler Then
Set usehandler = bstack.lastobj
If usehandler.t1 <> 3 Then
            bstack.soros.PushObj bstack.lastobj
            Set bstack.lastobj = Nothing
            bstack.tmpstr = "@STACKITEM() " + Left$(B$, 1)
            BackPort B$


End If
End If
End If

Else
GetArr = FastSymbol(B$, ")")
End If

End Function
Function IsExp(basestack As basetask, a$, R As Variant, Optional ByVal noand1 As Boolean = True, Optional flatobject As Boolean = False, Optional Comp As Boolean = True) As Boolean
Dim par As Long, parin As Long
If LastErNum = -2 Then LastErNum = 0
If a$ = vbNullString Or a$ = vbCrLf Then Exit Function
IsExp = IsExpA(basestack, a$, R, par, noand1, (Comp))

again:
If par > 0 Then
If lookOne(a$, ",") Then
'parin = par
'Set basestack.lastobj = Nothing
IsExp = GetArr(basestack, a$, R, "", 1)
If LastErNum = -2 Then IsExp = False

If IsExp Then
par = par - 1

If basestack.lastobj Is Nothing Then
IsExp = IsExpA(basestack, a$, R, par, noand1, Comp, True)
End If
If par > 0 Then
GoTo again
End If
End If
End If
End If
If Not IsExp Then
'If LastErNum1 = -1 Then IsExp = False: Exit Function
If basestack.usestack Then
IsExp = IsNumber(basestack, a$, R)
End If
End If
If LastErNum = -2 Then IsExp = False
While par > 0
IsExp = FastSymbol(a$, ")")
par = par - 1
Wend
If flatobject Then Set basestack.lastobj = Nothing
End Function
Function rightoperator(bstack As basetask, aa$, po As Variant) As Boolean
Dim R As Variant, ac As Variant, MUL As Long, R1 As Variant
R1 = 1
MUL = 0
''second  loop Logic...
Do
    If Fast2Symbol(aa$, "**", 2, "^", 1) Then
            ' get from right number or expression
            If IsNumber(bstack, aa$, R, True) Then
            Set bstack.lastobj = Nothing
                On Error Resume Next
                po = po ^ R
                If Err.Number Then
                Err.Clear
                po = Infinity()
                End If
            ElseIf FastSymbol(aa$, "(") Then
                If IsExp(bstack, aa$, R, , True) Then
                On Error Resume Next
                po = po ^ R
                If Err.Number Then
                Err.Clear
                po = Infinity()
                End If
                
                    If Not FastSymbol(aa$, ")") Then ' тГМ ОПОъА ТГМ ЬэВМОУЛЕ  ЕЛЕъР ЙАИ ТГМ ПЕТэЛЕ
                        rightoperator = False
                        Exit Function
                    End If
                Else
                    rightoperator = False
                    Exit Function
                End If
            Else
                rightoperator = False
                Exit Function
            End If
    ElseIf MUL > 0 Then
            ' do it before we find next / or *
            Select Case MUL
            Case 500
            bstack.soros.DataVal R1
             R1 = 1
            Case 1
                po = R1 * po
            
            Case 2
                If po = 0 Then
                    'DIVISION BY ZERO
                
                    MyErMacro aa$, "division by zero", "ДИАъЯЕСГ ЛЕ ТО ЛГДщМ"
                
                    rightoperator = False
                    Exit Function
                Else
                    po = R1 / po
                End If
            End Select
            R1 = po
            MUL = 0
    ElseIf FastSymbol(aa$, "*") Then
            If logical(bstack, aa$, R) Then
                MUL = 1
                R1 = po
                po = R
            ElseIf FastSymbol(aa$, "(") Then
                If IsExp(bstack, aa$, R, , True) Then
                    MUL = 1
                    R1 = po
                    po = R
                    If Not FastSymbol(aa$, ")") Then
                        rightoperator = False
                        Exit Function
                    End If
                Else
                    rightoperator = False
                    Exit Function
                End If
            Else
                rightoperator = False
                Exit Function
            End If
    ElseIf FastSymbol(aa$, "/") Then
            If logical(bstack, aa$, R) Then
                MUL = 2
                R1 = po
                po = R
            ElseIf FastSymbol(aa$, "(") Then
                If IsExp(bstack, aa$, R, , True) Then
                    MUL = 2
                    R1 = po
                    po = R
                    If Not FastSymbol(aa$, ")") Then
                        rightoperator = False
                        Exit Function
                    End If
                Else
                    rightoperator = False
                    Exit Function
                End If
            Else
                rightoperator = False
                Exit Function
            End If
    
        Else
    rightoperator = True
         Exit Do
        End If
Loop
End Function
Function IsExpA(bstack As basetask, aa$, rr As Variant, parenthesis As Long, Optional ByVal noand As Boolean = True, Optional ByVal Comp As Boolean = True, Optional ByPass As Boolean = False) As Boolean
Dim R As Variant, ac As Variant, po As Variant, MUL As Long, R1 As Variant, ut$, back As Variant
Dim logic As Boolean, l As Boolean, park As Object, objlist As mStiva, rightlevel As Long, usehandler As mHandler
On Error Resume Next
IsExpA = False
If aa$ = vbNullString Then Exit Function
rr = 0
Do While FastOperator(aa$, "(", 1)
parenthesis = parenthesis + 1
Loop
If parenthesis > 0 Then Comp = True: noand = True
po = CDbl(1)
ac = 0#
' sign

Do
' first loop remove sign(s)

    Do
        If FastSymbol1(aa$, "-") Then
            po = -po
        ElseIf Not FastSymbol1(aa$, "+") Then
            Exit Do
        End If
    Loop
again:
    If logical(bstack, aa$, R, parenthesis, , ByPass) Then
again2:
      If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
            If usehandler.t1 = 4 Then
                R = usehandler.index_cursor * usehandler.sign: Set bstack.LastEnum = usehandler.objref
                If po < 0 Then R = -R: po = -po: usehandler.sign = -usehandler.sign
            End If
            GoTo cont111333
        ElseIf lookTwoSame(aa$, "/") Then
        ElseIf MaybeIsSymbol(aa$, "/*-+=~^&|<>?") Then
        
                '' get operator
                Dim ss$, ss1$
                If TypeOf bstack.lastobj Is Group Then
                
                If Not bstack.lastpointer Is Nothing Then
                If bstack.lastpointer.IamFloatGroup Then
                Set bstack.lastobj = bstack.lastpointer
                Else
                With bstack.lastobj
                    ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                End With
                 IsNumber bstack, ut$, R
                End If
                Set bstack.lastpointer = Nothing
                End If
                
                MUL = MyTrimL(aa$)
                
            If Mid$(aa$, MUL, 1) Like "[<>]" Then
                If MaybeIsSymbol(Mid$(aa$, MUL + 1, 1), "=>") Then
                    ss$ = Mid$(aa$, MUL, 2)
                    Mid$(aa$, 1, MUL + 1) = space(MUL + 1)
                Else
                    ss$ = Mid$(aa$, MUL, 1)
                    Mid$(aa$, 1, MUL) = space(MUL)
                End If
            Else
                If MaybeIsSymbol(Mid$(aa$, MUL + 1, 1), "[^|!~=*/]") Then
                    ss$ = Mid$(aa$, MUL, 2)
                    Mid$(aa$, 1, MUL + 1) = space(MUL + 1)
                Else
                
                    If Mid$(aa$, MUL, 2) = "->" Then GoTo LeaveIt
                    ss$ = Mid$(aa$, MUL, 1)
                    Mid$(aa$, 1, MUL) = space(MUL)
                    End If
            End If
               If po = -1 Then
                    'Set park = Nothing
                    If bstack.lastobj.HasUnary Then ProcessOper bstack, Nothing, "-:", R, (0)
                    po = -po
                End If
withoper:
                Set park = bstack.lastobj
                Set bstack.lastobj = Nothing
                
againoper:
                If ss$ Like "[<>=]*" Then
                If IsExp(bstack, aa$, R, False) Then
                If bstack.lastobj Is Nothing Then
                If Not park Is Nothing Then
                If TypeOf park Is Group Then
                        ProcessOper bstack, park, ss$, R, 1
                        MUL = 1  ' why
                        GoTo cont4567
                    Else
                        MissingGroup
                    End If
                    Else
                    MissingGroup
                    End If
                Else
                    If (TypeOf bstack.lastobj Is Group) And (TypeOf park Is Group) Then
                        ProcessOper bstack, park, ss$, R, 1
                        MUL = 1  ' why
                        GoTo cont4567
                    Else
                        MissingGroup
                    End If
                    End If
                Else
                    MissNumExpr
                End If
                IsExpA = False
                Exit Function
                End If

                Do While MaybeIsSymbol(aa$, "+-")
                    If FastSymbol1(aa$, "-") Then po = -po
                    FastSymbol1 aa$, "+"
                Loop
               
                If Not IsSymbol(aa$, "(") Then
getnextnum:
                If IsNumber(bstack, aa$, R) Then
                ' check if we have group
                If bstack.lastobj Is Nothing Then MissingGroup: IsExpA = False: Exit Function
                If Not TypeOf bstack.lastobj Is Group Then MissingGroup: IsExpA = False: Exit Function
                If Not bstack.lastpointer Is Nothing Then
                    If bstack.lastpointer.IamFloatGroup Then
                    If bstack.lastpointer Is NullGroup Then
                        Set bstack.lastobj = New Group
                        bstack.lastobj.BeginFloat 0
                        bstack.lastobj.EndFloat
                    Else
                        Set bstack.lastobj = bstack.lastpointer
                        
                   
                End If
                Else
                With bstack.lastobj
                    ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                End With
                 IsNumber bstack, ut$, R
                End If
                Set bstack.lastpointer = Nothing
                End If
                ' process unary if we have one
                If po = -1 Then
                    If bstack.lastobj.HasUnary Then ProcessOper bstack, Nothing, "-:", R, (0)
                    po = -po
                End If
                
processobjlist:
                
                If Not bstack.lastobj Is Nothing Then
                    If TypeOf bstack.lastobj Is Group Then
                If Not bstack.lastpointer Is Nothing Then
                If bstack.lastpointer.IamFloatGroup Then
                Set bstack.lastobj = bstack.lastpointer
                Else
                With bstack.lastobj
                    ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                End With
                 IsNumber bstack, ut$, R
                End If
                Set bstack.lastpointer = Nothing
                End If
                    
                    MUL = MyTrimL(aa$)
                If lookTwoSame(aa$, "/") Then
                ElseIf MaybeIsSymbol(Mid$(aa$, MUL, 1), "/*-+=~^&|<>?") Then
                
                                    
                
                If MaybeIsSymbol(Mid$(aa$, MUL, 2), ">=") Then
                            GoTo groupoperation
                            ElseIf InStr(bstack.lastobj.highpriorityoper, "[R" + Mid$(aa$, MUL, 2) + "]") Then
                            ss1$ = Mid$(aa$, MUL, 2)
                             Mid$(aa$, 1, MUL + Len(ss1$) - 1) = space(MUL + Len(ss1$) - 1)
                            If objlist Is Nothing Then Set objlist = New mStiva
                                objlist.PushObj park
                                objlist.PushStr ss$
                                Set park = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                ss$ = ss1$
                                rightlevel = rightlevel + 1
                                GoTo againoper
                            Else
                            If rightlevel > 0 Then
                            rightlevel = rightlevel - 1
                            GoTo comehere
                            
                             
                            End If
                    ss1$ = Mid$(aa$, MUL, 1)
                    End If
                    If Mid$(aa$, MUL, 2) = "->" Then GoTo groupoperation
                    If InStr(bstack.lastobj.highpriorityoper, "[" + ss1$ + "]") Then
                    Mid$(aa$, 1, MUL + Len(ss1$) - 1) = space(MUL + Len(ss1$) - 1)
                    If InStr(bstack.lastobj.highpriorityoper, "[" + ss$ + "]") Then
                    ProcessOper bstack, park, ss$, R, 1
                    
                    MUL = 1
                    If objlist Is Nothing Then Set objlist = New mStiva
                    Set park = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    ss$ = ss1$
                    GoTo againoper
                  
                    Else

                     If objlist Is Nothing Then Set objlist = New mStiva
                    objlist.PushObj park
                    objlist.PushStr ss$
                    Set park = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    ss$ = ss1$
                    GoTo againoper
                    
                    End If
                    Else
                    
                      ' why

                    If objlist Is Nothing Then Set objlist = New mStiva
                    If objlist.IsEmpty Then
                    ProcessOper bstack, park, ss$, R, 1
                    
                    MUL = 1
                    GoTo again2
                    Else
comehere:
                    ProcessOper bstack, park, ss$, R, 1
                    MUL = 1
                    Set park = bstack.lastobj
                            If Not objlist Is Nothing Then
                                If Not objlist.IsEmpty Then
                                    ss$ = objlist.PopStr
                                    Set park = objlist.PopObj
                                    ProcessOper bstack, park, ss$, R, 1
                                    GoTo again2
                                End If
                            End If
                    GoTo again2
                    End If
                    End If
                    Else
                    
                    
                    If objlist Is Nothing Then
                                    
                                        ProcessOper bstack, park, ss$, R, 1
                                        Set objlist = New mStiva
                                        If ss1$ <> "" Then
                                    objlist.PushObj park
                    objlist.PushStr ss$
                    Set park = bstack.lastobj
                    ss$ = ss1$
                    GoTo againoper
                    MUL = 1
                    End If
                    GoTo again2
                    Else
                    '
                    If objlist.IsEmpty Then
                    ProcessOper bstack, park, ss$, R, 1
                    MUL = 1
                    GoTo again2
                    Else
                    
                     ProcessOper bstack, park, ss$, R, 1
                    MUL = 1
                    ss$ = objlist.PopStr
                    Set park = objlist.PopObj
                    GoTo groupoperation

                    End If
                    'End If
                    End If
                    
                    
                    End If
                    End If
                     If InStr(bstack.lastobj.highpriorityoper, "[" + ss$ + "]") Then
                     ProcessOper bstack, park, ss$, R, 1
                     ss$ = ss1$
                    MUL = 1
                    Set park = bstack.lastobj
                     GoTo getnextnum
                     Else
                    If objlist Is Nothing Then Set objlist = New mStiva
                    
                    objlist.PushObj park
                    objlist.PushStr ss$
                    Set park = bstack.lastobj
                    ss$ = ss1$
                    ss1 = vbNullString
                    GoTo getnextnum
                   End If
                    
                End If
                    GoTo groupoperation
                Else
                        IsExpA = False
                        Exit Function
                End If
                ElseIf IsExp(bstack, aa$, R, False) Then
                If Not ss$ Like "[<>=]*" Then FastSymbol1 aa$, ")"
groupoperation:
                    If Not (bstack.lastobj Is Nothing) And Not (park Is Nothing) Then
                        If (TypeOf bstack.lastobj Is Group) And (TypeOf park Is Group) Then
                            ProcessOper bstack, park, ss$, R, 1
                            MUL = 1  ' why
                            If Not objlist Is Nothing Then
                                If Not objlist.IsEmpty Then
                                    ss$ = objlist.PopStr
                                    Set park = objlist.PopObj
                                    GoTo processobjlist
                                
                                Else
                                Set park = bstack.lastobj
                                End If
                            Else
                            Set park = bstack.lastobj
                            End If
                            
cont4567:
                            
                            If lookOne(aa$, ")") Then
                                
                        
                                If parenthesis > 0 Then
                                FastSymbol1 aa$, ")"
                                    parenthesis = parenthesis - 1
                                    If ac <> 0 Then po = ac + po: ac = 0
                                    ac = 0
                                Else
                                    If po = 1 Then
                                        po = R
                                    ElseIf po = -1 Then
                                        po = -R
                                    Else
                                    po = po * R
                                    End If
                                    If ac = 0 Then
                                    rr = po
                                    Else
                                        rr = ac
                                        rr = rr + po
                                        If Err.Number = 6 Then
                                            rr = CDbl(rr) + CDbl(po)
                                            Err.Clear
                                        End If
                                    End If
                                    IsExpA = True
                                     Set park = Nothing
                                    Exit Function
                                End If
                                
                            End If
                            po = 1
                            If Not bstack.lastobj Is Nothing Then GoTo again2
                            'Set park = Nothing
                        Else
                             MyEr "Wrong Operator", "кэХОР тЕКЕСТчР"
                             IsExpA = False
                             Exit Function
                        End If
                        
                    Else
                        Set park = Nothing
                        If (MUL + Len(ss$) - 1) > 0 Then
                            If aa$ = vbNullString Then
                                aa$ = ss$
                            Else
                             '   Mid$(aa$, 1, MUL + Len(ss$) - 1) = ss$
                            End If
                        End If
                        MUL = 0
                    End If
                End If
                Else
                ' maybe is an error or not ???
                End If
            ElseIf po = -1 And TypeOf bstack.lastobj Is Group Then
                If Not bstack.lastpointer Is Nothing Then
                    If bstack.lastpointer.IamFloatGroup Then
                Set bstack.lastobj = bstack.lastpointer
                Else
                With bstack.lastobj
                    ss$ = "Group(" + .lasthere + "." + .GroupName + ")"
                End With
                 IsNumber bstack, ss$, R
                End If
                Set bstack.lastpointer = Nothing
                End If
                    po = -po
                    Set park = Nothing
                    If bstack.lastobj.HasUnary Then ProcessOper bstack, park, "-:", R, (0)
again3:

                    If Not objlist Is Nothing Then
                    If Not objlist.IsEmpty Then
                    Set park = objlist.PopObj
                    ss$ = objlist.PopStr
                    ProcessOper bstack, park, ss$, R, 1
                    MUL = 1
                    ElseIf Len(aa$) > 0 Then
                    If Fast2Label(aa$, "WITH", 4, "ле", 2, 5) Then GoTo a1290456
                    End If
                    
                    ElseIf Len(aa$) > 0 Then
                        If Fast2Label(aa$, "WITH", 4, "ле", 2, 5) Then
a1290456:
                            If TypeOf bstack.lastobj Is Group Then
                                If Not bstack.lastpointer Is Nothing Then
                                    If bstack.lastpointer.IamFloatGroup Then
                                      If bstack.lastpointer Is NullGroup Then
                                            Set bstack.lastobj = New Group
                                            bstack.lastobj.BeginFloat 0
                                            bstack.lastobj.EndFloat
                                        Else
                                        Set bstack.lastobj = bstack.lastpointer
                                        End If
                                    Else
                                        With bstack.lastobj
                                            ut$ = "Group(" + .lasthere + "." + .GroupName + ")"
                                        End With
                                        IsNumber bstack, ut$, R
                                    End If
                                    Set bstack.lastpointer = Nothing
                                End If
                            End If
                             ss$ = "''"
                             GoTo withoper
                        End If
                    End If
                        If lookOne(aa$, ")") Then
                     
                                If parenthesis > 0 Then
                                FastSymbol1 aa$, ")"
                                    parenthesis = parenthesis - 1
                                    If ac <> 0 Then po = ac + po: ac = 0
                                    ac = 0
                                    GoTo again2
                                Else
                                    If po = 1 Then
                                        po = R
                                    ElseIf po = -1 Then
                                        po = -R
                                    Else
                                    po = po * R
                                    End If
                                    If ac = 0 Then
                                    rr = po
                                    Else
                                    rr = ac + po
                                        rr = ac
                                        rr = rr + po
                                        If Err.Number = 6 Then
                                            rr = CDbl(rr) + CDbl(po)
                                            Err.Clear
                                        End If
                                    End If
                                    IsExpA = True
                                     Set park = Nothing
                                    Exit Function
                                End If
                                
                            End If
            Else
            If TypeOf bstack.lastobj Is Group Then GoTo again3
           
            End If
cont111333:
         If MaybeIsSymbol(aa$, "IiеЕ") Then
             If Fast2Label(aa$, "IS", 2, "еимаи", 5, 5) Then
    Set R1 = bstack.lastobj
    If R1 Is Nothing Then
        MyEr "No object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО"
        IsExpA = False
        Exit Function
    Else
        l = False
        If TypeOf R1 Is Group Then
            If R1.IamApointer Then
                If R1.link.IamFloatGroup Then
                    Set R1 = R1.link
                Else
                    If GetVar(bstack, R1.lasthere + "." + R1.GroupName, rightlevel) Then
                        Set R1 = var(rightlevel)
                        rightlevel = 0
                    Else
                        Set R1 = New Group
                    End If
                
                End If
            Else
            l = True
            End If
        End If
        Set bstack.lastobj = Nothing
        Set bstack.lastpointer = Nothing
        If TypeOf R1 Is Group Then
        If Fast2Label(aa$, "TYPE", 4, "тупос", 5, 5) Then
                If FastPureLabel(aa$, ut$, , True) Then

                IsExpA = True
                ac = 0
                R = R1.TypeGroup(ut$)
                R1 = 1
                GoTo LeaveIt
            Else
            IsExpA = False
                Exit Function
            End If
        ElseIf GetPointer(bstack, aa$) Then
                Set R = bstack.lastpointer
                Set bstack.lastpointer = Nothing
                Set bstack.lastobj = Nothing
            
            Else
                Set bstack.lastobj = Nothing
                    MyEr "No object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО"
                IsExpA = False
                Exit Function
            End If
            If TypeOf R Is Group Then
                If R.IamApointer Then
                If R.link.IamFloatGroup Then
                    Set R = R.link
                    Else
                        If GetVar(bstack, R.lasthere + "." + R.GroupName, rightlevel) Then
                            Set R = var(rightlevel)
                            rightlevel = 0
                        Else
                            Set R1 = New Group
                        End If
                    End If
                End If
            End If
        ElseIf IsSymbol(aa$, "NOTHING", 7) Then
            If TypeOf R1 Is mHandler Then
            
            If CheckLastHandlerVariant(R1) Then
            Set usehandler = R1
            If usehandler.indirect > 0 Then
            Set R1 = var(usehandler.indirect)
            Else
            Set R1 = usehandler.objref
            End If
            End If
            End If
            Set R = Nothing
            Set usehandler = Nothing
         ElseIf IsSymbol(aa$, "типота", 6) Then
            If TypeOf R1 Is mHandler Then
            If CheckLastHandlerVariant(R1) Then
            Set usehandler = R1
            If usehandler.indirect > 0 Then
            Set R1 = var(usehandler.indirect)
            Else
            Set R1 = usehandler.objref
            End If
            End If
            End If
            Set R = Nothing
            Set usehandler = Nothing
        ElseIf IsNumber(bstack, aa$, R) Then
            Set bstack.lastpointer = Nothing
            If bstack.lastobj Is Nothing Then
                MyEr "No object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО"
                IsExpA = False
                Exit Function
                
            End If
            Set R = bstack.lastobj
            Set bstack.lastobj = Nothing
            If TypeOf R1 Is mHandler Then
                If CheckLastHandlerVariant(R1) Then
                    Set usehandler = R1
                    If usehandler.indirect > 0 Then
                    Set R1 = var(usehandler.indirect)
                    Else
                    Set R1 = usehandler.objref
                    End If
                End If
            End If
            If TypeOf R Is mHandler Then
            If CheckLastHandlerVariant(R) Then
            Set usehandler = R
            If usehandler.indirect > 0 Then
            Set R = var(usehandler.indirect)
            Else
            Set R = usehandler.objref
            End If
            End If
            
            End If
            Set usehandler = Nothing
        End If
            IsExpA = True
            ac = 0
            If l Then
            If R1.PointerPtr <> 0 Then
            R = CBool(R1.PointerPtr = ObjPtr(R))
            Else
            R = CBool(R1 Is R)
            End If
            Else
            R = CBool(R1 Is R)
            End If
            R1 = 1
        End If
    End If
    End If
End If
LeaveIt:
       
        IsExpA = True
        If po = 1 Then
            po = R
        ElseIf po = -1 Then
            po = -R
        Else
        po = po * R
        End If
    ElseIf LastErNum1 < 0 Then
    Exit Function
    ElseIf parenthesis = 1 Then
    Dim s$
    If IsStrExp(bstack, aa$, s$) Then
    
    IsExpA = GetArr(bstack, aa$, R, s$, 2)
    If IsExpA Then parenthesis = 0
    po = 0
    End If
    ElseIf FastSymbol1(aa$, "(") Then
                            If IsExp(bstack, aa$, R) Then
                                IsExpA = True
                                
                                If po = 1 Then
                                    po = R
                                ElseIf po = -1 Then
                                If Not bstack.lastobj Is Nothing Then
                                    If Typename(bstack.lastobj) = mgroup Then
                                        po = R
                                        Set park = Nothing
                                        ProcessOper bstack, park, "-:", R, (0)
                                        
                                    End If
                                
                                Else
                                
                                
                                    po = -R
                                End If
                                Else
                                    po = po * R
                                End If
                                
                                If Not FastSymbol1(aa$, ")") Then
                                    IsExpA = False
                                    Exit Function
                                End If
                            Else
                                IsExpA = False
                                Exit Function
                            End If
    Else
    
    IsExpA = False
    Exit Function

   End If

R1 = 1
MUL = 0
''second  loop Logic...
secodlooplogic:
Do
  If Fast2Symbol(aa$, "**", 2, "^", 1) Then
            Set bstack.lastobj = Nothing
            ' get from right number or expression
            If IsNumber(bstack, aa$, R, True) Then ' ЙОИТэЛЕ АМ ЕъМАИ АЯИХЛЭР ч ЛЕТАБКГТч
            Set bstack.lastobj = Nothing
                po = po ^ R
                If Err.Number Then
                po = Infinity()
                End If
            ElseIf FastSymbol1(aa$, "(") Then
                If IsExp(bstack, aa$, R, , True) Then
                    po = po ^ R
                    If Err.Number Then
                    po = Infinity()
                    End If
                    If Not FastSymbol1(aa$, ")") Then
                        IsExpA = False
                        Exit Function
                    End If
                Else
                    IsExpA = False
                    Exit Function
                End If
            Else
                IsExpA = False
                Exit Function
            End If
    
    ElseIf MUL > 0 Then
            ' do it before we find next / or *
            Set bstack.lastobj = Nothing
            Select Case MUL
            Case 500
            bstack.soros.DataVal R1
             R1 = 1
            Case 1
                po = R1 * po
            If Err.Number = 6 Then
            
            po = CDbl(R1) * CDbl(po)
            Err.Clear
            End If
            Case 2
                If po = 0 Then
                    'DIVISION BY ZERO
                
                    DevZeroMacro aa$
                
                    IsExpA = False
                    Exit Function
                Else
                    po = R1 / po
                    If Err.Number = 6 Then
                    po = CDbl(R1) / CDbl(po)
                    End If
                End If
            Case 3
               ' po = r1 * po
                po = CBool(CBool(R1) And CBool(po))
            Case 4, 44
            '' check for **, ^, /, *
                If Round(po, 13) = 0 Then
                    'DIVISION BY ZERO
                    DevZeroMacro aa$
                    IsExpA = False
                    Exit Function
                ElseIf MUL = 4 Then
                    po = Fix(R1 / po)
                Else
                   If po < 0 Then

                    po = Int((R1 - Abs(R1 - Abs(po) * Int(R1 / Abs(po)))) / po)
   
                   Else
                    po = Int(R1 / po)
                    End If
                   End If
            Case 40 ' Old version use switches "+DIV"
                If Round(po, 13) = 0 Then
                    'DIVISION BY ZERO
                    DevZeroMacro aa$
                    IsExpA = False
                    Exit Function
                Else
                    po = Int(R1 / po)
                End If
            Case 5, 55
                If Round(po, 13) = 0 Then
                    'DIVISION BY ZERO
                    DevZeroMacro aa$
                    IsExpA = False
                    Exit Function
                ElseIf MUL = 5 Then
                         back = R1 - Fix(R1 / po) * po
                         If Abs(back) >= Abs(po) Then back = back - back
                         po = back
                Else
                        back = Abs(R1 - Abs(po) * Int(R1 / Abs(po)))
                        If Abs(back) >= Abs(po) Then back = back - back
                        po = back
                  End If
            Case 50 ' Old version use switches "+DIV"
              If Round(po, 13) = 0 Then
                    'DIVISION BY ZERO
                    DevZeroMacro aa$
            
                    IsExpA = False
                    Exit Function
                Else
                   ' po = Sgn(r1) * (Int(Abs(r1)) - Int(Int(Abs(r1) / Abs(Int(po))) * Abs(Int(po))))
                   back = R1 - Int(R1 / po) * po
                   If Abs(back) >= Abs(po) Then back = back - back
                   po = back
                End If
            End Select
            R1 = 1
            MUL = 0
             
    ElseIf FastSymbol1(aa$, "*") Then
            If logical(bstack, aa$, R, , True) Then
                MUL = 1
                R1 = po
                po = R
            ElseIf FastSymbol1(aa$, "(") Then
                If IsExp(bstack, aa$, R, , True) Then
                    MUL = 1
                    R1 = po
                    po = R
                    If Not FastSymbol1(aa$, ")") Then
                        IsExpA = False
                        Exit Function
                    End If
                Else
                    IsExpA = False
                    Exit Function
                End If
            Else
                IsExpA = False
                Exit Function
            End If
    ElseIf lookTwoSame(aa$, "/") Then
      '  Mid$(aa$, 1, 2) = ":'"
          logic = True
        Exit Do
    ElseIf FastSymbol1(aa$, "/") Then
            If logical(bstack, aa$, R, , True) Then
                MUL = 2
                R1 = po
                po = R
            ElseIf FastSymbol1(aa$, "(") Then
                If IsExp(bstack, aa$, R, , True) Then
                    MUL = 2
                    R1 = po
                    po = R
                    If Not FastSymbol1(aa$, ")") Then
                        IsExpA = False
                        Exit Function
                    End If
                Else
                    IsExpA = False
                    Exit Function
                End If
            Else
                IsExpA = False
                Exit Function
            End If
     ElseIf MaybeIsSymbol(aa$, "DMдуdmДУ") Then
              If Fast2Label(aa$, "DIV", 3, "диа", 3, 4) Then
                    If logical(bstack, aa$, R) Then
                        If UseIntDiv Then  ' also 10 DIV 2*3 now is (10 DIV 2)*3
                            MUL = 40
                            R1 = po
                            po = R
                        Else
                            MUL = 4
                            ' right operator * / ^ **
                            R1 = po
                            If Not rightoperator(bstack, aa$, R) Then ' 10 DIV 2*3 now is 10 DIV (2*3)
                                IsExpA = False
                                Exit Function
                            End If
                            po = R
                        End If
                    ElseIf FastSymbol1(aa$, "(") Then
                        If IsExp(bstack, aa$, R, , True) Then
                            If UseIntDiv Then MUL = 40 Else MUL = 4
                            R1 = po
                            If Not FastSymbol1(aa$, ")") Then
                                IsExpA = False
                                Exit Function
                            End If
                            po = R
                        Else
                            IsExpA = False
                            Exit Function
                        End If
                    Else
                            IsExpA = False
                            Exit Function
                    End If
                ElseIf Fast2Label(aa$, "DIV#", 4, "диа#", 4, 5) Then
                    If logical(bstack, aa$, R, , True) Then
                        MUL = 44
                        R1 = po
                        If Not rightoperator(bstack, aa$, R) Then
                            IsExpA = False
                            Exit Function
                        End If
                        po = R
                    ElseIf FastSymbol1(aa$, "(") Then
                        If IsExp(bstack, aa$, R, , True) Then
                            MUL = 44
                            R1 = po
                            If Not FastSymbol1(aa$, ")") Then
                                IsExpA = False
                                Exit Function
                            End If
                            po = R
                        Else
                            IsExpA = False
                            Exit Function
                        End If
                    Else
                            IsExpA = False
                            Exit Function
                    End If
                ElseIf Fast3Label(aa$, "MOD", 3, "упокоипо", 8, "упок", 4, 9) Then
        
                    If logical(bstack, aa$, R, , True) Then
                        If UseIntDiv Then
                            MUL = 50
                            R1 = po
                            po = R
                        Else
                        MUL = 5
                        R1 = po
                        If Not rightoperator(bstack, aa$, R) Then
                            IsExpA = False
                            Exit Function
                        End If
                        po = R
                        End If
                    ElseIf FastSymbol1(aa$, "(") Then
                        If IsExp(bstack, aa$, R, , True) Then
                        If UseIntDiv Then MUL = 50 Else MUL = 5
                            R1 = po
                            If Not FastSymbol1(aa$, ")") Then
                                IsExpA = False
                                Exit Function
                            End If
                            If Not rightoperator(bstack, aa$, R) Then
                                IsExpA = False
                                Exit Function
                            End If
                            po = R

                        Else
                            IsExpA = False
                            Exit Function
                        End If
                    Else
                        IsExpA = False
                        Exit Function
                    End If

                    ElseIf Fast3Label(aa$, "MOD#", 4, "упок#", 5, "упокоипо#", 9, 10) Then
        
                    If logical(bstack, aa$, R, , True) Then
                        MUL = 55
                        R1 = po
                        If Not rightoperator(bstack, aa$, R) Then
                            IsExpA = False
                            Exit Function
                        End If
                        po = R
                    ElseIf FastSymbol1(aa$, "(") Then
                        If IsExp(bstack, aa$, R, , True) Then
                            MUL = 55
                            R1 = po
                            If Not FastSymbol1(aa$, ")") Then
                                IsExpA = False
                                Exit Function
                            End If
                            If Not rightoperator(bstack, aa$, R) Then
                                IsExpA = False
                                Exit Function
                            End If
                            po = R

                        Else
                            IsExpA = False
                            Exit Function
                        End If
                    Else
                        IsExpA = False
                        Exit Function
                    End If
        Else
         logic = True
         Exit Do
        End If
ElseIf MaybeIsSymbol(aa$, "AаXйгOАaxЙГoч╧") And noand Then
If Fast2Label(aa$, "XOR", 3, "апо", 3, 4) Then
    Set bstack.lastobj = Nothing
'  good
  MUL = 3
    If priorityOr Then
       If IsExp(bstack, aa$, R, , True) Then
            If ac <> 0 Then po = (ac + po)
            If po <> 0 Then po = -1
            If R <> 0 Then R = -1
            po = po Xor R
            ac = 0
        End If
    Else
    If IsExp(bstack, aa$, R, False, True) Then
            If ac <> 0 Then po = (ac + po)
            If po <> 0 Then po = -1
            If R <> 0 Then R = -1
            po = po Xor R
            ac = 0
        Else
            IsExpA = False
            Exit Function
        End If
    End If

ElseIf Fast2Label(aa$, "OR", 2, "г", 1, 2) Then
Set bstack.lastobj = Nothing
'  good
  MUL = 3
If priorityOr Then
    If IsExp(bstack, aa$, R, , True) Then
    If ac <> 0 Then po = (ac + po)
    If po <> 0 Then po = -1
    If R <> 0 Then R = -1
  po = po Or R
     ac = 0
    End If
Else
  If IsExp(bstack, aa$, R, False, True) Then
     If ac <> 0 Then po = (ac + po)
    If po <> 0 Then po = -1
    If R <> 0 Then R = -1
  po = po Or R
     ac = 0
     Else
    IsExpA = False
    Exit Function
 End If
End If

ElseIf Fast2Label(aa$, "AND", 3, "йаи", 3, 3) Then
Set bstack.lastobj = Nothing
'  good
  MUL = 3
  If IsExp(bstack, aa$, R, False, True) Then
     If ac <> 0 Then po = (ac + po)
    If po <> 0 Then po = -1
    If R <> 0 Then R = -1
  po = po And R
     ac = 0
 End If
Else
logic = True
Exit Do
 End If
ElseIf FastSymbol1(aa$, ")") Then
            If parenthesis > 0 Then
                parenthesis = parenthesis - 1
                If ac <> 0 Then po = ac + po: ac = 0
            Else
                aa$ = ")" & aa$
                If ac = 0 Then
                rr = po
                Else
                rr = ac
                rr = rr + po
                If Err.Number = 6 Then
                rr = CDbl(rr) + CDbl(po)
                Err.Clear
                End If
                End If
                Exit Function
            End If
ElseIf MaybeIsTwoSymbol(aa$, "->", 2) Then
logic = True
Exit Do
ElseIf FastSymbol1(aa$, "-") Then
Set bstack.lastobj = Nothing
  ' second parameter push old value to ac
  ' get new one to r
  ' check if we have string logical
  ' or we have parenthesis (....
  ' or just a perform a -1*
If logical(bstack, aa$, R, , True) Then
    R1 = -R1
    MUL = 1 ' from 3
    If ac = 0 Then ac = po Else ac = ac + po
    po = R
    
 ElseIf FastSymbol1(aa$, "(") Then
    If IsExp(bstack, aa$, R, , True) Then
    R1 = -R1
    MUL = 1 ' from 3
    If ac = 0 Then
    ac = po
    Else
    ac = ac + po
    If Err.Number = 6 Then
    Err.Clear
    ac = CDbl(ac) + CDbl(po)
    Err.Clear
    End If
    End If
    po = R
    If Not FastSymbol1(aa$, ")") Then
    IsExpA = False
    Exit Function
    End If
    End If
  Else
 '   r1 = -r1
    
   
    MissNumExpr
    IsExpA = False
    Exit Function
  End If
ElseIf FastSymbol1(aa$, "+") Then
Set bstack.lastobj = Nothing
If logical(bstack, aa$, R, , True) Then
    MUL = 1 ' from 3
    
    If ac = 0 Then
    ac = po
    Else
    ac = ac + po
    If Err.Number = 6 Then
    Err.Clear
    ac = CDbl(ac) + CDbl(po)
    Err.Clear
    End If
    End If
    po = R
    ElseIf FastSymbol1(aa$, "(") Then
    If IsExp(bstack, aa$, R, , True) Then
    MUL = 1 ' from 3
    If ac = 0 Then
    ac = po
    Else
    ac = ac + po
    If Err.Number = 6 Then
    Err.Clear
    ac = CDbl(ac) + CDbl(po)
    Err.Clear
    End If
    End If
    po = R
    If Not FastSymbol1(aa$, ")") Then
    IsExpA = False
    Exit Function
    End If
    End If
Else
    MissNumExpr
    IsExpA = False
    Exit Function
End If

ElseIf FastSymbol2(aa$, "<<") Then
Set bstack.lastobj = Nothing
If logical(bstack, aa$, R) Then
                MUL = 500
               
                R1 = po
                po = R
            ElseIf FastSymbol1(aa$, "(") Then
                If IsExp(bstack, aa$, R) Then
                    MUL = 1
                    R1 = po
                    po = R
                    If Not FastSymbol1(aa$, ")") Then
                        IsExpA = False
                        Exit Function
                    End If
                End If
            Else
                IsExpA = False
                Exit Function
            End If
            
'**********************************************************************
ElseIf Comp And MaybeIsSymbol(aa$, "<=>") Then
Set bstack.lastobj = Nothing
If FastSymbol1(aa$, "=") Then
    MUL = 3
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If IsExp(bstack, aa$, R, False, True, False) Then
            If R = 0 Then
                If ac <> 0 Then po = (ac + po)
                If po = 0 Then
                    po = True
                Else
                    po = MyRound(po, 13) = 0
                End If
            Else
                po = MyRound((((ac + po) - R) / R), 10) = 0
            End If
            ac = 0
        Else
            IsExpA = False
            Exit Function
        End If
    ElseIf IsExp(bstack, aa$, R, False, True, False) Then
        po = (ac + po) = R
        ac = 0
    Else
        IsExpA = False
        Exit Function
    End If
ElseIf FastSymbol1(aa$, "<") Then
    MUL = 3
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If Left$(aa$, 2) = " >" Then
            Mid$(aa$, 2, 1) = " "
            MUL = 1  ' from 3

            If IsExp(bstack, aa$, R, False, True, False) Then
                If ac = 0 Then
                    Select Case po
                    Case Is < R
                        po = -1
                    Case Is = R
                        po = 0
                    Case Else
                        po = 1
                    End Select
                    ac = 0
                Else
                    ac = ac + po
                    If Err.Number = 6 Then
                        Err.Clear
                        R = R - ac
                        If Err.Number = 6 Then Err.Clear
                        Select Case po
                        Case Is < R
                            po = -1
                        Case Is = R
                            po = 0
                        Case Else
                            po = 1
                        End Select
                    Else
                        Select Case ac
                        Case Is < R
                            po = -1
                        Case Is = R
                            po = 0
                        Case Else
                            po = 1
                        End Select
                        
                        ac = 0
                    End If
                 End If
             Else
                IsExpA = False
                Exit Function
             End If
            Else
            If IsExp(bstack, aa$, R, False, True, False) Then
                If ac = 0 Then
                    po = po <= R
                Else
                    ac = ac + po
                    If Err.Number = 6 Then
                        Err.Clear
                        If ac + 0 Then
                        If Err.Number = 6 Then
                            po = ac <= R
                        Else
                            po = po <= R
                        End If
                        Else
                            po = po <= R
                        End If
                    Else
                        po = ac <= R
                    End If
                    
                    ac = 0
                End If

            Else
                IsExpA = False
                Exit Function
            End If
        End If
    ElseIf Left$(aa$, 1) = ">" Then
        Mid$(aa$, 1, 1) = " "
        If IsExp(bstack, aa$, R, False, True, False) Then
            If ac = 0 Then
                po = po <> R
            Else
                ac = ac + po
                If Err.Number = 6 Then
                    Err.Clear
                    If ac + 0 Then
                    If Err.Number = 6 Then
                        po = ac <> R
                    Else
                        po = po <> R
                    End If
                    Else
                        po = po <> R
                    End If
                Else
                    po = ac <> R
                End If
                
                ac = 0
            End If

        Else
            IsExpA = False
            Exit Function
        End If
    ElseIf IsExp(bstack, aa$, R, False, True, False) Then
        If ac = 0 Then
            po = po < R
        Else
            ac = ac + po
            If Err.Number = 6 Then
                Err.Clear
                If ac + 0 Then
                If Err.Number = 6 Then
                    po = ac < R
                Else
                    po = po < R
                End If
                Else
                    po = po < R
                End If
            Else
                po = ac < R
            End If
            
            ac = 0
        End If
    Else
        IsExpA = False
        Exit Function
    End If
ElseIf FastSymbol1(aa$, ">") Then
    MUL = 3
    If Left$(aa$, 1) = "=" Then
        Mid$(aa$, 1, 1) = " "
        If IsExp(bstack, aa$, R, False, True, False) Then
            If ac = 0 Then
                po = po >= R
            Else
                ac = ac + po
                If Err.Number = 6 Then
                    Err.Clear
                    If ac + 0 Then
                    If Err.Number = 6 Then
                        po = ac >= R
                    Else
                        po = po >= R
                    End If
                    Else
                        po = po >= R
                    End If
                Else
                    po = ac >= R
                End If
                
                ac = 0
            End If

        Else
            IsExpA = False
            Exit Function
        End If
    ElseIf IsExp(bstack, aa$, R, False, True, False) Then
            If ac = 0 Then
                po = po > R
            Else
                ac = ac + po
                If Err.Number = 6 Then
                    Err.Clear
                    If ac + 0 Then
                    If Err.Number = 6 Then
                        po = ac > R
                    Else
                        po = po > R
                    End If
                    Else
                        po = po > R
                    End If
                Else
                    po = ac > R
                End If
                
                ac = 0
            End If

    Else
        IsExpA = False
        Exit Function
    End If
Else
logic = True
Exit Do
End If

Else
logic = True
Exit Do
End If
Loop
If ac = 0 Then
ac = po
Else
ac = ac + po
If Err.Number = 6 Then
Err.Clear
ac = CDbl(ac) + CDbl(po)
Err.Clear
End If
End If
po = 1
Loop Until logic

rr = ac

Do While parenthesis > 0
If FastSymbol1(aa$, ")") Then
parenthesis = parenthesis - 1
Else
Exit Do
End If
Loop
 Set park = Nothing
End Function
Private Function MyTrimLi(s$, l As Long) As Long
Dim i&
Dim p2 As Long, p1 As Integer, p4 As Long
 If l > Len(s) Then MyTrimLi = Len(s) + 1: Exit Function
 If l <= 0 Then MyTrimLi = 1: Exit Function
  l = l - 1
  i = Len(s)
  p2 = StrPtr(s) + l * 2:  p4 = p2 + i * 2
  For i = p2 To p4 Step 2
  GetMem2 i, p1
  Select Case p1
    Case 32, 160, 9
    Case Else
     MyTrimLi = (i - p2) \ 2 + 1 + l
   Exit Function
  End Select
  Next i
 MyTrimLi = Len(s) + 1
End Function
Function FastOperator(a$, c$, i As Long, Optional cl As Long = 1, Optional Remove As Boolean = True) As Boolean
Dim j As Long
If i <= 0 Then i = 1
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimLi(a$, i)
If i > j Then i = 1 ' no spaces
If j - i < cl - 1 Then Exit Function
If c$ = Mid$(a$, i, cl) Then
If Remove Then Mid$(a$, i, cl) = space$(cl)
FastOperator = True
End If
End Function
Function FastType(a$, c$) As Boolean
Dim w$, i As Long
i = 1
If FastPureLabel(a$, w$, i, , True) = 1 Then
If c$ = w$ Then
a$ = Mid$(a$, i)
FastType = True
End If
End If
End Function
Function IsNumber(bstack As basetask, a$, R As Variant, Optional flatobject As Boolean = False) As Boolean
Dim sng&, SG As Variant, ex$, ig$, DE$, i As Long, sg1 As Boolean

If lookOne(a$, "(") Then IsNumber = False: Exit Function
If Len(a$) = 0 Then IsNumber = False: Exit Function
SG = CLng(1)
If MaybeIsSymbol2(a$, "#+-", sng&) Then
sng& = sng& - 1
Do While sng& < Len(a$)
sng& = sng& + 1
Select Case Mid$(a$, sng&, 1)
Case "#"
    If Len(a$) > sng& Then
    If MaybeIsSymbolNoSpace(Mid$(a$, sng& + 1, 1), "[0-9A-Fa-f]") Then
    ex$ = "0x00" + Mid$(a$, sng& + 1, 6)
    If Len(ex$) < 10 Then Exit Function
        If IsNumberCheck(ex$, R) Then
        If ex$ <> "" Then
          
             
        Else
            ex$ = Right$("00000000" & Mid$(a$, sng& + 1, 6), 8)
            a$ = Mid$(a$, sng& + 7)
           R = SG * -(CDbl(UNPACKLNG(Right$(ex$, 2)) * 65536#) + CDbl(UNPACKLNG(Mid$(ex$, 5, 2)) * 256#) + CDbl(UNPACKLNG(Mid$(ex$, 3, 2))))
            If MaybeIsSymbolNoSpace(Mid$(a$, 1, 1), "[0-9]") Then
            MyEr "Too many digits", "пОККэ ЬГЖъА"
            IsNumber = False
            Else
            IsNumber = True
            End If
            Exit Function
        End If
        End If
        Else
        
    End If
    Else

    '' out
    End If
    Exit Function
Case " ", "+", ChrW(160)
Case "-"
SG = -SG
Case Else
Exit Do
End Select
Loop
End If
If sng& > 1 Then Mid$(a$, 1, sng& - 1) = space$(sng& - 1)
If MaybeIsSymbol3(a$, ".", sng&) Then

    If Len(a$) = sng& Then
        ig$ = "0"
        DE$ = "."
        GoTo conthere
    ElseIf Mid$(a$, sng& + 1, 1) Like "[0-9]" Then
        ig$ = "0"
        DE$ = "."
        GoTo conthere
    Else
    ' we have an identifier with . like .x
        IsNumber = IsNumberNew(bstack, a$, R, SG, flatobject)
        If flatobject Then Set bstack.lastobj = Nothing
        Exit Function
    End If
    
ElseIf Len(a$) < sng& Then
    IsNumber = False: Exit Function
Else
i = AscW(Mid$(a$, sng&, 1))
If i < 10 Or i > 63 Then
    IsNumber = IsNumberNew(bstack, a$, R, SG, flatobject)
    If flatobject Then Set bstack.lastobj = Nothing
    Exit Function
Else
    i = 0
    If Mid$(a$, sng&, 1) = "0" Then
        If LCase(Mid$(a$, sng& + 1, 1)) Like "[xВ]" Then
                    sng& = sng& + 2
                    Do While sng& <= Len(a$)
                        Select Case Mid$(a$, sng&, 1)
                        Case "A" To "F", "a" To "f", "0" To "9"
                            i = i + 1
                        Case Else
                            Exit Do
                        End Select
                    sng& = sng& + 1
                    Loop
                    If Mid$(a$, sng&, 1) = "%" Then
                        If i > 48 Then
                            MyEr "Too many digits", "пОККэ ЬГЖъА"
                            IsNumber = False
                            Exit Function
                        End If
                        R = CInt("&H" + Mid$(a$, sng - i, i))
                        sng& = sng& + 1
                    Else
                        If i > 8 Then
                            MyEr "Too many digits", "пОККэ ЬГЖъА"
                            IsNumber = False
                            Exit Function
                        End If
                        If Mid$(a$, sng&, 1) = "&" Then
                            R = CLng("&H" + Mid$(a$, sng - i, i))
                            sng& = sng& + 1
                        Else
                            R = HexToUnsigned(Mid$(a$, sng - i, i))
                        End If
                    End If
                     Mid$(a$, 1, sng& - 1) = space$(sng& - 1)
                    IsNumber = True
                    Exit Function
                End If
    ElseIf Not Mid$(a$, sng&, 1) Like "[1-9]" Then
        IsNumber = False
        Exit Function
    End If
        
    Do While sng& <= Len(a$)
        Select Case Mid$(a$, sng&, 1)
        Case "0" To "9"
        i = i + 1
        Case "."
            ig$ = Mid$(a$, sng& - i, i)
            DE$ = "."
            Exit Do
        Case Else
            ig$ = Mid$(a$, sng& - i, i)
        Exit Do
        End Select
        
       sng& = sng& + 1
    Loop
    If Len(ig$) = 0 Then ig$ = Mid$(a$, sng& - i, i)
End If
If DE$ <> "" Then
conthere:
      sng& = sng& + 1
      i = 0
        Do While sng& <= Len(a$)
       
        Select Case Mid$(a$, sng&, 1)
        Case "0" To "9"
            i = i + 1
        Case "E", "e", "е", "Е"
         If ex$ = vbNullString Then
            sg1 = True
            ex$ = "E"
             Exit Do
        End If
        Case Else
        Exit Do
        End Select
         sng& = sng& + 1
        Loop
        If i > 0 Then DE$ = DE$ + Mid$(a$, sng& - i, i)
        If sg1 Then
        sng& = sng& + 1
         i = 0
         Do While sng& <= Len(a$)
         Select Case Mid$(a$, sng&, 1)
         Case "0" To "9"
             i = i + 1
         Case "+", "-"
            If Len(ex$) = 1 Then
               i = i + 1
            Else
                Exit Do
            End If
         Case Else
             Exit Do
         End Select
          sng& = sng& + 1
         Loop
         If i > 0 Then ex$ = ex$ + Mid$(a$, sng& - i, i)
         sng = sng - Len(ex$)
        End If
    End If

    If ex$ <> "" Then
                If Len(ex$) < 3 Then
                If ex$ = "E" Then
                ex$ = "0"
                ElseIf ex$ = "E-" Or ex$ = "E+" Then
                sng = sng + 2
                End If
                End If
                    
            
                If val(Mid$(ex$, 2)) > 308 Or val(Mid$(ex$, 2)) < -324 Then
                    R = 0 ' val(ig$ & DE$)
                    sng = sng - Len(ex$)
                    ex$ = vbNullString
                    MyEr "Exponet Overflow", "уПЕЯВЕъКИСГ еЙХщТГ)"
                    IsNumber = False
                    Exit Function
                    Else
                    sng = sng + Len(ex$)
                    If sng <= Len(a$) Then
                        If Asc(Mid$(a$, sng, 1)) = 126 Then
                        Mid$(a$, sng, 1) = " "
                        If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = cdecimaldot$
                        On Error Resume Next
                        R = CSng(ig$ & DE$ & ex$)
                        If Err.Number = 6 Then
                        If val(Mid$(ex$, 2)) > 38 Or val(Mid$(ex$, 2)) < -45 Then
                            MyEr "Exponet Overflow", "уПЕЯВЕъКИСГ еЙХщТГ)"
                        Else
                            MyEr "Overflow single", "уПЕЯВЕъКИСГ АПКОЩ"
                            End If
                            Err.Clear
                        End If
                        Exit Function
                        Else
                            R = val(ig$ & DE$ & ex$)
                        End If
                    Else
                        R = val(ig$ & DE$ & ex$)
                        If Err.Number = 6 Then
                        Overflow
                        Exit Function
                        End If
                    End If
                    On Error GoTo 0
                    
                 
                End If
        Else
            If sng <= Len(a$) Then
            On Error Resume Next
            Select Case Asc(Mid$(a$, sng, 1))
            Case 64
                Mid$(a$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = cdecimaldot$
                
                R = CDec(ig$ & DE$)
                If Err.Number = 6 Then
                Err.Clear
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                R = val(ig$ & DE$)
                End If
            Case 35
            Mid$(a$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = cdecimaldot$
                R = CCur(ig$ + DE$)
                If Err.Number = 6 Then
                Err.Clear
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                R = val(ig$ & DE$)
                End If
            Case 38
            Mid$(a$, sng, 1) = " "
                    R = CLng(ig$)
                    If Err.Number = 6 Then
                        Err.Clear
                        R = val(ig$)
                    End If
           Case 37
                Mid$(a$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = cdecimaldot$
                R = CInt(ig$)
                If Err.Number = 6 Then
                Err.Clear
                R = val(ig$)
                End If
           Case 126
                Mid$(a$, sng, 1) = " "
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = cdecimaldot$
                R = CSng(ig$ & DE$)
                If Err.Number = 6 Then
                Err.Clear
                If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                R = val(ig$ & DE$)
                End If
            Case Else
                R = val(ig$ & DE$)
            End Select
            Else
            R = val(ig$ & DE$)
            End If
            End If
            If SG < 0 Then R = -R
            If Err.Number = 6 Then
                If Len(ex$) > 2 Then
                    ex$ = Left$(ex$, Len(ex$) - 1)
                    sng = sng - 1
                    Err.Clear
                    R = val(ig$ & DE$ & ex$)
                    If Err.Number = 6 Then
                        sng = sng - Len(ex$)
                        If DE$ <> vbNullString Then Mid$(DE$, 1, 1) = "."
                         R = val(ig$ & DE$)
                    End If
                End If
                
           ErrInExponet a$
          IsNumber = False
            Exit Function
            End If
        End If
      Mid$(a$, 1, sng& - 1) = space$(sng& - 1)
  
    IsNumber = True


End Function

Function IsNumberNew(bstack As basetask, a$, R As Variant, SG As Variant, flatobject) As Boolean
Dim VR As Long, v$, v1&, w1 As Long, w2 As Long, p As Variant, s1$, dd As Long, dn As Long, w3 As Long
Dim pp As Variant, pppp As mArray, nbstack As basetask, usehandler As mHandler, usebackup As Boolean
Dim anything As Object, n$, useFast As FastCollection, userGroup As Group, useProp As PropReference, gr As Boolean
Dim sg1 As Boolean, s$, par As Boolean
R = 0#
If a$ = vbNullString Then IsNumberNew = False: Exit Function
'On Error Resume Next

Set bstack.lastobj = Nothing
againpointer:
w2 = Len(a$)
If Len(a$) < 129 Then
    v1& = IsLabelBig(bstack, a$, v$, par, s1$, True, , usebackup, , gr)
Else
    n$ = Left$(a$, 128)
    s$ = bstack.tmpstr
    v1& = IsLabelBig(bstack, n$, v$, par, s1$, True, , usebackup, sg1, gr)
    If Len(n$) = 0 Then
        If sg1 Then bstack.tmpstr = s$
        sg1 = False
        v1& = IsLabelBig(bstack, a$, v$, par, s1$, True, , usebackup, , gr)
    Else
        If sg1 Then
        sg1 = False
        Select Case Len(n$)
        Case Is < 128
            Mid$(a$, 129 - Len(n$), Len(n$)) = n$
            a$ = Mid$(a$, 129 - Len(n$))
        Case Is > 128
            a$ = n$ + Mid$(a$, 129)
        Case Else
            Mid$(a$, 1, 128) = n$
        End Select
        Else
            a$ = Mid$(a$, 129 - Len(n$))
        End If
    End If
End If


If v1& = 0 Then Exit Function

If par Then
par = False
If usebackup Then If v1& > 4 Then GoTo conthere


removethis:
dn = dn + 1
If dn > 2 Then
' it is a var with name this or ауто
v1& = FastPureLabel((v$), v$)
VR = -1

End If
contthis1:
v1& = Abs(v1&)
 
 If v1& = 1 Then
 GoTo LOOKFORVARNUM
 ElseIf v1& = 4 Then
 GoTo LOOKFORVARNUM4
 ElseIf v1& = 5 Or v1& = 7 Then
 GoTo LOOKFORSUBNUM
 Else
 IsNumberNew = False
  a$ = v$ + a$
    Exit Function
 End If
 ''
End If
conthere:
Select Case v1&
Case 1
If usebackup Then
    If Not numidbackup.Find(v$, w1) Then GoTo LOOKFORVARNUM
Else
    If Not numid.Find(v$, w1, bstack.numnum) Then GoTo LOOKFORVARNUM
    If w1 < 0 Then GoTo LOOKFORVARNUM
End If
findsecond:
On w1 GoTo num1, num2, num3, num4, num5, num6, num7, num8, num9, num10, num11, num12, num13, num14, num15, num16, num17, num18, num19, num20, num21, num22, num23, num24, num25, num26, num27, num28, num29, num30, num31, num32, num33, num34, num35, num36, num37, num38, num39, num40, num41, num42, num43, num44, num45, num46, num47, num48, num49, num50, num51, num52, num53, num54, num55, num56, num57, num58, num59, num60, num61, num62, num63, num64, num65, num66, num67, num68, num69, num70, num71, num72, num73, num74, num75, num76, num77, num78, num79, num80, num81, num82, num83, num84, num85, num86, num87, num88, num89, num90, num91, num92, num93, num94, num95, num96, num97, num98, num99, num100, num101, num102, num103, num104
IsNumberNew = 0
InternalError
Exit Function
num104:
If sRec Is Nothing Then
    Set sRec = New RecordMci
    With sRec
    If Not .HaveMic Then Set sRec = Nothing: MissMic: Exit Function
    .Rec_Initialize
    .Mono
    .Bit8
    .QualityAny 11025
    End With
End If
R = SG * sRec.getLevels()
IsNumberNew = True
Exit Function

num103:
R = SG * doslast
IsNumberNew = True
Exit Function

num102: ' Case "MONITORS", "охомес"
R = SG * DisplayMonitorCount
IsNumberNew = True
Exit Function
num101: ' Case "CLIPBOARD.DRAWING", "пяовеияо.сведио"
Set bstack.lastobj = GetImageEmf()
R = 0
IsNumberNew = True
Exit Function
num100: ' Case "CLIPBOARD.IMAGE", "пяовеияо.еийома"
Set bstack.lastobj = GetImageDIB()
R = 0
IsNumberNew = True
Exit Function
num99: ' Case "INTERNET", "диадийтуо"
If SG < 0 Then
R = -Connected
Else
R = Connected
End If
IsNumberNew = True
Exit Function
num98:
If SG < 0 Then
R = -(pagio$ = "GREEK")
Else
R = pagio$ = "GREEK"
End If
IsNumberNew = True
Exit Function
num82:
If SG < 0 Then
R = -Infinity()
Else
R = Infinity()
End If
IsNumberNew = True
Exit Function
num93:
Set bstack.lastobj = NewVarItem()
bstack.lastobj.Typename = ">"
R = 0
IsNumberNew = True
FastSymbol a$, "?"
Exit Function
num90: ' "WINDOW","сусйеуг"
R = SG * FindFormSScreen(bstack.Owner)
IsNumberNew = True
Exit Function
num89: '"OSBIT"
If Is64bit Then
R = SG * 64
Else
R = SG * 32
End If
IsNumberNew = True
Exit Function
num88: ' "охомг","SHOW"
    If Not Screen.ActiveForm Is Nothing Then
    If bstack.Owner Is Form1.DIS Then
    R = SG * (Form1.hWnd = Screen.ActiveForm.hWnd And bstack.Owner.Visible)
    ElseIf Typename(bstack.Owner) = "PictureBox" Then
    R = SG * bstack.Owner.Visible
    Else
    R = SG * bstack.Owner.hWnd = Screen.ActiveForm.hWnd
    End If
    Else
    R = False
    End If
IsNumberNew = True
Exit Function
num87: ' "ISWINE"
R = SG * IsWine
IsNumberNew = True
Exit Function
' Select Case v$
num1: ' "THIS", "ауто"   ' 1
IsNumberNew = This1(bstack, v$, R)
Exit Function

num2: ' "RND", "туваиос"
R = SG * RndM(rndbase)
IsNumberNew = True
Exit Function

num3: ' "PEN", "пема"

With players(GetCode(bstack.Owner))
For w1 = 0 To 15
If QBColor(w1) = .mypen Then
R = SG * w1
IsNumberNew = True
Exit Function
End If
Next w1
R = SG * -.mypen
IsNumberNew = True
End With
Exit Function
num4: ' "HWND","паяахуяо"
R = SG * myHwnd(bstack)

IsNumberNew = True
Exit Function
num5: ' Case "LOCALE", "топийо"
R = SG * Clid
    
    IsNumberNew = True
    Exit Function

num6: ' "CODEPAGE", "йыдийосекида"
R = SG * UserCodePage
    
    IsNumberNew = True
    Exit Function
num7: ' "SPEECH", "коцос"
  R = SG * NumVoices

    
    IsNumberNew = True
    Exit Function
num8: ' "ERROR", "кахос"
    If LastErNum2 <> 0 Then
        R = SG * LastErNum2
    Else
        R = SG * LastErNum1
    End If
    LastErNum2 = 0
    LastErNum1 = 0  'reset when readed
    IsNumberNew = True
    Exit Function
num9: ' "SCREEN.Y", "амакусг.у"
  R = SG * ScrInfo(Console).Height
    
    IsNumberNew = True
    Exit Function
num10: ' "SCREEN.X", "амакусг.в"
  R = SG * ScrInfo(Console).Width
     
    IsNumberNew = True
    Exit Function
num11: ' "TWIPSY", "уьос.сглеиоу"
  R = SG * Screen.TwipsPerPixelY

    
    IsNumberNew = True
    Exit Function
num12: ' "TWIPSX", "пкатос.сглеиоу"
  R = SG * Screen.TwipsPerPixelX
    
    IsNumberNew = True
    Exit Function
num13: ' "REPORTLINES", "цяаллесамажояас"
  R = SG * players(GetCode(bstack.Owner)).LastReportLines
    
    IsNumberNew = True
    Exit Function
num14: ' "LINESPACE", "диастиво"
    R = SG * players(GetCode(bstack.Owner)).uMineLineSpace '' bstack.linespace
    
    IsNumberNew = True
    Exit Function
num15: ' "MODE", "тупос"
With players(GetCode(bstack.Owner))
If bstack.toprinter Then
    If .uMineLineSpace > .MineLineSpace Then
        R = SG * .SZ / szFactor / 2
    Else
         R = SG * .SZ / szFactor
    End If
    Else
    If .uMineLineSpace > .MineLineSpace Then
        R = SG * .UseDouble
    Else
         R = SG * .SZ
    End If
    
    
    End If
    End With
    
    IsNumberNew = True
    Exit Function
num16: ' "MEMORY", "лмглг"
    R = SG * check_mem
    
    IsNumberNew = True
    Exit Function
num17: ' "CHARSET", "ваяайтгяес"   ' charset of the object to display
  R = SG * players(GetCode(bstack.Owner)).charset
    
    IsNumberNew = True
    Exit Function
num18: ' "ITALIC", "пкациа"  ' charset of the object to display
    
    R = SG * players(GetCode(bstack.Owner)).italics
    
    IsNumberNew = True
    Exit Function
num19: ' "BOLD", "жаядиа"  ' charset of the object to display

    R = SG * players(GetCode(bstack.Owner)).bold
    
    IsNumberNew = True
    Exit Function

num20: ' "COLORS", "вяылата"
    R = SG * 2# ^ bitsPerPixel
    
    IsNumberNew = True
    Exit Function
num21: ' "ауноуса", "ASCENDING"
    R = 0
    
    IsNumberNew = True
    Exit Function
num22: ' "жхимоуса", "DESCENDING"
    R = SG
    
    IsNumberNew = True
    Exit Function

num23: ' "BOOLEAN", "коцийос"
    R = SG * 1
        
    IsNumberNew = True
    Exit Function
num24: ' "BYTE", "ьгжио"
    R = SG * 2
        
    IsNumberNew = True
    Exit Function
num25: ' "INTEGER", "айеяаиос"
    R = SG * 3
        
    IsNumberNew = True
    Exit Function
num26: ' "LONG", "лайяус"
    R = SG * 4
        
    IsNumberNew = True
    Exit Function
num27: ' "CURRENCY", "коцистийо"
    R = SG * 5
        
    IsNumberNew = True
    Exit Function
num28: ' "SINGLE", "апкос"
    R = SG * 6
        
    IsNumberNew = True
    Exit Function
num29: ' "DOUBLE", "дипкос"
    R = SG * 7
        
    IsNumberNew = True
    Exit Function
num30: ' "DATEFIELD", "глеяолгмиа"
    R = SG * 8
        
    IsNumberNew = True
    Exit Function
num31: ' "BINARY", "дуадийо"
    R = SG * 9
        
    IsNumberNew = True
    Exit Function
num32: ' "TEXT", "йеилемо"
    R = SG * 10
        
    IsNumberNew = True
    Exit Function
num33: ' "OLE"
    R = SG * 11
        
    IsNumberNew = True
    Exit Function
num34: ' "MEMO", "уполмгла"
    R = SG * 12
        
    IsNumberNew = True
    Exit Function
num35: ' "REVISION", "амахеыягсг"
    R = SG * Revision
    
    IsNumberNew = True
    Exit Function
num36: ' "BROWSER", "амакоцио"
        
        R = SG * (Trim(LCase(Form1.view1.LocationURL)) = "about:blank" Or Form1.view1.Visible = False)
    IsNumberNew = True
    Exit Function
num37: ' "VERSION", "ейдосг"
    R = SG * val(CStr(VerMajor) & "." & CStr(VerMinor))
    
    IsNumberNew = True
    Exit Function
num38: ' "MOTION.X", "йимгсг.в"
With bstack
If .toprinter Then
    R = 0
Else
    R = SG * bstack.Owner.Left
    End If
    End With
    
    IsNumberNew = True
    Exit Function
num39: ' Case "MOTION.Y", "йимгсг.у"
With bstack
If .toprinter Then
    R = 0
Else
    R = SG * .Owner.Top
    End If
    
    End With
    
    IsNumberNew = True

    Exit Function
num40: ' "MOTION.XW", "йимгсг.вп", "MOTION.WX", "йимгсг.пв"
    R = SG * Form1.Left
    
    IsNumberNew = True
    Exit Function
num41: ' "MOTION.YW", "йимгсг.уп", "MOTION.WY", "йимгсг.пу"
    R = SG * Form1.Top
    
    IsNumberNew = True
    Exit Function
num42: ' "FIELD", "педио"
    R = SG * Result
    
    
    IsNumberNew = True
    Exit Function
num43: ' "MOUSE.KEY", "деийтгс.йол"
  
    R = SG * mouse2


       
    IsNumberNew = True
    Exit Function
num44: ' "MOUSE", "деийтгс"

If Not releasemouse Then
If Not Form1.Visible Then newshow Basestack1
End If
R = SG * mouse
If R = 0 Then
MyDoEventsNoThread
     R = SG * mouse ' MOUB
End If
    


    IsNumberNew = True
    Exit Function
num45: ' "MOUSE.X", "деийтгс.в"

With bstack
If .toprinter Then
    R = SG * Form1.PrinterDocument1.currentX
ElseIf .toback Then
    R = SG * MOUSEX(Form1.Left)
Else
    R = SG * MOUSEX(Form1.Left + bstack.Owner.Left)
End If
End With
 
    IsNumberNew = True
    Exit Function
num46: ' "MOUSE.Y", "деийтгс.у"
With bstack
If .toprinter Then

R = SG * Form1.PrinterDocument1.currentY
ElseIf .toback Then
R = SG * MOUSEY(Form1.Top)
Else
R = SG * MOUSEY(Form1.Top + bstack.Owner.Top)
End If
End With
       
    IsNumberNew = True
    Exit Function
num47: ' "MOUSEA.X", "деийтгса.в"
  
    R = SG * MOUSEX(Form1.Left)
    
      
    IsNumberNew = True
    Exit Function
num48: ' "MOUSEA.Y", "деийтгса.у"
 
    R = SG * MOUSEY(Form1.Top)
   
       
    IsNumberNew = True
    Exit Function

num49: ' "TRUE", "акгхес", "акгхгс"
    R = CDbl(SG * -1)
    'r = CBool(sg * -1)
    IsNumberNew = True
    Exit Function
num50: ' "FALSE", "ьеудес", "ьеудгс"
    R = CBool(0)
    R = 0#
    IsNumberNew = True
    Exit Function
num51: ' "STACK.SIZE", "лецехос.сыяоу"
    IsNumberNew = True
    R = SG * bstack.soros.Total
    
    Exit Function
num52: ' "ISNUM", "еимая"
    IsNumberNew = True
      If bstack.soros.Total > 0 Then
    If bstack.soros.PopType = "N" Then R = SG * True Else R = 0
    Else
    R = 0
    End If
    
    Exit Function
num53: ' "PI", "пи"
     R = BigPi
    If SG < 0 Then R = -R
    
    IsNumberNew = True
    Exit Function
num54: ' "NOT", "ови", "дем"
   ' r = SG * -1
    If FastSymbol(a$, "(") Then
    If IsExp(bstack, a$, R, , True) Then
   
        R = CBool(R = 0)
        If SG < 0 Then R = -R
           IsNumberNew = FastSymbol(a$, ")")
           Exit Function
    Else
       NotAfter a$
    End If
    ElseIf IsExp(bstack, a$, R, False, True) Then
        R = CBool(R = 0)
        If SG < 0 Then R = -R
    Else
       NotAfter a$
    End If
    'a$ = "-" & a$
    IsNumberNew = True
    Exit Function
num55: ' "ISLET", "еимця"
    IsNumberNew = True
    If bstack.soros.Total > 0 Then
    If bstack.soros.PopType = "S" Then R = SG * True Else R = 0
    End If
    
    Exit Function
num56: ' Case "WIDTH", "пкатос"
    IsNumberNew = True
    R = SG * players(GetCode(bstack.Owner)).mx
    
    Exit Function
num57: ' "POINT", "сглеио"
'  dsprite ??
    
    If TypeOf bstack.Owner Is MetaDc Then
        MyEr "Can't read pixel from metafile", "ДЕМ ЛПОЯЧ МА ДИАБэСЫ ЕИЙОМОСТОИВЕъО"
    Else
    IsNumberNew = True
    With players(GetCode(bstack.Owner))
    w1 = GetPixel(bstack.Owner.hdc, .XGRAPH \ dv15, .YGRAPH \ dv15)
        If w1 = -1 Then
            R = SG * &H7FFFFFFF
        Else
            R = SG * -(w1 And &HFFFFFF)
        End If
    End With
    End If
    Exit Function
num58: ' "POS.X", "хесг.в"
    IsNumberNew = True
    R = SG * players(GetCode(bstack.Owner)).XGRAPH
    
    Exit Function
num59: ' "POS.Y", "хесг.у"
    IsNumberNew = True
    R = SG * players(GetCode(bstack.Owner)).YGRAPH
    
    Exit Function
num60: ' "SCALE.X", "йкилан.в", "в.сглеиа", "X.TWIPS"
    IsNumberNew = True
    If bstack.toprinter Then
    R = SG * Form1.PrinterDocument1.Scalewidth
    Else
    R = SG * players(GetCode(bstack.Owner)).MAXXGRAPH
    End If
    
    Exit Function
num61: ' "SCALE.Y", "йкилан.у", "у.сглеиа", "Y.TWIPS"
    IsNumberNew = True
    If bstack.toprinter Then
    R = SG * Form1.PrinterDocument1.Scaleheight
    Else
    R = SG * players(GetCode(bstack.Owner)).MAXYGRAPH
    End If
    
    Exit Function
num62: ' "EMPTY", "йемо"
    IsNumberNew = True
    R = SG * (bstack.soros.Total = 0)
    
    Exit Function
num63: ' "MOVIE.COUNTER", "MEDIA.COUNTER", "MUSIC.COUNTER", "таимиа.летягтгс", "лоусийг.летягтгс"
    IsNumberNew = True
    R = SG * MediaPlayer1.getPositionInSec
    If MediaPlayer1.Error > 0 Then
    R = SG * -1
    End If
    
    Exit Function
num64: ' "PLAYSCORE", "паифеижымг"
    IsNumberNew = True
    
       R = SG * TaskMaster.PlayMusic
    
    Exit Function
num65: ' "MOVIE", "MEDIA", "MUSIC", "таимиа", "лоусийг"
    IsNumberNew = True
    AVIRUN = MediaPlayer1.isMoviePlaying
    R = SG * AVIRUN
    
    Exit Function
num66: ' "DURATION", "диаяйеиа"
    IsNumberNew = True
    R = SG * MediaPlayer1.getLengthInMS / 1000
   
    
    Exit Function
num67: ' "VOLUME", "емтасг"
    IsNumberNew = True
    MediaPlayer1.GetMasterVolume vol
    R = SG * CDbl(vol)
    
    Exit Function
num68: ' "TAB", "стгкг"
    IsNumberNew = True
    R = SG * players(GetCode(bstack.Owner)).Column + 1  'CHANGED FROM Ver 7.1
    
    Exit Function
num69: ' "HEIGHT", "уьос"
    IsNumberNew = True
    R = SG * players(GetCode(bstack.Owner)).my
    
    Exit Function
num70: ' "POS", "хесг"
    IsNumberNew = True
    
    
    
    R = SG * GetRealPos(bstack.Owner)
    
    Exit Function
num71: ' "ROW", "цяаллг"
    IsNumberNew = True
    R = SG * GetRealRow(bstack.Owner)
    
    Exit Function
num72: ' "TIMECOUNT", "жоятос" ' ****************************
  IsNumberNew = True
    If bstack.Prof Is Nothing Then
    R = SG * Prof.MARKTWO
    Else
    R = SG * bstack.Prof.MARKTWO
    End If
    Exit Function

num73: ' "TICK", "тий" ' ****************************
  IsNumberNew = True
  If TaskMaster Is Nothing Then
  R = 0
  ElseIf TaskMaster.QueueCount = 0 Then
  R = 0
  Else
    R = SG * tickTimer
  End If
    
    Exit Function
num74: ' "TODAY", "сглеяа"
    IsNumberNew = True
    R = SG * CDbl(Date)
    
    Exit Function
num75: ' "NOW", "тыяа"
    IsNumberNew = True
    R = SG * CDbl(CDate(Time))
    
     Exit Function
num76: ' "MENU.VISIBLE", "епикоцес.жамеяес"  ' NEW 6.5 REV 8
    IsNumberNew = True
    R = SG * Form1.List1.Visible
    
    Exit Function
num77: ' "MENUITEMS", "епикоцес"
    IsNumberNew = True
    R = SG * Form1.List1.listcount
    
    Exit Function
num78: ' "MENU", "епикоцг"
    IsNumberNew = True
    R = 0
    With Form1.List1
    If .listcount > 0 Then
 
     R = SG * CDbl(.ListIndex + 1)
    End If
    End With
    
    Exit Function
num85: ' "[]"
 Set usehandler = New mHandler
    usehandler.t1 = 3
    Set usehandler.objref = New mStiva
     usehandler.objref.MergeBottom bstack.soros
    '  Set bstack.Sorosref = New mStiva
    Set bstack.lastobj = usehandler
    R = 0
    IsNumberNew = True
    Exit Function

num84: ' "ARRAY", "пимайас"
If bstack.soros.Total = 0 Then
    
           EmptyStack a$
  
        IsNumberNew = False: Exit Function

    ElseIf bstack.soros.StackItemTypeObjectType(1) = "*[mArray]" Then
        Set bstack.lastobj = bstack.soros.PopObj
        R = 0
        If FastSymbol(a$, "#") Then GoTo comehere
        
        IsNumberNew = True
        Exit Function
    Else
   StackTopNotArray a$
  
    IsNumberNew = False
    End If
Exit Function
num97:
    IsNumberNew = NewInventory(bstack, a$, R, True)
    Exit Function
num96:
    IsNumberNew = NewInventory(bstack, a$, R, False)
    Exit Function
num95:
w1 = 1
GoTo num941
num94: '"BUFFER", "диаяхяысг"
w1 = 2
num941:
If bstack.soros.Total = 0 Then
    
            EmptyStack a$
  
        IsNumberNew = False: Exit Function

    ElseIf bstack.soros.StackItemType(1) = "*" Then
        Set bstack.lastobj = bstack.soros.PopObj
        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
            If usehandler.t1 <> w1 Then
                Set usehandler = Nothing
pushback:
                bstack.soros.PushObj bstack.lastobj
                Set bstack.lastobj = Nothing
                WrongObject
                IsNumberNew = False
                Exit Function
            End If
        Else
            GoTo pushback
        End If
        R = 0
        IsNumberNew = True
        Exit Function
    Else
        MyErMacro a$, "Stack top isn't " + v$, "г ЙОЯУЖч ТОУ СЫЯОЩ ДЕМ ЕъМАИ " + v$
        IsNumberNew = False
    End If
    Exit Function
num83: ' "GROUP", "олада"
If bstack.soros.Total = 0 Then
    
            EmptyStack a$
  
        IsNumberNew = False: Exit Function

    ElseIf bstack.soros.StackItemTypeObjectType(1) = mgroup Then
        Set bstack.lastobj = bstack.soros.PopObj
        R = 0
        IsNumberNew = True
        Exit Function
    Else
    StackTopNotGroup a$
  
    IsNumberNew = False
    End If
    Exit Function
num79: ' "NUMBER", "аяихлос", "тилг"
    If bstack.soros.Total = 0 Then
    
            EmptyStack a$
  
        IsNumberNew = False: Exit Function

    ElseIf bstack.soros.PopType = "N" Then
    If SG = 1 Then
    R = bstack.soros.PopVal
    Else
    R = -bstack.soros.PopVal
    End If
    
    IsNumberNew = True
    Exit Function
    ElseIf bstack.soros.PopType = "L" Then
    R = SG * bstack.soros.PopVal
    
    IsNumberNew = True
    Exit Function
    Else
     
            StackTopNotNumber a$
  
    IsNumberNew = False
    End If
    Exit Function
num81: ' "калда"
    Set bstack.lastobj = ProcLambda(bstack, a$, 0)
    R = 0
   If FastSymbol(a$, "(") Then
    If Not CallLambdaASAP(bstack, a$, R) Then IsNumberNew = False: Exit Function
    If SG < 0 Then R = -R
    IsNumberNew = True
    Else
    IsNumberNew = Not bstack.lastobj Is Nothing
    End If
Exit Function
num80: ' "LAMBDA"
    Set bstack.lastobj = ProcLambda(bstack, a$, 1)
    R = 0
    If FastSymbol(a$, "(") Then
    If Not CallLambdaASAP(bstack, a$, R) Then IsNumberNew = False: Exit Function
    If SG < 0 Then R = -R
    IsNumberNew = True
    Else
    IsNumberNew = Not bstack.lastobj Is Nothing
    End If
Exit Function
num86: ' Case "STACK", "сыяос"
IsNumberNew = IsStackObj(v$, bstack, a$, R, SG)
    Exit Function
num91: 'MONITOR.STACK - екецвос.сыяоу
    R = SG * CurrentStackSize()
    IsNumberNew = True
    Exit Function
Exit Function
num92: 'MONITOR.STACK.SIZE - екецвос.лецехос.сыяоу
    R = SG * stacksize
    IsNumberNew = True
    Exit Function
Exit Function
LOOKFORVARNUM:
If GetVar(bstack, v$, VR) Then
    If MyIsObject(var(VR)) Then
    n$ = v$
        v$ = Typename(var(VR))
        If v$ = mProp Then
        Set useProp = var(VR)
        
         R = useProp.Value
        
            If Not useProp.lastobj Is Nothing Then
               Set bstack.lastobj = useProp.lastobjfinal
                R = 0
            Else
                If SG < 0 Then R = -R
            End If
            Set useProp = Nothing
        ElseIf v$ = mgroup Then
            Set userGroup = var(VR)
            If userGroup.IamCleared Then
            Set userGroup = New Group
            userGroup.BeginFloat 0
            userGroup.EndFloat
            Set bstack.lastobj = userGroup
            IsNumberNew = True
            Exit Function
            End If
            If userGroup.HasValue And Not IsOperator(a$, "::", 2) Then
            If Len(userGroup.Patch) > 0 Then
                s1$ = userGroup.Patch + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
            Else
                s1$ = n$ + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                End If
                If GetSub(s1$, v1&) Then
foundprivate:
                    Set nbstack = New basetask
                    Set nbstack.Parent = bstack
                    If bstack.IamThread Then Set nbstack.Process = bstack.Process
                    Set nbstack.Owner = bstack.Owner
                    nbstack.OriginalCode = v1&
                    nbstack.UseGroupname = sbf(v1&).sbgroup
                    nbstack.tpointer = sbf(v1&).tpointer
                    nbstack.SetV
                    If GoFunc(nbstack, s1$, ")", p) Then
                        If Not nbstack.StaticCollection Is Nothing Then
                            bstack.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                        End If
                        'Set bstack.lastobj = nBstack.lastobj
                    If Mid(a$, 1, 2) = "=>" Then
                    If Not bstack.lastobj Is Nothing Then
                    If TypeOf bstack.lastobj Is Group Then
                        Set userGroup = bstack.lastobj
                        Set bstack.lastobj = Nothing
                        If userGroup.IamApointer Then
                        Set pppp = BoxGroupVar(CVar(userGroup))
                        w2 = 0
                        Set nbstack.lastobj = Nothing
                        Set nbstack.lastpointer = Nothing
                        Mid$(a$, 1, 2) = "." + Chr(3): GoTo contgroup
                        
                        Else
                        NoOperatorForThatObject "=>"
                     End If
                    End If
                    Else
                    NoOperatorForThatObject "=>"
                    End If
                    IsNumberNew = False
                    Exit Function
                    ElseIf IsOperator(a$, "(") Then
                            Set pppp = New mArray
                            Set pppp.GroupRef = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            pppp.Arr = False
                            w2 = -2
                        Set nbstack = Nothing
                         v$ = vbNullString
                            GoTo contrightpar
                ElseIf FastSymbol(a$, "#") Then
                        Set nbstack = Nothing
                        GoTo comehere
                Else
                       Set nbstack = Nothing
                       
                       R = p
                       If SG < 0 Then R = -R
                       End If
                        IsNumberNew = True
                    Else
                        IsNumberNew = False
                    End If
                Else
                    If userGroup.HasStrValue Then
                        R = 0
                        Set bstack.lastobj = CopyGroupObj(var(VR))
                    Else
                        R = 0
                       
                        
                        s1$ = userGroup.Patch + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                         If Left$(s1$, Len(here$) + 1) = here$ + "." Then
                         s1$ = Mid$(s1$, Len(here$) + 2)
                         End If
                        If GetSub(s1$, v1&) Then GoTo foundprivate
                        InternalEror
                        IsNumberNew = False
                    End If
                End If
            Else
             
                R = 0
                If userGroup.IamApointer Then  ' ???
                If Mid(a$, 1, 2) = "=>" Then
                If userGroup.link.IamFloatGroup Then
                Set pppp = BoxGroupVar(var(VR))
                
                Mid$(a$, 1, 2) = "." + Chr(3)
                IsNumberNew = SpeedGroup(bstack, pppp, "VAL", "", a$, (0)) = 1
                R = bstack.LastValue
                If SG < 0 Then R = -R
                Else
                Mid(a$, 1, 2) = Chr$(0) + "."
                Set bstack.lastpointer = userGroup
                
                GoTo againpointer
                End If
                
                Else
                Set bstack.lastpointer = userGroup.link
                Set bstack.lastobj = userGroup
                End If
                Else
                CopyGroup2 var(VR), bstack
                Set bstack.lastpointer = Nothing
      
              
                End If
            End If
        ElseIf v$ = "mEvent" Then
            CopyEvent var(VR), bstack
            R = 0
        ElseIf v$ = "lambda" Then
            
            CopyLambda var(VR), bstack
            R = 0
        ElseIf v$ = mHdlr Then
            ' this is ok for both buffer and inventory
            Set usehandler = var(VR)
            If usehandler.t1 = 2 Then
                CopyHandler var(VR), bstack
                R = 0
            Else
                If Not usehandler.UseIterator Then
                    Set nbstack = Nothing  ' ???
                    If FastSymbol(a$, "#") Then
                        If Not usehandler.t1 = 3 Then WrongObject: Exit Function
                        IsNumberNew = Matrix(bstack, a$, usehandler, R)
                        If SG < 0 Then R = -R
                    ElseIf flatobject Then
                        If usehandler.t1 = 4 Then
                            R = usehandler.index_cursor
                            If SG < 0 Then R = -R
                        Else
                            R = 0
                        End If
                    Else
                        CopyHandler var(VR), bstack
                        R = 0
                    End If
                ElseIf FastSymbol(a$, "^") Then
                    R = usehandler.index_cursor
                    If SG < 0 Then R = -R
                ElseIf FastSymbol(a$, "#") Then
                    Set nbstack = Nothing '???
                    IsNumberNew = Matrix(bstack, a$, usehandler, R)
                    If MyIsObject(R) Then R = 0#
                    If SG < 0 Then R = -R
                Else
                    Set bstack.lastobj = var(VR)
                    R = 0
                End If
            End If
            Set usehandler = Nothing
        ElseIf v$ = "Constant" Then
            If var(VR).flag Then
            If Typename(var(VR).Value) = "lambda" Then
                CopyLambda var(VR).Value, bstack
                R = 0
            End If
            Else
            R = var(VR)
            If SG = -1 Then R = -R
            
            End If
        Else
                Set bstack.lastobj = var(VR) 'MakeitObjectGeneric(VR)
                R = 0
        End If
    
Else
If IsNumeric(var(VR)) Then

        R = var(VR)
        If SG < 0 Then R = -R
   Else
   R = 0
  
    End If
End If

IsNumberNew = True
ElseIf VR = -1 Then

R = ReadVarDouble(bstack, v$)
If Not bstack.lastobj Is Nothing Then
If TypeOf bstack.lastobj Is Group Then
If bstack.lastobj.IamApointer Then

 If Left$(a$, 2) = "=>" Then

 Set pppp = BoxGroupVar(bstack.lastobj)

                Mid$(a$, 1, 2) = "." + Chr(3)
                IsNumberNew = SpeedGroup(bstack, pppp, "VAL", "", a$, (0)) = 1
                R = bstack.LastValue
End If

End If
End If
End If
If SG < 0 Then R = -R

IsNumberNew = True
Exit Function
Else
If Len(v$) > 5 Then
If Left$(v$, 5) = "THIS." Or Left$(v$, 5) = "ауто." Then
v$ = Mid$(v$, 5)
v1& = IsLabel(bstack, (v$), v$)
If v$ <> "" Then GoTo removethis
End If
End If
IsNumberNew = False  ''         " " + & String$(w2 - Len(a$), " ")
If IsObject(bstack.LastEnum) Then
  R = bstack.LastEnum.SearchSimple(v$, par)
  If par Then
  If SG < 0 Then R = -R
  IsNumberNew = True
  Exit Function
  End If
 End If

 ''If w2 >= Len(a$) Then a$ = " " & String$(w2 - Len(a$), " ") + a$ Else
 If v1& = 1 Then If numidbackup.Find(v$, w1) Then GoTo findsecond
  If w2 >= Len(a$) Then
  If v$ = myUcase(s1$, True) Then
  a$ = s1$ + a$
  Else
  a$ = v$ + a$
  End If
  End If
   
 If FindNameForGroup(bstack, v$) Then
  UnknownProperty1 a$, v$
 Else

 If LenB(v$) = 0 Then v$ = s1$
  
 UnknownVariable1 a$, v$
End If
End If
Exit Function

Case 4
LOOKFORVARNUM4:
If GetVar(bstack, v$, VR) Then
If Typename(var(VR)) = "lambda" Then
CopyLambda var(VR), bstack
Else

R = var(VR)
If SG < 0 Then R = -R
End If

IsNumberNew = True
Else
If VR = -1 Then

R = ReadVarInt(bstack, v$)
If SG < 0 Then R = -R
IsNumberNew = True
Exit Function
End If
IsNumberNew = False
    If w2 >= Len(a$) Then a$ = Left$(v$ + space$(Len(v$)), w2 - Len(a$)) + a$ Else
        If FindNameForGroup(bstack, v$) Then
            UnknownProperty1 a$, v$
        Else
            UnknownVariable1 a$, v$
        End If
    End If


Exit Function
Case 7
If usebackup Then
    GoTo isasub
Else
    GoTo LOOKFORSUBNUM
 End If
Case 5
'On Error Resume Next
If usebackup Then
        If Not funidbackup.Find(v$, w1) Then
       '' GoTo LOOKFORSUBNUM
       GoTo isasub
        End If
Else
    If Not funid.Find(v$, w1, bstack.numfunnum) Then GoTo LOOKFORSUBNUM
    If w1 < 0 Then GoTo LOOKFORSUBNUM
End If
'Select Case v$

findthird:
On w1 GoTo fun1, fun2, fun3, fun4, fun5, fun6, fun7, fun8, fun9, fun10, fun11, fun12, fun13, fun14, fun15, fun16, fun17, fun18, fun19, fun20, fun21, fun22, fun23, fun24, fun25, fun26, fun27, fun28, fun29, fun30, fun31, fun32, fun33, fun34, fun35, fun36, fun37, fun38, fun39, fun40, fun41, fun42, fun43, fun44, fun45, fun46, fun47, fun48, fun49, fun50, fun51, fun52, fun53, fun54, fun55, fun56, fun57, fun58, fun59, fun60, fun61, fun62, fun63, fun64, fun65, fun66, fun67, fun68, fun69, fun70, fun71, fun72, fun73, fun74, fun75, fun76, fun77, fun78, fun79, fun80, fun81, fun82, fun83, fun84, fun85, fun86, fun87, fun88, fun89, fun90, fun91, fun92, fun93, fun94, fun95, fun96, fun97, fun98, fun99, fun100, fun101, fun102, fun103, fun104, fun105, fun106, fun107, fun108, fun109, fun110, fun111, fun112
IsNumberNew = False
Exit Function
fun112: ' "CREATEOBJ(", "амтийеилемо("
    R = 0
    IsNumberNew = createAnobject(bstack, a$)
Exit Function
fun111: ' "PLAYER(", "паийтгс("
If IsExp(bstack, a$, p, , True) Then
    R = SpriteVisible(CLng(p))
    If SG < 0 Then R = CBool(Not R)
    
    
    IsNumberNew = FastSymbol(a$, ")", True)
End If
Exit Function
fun108: '"POINTER(", "деийтгс("
IsNumberNew = GetPointer(bstack, a$)
Set bstack.lastobj = bstack.lastpointer
Set bstack.lastpointer = Nothing
If IsNumberNew Then IsNumberNew = FastSymbol(a$, ")")
Exit Function
fun101: ' "BANK(", "тяап("
IsNumberNew = False
If IsExp(bstack, a$, R, , True) Then
    If FastSymbol(a$, ",") Then
        If IsExp(bstack, a$, p, , True) Then
            R = Round(R, CLng(p))
            IsNumberNew = FastSymbol(a$, ")", True)
            Else
                MissParam a$
        End If
    Else
    R = Round(R)
    IsNumberNew = FastSymbol(a$, ")", True)
End If
    Else
                    
                MissParam a$
    End If
If SG < 0 Then R = -R
Exit Function

fun99: ' case "IF(","ам("
IsNumberNew = False
If IsExp(bstack, a$, p) Then IsNumberNew = ProcessIf(p, bstack, a$, R)
Exit Function
fun97: ' "READY(", "етоило("
IsNumberNew = False
    w1 = Abs(IsLabel(bstack, a$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If Typename(var(w1)) = doc Then
                    R = SG * Not var(w1).Busy
                Else
                    R = SG * True
                End If
                
                IsNumberNew = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      R = SG * Not pppp.item(w2).Busy
                      Else
                      R = SG * True
                      End If
                Else
                
                End If
                    
                IsNumberNew = FastSymbol(a$, ")", True)
    Else
                    
                MissParam a$
    End If
    Exit Function
fun100: ' "ORDER(","танг("
' this is same as sort numbers inside strings
If IsStrExp(bstack, a$, s1$) Then
If FastSymbol(a$, ",") Then
If IsStrExp(bstack, a$, s$) Then
If FastSymbol(a$, ")") Then
IsNumberNew = True
R = SG * -compareStr4(s$, s1$)
Exit Function
Else
SyntaxError
Exit Function
End If
End If
End If
End If
MissStringExpr
IsNumberNew = False
Exit Function
fun1: ' "PARAM(", "паяал("
v$ = vbNullString
If IsStrExp(bstack, a$, s1$) Then

Do
w1 = Len(s1$)
      If IsNumberD2(s1$, p) Then
      If v$ = vbNullString Then
      R = p
      If SG < 0 Then R = -R
      
        v$ = " "
      Else
      Select Case VarType(p)
        Case vbLong
        v$ = v$ + "," + Str(p) + "&"
        Case vbDecimal
        v$ = v$ + "," + Str(p) + "@"
        Case vbSingle
        v$ = v$ + "," + Str(p) + "~"
        Case vbCurrency
        v$ = v$ + "," + Str(p) + "#"
        Case vbInteger
        v$ = v$ + "," + Str(p) + "%"
        Case Else
        v$ = v$ + "," + Str(p)
        End Select
      End If
      Else
             ISSTRINGA s1$, s$
        If v$ = vbNullString Then Exit Do Else v$ = v$ + ",{" + s$ + "}"
    End If
    FastSymbol s1$, ","
Loop Until Trim$(s1) = vbNullString Or w1 = Len(s1$)
ElseIf IsExp(bstack, a$, p) Then
    If bstack.lastobj Is Nothing Then
        ExpectedObjInline a$
    ElseIf TypeOf bstack.lastobj Is mHandler Then
        Set usehandler = bstack.lastobj
        Set bstack.lastobj = Nothing
        If usehandler.indirect >= 0 Then
            If MyIsObject(var(usehandler.indirect)) Then
                dd = usehandler.indirect
                Set usehandler = New mHandler
                On Error Resume Next
                'Err.Clear
                ' maybe we want the typelib
                If FastSymbol(a$, ",") Then
                
                End If
                Set usehandler.objref = MakeATypeLib(var(dd))

                If Err Then
                   Err.Clear
                   Set bstack.lastobj = Nothing
                   cantreadlib a$
                    Else
                   usehandler.t1 = 1
                    Set bstack.lastobj = usehandler
                End If
                
                On Error GoTo 0
                Set usehandler = Nothing
            Else
            ExpectedObjInline a$
            End If
            Else
            If usehandler.IamEnum Then Set anything = usehandler.objref: GoTo contparamhere
        End If
    ElseIf TypeOf bstack.lastobj Is PropReference Then
        Set useProp = bstack.lastobj
        If useProp.IsObj Then
            R = useProp.Value
            Set anything = useProp.lastobjfinal
contparamhere:
            Set usehandler = New mHandler
                On Error Resume Next
                'Err.Clear
                ' maybe we want the typelib
                If FastSymbol(a$, ",") Then
                
                End If
                Set usehandler.objref = MakeATypeLib(anything)

                If Err Then
                    Err.Clear
                    Set bstack.lastobj = Nothing
                    cantreadlib a$
                Else
                    usehandler.t1 = 1
                    Set bstack.lastobj = usehandler
                End If
                On Error GoTo 0
         Else
            ExpectedObjInline a$
        End If
    Else
            Set anything = bstack.lastobj
            Set usehandler = New mHandler
            On Error Resume Next
            If FastSymbol(a$, ",") Then
            
            End If
            Set usehandler.objref = MakeATypeLib(anything)

            If Err Then
                Err.Clear
                Set bstack.lastobj = Nothing
                cantreadlib a$
            Else
                usehandler.t1 = 1
                Set bstack.lastobj = usehandler
            End If
            On Error GoTo 0
        End If
    End If
    IsNumberNew = FastSymbol(a$, ")", True)
    a$ = Mid$(v$, 2) + a$
    Exit Function
fun73: ' "EACH("
    If iter(bstack, a$, 1) Then
        R = 0
        IsNumberNew = FastSymbol(a$, ")", True)
    Else
        IsNumberNew = False
    End If
    Exit Function
fun72: ' "йахе("
    If iter(bstack, a$, 0) Then
        R = 0
        IsNumberNew = FastSymbol(a$, ")", True)
    Else
        IsNumberNew = False
    End If
    Exit Function
fun2: ' "STACKITEM(", "тилгсыяоу("
    IsNumberNew = StackItem(bstack, a$, SG, R)
    If FastSymbol(a$, "#") Then GoTo comehere
    Exit Function
fun3: ' "SGN(", "сгл("
If IsExp(bstack, a$, p, , True) Then
R = Sgn(MyRound(p, 28))


If SG < 0 Then R = -R


 IsNumberNew = FastSymbol(a$, ")", True)
 Else
 MissParam a$: IsNumberNew = False
End If
Exit Function

fun4: ' "FRAC(", "дей("
If IsExp(bstack, a$, p, , True) Then
R = MyRound(Abs(Abs(p) - Int(Abs(p))), 13)
If SG < 0 Then R = -R


 IsNumberNew = FastSymbol(a$, ")", True)
 Else
MissParam a$: IsNumberNew = False
End If
Exit Function
fun5: ' "MATCH(", "таутисг("
If IsStrExp(bstack, a$, s1$) Then
If s1$ = vbNullString Then
R = 0

               IsNumberNew = FastSymbol(a$, ")", True)
ElseIf VALIDATEmStiva(bstack, UCase$(s1$), s$) Then   ' Only S and N
                If s$ = vbNullString Then
                    R = 0
                Else
                   R = -SG
               End If
               Else
               R = 0
               End If
               
               IsNumberNew = FastSymbol(a$, ")", True)
Else
MissParam a$
End If
Exit Function
fun6: ' "LOCALE(", "топийо("
If IsStrExp(bstack, a$, s1$) Then
If FastSymbol(a$, ",") Then
If IsExp(bstack, a$, p, , True) Then
R = SG * FoundSpecificLocaleId(s1$, CLng(Fix(p)))
Else
MissParam a$: IsNumberNew = False: Exit Function
End If
Else
R = SG * FoundLocaleId(s1$)
End If
   

    IsNumberNew = FastSymbol(a$, ")", True)
End If
Exit Function
fun7: ' "FILELEN(", "аявеиоу.лгйос("
If IsStrExp(bstack, a$, s1$) Then
If s1$ = vbNullString Then
R = 0

IsNumberNew = FastSymbol(a$, ")", True)
Else
If ExtractPath(s1$) = vbNullString Then
    If CFname(s1$) <> "" Then
        s1$ = CFname(s1$)
    ElseIf mylcasefILE(s1$) = ExtractName(s1$, True) Then
        s1$ = mcd + s1$
    End If
End If
       R = SG * myFileLen(GetDosPath(s1$))
               
               IsNumberNew = FastSymbol(a$, ")", True)
End If
Else
: MissParam a$
End If
Exit Function
fun8: ' "TAB(", "стгкг("
If IsExp(bstack, a$, p, , True) Then

R = SG * p * (players(GetCode(bstack.Owner)).Column + 1)
   
    IsNumberNew = FastSymbol(a$, ")", True)
End If
Exit Function
fun9: ' "KEYPRESS(", "патглемо("
If Not IsExp(bstack, a$, p) Then
MissNumExpr
IsNumberNew = False
Exit Function
Else
R = SG * CLng(KeyPressed(CLng(Fix(p))))

End If
 

    IsNumberNew = FastSymbol(a$, ")", True)
    Exit Function
fun10: ' "INKEY(", "емйол("

BLOCKkey = True
If Not IsExp(bstack, a$, p) Then p = 50: dn = 1
If p < 50 Then p = 50
p = p / 2
    p = uintnew(p + timeGetTime)
   If dn = 1 Then R = 0 Else R = clickMe

If Not (bstack.IamThread And dn = 1) Then clickMe2 = -2
               w1 = -1
                    Do While p > uintnew(timeGetTime)
                  
                  
                 If Not bstack.IamThread Then
                    MyDoEvents
                    mywait bstack, 1
                    Else
                    
                    p = 0
                    ''If (dn = 0) Then
                    If R = clickMe2 Then Exit Do
                    
                    R = -3
                      clickMe2 = clickMe
                      
                      
                    End If
                    If clickMe2 = R Then clickMe2 = -2
                    If w1 = -1 Then
                    If clickMe2 <> -2 Then
             
              
                    w1 = clickMe2
              
                    If w1 = 19 Or w1 = 131139 Then
                    'this IS A BREAK
                    BLOCKkey = False
                  
                   Form1.GiveASoftBreak (w1 = 19)
                    End If
                    p = 0
                    End If
                    End If
                     
                Loop
                If bstack.IamThread Then
        If bstack.LastClick = w1 Then
            w1 = -1
        Else
            bstack.LastClick = w1
        End If
End If
  R = SG * w1
    
  clickMe2 = -1



IsNumberNew = FastSymbol(a$, ")", True)
BLOCKkey = False
Exit Function
fun11: ' "тлгла(", "MODULE("
      MakeThisSub bstack, a$
    If IsLabel(bstack, a$, s$) Then
        R = SG * True
        If Right$(s$, 1) = "(" Then
            FastSymbol a$, ")"
            s$ = s$ + ")"
        End If
        If GetlocalSub(s$, w1) Then
            ElseIf Not GetSub(s$, w1) Then
            If Not GetSub2(bstack, s$, w1) Then
                R = False
                End If
        End If
        IsNumberNew = True
    End If

    IsNumberNew = FastSymbol(a$, ")", True)
Exit Function
fun12: ' "басг(", "MDB("
If IsStrExp(bstack, a$, s$) Then
If ExtractType(s$) = vbNullString Then s$ = s$ & ".MDB"
s$ = CFname(s$)
If s$ <> "" Then
R = CheckMine(s$) * SG

Else
R = 0
End If
   
    IsNumberNew = FastSymbol(a$, ")", True)
End If
Exit Function
fun13: ' "ASK(", "яыта("
If IsStrExp(bstack, a$, AskText$) Then
If Not CallAsk(bstack, a$, v$) Then IsNumberNew = False: Exit Function

R = SG * Form1.NeoASK(bstack)
AskInput = False
    IsNumberNew = FastSymbol(a$, ")", True)
End If
Exit Function
fun14: ' "суцйяоусг(", "COLLIDE("
    IsNumberNew = IsCollide(bstack, a$, R, SG)
    Exit Function
fun15: ' "лецехос.у(", "SIZE.Y("

    IsNumberNew = SizeY(bstack, SG, a$, s$, s1$, R)
    Exit Function
fun16: ' "лецехос.в(", "SIZE.X("
    IsNumberNew = SizeX(bstack, SG, a$, s$, s1$, R)
    Exit Function
fun17: ' "WRITABLE(", "еццяаьило("  ' АМ ЛПОЯЧ МА ЦЯэЬЫ СТО ЖэЙЕКО
    If IsStrExp(bstack, a$, s$) Then
      R = SG * WeCanWrite(s$)
   
    
    
    IsNumberNew = FastSymbol(a$, ")", True)
    Exit Function
    End If
    IsNumberNew = False
    Exit Function
fun110:  '"HSL(","вйж("

    If Not ColorHSL(bstack, a$, R) Then Exit Function
    R = SG * -R

        IsNumberNew = FastSymbol(a$, ")", True)
        Exit Function
fun18: ' "COLOR(", "COLOUR(", "вяыла("
    
   If Not ColorRGB(bstack, a$, R) Then Exit Function

    R = SG * -R

        IsNumberNew = FastSymbol(a$, ")", True)
        Exit Function
fun19: ' "DIMENSION(", "диастасг("
IsNumberNew = IsDimension(bstack, a$, R, SG)

    Exit Function
fun20: ' "ARRAY(", "пимайас("
    IsNumberNew = IsArrayFun(bstack, a$, R, SG)
    If FastSymbol(a$, "#") Then GoTo comehere
    Exit Function
fun21: ' "FUNCTION(", "сумаятгсг("
IsNumberNew = False
    If IsStrExp(bstack, a$, s$) Then
    If IsSymbolBracket(s$) Then
            PushStage bstack, False
            s1$ = block(s$)
            FastSymbol s$, "}"
            GlobalSub "A_()", s1$, Trim$(s$)
            IsSymbol3 a$, ","
              a$ = "A_(*" & a$
            IsNumberNew = IsExp(bstack, a$, p)
            If SG < 0 Then R = -p Else R = p
            PopStage bstack
Else
If lookOne(a$, ".") Then
dd = 1
      s1$ = aheadstatus(a$, , dd)
s$ = s$ + Left$(a$, dd - 1)
a$ = Mid$(a$, dd)
End If
    If FastSymbol(a$, ",") Then
    End If
     If Right$(s$, 1) = ")" Then
        a$ = Left$(s$, Len(s$) - 1) & a$
    ElseIf InStr(s$, ").") > 0 Then
    If Not FastSymbol(a$, ")") Then
        a$ = s$ & "(*" & a$
    Else
        a$ = s$ & a$
        End If
     Else
      a$ = s$ & "(*" & a$
      End If
    IsNumberNew = IsExp(bstack, a$, p)
    If SG < 0 Then R = -p Else R = p
  End If
    Else
        MissParam a$
    
    End If
    Exit Function
fun22: ' "DRIVE.SERIAL(", "сеияиайос.дисйоу("
IsNumberNew = DriveSerial1(bstack, a$, R, SG)
Exit Function
fun23: ' "FILE.STAMP(", "аявеиоу.сталпа("
IsNumberNew = False
    If IsStrExp(bstack, a$, s$) Then
    pp = 1
    If IsSymbol(a$, ",") Then
        If Not IsExp(bstack, a$, pp) Then
        
         MissNumExpr
        Exit Function
        End If
    End If
    If CFname(s$, p, pp) <> vbNullString Then
    If p = 0 Then
    CantReadFileTimeStap a$
    Else
     R = SG * p
     End If
     Else
        BadFilename
        Exit Function
     
     End If
     
    
    IsNumberNew = FastSymbol(a$, ")", True)
    Else
 MissParam a$
    End If
    Exit Function
fun25: ' "EXIST.DIR(", "упаявеи.йатакоцос("
IsNumberNew = False
    If IsStrExp(bstack, a$, s$) Then
    R = SG * isdir(s$)
     
    
    IsNumberNew = FastSymbol(a$, ")", True)
    Else
: MissParam a$
    End If
    Exit Function
fun26: ' "EXIST(", "упаявеи("
IsNumberNew = ExistNum(bstack, a$, R, SG)
Exit Function
fun27: ' "JOYPAD(", "кабг("
  IsNumberNew = False
    If IsExp(bstack, a$, R, , True) Then
        
    R = SG * Int(R)
    
    
    If R < 0 Or R > 15 Then
    
    WrongJoypadNumber a$

    Exit Function
    End If
    If Not MYJOYSTAT(R).Enabled Then
    IsNumberNew = False
        joypader a$, R
    Exit Function
    End If
    If Not MYJOYSTAT(R).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(R).Wait2Read Then
        joypader a$, R
        
    Exit Function
    End If
    End If
    R = SG * MYJOYSTAT(R).lngButton
IsNumberNew = FastSymbol(a$, ")", True)
       Else
       IsNumberNew = False
  MissParam a$
         ' IsNumberNew = FastSymbol(a$, ")")
  End If
  Exit Function
fun28: ' "JOYPAD.DIRECTION(", "кабг.йатеухумсг("
  IsNumberNew = False
    If IsExp(bstack, a$, R, , True) Then
    R = SG * Int(R)
    
    If R < 0 Or R > 15 Then
    
    WrongJoypadNumber a$
    
    Exit Function
    End If
    If Not MYJOYSTAT(R).Enabled Then
        joypader a$, R
    
    Exit Function
    End If
    If Not MYJOYSTAT(R).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(R).Wait2Read Then
        joypader a$, R
    
    Exit Function
    End If
    End If
    R = SG * MYJOYSTAT(R).joyPaD
    IsNumberNew = FastSymbol(a$, ")", True)
       Else
        MissParam a$
  End If
  Exit Function
fun29: ' "JOYPAD.ANALOG.X(", "кабг.амакоцийо.в("
  IsNumberNew = False
    If IsExp(bstack, a$, R, , True) Then
    R = SG * Int(R)
    
    If R < 0 Or R > 15 Then
    
    WrongJoypadNumber a$
    Exit Function
    End If
    If Not MYJOYSTAT(R).Enabled Then
        joypader a$, R
            Exit Function
    End If
    If Not MYJOYSTAT(R).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(R).Wait2Read Then
        joypader a$, R
    Exit Function
    End If
    End If
    R = SG * MYJOYSTAT(R).AnalogX
    IsNumberNew = FastSymbol(a$, ")", True)
       Else
        MissParam a$
  End If
  Exit Function
fun30: ' "JOYPAD.ANALOG.Y(", "кабг.амакоцийо.у("
  IsNumberNew = False
    If IsExp(bstack, a$, R, , True) Then
    R = SG * Int(R)
    
    If R < 0 Or R > 15 Then
    
    WrongJoypadNumber a$
    Exit Function
    End If
    If Not MYJOYSTAT(R).Enabled Then
        joypader a$, R
    Exit Function
    End If
    If Not MYJOYSTAT(R).Wait2Read Then
    PollJoypadk  ' МА ТО ДЫ эЛЕСА
    
    If Not MYJOYSTAT(R).Wait2Read Then
        joypader a$, R
    Exit Function
    End If
    End If
    R = SG * MYJOYSTAT(R).AnalogY
    IsNumberNew = FastSymbol(a$, ")", True)
       Else
            MissParam a$
  End If
  Exit Function
fun104: ' "BUFFER(", "диаяхяысг("
IsNumberNew = False
    If IsStrExp(bstack, a$, s$) Then
        If Not bstack.lastobj Is Nothing Then GoTo contbuf1
         w1 = Abs(Asc(v$) < 128)
        If IsLabelSymbolNew(a$, "ыс", "AS", w1) Then
            If Not IsSymbol(a$, "DECODE64", 8) Then
                MyEr "Only Decode64 supported", "лЭМО ТО Decode64 УПОСТГЯъФЕТАИ"
                Exit Function
            End If
            Set usehandler = New mHandler
            usehandler.t1 = 2
            
            Set usehandler.objref = Decode64toMemBloc(s$, par)
            If par Then
    
                Set bstack.lastobj = usehandler
                
                
                IsNumberNew = FastSymbol(a$, ")", True)
                Exit Function
            Else
                MyEr "Can't Decode String", "дЕМ ЛПОЯЧ МА АПОЙЫДИЙОПОИчСЫ ТО АКЖАЯИХЛГТИЙЭ"
                IsNumberNew = False
                Exit Function
            End If
        ElseIf CFname(s$) <> "" Then
            Set usehandler = New mHandler
            usehandler.t1 = 2
            If FastSymbol(a$, ",") Then
                If Not IsExp(bstack, a$, p) Then
                MissNumExpr
                Exit Function
                End If
                End If
            Set usehandler.objref = File2newMemblock(s$, R, p)
            If R = 0# Then
    
                Set bstack.lastobj = usehandler
                
                
                IsNumberNew = FastSymbol(a$, ")", True)
                Exit Function
            End If
        Else
            MissFile
        End If
    ElseIf IsExp(bstack, a$, R) Then
contbuf1:
        R = 0#
        p = 0#
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                Set bstack.lastobj = Nothing
                If usehandler.t1 = 2 Then
                    If FastSymbol(a$, ",") Then
                        IsExp bstack, a$, R
                        If FastSymbol(a$, ",") Then
                            If Not IsExp(bstack, a$, p) Then
                                MissNumExpr
                                Exit Function
                            End If
                        End If
                    End If
                
                     Set usehandler.objref = usehandler.objref.Copy(R, p)
                    Set bstack.lastobj = usehandler
                    IsNumberNew = FastSymbol(a$, ")", True)
                    Exit Function
                End If
            End If
            
            
        End If
    Else
    IsNumberNew = FastSymbol(a$, ")", True)
    End If
    ' no buffer return (using Buffer() as empty function)
    R = 0#
    Set bstack.lastobj = Nothing
    Exit Function
fun103: ' "IMAGE(", "еийома("
IsNumberNew = False
    If IsStrExp(bstack, a$, s$) Then
        If Left$(s$, 4) = "cDIB" And Len(s$) > 12 Then
            Set usehandler = New mHandler
            usehandler.t1 = 2
        
            Set usehandler.objref = SaveStr2MemBlock(s$, R)
            If R = 0 Then
                Set bstack.lastobj = usehandler
                IsNumberNew = FastSymbol(a$, ")", True)
                R = 0#
                Exit Function
            End If
        Else
                noImage a$
        End If
            
            
    ElseIf IsExp(bstack, a$, s$) Then
      
        If Not bstack.lastobj Is Nothing Then
           If TypeOf bstack.lastobj Is mHandler Then
              Set usehandler = bstack.lastobj
              Set bstack.lastobj = Nothing
              If usehandler.t1 = 2 Then
              
                  If usehandler.objref.ReadImageSizeX(R) Then
                  
                  
                    R = 0
                    dd = 0
                    w1 = -1
                    w2 = -1
                    w3 = 0
                    If FastSymbol(a$, ",") Then
                        If Not IsExp(bstack, a$, p) Then
                            If Not MaybeIsSymbol(a$, ",") Then
                                Set bstack.lastobj = Nothing
                                MissParam a$
                                Exit Function
                            End If
                            dd = &HFFFFFF
                        Else
                        dd = CLng(p)
                        End If
                        If FastSymbol(a$, ",") Then
                            If Not IsExp(bstack, a$, p) Then
                                If Not MaybeIsSymbol(a$, ",") Then
                                    Set bstack.lastobj = Nothing
                                    MissParam a$
                                    Exit Function
                                End If
                            Else
                                w1 = CLng(Abs(p))
                                If w1 < 1 Then w1 = -1
                            End If
                            If FastSymbol(a$, ",") Then
                                If Not IsExp(bstack, a$, p) Then
                                    If Not MaybeIsSymbol(a$, ",") Then
                                        Set bstack.lastobj = Nothing
                                        MissParam a$
                                        Exit Function
                                    End If
                                Else
                                    w2 = CLng(Abs(p))
                                    If w2 < 1 Then w2 = -1
                                End If
                                If FastSymbol(a$, ",") Then
                                If Not IsExp(bstack, a$, p) Then
                                    Set bstack.lastobj = Nothing
                                    MissParam a$
                                    Exit Function
                                Else
                                    w3 = CLng(Abs(p))
                                End If
                  End If
                                
                            End If
                        
                        End If
                    Else
                        p = &HFFFFFF
                    End If
                    Set bstack.lastobj = usehandler.CreateFromPicture(dd, w1, w2, w3)
                          Set usehandler = Nothing
                          IsNumberNew = FastSymbol(a$, ")", True)
                      Exit Function
                  End If
              End If
           End If
        End If
        Set bstack.lastobj = Nothing
            noImageInBuffer a$
            IsNumberNew = False
            R = 0#
    Else
        MissParam a$
    End If
    Exit Function

fun31: ' "IMAGE.X(", "еийома.в("
IsNumberNew = GetImageX(bstack, a$, R, SG)
    Exit Function
fun32: ' "IMAGE.Y(", "еийома.у("
    IsNumberNew = GetImageY(bstack, a$, R, SG)
   
    Exit Function
fun33: ' "IMAGE.X.PIXELS(", "еийома.в.сглеиа("
IsNumberNew = GetImageXpixels(bstack, a$, R, SG)
    Exit Function
fun34: ' "IMAGE.Y.PIXELS(", "еийома.у.сглеиа("
IsNumberNew = GetImageYpixels(bstack, a$, R, SG)

    Exit Function
fun35: ' "VALID(", "ецйуяо("
IsNumberNew = Validator(bstack, a$, v$, R, SG)
Exit Function
fun36: ' "EVAL(", "ейжя(", "ейжяасг("
    IsNumberNew = IsEval(v$, bstack, a$, R, SG)
    If FastOperator(a$, "(", 1) Then
    If Not bstack.lastobj Is Nothing Then
     If Typename(bstack.lastobj) = mHdlr Then
     Set pppp = New mArray
     Set pppp.GroupRef = bstack.lastobj
     Set bstack.lastobj = Nothing
     pppp.Arr = False
     GoTo contAr2
     ElseIf Typename(bstack.lastobj) = myArray Then
     Set pppp = bstack.lastobj
     Set bstack.lastobj = Nothing
     v$ = pppp.CodeName + "("
     GoTo contAr2
     ElseIf Typename(bstack.lastobj) = mgroup Then
     GoTo contgrouppar
     End If
    Else
    SyntaxError
    Exit Function
    End If
    
    End If
    If FastSymbol(a$, "#") Then GoTo comehere
    Exit Function
fun37: ' "POINT(", "сглеио("
    IsNumberNew = IsPoint(bstack, a$, R, SG)
    Exit Function
fun38: ' "CTIME(", "упыяа("
    IsNumberNew = IsCtime(bstack, a$, R, SG)
    Exit Function
fun39: ' "CDATE(", "уплея("
    IsNumberNew = IsCdate(bstack, a$, R, SG)
    Exit Function
fun40: ' "TIME(", "вяомос("
    IsNumberNew = IsTimeVal(bstack, a$, R, SG)
    Exit Function
fun41: ' "DATE(", "глеяа("
    IsNumberNew = IsDataVal(bstack, a$, R, SG)
    Exit Function
fun42: ' "VAL(", "тилг(", "аниа("
    IsNumberNew = IsVal(bstack, a$, R, SG, Left$(v$, 1) = "V")
    If FastSymbol(a$, "#") Then GoTo comehere
    Exit Function
fun43: ' "хесгдениа("
    IsNumberNew = IsRinstr(bstack, a$, R, SG, 0)
    Exit Function
fun107: ' "RINSTR("
    IsNumberNew = IsRinstr(bstack, a$, R, SG, 1)
    Exit Function
fun44: ' "INSTR(", "хесг("
    IsNumberNew = IsInstr(bstack, a$, R, SG, 0)
    Exit Function
fun106:
    IsNumberNew = IsInstr(bstack, a$, R, SG, 1)
    Exit Function
fun45: ' "RECORDS(", "еццяажес("
    IsNumberNew = IsRecords(bstack, a$, R, SG)
    Exit Function
fun46: ' "GROUP.COUNT(", "олада.сумоко("
    IsNumberNew = IsGroupCount(bstack, a$, R, SG)
    Exit Function
fun47: ' "PARAGRAPH(", "паяацяажос("
    IsNumberNew = IsParagr(bstack, a$, R, SG)
    Exit Function
fun48: ' "PARAGRAPH.INDEX(", "аяихлос.паяацяажоу("
 IsNumberNew = IsParIndex(bstack, a$, R, SG)
    Exit Function
fun49: ' "BACKWARD(", "писы("
    IsNumberNew = IsForwBack(1, bstack, a$, R, SG)
    Exit Function
fun50: ' "FORWARD(", "лпяоста("
    IsNumberNew = IsForwBack(0, bstack, a$, R, SG)
    Exit Function
fun51: ' "DOC.PAR(", "еццяажоу.пая("
    IsNumberNew = IsDocPar(bstack, a$, R, SG)
    Exit Function
fun52: ' "MAX.DATA(", "лецако.сеияас("
    IsNumberNew = IsMaxData(bstack, a$, R, SG)
    Exit Function
fun53: ' "MIN.DATA(", "лийяо.сеияас("
    IsNumberNew = IsMinData(bstack, a$, R, SG)
    Exit Function
fun54: ' "MAX(", "лецако("
    IsNumberNew = IsCompMinMax(2, bstack, a$, R, SG)
    Exit Function
fun55: ' "MIN(", "лийяо("
    IsNumberNew = IsCompMinMax(1, bstack, a$, R, SG)
    Exit Function
fun56: ' "COMPARE(", "суцйяиме("
    IsNumberNew = IsCompMinMax(0, bstack, a$, R, SG)
    Exit Function
fun57: ' "DOC.UNIQUE.WORDS(", "еццяажоу.ломадийес.кенеис("
    IsNumberNew = IsDocUniqueWords(bstack, a$, R, SG)
    Exit Function
fun58: ' "DOC.WORDS(", "еццяажоу.кенеис("
    IsNumberNew = IsDocWords(bstack, a$, R, SG)
    Exit Function
fun59: ' "DOC.LEN(", "еццяажоу.лгйос("
    IsNumberNew = IsDocLen(bstack, a$, R, SG)
    Exit Function
fun60: ' "LEN.DISP(", "лгйос.елж("
    IsNumberNew = IsLenDisp(bstack, a$, R, SG)
    Exit Function
fun61: ' "LEN(", "лгйос("
 IsNumberNew = IsLen(bstack, a$, R, SG)
    Exit Function
fun62: ' "SQRT(", "яифа("
    IsNumberNew = IsSqrt(bstack, a$, R, SG)
    Exit Function
fun63: ' "FREQUENCY(", "сувмотгта("
    IsNumberNew = IsFreq(bstack, a$, R, SG)
    Exit Function
fun64: ' "LOG(", "коц("
    IsNumberNew = IsLog(bstack, a$, R, SG)
    Exit Function
fun65:  ' "LN(", "кж("
    IsNumberNew = IsLn(bstack, a$, R, SG)
    Exit Function
fun66: ' "ATN(", "тон.еж("
    IsNumberNew = IsAtan(bstack, a$, R, SG)
    Exit Function
fun67:  ' "TAN(", "ежап("
  IsNumberNew = IsTan(bstack, a$, R, SG)
    Exit Function
fun68:  ' "COS(", "сум("
    IsNumberNew = IsCos(bstack, a$, R, SG)
    Exit Function
fun69:  ' "SIN(", "гл("
    IsNumberNew = IsSin(bstack, a$, R, SG)
    Exit Function
fun70:  ' "ABS(", "апок("
IsNumberNew = IsAbs(bstack, a$, R, SG)
Exit Function
fun71: ' "LOWORD(", "LOWWORD(", "йатылисо("
    IsNumberNew = IsLOWORD(bstack, a$, R, SG)
    Exit Function
fun74: ' "HIWORD(", "HIGHWORD(", "памылисо("
   IsNumberNew = IsHIWORD(bstack, a$, R, SG)
    Exit Function
fun75: ' "BINARY.NEG(", "дуадийо.амти(", "дуадийо.амтистяожо("
    IsNumberNew = IsBinaryNeg(bstack, a$, R, SG)
    Exit Function
fun76: ' "BINARY.OR(", "дуадийо.г("
    IsNumberNew = IsBinaryOr(bstack, a$, R, SG)
    Exit Function
fun105: ' "BINARY.NOT(", "дуадийо.ови("
    IsNumberNew = IsBinaryNot(bstack, a$, R, SG)
    Exit Function
fun77: ' "BINARY.AND(", "дуадийо.йаи("
    IsNumberNew = IsBinaryAnd(bstack, a$, R, SG)
    Exit Function
fun78: ' "BINARY.XOR(", "дуадийо.апо("
    IsNumberNew = IsBinaryXor(bstack, a$, R, SG)
    Exit Function
fun79: ' "HILOWWORD(", "дуолиса("
    IsNumberNew = IsHILOWWORD(bstack, a$, R, SG)
    Exit Function
fun80: ' "BINARY.SHIFT(", "дуадийо.окисхгсг("
    IsNumberNew = IsBinaryShift(bstack, a$, R, SG)
    Exit Function
fun81: ' "BINARY.ROTATE(", "дуадийг.пеяистяожг("
    IsNumberNew = IsBinaryRotate(bstack, a$, R, SG)
    Exit Function
fun82: ' "SINT(", "айеяаио.дуадийо("
' GET AN Unsigned AND GIVES A SIGN...AS READING BITS
    IsNumberNew = IsSint(bstack, a$, R, SG)
    Exit Function
fun83: ' "USGN(", "дуадийо("
    IsNumberNew = IsUsgn(bstack, a$, R, SG)
    Exit Function
fun84: ' "UINT(", "дуадийо.айеяаио("
' READING BITS OF A SIGN AND GIVE AN Unsigned OF SAME BITS
    IsNumberNew = IsUint(bstack, a$, R, SG)
    Exit Function
fun102: ' "CEIL(","ояож("
    IsNumberNew = IsCeil(bstack, a$, R, SG)
    Exit Function
fun85:  ' "ROUND(", "стяоцц("
    IsNumberNew = IsRound(bstack, a$, R, SG)
    Exit Function
fun86:  ' "INT(", "ай(", "FLOOR(","дапед("
    IsNumberNew = IsInt(bstack, a$, R, SG)
    Exit Function
fun87: ' "SEEK(", "летахесг("
    IsNumberNew = IsSeek(bstack, a$, R, SG)
    Exit Function
fun88:  ' "EOF(", "текос("
    IsNumberNew = IsEof(bstack, a$, R, SG)
    Exit Function
fun89: ' "RANDOM(", "туваиос("
    IsNumberNew = IsRandom(bstack, a$, R, SG)
    Exit Function
fun24: ' "STACK(", "сыяос("
    IsNumberNew = IsStack(bstack, a$, R, SG)
    Exit Function
fun92: ' "GROUP(", "олада("
    IsNumberNew = IsGroup(bstack, a$, R)
    Exit Function
fun98: ' "PROPERTY(", "идиотгта("
    IsNumberNew = IsProperty(bstack, a$, R, SG)
    Exit Function
fun90: ' "CHRCODE(", "ваяйыд("
    IsNumberNew = IsChrCode(bstack, a$, R, SG)
    Exit Function
fun91: ' "ASC(", "йыд("
    IsNumberNew = IsAsc(bstack, a$, R, SG)
    Exit Function
fun94: ' "CONS(", "емысг("
    IsNumberNew = IsCons(bstack, a$, R, SG)
    If FastSymbol(a$, "#") Then GoTo comehere
    Exit Function
fun95: ' "CAR(", "пяыто("
    IsNumberNew = IsCar(bstack, a$, R)
    If FastSymbol(a$, "#") Then GoTo comehere
    Exit Function
fun96: ' "CDR(", "еполема("
    IsNumberNew = IsCdr(bstack, a$, R)
    If FastSymbol(a$, "#") Then GoTo comehere
    Exit Function
fun93: ' "TEST(", "дойилг("
    IsNumberNew = IsTest(bstack, a$, R, SG)
    Exit Function
fun109: ' "BINARY.ADD(", "дуадийо.пяосхесг(","дуадийо.пяо("
    IsNumberNew = IsBinaryAdd(bstack, a$, R, SG)
    Exit Function
LOOKFORSUBNUM:
''On Error Resume Next
If Len(s1$) = 1 Then
If s1$ = Chr(0) Then
If bstack.lastpointer Is Nothing Then GoTo skiperror
Set pppp = bstack.lastpointer
Set bstack.lastpointer = Nothing
w2 = 0
GoTo contAr22
Else
SyntaxError
Exit Function
End If
Else
s1$ = v$ & ")" ' ANY CHAR HERE
End If
MakeThisSubNum bstack, s1$
If IsSymbol(a$, "*") Then
'is a function allways...
If GetlocalSub(s1$, v1&) Then
    GoTo contAr1
ElseIf GetSub(s1$, v1&) Then
GoTo contAr1
ElseIf GetSub2(bstack, s1$, v1&) Then
GoTo contAr1

Else
GoTo skiphere
End If

Else
If neoGetArray(bstack, v$, pppp, , , True) Then

    GoTo contAr2
ElseIf LastErNum <> 0 Then
Exit Function
ElseIf GetlocalSub(s1$, v1&) Then
    GoTo contAr1
ElseIf neoGetArray(bstack, v$, pppp, , True) Then
GoTo contAr2
ElseIf GetSub2(bstack, s1$, v1&) Then
GoTo contAr1

ElseIf GetSub(s1$, v1&) Then
GoTo contAr1
Else
skiphere:
If Len(bstack.UseGroupname) > 0 Then
    If InStr(s1$, bstack.UseGroupname) = 1 Then
        s1$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(s1$, Len(bstack.UseGroupname) + 1)
        If GetSub(s1$, v1&) Then GoTo contAr1
    End If
End If
If Right$(s1$, 1) = ")" Then
    If here$ Like "*." + s1$ Then
        subHash.ItemCreatorNoSwap s1$, bstack.OriginalCode, True
        GoTo contAr1
    ElseIf s1$ = "LAMBDA()" Then
contlambda01:
        If bstack.IamLambda Then
            s1$ = bstack.FuncRec
        Else
           s1$ = Mid$(here$, rinstr(here$, "].") + 2)
           If Right$(here$, 2) = "()" And bstack.UseGroupname = vbNullString Then

            s1$ = sbf(bstack.OriginalCode).goodname
            v1& = bstack.OriginalCode
           ElseIf Not GetSub(s1$, v1&) Then
               If here$ Like "*." + s1$ Then
                  ' subHash.ItemCreatorNoSwap s1$, bstack.OriginalCode, True
                  s1$ = sbf(bstack.OriginalCode).goodname
                   v1& = bstack.OriginalCode
               Else
                   GoTo skiperror
               End If
           End If
        End If
        GoTo contAr1
    ElseIf s1$ = "калда()" Then
        GoTo contlambda01
    Else
        If Right$(s1$, 3) <> "$()" Then
            If neoGetArray(bstack, Left$(s1$, Len(s1$) - 2) + "$(", pppp) Then GoTo contAr2
        End If
        dd = dd + 1
        If dd > 30 Then
            IsNumberNew = False
            Exit Function
        End If
    End If
End If
If funidbackup.Find(v$, w1) Then GoTo findthird
GoTo skiperror
End If
End If
'''ver 18
If GetSub(s1$, v1&) Then
GoTo contAr1
ElseIf neoGetArray(bstack, v$, pppp) Then
GoTo contAr2
Else
GoTo skiperror
End If
If GetSub(s1$, v1&) Then
contAr1:
's1$ = Trim$(s1$)

    If bstack.NoFuncError Then
    
    CallNext bstack, a$, par, p, v$
    If par Then
        If SG < 0 Then R = -p Else R = p
        IsNumberNew = True
    Else
    R = 0
        IsNumberNew = False
    End If
                
            
Else
    
    Set nbstack = New basetask
    Set nbstack.Parent = bstack
    If bstack.IamThread Then Set nbstack.Process = bstack.Process
    Set nbstack.Owner = bstack.Owner
    nbstack.OriginalCode = v1&
    nbstack.UseGroupname = sbf(v1&).sbgroup
    nbstack.tpointer = sbf(v1&).tpointer
    nbstack.SetV
    If GoFunc(nbstack, s1$, a$, p) Then
        ' Lookone(a$,"#")
        If Left$(a$, 1) = "#" Then
            If nbstack.lastobj Is Nothing Then
            NotArray
            IsNumberNew = False
            End If
            Set nbstack = Nothing
            Set anything = bstack.lastobj
            
           ' Set bstack.lastobj = anything
            If TypeOf bstack.lastobj Is mHandler Then
                FastSymbol a$, "#"
               ' Set nbstack = Nothing
                Set bstack.lastobj = anything
                GoTo comehere
            ElseIf TypeOf bstack.lastobj Is Group Then
                Set userGroup = anything
                Set nbstack = Nothing
                Set bstack.lastobj = anything
                If Not (userGroup.HasValue And Not userGroup.HasParameters) Then
                Mid$(a$, 1, 1) = "."
            End If
again1001:
            Set pppp = New mArray
            pppp.Arr = False
            Set pppp.GroupRef = bstack.lastobj
            w2 = -2
            Set nbstack = Nothing
            Set bstack.lastobj = Nothing
            GoTo contgroup3
        Else
            Mid$(a$, 1, 1) = Chr$(1)
            GoTo comehere
        End If
        ElseIf Left$(a$, 2) = "=>" Then
            Mid$(a$, 1, 2) = Chr$(7) + "."
            GoTo again1001

        ElseIf InStr(v$, "%") > 0 Then
            If SG = 1 Then
                R = MyRound(p)
            Else
                R = -MyRound(p)
            End If
        Else
            If SG = 1 Then
                R = p
            Else
                R = -p
            End If
        End If
            
            IsNumberNew = True
    Else
  ''
     IsNumberNew = False
    End If
End If
Exit Function

ElseIf neoGetArray(bstack, v$, pppp) Then
contAr2:

    If MaybeIsSymbol3(a$, ")", w3) Then
        IsNumberNew = True
        If Not pppp.Arr Then
            If Typename(pppp.GroupRef) = mgroup Then
                If pppp.GroupRef.HasParameters Then
                    GoTo conthere102030
                Else
                MyErMacro a$, "No parameter list for this group", "дЕМ УПэЯВЕИ КъСТА ПАЯАЛщТЯЫМ ЦИА АУТчМ ТГМ ОЛэДА"
                End If
            ElseIf Typename(pppp.GroupRef) = mHdlr Then
                '' here the poke as alfa(3).value or аКЖА(3).ТИЛч
                Set usehandler = pppp.GroupRef
                a$ = Mid$(a$, w3 + 1)
                If usehandler.indirect >= 0 Then
                    MyErMacro a$, "Not implemented yet", "дЕМ ЕВЕИ АЙЭЛА УКОПОИГХЕъ АУТЭ"
                    Exit Function
                End If
                If Left$(a$, 1) = "." Then
                ' LOOK FOR GROUP
                    w2 = -usehandler.objref.index - 2
                    GoTo contgroup
                ElseIf FastSymbol(a$, "(") Then
                    w2 = -usehandler.objref.index - 2
                    Set usehandler = Nothing
                    GoTo contlambdahere
                Else
                    Set bstack.lastobj = pppp
                    If usehandler.t1 = 2 Then
                        R = SG * usehandler.objref.GetPtr(0)
                    Else
                        R = SG * usehandler.objref.Done
                    End If
                End If
                Set usehandler = Nothing
            ElseIf Typename(pppp.GroupRef) = mProp Then
               ' Set useProp = pppp.GroupRef
               ' useProp.IndexOpt
               ' R = useProp.Value
                Set bstack.lastobj = pppp
                a$ = Mid$(a$, w3 + 1)
            Else
                a$ = Mid$(a$, w3 + 1)
                ' what object we have here????
            End If
        Else
            a$ = Mid$(a$, w3 + 1)
            R = 0
            If FastSymbol(a$, "#") Then
                Set usehandler = New mHandler
                usehandler.t1 = 3
                Set usehandler.objref = pppp
                Set nbstack = Nothing
                Set bstack.lastobj = usehandler
                GoTo comehere
            End If
            Set bstack.lastobj = pppp
        End If
        Exit Function
    End If

    If pppp.Arr Then
        dn = 0
        pppp.SerialItem (0), dd, 5
        dd = dd - 1
        If dd < 0 Then
            If Typename(pppp.GroupRef) = mProp Then
                GoTo contreadprop
            End If
        End If
        p = 0
        pp = 0
        IsNumberNew = True
        w2 = 0
        Do While dn <= dd
            ' pppp.SerialItem w3, dn, 6
             pppp.GetDnum dn, w3, v1&
            If IsExp(bstack, a$, p, , True) Then
                If dn < dd Then
                    If Not FastSymbol(a$, ",") Then: MyErMacro a$, "need index for " & v$ & ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " & v$ & ")": IsNumberNew = False: Exit Function
                Else
                    If FastSymbol(a$, ",") Then
                    IsNumberNew = False
                    MyErMacro a$, "too many indexes for array " & v$ & ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " & v$ & ")"
                    Exit Function
                End If
                If Not FastSymbol(a$, ")") Then: MissSymbol ")": IsNumberNew = False: Exit Function
            End If
            On Error Resume Next
            If p < -v1& Then
                IsNumberNew = False
                    MyErMacro a$, "index too low for array " & v$ & ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " & v$ & ")"
                    Exit Function
                End If
                If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
                    IsNumberNew = False
                    MyErMacro a$, "index too high for array " & v$ & ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " & v$ & ")"
                    IsNumberNew = False
                    Exit Function
                End If
                On Error GoTo 0
            Else
                IsNumberNew = False
                If Not LastErNum = -2 Then
                        MyErMacro a$, "missing index for array " & v$ & ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " & v$ & ")"
                End If
                Exit Function
            End If
            dn = dn + 1
        Loop
                    ' here here here
contAr22:
        If pppp.ItemType(w2) = mgroup Then
contgroup00:
            If Left$(a$, 1) = "." Then
contgroup:
                               
                IsNumberNew = SpeedGroup(bstack, pppp, "VAL", v$, a$, w2) = 1
                    If SG = 1 Then
                        R = bstack.LastValue
                    Else
                        R = -bstack.LastValue
                    End If
                ElseIf Left$(a$, 1) = "(" Then
contgroup3:
                    IsNumberNew = SpeedGroup(bstack, pppp, "VAL", v$, a$, w2) = 1
                        If SG = 1 Then
                            R = bstack.LastValue
                        Else
                            R = -bstack.LastValue
                        End If
                Else
contgroup2:
                    If pppp.item(w2).IamApointer Then
                        IsNumberNew = True
                        If Left$(a$, 2) = "=>" Then Mid$(a$, 1, 2) = "." + Chr(3): GoTo contgroup
                        Set bstack.lastpointer = pppp.item(w2).link
                        Set bstack.lastobj = pppp.item(w2)
                        R = 0
                    ElseIf pppp.item(w2).HasValue Then
                        If pppp.item(w2).HasParameters Then
                            GoTo contgroup
                        Else
                            IsNumberNew = SpeedGroup(bstack, pppp, "VAL", v$, "", w2) = 1
                            If SG = 1 Then
                                R = bstack.LastValue
                            Else
                                R = -bstack.LastValue
                            End If
                        End If
                    Else
                        If pppp.item(w2).IamApointer Then
                            If Mid(a$, 1, 2) = "=>" Then
                                Mid(a$, 1, 2) = Chr$(0) + "."
                                Set bstack.lastpointer = pppp.item(w2)
                                GoTo againpointer
                            Else
                                Set bstack.lastobj = pppp.item(w2)
                            End If
                        Else
                            bstack.soros.CopyGroupObj pppp.item(w2), anything
                            Set bstack.lastobj = anything
                        End If
                    End If
                End If
              
                Exit Function
                ElseIf pppp.ItemIsObject(w2) Then
                    If FastSymbol(a$, "(") Then
    
contlambdahere:
                        w3 = 0
                        Select Case pppp.ItemType(w2)
                        Case "lambda"
                            PushStage bstack, False
                            w1 = globalvarGroup("A_" + CStr(Abs(w2)), 0#)
                            Set var(w1) = pppp.item(w2)
                            If here$ = vbNullString Then
                                GlobalSub "A_" + CStr(Abs(w2)) + "()", "", , , w1
                            Else
                                GlobalSub here$ & "." & bstack.GroupName & "A_" + CStr(Abs(w2)) + "()", "", , , w1
                            End If
againlambda:
                            bstack.tmpstr = "A_" + CStr(Abs(w2)) + "(" + Left$(a$, 1)
                            BackPort a$
                            IsNumberNew = IsNumberNew(bstack, a$, p, SG, False)
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is lambda Then
                                    If IsOperator(a$, "(") Then
                                        Set var(w1) = bstack.lastobj
                                        GoTo againlambda
                                    End If
                                ElseIf IsOperator(a$, "(") Then
                                    If TypeOf bstack.lastobj Is mArray Then
                                        PopStage bstack
                                        PopStage bstack
                                        Set pppp = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        w3 = 0
                                        GoTo contAr2
                                    ElseIf TypeOf bstack.lastobj Is mHandler Then
                                        PopStage bstack
                                        Set usehandler = bstack.lastobj
                                        If usehandler.t1 = 3 Then
                                            Set anything = usehandler
                                            If CheckIsmArray(anything) Then
                                                Set pppp = anything
                                            Else
                                                Set pppp = New mArray
                                                pppp.Arr = False
                                                Set pppp.GroupRef = usehandler
                                            End If
                                            Set anything = Nothing
                                        ElseIf usehandler.t1 = 1 Then
                                            Set pppp = New mArray
                                            pppp.Arr = False
                                            Set pppp.GroupRef = usehandler
                                            w2 = -2
                                            GoTo contrightpar
                                        Else
                                            Set pppp = New mArray
                                            pppp.Arr = False
                                            Set pppp.GroupRef = usehandler
                                        End If
                                        Set usehandler = Nothing
                                    ElseIf TypeOf bstack.lastobj Is mArray Then
                                ' what???
                                    ElseIf TypeOf bstack.lastobj Is Group Then
cont100203030:
                                        Set pppp = New mArray
                                        pppp.Arr = False
                                        Set pppp.GroupRef = bstack.lastobj
                                        w2 = -2
                                        GoTo contgroup3
                                    End If
                                ElseIf TypeOf bstack.lastobj Is mArray Then
                                    PopStage bstack
                                    Set pppp = bstack.lastobj
                                    Set bstack.lastobj = Nothing
                                    w3 = 0
                                    GoTo contAr2
                                ElseIf TypeOf bstack.lastobj Is Group Then
                                    PopStage bstack
                                    Set pppp = New mArray
                                    pppp.Arr = False
                                    Set pppp.GroupRef = bstack.lastobj
                                    w2 = -2
                                    If Left$(a$, 1) = "." Then
                                        GoTo contgroup
                                    Else
                                        GoTo contgroup2
                                    End If
                                End If
                            End If
                            Set var(w1) = Nothing
                            If Right$(pppp.arrname, 2) = "%(" Then
                                If SG = 1 Then R = MyRound(p) Else R = -MyRound(p)
                            Else
                                If SG = 1 Then R = p Else R = -p
                            End If
                            PopStage bstack
                            IsNumberNew = True
                            Exit Function
                        Case myArray
                            Set pppp = pppp.item(w2)
                            w3 = 0
                            GoTo contAr2
                        Case mHdlr
                            Set bstack.lastobj = pppp.item(w2)
                            Set usehandler = bstack.lastobj
                            If usehandler.t1 = 3 Then
                                Set anything = usehandler
                                If CheckIsmArray(anything) Then
                                    Set pppp = anything
                                Else
                                    Set pppp = New mArray
                                    pppp.Arr = False
                                    Set pppp.GroupRef = usehandler
                                End If
                                Set anything = Nothing
                            Else
                                Set pppp = New mArray
                                pppp.Arr = False
                                Set pppp.GroupRef = usehandler
                            End If
                        Case mProp
                        pppp.GetPorp useProp, w2
                        w3 = 0
                        Set bstack.lastobj = Nothing
                        Set usehandler = Nothing
                        GoTo contreadprop2
                        End Select
                        Set bstack.lastobj = Nothing
                        Set usehandler = Nothing
                        w3 = 0
                        GoTo contAr2
                    Else
    ' here is the fault
                            R = rValue(bstack, pppp.itemObject(w2))
                            If FastSymbol(a$, "#") Then
                                Set nbstack = Nothing ' ???
comehere:
                                If Not bstack.lastobj Is Nothing Then
                                    If TypeOf bstack.lastobj Is mHandler Then
                                        Set usehandler = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        IsNumberNew = Matrix(bstack, a$, usehandler, R)
                                        If Left$(a$, 1) = "." And Not bstack.lastobj Is Nothing Then
                                        If TypeOf bstack.lastobj Is Group Then
                                        GoTo cont100203030
                                        
                                        End If
                                        ElseIf Not TypeOf bstack.lastobj Is mHandler And Not bstack.lastobj Is Nothing Then
                                        Set bstack.lastobj = usehandler
                                        Set usehandler = Nothing
                                        End If
                                        If MyIsObject(R) Then R = 0#
                                        If SG < 0 Then R = -R
                                        Exit Function
                                    ElseIf Typename(bstack.lastobj) = myArray Then
                                        Set usehandler = New mHandler
                                        usehandler.t1 = 3
                                        Set usehandler.objref = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        IsNumberNew = Matrix(bstack, a$, usehandler, R)
                                        If Left$(a$, 1) = "." And Not bstack.lastobj Is Nothing Then
                                            If TypeOf bstack.lastobj Is Group Then GoTo cont100203030
                                        End If
                                        If MyIsObject(R) Then R = 0#
                                        If SG < 0 Then R = -R
                                        Exit Function
                                    End If
                                End If
                                SyntaxError
                                IsNumberNew = False
                                Exit Function
                            ElseIf SG < 0 Then
                                R = -R
                            End If
                        End If
                        Exit Function
                    End If
                    On Error Resume Next
                    R = pppp.itemnumeric(w2)
                    If SG < 0 Then R = -R
                    If Err Then R = 0: Err.Clear
                    On Error GoTo 0
                Else
contrightpar:
                    If Typename(pppp.GroupRef) = mHdlr Then
                        Set usehandler = pppp.GroupRef
                        If IsExp(bstack, a$, p, , True) Then
                            If usehandler.t1 = 2 Then ' OK for Buffer
                                With usehandler.objref
                                If FastSymbol(a$, "!") Then
                                    If SG = 1 Then
                                        R = .GetBytePtr(p)
                                    Else
                                        R = -.GetBytePtr(p)
                                    End If
                                Else
                                    If FastSymbol(a$, ",") Then
                                        If IsStrExp(bstack, a$, s$) Then
                                        
                                        ElseIf FastPureLabel(a$, s$, True) <> 1 Then
syntax1:
                                            SyntaxError
                                            Exit Function
                                        End If
                                        If .structref.Find(s$) Then
                                            If FastSymbol(a$, ",") Then
                                                If IsExp(bstack, a$, R) Then
                                                    R = .GetPtr(p) + .structref.Value + R
                                                Else
                                                    GoTo syntax1
                                                End If
                                            Else
                                                R = .GetPtr(p) + .structref.Value
                                            End If
                                            If FastSymbol(a$, "!") Then
                                                If SG = 1 Then
                                                    R = R - .GetPtr(0)
                                                Else
                                                    R = -R - .GetPtr(0)
                                                End If
                                            Else
                                                If SG < 0 Then R = -R
                                            End If
                                        Else
                                            GoTo syntax1
                                        End If
                                    Else
                                        R = .GetPtr(p)
                                        If SG < 0 Then R = -R
                                    End If
                                End If
                                If .status = 4 Then MyErMacro a$, "Buffer locked, wrong use of pointer", "г дИэЯХЯЫСГ ЙКЕИДЧХГЙЕ, ЙАЙч ВЯчСГ ДЕъЙТГ"
                                IsNumberNew = FastSymbol(a$, ")") And .status = 0
                            End With
                            Exit Function
                        ElseIf usehandler.t1 = 3 Then
                            Set bstack.lastobj = Nothing
                            Set anything = usehandler
                            If CheckLastHandler(anything) Then
                                Set usehandler = anything
                                If TypeOf usehandler.objref Is mArray Then
                                    Set pppp = usehandler.objref
                                    Set usehandler = Nothing
                                    w2 = CLng(p)
                                    If pppp.count > w2 And w2 >= 0 Then
                                        pppp.index = w2
                                        If MyIsObject(pppp.Value) Then
                                            FastSymbol a$, ")"
                                            GoTo contAr22
                                        Else
                                            R = pppp.itemnumeric(w2)
                                            GoTo finishnum
                                        End If
                                    Else
                                        indexout a$
                                    End If
                                Else
                                    SyntaxError
                                End If
                                Set usehandler = Nothing
                            Else
                                MyEr "???", "???"
                            End If
                            Exit Function
                        End If
                        Set bstack.lastobj = Nothing
                        If VarType(p) = vbBoolean Then p = CLng(p)
                        If Not FastSymbol(a$, "!") Then s$ = Trim$(Str(p)): GoTo contlabel
                        If TypeOf usehandler.objref Is mHandler Then
                            Set usehandler = usehandler.objref
                            If usehandler.indirect = -1 Then
                                Set anything = usehandler.objref
                                Set usehandler = New mHandler
                                Set pppp.GroupRef = usehandler
                                Set usehandler.objref = anything
                                Set anything = Nothing
                                Set bstack.lastobj = Nothing
                            End If
                        End If
                        With usehandler.objref
                            p = MyRound(p)
                            If Abs(p) < .count Then
                                If p < 0 Then
                                    .index = .count + MyRound(p)
                                Else
                                    .index = MyRound(p)
                                End If
                                .Done = True
                                '' what??? here here here
                                IsNumberNew = FastSymbol(a$, ")")
                                If Left$(a$, 1) = "." Then
                                    If Fast2NoSpace(a$, ".аниа", 5, ".VALUE", 6, 6) Then
                                        w2 = -100
                                    Else
                                        w2 = -MyRound(p) - 100
                                    End If
                                    GoTo contgroup
                                ElseIf FastSymbol(a$, "(") Then
                                    If .IsObj Then
                                        If TypeOf .ValueObj Is mHandler Then
                                            Set pppp.GroupRef = .ValueObj
                                            w3 = 0
                                            GoTo contAr2
                                        ElseIf TypeOf .ValueObj Is Group Then
                                            Set pppp.GroupRef = .ValueObj
                                            w2 = -2
                                            GoTo contgroup
                                        End If
                                        w2 = -.index - 100
                                        If TypeOf .ValueObj Is lambda Then GoTo contlambdahere
                                        If TypeOf .ValueObj Is mArray Then
                                            Set pppp = .ValueObj
                                            w3 = 0
                                            GoTo contAr2
                                        End If
                                    Else
                                        MyErMacro a$, "No Object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО"
                                    End If
                                End If
                                If Not .IsObj Then
                                    If .ValueType(0, R, s$) Then
                                        If SG < 0 Then R = -R
                                    Else
                                        R = 0
                                    End If
                                Else
                                    Set bstack.lastobj = usehandler.objref.ValueObj
                                    R = 0
                                End If
                                Exit Function
                            Else
                                indexout a$
                            End If
                        End With
                        Exit Function
                    ElseIf IsStrExp(bstack, a$, s$) Then
                        w3 = 0
contlabel:
                        Set usehandler = pppp.GroupRef
                        If usehandler.t1 = 1 Then
                            If Typename(usehandler.objref) <> "FastCollection" Then
                                If usehandler.indirect = -1 Then
                                    Set usehandler = usehandler.objref
                                    Set useFast = usehandler.objref
                                    Set usehandler = pppp.GroupRef
                                    Set usehandler.objref = useFast
                                Else
                                    GoTo inv100
                                End If
                            Else
                                Set useFast = usehandler.objref
                            End If
                        Else
inv100:                                 Expected "Inventory", "йАТэСТАСГ"
                            Exit Function
                        End If
                        With useFast
                            If .StructLen > 0 Then s$ = myUcase(s$)
                            If .Find(s$) Then
                                IsNumberNew = FastSymbol(a$, ")")
                                If Left$(a$, 1) = "." Then
                                    w2 = -.index - 100
                                    GoTo contgroup
                                ElseIf Left$(a$, 1) = "(" Then
                                    Mid$(a$, 1, 1) = " "
                                    If .IsObj Then
                                        w2 = -.index - 100
                                        If TypeOf .ValueObj Is lambda Then GoTo contlambdahere
                                        If TypeOf .ValueObj Is mArray Then
                                            Set pppp = .ValueObj
                                            w3 = 0
                                            GoTo contAr2
                                        ElseIf TypeOf .ValueObj Is mHandler Then
                                            Set usehandler = .ValueObj
                                            If usehandler.t1 = 3 Then
                                                Set pppp = usehandler.objref
                                            Else
                                                Set pppp.GroupRef = usehandler
                                            End If
                                            w3 = 0
                                            GoTo contAr2
                                        End If
                                    Else
                                        MyErMacro a$, "No Object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО"
                                    End If
                                End If
                                If Not .IsObj Then
                                    If .ValueType(0, R, s$) Then
                                        If SG < 0 Then R = -R
                                    Else
                                        R = 0
                                    End If
                                Else
                                    If Typename(.ValueObj) = mgroup Then
                                        Set userGroup = .ValueObj
                                        If userGroup.HasValue Then
                                            w2 = -.index - 100
                                            GoTo contgroup
                                        Else
                                            R = 0
                                            Set bstack.lastobj = userGroup
                                            Exit Function
                                        End If
                                    Else
                                        R = rValue(bstack, .ValueObj)
                                        If FastSymbol(a$, "#") Then
                                            If Not bstack.lastobj Is Nothing Then
                                                If Typename(bstack.lastobj) = mHdlr Then
                                                    Set usehandler = bstack.lastobj
                                                    Set bstack.lastobj = Nothing
                                                    IsNumberNew = Matrix(bstack, a$, usehandler, R)
                                                    If MyIsObject(R) Then R = 0#
                                                    If SG < 0 Then R = -R
                                                    Exit Function
                                                End If
                                            End If
                                            SyntaxError
                                            IsNumberNew = False
                                            Exit Function
                                        ElseIf SG < 0 Then
                                            R = -R
                                        End If
                                    End If
                                End If
                                Exit Function
                            Else
                               indexout a$
                            End If
                        End With
                    Exit Function
                    End If
                ElseIf Typename(pppp.GroupRef) = mgroup Then
conthere102030:
                    Set userGroup = pppp.GroupRef
                    If Len(v$) > Len(userGroup.GroupName) Then
                    If Len(pppp.CodeName) = 0 Then
                        s1$ = Left$(v$, Len(v$) - 1) + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                        Else
                        s1$ = pppp.CodeName + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                        End If
                    Else
                        s1$ = userGroup.GroupName + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                    End If
                    If GetSub(s1$, v1&) Then
                        Set nbstack = New basetask
                        Set nbstack.Parent = bstack
                        If bstack.IamThread Then Set nbstack.Process = bstack.Process
                        Set nbstack.Owner = bstack.Owner
                        nbstack.OriginalCode = v1&
                        nbstack.UseGroupname = sbf(v1&).sbgroup
                        nbstack.tpointer = sbf(v1&).tpointer
                        nbstack.SetV
                        If GoFunc(nbstack, s1$, a$, p) Then
                            If Not nbstack.StaticCollection Is Nothing Then
                                bstack.Parent.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                            End If
                            IsNumberNew = True
                            If IsOperator(a$, "(") Then
contgrouppar:
                                Set pppp = New mArray
                                If Typename(bstack.lastobj) = mgroup Then
                                    If bstack.lastobj.IamApointer Then
                                        Set pppp.GroupRef = bstack.lastobj.link
                                    Else
                                        Set pppp.GroupRef = bstack.lastobj
                                    End If
                                    Set bstack.lastpointer = Nothing
                                    Set bstack.lastobj = Nothing
                                Else
                                    Set pppp.GroupRef = bstack.lastobj
                                End If
                                pppp.Arr = False
                                w2 = -2
                                Set nbstack = Nothing
                                v$ = vbNullString
                                GoTo contrightpar
                            ElseIf Left$(a$, 1) = "." Then
                                Set pppp = New mArray
                                If bstack.lastobj.IamApointer Then
                                    Set pppp.GroupRef = bstack.lastobj.link
                                Else
                                    Set pppp.GroupRef = bstack.lastobj
                                End If
                                Set bstack.lastobj = Nothing
                                Set bstack.lastpointer = Nothing
                                pppp.Arr = False
                                w2 = -2
                                Set nbstack = Nothing
                                v$ = vbNullString
                                GoTo contgroup
                            ElseIf FastSymbol(a$, "#") Then
                                Set nbstack = Nothing
                                GoTo comehere
                            End If
                            Set nbstack = Nothing
                            R = p
                            If SG < 0 Then R = -R
                            IsNumberNew = True
                        Else
                            IsNumberNew = False
                        End If
                    Else
                        If Typename(var(VR)) = mgroup Then
                            Set userGroup = var(VR)
                            If userGroup.HasStrValue Then
                                R = 0
                                Set bstack.lastobj = CopyGroupObj(var(VR))
                            Else
                                R = 0
                                InternalEror
                                IsNumberNew = False
                            End If
                        Else
                            R = 0
                            InternalEror
                            IsNumberNew = False
                        End If
                    End If
                    Exit Function
                Else
contreadprop:
                    If TypeOf pppp.GroupRef Is PropReference Then
contreadprop2:
                        Set useProp = pppp.GroupRef
                        If getindexes(bstack, useProp, a$) Then
                            Set bstack.lastobj = pppp
                        Else
                            R = useProp.Value
                            Set bstack.lastobj = useProp.lastobjfinal
                        End If
                        If Not bstack.lastobj Is Nothing Then R = 0
                        GoTo finishnum
                    End If
                                        
                End If
                If TypeOf pppp.GroupRef Is mHandler Then
                    MyEr "Not for this kind of object", "╪ВИ ЦИА АУТЭ ТО АМТИЙЕъЛЕМО"
                    R = 0
                    Exit Function
                Else
                    Set useProp = pppp.GroupRef
                    R = useProp.Value
                    Set bstack.lastobj = useProp.lastobj
                    
                    
                    If Not MyIsNumeric(R) Then
                        If VarType(R) = 8 Then
                            If Len(R) = 0 Then R = 0 Else R = val(R)
                        Else
                            R = 0#
                        End If
                    End If
finishnum:
                    If SG < 0 Then R = -R
                End If
                IsNumberNew = FastSymbol(a$, ")")
               
                If FastSymbol(a$, "#") Then GoTo comehere
                
                
               
                End If
                Exit Function
            Else
skiperror:
            IsNumberNew = False
            If FindNameForGroup(bstack, v$) Then
                UnknownMethod1 a$, v$
            Else
                If Len(v$) > 5 Then
                    If Left$(v$, 5) = "THIS." Or Left$(v$, 5) = "ауто." Then
                        v$ = Mid$(v$, 5)
                        v1& = IsLabel(bstack, (v$), v$)
                        s1$ = vbNullString
                        If v$ <> "" Then IsNumberNew = True: GoTo contthis1
                    End If
                End If
                UnknownFunction1 a$, v$
            End If
            Exit Function
        End If
Case 105
isasub:
    If CurrentStackSize > stacksize Then
        MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
        MOUT = True
        IsNumberNew = False: Exit Function
    End If
    w1 = bstack.soros.Total
    If Not PushParamSUB(bstack, a$) Then
    w1 = bstack.soros.Total - w1
    If w1 > 0 Then bstack.soros.drop w1
    IsNumberNew = False:  Exit Function
    End If
    If FastSymbol(a$, ")") Then
        PushStage bstack, False
        v1& = bstack.OriginalCode
        v$ = bstack.originalname$
        bstack.originalname$ = s1$
        If gr Then
            s1$ = "сумаятгсг " + s1$
        Else
            s1$ = "FUNCTION " + s1$
        End If
        If searchsub(v1&, s1$, w1, v1&, n$, True) Then
againsub:
            If Len(s1$) > 0 Then
                If Not MyRead(7, bstack, s1$, 1) Then
                    bstack.originalname$ = v$
                    PopStage bstack
                    IsNumberNew = False
                    Exit Function
                End If
            End If
            bstack.FuncValue = R
            Set bstack.FuncObj = Nothing
            dn = bstack.addlen
            bstack.RetStack.PushVal CDec(0)
            
            If trace Then
            s1$ = TestShowSub: sg1 = TestShowBypass
            If v1& > 0 Then
                bstack.addlen = Len(sbf(v1&).sb) - w1 - Len(n$) + 1
                TestShowSub = sbf(v1&).sb
            ElseIf v1& = 0 Then
                bstack.addlen = 0
                TestShowSub = n$
            Else
                bstack.addlen = Len(var(-v1&).code) - w1 - Len(n$) + 1
                TestShowSub = var(-v1&).code
            End If
            w1 = w1 + Len(n$)
            TestShowBypass = True
            dd = 1
            executeblock dd, bstack, n$, False, True, , True
            SwapStrings s1$, TestShowSub: TestShowBypass = sg1
            Else
             w1 = w1 + Len(n$)
            dd = 1
            executeblock dd, bstack, n$, False, True, , True
            End If
            bstack.RetStackDrop 1
            bstack.addlen = dn
            If dd > 0 Then
                IsNumberNew = True
                Set bstack.lastobj = bstack.FuncObj
                Set bstack.FuncObj = Nothing
                R = bstack.FuncValue
                bstack.FuncValue = Empty
                If SG = -1 Then R = -R
                If Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is mHandler Then
                            If FastSymbol(a$, "#") Then
                                GoTo comehere
                            End If
                        ElseIf TypeOf bstack.lastobj Is Group Then
                            Set userGroup = bstack.lastobj
                            If Left$(a$, 2) = "=>" Then
                                Mid$(a$, 1, 2) = Chr$(7) + "."
                                GoTo again1001
                            ElseIf Left$(a$, 1) = "#" Then
                                If Not (userGroup.HasValue And Not userGroup.HasParameters) Then
                                    Mid$(a$, 1, 1) = "."
                                End If
                                GoTo again1001
                            End If
                            
                        Else
                            If Len(a$) > 0 Then
                            Mid$(a$, 1, 1) = Chr$(1)
                            End If
                            GoTo comehere
                        End If
                End If
            Else
            IsNumberNew = False
            If bstack.ErrorOriginal = 0 Then
            LastErNum = -1
            LastErNum1 = -1
            bstack.ErrorOriginal = v1&
            If v1& > 0 Then
                a$ = n$ + space$(Len(sbf(v1&).sb) - w1 + 1)
            ElseIf v1& = 0 Then
                a$ = n$
            Else
                a$ = n$ + space$(Len(var(-v1&).code) - w1 + 1)
            End If
            End If
            
            Exit Function
            End If
        ElseIf bstack.IamChild Then
            w3 = FindPrevOriginal(bstack)
            If searchsub(w3, s1$, w1, v1&, n$, True) Then
                If w3 <> v1& And v1& < 0 Then
                    v1& = w3
                End If
                GoTo againsub
            Else
                GoTo nofun1
            End If
        Else
nofun1:
            MyEr "Function @" + Mid$(s1$, InStr(s1$, " ") + 1) + ") not found", "г СУМэЯТГСГ @" + Mid$(s1$, InStr(s1$, " ") + 1) + ") ДЕМ БЯщХГЙЕ"
            IsNumberNew = False
        End If
        bstack.originalname$ = v$
        PopStage bstack
    Else
        IsNumberNew = False
    End If
    Exit Function
End Select

'' THESE THREE STATEMENDS NOT USED ANY MORE
    IsNumberNew = False
    a$ = v$ + a$
    Exit Function
''End Select
zerohere:

End Function
Private Sub MyDoEventsNoThread()
On Error GoTo there
If TaskMaster Is Nothing Then
    DoEvents
    Exit Sub
ElseIf Not TaskMaster.Processing And TaskMaster.QueueCount = 0 Then
    DoEvents
    Exit Sub
Else
    If TaskMaster.PlayMusic Then
        TaskMaster.OnlyMusic = True
        TaskMaster.TimerTick
        TaskMaster.OnlyMusic = False
    End If
    TaskMaster.StopProcess
    DoEvents
    TaskMaster.StartProcess
End If
Exit Sub
there:
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd1
End Sub
Function ProcLambda(bstack As basetask, rest$, Lang As Long) As Object
' no named functio- object
Dim Body As New lambda, k As Long, n$, dummy As Variant, er As Boolean, pos1 As Long, p As Variant, s$
Dim pppp As mArray, pppp2 As mArray, frm$, Find As basetask, rest1$
' need fixed param...with &
again1:
ClearStr rest$
Do While MaybeIsSymbol(rest$, "/\'"): SetNextLine rest$: ClearStr rest$: Loop
If Not FastSymbol(rest$, "->", , 2) Then
' put here description for error
If er Then Exit Function
Do
If Len(rest$) < 129 Then
        k = IsPureLabel(rest$, n$)
    Else
        rest1$ = Left$(rest$, 128)
        k = IsPureLabel(rest1$, n$)
        If Len(rest1$) = 0 Then
            k = IsPureLabel(rest$, n$)
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If

If k = 0 Then

        If frm$ <> "" Then Exit Function
                    If FastSymbol(rest$, "(") Then
                                er = True
                                frm$ = BlockParam(rest$)
                            If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                    If Not FastSymbol(rest$, ")") Then
                       
                            
                            End If
                           frm$ = Trim$(frm$)
                           GoTo again1
                    Else
                    MyEr "Symbol -> for Lmabda needed", "вЯЕИэФЕТАИ ТО СЩЛБОКО -> ЦИА ТГМ КэЛДА СУМэЯТГСГ"
                    Exit Function
                End If
End If
If k > 4 Then If Not FastSymbol(rest$, ")") Then Exit Function
n$ = myUcase(n$, True)


If FastSymbol(rest$, "=") Then
Select Case k
Case 1, 4
If IsExp(bstack, rest$, p) Then
If Not bstack.lastobj Is Nothing Then
    Set dummy = bstack.lastobj
    Set bstack.lastobj = Nothing
   Body.FeedNonLocal n$, dummy, var()
   Set dummy = Nothing
    Else
       dummy = p
    Body.FeedNonLocal n$, dummy, var()
    End If
dummy = Empty
End If
Case 3
If IsStrExp(bstack, rest$, s$) Then
If Not bstack.lastobj Is Nothing Then
    Set dummy = bstack.lastobj
    Set bstack.lastobj = Nothing
   Body.FeedNonLocal n$, dummy, var()
   Set dummy = Nothing
    Else
       dummy = s$
    Body.FeedNonLocal n$, dummy, var()
    End If
dummy = Empty
End If
Case 5, 7

 If IsExp(bstack, rest$, p) Then
 If Not bstack.lastobj Is Nothing Then
      If Typename(bstack.lastobj) = myArray Then
      Set pppp = bstack.lastobj
        pppp.arrname = n$
        Set dummy = pppp
        Body.FeedNonLocal n$, dummy, var()
        Set dummy = Nothing
        Set pppp = Nothing
        Else
        Exit Function
      End If
      Else
        Exit Function
      End If
      Else
        Exit Function
     End If
Case 6
If IsStrExp(bstack, rest$, s$) Then
If Not bstack.lastobj Is Nothing Then
      If Typename(bstack.lastobj) = myArray Then
      Set pppp = bstack.lastobj
        pppp.arrname = n$
        Set dummy = pppp
        Body.FeedNonLocal n$, dummy, var()
        Set dummy = Nothing
        Set pppp = Nothing
        Else
        Exit Function
      End If
      Else
        Exit Function
      End If
      Else
        Exit Function
End If
End Select
ElseIf k < 5 Then
        If GetVar(bstack, n$, pos1, , , True) Then
            If Typename(var(pos1)) = "lambda" Then
            Dim aaa As lambda
            var(pos1).CopyTo aaa, var()
            Set dummy = aaa
                Body.FeedNonLocal n$, dummy, var()
                Set dummy = Nothing
                dummy = Empty
                Set aaa = Nothing
            ElseIf Typename(var(pos1)) = mgroup Then
                Set dummy = CopyGroupObj(var(pos1))
                Body.FeedNonLocal n$, dummy, var()
                Set bstack.lastobj = dummy
                Set dummy = Nothing
            Else
                Body.FeedNonLocal n$, var(pos1), var()
            End If
        Else
        
            If Right$(n$, 1) = "$" Then
                   If Not IsStr1(bstack, (n$), s$) Then
                        MyEr "", ""
                        dummy = vbNullString
                    Else
                        dummy = s$
                    End If
            Else
             
             If Not IsNumberNew(bstack, (n$), dummy, (1), True) Then
             MyEr "", ""
             dummy = Empty
             End If
                End If
                Body.FeedNonLocal n$, dummy, var()
        dummy = Empty
            
        End If
Else
       
        If neoGetArray(bstack, n$, pppp) Then
        Set pppp2 = New mArray
        pppp.CopyArray pppp2
  
        Set dummy = pppp2
        Set pppp2 = Nothing
        Set pppp = Nothing
        Body.FeedNonLocal n$, dummy, var()
        Else
        End If
    End If
If Not FastSymbol(rest$, ",") Then Exit Do
ClearStr rest$
Do While MaybeIsSymbol(rest$, "/\'"): SetNextLine rest$: ClearStr rest$: Loop
Loop
If frm$ <> "" Then Exit Function
ClearStr rest$
Do While MaybeIsSymbol(rest$, "/\'"): SetNextLine rest$: ClearStr rest$: Loop
If FastSymbol(rest$, "(") Then
                                frm$ = BlockParam(rest$)
                            If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                           If Not FastSymbol(rest$, ")", True) Then
                            
                           
                             frm$ = Trim$(frm$)
                           GoTo again1
                           
                            End If
                          
'Else
'Exit Function
 End If

er = True
GoTo again1

ElseIf FastSymbol(rest$, "{") Then
' get block
getfunc:
If frm$ <> "" Then
                                If Lang = 1 Then
                                frm$ = "Read " + frm$ + vbCrLf
                                Else
                                frm$ = "дИэБАСЕ " + frm$ + vbCrLf
                                End If
Body.code = frm$ + vbCrLf + block(rest$)
Else
Body.code = block(rest$)
End If
If Trim$(Body.code) = vbNullString Then Exit Function
k = Len(rest$)
If Not FastSymbol(rest$, "}") Then Exit Function
Else
GetLine:
' get one line only
 pos1 = 1
Body.code = aheadstatus(rest$, False, pos1)
If pos1 = 1 Then Exit Function
If frm$ <> "" Then
                                If Lang = 1 Then
                                frm$ = "Read " + frm$ + vbCrLf
                                Else
                                frm$ = "дИэБАСЕ " + frm$ + vbCrLf
                                End If
Body.code = frm$ + ": =" + Left$(rest$, pos1 - 1)
Else
Body.code = "=" + Left$(rest$, pos1 - 1)
End If
k = Len(rest$)
rest$ = Mid$(rest$, pos1)
End If
If bstack.OriginalCode < 0 Then
    Set Find = bstack
    
    
    Do While Find.IamChild
    If Find.OriginalCode > -1 Then Exit Do
    k = k + var(-Find.OriginalCode).lastlen
    Body.OriginalCode = var(-Find.OriginalCode).OriginalCode
    Set Find = Find.Parent
    
    Loop

    Body.lastlen = k
Else
    Body.OriginalCode = bstack.OriginalCode
  
    Body.lastlen = k
End If

Set ProcLambda = Body
End Function
Function IsLabelBig(bstack As basetask, a$, rrr$, Optional nocommand As Boolean, Optional R$, Optional noconvert As Boolean = False, Optional StrPointer As Boolean, Optional iscommand As Boolean, Optional fixlen As Boolean, Optional gr As Boolean) As Long
Dim rr&, one As Boolean, c$, dot&, skipcase As Boolean, cc As Long, isstrparam As Boolean, ascwc As Integer
R$ = vbNullString
gr = False
If a$ = vbNullString Then IsLabelBig = 0: Exit Function  'ok
a$ = NLtrim$(a$)
Do While Len(a$) > 0
    c$ = Left$(a$, 1) 'ANYCHAR HERE
    ascwc = AscW(c$)
    If ascwc < 10 And ascwc >= 0 Then
        Select Case ascwc
        Case 8 '
            If Len(R$) > 0 Then Exit Do
            ' get a name from bstack tempstr
            a$ = bstack.tmpstr + Mid$(a$, 2)
            fixlen = True
            bstack.tmpstr = vbNullString
            nocommand = Left$(a$, 1) <> "@"
        Case 2 To 7
            a$ = Mid$(a$, 2)
        Case 1
            isstrparam = True
            GoTo conthere1
        Case 0 ' for group pointers
conthere1:
            If LenB(R$) = 0 Then
                If Not bstack.lastpointer Is Nothing Then
                    With bstack.lastpointer
                        If .lasthere = vbNullString Then
                            If .GroupName <> "" Then
                                If isstrparam Then
                                    R$ = .GroupName + "$"
                                    rr& = 3
                                Else
                                    R$ = .GroupName
                                    rr& = 1
                                End If
                            Else
                            ' why ?
                               Exit Function
                            End If
                        Else
                            If .GroupName <> "" Then
                                If isstrparam Then
                                    R$ = .lasthere + "." + .GroupName + "$"
                                    rr& = 3
                                Else
                                    R$ = .lasthere + "." + .GroupName
                                    rr& = 1
                                End If
                            Else
                                If isstrparam Then
                                    R$ = .lasthere + "$"
                                    rr& = 3
                                Else
                                    R$ = .lasthere
                                    rr& = 1
                                End If
                            End If
                        End If
                    End With
                    Set bstack.lastpointer = Nothing
                    If Mid$(a$, 2, 1) = "." Then
                        a$ = Mid$(a$, 2)
                    Else
                        If Mid$(a$, 2, 2) = "$'" Then
                            rr& = 3
                            a$ = Mid$(a$, 2)
                        ElseIf Mid$(a$, 2, 1) = "'" Then
                            a$ = Mid$(a$, 2)
                        Else
                            Mid$(a$, 1, 1) = "("  ' parameter for value for pointers for groups using in Eval() and Eval$()
                        End If
                    End If
                    nocommand = True
                Else
                    Mid$(a$, 1, 2) = "=>"
                    Exit Function
                End If
            Else
                a$ = Mid$(a$, 2)
            End If
        Case Else
            Exit Do
        End Select
    ElseIf ascwc < 256 And ascwc > 0 Then
        Select Case ascwc
        Case 64  '"@"
           If R$ = vbNullString Then
              a$ = Mid$(a$, 2)
              iscommand = True
              ElseIf Mid$(a$, 2, 1) <> "(" And Len(R$) > 0 Then
            R$ = R$ & "."
              a$ = Mid$(a$, 2)
              Else
                 IsLabelBig = 0: Exit Function
            End If
        Case 63 '"?"
            If R$ = vbNullString Then
                rrr$ = "?"
                IsLabelBig = 1
                Exit Function
            End If
            a$ = Mid$(a$, 2)    ' why this
        Case 46 '"."
            If one Then
                Exit Do
            ElseIf Len(R$) > 0 Then
                R$ = R$ & Left$(a$, 1)
                a$ = Mid$(a$, 2)
            ElseIf Not Mid$(a$, 2, 1) Like "[0-9]" Then
                If Len(R$) > 0 Then
                    R$ = R$ & Left$(a$, 1)
                    rr& = 1
                Else
                    dot& = dot& + 1
                End If
                a$ = Mid$(a$, 2)
            Else
                If R$ = vbNullString And dot& > 0 Then
                    nocommand = True
                    rrr$ = String$(dot& + 1, ".")     ' i want this only in right position for "dir .. "
                    R$ = rrr$
                    a$ = Mid$(a$, 2)
                    IsLabelBig = 1
                Else
                    IsLabelBig = 0
                End If
                Exit Function
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        Case 48 To 57, 95 '"0" To "9", "_"  ' old ,"\"
            If one Then
                Exit Do
            ElseIf Len(R$) > 0 Then
                R$ = R$ & c$
                a$ = Mid$(a$, 2)
                rr& = 1 'is an identifier or floating point variable
            Else
                If dot& > 0 Then a$ = "." + a$: dot& = 0
                Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
                Exit Do
            Else
                R$ = R$ & Left$(a$, 1)
                a$ = Mid$(a$, 2)
                rr& = 1 'is an identifier or floating point variable
            End If
        Case 38 ' "&"
            If one Then Exit Do
            If Len(R$) > 0 Then
                'ERROR
                rr& = 0
                '' r$ = VbNullString
                rrr$ = vbNullString
                Exit Function
            Else
           nocommand = True
            Dim i As Long
                If noconvert Then
                IsLabelBig = 0
                Exit Function
                Else
                a$ = Mid$(a$, 2)
                varhash.flat
               rr& = Abs(IsLabelBig(bstack, a$, R$, , c$))
               If rr& < 5 And varhash.lastNDX > 0 Then

              i = varhash.lastNDX
usethat:
              R$ = varhash.lastkey
              
              
              If MyIsObject(var(i)) Then
                            If var(i) Is Nothing Then
                            ElseIf TypeOf var(i) Is Group Then
                                If Len(var(i).LastOpen) > 0 Then
                                    c$ = var(i).LastOpen
                                    If GetlocalVar(c$, i) Then
                                        If IsBadCodePtr(var(i).PointerPtr) = 0 Then
                                            c$ = R$
                                        End If
                                    End If
                                End If
                            End If
                        End If
                        rrr$ = R$
                        IsLabelBig = -50
                        Exit Function
               
               End If
               
               
               
                End If
                skipcase = True
                
                If rr& < 5 Then
                 c$ = myUcase(c$, True)
again2134:
                    If GetlocalVar(R$, i) Then
bypass1:
                        If MyIsObject(var(i)) Then
                            If var(i) Is Nothing Then
                            ElseIf TypeOf var(i) Is Group Then
                                If Len(var(i).LastOpen) > 0 Then
                                    c$ = var(i).LastOpen
                                    If GetlocalVar(c$, i) Then
                                        If IsBadCodePtr(var(i).PointerPtr) = 0 Then
                                            c$ = R$
                                        End If
                                    End If
                                End If
                            End If
                        End If
                        rrr$ = here$ & "." & R$
                        IsLabelBig = -50
                        Exit Function
                    ElseIf bstack.ExistVar2(c$) Then
                        R$ = c$
                        If Not bstack.modfuncall Then
abnormal_exit:

                            'r$ = "#" + r$
                            'rr& = 2
                            'Exit Do
                                MyEr "only for module or function call", "ЛЭМО СЕ ЙКчСГ ЦИА ТЛчЛА ч СУМэЯТГСГ"
                                IsLabelBig = 0
                            Exit Function
                        End If
                        c$ = "_" + Str$(var2used)
                        Dim p, s$
                        If rr& = 6 Then
                            If Not IsStr1(bstack, (R$), s$) Then GoTo cont123
                            If bstack.lastobj Is Nothing Then
                            rr& = globalvarGroup(c$, s$)
                            Else
                            Set p = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            rr& = globalvarGroup(c$, p)
                            End If
                        Else
                            If Not IsNumber(bstack, (R$), p) Then GoTo cont123
                           
                            If bstack.lastobj Is Nothing Then
                            rr& = globalvarGroup(c$, p)
                            Else
                            Set p = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            rr& = globalvarGroup(c$, p)
                            End If
                        End If
                        ' to tempcopy
                        FeedCopyInOut bstack, R$, rr&, ""  ' parent
                        If here$ <> "" Then R$ = here$ + "." + c$ Else R$ = c$
                        
                        rr& = 2
                        Exit Do
                    ElseIf Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                        If Len(bstack.UseGroupname) > 0 Then
                                 c$ = bstack.UseGroupname + Mid$(R$, 6)
                                 
                         Else
                             c$ = StripThis2(here$)
                             If c$ <> "" Then c$ = c$ & "." & Mid$(R$, 6) Else c$ = here$ & "." & R$
                         End If
        
                      rrr$ = c$
                        IsLabelBig = -50
                        Exit Function
                  ElseIf varhash.Find(R$, cc) Then
        
                         rrr$ = R$
                        IsLabelBig = -50
                        Exit Function
                    Else
        
                    
                    If R$ = "THIS" Or R$ = "ауто" Then
                    rrr$ = R$
                   IsLabelBig = -100
                   
                   Exit Function
                    Else
                    c$ = ChrW(-65) + myUcase(c$, True)
                    If varhash.Find2(bstack.UseGroupname + c$, i) Then
                    GoTo usethat
                    
                    End If
                    
                    
                If GetSub(R$ + ")", rr&) Then
                
                                 R$ = "{" + sbf(rr&).sb + "} " + sbf(rr&).sbgroup
                                 
                    rr& = 2
                    Exit Do
                    Else
                    
                 If Not bstack.NoError Then MyErMacro a$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
                    End If
                    End If
                Else
                    If FastSymbol(a$, ")") Then
        
                            rr& = 0
                            If Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                            If varhash.ExistKey(bstack.UseGroupname & Mid$(R$, 6)) Then
                       
        
                                        rrr$ = bstack.UseGroupname & Mid$(R$, 6, Len(R$) - 5)
                                        IsLabelBig = -50
                                        Exit Function
                                    Else
                                     If varhash.ExistKey(bstack.UseGroupname + ChrW(-65) + Mid$(R$, 6)) Then
                       
        
                                        rrr$ = bstack.UseGroupname + ChrW(-65) & Mid$(R$, 6, Len(R$) - 5)
                                        IsLabelBig = -50
                                        Exit Function
                                        End If
                                    rr& = 2
                                    End If
                                ElseIf varhash.ExistKey(here$ & "." & R$) Then
                               
                                       
                                            rrr$ = here$ & "." & R$
                                        IsLabelBig = -50
                                        Exit Function
                                ElseIf varhash.ExistKey(R$) Then
                                  
                                        rrr$ = R$
                                        IsLabelBig = -50
                                        Exit Function
                                Else
                                
                                   rr& = 3
                                End If
                                c$ = vbNullString
                                 If rr& > 0 Then
                                    If rr& = 2 Then
                                        If Len(bstack.UseGroupname) > 0 Then
                                        c$ = bstack.UseGroupname + ChrW(-65) + Mid$(R$, 6)
                                        R$ = bstack.UseGroupname + Mid$(R$, 6)
                                        End If
                                    End If
checkc:
                                 rr& = 1
                                 If GetSub(R$ + ")", rr&) Then
                                 If sbf(rr&).Extern > 0 Then
                                 R$ = "{CALL EXTERN" + Str$(sbf(rr&).Extern) + "}" + sbf(rr&).sbgroup
                                 Else
                            R$ = "{" + sbf(rr&).sb + "}" + sbf(rr&).sbgroup
                            End If
                                 
                    rr& = 2
     
                    Exit Do
                    
                    Else
                    If Len(c$) > 0 Then
                    R$ = c$
                    GoTo checkc
                    End If
                    If Not bstack.NoError Then MyErMacro a$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
               
                                 
                                 End If
                                 rr& = 0
                                 R$ = vbNullString
                                Exit Do
                        Else
                        Dim pppp As mArray, a1$, w2 As Long
                        a1$ = R$
                        If GetOneAsString(bstack, a$, R$, rr&) Then
                                                                
                            If neoGetArray(bstack, a1$, pppp) Then
                            
                            
                            If Not pppp.Arr Then GoTo cont123
                            c$ = varhash.lastkey
                            If Not NeoGetArrayItem(pppp, bstack, a1$, w2, Mid$(R$, Len(a1$) + 1)) Then GoTo cont123
                            If pppp.ItemType(w2) = mgroup Then
                            If Len(pppp.item(w2).LastOpen) > 0 Then
                            R$ = pppp.item(w2).LastOpen
                            rr& = 2
                            Exit Do
                            End If
                            End If
                        
                            
                            R$ = Funcweak(bstack, c$ + Mid$(R$, Len(a1$) + 1))
                            a1$ = c$
                            Dim p1, s1$
                                                If Not bstack.modfuncall Then
                                            GoTo abnormal_exit
                                        End If
                            c$ = "_" + Str$(var2used)
                            If pppp.MyIsObject(pppp.item(w2)) Then
                            
                               
                                If pppp.ItemType(w2) = mgroup Then
                                If pppp.item(w2).IamApointer Then
                                If pppp.item(w2).LastOpen <> vbNullString Then
                                rr& = 1
                                R$ = pppp.item(w2).LastOpen
                                GoTo again2134
                                Else
                                 rr& = globalvarGroup(c$, p1)
                                    Set var(rr&) = pppp.item(w2)
                                    End If
                                Else

                                    R$ = "#" + R$
                                    rr& = 2
                                    Exit Do
                                    End If
                                Else
                                 rr& = globalvarGroup(c$, p1)
                                Set var(rr&) = pppp.item(w2)
                                End If
                            Else
                                rr& = globalvarGroup(c$, pppp.item(w2))
                            End If
                            FeedCopyInOut bstack, R$, rr&, a1$
                           
                            If here$ <> "" Then R$ = here$ + "." + c$ Else R$ = c$
                            rr& = 2
                            Exit Do
                          
                            End If
                          End If
                        End If
                        End If
cont123:
                    R$ = vbNullString
                    rr& = 0
                    Exit Do
            End If
            Case 36 ' "$"
       If one Then Exit Do
            If Len(R$) > 0 Then
            one = True
            rr& = 3 ' is string variable
            R$ = R$ & Left$(a$, 1)
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If Len(R$) > 0 Then
            one = True
            rr& = 4 ' is long variable
            R$ = R$ & Left$(a$, 1)
            nocommand = True
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 58 '":"
        If one Then Exit Do
        If Mid$(a$, 2, 1) <> "\" Then Exit Do
        If InStr(R$, ":") > 1 Then Exit Do
        R$ = R$ & Left$(a$, 2)
                a$ = Mid$(a$, 3)
        Case 40 ' "("
            If Len(R$) > 0 Then
                If Mid$(a$, 2, 2) = ")@" Then
                 R$ = R$ & "()."
                a$ = Mid$(a$, 4)
                ElseIf Mid$(a$, 2, 2) = ")." Then ' And rr& = 1 Then
                 R$ = R$ & "()."
                 rr& = 0
                 one = False
              a$ = Mid$(a$, 4)
              GoTo cont1234
                Else
                Select Case rr&
                Case 1
                rr& = 5 ' float array or function
                Case 3
                rr& = 6 'string array or function
                Case 4
                rr& = 7 ' long array
                Case Else
                Exit Do
                End Select
                R$ = R$ & Left$(a$, 1)
                a$ = Mid$(a$, 2)
               Exit Do
            
            End If
           Else
           Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            R$ = R$ & Left$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
cont1234:
    Loop
    If skipcase Then
        rrr$ = R$
    Else
      rrr$ = myUcase(R$, gr)
    End If
    If dot& Then
havedot:
        nocommand = True
            If Len(R$) > 0 Then
                rr& = bstack.GetDotNew(rrr$, dot&) * rr&
                nocommand = rr&
            Else
                If dot& > 1 Then
                    rrr$ = String$(dot&, ".") + rrr$: If rr& = 0 Then rr& = 1
                Else
                    '' PUT THE DOT BACK
                    If dot& = 1 Then a$ = "." + a$
                End If
            End If
    ElseIf Len(rrr$) > 5 Then
        If Left$(rrr$, 1) = "а" Then
        If Left$(rrr$, 5) = "ауто." Then
        
        
        
        If Len(bstack.UseGroupname) > 0 Then
        rrr$ = bstack.UseGroupname + Mid$(rrr$, 6)
        Else
        rrr$ = Mid$(rrr$, 6)
        dot& = 1
        GoTo havedot
        End If
        End If
        ElseIf Left$(rrr$, 1) = "T" Then
        If Left$(rrr$, 5) = "THIS." Then
          If Len(bstack.UseGroupname) > 0 Then
        rrr$ = bstack.UseGroupname + Mid$(rrr$, 6)
        Else
        rrr$ = Mid$(rrr$, 6)
        dot& = 1
        GoTo havedot
        End If
        End If
        End If
    End If
    If StrPointer Then
    If Abs(rr&) = 3 Then
   cc = LastErNum1
    If IsStr1(bstack, (rrr$), rrr$) Then
        fixlen = True
        a$ = rrr$ + a$
        StrPointer = False
        IsLabelBig = Abs(IsLabelBig(bstack, a$, rrr$, , R$)) * Sgn(rr&)
        
    End If
    LastErNum1 = cc
    nocommand = True
    Exit Function
    
    ElseIf Abs(rr&) = 6 Then
        fixlen = True
        a$ = rrr$ + a$
        cc = LastErNum1
        If IsStr1(bstack, a$, rrr$) Then
        a$ = rrr$ + a$
        IsLabelBig = Abs(IsLabelBig(bstack, a$, rrr$, , R$)) * Sgn(rr&)
        LastErNum1 = cc
        Else
        LastErNum1 = cc
        cc = InStr(rrr$, "(")
        If cc > 0 Then
        a$ = Mid$(rrr$, cc + 1) + a$
        rrr$ = Left$(rrr$, cc)
        IsLabelBig = 4 * Sgn(rr&)
        Else
        IsLabelBig = Sgn(rr&)
        End If
        
        End If
        StrPointer = False
      
        nocommand = True
        
        
    Exit Function
    
    Else
    IsLabelBig = rr&
   End If
    
   Else
    IsLabelBig = rr&
    End If
    
    nocommand = IsLabelBig And (Len(R$) = 1 Or nocommand)

End Function
Function IsLabelFileName(bstack As basetask, a$, rrr$, Optional nocommand As Boolean, Optional R$, Optional noconvert As Boolean = False) As Long
Dim rr&, one As Boolean, c$, dot&, gr As Boolean, skipcase As Boolean, cc As Long
R$ = vbNullString
If a$ = vbNullString Then IsLabelFileName = 0: Exit Function  'ok
a$ = NLtrim$(a$)
    Do While Len(a$) > 0
     c$ = Left$(a$, 1) 'ANYCHAR HERE
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 0 To 7
         a$ = Mid$(a$, 2)
        Case 64 '"@"
           If R$ = vbNullString Then
              a$ = Mid$(a$, 2)
              ElseIf Mid$(a$, 2, 1) <> "(" And R$ <> "" Then
            R$ = R$ & "."
              a$ = Mid$(a$, 2)
              Else
                 IsLabelFileName = 0: Exit Function
            End If
        Case 63 '"?"
        If R$ = vbNullString Then
        rrr$ = "?"
        
        IsLabelFileName = 1
        Exit Function
        End If
        a$ = Mid$(a$, 2)
        Case 58 ' ":"
            If one Then
  
            Exit Do
           
             ElseIf R$ <> "" Then
            If Len(a$) > 1 Then
             
            If Mid$(a$, 2, 1) <> "\" Then
            Exit Do
            ElseIf Mid$(a$, 2, 2) = vbCrLf Then
                Exit Do
            End If
            End If
            
            If InStr(R$, ":") > 0 Then
                IsLabelFileName = 0
            Exit Function
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1
            End If
            Else
            IsLabelFileName = 0
            Exit Function
            End If
        Case 46 ' "."
            
            If one Then
  
            Exit Do
           ElseIf R$ <> "" Then
           
                    R$ = R$ & c$
                       a$ = Mid$(a$, 2)
           ''
           ElseIf Not Mid$(a$, 2, 1) Like "[0-9]" Then
            
                       If R$ <> "" Then
                       R$ = R$ & c$
                      rr& = 1
                                      
                            Else
                            
                            dot& = dot& + 1
                    
                            End If
                         
                         a$ = Mid$(a$, 2)
                        
                        
            Else
                         If R$ = vbNullString And dot& > 0 Then
                                  nocommand = True
                                 rrr$ = String$(dot& + 1, ".")     ' i want this only in right position for "dir .. "
                                 R$ = rrr$
                                  a$ = Mid$(a$, 2)
                                 IsLabelFileName = 1
                         Else
                              IsLabelFileName = 0
                        End If
                    
            Exit Function
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        
        Case 92 '"\"
           If one Then
            Exit Do
            ElseIf R$ <> "" Or dot& Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
              Exit Do
            End If
        Case 48 To 57, 95  ' "0" To "9", "_"
       
           If one Then
            Exit Do
            ElseIf R$ <> "" Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
             nocommand = True
            rr& = 1 'is an identifier or floating point variable
            Else
            If dot& > 0 Then a$ = "." + a$: dot& = 0
            
            Exit Do
            End If
Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 38 '"&"
        
            If one Then Exit Do
            
            If R$ <> "" Then
                'ERROR
                rr& = 0
                '' r$ = VbNullString
                rrr$ = vbNullString
                Exit Function
            Else
           nocommand = True
                
                If noconvert Then
                IsLabelFileName = 0
                Exit Function
                Else
                a$ = Mid$(a$, 2)
                rr& = Abs(IsLabelFileName(bstack, a$, R$))
                End If
                skipcase = True
                If rr& < 5 Then
            Dim i As Long
         
                    If GetlocalVar(R$, i) Then
                        a$ = Chr(34) + here$ & "." & R$ & Chr(34) + a$
                    ElseIf Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                        If Len(bstack.UseGroupname) > 0 Then
                                 c$ = bstack.UseGroupname + Mid$(R$, 6)
                                 
                         Else
                             c$ = StripThis2(here$)
                             If c$ <> "" Then c$ = c$ & "." & Mid$(R$, 6) Else c$ = here$ & "." & R$
                         End If
                    a$ = Chr(34) + c$ + Chr(34) + a$
                    
                  ElseIf varhash.Find(R$, cc) Then
                         a$ = Chr(34) + R$ & Chr(34) + a$
                    Else
                    '' r$ = myUcase(r$, gr)
                    
                    If R$ = "THIS" Or R$ = "ауто" Then
                    rrr$ = R$
                   IsLabelFileName = -100
                   
                   Exit Function
                    Else
                If GetSub(R$ + ")", rr&) Then
                
                                 R$ = "{" + sbf(rr&).sb + "} " + sbf(rr&).sbgroup
                                 
                    rr& = 2
                    Exit Do
                    Else
                 If Not bstack.NoError Then MyErMacro a$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
                    End If
                    End If
                Else
                    If FastSymbol(a$, ")") Then
                           '' r$ = myUcase(r$, gr)
                            rr& = 0
                            If Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                            If varhash.ExistKey(bstack.UseGroupname & Mid$(R$, 6)) Then
                       
                                    a$ = Chr(34) + bstack.UseGroupname & Mid$(R$, 6, Len(R$) - 6) + Chr(34) + a$
                                    Else
                                    rr& = 2
                                    End If
                                ElseIf varhash.ExistKey(here$ & "." & R$) Then
                               a$ = Chr(34) + here$ & "." & R$ + Chr(34) + a$
  
                                ElseIf varhash.ExistKey(R$) Then
                                    a$ = Chr(34) + R$ + Chr(34) + a$
                                Else
                                   rr& = 3
                                End If
                                 If rr& > 0 Then
                                 If rr& = 2 Then
                                 If Len(bstack.UseGroupname) > 0 Then
                                 R$ = bstack.UseGroupname + Mid$(R$, 6)
                                 End If
                                 End If
                                 rr& = 1
                                 If GetSub(R$ + ")", rr&) Then
                            R$ = "{" + sbf(rr&).sb + "}" + sbf(rr&).sbgroup
                                 
                    rr& = 2
     
                    Exit Do
                    
                    Else
                    If Not bstack.NoError Then MyErMacro a$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
               
                                 
                                 End If
                                 rr& = 0
                                 R$ = vbNullString
                                Exit Do
                            End If
                    End If
                    
                    R$ = vbNullString
                    rr& = 0
                    Exit Do
            End If
            
        Case 36 '"$"
       If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 '"%"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            R$ = R$ & c$
            nocommand = True
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 40 '"("
            If R$ <> "" Then
                If Mid$(a$, 2, 2) = ")@" Then
                 R$ = R$ & "()."
              a$ = Mid$(a$, 4)
                Else
                Select Case rr&
                Case 1
                rr& = 5 ' float array or function
                Case 3
                rr& = 6 'string array or function
                Case 4
                rr& = 7 ' long array
                Case Else
                Exit Do
                End Select
                R$ = R$ & c$
                a$ = Mid$(a$, 2)
               Exit Do
            
            End If
           Else
           Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
    Loop
    If skipcase Then
    rrr$ = R$
    Else
    rrr$ = myUcase(R$, gr)
    End If
   If dot& Then
   nocommand = True
                           If R$ <> "" Then
     If Left$(rrr$, 1) = "\" Then
                     R$ = String$(dot&, ".") + rrr$
                          rrr$ = R$
                          rr& = 1
     Else
                        rr& = bstack.GetDotNew(rrr$, dot&) * rr&
                        End If

                        nocommand = rr&
                           Else
                           
                         
                          'rrr$ = String$(dot&, ".") + rrr$: If rr& = 0 Then rr& = 1
                          R$ = String$(dot&, ".") + rrr$
                          rrr$ = R$
                          rr& = 1
                          
                          End If
    
    
   End If
   
    IsLabelFileName = rr&
    nocommand = IsLabelFileName And (Len(R$) = 1 Or nocommand)
 '' a$ = LTrim$(a$)

End Function
Function IsLabel(bstack As basetask, a$, rrr$, Optional skipdot As Boolean) As Long
Dim buf$, fixme As Boolean, q1$
If Len(a$) < 129 Then IsLabel = innerIsLabel(bstack, a$, rrr$, , , skipdot): Exit Function

   
    buf$ = Left$(a$, 128)
    q1$ = bstack.tmpstr
    IsLabel = innerIsLabel(bstack, buf$, rrr$, , , skipdot, fixme)
    If Len(buf$) = 0 Then
        If fixme Then bstack.tmpstr = q1$
        IsLabel = innerIsLabel(bstack, a$, rrr$, , , skipdot)
    Else
        If fixme Then
            Select Case Len(buf$)
            Case Is < 128
                Mid$(a$, 129 - Len(buf$), Len(buf$)) = buf$
                a$ = Mid$(a$, 129 - Len(buf$))
            Case Is > 128
                a$ = buf$ + Mid$(a$, 129)
            Case Else
                Mid$(a$, 1, 128) = buf$
            End Select
        Else
        a$ = Mid$(a$, 129 - Len(buf$))
        End If
    End If

    
    

End Function
'
Function innerIsLabel(bstack As basetask, a$, rrr$, Optional nospace As Boolean = False, Optional skipcase As Boolean = False, Optional skipdot As Boolean, Optional fixlen As Boolean) As Long
Dim rr&, one As Boolean, c$, dot&, gr As Boolean, R$, cc As Long
'r$ = VbNullString
If a$ = vbNullString Then innerIsLabel = 0: Exit Function   ' ok
If Not nospace Then a$ = NLtrim$(a$) Else If AscW(a$) = 32 Then Exit Function
Do While Len(a$) > 0
    c$ = Left$(a$, 1) 'ANYCHAR HERE
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
           If R$ = vbNullString Then
              a$ = Mid$(a$, 2)
              ElseIf Mid$(a$, 2, 1) <> "(" And R$ <> "" Then
            R$ = R$ & "."
              a$ = Mid$(a$, 2)
              Else
                 innerIsLabel = 0: Exit Function
            End If
        Case 63 '"?"
            If R$ = vbNullString Then
                rrr$ = "?"
                innerIsLabel = 1
                Exit Function
            End If
            a$ = Mid$(a$, 2)
        Case 58 '":"
            If one Then
  
            Exit Do
           
            ElseIf R$ <> "" Then
            If Len(a$) > 1 Then
            If Mid$(a$, 2, 1) <> "\" Then
            Exit Do
            ElseIf Mid$(a$, 2, 2) = vbCrLf Then
                Exit Do
            End If
            End If
            
            If InStr(R$, ":") > 0 Then
                innerIsLabel = 0
            Exit Function
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1
            End If
            Else
            innerIsLabel = 0
            Exit Function
            End If
        Case 46 '"."
            
            If one Then
                Exit Do
            ElseIf R$ <> "" Then
                R$ = R$ & c$
                a$ = Mid$(a$, 2)
            ElseIf Not Mid$(a$, 2, 1) Like "[0-9]" Then
            
                       If R$ <> "" Then
                       R$ = R$ & c$
                      rr& = 1
                                      
                            Else
                            
                            dot& = dot& + 1
                    
                            End If
                         
                         a$ = Mid$(a$, 2)
                        
                        
            Else
                         If R$ = vbNullString And dot& > 0 Then
                                 rrr$ = String$(dot& + 1, ".")     ' i want this only in right position for "dir .. "
                                 R$ = rrr$
                                  a$ = Mid$(a$, 2)
                                 innerIsLabel = 1
                         Else
                              innerIsLabel = 0
                        End If
                    
            Exit Function
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        
        Case 92 '"\"
           If one Then
            Exit Do
            ElseIf R$ <> "" Or dot& Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
              Exit Do
            End If
        Case 48 To 57, 95 '"0" To "9", "_"  ' old ,"\"
       
           If one Then
            Exit Do
            ElseIf R$ <> "" Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            If dot& > 0 Then a$ = "." + a$: dot& = 0
            
            Exit Do
            End If
Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 38 ' "&"
        
            If one Then Exit Do
            
            If R$ <> "" Then
                'ERROR
                rr& = 0
                '' r$ = VbNullString
                rrr$ = vbNullString
                innerIsLabel = 0
                Exit Function
            Else
                a$ = Mid$(a$, 2)
                rr& = Abs(innerIsLabel(bstack, a$, R$, True))
                skipcase = True
                If rr& < 5 Then
                    Dim i As Long
                    If GetlocalVar(R$, i) Then
                        a$ = Chr(34) + here$ & "." & R$ & Chr(34) + a$
                    ElseIf Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                        If Len(bstack.UseGroupname) > 0 Then
                            c$ = bstack.UseGroupname + Mid$(R$, 6)
                        Else
                            c$ = StripThis2(here$)
                            If c$ <> "" Then c$ = c$ & "." & Mid$(R$, 6) Else c$ = here$ & "." & R$
                        End If
                        a$ = Chr(34) + c$ + Chr(34) + a$
                    ElseIf varhash.Find(R$, cc) Then
                        a$ = Chr(34) + R$ & Chr(34) + a$

                        If R$ = "THIS" Or R$ = "ауто" Then
                            rrr$ = R$
                            innerIsLabel = -100
                            Exit Function
                        Else
                            If GetSub(R$ + ")", rr&) Then
                                R$ = "{" + sbf(rr&).sb + "} " + sbf(rr&).sbgroup
                                rr& = 2
                                Exit Do
                            Else
                                If cc > 0 Then
                                ElseIf Not bstack.NoError Then
                                    MyErMacro a$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                                End If
                            End If
                        End If
                    End If
                Else
                    If FastSymbol(a$, ")") Then
                           '' r$ = myUcase(r$, gr)
                            rr& = 0
                            If Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                                If varhash.ExistKey(bstack.UseGroupname & Mid$(R$, 6)) > 0 Then
                                    a$ = Chr(34) + bstack.UseGroupname & Mid$(R$, 6, Len(R$) - 6) + Chr(34) + a$
                                Else
                                    rr& = 2
                                End If
                            ElseIf varhash.ExistKey(here$ & "." & R$) Then
                                 a$ = Chr(34) + here$ & "." & R$ + Chr(34) + a$
                            ElseIf varhash.ExistKey(R$) Then
                                a$ = Chr(34) + R$ + Chr(34) + a$
                            Else
                               rr& = 3
                            End If
                            If rr& > 0 Then
                                 If rr& = 2 Then
                                    If Len(bstack.UseGroupname) > 0 Then
                                        R$ = bstack.UseGroupname + Mid$(R$, 6)
                                    End If
                                 End If
                                 rr& = 1
                                 If GetSub(R$ + ")", rr&) Then
                                    R$ = "{" + sbf(rr&).sb + "}" + sbf(rr&).sbgroup
                                    rr& = 2
                                    Exit Do
                    
                    Else
                    If Not bstack.NoError Then MyErMacro a$, "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
               
                                 
                                 End If
                                 rr& = 0
                                 R$ = vbNullString
                                Exit Do
                            End If
                    End If
                    
                    R$ = vbNullString
                    rr& = 0
                    Exit Do
            End If
            
        Case 36 ' "$"
       If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If R$ <> "" Then
                If Mid$(a$, 2, 2) = ")@" Then
                 R$ = R$ & "()."
              a$ = Mid$(a$, 4)
                ElseIf Mid$(a$, 2, 2) = ")." Then ' And rr& = 1 Then
                 R$ = R$ & "()."
                 rr& = 0
                 one = False
              a$ = Mid$(a$, 4)
              GoTo cont1234
                Else
                Select Case rr&
                Case 1
                rr& = 5 ' float array or function
                Case 3
                rr& = 6 'string array or function
                Case 4
                rr& = 7 ' long array
                Case Else
                Exit Do
                End Select
                R$ = R$ & c$
                a$ = Mid$(a$, 2)
               Exit Do
            
            End If
           Else
           Exit Do
            End If
 Case 8 '
     If Len(R$) > 0 Then Exit Do
     a$ = bstack.tmpstr + Mid$(a$, 2)
     fixlen = True
     bstack.tmpstr = vbNullString
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
cont1234:
    Loop
    If skipcase Then
    rrr$ = R$
    Else
    rrr$ = myUcase(R$, gr)
    End If
   If dot& Then
                           If R$ <> "" Then
     If skipdot And dot& = 1 Then
     rrr$ = "THIS." + rrr$
     
     Else

                        rr& = bstack.GetDotNew(rrr$, dot&) * rr&

                        End If
                           Else
                          If dot& > 1 Then rrr$ = String$(dot&, ".") + rrr$: If rr& = 0 Then rr& = 1
                          End If
    
    
   End If
    innerIsLabel = rr&
End Function
Function IsLabelDIM(bstack As basetask, a$, R$) As Long
Dim rr&, one As Boolean, c$, dot&, gr As Boolean, skipcase As Boolean, cc As Long
R$ = vbNullString
If a$ = vbNullString Then IsLabelDIM = 0: Exit Function ' ok
a$ = NLtrim$(a$)
    Do While Len(a$) > 0
     c$ = Left$(a$, 1) 'ANYCHAR HERE
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
           If R$ = vbNullString Then
              a$ = Mid$(a$, 2)
              ElseIf Mid$(a$, 2, 1) <> "(" And R$ <> "" Then
            R$ = R$ & "."
              a$ = Mid$(a$, 2)
              Else
                 IsLabelDIM = 0: Exit Function
            End If
        Case 63 '"?"
        If R$ = vbNullString Then
        R$ = "?"
        IsLabelDIM = 1
        Exit Function
        End If
        a$ = Mid$(a$, 2)
        Case 58 '":"
            If one Then
  
            Exit Do
           
            ElseIf R$ <> "" Then
            If Len(a$) > 1 Then
            If Mid$(a$, 2, 1) <> "\" Then
            Exit Do
            ElseIf Mid$(a$, 2, 2) = vbCrLf Then
                Exit Do
            End If
            End If
            
            If InStr(R$, ":") > 0 Then
                IsLabelDIM = 0
            Exit Function
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1
            End If
            Else
            IsLabelDIM = 0
            Exit Function
            End If
        Case 46 '"."
            
            If one Then
  
            Exit Do
           ElseIf R$ <> "" Then
           
                    R$ = R$ & c$
                       a$ = Mid$(a$, 2)
           ''
           ElseIf Not Mid$(a$, 2, 1) Like "[0-9]" Then
            
                       If R$ <> "" Then
                       R$ = R$ & c$
                      rr& = 1
                                      
                            Else
                            
                            dot& = dot& + 1
                    
                            End If
                         
                         a$ = Mid$(a$, 2)
                        
                        
            Else
                         If R$ = vbNullString And dot& > 0 Then
                     
                             
                                 R$ = String$(dot& + 1, ".")
                                  a$ = Mid$(a$, 2)
                                 IsLabelDIM = 1
                         Else
                              IsLabelDIM = 0
                        End If
                    
            Exit Function
            End If
        Case 94, 123 To 126, 160  '"{" To "~", "^"
            Exit Do
        
        Case 92 '"\"
           If one Then
            Exit Do
            ElseIf R$ <> "" Or dot& Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
              Exit Do
            End If
        Case 48 To 57, 95 '"0" To "9", "_"  ' old ,"\"
       
           If one Then
            Exit Do
            ElseIf R$ <> "" Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
             rr& = 1 'is an identifier or floating point variable
            Else
            If dot& > 0 Then a$ = "." + a$: dot& = 0
            
            Exit Do
            End If
Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 38 ' "&"
        
            If one Then Exit Do
            
            If R$ <> "" Then
            
                rr& = 0
     
              R$ = vbNullString
                Exit Function
            Else
                a$ = Mid$(a$, 2)
                rr& = Abs(IsLabelDIM(bstack, a$, R$))
                skipcase = True
                If rr& < 5 Then
            Dim i As Long
         
                    If GetlocalVar(R$, i) Then
                        a$ = Chr(34) + here$ & "." & R$ & Chr(34) + a$
                    ElseIf Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                        If Len(bstack.UseGroupname) > 0 Then
                                 c$ = bstack.UseGroupname + Mid$(R$, 6)
                                 
                         Else
                             c$ = StripThis2(here$)
                             If c$ <> "" Then c$ = c$ & "." & Mid$(R$, 6) Else c$ = here$ & "." & R$
                         End If
                    a$ = Chr(34) + c$ + Chr(34) + a$
                    
                  ElseIf varhash.Find(R$, cc) Then
                         a$ = Chr(34) + R$ & Chr(34) + a$
                    Else
                    '' r$ = myUcase(r$, gr)
                    
                    If R$ = "THIS" Or R$ = "ауто" Then
                
                   IsLabelDIM = -100
                   
                   Exit Function
                    Else
                If GetSub(R$ + ")", rr&) Then
                
                                 R$ = "{" + sbf(rr&).sb + "} " + sbf(rr&).sbgroup
                                 
                    rr& = 2
                    Exit Do
                    Else
                    If Not bstack.NoError Then MyEr "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
                    End If
                    End If
                Else
                    If FastSymbol(a$, ")") Then
                           '' r$ = myUcase(r$, gr)
                            rr& = 0
                            If Left$(R$, 5) = "ауто." Or Left$(R$, 5) = "THIS." Then
                            If varhash.ExistKey(bstack.UseGroupname & Mid$(R$, 6)) Then
                                    a$ = Chr(34) + bstack.UseGroupname & Mid$(R$, 6, Len(R$) - 6) + Chr(34) + a$
                                    Else
                                    rr& = 1
                                    End If
                                ElseIf varhash.ExistKey(here$ & "." & R$) Then
                                     a$ = Chr(34) + here$ & "." & R$ + Chr(34) + a$
                                ElseIf varhash.ExistKey(R$) Then
                                    a$ = Chr(34) + R$ + Chr(34) + a$
                                Else
                                   rr& = 1
                                End If
                                 If rr& = 1 Then
                                 If Len(bstack.UseGroupname) > 0 Then
                                 R$ = bstack.UseGroupname + Mid$(R$, 6)
                                 Else
                                 End If
                                 If GetSub(R$ + ")", rr&) Then
                                                                  R$ = "{" + sbf(rr&).sb + "}" + sbf(rr&).sbgroup
                                 
                    rr& = 2
     
                    Exit Do
                    
                    Else
                    If Not bstack.NoError Then MyEr "can't pass reference", "ДЕМ ЛПОЯЧ МА БэКЫ АМАЖОЯэ"
                    End If
               
                                 
                                 End If
                                 rr& = 0
                                 R$ = vbNullString
                                Exit Do
                            End If
                    End If
                    
                    R$ = vbNullString
                    rr& = 0
                    Exit Do
            End If
            
        Case 36 ' "$"
       If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If R$ <> "" Then
                If Mid$(a$, 2, 2) = ")@" Then
                    R$ = R$ & "()."
                    a$ = Mid$(a$, 4)
                ElseIf Mid$(a$, 2, 2) = ")." Then ' And rr& = 1 Then
                    R$ = R$ & "()."
                    rr& = 0
                    one = False
                    a$ = Mid$(a$, 4)
                    GoTo cont1234
                Else
                    Select Case rr&
                    Case 1
                    rr& = 5 ' float array or function
                    Case 3
                    rr& = 6 'string array or function
                    Case 4
                    rr& = 7 ' long array
                    Case Else
                    Exit Do
                    End Select
                    R$ = R$ & c$
                    a$ = Mid$(a$, 2)
                    Exit Do
               End If
            Else
                Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
cont1234:
    Loop
    If Not skipcase Then R$ = myUcase(R$, gr)
   If dot& Then
                           If R$ <> "" Then
                         '  rr& = bstack.GetDotNew(r$, dot&) * rr&
                           If dot& = 1 Then
                           R$ = "THIS." + R$
                           rr& = -rr&
                           Else
                        rr& = bstack.GetDotNew(R$, dot&) * rr&
                        End If
                           Else
                            If dot& > 1 Then R$ = String$(dot&, ".") + R$: If rr& = 0 Then rr& = 1
                          End If
    
    
   End If
    IsLabelDIM = rr&
End Function

Function IsLabelSYMB3(a$, R$) As Boolean ' ok
Dim rr&, c$, LB As Long, mb As Long, LLB As Long
a$ = NLtrim$(a$)
LLB = Len(a$)
R$ = vbNullString
If LLB = 0 Then IsLabelSYMB3 = 0: Exit Function
mb = 0   'INDICATE LEFT SPACES
LB = 1
    Do While LB <= LLB
     c$ = Mid$(a$, LB, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 32, 160, 9
        If LB - mb > 1 Then
        LB = LB - 1
        Exit Do
        Else
        mb = LB
        End If
        Case 36, 37, 40 ' "$", "%", "("
            IsLabelSYMB3 = 0
            Exit Function
        Case 46 '"."
         If LB > mb Then
            rr& = 1
            Else
            IsLabelSYMB3 = 0
            Exit Function
            End If
        Case 65 To 90, 97 To 122 ' "A" To "Z", "a" To "z"
     
            rr& = 1 'is an identifier or floating point variable
        Case Else
        LB = LB - 1
        Exit Do
        End Select
                Else
  
           rr& = 1 'is an identifier or floating point variable
   
        
        End If
        LB = LB + 1
    Loop
    R$ = Mid$(a$, mb + 1, LB - mb)
    IsLabelSYMB3 = rr&
  If LB > 0 Then a$ = Mid$(a$, LB + 1)

End Function
Function IsLabelSYMB33(a$, R$, chars As Long) As Boolean ' ok
Dim rr&, c$, LB As Long, mb As Long, LLB As Long

LLB = Len(a$)
R$ = vbNullString
If LLB = 0 Then IsLabelSYMB33 = 0: Exit Function
mb = 0
LB = 1
    Do While LB <= LLB
     c$ = Mid$(a$, LB, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 32, 160, 9
        If LB - mb > 1 Then
        LB = LB - 1
        Exit Do
        Else
        mb = LB
        End If
        Case 46 '"."
         If LB > mb Then
            rr& = 1
            Else
            IsLabelSYMB33 = 0
            Exit Function
            End If
         Case 65 To 90, 97 To 122 ' "A" To "Z", "a" To "z"
     
            rr& = 1 'is an identifier or floating point variable
        Case Else
        LB = LB - 1
        Exit Do
        End Select
                Else
  
           rr& = 1 'is an identifier or floating point variable
   
        
        End If
        LB = LB + 1
    Loop
    R$ = Mid$(a$, mb + 1, LB - mb)
    IsLabelSYMB33 = rr&
   If rr& <> 0 Then
   chars = LB + 1
  
 End If
End Function
Function IsLabelF(a$, rrr$) As Long
Dim buf$
If Len(a$) < 129 Then IsLabelF = IsLabelF1(a$, rrr$): Exit Function

   
    buf$ = Left$(a$, 128)
    IsLabelF = IsLabelF1(buf$, rrr$)
    If buf$ = vbNullString Then
        IsLabelF = IsLabelF1(a$, rrr$)
    Else
        a$ = Mid$(a$, 129 - Len(buf$))
    End If
End Function

Function IsLabelF1(a$, R$) As Long  'ok
' for left side...no &

Dim rr&, one As Boolean, c$, gr As Boolean
R$ = vbNullString
If a$ = vbNullString Then IsLabelF1 = 0: Exit Function
a$ = NLtrim$(a$)
    Do While Len(a$) > 0
    c$ = Left$(a$, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 46 '"."
            If one Then
            Exit Do
            ElseIf R$ <> "" And Len(a$) > 1 Then
            If Mid$(a$, 2, 2) = ". " Or Mid$(a$, 2, 1) = " " Then Exit Do
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1
            Else
            IsLabelF1 = 0
            Exit Function
            End If
      Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
        Exit Do
        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            Exit Do
            ElseIf R$ <> "" Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If R$ <> "" Then
                one = True
                rr& = 4 ' is long variable
                R$ = R$ & c$
                a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If

    Loop
    R$ = myUcase(R$, gr)
    IsLabelF1 = rr&


End Function
Function IsLabelA(where$, a$, R$) As Long
Dim n$
If Len(a$) < 65 Then
    IsLabelA = IsLabelA1(where$, a$, R$)
Else
    n$ = Left$(a$, 64)
    IsLabelA = IsLabelA1(where$, n$, R$)
    If Len(n$) = 0 Then
        IsLabelA = IsLabelA1(where$, a$, R$)
    Else
        a$ = Mid$(a$, 65 - Len(n$))
    End If
End If
End Function
Function IsLabelA1(where$, a$, R$) As Long 'ok
' for left side...no &

Dim rr&, one As Boolean, c$, gr As Boolean
R$ = vbNullString
If a$ = vbNullString Then IsLabelA1 = 0: Exit Function
a$ = NLtrim$(a$)
    Do While Len(a$) > 0
    c$ = Left$(a$, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
            If Mid$(a$, 2, 1) <> "(" And R$ <> "" Then
              where$ = R$
            R$ = vbNullString
            a$ = Mid$(a$, 2)
            Else
              IsLabelA1 = 0: Exit Function
            End If
        Case 63 '"?"
        If R$ = vbNullString Then
        R$ = "?"
        a$ = Mid$(a$, 2)
        IsLabelA1 = 1
        Exit Function
        Else
        IsLabelA1 = 1
        Exit Function
        End If
        Case 46 '"."
            If one Then
            Exit Do
            Exit Do
            ElseIf R$ <> "" And Len(a$) > 1 Then
            If Mid$(a$, 2, 2) = ". " Or Mid$(a$, 2, 1) = " " Then Exit Do
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1
            Else
            IsLabelA1 = 0
            Exit Function
            End If
      Case 38 ' "&"
            If R$ = vbNullString Then rr& = 2:    a$ = Mid$(a$, 2)
            Exit Do
    Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
        Exit Do
        
        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            Exit Do
            ElseIf R$ <> "" Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If R$ <> "" Then
                            If Mid$(a$, 2, 2) = ")@" Then
                                    R$ = R$ & "()."
                                  
                                 a$ = Mid$(a$, 4)
                               Else
                                       Select Case rr&
                                       Case 1
                                       rr& = 5 ' float array or function
                                       Case 3
                                       rr& = 6 'string array or function
                                       Case 4
                                       rr& = 7 ' long array
                                       Case Else
                                       Exit Do
                                       End Select
                                       R$ = R$ & c$
                                       a$ = Mid$(a$, 2)
                                   Exit Do
                            
                          End If
               Else
                        Exit Do
            
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If

    Loop
    R$ = myUcase(R$, gr)

    IsLabelA1 = rr&

End Function

Function IsLabelDot(where$, a$, R$, Optional dotnum&) As Long 'ok
' for left side...no &

Dim rr&, one As Boolean, c$, firstdot$, gr As Boolean
R$ = vbNullString
If a$ = vbNullString Then IsLabelDot = 0: Exit Function

a$ = NLtrim$(a$)
    Do While Len(a$) > 0
    c$ = Left$(a$, 1)
    If AscW(c$) < 256 Then
        Select Case AscW(c$)
        Case 64  '"@"
            If Mid$(a$, 2, 1) <> "(" And R$ <> "" Then
              where$ = R$
            R$ = vbNullString
            a$ = Mid$(a$, 2)
            Else
              IsLabelDot = 0: a$ = firstdot$ + a$: Exit Function
            End If
        Case 63 '"?"
        If R$ = vbNullString And firstdot$ = vbNullString Then
        R$ = "?"
        a$ = Mid$(a$, 2)
        IsLabelDot = 1
        Exit Function
    
        ElseIf firstdot$ = vbNullString Then
        IsLabelDot = 1
        Exit Function
        Else
        IsLabelDot = 0
        Exit Function
        End If
        Case 46 '"."
            If one Then
            Exit Do
            Exit Do
            ElseIf R$ <> "" And Len(a$) > 1 Then
            If Mid$(a$, 2, 2) = ". " Or Mid$(a$, 2, 1) = " " Then Exit Do
            R$ = R$ & Left$(a$, 1)
            a$ = Mid$(a$, 2)
            rr& = 1
            Else
            firstdot$ = firstdot$ + "."
            a$ = Mid$(a$, 2)
            End If
       Case 92, 94, 123 To 126, 160 '"\","^", "{" To "~"
        Exit Do

        Case 48 To 57, 95 '"0" To "9", "_"
           If one Then
            If firstdot$ <> "" Then a$ = firstdot$ + a$
            Exit Do
            ElseIf R$ <> "" Then
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            Exit Do
            End If
        Case Is < 0, Is > 64 ' >=A and negative
            If one Then
            Exit Do
            ElseIf Len(R$) = 0 Then
            If firstdot$ = "." Then
            R$ = "THIS." + c$
            firstdot$ = vbNullString
            Else
            R$ = R$ & c$
            End If
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            Else
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        Case 36 ' "$"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 3 ' is string variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 37 ' "%"
            If one Then Exit Do
            If R$ <> "" Then
            one = True
            rr& = 4 ' is long variable
            R$ = R$ & c$
            a$ = Mid$(a$, 2)
            Else
            Exit Do
            End If
        Case 40 ' "("
            If R$ <> "" Then
                If Mid$(a$, 2, 2) = ")@" Then
                    R$ = R$ & "()."
                    a$ = Mid$(a$, 4)
                ElseIf Mid$(a$, 2, 2) = ")." Then ' And rr& = 1 Then
                    R$ = R$ & "()."
                    rr& = 0
                    one = False
                    a$ = Mid$(a$, 4)
                    GoTo cont1234
                Else
                       Select Case rr&
                        Case 1
                        rr& = 5 ' float array or function
                        Case 3
                        rr& = 6 'string array or function
                        Case 4
                        rr& = 7 ' long array
                        Case Else
                        Exit Do
                        End Select
                        R$ = R$ & c$
                        a$ = Mid$(a$, 2)
                    Exit Do
                        
                          End If
               Else
                        Exit Do
            
            End If
        Case Else
        Exit Do
        End Select
        Else
            If one Then
            Exit Do
            Else
            gr = True
            If firstdot$ = "." Then
            R$ = "ауто." + c$
            firstdot$ = vbNullString
            Else
            R$ = R$ & c$
            End If
            a$ = Mid$(a$, 2)
            rr& = 1 'is an identifier or floating point variable
            End If
        End If
cont1234:
    Loop
    If Len(firstdot$) = 0 Then
    R$ = myUcase(R$, gr)
    ElseIf dotnum& = -1 Then
        R$ = myUcase(R$, gr)
        dotnum& = Len(firstdot$)
    Else
    R$ = firstdot$ + myUcase(R$, gr)
    End If
    IsLabelDot = rr&
   

End Function
Function IsStrExp(basestack As basetask, aa$, rr$, Optional check As Boolean = True) As Boolean
If check Then
If Not aheadstatusStr(aa$) Then
'If Left$(aheadstatus(aa$, False), 1) = "S" Then Stop
 IsStrExp = False: Exit Function
End If
End If
'If check Then If Left$(aheadstatus(aa$, False), 1) <> "S" Then IsStrExp = False: Exit Function
If LastErNum = -2 Then LastErNum = 0 ': LastErNum1 = 0

If lookOne(aa$, "(") Then
IsExp basestack, aa$, (0), , True, False
End If
Dim ac$, fault As Boolean
' uink$ = VbNullString 'MINK$
again:
fault = False
IsStrExp = False
'' FastSymbol aa$, "+"   '' maybe but not sure if it is ok.
Do While IsString(basestack, aa$, rr$)
fault = False
IsStrExp = True
If Len(ac$) > 0 Then
ac$ = ac$ & rr$
Else
SwapStrings ac$, rr$
End If
If Not FastSymbol(aa$, "+") Then Exit Do
Set basestack.lastobj = Nothing
fault = True
If lookOne(aa$, "(") Then IsExp basestack, aa$, (0), , True, False
Loop
If fault Then
If LastErNum = -2 Then
Exit Function
Else
aa$ = "+" & aa$
End If
End If
If FastSymbol(aa$, "<<", , 2) Then
basestack.soros.DataStr ac$
ac$ = vbNullString
GoTo again
End If
If Not IsStrExp Then Set basestack.lastobj = Nothing
rr$ = ac$
 End Function

Function ReadVarDouble(bstack As basetask, what$) As Variant
Dim vvv As Variant
bstack.ReadVar what$, vvv
If MyIsObject(vvv) Then
Set bstack.lastobj = vvv
Else
ReadVarDouble = vvv
End If
End Function

Function ReadVarInt(bstack As basetask, what$) As Variant
Dim vvv As Variant
bstack.ReadVar what$, vvv
ReadVarInt = Int(vvv)
End Function
Function ReadVarStr(bstack As basetask, what$) As String
Dim vvv As Variant
bstack.ReadVar what$, vvv
ReadVarStr = vvv
End Function
Function IsString(bstackstr As basetask, a$, R$) As Boolean
R$ = vbNullString
Dim i As Long, q
i = MyTrimL(a$)   ' MyTrimL("   ") return 3 no 0. but never happen to be "   "
q = AscW(Mid$(a$, i, 1))
Select Case q
Case 123
        R$ = blockString(a$, 125, i + 1)
        IsString = FastSymbol(a$, "}")
        If Not IsString Then GoTo err1111
        Exit Function
Case 34
        R$ = blockString(a$, 34, i + 1)
        IsString = FastSymbol(a$, Chr$(34))
        If Not IsString Then GoTo err1111
        If R$ = vbNullString Then
        Dim rr$
        Do While a$ <> ""
            Oldway a$, rr$
            R$ = R$ + rr$
            If Len(a$) > 0 Then
            If AscW(a$) = 34 Then
                a$ = Mid$(a$, 2)
                R$ = R$ + Chr$(34) + blockString(a$, 34)
                IsString = FastSymbol(a$, Chr$(34))
            Else
            Exit Do
            End If
            Else
            Exit Do
            End If
        Loop
        End If
        If Not IsString Then GoTo err1111
        Exit Function
Case 40
     If IsExp(bstackstr, a$, q) Then SwapString2Variant R$, q: IsString = True
    
Case 1, 2
        IsString = ISSTRINGA(a$, R$)
Case Else
    IsString = IsStr1(bstackstr, a$, R$)
  End Select
Exit Function
err1111:
MyErMacroStr a$, "No closed string, open with " & ChrW(q), "аМОИВТЭ АКЖАЯИХЛГТИЙЭ, ЛЕ " & ChrW(q)

End Function
Private Sub Oldway(a$, R$)
Dim w As Long
        w = 1
        If Mid$(a$, w, 2) = Chr(34) + Chr$(34) Then
            Do
            R$ = R$ + Chr$(34)
            w = w + 2
            Loop Until Not Mid$(a$, w, 2) = Chr(34) + Chr$(34)
            a$ = NLtrim$(Mid$(a$, w))
    End If
End Sub
Function IsStr1(bstackstr As basetask, a$, R$) As Boolean
Dim nbstack As basetask, n$
Dim p As Variant, pp As Variant, pppp As mArray, ms As mStiva2, usehandler As mHandler
Dim q$, w As Long, w1&, w2 As Long, s$, par As Boolean, usebackup As Boolean
Dim q1$, q2$, w3 As Long, dn As Long, dd As Long, bs As basetask, sg1 As Boolean
Dim anything As Object, gr As Boolean
againpointer:
Set bstackstr.lastobj = Nothing

    
 w2 = Len(a$)

If Len(a$) < 129 Then
w1& = IsLabelBig(bstackstr, a$, q$, par, q2$, , , usebackup, , gr)
Else
    n$ = Left$(a$, 128)
    q1$ = bstackstr.tmpstr
    w1& = IsLabelBig(bstackstr, n$, q$, par, q2$, , , usebackup, sg1, gr)
    If Len(n$) = 0 Then
        If sg1 Then bstackstr.tmpstr = q1$
        w1& = IsLabelBig(bstackstr, a$, q$, par, q2$, , , usebackup, gr)
    Else
        If sg1 Then
            sg1 = False
            Select Case Len(n$)
            Case Is < 128
                Mid$(a$, 129 - Len(n$), Len(n$)) = n$
                a$ = Mid$(a$, 129 - Len(n$))
            Case Is > 128
                a$ = n$ + Mid$(a$, 129)
            Case Else
                Mid$(a$, 1, 128) = n$
            End Select
        Else
            a$ = Mid$(a$, 129 - Len(n$))
        End If
        
    End If
End If
''''''''If NoOptimum Then If w1& > 0 Then par = False
If w1& <= 0 Or par Then
If usebackup Then If w1& > 4 Then GoTo conthere
If w1& = 0 Then Exit Function  ' not found
If w1& = -50 Then
R$ = q$
IsStr1 = True
Exit Function
End If
If w1& = -100 Then
    w1& = 0
      R$ = vbNullString
      If bstackstr.GetDotNew(R$, 1, True) Then
      If R$ = "THIS." Then
      R$ = Left$(bstackstr.UseGroupname, Len(bstackstr.UseGroupname) - 1)
       ElseIf Len(bstackstr.UseGroupname) > 0 Then
        If bstackstr.tpointer > 0 Then
            If var(bstackstr.tpointer).GroupName = R$ Then
                R$ = var(bstackstr.tpointer).Patch
            Else
                GoTo cont2345
            End If
       Else
cont2345:
           If Len(R$) = 0 Then IsStr1 = False: Exit Function
          
           
           If R$ = bstackstr.UseGroupname Then
           R$ = Left$(R$, Len(R$) - 1)
           ElseIf InStr(R$, ".") = 0 Then
           R$ = Left$(R$, Len(R$) - 1)
            If here$ <> "" Then R$ = here$ + "." + R$
            Else
            R$ = Left$(R$, Len(R$) - 1)
           End If
           
           End If
       Else
       If Len(R$) = 1 Then
       Set bs = bstackstr.Parent
       Do While Not (bs Is Nothing)
        If bs.GetDotNew(R$, 1) Then
                     If Len(R$) = 1 Then
                     Set bs = bs.Parent
                     Else
                     R$ = here$ + "." + Left$(R$, Len(R$) - 1)
                     Set bs = Nothing
                     Exit Do
                     End If
Else
R$ = vbNullString
Exit Do
        End If
       Loop
       Else
    If Len(R$) = 0 Then
    
    ElseIf Left$(R$, 1) = "*" Then

    R$ = Mid$(R$, 2, Len(R$) - 2)
    ElseIf Len(here$) > 0 Then
           If Len(here$) < Len(R$) Then
              If Left$(R$, Len(here$) + 1) = here$ + "." Then
                  R$ = Left$(R$, Len(R$) - 1)
              Else
                  R$ = here$ + "." + Left$(R$, Len(R$) - 1)
              End If
          Else
             R$ = here$ + "." + Left$(R$, Len(R$) - 1)
          End If
   Else
          R$ = Left$(R$, Len(R$) - 1)
 End If
  End If
  End If
  
           IsStr1 = True
  
        Exit Function
    ElseIf Len(bstackstr.UseGroupname) > 0 Then
        R$ = Left$(bstackstr.UseGroupname, Len(bstackstr.UseGroupname) - 1)
         IsStr1 = True
         Exit Function

    End If
    R$ = vbNullString
End If
w1& = Abs(w1&)
Select Case w1&
Case 2
SwapStrings R$, q$
IsStr1 = True
Exit Function
Case 3
GoTo itisavar
Case 5
GoTo rvalObjectstring
Case 6
GoTo itisarrayorfunction
Case Else
checkpointer:
If w1& = 1 Then
If GetVar(bstackstr, q$, w1&) Then
    If MyIsObject(var(w1&)) Then
        If TypeOf var(w1&) Is Group Then
            If var(w1&).HasValue Then
            If var(w1&).HasValue And Not IsOperator(a$, "::", 2) Then
                q1$ = q$ + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                w = w1
                If GetSub(q1$, w1) Then GoTo foundprivate
                
            End If
            ElseIf var(w1&).IamApointer Then
                Set bstackstr.lastpointer = var(w1&)
                If var(w1&).link.IamFloatGroup Then
                 Set pppp = BoxGroupVar(var(w1))
                Mid$(a$, 1, 2) = "." + Chr(3)
                IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", "", a$, (0)) = 1
                R$ = bstackstr.LastValue
                Exit Function
                Else
                Mid$(a$, 1, 2) = Chr(0) + "."
                GoTo againpointer
                End If
            ElseIf lookOne(a$, "#") Then
                q$ = q$ + "$"
                w = w1&
                GoTo checkit
            End If
        ElseIf TypeOf var(w1&) Is mHandler Then
        If FastSymbol(a$, "#") Then
comehere:
        p = vbNullString
        IsStr1 = Matrix(bstackstr, a$, var(w1&), p)
        SwapString2Variant R$, p
        Exit Function
        End If
        End If
        
    End If
ElseIf q$ = "ARRAY" Then
arrentry:
If bstackstr.soros.Total = 0 Then
    
           EmptyStack a$
  
        IsStr1 = False: Exit Function

    ElseIf bstackstr.soros.StackItemTypeObjectType(1) = "*[mArray]" Then
        Set bstackstr.lastobj = bstackstr.soros.PopObj
    GoTo Final

        Exit Function
    Else
   StackTopNotArray a$
  
    IsStr1 = False
    End If
Exit Function
ElseIf q$ = "пимайас" Then
GoTo arrentry
End If
End If
         IsStr1 = False
        Exit Function

End Select
End If

conthere:
Select Case w1&
Case 1
GoTo checkpointer
Case 5
            ' check again
rvalObjectstring:
    If Left$(aheadstatus(q$ + CopyUntilEndOfLine(a$), False), 1) = "S" Then
        
        If neoGetArray(bstackstr, q$, pppp) Then
enterthis:
            If NeoGetArrayItem(pppp, bstackstr, q$, w, a$, , , True, True) Then
               
                If Not pppp.Arr And FastSymbol(a$, ")") Then
                ' need an object

                    If IsNumber(bstackstr, q$ + ")", p) Then
                        If Not bstackstr.lastobj Is Nothing Then
                            Set pppp.GroupRef = bstackstr.lastobj
                            Set bstackstr.lastobj = Nothing
                            w = -2
                            If FastSymbol(a$, "(") Then
                                If NeoGetArrayItem(pppp, bstackstr, q$, w, a$, , , True) Then
                                End If
                            End If
                        End If
                    End If
                Else
enteragain:
                    If pppp.ItemType(w) = mgroup Then
                        If pppp.item(w).IamFloatGroup Then
                            If pppp.item(w).IamApointer Then
                                If Mid$(a$, 1, 2) = "=>" Then Mid$(a$, 1, 2) = "." + ChrW(3)
                            End If
                            GoTo groupstrvalue
                        End If
                        If pppp.GroupRef Is Nothing Then
                            GoTo groupstrvalue
                        Else
                            If Len(q$) > Len(pppp.GroupRef.GroupName) Then
                                q1$ = Left$(q$, Len(q$) - 1) + "." + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                            Else
                                q1$ = pppp.GroupRef.GroupName + ChrW(&H1FFF) + ChrW(&H1FFD) + "()"
                            End If
                        End If
                        q$ = BlockParam(a$)
                        a$ = Mid$(a$, Len(q$) + 2)
                        If GetSub(q1$, w1) Then
                            Set nbstack = New basetask
                            Set nbstack.Parent = bstackstr
                            If bstackstr.IamThread Then Set nbstack.Process = bstackstr.Process
                            Set nbstack.Owner = bstackstr.Owner
                            nbstack.OriginalCode = w1
                            nbstack.UseGroupname = sbf(w1).sbgroup
                            nbstack.tpointer = sbf(w1).tpointer
                            nbstack.SetV
                            If GoFunc(nbstack, q1$, q$ + ")", R$) Then
                                If Not nbstack.StaticCollection Is Nothing Then
                                    bstackstr.Parent.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                                End If
                                'Set bstackstr.lastobj = nBstack.lastobj
                                If IsOperator(a$, "(") Then
                                    Set pppp = New mArray
                                    Set pppp.GroupRef = bstackstr.lastobj
                                    Set bstackstr.lastobj = Nothing
                                    pppp.Arr = False
                                    w = -2
                                    Set nbstack = Nothing
                                    GoTo contrightstrpar
                                ElseIf Left$(a$, 1) = "." Then
cont1002001:
                                     Set pppp = New mArray
                                     Set pppp.GroupRef = bstackstr.lastobj
                                     Set bstackstr.lastobj = Nothing
                                     pppp.Arr = False
                                     w = -2
                                     Set nbstack = Nothing
                                     GoTo groupstrvalue
                                End If
                            End If
                                Set nbstack = Nothing
                                IsStr1 = True
                            Else
                                IsStr1 = False
                            End If
                        ElseIf pppp.ItemType(w) = mHdlr Then
                        If FastSymbol(a$, "#") Then
                                p = vbNullString
                            IsStr1 = Matrix(bstackstr, a$, pppp.item(w), p)
                            If Left$(a$, 1) = "." And Not bstackstr.lastobj Is Nothing Then
                            If TypeOf bstackstr.lastobj Is Group Then
                            GoTo cont1002001
                            End If
                            End If
                            SwapString2Variant R$, p
                            Exit Function
                        Else
                        Set anything = pppp.item(w)
                        Set usehandler = anything
                        If usehandler.t1 = 3 Then
                        Set pppp = usehandler.objref
                        Set usehandler = Nothing
                        GoTo enterthis
                        End If
                        Set usehandler = Nothing
                        End If
                        ElseIf pppp.ItemType(w) = myArray And InStr(q$, "$") = 0 Then
                        If FastSymbol(a$, "#") Then
                                p = vbNullString
                            Set usehandler = New mHandler
                            Set usehandler.objref = pppp.item(w)
                                
                            IsStr1 = Matrix(bstackstr, a$, usehandler, p)
jump1:
                            If Left$(a$, 1) = "." And Not bstackstr.lastobj Is Nothing Then
                            If TypeOf bstackstr.lastobj Is Group Then
                            GoTo cont1002001
                            End If
                            End If
                            SwapString2Variant R$, p
                            Exit Function
                        Else
                            Set bstackstr.lastobj = pppp.item(4)
                            IsStr1 = True
                        End If
                        ElseIf Typename(pppp.GroupRef) = mProp Then
                 
                        
                        p = pppp.GroupRef.Value
                        Set bstackstr.lastobj = pppp.GroupRef.lastobjfinal
                        If Not bstackstr.lastobj Is Nothing Then p = vbNullString
                        If FastSymbol(a$, "#") Then
                        If TypeOf bstackstr.lastobj Is mHandler Then
                        Set usehandler = bstackstr.lastobj
                        Set bstackstr.lastobj = Nothing
                            IsStr1 = Matrix(bstackstr, a$, usehandler, p)
                            GoTo jump1
                        End If
                        ElseIf bstackstr.lastobj Is Nothing Then
                            R$ = ""
                            Exit Function
                        End If
                        Else
                            IsStr1 = False
                        End If
                        Exit Function
                    End If
groupstrvalue:
                    If pppp.ItemType(w) = mgroup Then
                        IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", q$, a$, w) = 1
                        R$ = bstackstr.LastValue
                        Exit Function
                    End If
                Else
                    If Not pppp Is Nothing Then
                        If anything Is pppp.item(w) Then Exit Function
                            Set anything = pppp.item(w)
                            If CheckLastHandler(anything) Then
                                Set usehandler = anything
                                If usehandler.t1 = 3 Then
                                    If TypeOf usehandler.objref Is mArray Then
                                        Set pppp = usehandler.objref
                                        Set usehandler = Nothing
                                    Else
                                        Exit Function
                                    End If
                                Else
                                    Set pppp = New mArray
                                    pppp.Arr = False
                                    Set pppp.GroupRef = anything
                                End If
                                Set usehandler = Nothing
                                If NeoGetArrayItem(pppp, bstackstr, q$, w, a$) Then
                                    GoTo enteragain
                                Else
                                    If Not pppp Is Nothing Then
                                        If w < 0 Then
                                        Set usehandler = pppp.item(w)
                                        If Typename(usehandler.objref) = myArray Then
                                            Set pppp = usehandler.objref
                                        End If
                                        Set usehandler = Nothing
                                        GoTo enterthis
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            Else
          
            If usebackup Then
            If Not strfunidbackup.Find(q$, w1) Then GoTo isasub ' Exit Function
        Else
            
            If Not strfunid.Find(q$, w1, bstackstr.strnum) Then
            q1$ = q$ + ")"
            If GetSub(q1$, w1&) Then
             Set nbstack = New basetask
                Set nbstack.Parent = bstackstr
                Set nbstack.Owner = bstackstr.Owner
                nbstack.UseGroupname = sbf(w1&).sbgroup
                nbstack.tpointer = sbf(w1&).tpointer
                nbstack.OriginalCode = w1&
                nbstack.SetV
                If GoFunc(nbstack, q1$, a$, s$, , , True) Then
                    If Not nbstack.StaticCollection Is Nothing Then
                        bstackstr.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                    End If
                    Set bstackstr.lastobj = nbstack.lastobj
                    Set nbstack = Nothing
                    SwapStrings R$, s$
                    s$ = vbNullString
                    GoTo Final
                    Else
                    IsStr1 = False
                End If
          
            
            
            
            End If
            Exit Function
            End If
            If w1 < 0 Then Exit Function
            
        End If
            On w1 GoTo F1, f2, f3, f4, f5, f6, f7
            Exit Function
F1: ' "STACKITEM(", "тилгсыяоу("
            IsStr1 = StackItem(bstackstr, a$, 1, p)
            GoTo Final
f2: ' "ARRAY(", "пимайас("
            IsStr1 = IsArrayFun(bstackstr, a$, p, 1)
            GoTo Final
f3: ' "CONS(", "емысг("
            IsStr1 = IsCons(bstackstr, a$, p, 1)
            GoTo Final
f4: ' "CAR(", "пяыто("
            IsStr1 = IsCar(bstackstr, a$, p)
            GoTo Final
f5: ' "CDR(", "еполема("
            IsStr1 = IsCdr(bstackstr, a$, p)
            GoTo Final
f6: ' "VAL(", "тилг(", "аниа("
            IsStr1 = IsVal(bstackstr, a$, p, 1, Left$(q$, 1) = "V")
            GoTo Final
f7: ' "EVAL(", "ейжя(", "ейжяасг("
            IsStr1 = IsEval(q$, bstackstr, a$, p, 1)

Final:
           If FastSymbol(a$, "#") Then
                p = vbNullString
                Set pp = bstackstr.lastobj
                Set bstackstr.lastobj = Nothing
                IsStr1 = Matrix(bstackstr, a$, pp, p)
                SwapString2Variant R$, p
    
                Exit Function
            ElseIf Left$(a$, 2) = "=>" Then
                    If TypeOf bstackstr.lastobj Is Group Then
                    Set pppp = BoxGroupVar(bstackstr.lastobj)
                    Set nbstack = Nothing
                    Set bstackstr.lastobj = Nothing
                    w = 0
                    Mid$(a$, 1, 2) = "." + ChrW(3)
                    GoTo groupstrvalue
                    End If
            End If
            End If
        Else
            IsStr1 = False
            Exit Function
        End If
    Case 3
        IsStr1 = False
        If usebackup Then
            If Not stridbackup.Find(q$, w1) Then GoTo itisavar
        Else
            If Not strid.Find(q$, w1, bstackstr.strnum) Then GoTo itisavar
            If w1 < 0 Then GoTo itisavar
        End If
    'Select Case q$
    ' "ABOUT$", "пеяи$"
findsecond:
        On w1 GoTo lit1, lit2, lit3, lit4, lit5, lit6, lit7, lit8, lit9, lit10, lit11, lit12, lit13, lit14, lit15, lit16, lit17, lit18, lit19, lit20, lit21, lit22, lit23, lit24, lit25, lit26, lit27, lit28, lit29, lit30, lit31, lit32, lit33, lit34, lit35, lit36, lit37

lit1:
            R$ = feedback$
            feedback$ = vbNullString
             IsStr1 = True
              Exit Function
lit2: '    Case "CONTROL$"
                Str1nControls R$
                IsStr1 = True
                Exit Function
lit32:   ' Case "жояла$"
                Str1nControlsGR R$
                IsStr1 = True
                Exit Function
                
lit3: '   Case "THREADS$"
                 R$ = bstackstr.Parent.ThreadsStr(1)
                 IsStr1 = True
                Exit Function
lit33: '  Case "мглата$"
                               R$ = bstackstr.Parent.ThreadsStr
                               IsStr1 = True
                            Exit Function
lit38: ' Case "INTERNET$", "диадийтуо$"
    R$ = GetExternalIP
      IsStr1 = True
     Exit Function
lit37: ' Case "INTERNET$", "диадийтуо$"
    R$ = GetExternalIP
      IsStr1 = True
     Exit Function
lit4: '   Case "LAN$", "дийтуо$"
    R$ = getIP
      IsStr1 = True
     Exit Function
lit5: '    Case "GRABFRAME$", "паяейаяе$"
                              If AVIUP Then
                              If MediaPlayer1.MovieHeight > 0 Then
                              R$ = GrabFrame
                              End If
                              End If
                             IsStr1 = True
                            Exit Function
lit6: '    Case "емаомола$", "TEMPNAME$"
                             R$ = GetTempFileName
                            IsStr1 = True
                            Exit Function
lit7: ' "TEMPORARY$", "пяосыяимо$"  ' бя╦хгйе дуо жояес то пяосыяимо$
                            R$ = strTemp  'аутос еимаи о жайекос
                            IsStr1 = True
                            Exit Function
lit8: '    Case "USER.NAME$", "омола.вягстг$"
                             R$ = Originalusername
                            IsStr1 = True
                            Exit Function
lit9: '    Case "COMPUTER$", "упокоцистгс$"
                             R$ = strMachineName
                            IsStr1 = True
                            Exit Function
lit10: '    Case "CLIPBOARD$", "пяовеияо$"
                            R$ = GetTextData(CF_UNICODETEXT)
                            If R$ = vbNullString Then R$ = Clipboard.GetText
                            IsStr1 = True
                            Exit Function
lit11: '    Case "CLIPBOARD.IMAGE$", "пяовеияо.еийома$"
                        R$ = GetImage()
                         IsStr1 = True
                         Exit Function

lit12: '    Case "паяалетяои$", "PARAMETERS$"
                        R$ = para$
                        IsStr1 = True
                        Exit Function
lit13: '    Case "OS$", "кс$"
                        R$ = os
                        IsStr1 = True
                        Exit Function
lit14: '    Case "емтокг$", "COMMAND$"
                        R$ = LASTPROG$
                    IsStr1 = True
                    Exit Function
lit15: '   Case "кахос$"
        If Left$(LastErNameGR, 1) = Chr(0) Then LastErNameGR = Mid$(LastErNameGR, 2)
                     R$ = LastErNameGR
                      LastErNum1 = 0
                        LastErNameGR = vbNullString
                     LastErName = vbNullString
                    IsStr1 = True
                    Exit Function
lit34: '    Case "ERROR$"
    If Left$(LastErName, 1) = Chr(0) Then LastErName = Mid$(LastErName, 2)
                     R$ = LastErName
                      LastErNum1 = 0
                     LastErNameGR = vbNullString
                     LastErName = vbNullString
                    IsStr1 = True
                    Exit Function
lit36: ' case "MODULE.NAME$", "омола.тлглатос$"
            If SecureNames Then
             IsStr1 = GetThisModuleName(R$)
            Exit Function
            End If
 
lit16: '    Case "MODULE$", "тлгла$"
                    R$ = here$
                    IsStr1 = True
                    Exit Function

lit17: '    Case "PRINTERNAME$", "ейтупытгс$"  ' ДЕМ ПАъФЕИ ЯЭКО ПИА Г ПЭЯТА
                    R$ = pname & " (" & Port & ")"
                    IsStr1 = True
                    Exit Function
lit18: '    Case "PROPERTIES$", "идиотгтес$"
                If ThereIsAPrinter Then
                If UBound(MyDM) = 1 Then
                    PrinterDim pw, ph, psw, psh, pwox, phoy
                End If
                R$ = ARRAYtoStr(MyDM())
                Else
                R$ = vbNullString
                End If
                    IsStr1 = True
                    Exit Function
lit19: '    Case "MOVIE.STATUS$", "йатастасг.таимиас$"
                   R$ = MediaPlayer1.getStatus
                IsStr1 = True
                Exit Function
lit20: '    Case "MOVIE.DEVICE$", "сусйеуг.пяобокгс$"
                   R$ = MediaPlayer1.getDeviceName
                IsStr1 = True
                Exit Function
lit21: '    Case "MOVIE.ERROR$", "кахос.таимиас$"
                   R$ = MediaPlayer1.checkError
                IsStr1 = True
                Exit Function
lit22: '    Case "PLATFORM$", "пкатжояла$"
                R$ = Platform
                IsStr1 = True
                Exit Function

lit23: '    Case "FONTNAME$", "цяаллатосеияа$"
    With bstackstr
                 If .tolayer > 0 And .tolayer < 32 Then
                 R$ = Form1.dSprite(.tolayer).Font.Name
                 ElseIf .tolayer >= 32 Then
                 R$ = players(.tolayer).FontName
                 ElseIf .toback Then
                 R$ = Form1.Font.Name
                 ElseIf .toprinter Then
                 R$ = Form1.PrinterDocument1.Font.Name
                 Else
                R$ = Form1.DIS.Font.Name
                End If
                End With
                 IsStr1 = True
                 Exit Function
lit24: '    Case "BROWSER$", "амакоцио$"
                R$ = Form1.view1.LocationURL
                IsStr1 = True
                Exit Function

lit25: '    Case "SPRITE$", "диажамеиа$"
                R$ = BACKSPRITE
                BACKSPRITE = vbNullString
                IsStr1 = True
                Exit Function
lit26: '    Case "APPDIR$", "ежаялоцг.йат$"
                R$ = GetLongName(App.Path)
                If Right(R$, 1) <> "\" Then R$ = R$ + "\"
                IsStr1 = True
                Exit Function
lit27: '    Case "DIR$", "йат$"
    
                R$ = UserPath
    
                IsStr1 = True
                Exit Function
lit28: '    Case "KEY$", "йол$"
                ' this is because w1 do a pretty new functionality...form1 can minimized..without own titlebar or controls.
                If GetCode(bstackstr.Owner) > 32 Then
                   R$ = INKEY$
                Else
                 If Not Form1.Visible Then newshow Basestack1: MyDoEvents
                  ''  If Not bstackstr.toprinter Then bstackstr.Owner.refresh
                ' so if we need a keystroke to read then we go ton non minimized status.
                R$ = UINKEY$  ' look if we have some keys here
                If R$ = vbNullString Or R$ = Chr(0) + Chr(0) Then
                Do
               ProcTask2 bstackstr
               If Not Form1.KeyPreview Then Form1.KeyPreview = True
                  MyRefresh bstackstr
                R$ = INKEY$  ' (inkey$ has autorepeat...)
                Loop Until R$ <> "" Or LastErNum <> 0
              ''  UINK$ = UINK$ & r$   ' so we send it there
              If LastErNum <> 0 And LenB(R$) = 0 Then R$ = Chr$(0)
                End If
                End If
                IsStr1 = True
                Exit Function
lit29: '    Case "INKEY$", "емйол$"
If GetCode(bstackstr.Owner) > 32 Then
                   R$ = INKEY$
                Else
     If Not releasemouse Then
        If Not Form1.Visible Then newshow Basestack1
            MyDoEvents2 bstackstr.Owner
        Else
         MyRefresh bstackstr
        If Not bstackstr.IamThread Then MyDoEvents
        End If
                R$ = UINKEY$
                If R$ = vbNullString Then
                    R$ = INKEY$
                End If
        End If
                IsStr1 = True
                Exit Function
lit30: '    Case "LETTER$", "цяалла$"
                If bstackstr.soros.Total = 0 Then
                IsStr1 = False
                ElseIf bstackstr.soros.PopType = "S" Then
                R$ = bstackstr.soros.PopStr
                IsStr1 = True
                End If
                Exit Function
lit35: '    Case "калда$"
        Set bstackstr.lastobj = ProcLambda(bstackstr, a$, 0)
        R$ = vbNullString
           If FastSymbol(a$, "(") Then
    If Not CallLambdaASAP(bstackstr, a$, p, True) Then IsStr1 = False: Exit Function
    R$ = CStr(p)
    IsStr1 = True
    Else
    IsStr1 = Not bstackstr.lastobj Is Nothing
    End If
    
    Exit Function
lit31: ' "LAMBDA$"
        Set bstackstr.lastobj = ProcLambda(bstackstr, a$, 1)
        R$ = vbNullString
           If FastSymbol(a$, "(") Then
        p = vbNullString
    If Not CallLambdaASAP(bstackstr, a$, p, True) Then IsStr1 = False: Exit Function
    R$ = CStr(p)
    IsStr1 = True
    Else
    IsStr1 = Not bstackstr.lastobj Is Nothing
    End If
    
    Exit Function
    Exit Function
    
itisavar:
                If GetVar(bstackstr, q$, w) Then
                If MyIsObject(var(w)) Then
                    If TypeOf var(w) Is lambda Then
                        Dim aaa As lambda
                        R$ = vbNullString
                        var(w).CopyTo aaa, var()
                        Set bstackstr.lastobj = aaa
                        Set aaa = Nothing
                    ElseIf TypeOf var(w) Is PropReference Then
                    On Error Resume Next
                        R$ = var(w).Value
                        Set bstackstr.lastobj = var(w).lastobjfinal
                        If Err Then R$ = vbNullString
                    ElseIf TypeOf var(w) Is Group Then
checkit:
                        If var(w).HasValue And Not IsOperator(a$, "::", 2) Then
                        If Len(var(w).Patch) > 0 Then
                        q1$ = var(w).Patch + "." + ChrW(&H1FFF) + "$()"
                        Else
                            q1$ = Left$(q$, Len(q$) - 1) + "." + ChrW(&H1FFF) + "$()"
                            End If
                             If GetSub(q1$, w1) Then
foundprivate:
                                Set nbstack = New basetask
                                Set nbstack.Parent = bstackstr
                                If bstackstr.IamThread Then Set nbstack.Process = bstackstr.Process
                                Set nbstack.Owner = bstackstr.Owner
                                nbstack.OriginalCode = w1
                                nbstack.UseGroupname = sbf(w1).sbgroup
                                nbstack.tpointer = sbf(w1).tpointer
                                nbstack.SetV
                                If GoFunc(nbstack, q1$, ")", R$) Then
                                    If Not nbstack.StaticCollection Is Nothing Then
                                        bstackstr.Parent.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                                    End If
                                    'Set bstackstr.lastobj = nBstack.lastobj
                                    If Mid$(a$, 1, 2) = "=>" Then
                                        If Not nbstack.lastobj Is Nothing Then
                                            If TypeOf nbstack.lastobj Is Group Then
                                                If nbstack.lastobj.IamApointer Then
                                                    Set pppp = BoxGroupVar(nbstack.lastobj)
                                                    Set nbstack = Nothing
                                                    w = 0
                                                    Mid$(a$, 1, 2) = "." + ChrW(3)
                                                End If
                                            GoTo groupstrvalue
                                            End If
                                        End If
                                    End If
                                    
                                    Set nbstack = Nothing
                                    IsStr1 = True
                                        If FastSymbol(a$, "#") Then
                                p = vbNullString
                                Set pp = bstackstr.lastobj
                                If TypeOf pp Is mArray Then
                                ' make it mhandler
                                End If
                                Set bstackstr.lastobj = Nothing
                            IsStr1 = Matrix(bstackstr, a$, pp, p)
                            SwapString2Variant R$, p
                            Exit Function
                        End If
                                Else
                                    IsStr1 = False
                                End If
                            Else
                                w3 = rinstr(q$, ".", Len(var(w).GroupName) + 1)
                               s$ = Left$(q$, Len(q$) - 1)
                                q1$ = Left$(s$, w3) + ChrW(&HFFBF) + Mid$(s$, w3 + 1) + "." + ChrW(&H1FFF) + "$()"
                                  If GetSub(q1$, w1) Then GoTo foundprivate
                                InternalEror
                                IsStr1 = False
                            End If
                        Else
                            R$ = vbNullString
                            Set bstackstr.lastobj = CopyGroupObj(var(w))
                        End If
                    ElseIf TypeOf var(w) Is Document Then
                        R$ = var(w)
                    ElseIf TypeOf var(w) Is Constant Then
                    If var(w).flag Then
                    If Typename(var(w).Value) = "lambda" Then
                    CopyLambda var(w).Value, bstackstr
                    
                    End If
                    Else
                    GoTo there12001
                    End If
                    Else
there12001:
                        On Error Resume Next
                        
                        R$ = var(w).Value
                        If Err > 0 Then
                        Err.Clear
                        R$ = var(w)
                        If Err > 0 Then
                            badread
                            End If
                        End If
                        On Error GoTo 0
                    End If
                Else
                If myIsNull(var(w)) Then
                VarNull
                IsStr1 = False
                      Exit Function
                Else
                    R$ = var(w)
                    End If
                End If
                IsStr1 = True
                
                Else
                  If w = -1 Then
                      R$ = ReadVarStr(bstackstr, q$)
                      IsStr1 = True
                      Exit Function
                End If
                     IsStr1 = False
                     ' MAKE LENGTH EQUAL...
                     If stridbackup.Find(q$, w1) Then GoTo findsecond
                     
                     If w2 >= Len(a$) Then a$ = Left$(q$ + space$(Len(q$)), w2 - Len(a$)) + a$
                    
                             If FindNameForGroup(bstackstr, q$) Then
                             MyErMacroStr a$, "Unknown property  " & q$, "╒ЦМЫСТГ ИДИЭТГТА " & q$
                             Else

                            UnknownVariable1 a$, q$
                            End If
                    End If
                
                Exit Function
    'End Select
    '' no used any more ???
                a$ = q$ & a$
                               
    Exit Function
    
Case 6
    IsStr1 = False
    If usebackup Then
        If Not strfunidbackup.Find(q$, w2) Then
        GoTo isasub
        End If
    Else
        If Not strfunid.Find(q$, w2, bstackstr.strfunnum) Then GoTo itisarrayorfunction
        If w2 < 0 Then GoTo itisarrayorfunction
    End If
findthird:
    On w2 GoTo fstr1, fstr2, fstr3, fstr4, fstr5, fstr6, fstr7, fstr8, fstr9, fstr10, fstr11, fstr12, fstr13, fstr14, fstr15, fstr16, fstr17, fstr18, fstr19, fstr20, fstr21, fstr22, fstr23, fstr24, fstr25, fstr26, fstr27, fstr28, fstr29, fstr30, fstr31, fstr32, fstr33, fstr34, fstr35, fstr36, fstr37, fstr38, fstr39, fstr40, fstr41, fstr42, fstr43, fstr44, fstr45, fstr46, fstr47, fstr48, fstr49, fstr50, fstr51, fstr52, fstr53, fstr54, fstr55, fstr56, fstr57, fstr58, fstr59, fstr60, fstr61, fstr62, fstr63, fstr64, fstr65, fstr66, fstr67, fstr68, fstr69, fstr70
fstr68: ' "амап$(","STRREV$("
    If IsStrExp(bstackstr, a$, q$) Then
        R$ = StrReverse(q$)
    Else
        MissNumExpr
        Exit Function
    End If
    IsStr1 = FastSymbol(a$, ")", True)
    Exit Function
fstr67: '"леяос$(", "PIECE$("
    If IsStrExp(bstackstr, a$, q$) Then
        If FastSymbol(a$, ",") Then
            If IsStrExp(bstackstr, a$, R$) Then
                If FastSymbol(a$, ",") Then
                    If IsExp(bstackstr, a$, p, , True) Then
                        p = Abs(Fix(p))
                        Set usehandler = GETarrayFROMstr(q$, R$)
                        Set pppp = usehandler.objref
                        Set usehandler = Nothing
                        R$ = pppp.item(CLng(p - 1))
                        Set pppp = Nothing
                    Else
                        MissNumExpr
                        Set anything = Nothing
                        Exit Function
                    End If
                Else
                Set usehandler = GETarrayFROMstr(q$, R$)
                
                
                If FastSymbol(a$, ")(", , 2) Then
                    If IsExp(bstackstr, a$, p, , True) Then
                        p = Abs(Fix(p))
                        Set pppp = usehandler.objref
                        R$ = pppp.item(CLng(p))
                        Set pppp = Nothing
                    Else
                        Set bstackstr.lastobj = usehandler
                        Set usehandler = Nothing
                    End If
                Else
                    Set bstackstr.lastobj = usehandler
                    Set usehandler = Nothing
                    
                    
                R$ = vbNullString
                End If
                ' RETURN ARRAY
                End If
            Else
                MissStringExpr
                Exit Function
            End If
        Else
            MissPar
            Exit Function
        End If
    Else
        MissStringExpr
        Exit Function
    End If
    IsStr1 = FastSymbol(a$, ")", True)
    Exit Function
fstr66: '"IF$(","ам("
IsStr1 = False
If IsExp(bstackstr, a$, p, , True) Then IsStr1 = ProcessIfStr(p, bstackstr, a$, R$)
Exit Function
fstr1: '"FORMAT$(", "лояжг$("
    R$ = enthesi(bstackstr, a$)
    IsStr1 = FastSymbol(a$, ")", True)
    Exit Function
fstr2: '"EVAL$(", "ейжя$(", "ейжяасг$("

    If IsExp(bstackstr, a$, p) Then
    If bstackstr.lastobj Is Nothing Then Exit Function
    If TypeOf bstackstr.lastobj Is mHandler Then
    
        Set anything = bstackstr.lastobj
             If bstackstr.lastobj.IamEnum Then
        R$ = bstackstr.lastobj.index_cursor
        
        Set bstackstr.lastobj = Nothing
         IsStr1 = FastSymbol(a$, ")", True)
        Exit Function
        ElseIf Not CheckLastHandlerOrIterator(anything, w) Then
        InternalError
        IsStr1 = False
        Exit Function
        End If
        Set usehandler = anything
        With usehandler
            If .t1 = 1 Then
                If FastSymbol(a$, ",") Then
                    If IsExp(bstackstr, a$, p, , True) Then
                        p = MyRound(p)
                        If Abs(p) < .objref.count Then
                            If p < 0 Then
                            .objref.index = .objref.count + MyRound(p)
                            Else
                            .objref.index = MyRound(p)
                            End If
                            .objref.Done = True
                            R$ = .objref.KeyToString
                        Else
                            MyErMacroStr a$, "Index out of limits", "дЕъЙТГР ЕЙТЭР ОЯъЫМ"
                            IsStr1 = False
                            Exit Function
                        End If
                    Else
                        MissPar
                    End If
                ElseIf .objref.Done Or w >= 0 Then
                    If w >= 0 Then
                        .objref.index = w
                        .objref.Done = True
                    End If
                    If FastSymbol(a$, "!") Then
                        R$ = .objref.KeyToString
                        Set bstackstr.lastobj = Nothing
                    Else
                        If .objref.IsObj Then
                            rValue bstackstr, usehandler.objref.ValueObj
                            R$ = vbNullString
                        Else
                            Set bstackstr.lastobj = Nothing
                            R$ = CStr(.objref.Value)
                        End If
                    End If
                End If
            ElseIf .t1 = 4 Then
                If w = -1 Then .objref.index = .index_start
                R$ = .objref.KeyToString()
                Set bstackstr.lastobj = Nothing
            Else ' IS A MEMBLOCK
                Set bstackstr.lastobj = Nothing
                If FastSymbol(a$, ",") Then
                    If IsExp(bstackstr, a$, p, , True) Then
                        pp = p
                        If FastSymbol(a$, "!") Then
                            If FastPureLabel(a$, s$, , True) Then
                                If .objref.UseStruct Then
                                    If .objref.structref.Find(s$) Then
                                        pp = .objref.structref.sValue
                                        w2 = cUlng(uintnew(.objref.GetPtr(p)) + .objref.structref.Value)
                                        If FastSymbol(a$, "!") Then
                                            If IsExp(bstackstr, a$, p, , True) Then
                                                w2 = cUlng(uintnew(w2) + MyRound(p) * Abs(pp))
                                            End If
                                        End If
                                    Else
                                        MyErMacroStr a$, "Unknown variable " & s$, "╒ЦМЫСТГ ЛЕТАБКГТч " & s$
                                        Exit Function
                                    End If
                                Else
                                    MyErMacroStr a$, "no structure exist", "ДЕМ УПэЯВЕИ ДОЛч"
                                    Exit Function
                                End If
                            Else
                                w2 = .objref.GetBytePtr(p)
                            End If
                        Else
                            w2 = .objref.GetPtr(p)
                        End If
                        If .objref.status = 4 Then MyErMacroStr a$, "Buffer locked, wrong use of pointer", "г дИэЯХЯЫСГ ЙКЕИДЧХГЙЕ, ЙАЙч ВЯчСГ ДЕъЙТГ": Exit Function
                        dd = 2 + (AscW(q$) < 128)
                        If FastSymbol(a$, ",") Then
                            If IsExp(bstackstr, a$, p, , True) Then
                                ' NOW WE KNOW HOW MANY BYTES WE TAKE (ALWAYS BYTES)
                                p = MyRound(p)
                                If .objref.ValidArea(w2, p) Then
                                    If p Mod 2 = 1 Then
                                        R$ = StrConv(String(p, Chr(0)), vbFromUnicode)
                                    Else
                                        R$ = String$((p + 1) \ 2, Chr(0))
                                    End If
                                    CopyBytes CLng(p), StrPtr(R$), w2
                                Else
                                    MyErMacroStr a$, "Buffer is small, can't get so many bytes", "г дИэЯХЯЫСГ ЕъМАИ ЛИЙЯч, ДЕМ ЛПОЯЧ МА ПэЯЫ ТЭСА ЬГЖъА"
                                End If
                            Else
                                MissPar
                                IsStr1 = False
                                Exit Function
                            End If
                        ElseIf IsLabelSymbolNew(a$, "ыс", "AS", dd) Then
                        w2 = .objref.GetBytePtr(p)
                        If IsLabelSymbolNew(a$, "цяалла", "STRING", dd, , , , False) Then
                            CopyBytes 4, VarPtr(w3), w2
                             dd = .objref.GetStringFromOffset(w2, R$)
                            If w3 <> dd Then
                                    MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                                    IsStr1 = False
                                    Exit Function
                            End If

                        ElseIf IsLabelSymbolNew(a$, "ваяайтгяес", "UNICODE", dd, , , , False) Then
                        w2 = .objref.GetBytePtr(p)
                        CopyBytes 4, VarPtr(w3), w2
                        If w3 > &H100000 Then
                        R$ = GetBStrFromBstrPtr(w3)
                        Else
                            MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                            IsStr1 = False
                            Exit Function
                        End If
                        ElseIf IsLabelSymbolNew(a$, "топийо", "LOCALE", dd, , , , False) Then
                        w2 = .objref.GetBytePtr(p)
                        CopyBytes 4, VarPtr(w3), w2
                        If w3 > &H100000 Then
                            If IsExp(bstackstr, a$, p, , True) Then
                                    If GetCodePage(CLng(Fix(p))) = 0 Then
                                        NoValidLocale
                                        Exit Function
                                    End If
                                R$ = Convert3(Convert2(GetBStrFromPtr(w3, True), LCID_DEF), CLng(Fix(p)))
                            Else
                                R$ = Convert3(Convert2(GetBStrFromPtr(w3, True), LCID_DEF), Clid)
                                End If
                            Else
                                MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                                IsStr1 = False
                                Exit Function
                            End If
                        End If
                    Else
                        If .objref.WhatIsBasicItem = vbString Or pp < 0 Then
                            CopyBytes 4, VarPtr(w3), w2
                            dd = .objref.GetStringFromOffset(w2, R$)
                            If w3 <> dd Then
                                If dd = 0 Then
                                    R$ = vbNullString
                                Else
                                    ' extreme change with Fast ! in console or in code using Set Fast !
                                    If extreme Then
                                        ' unsafe may crash
                                        R$ = GetBStrFromBstrPtr(w3)
                                    Else
                                        MyEr "Invalid Pointer for BSTR at Buffer", "лГ щЦЙУЯОР ДЕъЙТГР ЦИА BSTR СТГ дИэХЯЫСГ"
                                        IsStr1 = False
                                        Exit Function
                                    End If
                                    End If
                                End If
                            Else
                                p = .objref.SizeByte - pp * 2
                                If .objref.SizeByte Mod 2 = 1 Then
                                    R$ = StrConv(String$(.objref.SizeByte - pp * 2, Chr(0)), vbFromUnicode)
                                Else
                                    R$ = String$((.objref.SizeByte - pp * 2 + 1) \ 2, Chr(0))
                                End If
                                CopyBytes CLng(p), StrPtr(R$), w2
                            End If
                        End If
                        IsStr1 = FastSymbol(a$, ")") And .objref.status = 0
                        Exit Function
                    Else
                        MissPar
                        IsStr1 = False
                        Exit Function
                    End If
                    
                Else  ' elval$(alfa)  'copy entire block to r$
                    If .objref.SizeByte > 0 And .objref.status = 0 Then
                        'r$ = String$((.objref.SizeByte + 1) \ 2, Chr(0))
                        R$ = StrConv(String$(.objref.SizeByte, Chr(32)), vbFromUnicode)
                        CopyBytes .objref.SizeByte, StrPtr(R$), .objref.GetPtr(0)
                    Else
                        R$ = vbNullString
                    End If
                End If
            End If
            IsStr1 = FastSymbol(a$, ")", True)
            Set anything = Nothing
            Exit Function
        End With
        Set anything = Nothing
    ElseIf Typename(bstackstr.lastobj) = "VarItem" Then
                   IsStr1 = FastSymbol(a$, ")", True)
                Exit Function
ElseIf Not bstackstr.lastpointer Is Nothing Then
getgroup:
If TypeOf bstackstr.lastobj Is Group Then
            If Not bstackstr.lastpointer.IamApointer Then Set bstackstr.lastpointer = bstackstr.lastobj
            Set bstackstr.lastobj = Nothing
            If bstackstr.lastpointer.link.IamFloatGroup Then
            Set pppp = New mArray
            pppp.PushDim 1
            pppp.PushEnd
            pppp.Arr = True
            Set pppp.item(0) = bstackstr.lastpointer
            Set bstackstr.lastpointer = Nothing
            If pppp.item(0).link.HasParameters Then Mid$(a$, 1, 1) = "("
                IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", "", a$, 0) = 1
                R$ = bstackstr.LastValue
                If Not pppp.item(0).link.HasParameters Then IsStr1 = FastSymbol(a$, ")", True)
                    Exit Function
                Else
            If lookOne(a$, ",") Then
                Mid$(a$, 1, 1) = Chr(1)
                If IsStr1(bstackstr, a$, R$) Then
                  IsStr1 = True  '??? something wrong??
                    
                    Exit Function
                End If
            ElseIf IsStr1(bstackstr, Chr$(0) + "$'", R$) Then
            
               ' IsStr1 = True 'FastSymbol(a$, ")", True)
               IsStr1 = FastSymbol(a$, ")", True)
                Set anything = Nothing
                Exit Function
            End If
            End If
            End If
    End If
    MissParam a$
Else
dd = 1
q$ = aheadstatus(a$, False, dd)
q$ = Left$(a$, dd)
Dim myGroup As Group
    If CheckGroupOrPointer(bstackstr, (q$), myGroup, Nothing, (0)) Then
    
            If myGroup Is Nothing Then
            
            ElseIf Not myGroup.IamApointer Then
                a$ = Mid$(a$, dd)
                Set pppp = New mArray
                pppp.PushDim 1
                pppp.PushEnd
                pppp.Arr = True
                Set pppp.item(0) = myGroup
                If myGroup.HasParameters Then
                    If Left$(a$, 1) <> ")" Then
                        Mid$(a$, 1, 1) = "("
                    Else
                        IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", "", "", 0) = 1
                        R$ = bstackstr.LastValue
                        IsStr1 = FastSymbol(a$, ")", True)
                        Exit Function
                    End If
                End If
                IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", "", a$, 0) = 1
                R$ = bstackstr.LastValue
                If Not myGroup.HasParameters Then IsStr1 = FastSymbol(a$, ")", True)
                Exit Function
            Else
            a$ = Mid$(a$, dd + 1)
            GoTo getgroup
            End If
           
    Else
conthere1111:
        If IsStrExp(bstackstr, a$, q$) Then
    
            If FastSymbol(a$, ".") Then
                If lookOne(a$, ")") Then
                    a$ = q$ + a$
                Else
                    a$ = q$ + "." + a$
                End If
                If Not IsStrExp(bstackstr, a$, R$) Then
                    IsStr1 = False: Exit Function
                End If
            ElseIf CheckGroupOrPointer(bstackstr, (q$), myGroup, Nothing, (0)) Then
            
            If myGroup.HasParameters Then
            Mid$(a$, 1, dd + 1) = " "
            s$ = BlockParam(a$)
            
            Mid$(a$, 1, Len(s$)) = space(Len(s$))
                If Right$(q$, 1) <> "$" Then
                If IsStrExp(bstackstr, q$ + "$(" + s$ + ")", R$) Then
                IsStr1 = FastSymbol(a$, ")", True)
                Exit Function
                End If
                Else
                If IsStrExp(bstackstr, q$ + "(" + s$ + ")", R$) Then
                IsStr1 = FastSymbol(a$, ")", True)
                Exit Function
                End If
                End If
            Else
                If IsStrExp(bstackstr, q$ + "$'", R$) Then
                IsStr1 = FastSymbol(a$, ")", True)
                End If
                Exit Function
            End If
           
            Else
            R$ = q$
            IsStr1 = FastSymbol(a$, ")", True)
            Exit Function
            End If
            
         Else
            R$ = vbNullString
        End If
    End If
End If
IsStr1 = FastSymbol(a$, ")", True)
Exit Function
fstr3: ' "STACKTYPE$(", "сыяоутупос$("
w3 = 1
If IsExp(bstackstr, a$, p) Then
If bstackstr.lastobj Is Nothing Then
    Set anything = bstackstr.soros
    w3 = Abs(CLng(Fix(p)))
ElseIf Not CheckStackObj(bstackstr, anything, w3) Then
    MyEr "Not a stack object", "дЕМ ЕъМАИ АМТИЙЕъЛЕМО СЫЯОЩ"
    Exit Function
ElseIf FastSymbol(a$, ",") Then
If IsExp(bstackstr, a$, p, , True) Then
    w3 = Abs(CLng(Fix(p)))
End If
End If
backitem1:
    If anything.Total < w3 Then
 
            MyErMacroStr a$, "Stack item not found at position " & CStr(w3), "дЕМ УПэЯВЕИ СТОИВЕъО СЫЯОЩ СТГ ХщСГ " & CStr(w3)
  
        IsStr1 = False: Exit Function

    ElseIf anything.StackItemType(w3) = "*" Then
    Set bstackstr.lastobj = anything.StackItem(w3)
    Set anything = bstackstr.lastobj
    Set bstackstr.lastobj = Nothing
    CheckDeepAny anything
    R$ = Typename$(anything)
    If R$ = mHdlr Then
            Set usehandler = anything
                Select Case usehandler.t1
                Case 1
                    R$ = "Inventory"
                Case 2
                    R$ = "Buffer"
                Case 3
                        w3 = usehandler.indirect
                        If w3 > -1 And w3 <= var2used Then
                        R$ = Typename(var(w3))
                        Else
                        R$ = Typename(usehandler.objref)
                        End If
                Case Else
                    R$ = Typename(usehandler.objref)
            End Select
            Set usehandler = Nothing
    End If
    IsStr1 = FastSymbol(a$, ")", True)
    ElseIf anything.StackItemType(w3) = "?" Then
    R$ = "(?)"
    ElseIf anything.StackItemType(w3) = "S" Then
    s$ = CStr(anything.StackItem(w3))
    R$ = vbNullString
    Select Case Abs(IsLabel(bstackstr, s$, q2$))
    Case 1, 3, 4
    
    If varhash.ExistKey(q2$) Then
    R$ = "ReferVar"
    ElseIf varhash.ExistKey(q2$ + "(") Then
    R$ = "ReferArray"
    End If
    
    Case 5, 6, 7
   
    End Select
    If R$ = vbNullString Then R$ = "String"
            IsStr1 = FastSymbol(a$, ")", True)
    ElseIf anything.StackItemType(w3) = "N" Then
    
    R$ = "Number"
        IsStr1 = FastSymbol(a$, ")", True)
    ElseIf anything.StackItemType(w3) = "L" Then
    R$ = "Long"
        IsStr1 = FastSymbol(a$, ")", True)
    Else
            MyErMacroStr a$, "Stack item isn't known object at position " & CStr(w3), "To СТОИВЕъО ТОУ СЫЯОЩ ДЕМ ЕъМАИ ЦМЫСТЭ АМТИЙЕъЛЕМО СТГ ХщСГ " & CStr(w3)
  
    IsStr1 = False
    End If
    Exit Function
Else
w3 = 1
Set anything = bstackstr.soros
GoTo backitem1
End If
Exit Function
fstr4: 'STACKITEM$(", "тилгсыяоу$("
w3 = 1
If IsExp(bstackstr, a$, p) Then
If bstackstr.lastobj Is Nothing Then
    Set anything = bstackstr.soros
    w3 = Abs(CLng(Fix(p)))
ElseIf Not CheckStackObj(bstackstr, anything, w3) Then
    MyEr "Not a stack object", "дЕМ ЕъМАИ АМТИЙЕъЛЕМО СЫЯОЩ"
    Exit Function
ElseIf FastSymbol(a$, ",") Then
If IsExp(bstackstr, a$, p, , True) Then
    w3 = Abs(CLng(Fix(p)))
End If
End If
backitem2:
    If anything.Total < w3 Then
 
            MyErMacroStr a$, "Stack item not found at position " & CStr(w3), "дЕМ УПэЯВЕИ ТИЛч СЫЯОЩ СТГ ХщСГ " & CStr(w3)
  
        IsStr1 = False: Exit Function

    ElseIf anything.StackItemType(w3) = "S" Then
    R$ = anything.StackItem(w3)
    IsStr1 = FastSymbol(a$, ")", True)
    Exit Function
    ElseIf anything.StackItemType(w3) = "*" Then
    R = 0
    Set bstackstr.lastobj = anything.StackPickRef(w3).ObjectRef
    IsStr1 = FastSymbol(a$, ")", True)
    Exit Function
    Else
            MyErMacroStr a$, "Stack item isn't string at position " & CStr(w3), "г ТИЛч ТОУ СЫЯОЩ ДЕМ ЕъМАИ ЦЯэЛЛА СТГ ХщСГ " & CStr(w3)
  
    IsStr1 = False
    End If
    Exit Function
Else
w3 = 1
Set anything = bstackstr.soros
GoTo backitem2
End If
fstr5: ' "исвмг$(", "WEAK$("
                R$ = Funcweak(bstackstr, a$)

                 IsStr1 = FastSymbol(a$, ")") And R$ <> ""
             If Not IsStr1 Then
             MyErMacroStr a$, "No variable found or is static", "дЕМ УПэЯВЕИ ЛЕТАБКГТч ч ЕъМАИ СТАТИЙч"
             End If
                Exit Function
fstr6: '"коцос$(", "SPEECH$("
           If IsExp(bstackstr, a$, p, , True) Then
                       
                        R$ = VoiceName(p)
                       
                        End If
                        IsStr1 = FastSymbol(a$, ")")
             
                Exit Function
fstr7: ' "ASK$(", "яыта$("
If IsStrExp(bstackstr, a$, AskText$) Then
If UCase(q$) = "ASK$(" Then
DialogSetupLang 1
Else
DialogSetupLang 0
End If
If AskText$ = vbNullString Then ZeroParam a$: IsStr1 = False: Exit Function
If FastSymbol(a$, ",") Then IsStrExp bstackstr, a$, AskTitle$
    If FastSymbol(a$, ",") Then
        IsStrExp bstackstr, a$, s$ 'AskOk$
        If s$ = "" Then
        AskOk$ = ""
        ElseIf s$ = "*" Then
            AskOk$ = "*" + AskOk$
        Else
            AskOk$ = s$
        End If
    End If
    If FastSymbol(a$, ",") Then
        IsStrExp bstackstr, a$, s$ ' AskCancel$
        If s$ = "" Then
        AskCancel$ = ""
        ElseIf s$ = "*" Then
            AskCancel$ = "*" + AskCancel$
        Else
            AskCancel$ = s$
        End If
    End If

If FastSymbol(a$, ",") Then IsStrExp bstackstr, a$, AskDIB$
If FastSymbol(a$, ",") Then IsStrExp bstackstr, a$, AskStrInput$: AskInput = True

olamazi

If Form1.NeoASK(bstackstr) Then
R$ = AskResponse$
Else
R$ = AskResponse$
End If
AskInput = False
    IsStr1 = FastSymbol(a$, ")", True)
End If
Exit Function
fstr8: ' "LOCALE$(", "топийо$("
         If IsExp(bstackstr, a$, p, , True) Then

    R$ = GetlocaleString(CLng(Fix(p)))
     IsStr1 = FastSymbol(a$, ")")
       End If
       
        Exit Function
 
fstr9: ' "SHORTDIR$(", "лийяос.йатакоцос$("
         If IsStrExp(bstackstr, a$, q$) Then
      

    R$ = GetDosPath(q$)
     IsStr1 = FastSymbol(a$, ")")
       End If
       
        Exit Function
 
fstr10: '"FILTER$(", "жиктяо$("
     If IsStrExp(bstackstr, a$, q$) Then
       If FastSymbol(a$, ",") And IsStrExp(bstackstr, a$, q1$) Then
        R$ = CleanStr(q$, q1$)
        IsStr1 = True
        Else
        MissStringExpr
       End If
       Else
       MissStringExpr
    End If
    If IsStr1 Then If Not FastSymbol(a$, ")") Then IsStr1 = False
    Exit Function
fstr11: '"коцос$(", "SPEECH$("
           If IsExp(bstackstr, a$, p, , True) Then
                       
                        R$ = VoiceName(p)
                       
                        End If
                        IsStr1 = FastSymbol(a$, ")")
             
                Exit Function
   
    
fstr12: ' "аявеио$(", "FILE$("
     If Left$(UCase(q$), 1) = "F" Then
DialogSetupLang 1

Else
DialogSetupLang 0

End If
        If IsStrExp(bstackstr, a$, R$) Then
                       If IsSelectorInUse Then
 IsStr1 = False
MyErMacroStr a$, "File/Folder Selector in Use", "о ЕПИКОЦщАР АЯВЕъЫМ/ЖАЙщКЫМ ЕъМАИ СЕ ВЯчСГ"
Exit Function
End If

If R$ = vbNullString Then
R$ = LoadFileCaption
End If
If FastSymbol(a$, ",") Then
If IsStrExp(bstackstr, a$, q1$) Then
' ok
Else
 IsStr1 = False
MissParam a$
Exit Function
End If
Else
q1$ = "GSB"
End If
                        R$ = mylcasefILE(GetFile(bstackstr, R$, mcd, q1$))
                       Else
                       
                        R$ = mylcasefILE(GetFile(bstackstr, R$, mcd, "GSB"))
                        End If
                        IsStr1 = FastSymbol(a$, ")")
             
                Exit Function
fstr13: ' "PARAM$(", "паяал$("
q1$ = vbNullString
If IsStrExp(bstackstr, a$, q2$) Then

Do
w1 = Len(q2$)
      If IsNumberD2(q2$, p) Then
      If q1$ = vbNullString Then Exit Do Else q1$ = q1$ + "," + Str(p)
      
      Else
             ISSTRINGA q2$, s$
        If q1$ = vbNullString Then
                R$ = s$
        q1$ = ","
        Else
        q1$ = q1$ + ",{" + s$ + "}"
        End If
    End If
    FastSymbol q2$, ","
Loop Until Trim$(q2$) = vbNullString Or w1 = Len(q2$)
End If
    IsStr1 = FastSymbol(a$, ")", True)
    ' FIX THIS a$=....
    a$ = Mid$(q1$, 2) + a$
    Exit Function
fstr14: ' "LAZY$(", "ойм$("
   If FastSymbol(a$, "&") Then
            If Abs(IsLabelBig(bstackstr, a$, q2$, par)) < 5 Then    ''IsLabelDot(HERE$, A$, q2$)

            Exit Function
            End If
          
            par = False
         '   MakeThisSubNum bstackstr, q2$
             If GetSub(q2$ + ")", w1) Then
             If sbf(w1).sbgroup = vbNullString Then
             R$ = sbf(w1).sb + "}"
             Else
                    R$ = sbf(w1).sb + "}" + sbf(w1).sbgroup
                    
                    par = True
                    End If
                    End If
                
            If Not FastSymbol(a$, ")") Then
                    IsStr1 = False
                    MyErMacroStr a$, "No parameters allowed here ()", "дЕМ ЕПИТЯщПОМТАИ ПАЯэЛЕТЯОИ ЕДЧ ()"
                    Exit Function
            End If
            If Left$(R$, 10) = "'11001EDIT" Then
                s$ = GetNextLine(R$) + vbCrLf
            Else
                s$ = vbNullString
            End If
            q2$ = vbNullString
    Else
    par = False
         w = 1
         q1$ = aheadstatus(a$, , w)
         If w > 0 Then q2$ = Left$(a$, w - 1) Else q2$ = "0"
         a$ = Mid$(a$, w)
         While FastSymbol(a$, ",")
            w = 1
            q1$ = aheadstatus(a$, , w)
            If w > 0 Then q2$ = q2$ + "," + Left$(a$, w - 1) Else q2$ = q2$ + ",0"
            a$ = Mid$(a$, w)
         Wend
         
         R$ = "=" + q2$: q2$ = "}" + bstackstr.UseGroupname
         s$ = vbNullString
   End If
 
If Trim$(R$ + q2$) <> "" Then
   ' r$ = "{тлгла " + Chr(34) + HERE$ & Chr(34) + vbCrLf + r$ + q2$
          If par Then
    
            R$ = "{" + s$ + R$ + q2$
    
       Else
   If q$ = "ойм$(" Then

   If here$ = vbNullString Then
    R$ = "{" + s$ + "тлгла {}" + vbCrLf + R$ + q2$
   Else
    R$ = "{" + s$ + "тлгла " + here$ + vbCrLf + R$ + q2$
    End If
    Else
    If here$ = vbNullString Then
    R$ = "{" + s$ + "MODULE {}" + vbCrLf + R$ + q2$
   Else
    R$ = "{" + s$ + "MODULE " + here$ + vbCrLf + R$ + q2$
    End If
    End If
    End If
    Else
    R$ = "{}"
    End If
     IsStr1 = FastSymbol(a$, ")")
       
       
        Exit Function
fstr15: ' "INPUT$(", "еисацыцг$("
      IsSymbol3 a$, "#"  ' drop it
    If IsExp(bstackstr, a$, p, , True) Then
    p = Int(Abs(p))
    dn = Fkind(p)
    If dn = FnoUse Or dn = Foutput Or dn = Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": IsStr1 = False: Exit Function
    dn = Fstep(p)
    If uni(p) And dn = 1 Then dn = 2
    
    If FastSymbol(a$, ",") Then
    If Not IsExp(bstackstr, a$, pp, , True) Then
    MyErMacroStr a$, "missing parameter for length in chars", "КЕъПЕИ ПАЯэЛЕТЯОР ЦИА ЛчЙОР СЕ ВАЯАЙТчЯЕР"
    IsStr1 = False: Exit Function
    End If
    End If
    On Error Resume Next
    If dn = 2 Then
        dn = Module10.ReadFileHandler(CLng(p))
        If dn = 0 Then IsStr1 = False: Exit Function
        Module10.FileReadString dn, R$, CLng(MyRound(Int(pp * 2)))
        If FastSymbol(a$, ",") Then
            SwapStrings R$, q$
            GoTo JUMP001
        End If
    Else
        dn = Module10.ReadFileHandler(CLng(p))
        If dn = 0 Then IsStr1 = False: Exit Function
        Module10.FileReadString dn, q$, CLng(Abs(Int(pp / 2)))
        If FastSymbol(a$, ",") Then
JUMP001:
            If IsExp(bstackstr, a$, pp, , True) Then
                    If pp < 0 Then
                    R$ = utf8decode(q$)
                    
                    Else
                    If GetCodePage(CLng(Fix(pp))) = 0 Then
                        NoValidLocale
                        Exit Function
                    End If
                    R$ = StrConv(q$, vbUnicode, CLng(Fix(pp)))
                    End If
            Else
                MissPar
                Exit Function
            End If
        Else
        R$ = StrConv(q$, vbUnicode, Clid)
        End If
    End If
    End If
    If Err.Number = 0 Then
    IsStr1 = FastSymbol(a$, ")")
    End If
    On Error GoTo 0
     Exit Function
fstr16: '"MEMBER.TYPE$(", "лекоус.тупос$("
     If Abs(IsLabel(bstackstr, a$, s$)) = 1 Then
            If getvar2(bstackstr, s$, w1) Then
                If Typename(var(w1)) = mgroup Then
                If FastSymbol(a$, ",") Then
                If IsExp(bstackstr, a$, p, , True) Then
                p = Fix(p)
                Set ms = var(w1).PrepareSoros(var(), "")
                If p < 1 Or p > ms.Total Then
                OutOfLimit
                Exit Function
                
                End If
                s$ = ms.StackItem(CLng(p))
                If Left$(s$, 1) = "*" Then s$ = Mid$(s$, 2)
                q1$ = Split(s$)(1)
                s$ = Split(s$)(0)
                If Right$(s$, 1) = "(" Then
                    If here$ = vbNullString Or var(w1).IamGlobal Then
                    If varhash.ExistKey(s$) Then
                        If Right$(s$, 3) = "$()" Then
                            R$ = "Array String"
                        ElseIf Right$(s$, 3) = "%()" Then
                            R$ = "Array Integer"
                        Else
                             R$ = "Array Double"
                            
                        End If
                    End If
                    Else
                    If varhash.ExistKey(here$ + "." + s$) Then
                        If Right$(s$, 3) = "$()" Then
                            R$ = "Array String"
                        ElseIf Right$(s$, 3) = "%()" Then
                            R$ = "Array Integer"
                        Else
                             R$ = "Array Double"
                            
                        End If
                    End If
                    End If
                Else
                w3 = val(q1$)
                
                    R$ = Typename(var(w3))
                If R$ = mHdlr Then
                        Set usehandler = var(w3)
                       Select Case usehandler.t1
                       Case 1
                           R$ = "Inventory"
                       Case 2
                           R$ = "Buffer"
                       Case Else
                         R$ = Typename(usehandler.objref)
                       End Select
                     End If
                    End If
                Else
                MissNumExpr
                Exit Function
                End If
                Else
                MissNumExpr
                Exit Function
                End If
                Else

                MissingGroup
                Exit Function
                End If
 
                IsStr1 = FastSymbol(a$, ")", True)
                Exit Function
            Else
        
            Nosuchvariable s$
            End If
        Else
         MissingGroup
       End If
       Exit Function
fstr17: ' "MEMBER$(", "лекос$("
     If Abs(IsLabel(bstackstr, a$, s$)) = 1 Then
            If getvar2(bstackstr, s$, w1) Then   '' we need s$ if this is a "THIS"
                  If Typename(var(w1)) = mgroup Then
                If FastSymbol(a$, ",") Then
                If IsExp(bstackstr, a$, p, , True) Then
                    p = Fix(p)
                If var(w1).IamGlobal Then
                    Set ms = var(w1).PrepareSoros(var(), Left$(s$, Len(s$) - Len(var(w1).GroupName) + 1))
                ElseIf Len(here$) > 0 Then
                    If Len(bstackstr.UseGroupname) > 0 Then
                        Set ms = var(w1).PrepareSoros(var(), bstackstr.UseGroupname)
                    Else

                        s$ = var(w1).Patch
                        Set ms = var(w1).PrepareSoros(var(), Left$(s$, Len(s$) - Len(var(w1).GroupName) + 1))
                    End If
                Else

                    Set ms = var(w1).PrepareSoros(var(), Left$(s$, Len(s$) - Len(var(w1).GroupName) + 1))
                End If
                If p < 1 Or p > ms.Total Then
                OutOfLimit
                Exit Function
                
                End If
                 s$ = ms.StackItem(CLng(p))
                If Left$(s$, 1) = "*" Then s$ = Mid$(s$, 2)
                         R$ = Split(s$)(0)
                 If InStr(R$, ChrW(&HFFBF)) > 0 Then R$ = Replace$(R$, ChrW(&HFFBF), "")
                Else
                MissNumExpr
                Exit Function
                End If
                Else
                MissNumExpr
                Exit Function
                End If
                Else

                MissingGroup
                Exit Function
                End If
 
                IsStr1 = FastSymbol(a$, ")", True)
                Exit Function
            Else
        
            Nosuchvariable s$
            End If
        Else
         MissingGroup
       End If
       Exit Function
    
    
fstr18: '"PIPENAME$(", "аукос$("
                If IsStrExp(bstackstr, a$, R$) Then
                        R$ = validpipename(R$)
                ElseIf IsExp(bstackstr, a$, p, , True) Then
                        R$ = validpipename("M" & Trim$(Str$(p)))
                End If
                IsStr1 = FastSymbol(a$, ")")
                Exit Function
fstr19: '"DRIVE$("
                If IsStrExp(bstackstr, a$, R$) Then
                        R$ = DriveTypee(Left$(R$, 3))
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
                Exit Function
fstr20: '"FILE.TYPE$(", "тупос.аявеиоу$("
                If IsStrExp(bstackstr, a$, R$) Then
                        R$ = ExtractType(R$)
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
                Exit Function
fstr21: ' "FILE.NAME.ONLY$(", "омола.аявеиоу.ломо$("
                If IsStrExp(bstackstr, a$, R$) Then
                        R$ = ExtractNameOnly(R$, True)
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
                Exit Function
fstr22: ' "FILE.NAME$(", "омола.аявеиоу$("
                If IsStrExp(bstackstr, a$, R$) Then
                        R$ = ExtractName(R$, True)
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
                Exit Function
fstr23: ' "FILE.PATH$(", "топос.аявеиоу$("
                If IsStrExp(bstackstr, a$, R$) Then
                        R$ = ExtractPath(R$)  ' ДъМЕИ ВЫЯъР МА ЙОИТэЕИ АМ УПэЯВЕИ!
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
                Exit Function
fstr24: ' "одгцос$("
                If IsStrExp(bstackstr, a$, R$) Then
                        R$ = DriveType(Left$(R$, 3))  'greek response
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
                Exit Function
fstr25: '"титкос.аявеиоу$(", "FILE.TITLE$("
                If IsStrExp(bstackstr, a$, R$) Then
                        If R$ <> "" Then R$ = FileNameType(R$)
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
fstr26: '"ежаялоцг.аявеиоу$(", "FILE.APP$("
                If IsStrExp(bstackstr, a$, R$) Then
                        If R$ <> "" Then R$ = myRegister(R$)
                        IsStr1 = FastSymbol(a$, ")")
                        Exit Function
                End If
fstr27: '"HIDE$(", "йяужо$("
                If IsStrExp(bstackstr, a$, R$) Then
                    If FastSymbol(a$, ",") Then
                        If IsStrExp(bstackstr, a$, q$) Then
                            If FastSymbol(a$, ",") Then
                                If IsExp(bstackstr, a$, p, , True) Then
                                    R$ = mycoder.encryptline(R$, q$, CLng(Fix(p)))
                                    IsStr1 = FastSymbol(a$, ")")
                                    Exit Function
                                End If
                            End If
                        End If
                    End If
                End If
                Exit Function
fstr28: ' "LEFTPART$(", "аяистеяолеяос$("
    IsStr1 = False
    If IsStrExp(bstackstr, a$, s$) Then
        If FastSymbol(a$, ",") Then
            If IsStrExp(bstackstr, a$, q$) Then
                R$ = GetStrUntil(q$, s$)
                IsStr1 = FastSymbol(a$, ")")
            ElseIf IsExp(bstackstr, a$, p, , True) Then
                R$ = GetStrUntil(ChrW$(CLng(p)), s$)
                IsStr1 = FastSymbol(a$, ")")
            End If
        End If
    End If
    Exit Function
fstr29: '"RIGHTPART$(", "денилеяос$("
    IsStr1 = False
    If IsStrExp(bstackstr, a$, R$) Then
        If FastSymbol(a$, ",") Then
            If IsStrExp(bstackstr, a$, q$) Then
                DropLeft q$, R$
                IsStr1 = FastSymbol(a$, ")")
            ElseIf IsExp(bstackstr, a$, p, , True) Then
                DropLeft ChrW$(CLng(p)), R$
                IsStr1 = FastSymbol(a$, ")")
            End If
        End If
    End If
    Exit Function
fstr30: ' "ARRAY$(", "пимайас$("
    
    If IsStrExp(bstackstr, a$, s$) Then
        If bstackstr.lastobj Is Nothing Then
            If Right$("!!" & s$, 2) = "()" Then
                Mid$(s$, Len(s$), 1) = " "
                s$ = RTrim$(s$)
            Else
                w = InStr("!" & s$, "(") - 1
                If w > 0 And w <= Len(s$) Then
                    s$ = Left$(s$, w)
                ElseIf neoGetArray(bstackstr, s$, pppp) Then
                GoTo check1236789
                Else
                s$ = s$ + "("
                End If
                                
            End If
            If neoGetArray(bstackstr, s$, pppp) Then
check1236789:
                If Not pppp.Arr Then NotArray: Exit Function
                If FastSymbol(a$, ",") Then
                    IsStr1 = NeoGetArrayItem(pppp, bstackstr, s$, w, a$)
                Else
                    IsStr1 = FastSymbol(a$, ")", True)
                    w = 0
                    'w = pppp.index
                End If
check999100:
                If Not pppp.IsEmpty Then
                    If MyIsObject(pppp.item(w)) Then
                        If TypeOf pppp.itemObject(w) Is Document Then
                            R$ = pppp.item(w)
                            Set bstackstr.lastobj = Nothing
                        Else
                            Set bstackstr.lastobj = pppp.item(w)
                           R$ = vbNullString
                        End If
                        
                    Else
                        R$ = CStr(pppp.item(w))
                        Set bstackstr.lastobj = Nothing
                    End If
                    
                Else
                    Set bstackstr.lastobj = Nothing
                    MyEr "Empty Array", "╒ДЕИОР пъМАЙАР"
                End If
                
            Else
                Set bstackstr.lastobj = Nothing
                NotArray
            End If
            
            Exit Function
        ElseIf TypeOf bstackstr.lastobj Is mArray Then
                Set pppp = bstackstr.lastobj
                GoTo check1236789
        Else
            SyntaxError
            Set bstackstr.lastobj = Nothing
        End If
    ElseIf IsExp(bstackstr, a$, p) Then
        If Not bstackstr.lastobj Is Nothing Then
            If TypeOf bstackstr.lastobj Is mHandler Then
            Set usehandler = bstackstr.lastobj
            
                If usehandler.indirect >= 0 Then
               If Typename(var(usehandler.indirect)) = myArray Then
                    Set pppp = var(usehandler.indirect)
                    GoTo check1236789
                    Else
     
                    End If
                    
                ElseIf TypeOf usehandler.objref Is mArray Then
                
                
                    Set pppp = usehandler.objref
                    If bstackstr.lastobj.UseIterator Then
                        If Not pppp.Arr Then NotArray: Exit Function
                        If FastSymbol(a$, ",") Then
                            IsStr1 = IsExp(bstackstr, a$, R, , True)
                            IsStr1 = FastSymbol(a$, ")", True)
                            w = R
                        Else
                            IsStr1 = FastSymbol(a$, ")", True)
                            w = pppp.index
                        End If
                        If Not IsStr1 Then Exit Function
                    GoTo check999100
                    Else
                    GoTo check1236789
                    End If
                ElseIf TypeOf usehandler.objref Is mStiva Then
                Set anything = usehandler.objref
                Set bstackstr.lastobj = Nothing
                    If FastSymbol(a$, ",") Then
                    If IsExp(bstackstr, a$, p, , True) Then
                    Set bstackstr.lastobj = anything.ExportArray(CLng(MyRound(p)))
                    
                    End If
                    Else
                        Set bstackstr.lastobj = anything.ExportArray(anything.count)
                        
                    End If
                    Set anything = Nothing
                    IsStr1 = FastSymbol(a$, ")", True)
                    
                    Exit Function
                Else
                 Set bstackstr.lastobj = Nothing
                NotArray
                End If
            ElseIf TypeOf bstackstr.lastobj Is mArray Then
                Set pppp = bstackstr.lastobj
                GoTo check1236789
            End If
        End If
    Else
      SyntaxError
    Set bstackstr.lastobj = Nothing
      IsStr1 = False
    End If
    Exit Function
fstr31: '"TYPE$(", "тупос$("
    w1 = Abs(IsLabel(bstackstr, a$, s$))
    If w1 > 4 Then
    If neoGetArray(bstackstr, s$, pppp) Then
    w2 = 0
                    If Not NeoGetArrayItem(pppp, bstackstr, s$, w2, a$) Then
                        If Not pppp.Arr Then
                            If Typename(pppp.GroupRef) = mHdlr Then
                                Set p = pppp.GroupRef
                                IsStr1 = CheckItemType(bstackstr, p, a$, R$)
                                Exit Function
                            End If
                        End If
                        
                        If FastSymbol(a$, ")") Then
                            If Not pppp Is Nothing Then
                                R$ = myArray
                                IsStr1 = FastSymbol(a$, ")")
                            End If
                        Else
                           NotExistArray
                        End If
                           
                            Exit Function
                        End If
                        If pppp.Arr Then
                            If pppp.ItemIsObject(w2) Then
                                Set p = pppp.item(w2)
                                IsStr1 = CheckItemType(bstackstr, p, a$, R$)
                                Exit Function
                            Else
                                R$ = pppp.ItemType(w2)
                            End If
                    Else
                        If Typename(pppp.GroupRef) = mHdlr Then
                            Set p = pppp.GroupRef
                        
                            IsStr1 = CheckItemType(bstackstr, p, a$, R$, True)
                            Exit Function
                        
                    
                    Else
                    R$ = Typename(pppp.GroupRef)
                   
                    End If
                    
                     
                    End If
                  If R$ = "VarItem" Then R$ = "Optional"
                    IsStr1 = FastSymbol(a$, ")")
    Else
    Nosuchvariable s$
    End If
    ElseIf w1 > 0 Then
        If GetVar(bstackstr, s$, w1) Then
        IsStr1 = CheckItemType(bstackstr, var(w1), a$, R$)
        Exit Function
                    
    ElseIf bstackstr.ExistVar2(s$) Then
                    bstackstr.ReadVar s$, p
                     IsStr1 = CheckItemType(bstackstr, p, a$, R$)
                                Exit Function
    Else
        Nosuchvariable s$
    End If
    ElseIf IsStrExp(bstackstr, a$, s$) Then
                R$ = strProgIDfromSrting(s$)
                    IsStr1 = FastSymbol(a$, ")")
    
    Else
    
    SyntaxError
    End If
    Exit Function
fstr32: ' "PARAGRAPH$(", "паяацяажос$("
 
        w1 = Abs(IsLabel(bstackstr, a$, s$))
        If w1 = 3 Then
            If GetVar(bstackstr, s$, w1) Then
                    ' GET PARAGRAPH ORDER NUMBER
                    If Not FastSymbol(a$, ",") Then
                        MissParam a$
                        Exit Function
                    End If
                    If FastSymbol(a$, "(") Then
                    
                    w3 = Abs(IsLabel(bstackstr, a$, s$))
                    If w3 = 1 Or w3 = 4 Then
                    If Not GetVar(bstackstr, s$, w3) Then Nosuchvariable s$: Exit Function
                    If Not FastSymbol(a$, ")") Then SyntaxError: Exit Function
                    dd = 1
                    Else
                    MissingnumVar
                     Exit Function
                    End If
                    ElseIf Not IsExp(bstackstr, a$, p, , True) Then
                      MissNumExpr
                      Exit Function
                    End If
                        If Typename(var(w1)) = doc Then
                        R$ = var(w1).TextParagraphOrder(CLng(Fix(p)))
                        If FastSymbol(a$, ",") Then
                            If Not IsExp(bstackstr, a$, pp, , True) Then MissNumExpr: Exit Function
                            If pp < 0 Then
                                If dd = 1 Then
                                        dd = var(w3)
                                        p = dd
                                             If var(w1).InvalidPara(CLng(p)) Then
                                        MissingDocRef
                                        Exit Function
                                        End If
                                         If var(w1).BackMove Then
                                        var(w3) = var(w1).BackStep(dd)
                                        Else
                                        var(w3) = var(w1).Advance(dd)
                                        End If
                                 
                                        
                                        R$ = var(w1).RemoveDocParaIndex(CLng(p))
                                Else
                                        R$ = var(w1).TextParagraphOrderRemove(CLng(p))
                                End If
                            Else
                                 If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                      If var(w1).InvalidPara(dd) Then
                                        MissingDocRef
                                        Exit Function
                                        End If
                                            If var(w1).BackMove Then
                                            var(w3) = var(w1).BackStep(dd)
                                            Else
                                            var(w3) = var(w1).Advance(dd)
                                            End If
                                            
                                                R$ = Mid$(var(w1).TextParagraph(CLng(p)), CLng(pp))
                                    Else
                                
                                R$ = Mid$(var(w1).TextParagraphOrder(CLng(Fix(p))), CLng(pp))
                                End If
                            End If
                        Else
                                        If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                               If var(w1).InvalidPara(dd) Then
                                        MissingDocRef
                                        Exit Function
                                        End If
                                            If var(w1).BackMove Then
                                            var(w3) = var(w1).BackStep(dd)
                                            Else
                                            var(w3) = var(w1).Advance(dd)
                                            End If
                                                R$ = var(w1).TextParagraph(CLng(p))
                                    Else
                        
                        R$ = var(w1).TextParagraphOrder(CLng(Fix(p)))
                        End If
                        End If
                        Else
                            MissingDoc
                            Exit Function
                        End If
                    
                    IsStr1 = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    Exit Function
            End If
        ElseIf w1 = 6 Then
            If neoGetArray(bstackstr, s$, pppp) Then
                    If Not NeoGetArrayItem(pppp, bstackstr, s$, w2, a$) Then Exit Function
                    If Not FastSymbol(a$, ",") Then
                    MissParam a$
                    Exit Function
                    End If
                    
                    If FastSymbol(a$, "(") Then
                    
                    w3 = Abs(IsLabel(bstackstr, a$, s$))
                    If w3 = 1 Or w3 = 4 Then
                    If Not GetVar(bstackstr, s$, w3) Then Nosuchvariable s$: Exit Function
                     If Not FastSymbol(a$, ")") Then SyntaxError: Exit Function
                    dd = 1
                    Else
                    MissingnumVar
                     Exit Function
                    End If
                    ElseIf Not IsExp(bstackstr, a$, p, , True) Then
                      MissNumExpr
                      Exit Function
                    End If
                        If pppp.ItemType(w2) = doc Then
                         If FastSymbol(a$, ",") Then
                            If Not IsExp(bstackstr, a$, pp, , True) Then MissNumExpr: Exit Function
                                If pp < 0 Then
                                        If dd = 1 Then
                                                dd = var(w3)
                                                p = dd
                                                   If pppp.item(w2).InvalidPara(dd) Then
                                                    MissingDocRef
                                                    Exit Function
                                                    End If
                                                If pppp.item(w2).BackMove Then
                                                var(w3) = pppp.item(w2).BackStep(dd)
                                                Else
                                                var(w3) = pppp.item(w2).Advance(dd)
                                                End If
                                                R$ = pppp.item(w2).RemoveDocParaIndex(CLng(p))
                                        Else
                                                R$ = pppp.item(w2).TextParagraphOrderRemove(CLng(Fix(p)))
                                        End If
                                Else
                                   If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                                 If pppp.item(w2).InvalidPara(dd) Then
                                                    MissingDocRef
                                                    Exit Function
                                                    End If
                                            If pppp.item(w2).BackMove Then
                                            var(w3) = pppp.item(w2).BackStep(dd)
                                            Else
                                            var(w3) = pppp.item(w2).Advance(dd)
                                            End If
                                        R$ = Mid$(pppp.item(w2).TextParagraph(CLng(p)), CLng(pp))
                                    Else
                                R$ = Mid$(pppp.item(w2).TextParagraphOrder(CLng(Fix(p))), CLng(pp))
                                End If
                                End If
                            Else
                            If dd = 1 Then
                                    dd = var(w3)
                                            p = dd
                                                 If pppp.item(w2).InvalidPara(dd) Then
                                                    MissingDocRef
                                                    Exit Function
                                                    End If
                                            If pppp.item(w2).BackMove Then
                                            var(w3) = pppp.item(w2).BackStep(dd)
                                            Else
                                            var(w3) = pppp.item(w2).Advance(dd)
                                            End If
                                R$ = pppp.item(w2).TextParagraph(CLng(p))
                                            Else
                                R$ = pppp.item(w2).TextParagraphOrder(CLng(Fix(p)))
                                End If
                            End If
                        Else
                            MissingDoc
                            Exit Function
                        End If
                    
                    IsStr1 = FastSymbol(a$, ")", True)
            Else
                    MissParam a$
            End If
        End If
    Exit Function
fstr33: '"UNION.DATA$(", "емысг.сеияас$("
  
  Do
  If IsStrExp(bstackstr, a$, s) Then
  ElseIf IsExp(bstackstr, a$, p, , True) Then
  w3 = UINT(p)
    If w3 >= &H10000 And w3 <= &H10FFFF Then
        w3 = w3 - &H10000
        s$ = ChrW(UINT(w3 \ &H400& + &HD800&)) + ChrW(UINT((w3 And &H3FF&) + &HDC00&))
        Else
    s$ = ChrW$(w3)
    End If
  Else
  s = ChrW(0)
  End If
  R$ = R$ + s
  
  Loop Until Not FastSymbol(a$, ",") Or a$ = vbNullString

    IsStr1 = FastSymbol(a$, ")", True)

    Exit Function
fstr34: ' "MAX.DATA$(", "лецако.сеияас$("

  If IsStrExp(bstackstr, a$, R$) Then
  
  Do While FastSymbol(a$, ",")
  If Not IsStrExp(bstackstr, a$, s) Then MissStringExpr: Exit Function
  If R$ < s Then R$ = s
  
  Loop

    IsStr1 = FastSymbol(a$, ")", True)
        Else
      MissStringExpr
        End If
    Exit Function
fstr35: ' "MIN.DATA$(", "лийяо.сеияас$("
 IsStr1 = False
  If IsStrExp(bstackstr, a$, R$) Then
  
  Do While FastSymbol(a$, ",")
  If Not IsStrExp(bstackstr, a$, s) Then MissStringExpr: Exit Function
  If R$ > s Then R$ = s
  
  Loop

    IsStr1 = FastSymbol(a$, ")", True)
        Else
      MissStringExpr
        End If
    Exit Function
fstr36: ' "FUNCTION$(", "сумаятгсг$("
    If IsStrExp(bstackstr, a$, s$) Then
        If IsSymbolBracket(s$) Then
            PushStage bstackstr, False
            GlobalSub "A$()", block(s$)
            IsSymbol3 a$, ","
            ' fix this a$=...
              a$ = "A$(*" & a$
            IsStr1 = IsStrExp(bstackstr, a$, R$)
            
            PopStage bstackstr
            Else
            If lookOne(a$, ".") Then
                dd = 1
                      q1$ = aheadstatus(a$, , dd)
                s$ = s$ + Left$(a$, dd - 1)
                a$ = Mid$(a$, dd)
            End If
                 If FastSymbol(a$, ",") Then
                End If
                
              
                    If Right$(s$, 1) = ")" Then
                       ' fix this a$=...
                        a$ = Left$(s$, Len(s$) - 1) & a$
                   ElseIf InStr(s$, ").") > 0 Then     ''''''Or A$ Like ".*"
                   FastSymbol a$, ")"
                      ' fix this a$=...
                     a$ = s$ & a$
                    Else
               If Right$("!" & s$, 1) = "$" Then
                  ' fix this a$=...
                    a$ = s$ & "(*" & a$  '' w1 put a @ from 102
                Else
                  ' fix this a$=...
                 a$ = s$ & "$(" & a$
                    End If
                End If
        IsStr1 = IsStrExp(bstackstr, a$, R$)
     End If
     End If
    Exit Function
fstr37: '"HEX$(", "дейаен$("
    If IsExp(bstackstr, a$, p, , True) Then
    R$ = PACKLNGUnsign$(p)
    If LastErNum1 <> 0 Or Len(R$) = 0 Then IsStr1 = False: Exit Function
    If FastSymbol(a$, ",") Then
    If Not IsExp(bstackstr, a$, p, , True) Then
      MyErMacroStr a$, "missing parameter 1 to 4 (bytes)", "КЕъПЕИ ПАЯэЛЕТЯОР 1 щЫР 4"
        IsStr1 = False: Exit Function
    ElseIf MyRound(p) < 1 Or MyRound(p) > 4 Then
         MyErMacroStr a$, "parameter from 1 to 4 (bytes)", "ПАЯэЛЕТЯОР АПЭ 1 щЫР 4 ДУАДИЙэ ЬГЖъА (bytes)"
        IsStr1 = False: Exit Function
Else
    R$ = Right$(R$, p * 2)
    End If
    End If
     IsStr1 = True
                         If Not FastSymbol(a$, ")") Then IsStr1 = False
                        Exit Function
    End If
fstr38: '"SHOW$(", "жамеяо$("
    If IsStrExp(bstackstr, a$, R$) Then
        If FastSymbol(a$, ",") Then
            If IsStrExp(bstackstr, a$, q$) Then
                If FastSymbol(a$, ",") Then
                    If IsExp(bstackstr, a$, p, , True) Then
                        R$ = mycoder.decryptline(R$, q$, CLng(Fix(p)))
                        IsStr1 = True
                         If Not FastSymbol(a$, ")") Then IsStr1 = False
                        Exit Function
                    End If
                End If
            End If
        End If
    End If
    Exit Function
fstr39: '"MENU$(", "епикоцг$(", "епикоцес$("
    If IsExp(bstackstr, a$, p, , True) Then
    p = Abs(CLng(Fix(p)))
    With Form1.List1
        If p > 0 And .listcount >= p Then
            R$ = .list(CLng(p) - 1)
            IsStr1 = True
            Else
            MyErMacroStr a$, "index out of limits", "О ДЕъЙТГР ЕъМАИ ЕЙТЭР ОЯъЫМ"
        End If
    End With
    Else
    ' return a copy
    Set pppp = New mArray: pppp.PushDim (Form1.List1.listcount): pppp.PushEnd: pppp.Arr = True
    For w2 = 0 To Form1.List1.listcount - 1
    pppp.item(w2) = Form1.List1.list(w2)
    Next w2
               Set usehandler = New mHandler
                usehandler.t1 = 3
                Set usehandler.objref = pppp
                Set bstackstr.lastobj = usehandler
                Set pppp = Nothing
                Set usehandler = Nothing
                R$ = vbNullString
                IsStr1 = True
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False
    Exit Function
fstr40: '"REPLACE$(", "аккацг$("
    
    If IsStrExp(bstackstr, a$, q$) Then
       If FastSymbol(a$, ",") And IsStrExp(bstackstr, a$, q1$) Then
            If FastSymbol(a$, ",") And IsStrExp(bstackstr, a$, q2$) Then
     IsStr1 = True
      If FastSymbol(a$, ",") And IsExp(bstackstr, a$, p, , True) Then
            p = Int(p)
            If p < 0 Then p = 1
        If FastSymbol(a$, ",") And IsExp(bstackstr, a$, pp, , True) Then
        pp = Abs(Int(pp))
        If p > 1 Then
        R$ = Left$(q2$, p - 1) + Replace$(q2$, q$, q1$, p, pp)
        Else
        R$ = Replace$(q2$, q$, q1$, p, pp)
        End If
        Else
        If p = 1 Then
            R$ = Replace$(q2$, q$, q1$, p)
            
        Else
            R$ = Left$(q2$, p - 1) + Replace$(q2$, q$, q1$, p)
        End If
      End If
      Else
    R$ = Replace$(q2$, q$, q1$)
    End If
       End If
       End If
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False
    Exit Function
fstr41: '"PATH$(", "топос$("
      If IsExp(bstackstr, a$, p, , True) Then
    IsStr1 = True
    R$ = GetSpecialfolder(CLng(Fix(p)))
    AddDirSep R$
    ElseIf IsStrExp(bstackstr, a$, q$) Then
     IsStr1 = True
     
    R$ = ExtractPath$(q$)
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False
    Exit Function
fstr42: '"UCASE$(", "йеж$("
    If IsStrExp(bstackstr, a$, R$) Then
      IsStr1 = True
      If FastSymbol(a$, ",") And IsExp(bstackstr, a$, p, , True) Then
            If Fix(p) <> 0 Then
            If GetCodePage(CLng(Fix(p))) = 0 Then
                NoValidLocale
                Exit Function
            End If
            R$ = kUpper(Convert3(R$, CLng(Fix(p))), Fix(p))
            Else
            R$ = kUpper(Convert3(R$, CLng(Clid)), CDbl(Clid))
            End If
      Else
      myUcase2 R$
     End If
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False
    Exit Function
fstr43: '"LCASE$(", "пеф$("
     If IsStrExp(bstackstr, a$, R$) Then
   IsStr1 = True
      If FastSymbol(a$, ",") And IsExp(bstackstr, a$, p, , True) Then
      If Fix(p) <> 0 Then
        If GetCodePage(CLng(Fix(p))) = 0 Then
            NoValidLocale
            Exit Function
        End If
      R$ = klower(Convert3(R$, CLng(Fix(p))), Fix(p))
      Else
      R$ = klower(Convert3(R$, CLng(Clid)), CDbl(Clid))
      End If
      Else
      myLcase2 R$
     
     End If
    
    End If
    
    
    If Not FastSymbol(a$, ")") Then IsStr1 = False
    Exit Function
fstr44: '"STRING$(", "епам$("
        dd = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, a$, q$) Then
    If FastSymbol(a$, ",") Then
        If IsExp(bstackstr, a$, p, , True) Then
        p = Int(Abs(p))
        If LenB(q$) > 0 Then
            On Error Resume Next
            If LenB(q$) Mod 2 = 0 Then
                dd = Len(q$)
                    R$ = space$(p * dd)
                    
                    While p > 0
                        p = p - 1
                        Mid$(R$, p * dd + 1, dd) = q$
                    Wend

            Else
                While p > 0
                R$ = R$ & q$
                p = p - 1
                Wend
            End If
            End If
            IsStr1 = True
        End If
     Else
        If IsLabelSymbolNew(a$, "ыс", "AS", dd) Then
            If IsSymbol(a$, "JSON", 4) Then
                R$ = StringToEscapeStr(q$, True)
            ElseIf IsSymbol(a$, "ENCODE64", 8) Then
                If FastSymbol(a$, ",") Then
                    If IsExp(bstackstr, a$, p, , True) Then
                        p = Int(Abs(p))
                        If p = 0 Then
                        If FastSymbol(a$, ",") Then
                            If IsExp(bstackstr, a$, p, , True) Then
                                R$ = Encode64(q$, False, CLng(p))
                            Else
                                MissParam a$
                                Exit Function
                            End If
                        Else
                        R$ = Encode64(q$, CBool(p))
                        End If
                        Else
                        R$ = Encode64(q$, CBool(p))
                        End If
                    Else
                    MissParam a$
                    Exit Function
                    End If
                Else
                R$ = Encode64(q$)
                End If
            ElseIf IsSymbol(a$, "DECODE64", 8) Then

                While FastSymbol(q$, vbCrLf, , 2)
                Wend
                R$ = Decode64(q$, par)
                If Not par Then MyEr "No base 64 encoding string", "тО АКЖАЯИХЛГТИЙЭ ДЕМ щВЕИ ДЕДОЛщМА СЕ БэСГ 64": IsStr1 = False: Exit Function
            ElseIf IsSymbol(a$, "UTF8", 4) Then
                 If IsSymbolNoSpace(a$, "DEC", 3) Then
                    R$ = utf8decode(q$)
                ElseIf IsSymbolNoSpace(a$, "ENC", 3) Then
                    R$ = utf8encode(q$)
                Else
                    SyntaxError
                    IsStr1 = False
                    Exit Function
                End If
            ElseIf IsSymbol(a$, "URL", 3) Then
                 If IsSymbolNoSpace(a$, "ENC", 3) Then
                    w = 0
                    If FastSymbol(a$, "1") Then
                    w = 1
                    ElseIf IsSymbolNoSpace(a$, "RFC3986", 7) Then
                    w = 1
                    ElseIf FastSymbol(a$, "2") Then
                    w = 2
                    ElseIf IsSymbolNoSpace(a$, "HTML5", 5) Then
                    w = 2
                    ElseIf IsSymbolNoSpace(a$, "SYS", 3) Then
                    w = 3
                    End If
                    If w = 3 Then
                    R$ = URLEncode(q$, IsSymbol(a$, "+"))
                    Else
                    R$ = URLEncodeEsc(q$, IsSymbol(a$, "+"), w)
                    End If
                ElseIf IsSymbolNoSpace(a$, "DEC", 3) Then
                    R$ = DecodeEscape(q$, IsSymbol(a$, "+"))

                ElseIf IsSymbolNoSpace(a$, "HOST", 4) Then
                    R$ = GetHost(q$)
                ElseIf IsSymbolNoSpace(a$, "PATH", 4) Then
                
                R$ = GetUrlPath(q$)
                ElseIf IsSymbolNoSpace(a$, "PORT", 4) Then
                    R$ = GetDomainName(q$, True)
                    If R$ <> vbNullString Then
                    If Left$(R$, 1) = "[" Then
                    w = InStr(R$, "]") + 1
                    R$ = Mid$(R$, w)
                    Else
                        w = InStr(R$, "@")
                        If w > 0 Then R$ = Mid$(R$, w + 1)
                    End If
                    If R$ <> vbNullString Then
                    w = InStr(R$, ":")
                    If w > 0 Then R$ = Mid$(R$, w + 1) Else R$ = ""
                    End If
                    End If
                    If R$ = "" Then
                    Select Case UCase(GetUrlParts(q$, 1))
                    Case "HTTP", "TELNET"
                    R$ = "80"
                    Case "FTP"
                    R$ = "21"
                    Case "HTTPS"
                    R$ = "443"
                    Case "LDAP"
                    R$ = "389"
                    Case "SOCKS5"
                    R$ = "1080"
                    End Select
                    End If
                ElseIf IsSymbolNoSpace(a$, "PART", 4) Then
                    If IsExp(bstackstr, a$, p, True, True, False) Then
                    w = CLng(p)
                    Else
                    w = 1
                    End If
                    R$ = GetUrlParts(q$, p)
                ElseIf IsSymbolNoSpace(a$, "SCHEME", 6) Then
                    If IsExp(bstackstr, a$, p, True, True, False) Then
                    w = CLng(p)
                    Else
                    w = 1
                    End If
                    R$ = GetUrlParts(q$, w, 1)
                ElseIf IsSymbolNoSpace(a$, "FRAGMENT", 8) Then
                    R$ = DecodeEscape(q$, IsSymbol(a$, "+"))
                    If R$ <> vbNullString Then
                    w = InStr(R$, "#")
                    If w > 0 Then R$ = Mid$(R$, w + 1) Else R$ = vbNullString
                    End If
                ElseIf IsSymbolNoSpace(a$, "USERINFO", 8) Then
                    R$ = GetDomainName(q$, True)
                    If R$ <> vbNullString Then
                    w = InStr(R$, "@")
                    If w > 0 Then R$ = Left$(R$, w - 1) Else R$ = vbNullString
                    End If
                ElseIf IsSymbolNoSpace(a$, "AUTHORITY", 9) Then
                    R$ = GetDomainName(q$, True)
                    If R$ <> vbNullString Then
                    If Left$(R$, 1) = "[" Then
                        w = InStr(R$, "]")
                        R$ = Mid$(R$, 2, w - 2)
                    End If
                    End If
                Else
                    SyntaxError
                    IsStr1 = False
                    Exit Function
                End If
            Else
                SyntaxError
                IsStr1 = False
                Exit Function
            End If
        Else
        
         R$ = StringToEscapeStr(q$)
         End If
         IsStr1 = True
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False
     Exit Function
    End If
       IsStr1 = False
    Exit Function
fstr45: ' "MID$(", "лес$("
    dd = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, a$, q$) Then
    If FastSymbol(a$, ",") Then
    If IsExp(bstackstr, a$, p, , True) Then
    p = Abs(p)
    If p = 0 Then
        MyErMacroStr a$, "Zero pos in mid$ not allowed", "лГДЕМИЙч ХщСГ СТГМ лес$ ДЕМ ЕПИТЯщПЕТАИ)"
        IsStr1 = False
        Exit Function
    Else
      If FastSymbol(a$, ",") Then
          If IsExp(bstackstr, a$, pp, , True) Then
                pp = Abs(pp)
                If IsLabelSymbolNew(a$, "ыс", "AS", dd, , , , False) Then
                    If IsLabelSymbolNew(a$, "ьгжио", "BYTE", dd, , , , False) Then
                        R$ = MidB$(q$, p, pp)
                    Else
                        SyntaxError
                        Exit Function
                    End If
                Else
                    R$ = Mid$(q$, p, pp)
                End If
            Else
                MissParam a$
                Exit Function
            End If
        Else
            If IsLabelSymbolNew(a$, "ыс", "AS", dd, , , , False) Then
                If IsLabelSymbolNew(a$, "ьгжио", "BYTE", dd, , , , False) Then
                    R$ = MidB$(q$, p)
                Else
                    SyntaxError
                    Exit Function
                End If
            Else
                R$ = Mid$(q$, p)
            End If
        End If
        IsStr1 = True
        End If
        Else
            MissParam a$
            Exit Function
        End If
    End If
    If Not FastSymbol(a$, ")", True) Then IsStr1 = False
    Else
    MissStringExpr
    IsStr1 = False
    Exit Function
    End If
    IsStr1 = True
    Exit Function
    
fstr46: ' "LEFT$(", "аяис$("
    dd = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, a$, q$) Then
    If FastSymbol(a$, ",") And IsExp(bstackstr, a$, p, , True) Then
    p = Abs(p)
    If IsLabelSymbolNew(a$, "ыс", "AS", dd, , , , False) Then
        If IsLabelSymbolNew(a$, "ьгжио", "BYTE", dd, , , , False) Then
            R$ = LeftB$(q$, p)
        Else
        SyntaxError
        Exit Function
        End If
    Else
        R$ = Left$(q$, p)
    End If
    IsStr1 = True
    End If
    If Not FastSymbol(a$, ")", True) Then IsStr1 = False
    Else
    MissStringExpr
    IsStr1 = False
    Exit Function
    End If
    Exit Function
fstr47: ' "RIGHT$(", "дени$("
    dd = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, a$, q$) Then
    If FastSymbol(a$, ",") And IsExp(bstackstr, a$, p, , True) Then
    p = Abs(p)
    If IsLabelSymbolNew(a$, "ыс", "AS", dd, , , , False) Then
        If IsLabelSymbolNew(a$, "ьгжио", "BYTE", dd, , , , False) Then
           R$ = RightB$(q$, p)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        R$ = Right$(q$, p)
    End If
    IsStr1 = True
    End If
    If Not FastSymbol(a$, ")", True) Then IsStr1 = False
    Else
    MissStringExpr
    IsStr1 = False
    Exit Function
    End If
    Exit Function
fstr48: ' "SND$(", "гво$("
     If IsStrExp(bstackstr, a$, q$) Then
        R$ = CFname(q$ & ".WAV")
         If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
    Else
        IsStr1 = False
    Exit Function
    End If
fstr49: ' "BMP$(", "еий$("
     If IsStrExp(bstackstr, a$, q$) Then
        R$ = CFname(q$ & ".BMP")
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
    Else
        IsStr1 = False
    Exit Function
    End If
fstr50: '"JPG$(", "жыто$("
     If IsStrExp(bstackstr, a$, q$) Then
        R$ = CFname(q$ & ".JPG")
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
    Else
        IsStr1 = False
    Exit Function
    End If
fstr69: '"RTRIM$(", "апой.де$("
    dd = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, a$, q$) Then
        If IsLabelSymbolNew(a$, "ыс", "AS", dd, , , , False) Then
        If IsLabelSymbolNew(a$, "ьгжио", "BYTE", dd, , , , False) Then
           R$ = MyTrimRB$(q$)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        R$ = MyTrimRW$(q$)
    End If
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
    Else

        IsStr1 = False
    Exit Function
    End If

fstr70: '"LTRIM$(", "апой.ая$("
    dd = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, a$, q$) Then
        If IsLabelSymbolNew(a$, "ыс", "AS", dd, , , , False) Then
        If IsLabelSymbolNew(a$, "ьгжио", "BYTE", dd, , , , False) Then
           R$ = MyTrimLB$(q$)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        R$ = MyTrimLW$(q$)
    End If
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
    Else

        IsStr1 = False
    Exit Function
    End If

fstr51: '"TRIM$(", "апой$("
    dd = 2 + (AscW(q$) < 128)
    If IsStrExp(bstackstr, a$, q$) Then
        If IsLabelSymbolNew(a$, "ыс", "AS", dd, , , , False) Then
        If IsLabelSymbolNew(a$, "ьгжио", "BYTE", dd, , , , False) Then
           R$ = MyTrimB$(q$)
        Else
           SyntaxError
            Exit Function
        End If
    Else
        R$ = MyTrim$(q$)
    End If
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
    Else

        IsStr1 = False
    Exit Function
    End If
fstr52: '"QUOTE$(", "паяахесг$("
R$ = vbNullString
q1$ = vbNullString
Do
If IsStrExp(bstackstr, a$, q$) Then
' make q$ as json string
 R$ = R$ & q1$ & Chr(34) + q$ + Chr(34)
ElseIf IsExp(bstackstr, a$, p, , True) Then
        R$ = R$ & q1$ & Trim$(Str$(p))
        Else
        IsStr1 = False: Exit Function
        End If
        If Not FastSymbol(a$, ",") Then Exit Do
        q1$ = ","
        Loop
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
 
fstr53: '"сыяос$(", "STACK$("
R$ = vbNullString
Do
If IsStrExp(bstackstr, a$, q$) Then
 R$ = R$ & Sput(q$)
ElseIf IsExp(bstackstr, a$, p) Then
        If Not bstackstr.lastobj Is Nothing Then
        MyEr "Number or and string allowed", "ЕПИТЯщПОМТАИ аЯИХЛОъ ч ЙАИ цЯэЛЛАТА "
        Set bstackstr.lastobj = Nothing
        IsStr1 = False: Exit Function
        End If
        Select Case VarType(p)
        Case vbLong
        R$ = R$ & " " & Trim$(Str$(p)) + "&"
        Case vbDecimal
        R$ = R$ & " " & Trim$(Str$(p)) + "@"
        Case vbSingle
        R$ = R$ & " " & Trim$(Str$(p)) + "~"
        Case vbCurrency
        R$ = R$ & " " & Trim$(Str$(p)) + "#"
        Case vbInteger
        R$ = R$ & " " & Trim$(Str$(p)) + "%"
        Case Else
        R$ = R$ & " " & Trim$(Str$(p))
        End Select
        End If
        If Not IsSymbol3(a$, ",") Then Exit Do
        Loop
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
fstr54: '"ADD.LICENSE$(", "баке.адеиа$("
If IsStrExp(bstackstr, a$, q$) Then
If FastSymbol(a$, ",") Then
If IsStrExp(bstackstr, a$, q1$) Then
Err.Clear
On Error Resume Next
        If q1$ = vbNullString Then
        R$ = Licenses.Add(q$)
        Else
        R$ = Licenses.Add(q$, q1$)
        End If
        If Err.Number > 0 And Err.Number <> 732 Then MissLicense
        Err.Clear
        On Error GoTo 0
       If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
End If
Else
Err.Clear
On Error Resume Next
        R$ = Licenses.Add(q$)
        If Err > 0 And Err.Number <> 732 Then MissLicense
        Err.Clear
        On Error GoTo 0
       If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True


End If
End If

        Exit Function
fstr55: '"ENVELOPE$(", "жайекос$("
If IsStrExp(bstackstr, a$, q$) Then
    If FastSymbol(a$, ",") Then
            If Not IsStrExp(bstackstr, a$, q1$) Then IsStr1 = False: Exit Function
            Else
            q1$ = vbNullString
            End If
            If VALIDATE(q$, UCase$(q1$), q2$) Then ' Only S and N
               R$ = q2$
               Else
               R$ = vbNullString
               End If
    Else
' STACK$(BSTACKSTR)
                If FastSymbol(a$, ",") Then
                If Not IsStrExp(bstackstr, a$, q1$) Then IsStr1 = False: Exit Function
                Else
                q1$ = vbNullString
                End If

                If VALIDATEmStiva(bstackstr, UCase$(q1$), q2$) Then
                   R$ = q2$
                   Else
                   R$ = vbNullString
                   End If

    End If
         If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
        Exit Function
fstr56: '"FIELD$(", "педио$("
    If IsStrExp(bstackstr, a$, q$) Then
        If FastSymbol(a$, ",") Then
           If Not IsExp(bstackstr, a$, p, , True) Then
           IsStr1 = False
           Exit Function
           End If
           p = Abs(p)
        Else
           IsStr1 = False
           Exit Function
        End If
        R$ = Left$(Trim$(q$), p)
        R$ = R$ & space$(p - Len(R$))
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True
      
    Else

        IsStr1 = False
   
    End If
    Exit Function
fstr57: '"DRW$(", "свд$("
    If IsStrExp(bstackstr, a$, q$) Then
        R$ = CFname(q$ & ".WMF")
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
        IsStr1 = True

    Else
        IsStr1 = False
    End If
    Exit Function
fstr58: '"TIME$(", "вяомос$("
    If IsExp(bstackstr, a$, p, , True) Then
        If FastSymbol(a$, ",") Then
            If Not IsExp(bstackstr, a$, pp, , True) Then
                pp = Clid
            End If
            If FastSymbol(a$, ",") Then
                If IsStrExp(bstackstr, a$, s$) Then
                    If UCase(s$) = "SHORT TIME" Then
                        s$ = GetlocaleString2(&H5D, pp)
                    ElseIf UCase(s$) = "LONG TIME" Then
                        s$ = GetlocaleString2(&H79, pp)
                    End If
                    IsStr1 = True
                    R$ = FormatTimeWithLocale(s$, CDate(p), pp)
                Else
                    MissParam a$
                    IsStr1 = False
                    Exit Function
                End If
            Else
                IsStr1 = True
                R$ = FormatTimeWithLocale(GetlocaleString2(&H5D, pp), CDate(p), pp)
            End If
       Else
            R$ = Format(p, "SHORT TIME")
            IsStr1 = True
       End If
    Else
        IsStr1 = True
        R$ = Trim$(GetTimeZoneInfo)
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
    Exit Function
fstr59: ' "DATE$(", "глеяа$("
    IsStr1 = True
    If IsExp(bstackstr, a$, p, , True) Then
        If FastSymbol(a$, ",") Then
        If Not IsExp(bstackstr, a$, pp, , True) Then
            pp = Clid
        End If
        If FastSymbol(a$, ",") Then
        If IsStrExp(bstackstr, a$, s$) Then
        If UCase(s$) = "SHORT DATE" Then
        s$ = GetlocaleString2(&H1F, pp)
        ElseIf UCase(s$) = "LONG DATE" Then
        s$ = GetlocaleString2(&H20, pp)
        End If
            R$ = FormatDateWithLocale(s$, CDate(p), pp)
        Else
        MissParam a$
        IsStr1 = False
        Exit Function
        End If
        Else
        R$ = FormatDateWithLocale(GetlocaleString2(&H1F, Clid), CDate(p), Clid)
        End If
        Else
        R$ = Format(CDbl(CDate(p)), "SHORT DATE")
        End If
    Else
        MissParam a$
        IsStr1 = False
        Exit Function
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
    Exit Function
fstr60: '"STR$(", "цяажг$("
    If IsExp(bstackstr, a$, p) Then
    If Not bstackstr.lastobj Is Nothing Then
        If TypeOf bstackstr.lastobj Is Group Then
            If bstackstr.lastobj.HasValue Then
            
            Else
            MyErMacro a$, "Group has no value", "г ОЛэДА ДЕМ щВЕИ АНъА"
            Exit Function
            End If
        ElseIf TypeOf bstackstr.lastobj Is mHandler Then
        p = 0
        Set usehandler = bstackstr.lastobj
        If usehandler.t1 = 4 Then p = usehandler.index_cursor
        Set bstackstr.lastobj = Nothing
        Set usehandler = Nothing
        End If
        End If
        If FastSymbol(a$, ",") Then
            If IsExp(bstackstr, a$, pp, , True) Then
            If pp = 0 Then
                If VarType(p) = vbBoolean Then
                    R$ = Format$(p, DefBooleanString)
                Else
                    R$ = CStr(p)
                End If
            Else
                q$ = GetlocaleString2(14, pp)
                If VarType(p) = vbBoolean Then
                    If pp = 1032 Then
                        R$ = Format$(p, ";\а\К\Г\Х\ч\Р;\ь\Е\У\Д\ч\Р")
                    ElseIf pp = 1033 Then
                        R$ = Format$(p, ";\T\r\u\e;\F\a\l\s\e")
                    Else
                        R$ = Format$(p, DefBooleanString)
                    End If
                Else
                R$ = LTrim$(Str$(p))
                If Left$(R$, 1) = "." Then
                    R$ = "0" + R$
                ElseIf Left$(R$, 2) = "-." Then
                    R$ = "-0" + Mid$(R$, 2)
                End If
                R$ = Replace(R$, ".", q$)
            End If
                End If
                

            GoTo contstrhere
            ElseIf IsStrExp(bstackstr, a$, q$) Then
            On Error Resume Next
                R$ = Format(p, q$)
                If Err.Number = 6 Then Overflow
                Err.Clear
                If Not NoUseDec Then
                    If mNoUseDec Then
                        R$ = Replace$(R$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                        R$ = Replace$(R$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                        R$ = Replace$(R$, Chr(2), NowDec$)
                        R$ = Replace$(R$, Chr(3), NowThou$)
                        
                    ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                        R$ = Replace$(R$, ",", Chr(2))
                        R$ = Replace$(R$, ".", ",")
                        R$ = Replace$(R$, Chr(2), ".")

                End If
                    End If
contstrhere:
            If FastSymbol(a$, ",") Then
            If IsExp(bstackstr, a$, pp, , True) Then
            If pp > 0 Then
            R$ = Left$(R$ + space$(pp), pp)
            Else
            R$ = Right$(space$(Abs(pp)) + R$, Abs(pp))
            End If
            Else
            IsStr1 = False
            Exit Function
            End If
            End If
            
            ElseIf IsExp(bstackstr, a$, pp, , True) Then
            
            If pp > 0 Then
            R$ = Left$(Trim$(Str(p)) + space$(pp), pp)
            Else
            R$ = Right$(space$(Abs(pp)) + Trim$(Str(p)), Abs(pp))
            End If
            Else
            IsStr1 = False
            Exit Function
            End If
        Else
            If VarType(p) = vbBoolean Then
                R$ = Format$(p, ";\T\r\u\e;\F\a\l\s\e")
            Else
                R$ = Str(p)
            End If
        End If
        
        If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
    IsStr1 = True
    Exit Function
    ElseIf IsStrExp(bstackstr, a$, R$) Then
        If FastSymbol(a$, ",") Then
            If IsStrExp(bstackstr, a$, q$) Then
                R$ = Format(R$, q$)
            ElseIf IsExp(bstackstr, a$, pp, , True) Then
                If Fix(pp) = 0 Then
                    R$ = Convert2(R$, Clid)
                Else
                    If GetCodePage(CLng(Fix(pp))) <> 0 Then
                        R$ = Convert2(R$, CLng(Fix(pp)))
                    Else
                        IsStr1 = False
                        NoValidLocale
                        Exit Function
                    End If
                End If
            Else
                IsStr1 = False
                Exit Function
            End If
        Else
        R$ = StrConv(R$, vbFromUnicode, Clid)
        End If
            If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
    IsStr1 = True
    Else
    IsStr1 = False
    End If
    Exit Function
   
fstr61: '"CHRCODE$(", "ваяйыд$("
    If IsExp(bstackstr, a$, p, , True) Then
        w3 = UINT(p)
    If w3 >= &H10000 And w3 <= &H10FFFF Then
        w3 = w3 - &H10000
        R$ = ChrW(UINT(w3 \ &H400& + &HD800&)) + ChrW(UINT((w3 And &H3FF&) + &HDC00&))
        Else
    R$ = ChrW$(w3)
    End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
    IsStr1 = True
    Else
    IsStr1 = False
    End If
    Exit Function
    
fstr62: ' "CHR$(", "вая$("
    If IsExp(bstackstr, a$, p, , True) Then
        If FastSymbol(a$, ",") Then
                If IsExp(bstackstr, a$, pp, , True) Then
                If pp = 0 Then
                    pp = LCID_DEF
                Else
                    If GetCodePage(CLng(Fix(pp))) = 0 Then
                        NoValidLocale
                        Exit Function
                    End If
                End If
                
                     R$ = ChrW$(AscW(StrConv(ChrW$(p Mod 256), 64, CLng(Fix(pp)))))
                Else
                        IsStr1 = False: Exit Function
                End If
        Else

                 R$ = ChrW$(AscW(StrConv(ChrW$(Fix(p) Mod 256), 64, Clid)))

        End If
        If InStr(R$, ChrW(&HFFFFF8FB)) > 0 Then R$ = Replace(R$, ChrW(&HFFFFF8FB), ChrW(&H2007))
    If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
    IsStr1 = True
    Exit Function
    ElseIf IsStrExp(bstackstr, a$, q$) Then 'CONVERT TO ASCII

            If FastSymbol(a$, ",") Then
                If IsExp(bstackstr, a$, pp, , True) Then
                If Fix(pp) = 0 Then
                   R$ = Convert3(q$, LCID_DEF)
                ElseIf LCID_DEF = 1032 Then
                    If GetCodePage(CLng(Fix(pp))) = 0 Then
                        NoValidLocale
                        Exit Function
                    End If
                
                
                     R$ = Convert3(q$, CLng(Fix(pp)))
                Else
                    If GetCodePage(CLng(Fix(pp))) = 0 Then
                        NoValidLocale
                        Exit Function
                    End If
                
                  R$ = Convert3(Convert2(q$, LCID_DEF), CLng(Fix(pp)))
     
                   
                     End If
                Else
                        IsStr1 = False: Exit Function
                End If
        Else
        R$ = StrConv(q$, vbUnicode, Clid)
        End If
    If Not FastSymbol(a$, ")") Then IsStr1 = False: Exit Function
    IsStr1 = True
    Else
    IsStr1 = False
    End If
    Exit Function
fstr63: ' "GROUP$(", "олада$("
        
R$ = vbNullString
 IsStr1 = IsGroup(bstackstr, a$, p)
        
        
Exit Function
fstr64: ' "PROPERTY$(", "идиотгта$("
        w1 = Abs(IsLabel(bstackstr, a$, s$))
        If w1 = 1 Or w1 = 3 Or w1 = 6 Then
        If w1 = 6 Then If Not FastSymbol(a$, ")", True) Then Exit Function
        If Not GetVar(bstackstr, s$, w2) Then GoTo jmp147811
        If w1 = 6 Then
        
         If Not Typename(var(w2)) = myArray Then GoTo jmp147811
         Set pppp = var(w2)
         If pppp.Arr Then GoTo jmp147811
         If Not pppp.ItemType(-1) = mProp Then GoTo jmp147811
         Set bstackstr.lastobj = pppp.GroupRef
        Else
        If Not Typename(var(w2)) = mProp Then GoTo jmp147811
        Set bstackstr.lastobj = var(w2)
        End If
            R$ = vbNullString
            IsStr1 = FastSymbol(a$, ")", True)
            Exit Function
                
        Else
jmp147811:
        MyErMacro a$, "Expected a property name", "пЕЯъЛЕМА ЭМОЛА ИДИЭТГТАР"
        End If
Exit Function
fstr65:
    If IsStrExp(bstackstr, a$, q$) Then
        IsStr1 = True
        R$ = Tcase(q$)
    End If
        If Not FastSymbol(a$, ")") Then IsStr1 = False
    Exit Function
    
itisarrayorfunction:
    MakeThisSubNum bstackstr, q$
    q1$ = q$
    
    If Right$(q1$, 1) <> ")" Then q1$ = q1$ + ")"
    
            If IsSymbol(a$, "*") Then
            'is a function allways...
            If GetlocalSub(q1$, w1&) Then
                GoTo contStrFun
            ElseIf GetSub(q1$, w1&) Then
                GoTo contStrFun
            ElseIf GetSub2(bstackstr, q1$, w1&) Then
                GoTo contStrFun
            Else
            If Len(bstackstr.UseGroupname) > 0 Then
            If InStr(q1$, bstackstr.UseGroupname) = 1 Then
            q1$ = bstackstr.UseGroupname + ChrW(&HFFBF) + Mid$(q1$, Len(bstackstr.UseGroupname) + 1)
            If GetSub(q1$, w1&) Then GoTo contStrFun

            End If
            End If
                GoTo skiperrorStr
            End If
            
            Else
            If neoGetArray(bstackstr, q$, pppp, , , True) Then
                GoTo contStrArr
            ElseIf GetlocalSub(q1$, w1&) Then
                GoTo contStrFun
            ElseIf neoGetArray(bstackstr, q$, pppp, , True) Then
                GoTo contStrArr
            ElseIf GetSub2(bstackstr, q1$, w1&) Then
                GoTo contStrFun
            ElseIf GetSub(q1$, w1&) Then
                GoTo contStrFun
            Else
            If Len(bstackstr.UseGroupname) > 0 Then
            If InStr(q1$, bstackstr.UseGroupname) = 1 Then
            q1$ = bstackstr.UseGroupname + ChrW(&HFFBF) + Mid$(q1$, Len(bstackstr.UseGroupname) + 1)
            If GetSub(q1$, w1&) Then GoTo contStrFun
            End If
            End If

                GoTo skiperrorStr
            End If
            End If

    
        If GetSub(q1$, w1&) Then
contStrFun:
    If bstackstr.NoFuncError Then
    R$ = q$
                CallNext bstackstr, a$, par, p, R$
                    If par Then
                        IsStr1 = True
                    Else
                        R$ = vbNullString
                        IsStr1 = False
                    End If
                Else
                Set nbstack = New basetask
                Set nbstack.Parent = bstackstr
                Set nbstack.Owner = bstackstr.Owner
                nbstack.UseGroupname = sbf(w1&).sbgroup
                nbstack.tpointer = sbf(w1&).tpointer
                nbstack.OriginalCode = w1&
                nbstack.SetV
                If GoFunc(nbstack, q1$, a$, s$, , , True) Then
                    If Not nbstack.StaticCollection Is Nothing Then
                        bstackstr.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                    End If
                    Set bstackstr.lastobj = nbstack.lastobj
                    SwapStrings R$, s$
                    s$ = vbNullString
                    IsStr1 = True
                Else
                    IsStr1 = False
                End If
                End If
            Exit Function
        ElseIf neoGetArray(bstackstr, q$, pppp) Then
contStrArr:
            
            If pppp.Arr Then
            If FastSymbol(a$, ")") Then
                IsStr1 = True
                p = 0
                Set bstackstr.lastobj = pppp
                Exit Function
            End If
            dn = 0
            
            dd = pppp.bDnum - 1
            If dd < 0 Then
            If Typename(pppp.GroupRef) = mProp Then
            
            GoTo contreadprop
            End If
            End If
            p = 0
            pp = 0
        IsStr1 = True
        w2 = 0
        Do While dn <= dd
        pppp.GetDnum dn, w3, w1&
        If IsExp(bstackstr, a$, p, , True) Then
        If dn < dd Then
            If Not FastSymbol(a$, ",") Then MyErMacroStr a$, "need index for " & q$ & ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " & q$ & ")": IsStr1 = False: Exit Do
            Else
            If FastSymbol(a$, ",") Then
            IsStr1 = False
            MyErMacroStr a$, "too many indexes for array " & q$ & ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " & q$ & ")"
        Exit Function
        End If
            If Not FastSymbol(a$, ")") Then MissSymbol ")": IsStr1 = False: Exit Function
        End If
              If p < -w1& Then
                 MyErMacroStr a$, "index too low for array " & q & ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " & q$ & ")": Exit Function
    
                End If
            On Error Resume Next
        If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
        
            MyErMacroStr a$, "index too high for array " & q$ & ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " & q$ & ")"
            IsStr1 = False: Exit Function
            End If
            On Error GoTo 0
              Else
        IsStr1 = False
        
          MyErMacroStr a$, "missing index for array " & q$ & ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " & q$ & ")"
        Exit Function
    
        End If
        dn = dn + 1
        Loop
    If pppp.ItemIsObject(w2) Then
        If FastSymbol(a$, "(") Then
            If pppp.ItemType(w2) = "lambda" Then
                Set anything = pppp.item(w2)
contlambdastr:
                PushStage bstackstr, False
                w1 = globalvarGroup("A_" + CStr(Abs(w2)), 0#)
                Set var(w1) = anything
                If here$ = vbNullString Then
                    dd = ModuleSubAsap("A_" + CStr(Abs(w2)) + "$()", "", , w1)
                Else
                    dd = ModuleSubAsap(here$ & "." & bstackstr.GroupName & "A_" + CStr(Abs(w2)) + "$()", "", , w1)
                End If
                a$ = "A_" + CStr(Abs(w2)) + "$(" + a$
                IsStr1 = IsStr1(bstackstr, a$, R$)
                Set var(w1) = Nothing
                PopStage bstackstr
            ElseIf pppp.ItemType(w2) = mHdlr Then
                Set bstackstr.lastobj = pppp.item(w2)
                Set pppp = New mArray
                pppp.Arr = False
                Set pppp.GroupRef = bstackstr.lastobj
                Set bstackstr.lastobj = Nothing
                GoTo contStrArr
            ElseIf pppp.ItemType(w2) = myArray Then
                Set pppp = pppp.item(w2)
                GoTo contStrArr
            ElseIf pppp.ItemType(w2) = mgroup Then
                IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", q$, a$, w2) = 1
                R$ = bstackstr.LastValue
                Exit Function
            ElseIf pppp.ItemType(w2) = mProp Then
                 ' a$(2)(...
                 p = 0
                 pppp.SwapItem w2, p
                 Set anything = p
                 pppp.SwapItem w2, p
                 Set pppp = New mArray
                 Set pppp.GroupRef = anything
                 Set anything = Nothing
                 pppp.Arr = False
                 GoTo contreadprop
            End If
        ElseIf pppp.ItemType(w2) = mgroup Then
                    IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", q$, "", w2) = 1
                    R$ = bstackstr.LastValue
                    Exit Function
        ElseIf pppp.ItemIsObject(w2) Then
                    p = rValue(bstackstr, pppp.itemObject(w2))
                    If bstackstr.lastobj Is Nothing Then
                        If TypeOf pppp.itemObject(w2) Is Document Then
                            R$ = pppp.item(w2)
                        Else
                            On Error Resume Next
                            R$ = pppp.item(w2)
                            If Err > 0 Then
                                Err.Clear
                                R$ = CStr(pppp.item(w2).Value)
                                If Err Then
                                    MyEr "Can't fing value in this object", "дЕМ ЛПОЯЧ МА БЯЫ ТИЛч СЕ АУТЭ ТО АМТИЙЕъЛЕМО"
                                    IsStr1 = False
                                    Exit Function
                                End If
                            End If
                        End If
                    End If
                    IsStr1 = True
                    Exit Function
                Else
                    R$ = pppp.item(w2)
                End If
            Else
                R$ = pppp.item(w2)
            End If
            IsStr1 = True
        Exit Function
Else
contrightstrpar:
    If Typename(pppp.GroupRef) = mHdlr Then
        Set usehandler = pppp.GroupRef
        If usehandler.t1 <> 1 Then
            If usehandler.t1 = 3 Then
                Set pppp = usehandler.objref
                Set usehandler = Nothing
                GoTo contStrArr
            Else
                SyntaxError
                IsStr1 = False
                Exit Function
            End If
        End If
    ' only for Inventory
        If Not TypeOf usehandler.objref Is FastCollection Then
            Set pppp.GroupRef = usehandler.objref
            Set usehandler = Nothing
            GoTo contrightstrpar
        End If
       ' Set usehandler = pppp.GroupRef
        With usehandler.objref
            If IsExp(bstackstr, a$, p, , True) Then
                If VarType(p) = vbBoolean Then p = CLng(p)
                If FastSymbol(a$, "!") Then
                    If Abs(p) < .count Then
                        If p < 0 Then
                            .index = .count + MyRound(p)
                        Else
                            .index = MyRound(p)
                        End If
                    Else
                        MyErMacroStr a$, "Index out of limits", "дЕъЙТГР ЕЙТЭР ОЯъЫМ"
                        IsStr1 = False
                        Exit Function
                    End If
                Else
                    .Find p
                End If
            ElseIf IsStrExp(bstackstr, a$, R$) Then
                .Find R$
            End If
            If .Done Then
                If .IsObj Then
                    If TypeOf .ValueObj Is lambda Then
                        If FastSymbol(a$, ")(", , 2) Then
                            Set anything = .ValueObj
                            GoTo contlambdastr
                        Else
                            Set bstackstr.lastobj = .ValueObj
                        End If
                    ElseIf TypeOf .ValueObj Is mArray Then
                    Set pppp = .ValueObj
                    If FastSymbol(a$, ")(", , 2) Then GoTo contStrArr
                ElseIf TypeOf .ValueObj Is mHandler Then
                    Set pppp.GroupRef = .ValueObj
                        If FastSymbol(a$, ")(", , 2) Then GoTo contStrArr
                    ElseIf TypeOf .ValueObj Is Document Then
                        R$ = .ValueObj.textDoc
                    ElseIf TypeOf .ValueObj Is Group Then
                        Set usehandler = pppp.GroupRef
                        Set anything = usehandler.objref
                        dd = anything.index
                        Set pppp = New mArray: pppp.PushDim (1): pppp.PushEnd: pppp.Arr = True
                        Set pppp.item(0) = .ValueObj
                        w2 = 0
                        IsStr1 = IsStr1 And FastSymbol(a$, ")")  ' ????
                        ' why not = IsStr1 And SpeedGroup(bstackstr, pppp, "VAL$", q$, a$, w2) = 1
                        IsStr1 = SpeedGroup(bstackstr, pppp, "VAL$", q$, a$, w2) = 1
                        R$ = bstackstr.LastValue
                        anything.index = dd
                        Set .ValueObj = pppp.item(0)
                        Set pppp.item(0) = Nothing
                        Exit Function
                    ElseIf TypeOf .ValueObj Is PropReference Then
                        .ValueObj.index = p
                        R$ = .ValueObj.Value
                        Set bstackstr.lastobj = .ValueObj.lastobjfinal
                        IsStr1 = IsStr1 And FastSymbol(a$, ")")
                    Else
                        MyErMacroStr a$, "This kind of object not supported", "аУТОЩ ТОУ ЕъДОУР ТО АМТИЙЕъЛЕМО ДЕМ УПОСТГЯъФЕТАИ"
                    End If
                Else
                    Call .ValueType(2, p, R$)
                End If
            Else
                MyErMacroStr a$, "Key Not Found", "дЕМ БЯщХГЙЕ ТО ЙКЕИДъ"
            End If
        End With
    ElseIf Typename(pppp.GroupRef) = mgroup Then
        If Len(q$) > Len(pppp.GroupRef.GroupName) Then
            If Len(pppp.CodeName) > 0 Then
                q1$ = pppp.CodeName + "." + ChrW(&H1FFF) + "$()"
            Else
                q1$ = Left$(q$, Len(q$) - 2) + "." + ChrW(&H1FFF) + "$()"
            End If
        Else
            q1$ = pppp.GroupRef.GroupName + ChrW(&H1FFF) + "$()"
        End If
            If GetSub(q1$, w1) Then
                Set nbstack = New basetask
                    Set nbstack.Parent = bstackstr
                    If bstackstr.IamThread Then Set nbstack.Process = bstackstr.Process
                        Set nbstack.Owner = bstackstr.Owner
                        nbstack.OriginalCode = w1
                        nbstack.UseGroupname = sbf(w1).sbgroup
                        nbstack.tpointer = sbf(w1).tpointer
                        nbstack.SetV
                        If GoFunc(nbstack, q1$, a$, R$) Then
                            If Not nbstack.StaticCollection Is Nothing Then
                                bstackstr.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                            End If
                            'Set bstackstr.lastobj = nBstack.lastobj
                            Set nbstack = Nothing
                            IsStr1 = True
                        Else
                            IsStr1 = False
                        End If
                    Else
                        InternalEror
                        IsStr1 = False
                    End If
                    Exit Function
                Else
contreadprop:
           If Not getindexes(bstackstr, pppp.GroupRef, a$) Then
            On Error Resume Next
                R$ = pppp.GroupRef.Value
                If Err.Number > 0 Then
                    pppp.GroupRef.IndexAgain
                    If Typename(pppp.GroupRef.Value) = "Null" Then
                        R$ = ""
                        Err.Clear
                    Else
                        InStr = False
                        MyEr Err.Description, Err.Description
                        Err.Clear
                        Exit Function
                    End If
                End If
           Else
                Set bstackstr.lastobj = pppp
                R$ = vbNullString
           End If
                      
                End If
                  IsStr1 = FastSymbol(a$, ")")
                Exit Function
            End If
        Else  '......
skiperrorStr:
            If Right$(q1$, 1) = ")" Then
                If here$ Like "*." + q1$ Then
                    subHash.ItemCreatorNoSwap q1$, bstackstr.OriginalCode, True
                    GoTo contStrFun
            ElseIf q1$ = "LAMBDA$()" Then
contlambda01:
                If bstackstr.IamLambda Then
                    q1$ = bstackstr.FuncRec
                Else
                    q1$ = Mid$(here$, rinstr(here$, "].") + 2)
                    If Right$(here$, 2) = "()" And bstackstr.UseGroupname = vbNullString Then
                        q1$ = sbf(bstackstr.OriginalCode).goodname
                        w1& = bstackstr.OriginalCode
                    ElseIf Not GetSub(q1$, w1&) Then
                        If here$ Like "*." + q1$ Then
                            q1$ = sbf(bstackstr.OriginalCode).goodname
                            w1& = bstackstr.OriginalCode
                        Else
                            GoTo skiperrorStr
                        End If
                    End If
                End If
                GoTo contStrFun
            ElseIf q1$ = "калда$()" Then
                GoTo contlambda01
            End If
        End If
        If strfunidbackup.Find(q$, w2) Then GoTo findthird
        If FindNameForGroup(bstackstr, q$) Then
            MyErMacroStr a$, "unknown method/array  " & q$, "╒ЦМЫСТГ ЛщХОДОР/ПъМАЙАР " & q$
        Else
            MyErMacroStr a$, "unknown function/array " & q$, "╒ЦМЫСТГ СУМэЯТГСГ/ПъМАЙАР " & q$
        End If
        Exit Function
    End If
Case 106
isasub:
    If CurrentStackSize > stacksize Then
        MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
        MOUT = True
        IsStr1 = False: Exit Function
    End If
    w1 = bstackstr.soros.Total
    If Not PushParamSUB(bstackstr, a$) Then
        w1 = bstackstr.soros.Total - w1
        If w1 > 0 Then bstackstr.soros.drop w1
        IsStr1 = False:  Exit Function
    End If
    If FastSymbol(a$, ")") Then
        PushStage bstackstr, False
        w2 = bstackstr.OriginalCode
        q1$ = bstackstr.originalname$
        bstackstr.originalname$ = q2$ + ")"
        If gr Then
            q2$ = "сумаятгсг " + q2$
        Else
            q2$ = "FUNCTION " + q2$
        End If
        If searchsub(w2, q2$, w1, w2, n$, True) Then
againsub:
            If Len(q2$) > 0 Then
                If Not MyRead(7, bstackstr, q2$, 1) Then
                    bstackstr.originalname$ = q1$
                    PopStage bstackstr
                    IsStr1 = False
                    Exit Function
                End If
            End If
            bstackstr.FuncValue = vbNullString
            Set bstackstr.FuncObj = Nothing
            dn = bstackstr.addlen
            bstackstr.RetStack.Push3long Len(a$), 0, Len(a$) - Len(n$)
            If trace Then
            q2$ = TestShowSub: sg1 = TestShowBypass
            If w2 > 0 Then
                bstackstr.addlen = Len(sbf(w2).sb) - w1 - Len(n$) + 1
                TestShowSub = sbf(w2).sb
            ElseIf w2 = 0 Then
                bstackstr.addlen = 0
                TestShowSub = n$
            Else
                bstackstr.addlen = Len(var(-w2).code) - w1 - Len(n$) + 1
                TestShowSub = var(-w2).code
            End If
            TestShowBypass = True
            dd = 1
            executeblock dd, bstackstr, n$, False, False, , True
            SwapStrings q2$, TestShowSub: TestShowBypass = sg1
            Else
            dd = 1
            executeblock dd, bstackstr, n$, False, False, , True
            End If
            bstackstr.RetStackDrop 1
            bstackstr.addlen = dn
            If dd > 0 Then
                IsStr1 = True
                Set bstackstr.lastobj = bstackstr.FuncObj
                Set bstackstr.FuncObj = Nothing
                R$ = bstackstr.FuncValue
                bstackstr.FuncValue = Empty
            Else
                IsStr1 = False
                If bstackstr.ErrorOriginal = 0 Then
                    LastErNum = -1
                    LastErNum1 = -1
                    bstackstr.ErrorOriginal = w2
                    If w2 > 0 Then
                        a$ = n$ + space$(Len(sbf(w2).sb) - w1 + 1)
                    ElseIf w2 = 0 Then
                        a$ = n$
                    Else
                        a$ = n$ + space$(Len(var(-w2).code) - w1 + 1)
                    End If
                End If
                Exit Function
            End If
            If usebackup Then
                    If Not bstackstr.lastobj Is Nothing Then
                        If InStr(q$, "$") = 0 Then GoTo Final
                    End If
            End If
        ElseIf bstackstr.IamChild Then
            dn = FindPrevOriginal(bstackstr)
            If searchsub(dn, q2$, w1, w2, n$, True) Then
                    If dn <> w2 And w2 < 0 Then
                        w2 = dn
                    End If
                GoTo againsub
            Else
                GoTo nofun1
            End If
        Else
nofun1:
            MyEr "Function @" + Mid$(q2$, InStr(q2$, " ") + 1) + ") not found", "г СУМэЯТГСГ @" + Mid$(q2$, InStr(q2$, " ") + 1) + ") ДЕМ БЯщХГЙЕ"
            IsStr1 = False
        End If
        bstackstr.originalname$ = q1$
        PopStage bstackstr
        
    Else
        IsStr1 = False
    End If
    Exit Function
End Select
If a$ = vbNullString Then IsStr1 = False: Exit Function
IsStr1 = True
End Function

Function ISSTRINGA(bb$, R$) As Boolean
'
Dim q$, w As Long, a$
a$ = NLtrim$(bb$)
R$ = vbNullString
If a$ = vbNullString Then Exit Function
Select Case AscW(a$)
Case 1
q$ = Chr(1)
Case 2
R$ = Mid$(a$, 2, 8)
R$ = Mid$(a$, 10, CLng("&H" & R$))
bb$ = Mid$(a$, Len(R$) + 10)
ISSTRINGA = True
Exit Function
Case 34
q$ = Chr(34)
End Select
If q$ = vbNullString Or Len(a$) < 2 Then ISSTRINGA = False: Exit Function
If q$ = Chr(34) Then
    w = 1
    Do
    w = w + 1
    w = InStr(w, a$, q$)
    If w > 0 Then
    If Mid$(a$, w - 1, 1) <> "\" Then Exit Do
    ElseIf w = 0 Then
    Exit Do
    End If
    Loop

Else
w = InStr(2, a$, q$, vbBinaryCompare)
End If
If w = 0 Then ISSTRINGA = False: Exit Function
R$ = Mid$(a$, 2, w - 2)
bb$ = NLtrim$(Mid$(a$, w + 1))

ISSTRINGA = True

End Function
Function IsOperator(a$, c$, Optional cl As Long = 1) As Boolean
If Len(a$) > 0 Then
If Left$(a$, cl) = c$ Then
    a$ = NLtrim$(Mid$(a$, cl + 1))
    IsOperator = True
End If
End If
End Function
Function IsOperator0(a$, c$, Optional cl As Long = 1) As Boolean
Dim n$
If Len(a) > 0 Then
If Left$(a$, cl) = c$ Then  ' no letters in operator so no UCASE
' check next character
n$ = Left$(Mid$(a$, cl + 1, 1) & " ", 1)
    If Not InStr(novalidstr, n$) > 0 Then
    
    a$ = NLtrim$(Mid$(a$, cl + 1))
    IsOperator0 = True
    End If
End If
End If
End Function
Function IsOperatorNoRemove(a$, c$, Optional cl As Long = 1) As Boolean
Dim n$
If Len(a) > 0 Then
If Left$(a$, cl) = c$ Then  ' no letters in operator so no UCASE
' check next character
n$ = Left$(Mid$(a$, cl + 1, 1) & " ", 1)
    If Not InStr(novalidstr, n$) > 0 Then
    
    
    IsOperatorNoRemove = True
    End If
End If
End If
End Function
Function codeW(a$) As Long
If a$ <> "" Then
If AscW(a$) < 128 Then codeW = 1
End If
End Function


Function IsSymbol(a$, c$, Optional l As Long = 1, Optional mis As Boolean = False) As Boolean
Dim i As Long, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i <= j Then

If myUcase(Mid$(a$, i, l)) = c$ Then
a$ = NLtrim$(Mid$(a$, l + i))
IsSymbol = True

 Else
 If mis Then
 MyEr "missing " & c$, "КЕъПЕИ " & c$
 ElseIf i > 1 Then
 a$ = Mid$(a$, i)
 End If
IsSymbol = False
End If
Else
 If mis Then
 MyEr "missing " & c$, "КЕъПЕИ " & c$
 Else
 a$ = vbNullString
 End If
IsSymbol = False
End If
End Function

Function IsSymbolBracket(a$) As Boolean
Dim i As Long, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then Exit Function
If Mid$(a$, i, 1) = "{" Then
a$ = Mid$(a$, i + 1)
IsSymbolBracket = True
End If
End Function


Private Function IsSymbol3(a$, c$) As Boolean
' SAME AS FASTSYMB WITHOUT trim after
Dim i As Long, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then Exit Function
If j - i > -1 Then
If c$ = Mid$(a$, i, 1) Then
a$ = Mid$(a$, i + 1)
IsSymbol3 = True
End If
End If
End Function
'
Function Fast2NoSpace(a$, c$, cl As Long, D$, dl As Long, ahead&) As Boolean
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
Pad$ = myUcase(Left$(a$, ahead&))
If c$ = Left$(Pad$, cl) Then
j = MyTrimLi(a$, cl + 1)
check:
If Len(Mid$(a$, j, 1)) > 0 Then
Select Case AscW(Mid$(a$, j, 1))
Case 36, 37, 40, 46, 48 To 57, 95, Is < 0, Is > 64
Fast2NoSpace = False
Case Else
a$ = Mid$(a$, j)
Fast2NoSpace = True
End Select
Else
a$ = Mid$(a$, j)
Fast2NoSpace = True
End If
Exit Function
End If
If D$ = Left$(Pad$, dl) Then
j = MyTrimLi(a$, dl + 1)
GoTo check
End If
End Function
Function Fast3NoSpaceCheck(Pos As Long, a$, c$, cl As Long, D$, dl As Long, e$, el As Long, ahead&) As Boolean
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
Pad$ = myUcase(Mid$(a$, Pos, ahead&))
If c$ = Left$(Pad$, cl) Then
    Pos = Pos + cl
    Fast3NoSpaceCheck = True
Exit Function
End If
If D$ = Left$(Pad$, dl) Then
Pos = Pos + dl
Fast3NoSpaceCheck = True
Exit Function
End If
If e$ = Left$(Pad$, el) Then
Pos = Pos + el
Fast3NoSpaceCheck = True
End If

End Function
Function Fast3NoSpace(a$, c$, cl As Long, D$, dl As Long, e$, el As Long, ahead&) As Boolean
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
Pad$ = myUcase(Left$(a$, ahead&))
If c$ = Left$(Pad$, cl) Then
a$ = Mid$(a$, MyTrimLi(a$, cl + 1))
Fast3NoSpace = True
Exit Function
End If
If D$ = Left$(Pad$, dl) Then
a$ = Mid$(a$, MyTrimLi(a$, dl + 1))
Fast3NoSpace = True
Exit Function
End If
If e$ = Left$(Pad$, el) Then
a$ = Mid$(a$, MyTrimLi(a$, el + 1))
Fast3NoSpace = True
End If

End Function
Function Fast3Label(a$, c$, cl As Long, D$, dl As Long, e$, el As Long, ahead&) As Boolean
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then Exit Function
Pad$ = myUcase(Mid$(a$, i, ahead&)) + " "
If j - i >= cl - 1 Then
If InStr(c$, Left$(Pad$, cl)) > 0 Then
If Mid$(Pad$, cl + 1, 1) Like "[0-9+.\( @-]" Then
a$ = Mid$(a$, MyTrimLi(a$, i + cl))
Fast3Label = True
End If
Exit Function
End If
End If
If j - i >= dl - 1 Then
If InStr(D$, Left$(Pad$, dl)) > 0 Then
If Mid$(Pad$, dl + 1, 1) Like "[0-9+.\( @-]" Then
a$ = Mid$(a$, MyTrimLi(a$, i + dl))
Fast3Label = True
End If
Exit Function
End If
End If
If j - i >= el - 1 Then
If InStr(e$, Left$(Pad$, el)) > 0 Then
If Mid$(Pad$, el + 1, 1) Like "[0-9+.\( @-]" Then
a$ = Mid$(a$, MyTrimLi(a$, i + el))
Fast3Label = True
End If
End If
End If
End Function
Function Fast2VarNoTrim(a$, c$, cl As Long, D$, dl As Long, ahead&, Pos As Long) As Boolean
' need space
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then Exit Function
Pad$ = myUcase(Mid$(a$, i, ahead&)) + " "
If j - i >= cl - 1 Then
If InStr(c$, Left$(Pad$, cl)) > 0 Then
If Mid$(Pad$, cl + 1, 1) = " " Then
Mid$(a$, i) = space$(cl)
Pos = 1
Fast2VarNoTrim = True
Exit Function
End If
End If
End If
If dl = 0 Then Exit Function
If j - i >= dl - 1 Then
If InStr(D$, Left$(Pad$, dl)) > 0 Then
If Mid$(Pad$, dl + 1, 1) = " " Then
Mid$(a$, i) = space$(dl)
Pos = 2
Fast2VarNoTrim = True
End If
End If
End If
End Function
Function Fast2Varl(a$, c$, cl As Long, D$, dl As Long, ahead&, ByVal f As Long) As Boolean
' use F if dl>0
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then a$ = vbNullString: Exit Function
Pad$ = myUcase(Mid$(a$, i, ahead&))
If f = 2 Then GoTo there
If j - i >= cl - 1 Then
If Left$(Pad$, cl) = c$ Then
a$ = Mid$(a$, MyTrimLi(a$, i + cl))
Fast2Varl = True
Exit Function
End If
End If
If dl = 0 Or f = 1 Then Exit Function
there:
If j - i >= dl - 1 Then
If Left$(Pad$, dl) = D$ Then
a$ = Mid$(a$, MyTrimLi(a$, i + dl))
Fast2Varl = True
End If
End If
End Function
Function Fast2VarSpace(a$, c$, cl As Long, D$, dl As Long, ahead&) As Boolean
' need always space
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then a$ = vbNullString: Exit Function
Pad$ = myUcase(Mid$(a$, i, ahead&))
If j - i >= cl - 1 Then
If Left$(Pad$, cl) = c$ Then
If Mid$(Pad$, cl + 1, 1) = " " Then
a$ = Mid$(a$, MyTrimLi(a$, i + cl))
Fast2VarSpace = True
Exit Function
End If
End If
End If
If dl = 0 Then Exit Function
If j - i >= dl - 1 Then
If Left$(Pad$, dl) = D$ Then
If Mid$(Pad$, dl + 1, 1) = " " Then
a$ = Mid$(a$, MyTrimLi(a$, i + dl))
Fast2VarSpace = True
End If
End If
End If
End Function
Function Fast3Varl(a$, c$, cl As Long, D$, dl As Long, e$, el As Long, ahead&) As Boolean
Dim i As Long, Pad$, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then a$ = vbNullString: Exit Function
Pad$ = myUcase(Mid$(a$, i, ahead&))
If j - i >= cl - 1 Then
If Left$(Pad$, cl) = c$ Then
a$ = Mid$(a$, MyTrimLi(a$, i + cl))
Fast3Varl = True
Exit Function
End If
End If
If dl = 0 Then Exit Function
If j - i >= dl - 1 Then
If Left$(Pad$, dl) = D$ Then
a$ = Mid$(a$, MyTrimLi(a$, i + dl))
Fast3Varl = True
End If
End If
If el = 0 Then Exit Function
If j - i >= el - 1 Then
If Left$(Pad$, el) = e$ Then
a$ = Mid$(a$, MyTrimLi(a$, i + el))
Fast3Varl = True
End If
End If
End Function

Function ConstNew(bstack As basetask, B$, w$, makeallglobal As Boolean, Lang As Long) As Boolean
Dim p As Variant, ii As Long, ss$, what As Long
    Dim cv As Constant
    Do
    what = IsLabel(bstack, B$, w$)
    Select Case what
    Case 1, 4
        If GetlocalVar(w$, ii) Then
        MyEr "Variable exist as local", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ТОПИЙч"
        ConstNew = False
        Exit Function
        ElseIf GetVar(bstack, w$, ii, True) And makeallglobal Then
        If bstack.Vars < ii Then
        MyEr "Variable exist as global", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ЦЕМИЙч"
        ConstNew = False
        
        Exit Function
        End If
        End If
        p = 0
    If IsLabelSymbolNew(B$, "ыс", "AS", Lang) Then
    
               If IsLabelSymbolNew(B$, "аяихлос", "DECIMAL", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then
                    If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    Else
                        missNumber
                        Exit Function
                    End If
                    p = CDec(p)
            ElseIf IsLabelSymbolNew(B$, "дипкос", "DOUBLE", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then
                    If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    Else
                        missNumber
                        Exit Function
                    End If
                p = CDbl(p)
            ElseIf IsLabelSymbolNew(B$, "апкос", "SINGLE", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then
                    If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    Else
                        missNumber
                        Exit Function
                    End If
                p = CSng(p)
            ElseIf IsLabelSymbolNew(B$, "коцийос", "BOOLEAN", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then
                    If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    Else
                        missNumber
                        Exit Function
                    End If
                p = CBool(p)
            ElseIf IsLabelSymbolNew(B$, "лайяус", "LONG", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then
                    If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    Else
                        missNumber
                        Exit Function
                    End If
                p = CLng(p)
            ElseIf IsLabelSymbolNew(B$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then
                    If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    Else
                        missNumber
                        Exit Function
                    End If
                p = CInt(p)
            ElseIf IsLabelSymbolNew(B$, "коцистийо", "CURRENCY", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then
                    If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    Else
                        missNumber
                        Exit Function
                    End If

                p = CCur(p)
            Else
            MyEr "No type found", "ДЕМ БЯчЙА ТЩПО"
            Exit Function
            End If
            If what = 4 Then
            If Typename(p) <> "boolean" Then p = Int(p)
            End If
            GoTo conthere
    ElseIf FastSymbol(B$, "=") Then
                If Not IsExp(bstack, B$, p) Then MissNumExpr: Exit Function
            ElseIf GetVar(bstack, w$, ii, True) Then
                p = var(ii)
            Else
                
                MyEr "No global const found", "дЕМ БЯщХГЙЕ ЦЕМИЙч СТАХЕЯч"
            Exit Function
            End If
conthere:
            If Not bstack.lastobj Is Nothing Then
makelambda:
            If Typename(bstack.lastobj) = "lambda" Then
            Set cv = New Constant
            cv.DefineOnce bstack.lastobj
            Set bstack.lastobj = Nothing
            ii = globalvar(w$, p, , makeallglobal)
            If makeallglobal Or here$ = vbNullString Then
             GlobalSub w$ + "()", "", , , ii
            Else
            GlobalSub here$ + "." + w$ + "()", "", , , ii
            End If
            Else
            Set bstack.lastobj = Nothing
            Set cv = New Constant
            ii = globalvar(w$, p, , makeallglobal)
            cv.DefineOnce p
            End If
            Else
            Set bstack.lastobj = Nothing
            Set cv = New Constant
            If what = 4 Then cv.DefineOnce MyRound(p) Else cv.DefineOnce p
            ii = globalvar(w$, p, , makeallglobal)
            End If
            Set var(ii) = cv
            ConstNew = True
    Case 3
        If GetlocalVar(w$, ii) Then
        MyEr "Variable exist as local", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ТОПИЙч"
        ConstNew = False
        Exit Function
        ElseIf GetVar(bstack, w$, ii, True) And makeallglobal Then
        If bstack.Vars < ii Then
        MyEr "Variable exist as global", "г ЛЕТАБКГТч УПэЯВЕИ ЫР ЦЕМИЙч"
        ConstNew = False
        
        Exit Function
        End If
        End If
              If FastSymbol(B$, "=") Then
                If Not IsStrExp(bstack, B$, ss$) Then MissStringExpr: Exit Function
            ElseIf GetVar(bstack, w$, ii, True) Then
                ss$ = var(ii)
            Else
                
                MyEr "No global const found", "дЕМ БЯщХГЙЕ ЦЕМИЙч СТАХЕЯч"
            Exit Function
            End If
             If Not bstack.lastobj Is Nothing Then GoTo makelambda
            Set bstack.lastobj = Nothing
            Set cv = New Constant
            cv.DefineOnce ss$
            ii = globalvar(w$, p, , makeallglobal)
            Set var(ii) = cv
            ConstNew = True
    Case Else
        MyErMacro B$, "No constant for that type " + w$, "╪ВИ СТАХЕЯч ЦИА АУТЭ ТО ТЩПО " + w$
        Exit Function
    End Select
 Loop Until Not FastSymbol(B$, ",")
End Function

Sub ConnectStatic(bstack As basetask, ByVal what$)
''what$ = "%_" + what$
Dim vvv As Variant, Parent As basetask, parent1 As basetask
Set Parent = bstack.Parent
Do While Not Parent Is Nothing
If Parent.StaticInUse$ = what$ Then

   Set bstack.StaticCollection = Parent.StaticCollection
    bstack.StaticInUse$ = what$
     bstack.OriginalCode = Parent.OriginalCode
    Exit Do
End If
Set Parent = Parent.Parent
Loop
Set Parent = Nothing
End Sub
Function Execute(bstack As basetask, B$, once As Boolean, Optional linebyline As Boolean, Optional loopthis As Boolean = False, Optional noblock As Boolean = True, Optional restartmodule As Boolean, Optional onlyone As Boolean = False) As Long
Dim di As Object, nchr As Integer
Set di = bstack.Owner
Dim myobject As Object, usehandler As mHandler, usehandler1 As mHandler
checkbreak bstack, B$, once
Dim pppp As mArray, bb$, ec$, i As Long, jump As Boolean, slct As Long, sp As Variant, sw$, ok As Boolean, IFCTRL As Long
'If linebyline Then
If loopthis Or linebyline And Not noblock Then IFCTRL = bstack.IFCTRL: jump = bstack.jump
Dim w$, LLL As Long, sss As Long, v As Long, p As Variant, ss$, lbl As Boolean, st As Variant, bs As basetask
Dim sX, VarStat As Boolean, NewStat As Boolean
Dim x1 As Long, y1 As Long, x2 As Long, y2 As Long, SBB$, nd&, Lang As Long, kolpo As Boolean, iscom As Boolean
Dim temphere$, one As Boolean

If loopthis Then Execute = 2 Else Execute = 1
againexecute:
sss = Len(B$): lbl = True

Do While Len(B$) <> LLL
    If NOEXECUTION Then
    NOEXECUTION = False
    MyClear bstack, ""
    NOEXECUTION = True
        MyEr "", ""
        k1 = 0
        REFRESHRATE = 40
        SLOW = False
        extreme = False
        If MOUT Then
            TaskMaster.Dispose
            'NOEXECUTION = False
            MOUT = False
            MKEY$ = "@Start" + Chr$(13)
            'b$ = "@Start : error {}"
            once = False
            Prefresh(GetCode(bstack.Owner)).k1 = 0
            MyDoEvents0 bstack.Owner
            MyEr "", ""
            LLL = 0
            'NOEXECUTION = True
            Execute = 0
            Exit Function
        Else
            myesc B$
            If once Then
                B$ = vbCrLf + B$   ' this cause troubles...
                Execute = 0
            Else
                once = True
                Execute = 1
            End If
            Exit Function
        End If
    End If
    If trace Or SLOW Then
       If WaitShow > 0 Then WaitShow = WaitShow - 1
        refreshGui
        If IsWine Then
            MyDoEvents1 di
        ElseIf trace And Not bypasstrace Then
            MyDoEvents0new di   ' change from simple to version 2\ change to mydoevents0
        Else
            MyDoEvents1 di
        End If
    End If
again1:
    LLL = Len(B$)
    i = 0
    If LLL = 0 Then Exit Do
    If MaybeIsSymbol2(B$, a123, i) Then
        If Mid$(B$, i, 1) = "=" Then
            B$ = Mid$(B$, MyTrimLi(B$, i + 1))
            If (InStr(bstack.originalname$, "(") > 1) Then   ' return from a function no error checking
                x1 = 0
                If GetReturnArray(bstack, x1, B$, p, ss$, pppp) Then Execute = 0: Exit Function
                If once Then Exit Function
                If trace Then
                
                End If
            End If
            GoTo again1
        ElseIf Mid$(B$, i, 1) = "-" Then
            If Mid$(B$, i + 1, 1) = ">" Then
                B$ = Mid$(B$, MyTrimLi(B$, i + 2))
                If (InStr(bstack.originalname$, "(") > 1) Then
                    x1 = 0
                    If Not GetPointer(bstack, B$) Then Execute = 0: Exit Function
                    If bstack.lastpointer Is Nothing Then MissingGroup:   Execute = 0: Exit Function
                    Set bstack.FuncObj = bstack.lastpointer
                    bstack.FuncValue = CLng(0)
                    Set bstack.lastpointer = Nothing
                    Set bstack.lastobj = Nothing
                    If once Then Exit Function
                End If
                GoTo again1
            Else
                SyntaxError
                Execute = 0
                Exit Function
            End If
        Else
            B$ = Mid$(B$, MyTrimLi(B$, i + 1))
            i = 0
            If MaybeIsSymbol3(B$, "}", i) Then
                If myexit(bstack) Then Execute = 1: B$ = vbNullString: Exit Function
                B$ = Mid$(B$, MyTrimLi(B$, i + 1))
                sss = Len(B$)
                GoTo again1
            End If
            If executeblock(Execute, bstack, B$, once, kolpo) Then Exit Function
            '' WHY 4???
            ''If Execute = 4 Then b$ = "{" + b$: Exit Function
            If kolpo Then ec$ = block(B$)
            If Execute = 2 And Len(B$) > 0 Then Exit Function
           
            If Not FastSymbol(B$, "}") Then Execute = 0: Exit Function
            
            If NocharsInLine(B$) Then Exit Function
            sss = LLL  'basic...
            If jump Or IFCTRL = 2 Then
                jump = False
                i = 1
                While FastOperator(B$, vbCrLf, i, 2)
                Wend
                If IsLabelSymbolNew(B$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                If i > 0 Then lbl = True
            End If
            If linebyline Then Exit Do
        End If
    End If

contVarNew:
    If MaybeIsSymbol(B$, "/\'") Then
        NewStat = False
        VarStat = False
        SetNextLine B$
        sss = Len(B$)
        lbl = True
        If jump Or IFCTRL = 2 Then
            If IsLabelSymbolNew(B$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
            If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
        End If
        If sss > 0 Then GoTo again1
        GoTo JUMPHERE
    ElseIf FastSymbol(B$, ":") Then
        NewStat = False
        VarStat = False
        sss = Len(B$)
        If sss > 0 Then GoTo again1
        GoTo JUMPHERE
    End If
jumpforCR:
    If ReplaceCRLFSPACE(B$) Then
        If Len(B$) = 0 Then GoTo JUMPHERE
        NewStat = False
        VarStat = False
        sss = LLL: lbl = True: jump = False
        If IsNumberLabel(B$, w$) Then
        If FastSymbol(B$, vbCrLf, , 2) Then GoTo againexecute
        sss = Len(B$): sss = LLL: lbl = False: jump = False:  If sss = 0 Then sss = 2: B$ = vbCrLf
        End If
    Else
        If lbl Then
            If IsNumberLabel(B$, w$) Then
                If IFCTRL = 2 Then
                    once = False
                    B$ = w$
                    Execute = 2
                    Exit Function
                Else
                    sss = Len(B$): sss = LLL: jump = False: If sss = 0 Then sss = 2: B$ = vbCrLf
                End If
            End If
        End If
    End If
    If VarStat Or NewStat Then
        If FastSymbol(B$, ",") Then
            sss = LLL: lbl = False: jump = False
        ElseIf FastOperator(B$, ":", 1) Then
entry1:
            NewStat = False
            VarStat = False
            GoTo contconthere
        ElseIf NocharsInLine(B$) Then
            SetNextLine B$
            
            If B$ <> "" Then GoTo again1
        Else
            PlaceAcommaBefore
            Execute = 0
            Exit Function
        End If
        one = True
        iscom = True
        Select Case IsLabelDotSub(temphere$, B$, w$, ss$, Lang, nchr)
        Case 0
            one = False
            VarStat = False
            NewStat = False
            GoTo contconthere
        Case 1234
            VarStat = False
            NewStat = False
            GoTo contconthere
        Case 1
            If Left$(w$, 1) = "." Then
                ss$ = w$
                IsLabel bstack, ss$, w$
            End If
            GoTo VarOnly
        Case 2
            noref
            Execute = 0
            Exit Function
        Case 3
            GoTo contcase3
        Case 4
            GoTo contcase4
        Case 5
            GoTo contcase5
        Case 6
            GoTo contcase6
        Case 7
            GoTo contcase7
        Case Else
            GoTo errstat
        End Select
    ElseIf FastSymbol(B$, ":") Then
contconthere:
        NewStat = False: VarStat = False: sss = LLL: lbl = False: jump = False:  If sss = 0 Then sss = 2: B$ = vbCrLf
    End If
again2:
    If lookOne(B$, "@") Then w$ = vbNullString: GoTo parsecommand
again3:
one = True
    x1 = IsLabelDotSub(temphere$, B$, w$, ss$, Lang, nchr)
again4:
    Select Case x1
    Case 0
        If FastSymbol(B$, "(") Then
            i = 1
            x1 = 0
            While Len(aheadstatus(B$, False, i)) > 0
                x1 = i - 1
                i = i + 1
            Wend
            ss$ = Left$(B$, x1)
            If x1 > 0 And MyTrim(ss$) <> vbNullString Then
                Mid$(B$, 1, x1) = space$(x1)
                If FastSymbol(B$, ")", True) Then
                    If FastSymbol(B$, "=") Then
                        If IsExp(bstack, B$, p) Then
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is mArray Then
                                Set pppp = bstack.lastobj
                                GoTo wehavearray
                                ElseIf TypeOf bstack.lastobj Is mHandler Then
                                    If CheckIsmArray(bstack.lastobj) Then
                                    
                                      Set usehandler = bstack.lastobj
                                      
                                        Set pppp = usehandler.objref
wehavearray:
                                        Set bstack.lastobj = Nothing
                                        Set myobject = bstack.soros
                                        Set bstack.Sorosref = New mStiva
                                        bstack.soros.MergeBottomCopyArray pppp
                                        If Not MyRead(1, bstack, ss$, 1) Then
                                            Set bstack.lastobj = Nothing
                                            Set bstack.Sorosref = myobject
                                            Execute = 0
                                            Exit Function
                                        End If
                                        Set bstack.lastobj = Nothing
                                        Set bstack.Sorosref = myobject
                                        Set myobject = Nothing
                                        GoTo loopagain
                                    Else
a123321:                                    NotArray
                                            Execute = 0
                                            Exit Function
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        GoTo a123321
        End If
        one = False
    Case 1234
        GoTo jumpforCR
    Case 2
        NoRef2
        Execute = 0
        Exit Function
    Case 1
        If sss = LLL Then
            If lbl Then
                If lookA123(B$) Then
                    sw$ = GetNextLine(B$)
                    LLL = Len(B$): sss = LLL: GoTo again1
                End If
            End If
            If Trim$(w$) = vbNullString Then
                Execute = 1
                Exit Function
            End If
            If trace Then
                If Not bypasstrace Then
tragain:
                    If Not TraceThis(bstack, di, B$, ss$, SBB$) Then Execute = 0: Exit Function
                    If Len(tracecode) > 0 Then
                    ss$ = tracecode
                    tracecode = vbNullString
                    bypasstrace = True

                     If executeblock(Execute, bstack, ss$, once, kolpo, , , True) Then bypasstrace = False: Exit Function

                     bypasstrace = False
                     tracecode = vbNullString
                    GoTo tragain
                   
                    End If
                End If
            End If
            iscom = False
            If Left$(w$, 1) = "." Then
               '  ss$ = w$
                 
               ' IsLabel bstack, ss$, w$
               If Not expanddot(bstack, w$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
               Execute = 0
               Exit Function
               End If
                iscom = True
               
                lbl = False
                GoTo VarOnly
            ElseIf Len(temphere$) > 0 Then
                iscom = True
                lbl = False
                VarStat = True
                GoTo VarOnly
            ElseIf Not NoOptimum Then
                v = 0
                If MaybeIsSymbolNoSpace(B$, "[+/*~-]") Then
                    GoTo VarOnly
                ElseIf MaybeIsSymbol(B$, "<=_") Then
                    GoTo VarOnly
                ElseIf Not comhash.Find2(w$, i, v) Then
                    iscom = True
                    lbl = False
                    GoTo VarOnly
                ElseIf i <> 0 Then
                    If IsBadCodePtr(i) = 0 Then
                        On Error GoTo myerr1
                        If CallByPtr(i, bstack, B$, Lang) Then
                            LLL = 0 ' maybe b$ changed inside the call if LLL=len(b$) then we exit from loop
                            GoTo conthere222
                        Else
myerr1:
                            If bstack Is Nothing Then Exit Function
                            If LastErNum1 = -1 And bstack.IamThread Then Execute = 1 Else Execute = 0
                            If Err Then GoTo errstat0 Else Exit Function
                        End If
                        On Error GoTo errstat0
                    Else
                        GoTo parsecommand
                    End If
                ElseIf v <> 0 Then
                    On v GoTo contif, ContElse, contElseIf, contSelect, ContTry, ForCont, contNext, contRefr, contWhile, ContRepeat, ContGoto, contSub, autogosub, ContOn, contLoop, contBreak, ContContinue, ContRestart, ContReturn, ContEnd, ContExit, ContInline, contUpdate, contThread, contAfter, contPart, contStatic, contEvery, contTask, ContScan, contTarg, BypassGlobalComm, BypassComm, contNegLocal, contNegGlobal, makeconst, VarOnly, contCall, contBinary, contHALT, contSTOP, contDraw
                    Execute = 0: Exit Function
BypassGlobalComm:
                    iscom = True
                    GoTo parsecommand
BypassComm:
                    If bstack.commnum = 0 Then
                        w$ = "@" + w$
                    ElseIf bstack.commnum > comhash.index Then
                        w$ = "@" + w$
                    Else
                        iscom = True
                    End If
                    GoTo parsecommand
                Else
                    GoTo parsecommand
                End If
            End If
            Select Case w$
            Case "STOP", "диайопг"
contSTOP:
                If HaltLevel = 0 Then
                If trace Then GoTo notask
                
                If MsgBoxN("[STOP] л2000 - Temporary Execution Stop / пЯОСЫЯИМч йЯэТГСГ еЙТщКЕСГР" & vbCrLf & "use Exit to Return / ВЯГСИЛОПОъГСЕ ТО щНОДОР ЦИА ЕПИСТЯОЖч", vbYesNo, MesTitle$) = vbYes Then
notask:
                Set bs = bstack
                
                HaltLevel = HaltLevel + 1
                
                crNew bstack, players(GetCode(bstack.Owner))
                Form1.MyPrompt "", UserName & " (exit)>", bstack
                HaltLevel = HaltLevel - 1
                Set bstack = bs
                If ExTarget Then
                NOEXECUTION = True
                ElseIf HaltLevel < 0 Then
                    B$ = "START"
                    Execute = 1
                    ok = True
                    Exit Do
                Else
                    ExTarget = False
                    MOUT = False
                End If

                End If
                Else
                    
                  ExTarget = False
                    MOUT = False
                End If
            Case "HALT", "акт"
contHALT:
                ss$ = here$
                HaltLevel = HaltLevel + 1
                Form1.MyPrompt "", ">>"
                HaltLevel = HaltLevel - 1
                If HaltLevel < 0 Then
                    B$ = "START"
                    Execute = 1
                    ok = True
                    Exit Do
                Else
                    here$ = ss$
                    ExTarget = False
                    MOUT = False
                End If
            Case "TARGET", "стовос"
contTarg:
                targetsMyExec Execute, B$, bb$, v, di, w$, bstack, VarStat, temphere$
                If Execute = 0 Then Exit Function
            Case "SCAN", "саяысе"
ContScan:
                ClearJoyAll
                PollJoypadk
                If GetForegroundWindow <> Form1.hWnd Or Not Targets Then
                    If IsExp(bstack, B$, p, , True) Then
                    End If
                    MyDoEvents0 di
                    If Fkey > 0 Then
                        If FK$(Fkey) <> "" Then
                            If bstack.IamChild And bstack.IamAnEvent And Fkey = 13 And lastAboutHTitle <> "" Then
                                abt = True
                                Fkey = 0
                                vHelp
                            Else
                                ss$ = FK$(Fkey)
                                Fkey = 0
                                If TaskMaster Is Nothing Then
                                If Not interpret(Basestack1, ss$) Then
                                    Execute = 0
                                    Exit Function
                                End If
                                Else
                                TaskMaster.StopProcess
                                If Not interpret(Basestack1, ss$) Then
                                    Execute = 0
                                End If
                                TaskMaster.StartProcess
                                If Execute = 0 Then Exit Function
                                End If
                            End If
                        End If
                        Fkey = 0
                    End If
                Else
                    If di.Visible = False Then di.Visible = True
                        NoAction = False
                        nomore = True
                        If IsExp(bstack, B$, p, , True) Then
                        sX = Timer + p
                        x1 = Form1.lockme
                        If x1 Then UnHook Form1.hWnd
                            Form1.lockme = False
                            Do
                                y1 = BLOCKkey
                                BLOCKkey = True
                                MyDoEvents0 Form1
                                BLOCKkey = y1
                                If exWnd <> 0 Then ss$ = MyTitle$(bstack)
                                If Fkey > 0 Then
                                    If FK$(Fkey) <> "" Then
                                        B$ = FK$(Fkey) + B$
                                        Fkey = 0
                                        Exit Do
                                    End If
                                End If
                            Loop Until NoAction Or Timer > sX Or myexit(bstack) Or bstack.IamThread
                            Form1.lockme = x1
                            If x1 And GetForegroundWindow = Form1.hWnd Then Form1.hookme Form1.TEXT1.glistN
                        Else
                        Do
                            MyDoEvents0 Form1
                            If exWnd <> 0 Then ss$ = MyTitle$(bstack)
                            If Fkey > 0 Then
                                If FK$(Fkey) <> "" Then
                                    B$ = FK$(Fkey) + B$
                                    Fkey = 0
                                    Exit Do
                                End If
                            End If
                        Loop Until NoAction Or myexit(bstack)
                    End If
                    nomore = False
                End If
            Case "REFRESH", "амамеысг"
contRefr:
                If IsLabelSymbolNew(B$, "дойилг", "TEST", Lang) Then
                    MyDoEvents1 di
                ElseIf IsExp(bstack, B$, p, , True) Then
                    With Prefresh(GetCode(di))
                        If p = 0# Then
                            .k1 = uintnew(timeGetTime + REFRESHRATE)
                        Else
                            REFRESHRATE = uintnew(p)
                            .k1 = 0
                            bstack.RRCOUNTER = 0
                            If bstack.IamThread Then
                                MyDoEvents0 di
                            Else
                                MyDoEvents1 di
                            End If
                        End If
                    End With
                Else
                    Prefresh(GetCode(di)).RRCOUNTER = 0
                    MyDoEvents0 di
                    bstack.RRCOUNTER = 0
                End If
                If exWnd <> 0 Then
                    ss$ = MyTitle$(bstack)
                End If
                If Fkey > 0 Then If FK$(Fkey) <> "" Then MKEY$ = MKEY$ & FK$(Fkey)
                Fkey = 0
            Case "статийг", "статийес", "STATIC"
contStatic:
                StaticNew bstack, B$, w$, Lang
            Case "мгла", "THREAD"
contThread:
                ss$ = vbNullString
                If IsLabelSymbolNewExp(B$, "хесе", "SET", Lang, ss$) Then
                    If bstack.Process Is Nothing Then GoTo dothesame
                    If Not StaticNew(bstack, B$, w$, Lang) Then Execute = 0: Exit Function
                ElseIf IsLabelSymbolNewExp(B$, "ауто", "THIS", Lang, ss$) Then
                    If bstack.Process Is Nothing Then
dothesame:
                    B$ = vbNullString
                    NoThisInThread
                    Execute = 0: Exit Function
                    once = False
                ElseIf IsLabelSymbolNewExp(B$, "сбгсе", "ERASE", Lang, ss$) Then
                    Set bstack.Process.Process = Nothing
                    B$ = vbNullString ' get lost now
                ElseIf IsLabelSymbolNewExp(B$, "йяата", "HOLD", Lang, ss$) Then
                    bstack.Process.Busy = True
                ElseIf IsLabelSymbolNewExp(B$, "нейима", "RESTART", Lang, ss$) Then
                    bstack.Process.Busy = False
                    B$ = vbNullString
                ElseIf IsLabelSymbolNewExp(B$, "йахе", "INTERVAL", Lang, ss$) Then
                    If IsExp(bstack, B$, p, , True) Then
                        If p < 2 Then p = 2
                            bstack.Process.Interval = p
                        Else
                            B$ = vbNullString
                            MisInterval
                            Execute = 0: Exit Function
                        End If
                    Else
                        B$ = vbNullString
                        NoClauseInThread
                        Execute = 0: Exit Function
                    End If
                Else
                    If linebyline Then
                        B$ = w$ + " " + B$
                        Execute = Execute(bstack, B$, once, False)
                        Exit Do
                    End If
                    If Not MyThread(bstack, B$, Lang) Then Execute = 0: Exit Function
                    If Left$(here$ & "#", 1) = "!" Then here$ = Mid$(here$, 2)
                End If
            Case "LOOP", "йуйкийа"
contLoop:
                If noblock Then
                loopthis = True
                    Execute = 2
                    If myexit(bstack) Then Execute = 1: B$ = vbNullString: Exit Function
                Else
                    Execute = 5: Exit Function
                End If
                
            Case "BREAK", "диейоье"
contBreak:
            restartmodule = False
            'If bstack.SubLevel > 0 Then
            '        WaitShow = 0
            '         PopStagePartContinue2 bstack, bstack.RetStackTotal
            '        once = False
            '        b$ = Chr$(0)
            '        If bstack.RetStackTotal = 0 Then Execute = 1 Else Execute = 2
            'Else
                B$ = "BREAK"
                once = True
                Execute = 2
             '   End If
                
                Exit Function
            Case "CONTINUE", "сумевисе"
ContContinue:
 restartmodule = False


                If Execute <> 2 Then
                    B$ = "CONTINUE"
                    once = True
                    Execute = 3
                Else
                    B$ = vbNullString
                End If
                Exit Function
            Case "RESTART", "нейима"
ContRestart:
                B$ = vbNullString
                If restartmodule Then
             restartmodule = False
                loopthis = True
                End If
                Execute = 2
                Exit Function
            Case "RETURN", "епистяожг"
ContReturn:
                LastErNum = 0
                If IsExp(bstack, B$, p) Then
                    If bstack.lastobj Is Nothing Then
                        BadUseofReturn
                        Execute = 0
                        Exit Function
                    ElseIf Typename(bstack.lastobj) = mHdlr Then
                        Select Case bstack.lastobj.t1
                        Case 1
                            If ChangeValues(bstack, B$) Then GoTo loopcontinue
                        Case 2
                            If ChangeValuesMem(bstack, B$, Lang) Then GoTo loopcontinue
                        Case 3
                            If ChangeValuesArray(bstack, B$) Then GoTo loopcontinue
                        Case 4
                            NoProperObject
                            Set bstack.lastobj = Nothing
                            Execute = 0
                            Exit Function
                         End Select
                     End If
                     BadUseofReturn
                     Execute = 0
                     Exit Function
                ElseIf IsStrExp(bstack, B$, ss$) Then
                    append_table bstack, ss$, B$, True, Lang
                Else
                    If LastErNum <> 0 Then
                        LLL = Len(B$) - 1
                    Else
                        If bstack.RetStackTotal = 0 Then
                            stackproblem
                            Execute = 0
                            Exit Function
                        Else
                            PopStagePartContinue2 bstack, bstack.RetStackTotal
                        End If
                        once = False
                        B$ = Chr$(0)
                        Execute = 2
                        Exit Function
                    End If
                End If
            Case "END", "текос"
ContEnd:
                WaitShow = 0
                w$ = vbNullString
                If IsLabelSymbolNewExp(B$, "ам", "IF", Lang, w$) Then
                    If bstack.UseofIf > 0 Then
                        If Not HaveMark2(bstack) Then
                            MissIF
                            Execute = 0: Exit Function
                        End If
                        bstack.UseofIf = bstack.UseofIf - 1
                    Else
                            MissIF
                            Execute = 0: Exit Function
                    End If
                        lbl = False
                        If Len(B$) > 0 Then
                        If Left$(B$, 2) = vbCrLf Then lbl = True
                        End If
                ElseIf IsLabelSymbolNewExp(B$, "яоутимас", "SUB", Lang, w$) Then
                    once = False
                    B$ = Chr$(0)
                    Execute = 2
                    Exit Function
                ElseIf IsLabelSymbolNewExp(B$, "епикоцгс", "SELECT", Lang, w$) Then
                    NoCommandOrBlock
                    Execute = 1
                    Exit Function
                ElseIf IsLabelSymbolNewExp(B$, "сумаятгсгс", "FUNCTION", Lang, w$) Then
                    once = False
                    B$ = Chr$(0)
                    Execute = 2
                    Exit Function
                Else
                    B$ = vbNullString   ' no more syntax error
                    Execute = 1
                    MOUT = True
                    Exit Function
                End If
            Case "енодос", "EXIT"
         ''\\"SUB", "яоутима"
ContExit:
                ss$ = vbNullString
                If IsLabelSymbolNewExp(B$, "яоутимас", "SUB", Lang, ss$) Then
                    WaitShow = 0
                     PopStagePartContinue2 bstack, bstack.RetStackTotal
                    once = False
                    B$ = Chr$(0)
                    If bstack.RetStackTotal = 0 Then Execute = 1 Else Execute = 2
                    Exit Function
                ElseIf IsLabelSymbolNewExp(B$, "сумаятгсгс", "FUNCTION", Lang, ss$) Then
                WaitShow = 0
                     PopStagePartContinue2 bstack, bstack.RetStackTotal
                    once = False
                    B$ = Chr$(0)
                    If bstack.RetStackTotal = 0 Then Execute = 1 Else Execute = 2
                    Exit Function
                ElseIf IsLabelSymbolNewExp(B$, "циа", "FOR", Lang, ss$) Then
exitfor:

                    once = False
                    PopStagePartContinue2 bstack, bstack.RetStackTotal
                    i = FastPureLabel(B$, w$)
                    If i = 0 Then
                        i = IsNumberLabel(B$, w$)
                        If i = 0 Then
                            B$ = "NEXT"
                            Execute = 2
                        Else
                            B$ = w$
                            Execute = 12
                        End If
                    ElseIf i = 1 Then
                        B$ = w$
                        Execute = 12
                    Else
                    
                    
                    If Execute <> 2 Then Execute = 1 Else Execute = 3
                   restartmodule = False
                     B$ = vbNullString
                    once = True
                    Exit Function
                        B$ = "NEXT"
                        Execute = 2
                    End If
                    Exit Function
                ElseIf IsLabelSymbolNewExp(B$, "ейтупысгс", "PRINTING", Lang, ss$) Then
                    If bstack.toprinter Then
                        pnum = 0
                        oprinter.ClearUp
                        Form1.PrinterDocument1.Picture = LoadPicture("")
                        Set bstack.Owner = Form1.DIS
                        bstack.toprinter = False
                        SetNormal bstack.Owner
                    End If
                    B$ = vbNullString
                    once = True
                Else
                    If Execute <> 2 Then Execute = 1 Else Execute = 3
                   restartmodule = False
                    
                    B$ = vbNullString
                    once = True
                    Exit Function
                End If
            Case "FOR", "циа"
ForCont:
                If linebyline Then
                   If Not B$ = vbNullString Then
                    If AscW(B$) <> 32 Then
                        B$ = w$ + " " + B$
                    Else
                        B$ = w$ + B$
                    End If
                    Execute = Execute(bstack, B$, once, False)
                    Exit Do
                   Else
                   SyntaxError
                   Execute = 0
                   Exit Function
                   
                   End If
                End If
                If once = True Then Execute = 0: Exit Function
                If Len(B$) < 129 Then
                    x1 = Abs(IsLabelBig(bstack, B$, w$, , SBB$, , True))
                Else
                    ss$ = Left$(B$, 128)
                    ok = True
                    x1 = Abs(IsLabelBig(bstack, ss$, w$, , SBB$, , ok))
                    If Len(ss$) > 0 Then
                        If ok Then
                            B$ = Mid$(B$, 129 - Len(ss$))
                        ElseIf Len(ss$) <= 128 Then
                            Mid$(B$, 129 - Len(ss$), Len(ss$)) = ss$
                            Mid$(B$, 1, 129 - Len(ss$)) = space$(128 - Len(ss$))
                        Else
                            B$ = ss$ + Mid$(B$, 129)
                        End If
                    Else
                        x1 = Abs(IsLabelBig(bstack, B$, w$, , SBB$, , True))
                    End If
                End If
againfor948:
                nd& = x1
                Select Case x1
                Case 1, 4 'FLOATING POINT
                    If MaybeIsSymbol(B$, "<=") Then
                        If FastSymbol(B$, "=") Then
                        If bstack.StaticCollection Is Nothing Then GoTo cont10456
                            If bstack.ExistVar(w$) Then
                                x2 = -1
                                x1 = nd&
                                If IsExp(bstack, B$, p) Then
                                    If nd& = 4 Then p = MyRound(p) Else p = MyRound(p, 28)
                                    bstack.SetVar w$, p
                                    GoTo eos
                                Else
                                    Execute = 0
                                    Exit Function
                                End If
                            Else
cont10456:
                                x1 = Abs(GetlocalVar(w$, x2)) * x1
                            End If
                        ElseIf FastSymbol(B$, "<=", , 2) Then
                            x1 = Abs(GetVar(bstack, w$, x2, True)) * x1
                        End If
                        If x1 Then
                            If VarType(var(x2)) = vbLong Then
                                x1 = 8
                                If IsExp(bstack, B$, p) Then
                                    On Error Resume Next
                                    If x2 < 0 Then
                                        bstack.SetVar w$, CLng(Int(p))
                                    Else
                                        var(x2) = CLng(Int(p))
                                    End If
                                    If Err.Number = 6 Then
                                        Execute = 0
                                        OverflowLong
                                        Exit Function
                                    End If
                                End If
                            ElseIf VarType(var(x2)) = vbInteger Then
                                x1 = 16
                                If IsExp(bstack, B$, p) Then
                                    On Error Resume Next
                                    If x2 < 0 Then
                                        bstack.SetVar w$, CLng(Int(p))
                                    Else
                                        var(x2) = CInt(Int(p))
                                    End If
                                    If Err.Number = 6 Then
                                        Execute = 0
                                        OverflowLong True
                                        Exit Function
                                    End If
                                End If
                            Else
                                If IsExp(bstack, B$, p) Then
                                    If VarType(var(x2)) <> VarType(p) Then
                                        Select Case VarType(var(x2))
                                        Case vbInteger
                                            p = CInt(p)
                                        Case vbLong
                                            p = CLng(p)
                                        Case vbSingle
                                            p = CSng(p)
                                        Case vbCurrency
                                            p = CCur(p)
                                        Case vbDecimal
                                            p = CDec(p)
                                        Case Else
                                            p = CInt(p)
                                        End Select
                                    End If
                                    If x1 = 1 Then
                                        var(x2) = MyRound(p, 28)
                                    Else
                                        var(x2) = MyRound(p)
                                    End If
                                End If
                            End If
                        ElseIf IsExp(bstack, B$, p) Then
                            If nd& > 1 Then p = MyRound(p)
                            x2 = globalvar(w$, p, , VarStat, temphere$)
                            x1 = nd&
                        Else
                            Execute = 0
                            Exit Function
                        End If
eos:
                        If IsLabelSymbolNew(B$, "еыс", "TO", Lang) Then
                            If IsExp(bstack, B$, sp) Then
                            If nd& = 4 Then
                                sp = MyRound(sp, 0)
                                p = MyRound(p)
                            ElseIf x1 > 1 Then
                                sp = Int(sp)
                                p = Int(p)
                            ElseIf VarType(p) = vbDouble Then
                                If RoundDouble Then sp = MyRound(sp, 13)
                                p = MyRound(p, 28)
                            End If
                            If x1 > 1 Then sp = Round(sp, 0)
                            ' like BASIC FOR
                            If ForLikeBasic Then
                                st = 1
                            Else
                                st = Sgn(sp - p)
                            End If
                            If IsLabelSymbolNew(B$, "ама", "STEP", Lang) Then
                                If VarType(p) = vbSingle Then st = CSng(1)
                                If IsExp(bstack, B$, st) Then
                                    If VarType(p) = vbSingle Then
                                        st = CSng(st)
                                    End If
                                    If x1 > 1 Then
                                        If x1 >= 8 Then st = Fix(st) Else st = Round(st)
                                    End If
                                    If Not (Sgn(sp - p) = 0 Or st = 0) Then
                                        If ForLikeBasic And Sgn(st) <> Sgn(sp - p) Then
                                            st = 1
                                            sp = p - 1
                                        Else
                                            st = Abs(st)
                                            If sp < p Then
                                                If Fix(st) = st Then
                                                    If st <> 0 Then sp = sp - ((sp - p) Mod st) \ 2
                                                Else
                                                    sX = Abs(((sp - p) / st))
                                                    If sX = MyRound(sX) Then
                                                        sp = sp - MyRound(st / 2)
                                                    ElseIf st < 1 Then
                                                        sp = sp - 1 / Exp(18 - (Log(st + Abs(sp - p))) / Log(10))
                                                    Else
                                                       sp = p - Fix(sX) * st - st / 2
                                                    End If
                                                End If
                                            Else
                                                If Not (Fix(st) = st) Then
                                                    sX = Abs(((sp - p) / st))
                                                    If sX = MyRound(sX) Then
                                                        sp = sp + MyRound(st / 2)
                                                    ElseIf st < 1 Then
                                                        sp = sp + 1 / Exp(18 - (Log(st + Abs(sp - p))) / Log(10))
                                                    Else
                                                        sp = p + Fix(sX) * st + st / 2
                                                    End If
                                                End If
                                            End If
                                            st = Sgn(sp - p) * st
                                        End If
                                    End If
                                Else
                                    Execute = 0
                                    Exit Function
                                End If
                            End If
                            If st = 0 Then sp = p
                            If Not FastSymbol(B$, "{") Then
                            '' this is the old like Basic For
                               ' sw$ = b$
                                i = 1
                                aheadstatusNext B$, i, Lang, ok
                                If Not ok Then
                                MyEr "лissing Next", "дЕМ БЯчЙА ТО еПЭЛЕМО"
                                Execute = 0: Exit Function
                                End If
                                ss$ = Left$(B$, i - 1)
                                 B$ = Mid$(B$, i)
                                sw$ = ss$
                                sX = p
                                y1 = True
                                bstack.RetStack.PushVal 0  ' RETURN LENGTH FROM END OF B$
                                bstack.RetStack.PushStr w$   ' for check if is the right variable
                                TraceStore bstack, nd&, B$, 0
                                
                                slct = bstack.addlen
                                If ForLikeBasic Then
                                    If st > 0 And sp < p Then
                                        'once = False
                                        ss$ = "NEXT " + w$
                                        
                                        'Execute = 2
                                        'GoTo contbasicfor
                                    End If
                                End If
                                GoTo contfor
                            Else
                                y1 = False
                                ss$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                sw$ = ss$
                                TraceStore bstack, nd&, B$, 0
                                slct = bstack.addlen ' reusing slct variable
                                If FastSymbol(B$, "}") Then
                                    If ForLikeBasic Then
                                        If st > 0 And sp < p Then
                                            ss$ = "exit"
                                        End If
                                    End If
contfor:
                                    Execute = 1
                                    ok = False
                                    v = Len(B$)
                                    y2 = 0
                                        If x1 = 1 Then
                                            Do
                                                bstack.addlen = slct
                                                If executeblock(Execute, bstack, ss$, once, ok, , True) Then
                                                    bstack.addlen = nd&
                                                    If Execute <> 1 Then
                                                        If Execute = 2 Then
                                                             SwapStrings B$, ss$
                                                             Exit Function
                                                        Else
                                                            B$ = ss$ + B$: Exit Function
                                                        End If
                                                    End If
                                                Else
                                                    bstack.addlen = nd&
                                                    If Execute = 2 And ss$ <> "" And Not ok Then
                                                        If y1 And ss$ = "NEXT" Then
                                                            Execute = 1: Exit Do
                                                        End If
                                                        SwapStrings B$, ss$
                                                        Exit Function
                                                    ElseIf Execute = 12 Then
                                                        bstack.RetStackDrop 2
                                                        Execute = 2
                                                        B$ = ss$
                                                        Exit Function
                                                    End If
                                                End If
                                                If Not (ok Or MOUT) Or Execute = 3 Then
                                                    Execute = 1
                                                    'If y1 Then ss$ = b$ Else
                                                    ss$ = sw$
                                                    p = p + st
                                                Else
                                                    Exit Do
                                                End If
                                                If myexit(bstack) Then Execute = 1: Exit Do
                                                If x2 < 0 Then
                                                    bstack.SetVar w$, MyRound(p, 10)
                                                Else
                                                    If VarType(var(x2)) <> VarType(p) Then
                                                        Select Case VarType(var(x2))
                                                        Case vbInteger
                                                            var(x2) = CInt(MyRound(p))
                                                        Case vbLong
                                                            var(x2) = CLng(MyRound(p))
                                                        Case vbSingle
                                                            var(x2) = CSng(MyRound(p, 10))
                                                        Case vbCurrency
                                                            var(x2) = CCur(MyRound(p, 10))
                                                        Case vbDecimal
                                                            var(x2) = CDec(MyRound(p, 10))
                                                        Case Else
                                                            var(x2) = CDbl(MyRound(p, 10))
                                                        End Select
                                                    Else
                                                        var(x2) = MyRound(p, 10)
                                                    End If
                                                End If
                                                If st > 0 Then
                                                    If p > sp Then Exit Do
                                                ElseIf st < 0 Then
                                                    If p < sp Then Exit Do
                                                Else
                                                    Exit Do
                                                End If
                                            Loop
                                        ElseIf x1 > 4 Then
                                            On Error GoTo LONGERR
                                            y2 = p
                                            x1 = sp
                                            sss = st
                                            sp = sss
                                            Do
                                                bstack.addlen = slct
                                                If executeblock(Execute, bstack, ss$, once, ok, , True) Then
                                                    bstack.addlen = nd&
                                                    If Execute <> 1 Then
                                                        If Execute = 2 Then
                                                             SwapStrings B$, ss$
                                                             Exit Function
                                                        Else
                                                            B$ = ss$ + B$: Exit Function
                                                        End If
                                                        End If
                                                Else
                                                    
                                                bstack.addlen = nd&
                                                    If Execute = 2 And ss$ <> "" And Not ok Then
                                                        If y1 And ss$ = "NEXT" Then
                                                            Execute = 1: Exit Do
                                                        End If
                                                        SwapStrings B$, ss$
                                                        Exit Function
                                                    ElseIf Execute = 12 Then
                                                        bstack.RetStackDrop 2
                                                        Execute = 2
                                                        B$ = ss$
                                                        Exit Function
                                                    End If
                                                End If
                                                If Not (ok Or MOUT) Or Execute = 3 Then
                                                    Execute = 1
                                                    ss$ = sw$
                                                    y2 = y2 + sss
                                                Else
                                                    Exit Do
                                                End If
                                                If myexit(bstack) Then Execute = 1: Exit Do
                                                On Error Resume Next
                                                If VarType(var(x2)) = vbInteger Then
                                                    var(x2) = CInt(y2)
                                                Else
                                                    var(x2) = y2
                                                End If
                                                On Error GoTo 0
                                                If st > 0 Then
                                                    If y2 > x1 Then Exit Do
                                                ElseIf st < 0 Then
                                                    If y2 < x1 Then Exit Do
                                                Else
                                                    Exit Do
                                                End If
                                            Loop
                                            sss = sp
                                        Else
                                            Do
                                                bstack.addlen = slct
                                                If executeblock(Execute, bstack, ss$, once, ok, , True) Then
                                                    bstack.addlen = nd&
                                                    If Execute <> 1 Then
                                                        If Execute = 2 Then
                                                             SwapStrings B$, ss$
                                                             Exit Function
                                                        Else
                                                            B$ = ss$ + B$: Exit Function
                                                        End If
                                                        End If
                                                Else
                                                bstack.addlen = nd&
                                                    If Execute = 2 And ss$ <> "" And Not ok Then
                                                        If y1 And ss$ = "NEXT" Then
                                                            Execute = 1: Exit Do
                                                        End If
                                                        SwapStrings B$, ss$
                                                        Exit Function
                                                    ElseIf Execute = 12 Then
                                                        bstack.RetStackDrop 2
                                                        Execute = 2
                                                        B$ = ss$
                                                        Exit Function
                                                    End If
                                                End If
                                                If Not (ok Or MOUT) Or Execute = 3 Then
                                                    Execute = 1
                                                    ss$ = sw$
                                                    p = p + st
                                                Else
                                                    Exit Do
                                                End If
                                                If myexit(bstack) Then Execute = 1: Exit Do
                                                If x2 < 0 Then
                                                     bstack.SetVar w$, p
                                                Else
                                                    var(x2) = p
                                                End If
                                                If st > 0 Then
                                                    If p > sp Then Exit Do
                                                ElseIf st < 0 Then
                                                    If p < sp Then Exit Do
                                                Else
                                                    Exit Do
                                                End If
                                            Loop
                                        End If
                                        If Execute = 1 And y1 Then
                                            bstack.RetStackDrop 2
                                        End If
                                        x2 = 0  ' need to erased - because reused
                                        y2 = 0
                                        If MOUT Then Execute = 0: Exit Function
                                        ok = True
                                    End If
                                End If
                            End If
                        End If
                    Else
                        v = -1
                        Set pppp = Nothing
                        GoTo startwithgroup
                    End If
                Case 5
againarraystring:
                    If neoGetArray(bstack, w$, pppp) Then
                        If NeoGetArrayItem(pppp, bstack, w$, v, B$) Then

                            If Typename$(pppp.item(v)) = mgroup Then
                                If Left$(B$, 1) = "." Then
                                    If SpeedGroup(bstack, pppp, "VAL", "", B$, v) = 1 Then
                                        If Typename(bstack.lastobj) = mgroup Then
                                            Set pppp = New mArray
                                            pppp.Arr = False
                                            Set pppp.GroupRef = bstack.lastobj
                                            v = -2
                                        Else
                                            MissingGroup
                                            Exit Function
                                        End If
                                    Else
                                        Exit Function
                                    End If
                                End If

                            
                            
                            
startwithgroup:
                                
                                
                                Execute = SpeedGroup(bstack, pppp, "FOR", w$, B$, v)
                                Set pppp = Nothing ' ok here
                                If Execute = 0 Then
                                    If LastErNum1 = 0 Then SyntaxError
                                    Exit Function
                                ElseIf Execute <> 1 And B$ <> "" Then
                                    once = False
                                    Exit Function
                                End If
                                sss = Len(B$)
                                GoTo loopagain
                            End If
                            If MaybeIsSymbol(B$, "=<") Then
                            NotForArray
                            Else
                            MissingGroup
                            End If
                        Else
                            NotExistArray
                        End If
                        Execute = 0
                        Exit Function
                    Else
                        ok = False
                        If Right$(w$, 2) <> "$(" Then
                            w$ = Left$(w$, Len(w$) - 1) + "$("
                            GoTo againarraystring
                        End If
                    End If
                Case 6
                    If neoGetArray(bstack, w$, pppp) Then
                        If NeoGetArrayItem(pppp, bstack, w$, v, B$) Then
                            If Typename$(pppp.item(v)) = mgroup Then
                                GoTo startwithgroup
                            ElseIf pppp.IsStringItem(v) Then
                                ec$ = pppp.item(v)
                                x1 = Abs(IsLabelBig(bstack, ec$, w$, , SBB$, , True))
                                If Not ec$ = vbNullString Then B$ = ec$ + B$
                                Set pppp = New mArray
                                GoTo againfor948
                            Else
                                MissString
                                Execute = 0
                                Exit Function
                            End If
                        Else
                            Execute = 0
                            Exit Function
                        End If
                    Else
                        NotExistArray
                    End If
                End Select
                If Not ok Then
                    Execute = 0
                    Exit Function
                End If
            Case "NEXT", "еполемо"
contNext:
                If IsLabel(bstack, B$, w$) Then
                    If bstack.IsInRetStackString(ss$) Then
                        'ss$ = bstack.RetStack.PopStr
                        If ss$ <> w$ Then
                            bstack.RetStack.PushStr ss$
                            MissNext
                            Execute = 0
                            Exit Function
                        Else
                            With bstack.RetStack
                               .drop 1
                               .PushVal Len(B$)
                               .PushStr ss$
                           End With
                        End If
                        Exit Function
                    End If
                Else
                ' NEW FOR M2000, WE CAN USE NO VARIABLE
                    If bstack.IsInRetStackString(ss$) Then
                            With bstack.RetStack
                               .drop 1
                               .PushVal Len(B$)
                               .PushStr ss$
                           End With
                        Exit Function
                    End If
                End If
            Case "CALL", "йакесе"
        ' CHECK FOR NUMBER...
contCall:
                On Error Resume Next
                Err.Clear
                NeoCall ObjPtr(bstack), B$, Lang, ok
                If Not ok Or Err <> 0 Then
                    Execute = 0
                    Exit Function
                End If
        
            Case "INLINE", "емхесг"
ContInline:
                If once = True Then Execute = 0: Exit Function
                If IsLabelSymbolNew(B$, "йыдийа", "CODE", Lang) Then
                    If IsLabelDot(here$, B$, sw$) = 1 Then
                        If GetSub(myUcase(sw$, True), nd&) Then
                            WaitShow = Len(B$)
                            bstack.addlen = 0
                            If IsSymbol(B$, ",") Then
                                If Lang = 1 Then
                                    B$ = vbCrLf + "Inline code " + B$
                                Else
                                    B$ = vbCrLf + "╦МХЕСГ йЧДИЙА " + B$
                                End If
                            End If
                            B$ = vbCrLf + sbf(nd&).sb & B$
                            If trace Then TestShowSub = B$
                            sss = Len(B$)
                            GoTo again1
                        ElseIf GetSub(here$ + sw$, nd&) Then
                            WaitShow = Len(B$)
                            B$ = vbCrLf + sbf(nd&).sb & B$
                            If trace Then TestShowSub = B$
                            sss = Len(B$)
                            GoTo again1
                        End If
                    Else
                        GoTo errstat1
                    End If
                Else
                    If IsStrExp(bstack, B$, ss$) Then
                        WaitShow = Len(B$)
                        bstack.addlen = 0
                        B$ = vbCrLf + ss$ & B$
                        If trace Then TestShowSub = B$
                        sss = Len(B$)
                        GoTo again1
                    End If
                End If
            Case "UPDATE", "епийаияо"
contUpdate:
                If Len(bstack.UseGroupname) > 0 Then
                    B$ = ": set " + Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1) + "=" + Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1) + vbCrLf + B$
                    sss = Len(B$)
                Else
                    OnlyInAGroup
                    Execute = 0
                    Exit Function
                End If
                GoTo again1
            Case "AFTER", "лета"
contAfter:
                If linebyline Then
                    B$ = w$ + " " + B$
                    Execute = Execute(bstack, B$, once, False)
                    Exit Do
                End If
                If once = True Then Execute = 0: Exit Function
                If IsExp(bstack, B$, p) Then
                    If FastSymbol(B$, "{") Then
                        ss$ = block(B$) + vbCrLf & "thread this erase"
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                        sp = GetTaskId + 20000
                        B$ = Mid$(B$, 2)
                        Set bs = New basetask
                        bs.IamAnEvent = bstack.IamAnEvent
                        Set bs.Parent = bstack
                        bstack.PushThread CLng(sp), "after"
                        sThreadInternal bs, sp, 0, ss$, uintnew(p), here$, True
                        Set bs = Nothing
                        LLL = 0
                        Execute = 1
                    Else
                        LLL = 0
                        B$ = vbCrLf & "WAIT " & Str(p) & ": " & B$
                        Execute = 1
                    End If
                End If
            Case "сведио", "DRAWING"
contDraw:
            If Not linebyline Then
                    If once = True Then Execute = 0: Exit Function
                End If
                Execute = 0
                If IsExp(bstack, B$, p, , True) Then
                    If Not FastSymbol(B$, ",", True) Then Execute = 0: Exit Function
                    If Not IsExp(bstack, B$, sp, , True) Then MissParam B$: Execute = 0: Exit Function
                If FastSymbol(B$, "{") Then
                    ss$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If
                     TraceStore bstack, nd&, B$, 0
                    Mid$(B$, 1, 1) = " "
                     x2 = Len(B$)
                    
                    If Not MakeEmf(bstack, B$, Lang, ss$, p, sp) Then
                    
                        Execute = 0:  B$ = ss$ + space$(x2): Exit Function
                    End If
                    TraceRestore bstack, nd&
                    Execute = 1
                    Else
                        SyntaxError
                        Execute = 0: Exit Function
                End If
                Else
                    If FastSymbol(B$, "{") Then
                        ss$ = block(B$)
                                    If Not Left$(B$, 1) = "}" Then
                                        Execute = CheckBlock(once): Exit Function
                                    End If
                        TraceStore bstack, nd&, B$, 0
                        Mid$(B$, 1, 1) = " "
                        x2 = Len(B$)
                        If Not MakeEmf(bstack, B$, Lang, ss$) Then
                        
                            Execute = 0: B$ = ss$ + space$(x2): Exit Function
                        End If
                        TraceRestore bstack, nd&
                        Execute = 1
                        Else
                        SyntaxError
                            Execute = 0: Exit Function
                    End If
                End If
            Case "дуадийо", "BINARY"
contBinary:
                If Not linebyline Then
                    If once = True Then Execute = 0: Exit Function
                End If
                Execute = 0
                If FastSymbol(B$, "{") Then
                    ss$ = block(B$)
                    
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If
                    B$ = Mid$(B$, 2)
                    If Not GetRes(bstack, B$, Lang, ss$) Then
                        Execute = 0: Exit Function
                    End If
                    Execute = 1
                End If
            Case "леяос", "PART"
contPart:
                If Not linebyline Then
                    If once = True Then Execute = 0: Exit Function
                End If
                Execute = 0
                If FastSymbol(B$, "{") Then
                    ss$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                    x2 = Len(B$)
                    TraceStore bstack, nd&, B$, 0
                    B$ = Mid$(B$, 2)
                    If IsLabelSymbolNew(B$, "ыс", "AS", Lang) Then
          ' search for variable name only
                        ok = False
                        If Abs(IsLabel(bstack, B$, w$)) = 1 Then
                            If GetlocalVar(w$, v) Then ' exist...
                                LLL = 0
                                If var(v) = 0 Then var(v) = True: ok = True
                            ElseIf GetVar(bstack, w$, v) Then ' exist...
                                LLL = 0
                                If var(v) = 0 Then var(v) = True: ok = True
                            Else
                                v = globalvar(w$, ok, , VarStat, temphere$)
                                LLL = 0
                            End If
                            If ok Then
                                ok = False
                                Execute = 1
                                Call executeblock(Execute, bstack, ss$, (once), ok, , True)
                                bstack.addlen = nd&
                                If Execute = 0 Then B$ = ss$ + space$(x2): Exit Function
                                
                                var(v) = False
                                ok = True
                                If linebyline Then
                                    ClearStr B$
                                    Exit Do
                                End If
                            Else
                                bstack.addlen = nd&
                                Execute = 1
                            End If
                            
                        Else
                            ' ????
                            Exit Function
                        End If
                    Else
                        SyntaxError
                        Execute = 0
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
        
            Case "DO", "REPEAT", "епамакабе", "епамекабе"
ContRepeat:
                If linebyline Then
                    B$ = w$ + " " + B$
                    sw$ = here$
                    Execute = Execute(bstack, B$, once, False)
                    SwapStrings sw$, here$
                    Exit Do
                End If
                If once = True Then Execute = 0: Exit Function
                sw$ = here$
                If Not FastSymbol(B$, "{") Then
                i = 1
                aheadstatusDO B$, i, Lang, ok
                If ok Then
                    v = Len(B$)
                    ss$ = Left$(B$, i - 1)
                    B$ = Mid$(B$, i)
                    
                    TraceStore bstack, x1, B$, 0
                    
                    y1 = bstack.addlen
                    GoTo contdo
                Else
                    MissUntil
                    Execute = 0
                    Exit Function
                End If
                Else

                    v = Len(B$)
                    ss$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                    TraceStore bstack, x1, B$, 0
                     B$ = Mid$(B$, 2)
                    y1 = bstack.addlen
contdo:
                    ok = False
                    sss = Len(B$)
                    ec$ = ss$
                    If IsLabelSymbolNew(B$, "осо", "WHEN", Lang) Then
                    nchr = True
                    GoTo CONDwhen
                    End If
                    If IsLabelSymbolNew(B$, "левяи", "UNTIL", Lang) Then
                    nchr = False
CONDwhen:
                        Execute = 1
                        bstack.addlen = y1
                        Call executeblock(Execute, bstack, ss$, once, ok, , True)
                        bstack.addlen = x1
                            If Execute = 0 Then
                                B$ = space$(v - (Len(ec$) - Len(ss$)))
                                Execute = 0: Exit Function
                            ElseIf Execute = 2 Then
                                If ss$ <> "" And Not ok Then
                                    B$ = ss$: Exit Function
                                ElseIf ss$ = "" And ok Then
                                    B$ = "BREAK": Exit Function
                                End If
                            End If
                            If Execute = 3 Then ok = False
                            If ok Or MOUT Then
                                If ok Then
                                    ss$ = GetNextLine(B$)  'FORGET ANY CODE TO THE RIGHT
                                Else
                                    Exit Function
                                End If
                            Else
                                sss = Len(B)
                                w$ = B$
                                If IsExp(bstack, B$, p) Then
                                If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is mHandler Then
                                
                                Set usehandler = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                
                                    With usehandler
                                            If .UseIterator Then
                                                i = .indirect
                                                If i < 0 Then
                                                    Set myobject = .objref
                                                    If TypeOf myobject Is mHandler Then
                                                        Set usehandler1 = myobject
                                                        Set myobject = usehandler1.objref
                                                        Set usehandler1 = Nothing
                                                    End If
                                                Else
                                                    InternalEror
                                                    B$ = vbNullString
                                                    Exit Function
                                                End If
                                                p = .index_End <> -1 And Not myobject.IsEmpty
                                                If p Then
                                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                                    If v >= 0 Then
                                                        p = .index_cursor < .index_End
                                                    Else
                                                        p = .index_cursor > .index_End
                                                    End If
                                                    If p Then myobject.index = .index_cursor + v: .index_cursor = .index_cursor + v
                                                End If
                                                p = Not p
                                            ElseIf .IamEnum Then
                                                p = .Iterate()
                                                p = Not p
                                            End If
                                        
                                        End With
                                        Set usehandler = Nothing
                                    End If
                                  End If
                                w$ = Left$(w$, Len(w$) - Len(B$))
                                If nchr Then p = Not p
                                If Not p Then
                                    bb$ = w$
                                    ok = False
                                    Do
                                        ss$ = ec$
                                        w$ = bb$
                                        Execute = 1
                                        bstack.addlen = y1
                                        Call executeblock(Execute, bstack, ss$, once, ok, , True)
                                        bstack.addlen = x1
                                        If Execute = 0 Then
                                            B$ = space$(v - (Len(ec$) - Len(ss$)))
                                            SwapStrings sw$, here$
                                            Execute = 0: Exit Function
                                        ElseIf Execute = 2 Then
                                            If ss$ <> "" And Not ok Then
                                                SwapStrings sw$, here$
                                                B$ = ss$: Exit Function
                                            ElseIf ss$ = "" And ok Then
                                                SwapStrings sw$, here$
                                                B$ = "BREAK": Exit Function
                                            End If
                                        End If
                                        If Execute = 3 Then ok = False
                                        If ok Or MOUT Then Exit Do
                                        IsExp bstack, w$, p
                                    
                                    If Not bstack.lastobj Is Nothing Then
                                        If TypeOf bstack.lastobj Is mHandler Then
                                        Set usehandler = bstack.lastobj
                                        Set bstack.lastobj = Nothing
                                        With usehandler
                                            If .UseIterator Then
                                                i = .indirect
                                                If i < 0 Then
                                                    Set myobject = .objref
                                                    If TypeOf myobject Is mHandler Then
                                                        Set usehandler1 = myobject
                                                        Set myobject = usehandler1.objref
                                                        Set usehandler1 = Nothing
                                                    End If
                                                Else
                                                    InternalEror
                                                    B$ = vbNullString
                                                    Exit Function
                                                End If
                                                p = .index_End <> -1 And Not myobject.IsEmpty
                                                If p Then
                                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                                    If v >= 0 Then
                                                        p = .index_cursor < .index_End
                                                    Else
                                                        p = .index_cursor > .index_End
                                                    End If
                                                    If p Then myobject.index = .index_cursor + v: .index_cursor = .index_cursor + v
                                                End If
                                                p = Not p
                                            ElseIf .IamEnum Then
                                                p = .Iterate()
                                                p = Not p
                                            End If
                                         End With
                                         Set usehandler = Nothing
                                        End If
                                    End If
                                    If nchr Then p = Not p
                                    Loop Until p
                                    SwapStrings sw$, here$
                                End If
                            End If
                        End If
                    Else
                 ' play always
                        If IsLabelSymbolNew(B$, "памта", "ALWAYS", Lang) Then
                            Do
                                ss$ = ec$
                                Execute = 1
                                bstack.addlen = y1
                                Call executeblock(Execute, bstack, ss$, once, ok, , True, True)
                                bstack.addlen = x1
                                
                                If Execute = 0 Then
                                    B$ = space$(v - (Len(ec$) - Len(ss$)))
                                    SwapStrings sw$, here$
                                    Execute = 0: Exit Function
                                ElseIf Execute = 2 Then
                                    If ss$ <> "" And Not ok Then
                                        SwapStrings sw$, here$
                                        B$ = ss$: Exit Function
                                    ElseIf ss$ = "" And ok Then
                                        SwapStrings sw$, here$
                                        B$ = "BREAK": Exit Function
                                    End If
                                ElseIf Execute = 1 Then
                                'If ok Then once = True: b$ = vbNullString: Exit Function
                                ElseIf Execute = 3 Then
                                ok = False
                                End If
                                If ok Or MOUT Then Exit Do
                            Loop
                        Else
                            Execute = 0
                            Exit Function
                        End If
                 End If
                        lbl = False
                        If Len(B$) > 0 Then
                        If Left$(B$, 2) = vbCrLf Then lbl = True
                        End If
            End If
        Case "емы", "WHILE"
contWhile:
            If linebyline Then
                B$ = w$ + " " + B$
                sw$ = here$
                Execute = Execute(bstack, B$, once, False)
                SwapStrings sw$, here$
                Exit Do
            End If
            If once = True Then Execute = 0: Exit Function
            i = 0
            x1 = 0
again112:
            i = i + 1
            If Len(aheadstatus(B$, False, i)) > 0 Then
            x1 = i
            If MaybeIsSymbol3(B$, ",", i) Then GoTo again112
            End If
            If x1 > 0 Then
            Else
            SyntaxError
            Execute = 0
            Exit Function
            End If
            x1 = x1 - 1
            w$ = Left$(B$, x1)
            
            
            
            If IsExp(bstack, w$, p) Then
            
                st = True
                ss$ = vbNullString
getanother:
                            If Not bstack.lastobj Is Nothing Then
                            If TypeOf bstack.lastobj Is mHandler Then
                            Set usehandler = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            With usehandler
                            If .UseIterator Then
                                i = .indirect
                                If i < 0 Then
                                    Set myobject = .objref
                                    If TypeOf myobject Is mHandler Then
                                        Set usehandler1 = myobject
                                        Set myobject = usehandler1.objref
                                        Set usehandler1 = Nothing
                                    End If
                                Else
                                    InternalEror
                                    B$ = vbNullString
                                    Exit Function
                                End If
                                p = .index_End <> -1 And Not myobject.IsEmpty
                                If p Then
                                    myobject.index = .index_start
                                    .index_cursor = .index_start
                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                End If
                            ElseIf .IamEnum Then
                                p = .index_End <> -1
                                If p Then
                                    If .index_End <> 0 Then
                                        p = .Iterate()
                                    End If
                                End If
                            End If
                            Set bstack.lastobj = Nothing
                        End With
                        Set usehandler = Nothing
                    End If
                End If
                st = st And p
                If FastSymbol(w$, ",") Then
                    If IsExp(bstack, w$, p) Then
                        If Not bstack.lastobj Is Nothing Then GoTo getanother
                    Else
                        MissNumExpr
                        Execute = 0
                        Exit Function
                    End If
                End If
                    If Not Len(NLtrim(w$)) = 0 Then
                    If Len(w$) > x1 Then
                    B$ = w$ + B$
                    ElseIf Len(w$) = x1 Then
                    Mid$(B$, 1, x1) = w$
                    Else
                    Mid$(B$, 1, x1) = space$(x1 - Len(w$)) + w$
                    End If
                    
                    End If
                    'w$ = Left$(w$, Len(w$) - Len(b$))
                    w$ = Left$(B$, x1)
                    B$ = Mid$(B$, x1 + 1)
                    If p = 0# Then
                        If FastSymbol(B$, "{") Then
                            w$ = block(B$)
                            If Not Left$(B$, 1) = "}" Then
                                Execute = CheckBlock(once): Exit Function
                            End If
                          '  b$ = NLtrim$(b$)
                            If FastSymbol(B$, "}") Then
                                B$ = NLtrim(B$)
                                If B$ = vbNullString Then Exit Function
                                GoTo again1
                            Else
                                B$ = NLtrim$(B$)
                                If B$ = vbNullString Then Exit Function
                                GoTo again1
                            End If
                        Else
                                i = 1
                                aheadstatusEND B$, i, Lang, "емы", 3, "WHILE", 5, ok, sss
                               If Not ok Then
                                   MissWhile
                                Execute = 0
                                Exit Function
                            End If
                                B$ = NLtrim(Mid$(B$, i))
                                If B$ = vbNullString Then Exit Function
                                                        lbl = False
                                                If Len(B$) > 0 Then
                                                If Left$(B$, 2) = vbCrLf Then lbl = True
                                                End If
                                GoTo again1
                            Exit Do
                        End If
                    Else
                        If Not FastSymbol(B$, "{") Then
                        i = 1
                        aheadstatusEND B$, i, Lang, "емы", 3, "WHILE", 5, ok, sss
                        If ok Then
                            ss$ = Left$(B$, sss - 1) + space$(i - sss)
                            B$ = Mid$(B$, i)
                            TraceStore bstack, x1, B$, 0
                            y1 = bstack.addlen
                            ec$ = ss$
                            
                            GoTo contWhile1
                        Else
                            MissWhile
                            Execute = 0
                            Exit Function
                        End If
                        
                        Else
                            ss$ = block(B$)
                            If Not Left$(B$, 1) = "}" Then
                                Execute = CheckBlock(once): Exit Function
                            End If
                            TraceStore bstack, x1, B$, 0
                            y1 = bstack.addlen
                            ec$ = ss$
                            B$ = Mid$(B$, 2)
contWhile1:
                            sss = Len(B$)
                            bb$ = w$
                            Execute = 1
                            ok = False
                            sw$ = here$
                            Do
                                st = True
                                ss$ = ec$
                                w$ = bb$
                                bstack.addlen = y1
                                If executeblock(Execute, bstack, ss$, once, ok, , True) Then
                                    SwapStrings sw$, here$
                                    TraceRestore bstack, x1
                                    If Execute = 2 Then
                                    If ok And ss$ = "" Then B$ = "BREAK": Exit Function
                                    B$ = ss$: Exit Function
                                    End If
                                    B$ = ss$ & B$
                                    Exit Function
                                Else
                                    SwapStrings sw$, here$
                                    TraceRestore bstack, x1
                                    If Execute = 2 And ss$ <> "" And Not ok Then
                                        B$ = ss$
                                        Exit Function
                                    ElseIf Execute = 12 Then
                                        Execute = 2
                                        B$ = ss$
                                        Exit Function
                                    End If
                                End If
                                If Execute = 3 Then ok = False
                                If ok Or MOUT Then Exit Do
another1:
                                IsExp bstack, w$, p
                                                           If Not bstack.lastobj Is Nothing Then
                            If TypeOf bstack.lastobj Is mHandler Then
                            Set usehandler = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            With usehandler
                                            If .UseIterator Then
                                                i = .indirect
                                                If i < 0 Then
                                                    Set myobject = .objref
                                                    If TypeOf myobject Is mHandler Then
                                                        Set usehandler1 = myobject
                                                        Set myobject = usehandler1.objref
                                                        Set usehandler1 = Nothing
                                                    End If
                                                Else
                                                    InternalEror
                                                    B$ = vbNullString
                                                    Exit Function
                                                End If
                                                p = .index_End <> -1 And Not myobject.IsEmpty
                                                If p Then
                                                    If .index_start <= .index_End Then v = 1 Else v = -1
                                                    If v >= 0 Then
                                                        p = .index_cursor < .index_End
                                                    Else
                                                        p = .index_cursor > .index_End
                                                    End If
                                                    If p Then myobject.index = .index_cursor + v: .index_cursor = .index_cursor + v
                                                End If
                                            ElseIf .IamEnum Then
                                                p = .Iterate()
                                            End If
                                        End With
                                        Set usehandler = Nothing
                                        End If
                                    End If
                               
                                st = st And p
                                If FastSymbol(w$, ",") Then GoTo another1
                            Loop Until st = 0 Or NOEXECUTION
                 ' addition in 8.9 rev 33
                            Set bstack.lastobj = Nothing
                            If MOUT Then Execute = 0: Exit Function
                    End If
                End If
            End If
                        lbl = False
                        If Len(B$) > 0 Then
                        If Left$(B$, 2) = vbCrLf Then lbl = True
                        End If
        Case "йахе", "EVERY"
contEvery:
            If once = True Then Execute = 0: Exit Function
            If linebyline Then
                B$ = w$ + " " + B$
                sw$ = here$
                Execute = Execute(bstack, B$, once, False)
                SwapStrings sw$, here$
                Exit Do
            End If
            If IsExp(bstack, B$, p) Then
                If p <= 0 Then
                    If FastSymbol(B$, "{") Then
                        w$ = block(B$)
                        If Not Left$(B$, 1) = "}" Then
                              Execute = CheckBlock(once): Exit Function
                        End If
                        B$ = Mid$(B$, 2)
                        sss = Len(B$)
                    Else
                        Exit Do
                    End If
                Else
                    sw$ = here$
                    If FastSymbol(B$, "{") Then
                        ss$ = block(B$) + "}"
                              If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If
                        ec$ = ss$
                        B$ = Mid$(B$, 2)
                        sss = Len(B$)
                        Execute = 1
                        ok = False
                        ' GET A TICK HERE
                        sX = p
                        p = p + uintnew(timeGetTime)
                        Do
                            ss$ = ec$
                            Execute = 1
                            Call executeblock(Execute, bstack, ss$, once, ok, , True)
                            If Execute = 0 Then   '''Execute(bstack, ss$, ok) = 0
                                If NOEXECUTION Then
                                    B$ = "START"
                                    Execute = 1
                                    ok = True
                                    Exit Do
                                End If
                                B$ = ss$ & B$
                                SwapStrings sw$, here$
                                Execute = 0: Exit Function
                            ElseIf Execute = 2 Then
                                If Len(ss$) > 0 Then
                                    SwapStrings sw$, here$
                                    B$ = ss$: Exit Function
                                ElseIf ok Then
                                    B$ = "BREAK": once = True
                                    SwapStrings sw$, here$
                                    Exit Function
                                End If
                            End If
                            If ok Or MOUT Then Exit Do
                            If p < timeGetTime Then
                                p = (sX - (uintnew(timeGetTime) - p) \ sX) + uintnew(timeGetTime)
                            End If
                            If bstack.IamThread Then SkipRefresh bstack
                            If p > uintnew(timeGetTime) Then
                                ProcTask2 bstack
                                Do While p > uintnew(timeGetTime)
                                    ProcTask2 bstack
                                Loop
                            End If
                            p = sX + uintnew(timeGetTime)
                            
                        Loop
                        SwapStrings sw$, here$
                        If NOEXECUTION Then
                            B$ = "START"
                            Execute = 1
                            ok = True
                            Exit Do
                        End If
                        If MOUT Then Execute = 0: Exit Function
                    Else
                        sss = Len(B$)
                    End If
                End If
            End If
        Case "йуяио.еяцо", "MAIN.TASK", "TASK.MAIN"
contTask:
            If once = True Then Execute = 0: Exit Function
            If linebyline Then
                B$ = w$ + " " + B$
                sw$ = here$
                Execute = Execute(bstack, B$, once, False)
                SwapStrings sw$, here$
                Exit Do
            End If
            ' only one task main
            If taskmainonly = True Then Execute = 0: Exit Function
            taskmainonly = True
            w$ = B$
            Execute = 1
            If IsExp(bstack, B$, p) Then
                If FastSymbol(B$, "{") Then
                    ss$ = block(B$)
                    If Not Left$(B$, 1) = "}" Then
                        Execute = CheckBlock(once): Exit Function
                    End If
                    B$ = Mid$(B$, 2)
                    sp = GetTaskId + 20000
                    Set bs = New basetask
                    Set bs.Parent = bstack
                    bstack.PushThread CLng(sp), "_multi"
                    sThreadInternal bs, sp, 10, ss$, -1&, here$, True
                    TaskMaster.Message CLng(sp), 3, CLng(uintnew(p))
                    On Error Resume Next
                    bstack.TaskMain = True
                    i = 0
                    Do
                        If TaskMaster Is Nothing Then Execute = 0: Exit Function
                        If TaskMaster.PlayMusic Then
                            TaskMaster.OnlyMusic = True
                            TaskMaster.TimerTick
                            TaskMaster.OnlyMusic = False
                        End If
                        If TaskMaster Is Nothing Then Execute = 0: Exit Function
                        
                            
                            If TaskMaster.Processing Then
                                TaskMaster.TimerTick
                                i = 0
                            Else
                            'MyDoEvents0 di
                            'MyDoEventsNoRefresh
                            If i = 1 Then
                                DoEvents
                                i = 10
                            Else
                                If Timer Mod (100 + i) < 10 Then i = i + 1
                            End If
                        End If
                        
                        bstack.TaskMain = bstack.exist(CLng(sp), "_multi") = False
                    Loop Until MOUT Or bstack.TaskMain Or NOEXECUTION Or TaskMaster.QueueCount < 2
                    If bstack.exist(CLng(sp), "_multi") Then
                        TaskMaster.Message CLng(sp), 1
                    End If
                    On Error GoTo 0
                    bstack.TaskMain = False
                    If TaskMaster.PlayMusic Then mute = True
                End If
            End If
            taskmainonly = False
            If MOUT Then Execute = 0: Exit Function
        Case "ELSE", "аккиыс"
ContElse:
    
            
            If IFCTRL = 0 Then
            If lookB123(B$) Then
                If HaveMark(bstack, i, ok) Then
                  If i = 0 Then
                    SyntaxError
                    Execute = 0: Exit Function
                    End If
                    If (Not ok) Or i = 2 Then
                 
findEndif:
                       i = SetNextLineCLR(B$)
                        i = MyTrimLi(B$, i + 1)
                        If i > 0 Then
                        
                        aheadstatusENDIF B$, i, Lang, ok
                        If Not ok Then Execute = 0: Exit Function
                        
                        If i = Len(B$) + 2 Then MissENDIF: Execute = 0: Exit Function
                        DropMark bstack
                        bstack.UseofIf = bstack.UseofIf - 1

                        B$ = Mid$(B$, i)
                        Else
                        B$ = vbNullString
                        End If
                        sss = Len(B$)
                        lbl = False
                        If Len(B$) > 0 Then
                        If Left$(B$, 2) = vbCrLf Then lbl = True
                        End If

                
                    Else
                    ' no other else.if
                    DropMark bstack
                    MarkIf bstack, 0, False
                    End If
                  GoTo loopcontinue
                End If
            End If
                SyntaxError
                Execute = 0
                Exit Function
                
            Else
                If (Not jump) Or IFCTRL = 2 Then
                
                    If FastSymbol(B$, "{") Then
                        w$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If
                        B$ = Mid$(B$, 2)
                    ElseIf lookB123(B$) Then
                        i = SetNextLineCLR(B$)
                        i = MyTrimLi(B$, i + 1)
                        If i > 0 Then
                        
                        aheadstatusENDIF B$, i, Lang, ok
                        If Not ok Then Execute = 0: Exit Function
                        If i = Len(B$) + 2 Then MissENDIF: Execute = 0: Exit Function
                        DropMark bstack
                        bstack.UseofIf = bstack.UseofIf - 1
                        B$ = Mid$(B$, i)
                        Else
                        B$ = vbNullString
                        End If
                        lbl = True
                    Else
                    If Not once Then
                        SetNextLine B$
                        End If
                        lbl = True
                        jump = False
                        sss = Len(B$)
                        GoTo loopagain
                        lbl = True
                    End If
                    jump = False
                Else
                    If IsNumberLabel(B$, w$) Then
                        once = False
                        B$ = w$
                        Execute = 2
                        Exit Function
                    End If
                    If lookB123(B$) Then
                    If Not once Then
                        SetNextLineCLR B$
                        End If
                        lbl = True
                        jump = False
                        sss = Len(B$)
                        GoTo loopagain
                    End If
                    lbl = False
                    IFCTRL = 0 ' NONEED ANYTHING AND ERROR FOR IF.ELSE AND ELSE
                    jump = False
                    sss = Len(B$)
                    If FastSymbol(B$, "{") Then
                                    ss$ = block(B$)
                                  If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                                        TraceStore bstack, nd&, B$, 0
                                        B$ = Mid$(B$, 2)
                                        Call executeblock(Execute, bstack, ss$, False, ok, , True)
                                       TraceRestore bstack, nd&
                                If Execute = 2 Then
                                If Len(ss$) > 0 Then B$ = ss$: Exit Function
                                If ok Then B$ = "BREAK": once = True: Exit Function
                                End If
                                
                    Else
                
                    If once Or linebyline Then GoTo again1
                    End If
                End If
                
            End If
            IFCTRL = 0 ' NONEED ANYTHING AND ERROR FOR IF.ELSE AND ELSE
            jump = False
            sss = Len(B$)
              
            
        Case "TRY", "дес"
ContTry:
            If IsLabelSymbolNew(B$, "яеула", "STREAM", Lang) Then
                If bstack.CallW <> "" Then
                    ss$ = here$
                    i = bstack.soros.Total
                    here$ = bstack.fHere
                    If bstack.strg Then
                        If IsStrExp(bstack, (bstack.CallW), ec$) Then
                            bstack.soros.DataStr ec$
                        End If
                    Else
                        If IsExp(bstack, (bstack.CallW), p) Then
                            bstack.soros.DataVal p
                        End If
                    End If
                    here$ = ss$
                End If
                GoTo loopagain
            End If
            If once = True Then Execute = 0: Exit Function
            If linebyline Then
                B$ = w$ + " " + B$
                sw$ = here$
                PushErrStage bstack
                Execute = Execute(bstack, B$, once, False)
                PopErrStage bstack
                SwapStrings sw$, here$
                bstack.nokillvars = False
                Exit Do
            End If
        ' летабкгтг
            i = Abs(IsLabel(bstack, B$, w$))
            Select Case i
            Case 0  ' new
                If FastSymbol(B$, "{") Then
                    Execute = 1
                    ss$ = block(B$)
                    If Not Left$(B$, 1) = "}" Then
                        Execute = CheckBlock(once): Exit Function
                    End If
                    TraceStore bstack, x1, B$, 0
                    B$ = Mid$(B$, 2)
                    Execute = 1

                    PushErrStage bstack
                    Call executeblock(Execute, bstack, ss$, once, ok, , True)
                    PopErrStage bstack
                    TraceRestore bstack, x1
                    bstack.nokillvars = False
                    If NOEXECUTION Then Exit Function
                    once = False
                    MOUT = False
                   ' NOEXECUTION = False
                    NERR = False
                    LastErNum = 0
                    LastErNum1 = 0
                    bstack.ErrorOriginal = 0
                    If LastErName <> "" Then LastErName = Chr(0) + LastErName
                    If LastErNameGR <> "" Then LastErNameGR = Chr(0) + LastErNameGR
                        If Execute = 2 Then
                          If ss$ = "" Then
                             ' no here
                             ' b$ = ": Break"
                          Else
                              B$ = ": Goto " + ss$
                          End If
                          sss = Len(B$)
                          End If
                              Execute = 1
                        Else
                        SyntaxError
                        Execute = 0: Exit Function
                    End If
            Case 1, 4
                If FastSymbol(B$, "{") Then
                    p = 0#
                    If Not GetlocalVar(w$, v) Then
                        If Not GetVar(bstack, w$, v) Then
                            v = globalvar(w$, p, , VarStat, temphere$) '': GetlocalVar W$, v
                        End If
                    End If
                    Execute = 1
                    ss$ = block(B$)
                    If Not Left$(B$, 1) = "}" Then
                        Execute = CheckBlock(once): Exit Function
                    End If
                    B$ = Mid$(B$, 2)
                    LastErNum2 = 0
                    PushErrStage bstack
                    Call executeblock(Execute, bstack, ss$, once, ok, , True)
                    PopErrStage bstack
                    
                    var(v) = CDbl(Execute = 1)
                    If NOEXECUTION Then Exit Function
                    MOUT = False
                   ' NOEXECUTION = False
                    NERR = False
                    LastErNum = 0
                    LastErNum2 = LastErNum1
                    LastErNum1 = 0
                    bstack.ErrorOriginal = 0
                    If Execute = 2 Then
                          If ss$ = "" Then
    
                          Else
                              B$ = ": Goto " + ss$
                          End If
                          sss = Len(B$)
                          End If
                              Execute = 1
                Else
                SyntaxError
                Execute = 0: Exit Function
                End If
                
            End Select
            If MOUT Then Execute = 0: Exit Function
            Execute = 1
        Case "ELSE.IF", "аккиыс.ам"
contElseIf:
          '  If once = True Then Execute = 0: Exit Function
            If IFCTRL = 0 Then
                If HaveMark(bstack, i, ok) Then
                    If i = 0 Then
                    SyntaxError
                    Execute = 0: Exit Function
                    End If
                    x1 = 1
                    aheadstatusThen B$, x1, Lang, w$
                    If w$ = vbNullString Then
                        MissTHENELSE
                        Execute = 0
                        Exit Function
                    End If
                    
                    If lookB123(B$, x1) Then
                    'If MaybeIsSymbol3lot(b$, b123, (x1)) Then
                        If (Not ok) Or i = 2 Then
                    ' so we have to jump
                            x1 = i
                            i = SetNextLineCLR(B$)
                            i = MyTrimLi(B$, i + 1)
                            If i > 0 Then
                                aheadstatusELSEIF B$, i, Lang, ok, x1, (ok)
                                 If x1 = 0 Then
                              DropMark bstack
                              bstack.UseofIf = bstack.UseofIf - 1
                              End If
                                B$ = Mid$(B$, i)
                            Else
                                B$ = vbNullString
                            End If
                            sss = Len(B$)
                            lbl = True
                        Else
                        ' so we have to check expression
                            If IsExp(bstack, Left$(B$, x1), p, , True) Then
                                i = 1
                                ok = (p = 0#)
                                ' drop old save new
                                Select Case Lang
                                Case 0
                                    Select Case w$
                                    Case "аккиыс"
                                        Mid$(B$, 1, x1) = space(x1)
                                        ok = Not ok
                                        GoTo contThenElseIf
                                    Case "тоте"
                                      GoTo contThenElseIf
                                    End Select
                              Case 1
                                  Select Case w$
                                  Case "ELSE"
                                      Mid$(B$, 1, x1) = space(x1)
                                      ok = Not ok
                                        GoTo contThenElseIf
                                  Case "THEN"
contThenElseIf:
                                      If ok Then
                                            x1 = x1 + 1
                                            aheadstatusELSEIF B$, x1, Lang, ok, i, (ok)
                                                DropMark bstack
                                            If i = 0 Then
                                                bstack.UseofIf = bstack.UseofIf - 1
                                                Else
                                                MarkIf bstack, 1, True
                                            End If
                                            B$ = Mid$(B$, x1)
                                      Else
                                      Mid$(B$, 1, x1) = space(x1)
                                       DropMark bstack
                                        MarkIf bstack, 2, True
                                      End If
                                  End Select
                              End Select
                              sss = Len(B$)
                              lbl = True
                            End If
                        End If
                        GoTo loopcontinue
                    End If
                End If
                SyntaxError
                Execute = 0
                Exit Function
                
            Else
                ' use of flags
                If (Not jump) Or IFCTRL = 2 Then
                ' LOOK AHEAD...DO NOT PLAY THE LOGICAL EXPRESSION
                ' ALSO THROW ALL { } ELSE {} BECAUSE FOUND THAT IS AN EXPRESSION;;;
                    IFCTRL = 1
                    
                    aheadstatusIF B$, IFCTRL, Lang, w$
                    
                    If Len(w$) = 0 Then SyntaxError: Execute = 0: Exit Function
                    If FastOperator(B$, vbCrLf, IFCTRL, 2) Then
                    B$ = Mid$(B$, IFCTRL)
                                            SetNextLine B$
                          IFCTRL = 1
                    aheadstatusANY B$, IFCTRL
                    
                    B$ = Mid$(B$, IFCTRL)
                    Else
                    
                   ' aheadstatusANY b$, IFCTRL
                    
                    B$ = Mid$(B$, IFCTRL)
                    If FastSymbol(B$, "{") Then
                       w$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                                        B$ = Mid$(B$, 2)
                                         If FastSymbol(B$, ":") Then
                                    sss = Len(B$)
                                    
                                    IFCTRL = 0: GoTo again1
                                    End If
                    Else
                    SetNextLine B$
                    End If
                    End If
                     If bstack.RetStackTotal > 0 Then
                    If IsLabelSymbolNew(B$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                    If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                                                    If bstack.RetStack.LookTopVal = -3 Then
                                                        jump = False
                                                        IFCTRL = 0
                                                    End If
                                                Else
                    lbl = True
                    IFCTRL = 1
                    jump = False
                    i = 1
                    While FastOperator(B$, vbCrLf, i, 2)
                    Wend
                    If IsLabelSymbolNew(B$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                    If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                    End If
              
                Else   ' ONLY FOR NOT JUMP
                    If IsExp(bstack, B$, p, , True) Then
                        IFCTRL = 1
                        jump = (p = 0#)
                        i = 1
                        Select Case Abs(IsLabel(bstack, B$, w$))  ' now w$ is Ucase
                        Case 1
                            Select Case w$
                            Case "THEN", "тоте"
                                    'While FastOperator(b$, vbCrLf, i, 2)
                                    'Wend
                                    
                                If jump Then
                                    If FastSymbol(B$, "{") Then
                                        w$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                        B$ = Mid$(B$, 2)
                                         If FastSymbol(B$, ":") Then
                                    sss = Len(B$)
                                    
                                    IFCTRL = 0: GoTo again1
                                    End If

                                    Else
                                            i = 1
                                            aheadstatusELSE B$, i, Lang, w$
                                            If Len(w$) > 2 Then
                                            If Lang = 0 Then
                                                Select Case w$
                                                Case "аккиыс"
                                                    B$ = Mid$(B$, i)
                                                    GoTo ContElse
                                                Case "аккиыс.ам"
                                                     B$ = Mid$(B$, i)
                                                    GoTo contElseIf
                                                End Select
                                            Else
                                                Select Case w$
                                                Case "ELSE"
                                                    B$ = Mid$(B$, i)
                                                    GoTo ContElse
                                                Case "ELSE.IF"
                                                    B$ = Mid$(B$, i)
                                                    GoTo contElseIf
                                                End Select
                                         
                                                End If
                                                
                                                sss = Len(B$)
                                                
                                                GoTo again1
                                            Else
                                                SetNextLine B$
                                                lbl = True
                                            End If
                                        'End If
                                    End If
                                Else
                                    If Not FastSymbol(B$, "{") Then
                                    ' ELSE.IF true THEN ******************************************************
                                        If MaybeIsSymbol(B$, "0123456789") Then GoTo ContGoto
                                        i = 1
                                        aheadstatusELSE B$, i, Lang, w$
                                        If Len(w$) > 2 Then
                                        ' #1
                                            ss$ = Left$(B$, i - 1 - Len(w$)) '+ "}"
                                            
                                            If once Then
                                            
                                                once = False
                                                B$ = Mid$(B$, Len(ss$) + 1)
                                                TraceStore bstack, nd&, B$, 0
                                                Call executeblock(Execute, bstack, ss$, once, ok, , True, False)
                                                TraceRestore bstack, nd&
                                                If Execute = 0 Then
                                                   B$ = ss$ + B$
                                                ElseIf Execute = 5 Then
                                                 once = True
                                                GoTo contLoop
                                                ElseIf Execute = 6 Then
                                                B$ = vbNullString
                                                Execute = 2
                                                 once = True
                                                Exit Function
                                                ElseIf Execute = 2 And once Then
                                                    B$ = ss$
                                                    Exit Function
                                           ElseIf Execute = 3 Then
                                            B$ = ss$
                                            Exit Function
                                                Else
                                                    SetNextLine B$
                                                End If
                                                 once = True
                                                Exit Function
                                            Else
                                            ' else.if  then .... no block
                                                B$ = Mid$(B$, Len(ss$) + 1)
                                                ok = False
                                                 TraceStore bstack, nd&, B$, 0
                                                Call executeblock(Execute, bstack, ss$, False, ok, , True, False)
                                                 TraceRestore bstack, nd&
                                            End If
                                            If Execute = 1 Then
                                            If ok Then Exit Function
                                          
                                            GoTo contif2
                                            ElseIf Execute = 2 Then
                                                B$ = ss$
                                                once = False
                                                
                                            Exit Function
                                        ElseIf Execute = 6 Then
                                            GoTo ContRestart
                                        ElseIf Execute = 5 Then
                                            Execute = 2
                                            loopthis = True
                                            GoTo contif2
                                        Else
                                            If loopthis Then Execute = 2
                                            GoTo ContContinue
                                            End If
                                        Else
                                            IFCTRL = 2
                                        End If
                                    Else
contelseifpass:
                                        IFCTRL = 2
                                        ss$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If


                                        TraceStore bstack, nd&, B$, 0
                                        B$ = Mid$(B$, 2)
                                        Call executeblock(Execute, bstack, ss$, False, ok, , True)
                                       TraceRestore bstack, nd&
                                        If Execute = 1 Then
                                       ' If once Then Exit Do
                                        
                                        If FastSymbol(B$, ":") Then
                                        
                                            sss = Len(B$)
                                          IFCTRL = 0: GoTo again1
                                        End If
                                        If Not lookB123(B$) Then GoTo contif2
                                        Else
                                                  B$ = ss$
                                                once = False
                                                Execute = 2
                                                Exit Function
                                        End If
                                    End If
                                    
                                End If
                            Case "ELSE", "аккиыс"
                                   ' While FastOperator(b$, vbCrLf, i, 2)
                                    'Wend
                                    
                                If Not jump Then      ' JUMP FALSE SKIP ELSE
                                    If FastSymbol(B$, "{") Then
                                        w$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                        B$ = Mid$(B$, 2)
                                    Else
                                            i = 1
                                            
                                            aheadstatusELSE B$, i, Lang, w$
                                            If Len(w$) > 2 Then
                                             jump = True
                                            IFCTRL = 1
                                            If Lang = 0 Then
                                                Select Case w$
                                                Case "аккиыс"
                                                    B$ = Mid$(B$, i)
                                                    GoTo ContElse
                                                Case "аккиыс.ам"
                                                     B$ = Mid$(B$, i)
                                                    GoTo contElseIf
                                                End Select
                                            Else
                                                Select Case w$
                                                Case "ELSE"
                                                    B$ = Mid$(B$, i)
                                                    GoTo ContElse
                                                Case "ELSE.IF"
                                                    B$ = Mid$(B$, i)
                                                    GoTo contElseIf
                                                End Select
                                            End If
                                            sss = Len(B$)
                                            Else
                                                SetNextLine B$
                                                lbl = True
                                            End If
                                    
                                    End If
                                    jump = True
                                    IFCTRL = 1
                                Else
                                IFCTRL = 2
                                If MaybeIsSymbol(B$, "0123456789") Then GoTo ContGoto
                                i = 1
                                aheadstatusELSE B$, i, Lang, w$
                                If Len(w$) > 2 Then
                                ' #2
                                    ss$ = Left$(B$, i - 1 - Len(w$))
                                    If once Then
                                          once = False
                                                B$ = Mid$(B$, Len(ss$) + 1)
                                                TraceStore bstack, nd&, B$, 0
                                                Call executeblock(Execute, bstack, ss$, once, ok, , True, False)
                                                TraceRestore bstack, nd&
                                                
                                                If Execute = 0 Then
                                                   B$ = ss$ + B$
                                                ElseIf Execute = 5 Then
                                                once = True
                                                GoTo contLoop
                                                ElseIf Execute = 6 Then
                                                B$ = vbNullString
                                                Execute = 2
                                                once = True
                                                Exit Function
                                              ElseIf Execute = 3 Then
                                                    B$ = ss$
                                                    Exit Function
                                                ElseIf Execute = 2 And once Then
                                                    B$ = ss$
                                                    Exit Function
                                                Else
                                                    SetNextLine B$
                                                End If
                                                once = True
                                                Exit Function
                                Else
                                ' else.if else ..... no block
                                    B$ = Mid$(B$, Len(ss$) + 1)
                                    TraceStore bstack, nd&, B$, 0
                                    Call executeblock(Execute, bstack, ss$, False, ok, , True, False)
                                    TraceRestore bstack, nd&
                                    
                                End If
                                If Execute = 1 Then    ' else.if pass
                                If ok Then Exit Function
                                        If FastSymbol(B$, ":") Then
                                            sss = Len(B$)
                                          IFCTRL = 0: GoTo again1
                                        End If
                                        If Not lookB123(B$) Then GoTo contif2
                                ElseIf Execute = 2 Then
                                    If ok And Len(ss$) = 0 Then B$ = "BREAK" Else B$ = ss$
                                    once = False
                                    Exit Function
                                ElseIf Execute = 6 Then
                                    GoTo ContRestart
                                ElseIf Execute = 5 Then
                                loopthis = True
                                Execute = 2
                                Else
                                    If loopthis Then Execute = 2
                                    GoTo ContContinue
                                End If
                                Else
                                If FastSymbol(B$, "{") Then GoTo contelseifpass
                                End If
                              
                                End If
                            Case Else
                                Execute = 0
                                Exit Function
                            End Select
                             If bstack.RetStackTotal > 0 Then
                                If IsLabelSymbolNew(B$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                                If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                                                    If bstack.RetStack.LookTopVal = -3 Then
                                                        jump = False
                                                        IFCTRL = 0
                                                    End If
                                                Else
                           
                            If jump Or IFCTRL = 2 Then
                                i = 1
                                If Not once Then
                                If FastOperator(B$, vbCrLf, i, 2) Then
                                While FastOperator(B$, vbCrLf, i, 2)
                                Wend
                                End If
                                End If
                                If IsLabelSymbolNew(B$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                                If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                                
                            
                            End If
                            End If
                        Case Else
                            Execute = 0
                            Exit Function
                        End Select
                    Else
                        Execute = 0
                        Exit Function
                    End If
                End If
            End If
            sss = Len(B$)
        Case "IF", "ам"
contif:
       
       jump = 0
       IFCTRL = 0
        If IsExp(bstack, B$, p, , True) Then
            x1 = 1           ' NEED THEN OR ELSE OR ELSE.IF
            ok = (p = 0#)                    ' JUMP TRUE GOTO ELSE
            i = 1
            Select Case Abs(IsLabel(bstack, B$, w$))
            Case 1
            Select Case w$
                Case "THEN", "тоте"

                    If ok Then
                        If lookB123(B$) Then
                            i = SetNextLineCLR(B$)
                            MarkIf bstack, 1, ok
                            bstack.UseofIf = bstack.UseofIf + 1
                            x1 = 1
                            aheadstatusELSEIF B$, i, Lang, ok, x1, (ok)
                            DropMark bstack
                            If x1 = 0 Then
                                bstack.UseofIf = bstack.UseofIf - 1
                            Else
                                MarkIf bstack, 1, True
                            End If
                              
                              B$ = Mid$(B$, i)
         
                              IFCTRL = 0
                              jump = False
                        lbl = False
                        If Len(B$) > 0 Then
                        If Left$(B$, 2) = vbCrLf Then lbl = True
                        End If
                        sss = Len(B$)
                        GoTo loopcontinue
                    ElseIf FastSymbol(B$, "{") Then
                               '     If once = True Then Execute = 0: Exit Function
                                    w$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                                    B$ = Mid$(B$, 2)
                                    If FastSymbol(B$, ":") Then
                                    sss = Len(B$)
                                    
                                    IFCTRL = 0: GoTo again1
                                    End If
                                    GoTo contif2
                    Else
contif2:
                                        i = 1
                                        aheadstatusELSE B$, i, Lang, w$
                                        If Len(w$) > 2 Then
                                        jump = ok
                                        If IFCTRL = 0 Then IFCTRL = 1
                                            If Lang = 0 Then
                                                Select Case w$

                                                Case "аккиыс"
                                                    B$ = Mid$(B$, i)
                                                    GoTo ContElse
                                                Case "аккиыс.ам"
                                                     B$ = Mid$(B$, i)
                                                    GoTo contElseIf
                                                End Select
                                            Else
                                                Select Case w$
                                                Case "ELSE"
                                                    B$ = Mid$(B$, i)
                                                    GoTo ContElse
                                                Case "ELSE.IF"
                                                    B$ = Mid$(B$, i)
                                                    GoTo contElseIf
                                                End Select
                                            End If
                                            
                                            sss = Len(B$)
                                        Else
                                    If once Then
                                        w$ = GetStrUntil(vbCrLf, B$, False)
                                        Exit Function
                                    Else
                                        SetNextLine B$
                                        
                                        End If
                                        lbl = True
                                        End If
                                End If
                                If bstack.RetStackTotal = 0 Then
                                        jump = ok
                                       If IFCTRL = 0 Then IFCTRL = 1
                                Else
                                    If Not bstack.RetStack.LookTopVal = -3 Then
                                        jump = ok
                                        If IFCTRL = 0 Then IFCTRL = 1
                                     Else
                                        IFCTRL = 0
                                    End If
                                End If
                    Else
                        
                    If lookB123(B$) Then
                        i = SetNextLineCLR(B$)
                        MarkIf bstack, 2, jump
                        bstack.UseofIf = bstack.UseofIf + 1
                        jump = False
                        IFCTRL = 0
                        lbl = True
                        sss = Len(B$)
                        GoTo loopcontinue
                    Else
                        IFCTRL = 1
                        jump = True
                        If MaybeIsSymbol(B$, "0123456789") Then GoTo ContGoto
                         
                        IFCTRL = 2 ' NONEED ANYTHING BUT NOT ERROR FOR IF.ELSE AND ELSE
                        If Not FastSymbol(B$, "{") Then
                            i = 1
                            aheadstatusELSE B$, i, Lang, w$
                            If Len(w$) > 2 Then
                            ' #3
                                ss$ = Left$(B$, i - 1 - Len(w$))
                                B$ = Mid$(B$, i - Len(w$))
                            If once Then
                            TraceStore bstack, nd&, B$, 0
                            once = False
                                    Call executeblock(Execute, bstack, ss$, once, ok, , True, False)
                                    TraceRestore bstack, nd
                                    If Execute = 0 Then
                                                   B$ = ss$ + B$
                                            ElseIf Execute = 5 Then
                                                once = True
                                                GoTo contLoop
                                            ElseIf Execute = 6 Then
                                                B$ = vbNullString
                                                Execute = 2
                                                once = True
                                                Exit Function
                                            ElseIf Execute = 3 Then
                                            B$ = ss$
                                            Exit Function
                                            ElseIf Execute = 2 And once Then
                                                    B$ = ss$
                                                    Exit Function
                                        ElseIf Execute = 1 Then
                                            If ok And Len(ss$) = 0 Then
                                            B$ = vbNullString
                                            Else
                                            SetNextLineNL B$
                                            End If
                                        Else
                                            If ok = True Then B$ = "BREAK" Else B$ = ss$
                                            once = False
                                           ' Execute = 2
                                        Exit Function
                                    End If
                                    Exit Do
                            Else
                                ' if then ...   else or else.if, no block
                                TraceStore bstack, nd&, B$, 0
                                    Call executeblock(Execute, bstack, ss$, False, ok, , True, False)
                                    TraceRestore bstack, nd&
                            End If
                            If Execute = 1 Then
                            
                                SetNextLine B$
                                lbl = True
                                    If bstack.RetStackTotal > 0 Then
                                        
                                    If bstack.RetStack.LookTopVal = -3 Then
                                        IFCTRL = 0
                                    End If
                                End If
                                If ok Then once = True: B$ = vbNullString: Exit Function
                                
                                
                                
                            ElseIf Execute = 2 Then
                                If ok And Len(ss$) = 0 Then B$ = "BREAK" Else B$ = ss$
                                once = False
                                Exit Function
                            ElseIf Execute = 6 Or Execute = 3 Then
                                    GoTo ContRestart
                            ElseIf Execute = 5 Then
                            loopthis = True
                            ok = False
                                SetNextLine B$
                                Execute = 2
                                    If bstack.RetStackTotal > 0 Then
                                        
                                    If bstack.RetStack.LookTopVal = -3 Then
                                        IFCTRL = 0
                                    End If
                                End If
                            Else
                                If loopthis Then Execute = 2
                                GoTo ContContinue
                            End If
                        Else
                                 If bstack.RetStack.LookTopVal = -3 Then
                                        IFCTRL = 0
                                    End If
                        End If
                        Else
                        
                       ' bstack.addlen = Len(b$)
                        ss$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                        ok = False
                        
                        TraceStore bstack, nd&, B$, 0
                        
                        Call executeblock(Execute, bstack, ss$, False, ok, , True)
                        TraceRestore bstack, nd&
                        B$ = Mid$(B$, 2)
                        If Execute = 1 Then
                            If FastSymbol(B$, ":") Then
                                sss = Len(B$)
                                IFCTRL = 0
                                GoTo again1
                            End If
                            If Not lookB123(B$) Then GoTo contif2
                            IFCTRL = 0
                        ElseIf Execute = 2 Then
                        If ok Then B$ = "BREAK": once = True Else B$ = ss$
                        Exit Function
                        End If
                        End If
                        End If
                    End If
                Case "ELSE", "аккиыс"
                
                    If lookB123(B$) Then
                    
                    
                    If Not ok Then
                        ' find END IF
                         MarkIf bstack, 1, ok
                         bstack.UseofIf = bstack.UseofIf + 1
                        GoTo findEndif
                    Else
                         MarkIf bstack, 0, ok
                         bstack.UseofIf = bstack.UseofIf + 1
                        jump = False
                        IFCTRL = 0
                        lbl = True
                    End If
                    i = SetNextLineCLR(B$)
                    ElseIf Not ok Then       ' JUMP FALSE SKIP ELSE
                    
                        If FastSymbol(B$, "{") Then
                            If once = True Then Execute = 0: Exit Function
                            w$ = block(B$)
                                If Not Left$(B$, 1) = "}" Then
                                    Execute = CheckBlock(once): Exit Function
                                End If

                            B$ = Mid$(B$, 2)
                        Else
                            SetNextLine B$
                            lbl = True
                        End If
                        IFCTRL = 0 ' NONEED ANYTHING AND ERROR FOR IF.ELSE AND ELSE
                    Else
                        If MaybeIsSymbol(B$, "0123456789") Then GoTo ContGoto
                        IFCTRL = 0
                        jump = False
                    End If
                    sss = Len(B$)
                Case Else
                    Execute = 0
                    Exit Function
                End Select
            Case Else
                Execute = 0
                Exit Function
            End Select
            If once Then
            
            sss = Len(B$)
            GoTo again1
            Else
            If jump Or IFCTRL = 2 Then
                i = 1
                If FastOperator(B$, vbCrLf, i, 2) Then
                While FastOperator(B$, vbCrLf, i, 2)
                Wend
                If IsLabelSymbolNew(B$, "аккиыс.ам", "ELSE.IF", Lang) Then GoTo contElseIf
                If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo ContElse
                End If
            End If
            End If
    Else
        ' error
        If LastErNum = -2 Then
            Execute bstack, B$, True
        Else
            MissNumExpr
        End If
        Execute = 0
        Exit Function
    End If
    sss = Len(B$)
Case "SELECT", "епекене", "епикене"  '*************************************** SELECT CASE
contSelect:
        'Us$ = vbNullString
        If once = True Then Execute = 0: Exit Function
        If exeSelect(Execute, once, bstack, B$, v, Lang) Then Exit Function
        If Execute = 2 And Len(B$) = 0 Then Exit Function
        once = False
        lbl = False
        If Len(B$) > 0 Then
        If Left$(B$, 2) = vbCrLf Then lbl = True
        End If
        sss = Len(B$)
Case "апо", "ON"                 '************************************* ON NUMBER GOTO LABELS
ContOn:
        If IsExp(bstack, B$, p, , True) Then
        y1 = IsLabelSymbolNew(B$, "пяос", "GOTO", Lang)
        y2 = False
        If Not y1 Then
        y1 = IsLabelSymbolNew(B$, "диалесоу", "GOSUB", Lang, True)
        y2 = True
        End If
            If y1 Then
            On Error Resume Next
                p = CLng(Int(p))
                        If Err.Number = 6 Then
                                OverflowLong
                                Execute = 0
                                Exit Function
                                End If
                                On Error GoTo 0
                If p <= 0 Then ' no exit
                SetNextLine B$
                If Execute <> 2 Then Execute = 1 Else Execute = 3
            B$ = vbNullString
           once = True
           Exit Function
                Else
                w$ = vbNullString
                i = 0
                Do
                i = 1
                 x1 = FastPureLabel(B$, w$)
                    If x1 = 0 Then
                    If Not IsNumberLabel(B$, w$) Then p = 1000: Exit Do
                    
                    ElseIf x1 > 1 Then
                        p = 1000
                        Exit Do
                    End If
                    i = 0
                    p = p - 1
                    If Not FastSymbol(B$, ",") Then Exit Do
                    
                Loop Until p = 0#
                If p <> 0 Then
                
                If i = 0 Then
                Execute = 1: w$ = GetNextLine$(B$): sss = Len(B$):
                End If
                w$ = vbNullString
                'Exit Do
                Else
                If i > 0 Then
                MissingLabel
                sss = LLL
                  Execute = 0
                Exit Function
                Else
                If y2 Then
                If bstack.SubLevel > deep And deep <> 0 Then
' GO BACK TO FIRST CALL
If bstack.RetStackTotal >= 9 * deep Then
             NoMoreDeep deep

             Execute = 0
             Exit Function

            
Else
bstack.RetStackDrop bstack.RetStackTotal
 End If
  InternalEror
 NOEXECUTION = True
 Execute = 0
Exit Function
 
End If
               
               If p = 1000 Then Exit Function
                SetNextLine B$
               If x1 = 1 Then
               i = 1
               GoTo contHereFromOn
               Else
               GoTo contHere2FromOn
               End If
               
                
                End If
                B$ = w$
                Execute = 2
                Exit Function
                End If
                End If
                End If
            Else
              sss = LLL
            End If
        Else
            MissParam B$
            Execute = 0
            Exit Function
        End If
          
Case "SUB", "яоутима"
contSub:
           If once = True Then Execute = 0: Exit Function
   If Execute <> 2 Then
              B$ = w$
           once = True
           Execute = 3
         
           Else
           B$ = vbNullString
           
        End If
           Exit Function
Case "GOSUB", "диалесоу"
autogosub:
    If myexit(bstack) Then Execute = 1: Exit Function
    If bstack.SubLevel > deep And deep <> 0 Then
        ' GO BACK TO FIRST CALL
        If bstack.RetStackTotal >= 9 * deep Then
            NoMoreDeep deep
            Execute = 0
            Exit Function
        Else
            bstack.RetStackDrop bstack.RetStackTotal
        End If
        InternalEror
        NOEXECUTION = True
        Execute = 0
        Exit Function
    End If
    If Len(bstack.tmpstr) = 0 Then
        i = FastPureLabel(B$, w$)
        If i = 6 Or i = 3 Then
againsub:
            If Len(B$) = 0 Then
                bstack.tmpstr = w$ + " "
                BackPort B$
            Else
                bstack.tmpstr = w$ + Left$(B$, 1)
                BackPort B$
            End If
            If Not IsStrExp(bstack, B$, w$, False) Then
                InternalEror
                Execute = 0
                Exit Function
            End If
            i = FastPureLabel(w$, "", , , , , False)
            If i = 5 Then bb$ = w$: GoTo constrsub
        End If
    Else
        i = FastPureLabel(bstack.tmpstr, w$)
        bstack.tmpstr = vbNullString
        If i = 6 Or i = 3 Then GoTo againsub
    End If
contHereFromOn:
    If i = 5 Then
        once = False
        y1 = bstack.soros.Total
        If Not PushParamSUB(bstack, B$) Then
            y1 = bstack.soros.Total - y1
            If y1 > 0 Then bstack.soros.drop y1
            Execute = 0
            Exit Function
        End If
        If FastSymbol(B$, ")") Then
            PushStage bstack, False
            bstack.RetStack.PushLong Len(B$) '********************************
            If Lang Then
                bstack.RetStack.PushStr "SUB " + w$
            Else
                bstack.RetStack.PushStr "яоутима " + w$
            End If
            B$ = ChrW$(0)
            loopthis = Execute = 2
            Execute = 2
            bstack.IFCTRL = IFCTRL
            bstack.jump = jump
            Exit Function
        Else
            MissSymbol ")"
            Execute = 0
            Exit Function
        End If
    ElseIf i = 1 Then
        once = False
        PushStage bstack, True
        bstack.RetStack.PushVal Len(B$)
        bstack.RetStack.PushStr "S " + w$
        B$ = Chr$(0)
        Execute = 2
        Exit Function
    ElseIf i = 0 Then
        If IsNumberLabel(B$, w$) Then
contHere2FromOn:
        once = False
        PushStage bstack, True  ' CORRECT FROM REV 45 - VER 8
        bstack.RetStack.PushVal Len(B$)
        bstack.RetStack.PushStr "* " + w$
        B$ = Chr$(0)
        bstack.IFCTRL = IFCTRL
        bstack.jump = jump
        Execute = 2
        Exit Function
    Else
        If Not IsStrExp(bstack, B$, bb$) Then
            InternalEror
            Execute = 0
            Exit Function
        End If
constrsub:
        i = FastPureLabel(bb$, w$)
        If i = 5 Then
            once = False
            y1 = bstack.soros.Total
            If Not PushParamSUB(bstack, bb$) Then
                y1 = bstack.soros.Total - y1
                If y1 > 0 Then bstack.soros.drop y1
                    Execute = 0
                    Exit Function
                End If
                If FastSymbol(bb$, ")") Then
                    PushStage bstack, False
                    bstack.RetStack.PushVal Len(B$)
                    If Lang Then
                        bstack.RetStack.PushStr "SUB " + w$
                    Else
                        bstack.RetStack.PushStr "яоутима " + w$
                    End If
                    B$ = Chr$(0)
                    '' here is the fault...execute 2 means loop...
                    '' it is known only here...
                    loopthis = Execute = 2
                    Execute = 2
                    bstack.IFCTRL = IFCTRL
                    bstack.jump = jump
                    Exit Function
                Else
                    MissSymbol ")"
                    Execute = 0
                    Exit Function
                End If
            ElseIf i > 0 Then
                bb$ = vbNullString
                GoTo contHereFromOn
            End If
        End If
    Else
        bstack.tmpstr = w$ + Left$(B$, 1)
        BackPort B$
        Exit Do
    End If
Case "GOTO", "пяос"               '**************************************** This is the GOTO statement
ContGoto:
        If myexit(bstack) Then Execute = 1: Exit Function
        If Trim$(B$) = vbNullString Or FastSymbol(B$, ":") Then
                Execute = 0
                MissingLabel
                Exit Function
        Else
        ' GET OUT FOR NEXT
    
        
        i = FastPureLabel(B$, w$, , , , , False)

                If i = 1 Then
                    once = False
                    B$ = w$
                    Execute = 2
                    Exit Function
                ElseIf i = 0 Then
                    If IsNumberLabel(B$, w$) Then
                        once = False
                        B$ = w$
                        Execute = 2
                        Exit Function
                        '  Else
                        'b$ = w$ & b$
                    End If
                Else
                    'b$ = w$ & b$
                
                Exit Do
                End If
              End If
Case "LOCAL", "топийа", "топийг", "топийес"
contNegLocal:
            'If Not NewStat Then
            
                    If Not NewStat Then
                    If IsLabelSymbolNew(B$, "олада", "GROUP", Lang) Then
                    If Not ProcGroup(-1, bstack, B$, Lang) Then
                    Execute = 0
                    Exit Function
                    End If
                    GoTo loopcontinue
                    End If
                    NewStat = True
                    End If
                    sss = Len(B$)
                    LLL = sss
                iscom = True
                    Select Case IsLabelDotSub(temphere$, B$, w$, ss$, Lang, nchr)
                    Case 1234, 0
                    GoTo errstat
                    Case 1
                    If Left$(w$, 1) = "." Then
                     ss$ = w$
                    IsLabel bstack, ss$, w$
                    End If
                    GoTo VarOnly
                    Case 2
                    noref
                    Execute = 0
                    Exit Function
                    Case 3
                    GoTo contcase3
                    Case 4
                    GoTo contcase4
                    Case 5
                    GoTo contcase5
                    Case 6
                    GoTo contcase6
                    Case 7
                    GoTo contcase7
                    End Select
                  GoTo errstat
Case "GLOBAL", "цемийо", "цемийг", "цемийес"
contNegGlobal:
              '  If NewStat Then LocalAndGlobal: Execute = 0: Exit Function
                If Not VarStat Then
                If IsLabelSymbolNew(B$, "олада", "GROUP", Lang) Then
                    ' group can't be used as variable because exist read only variable
                    ' which pop group from stack
               If Not ProcGroup(1, bstack, B$, Lang) Then Execute = 0: Exit Function
               ElseIf IsLabelSymbolNew(B$, "цецомос", "EVENT", Lang) Then
                If lookOne(B$, "=") Then
                
                VarStat = True
                    If Lang = 0 Then
                    w$ = "цецомос"
                       Else
                    w$ = "EVENT"
                    End If
                    sss = Len(B$)
                    GoTo VarOnly
                End If
                If Not GlobalEVENT(bstack, B$, Lang) Then Execute = 0: Exit Function
                ElseIf IsLabelSymbolNew(B$, "йатастасг", "INVENTORY", Lang) Then
                If lookOne(B$, "=") Then
                
                VarStat = True
                    If Lang = 0 Then
                    w$ = "йатастасг"
                       Else
                    w$ = "INVENTORY"
                    End If
                    sss = Len(B$)
                    GoTo VarOnly
                End If
                If IsLabelSymbolNew(B$, "оуяа", "QUEUE", Lang) Then
                    If Not GlobalHandler(bstack, B$, Lang, 3) Then Execute = 0: Exit Function
                Else
                    If Not GlobalHandler(bstack, B$, Lang, 1) Then Execute = 0: Exit Function
                End If
                ElseIf IsLabelSymbolNew(B$, "диаяхяысг", "BUFFER", Lang) Then
                           If lookOne(B$, "=") Then
                
                VarStat = True
                    If Lang = 0 Then
                    w$ = "диаяхяысг"
                       Else
                    w$ = "BUFFER"
                    End If
                    sss = Len(B$)
                    GoTo VarOnly
                End If
                If Not GlobalHandler(bstack, B$, Lang, 2) Then Execute = 0: Exit Function
            
                ElseIf IsLabelSymbolNew(B$, "апая", "ENUM", Lang) Then

                If Not ProcEnum(bstack, B$, True) Then Execute = 0: Exit Function
                GoTo loopcontinue
                ElseIf IsLabelSymbolNew(B$, "апаяихлгсг", "ENUMERATION", Lang) Then

                If Not ProcEnum(bstack, B$, True) Then Execute = 0: Exit Function

                GoTo loopcontinue
                ElseIf IsLabelSymbolNew(B$, "долг", "STRUCTURE", Lang) Then

                If Not makestruct(bstack, B$, Lang, VarStat, False) Then Execute = 0: Exit Function

                GoTo loopcontinue
                Else
                GoTo CONT12212
               End If
                VarStat = True
                sss = Len(B$)
               
                Else
CONT12212:
                VarStat = True
                sss = Len(B$)
                
                    LLL = sss
                iscom = True
                    Select Case IsLabelDotSub(temphere$, B$, w$, ss$, Lang, nchr)
                    Case 1234, 0
                    GoTo errstat
                    Case 1
                    If Left$(w$, 1) = "." Then
                     ss$ = w$
                    IsLabel bstack, ss$, w$
                    ElseIf comhash.Find2(w$, i, v) Then
                    If i = 0 And v = 36 Then
                    ConstNew bstack, B$, w$, True, Lang
                    
                    If LastErNum = -1 Then
                    Execute = 0
                    Exit Function
                    End If
                    sss = Len(B$)
                    GoTo loopcontinue
                    End If
                    
                    End If
                    GoTo VarOnly
                    Case 2
                    noref
                    Execute = 0
                    Exit Function
                    Case 3
                    GoTo contcase3
                    Case 4
                    GoTo contcase4
                    Case 5
                    GoTo contcase5
                    Case 6
                    GoTo contcase6
                    Case 7
                    GoTo contcase7
                    End Select
                  GoTo errstat
                  End If
Case "CONST", "стахеяг", "стахеяес"
makeconst:
        ConstNew bstack, B$, w$, here$ = vbNullString, Lang
         If LastErNum = -1 Then
                    Execute = 0
                    Exit Function
                    End If
       ' sss = Len(b$)
        'GoTo AGAIN1
Case Else
    If Not NoOptimum Then
        If Not iscom Then GoTo parsecommand
    Else
    iscom = False
    End If
VarOnly:
    
    On ExecuteVar(Execute, 1, bstack, w$, B$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers, forerror
    
    If NoOptimum Then
    If GetSub(w$, v) Then
        iscom = True
    End If
    End If
parsecommand:
                    'If VarStat Or NewStat Then GoTo errstat
    
    If Not Identifier(bstack, w$, B$, iscom, Lang) Then
    
    If NERR Then NOEXECUTION = True
conthere111:
        If LastErNum1 = -1 And bstack.IamThread Then Execute = 1 Else Execute = 0
        Exit Function
        ' just happy here
exitdo:
        Exit Do
exitfunc:
        Set bstack.lastpointer = Nothing
        Exit Function
    Else
        If bstack.callx1 > 0 Then
            If Not ProcModuleEntry(bstack, "", 0, B$, Lang) Then
                          If MOUT And B$ = vbNullString Then
                Else
                    unknownid B$, w$
                End If
            End If
            bstack.RemoveOptionals
        End If
        iscom = False
conthere222:
        If bstack.connectnow Then
            bstack.connectnow = False
        End If
        If NocharsInLine(B$) Then Exit Do Else lbl = lookOne(B$, Chr(13))
    End If
End Select

    Else
   B$ = w$ & B$
    Execute = 0
         If FindNameForGroup(bstack, w$) Then
                UnknownProperty w$
        Else
                UnknownVariable w$
        End If

    Exit Function
forerror:
Execute = 0
Exit Function
    End If

Case 2
If Not lbl Then B$ = w$ & B$: Exit Do
B$ = Mid$(B$, 2)
lbl = False
sss = Len(B$)
Case 3
contcase3:
On ExecuteVar(Execute, 3, bstack, w$, B$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 4
contcase4:
On ExecuteVar(Execute, 4, bstack, w$, B$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 5
contcase5:
On ExecuteVar(Execute, 5, bstack, w$, B$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 6
contcase6:
On ExecuteVar(Execute, 6, bstack, w$, B$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 7
contcase7:
On ExecuteVar(Execute, 7, bstack, w$, B$, v, Lang, VarStat, NewStat, nchr, ss$, sss, temphere$) GoTo exitdo, autogosub, loopagain, contVarNew, again3, parsecommand, loopcontinue, exitfunc, forpointers, forfloatpointers
Case 8:
If Len(bstack.tmpstr) > 0 And Len(B$) > 0 Then
    w$ = bstack.tmpstr
    Mid$(B$, 1, 1) = Right$(w$, 1)
    
    If Left$(w$, 1) = "@" Then
    w$ = Mid$(w$, 2, Len(w$) - 2)
    GoTo parsecommand
    End If
    w$ = Left$(w$, Len(w$) - 1)
    
        
        B$ = NLtrim$(B$)
        If Right$(w$, 1) = "." Then
         x1 = IsLabelDotSub(temphere$, B$, sw$, ss$, Lang, nchr)
         w$ = w$ + sw$
         
        ' sss = Len(b$)
        'LLL = sss
        one = True
        
        nchr = AscW(w$)
        Else
        'sss = Len(b$)
        'LLL = sss
        SwapStrings sw$, w$
        x1 = IsLabelDotSub(temphere$, sw$, w$, ss$, Lang, nchr)
        one = True
        If Len(Trim(sw$)) > 0 Then
        If nchr = 40 Then
        nchr = AscW(w$)
        B$ = sw$ + B$
        Else
        nchr = AscW(sw$)
        End If
        Else
        nchr = AscW(w$)
        End If
        
        End If
        
        bstack.tmpstr = vbNullString
        GoTo again4
    
Else
    MyEr "Internal Error 2", "еСЫТЕЯИЙЭ КэХОР 2"
    Execute = 0
    Exit Function
End If
Case Else
If lookOne(B$, ".") Then
B$ = NLtrim$(B$)
        nd& = Len(B$)
        If bstack.GetDot(B$, (1)) Then
           sss = (Len(B$) - nd&) + sss
           LLL = (Len(B$) - nd&) + LLL
        End If
        GoTo again2
Else
one = False
End If
If MaybeIsSymbol(B$, ",+*/_!@()[];<>|~`0123456789") Then
SyntaxError
Execute = 0
Exit Function
End If
End Select
loopcontinue:
If once Then

'If jump Or IFCTRL Then
    If Not lookOne(B$, ":") Then
    Exit Do
    Else
    If onlyone Then Exit Do

    End If
'Else
'Exit Do
'End If
End If
loopagain:
If one Then
If linebyline Then
If Not lookOne(B$, ":") Then Exit Do
End If
End If
Loop
JUMPHERE:

If linebyline Then
With bstack
.IFCTRL = IFCTRL
.jump = jump
End With
End If
'linebyline = False

If Len(B$) > 0 Then If AscW(B$) = 34 Then SyntaxError: Execute = 0
Exit Function
errstat0:
MyEr Err.Description, Err.Description
Err.Clear
     Execute = 0: Exit Function
errstat1:
MissModuleName
     Execute = 0: Exit Function
errstat:
MissVarName
     Execute = 0: Exit Function
LONGERR:
    If Err.Number = 6 Then
            Execute = 0
            OverflowLong
    ElseIf Err.Number = 450 Then
            Execute = 0
            WrongOperator
            End If
Exit Function
forfloatpointers:
Set pppp = BoxGroupObj(bstack.lastpointer)

v = 0
 Set bstack.lastpointer = Nothing
 Execute = SpeedGroup(bstack, pppp, "", w$, B$, v)
 Set pppp = Nothing  ' now group ref counting work fine
                                      If Execute = 0 Then
                                      Exit Function
                                      ElseIf Execute <> 1 And B$ <> "" Then
                                     once = False
                                      Exit Function
                                     End If
                                        sss = Len(B$)
                                        GoTo loopagain
forpointers:

If Len(B$) > 1 Then

    If Not bstack.lastpointer Is Nothing Then
        '  Mid$(b$, 1, 1) = " "
        nchr = 0
        x1 = IsLabelDotSub(temphere$, B$, w$, ss$, Lang, nchr)
        With bstack.lastpointer
           If x1 = 0 Then
                Select Case nchr
                Case 40
                    If .link.HasStrValue Then
                        If here$ = .lasthere Then
                            w$ = .GroupName + "$("
                        Else
                            w$ = .lasthere + "." + .GroupName + "$("
                        End If
                        Mid$(B$, 1, 1) = " "
                        x1 = 6
                        sss = Len(B$)
                        GoTo contcase6
                    Else
                        If here$ = .lasthere Then
                            w$ = .GroupName + "("
                        Else
                            w$ = .lasthere + "." + .GroupName + "("
                        End If
                        Mid$(B$, 1, 1) = " "
                        x1 = 5
                        sss = Len(B$)
                        GoTo contcase5
                    End If
                Case 60
                    w$ = .lasthere + "." + .GroupName
                Case Else
                    If here$ = .lasthere Then
                        w$ = .GroupName
                    Else
                        w$ = .lasthere + "." + .GroupName
                    End If
                End Select
                x1 = 1
            
                GoTo VarOnly
            Else
            If .lasthere = vbNullString Then
                w$ = .GroupName + "." + w$
            Else
                w$ = .lasthere + "." + .GroupName + "." + w$
                End If
                If MaybeIsSymbol3(B$, "=", i) Then
                If i = 1 Then
                Mid$(B$, 1, 1) = "_"
                Else
                Mid$(B$, i - 1, 1) = "<"
                End If
                
                End If
            End If
            End With
            Set bstack.lastpointer = Nothing
        Else
            InternalError
            Execute = 0
            Exit Function
        End If

End If
GoTo again4


End Function

Function GoFunc(mystack As basetask, what$, rest$, vl As Variant, Optional Recursive As Long, Optional ByVal choosethis As Long = -1, Optional ByVal strg As Boolean = False, Optional ByVal usesamestack As Boolean = False) As Boolean
Dim f As Long, it As Long, pa$
Dim x1 As Long, par As Boolean, ohere$, w$, loopthis As Boolean
Dim Vars As Long, Vname As Long, subs As Long, snames As Long
Dim once As Boolean, RetStackSize As Long
Dim subsfc As FastCollection
Dim c As Constant, myl As lambda
Dim basestack As basetask
Dim ok As Boolean, nokillvars As Boolean
Dim i As Long, p As Long, S3 As Long, bb$, code$, ec$, small$, sbi As Long
Set basestack = mystack.Parent
If basestack Is Nothing Then Set basestack = mystack
ohere$ = here$
Dim backup$, TSHB As Boolean
If trace Then SwapStrings backup$, TestShowSub: TSHB = TestShowBypass
TestShowBypass = False
If CurrentStackSize > stacksize Then
    MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
    MOUT = True
    Set basestack = Nothing
    GoFunc = False: GoTo lastfun
End If
pa$ = mystack.UseGroupname
mystack.UseGroupname = basestack.UseGroupname
mystack.Look2Parent = True
mystack.strg = strg
mystack.fHere = here$
Vname = varhash.count
Vars = var2used
If usesamestack Then
    Set mystack.Sorosref = basestack.soros
Else
    If Not PushParamGeneralV70(mystack, rest$, basestack.restpart) Then
        mystack.Look2Parent = False
        GoTo lastfun
    End If
End If
mystack.Look2Parent = False
mystack.UseGroupname = pa$
If choosethis >= 0 Then
    x1 = choosethis
    If what$ = vbNullString Then
        If SecureNames Then
            If Left$(here$, 1) <> "_" Then If basestack.IamThread Then here$ = "_" + LTrim$(Str$(basestack.Process.id)) + here$
            here$ = RVAL33(here$, x1)
        Else
            here$ = RVAL(here$, 1) + mystack.originalname
        End If
    ElseIf Recursive Then
        here$ = RVAL(here$, 1) & "." & Trim$(what$)
        If SecureNames Then If basestack.IamThread Then If Left$(here$, 1) <> "_" Then here$ = "_" + LTrim$(basestack.Process.id) + here$: basestack.StaticInUse = LTrim$(basestack.Process.id)
    Else
        If SecureNames Then If basestack.IamThread Then If basestack.StaticInUse = vbNullString Then basestack.StaticInUse = LTrim$(basestack.Process.id)
    End If
Else
    If InStr(what$, "(") > 0 Then
        If GetSub(what$, x1) Then
            If here$ = vbNullString Then
                If ohere$ = vbNullString Then here$ = what$
            Else
                here$ = RVAL(here$, 1) & "." & Trim$(what$)
                If SecureNames Then If basestack.IamThread Then If Left$(here$, 1) <> "_" Then here$ = "_" + LTrim$(basestack.Process.id) + here$: basestack.StaticInUse = LTrim$(basestack.Process.id)
            End If
        ElseIf GetSub2(basestack, what$, x1) Then
            If here$ = vbNullString Then
                If ohere$ = vbNullString Then here$ = what$
            Else
                here$ = RVAL(here$, 1) & "." & Trim$(what$)
            End If
        End If
    Else
        If here$ = vbNullString Then
            If GetSub(what$, x1) Then
                here$ = RVAL(here$, 1)
            End If
        ElseIf GetlocalSub(what$, x1) Then
            here$ = RVAL(here$, 1)
        ElseIf GetSub(what$, x1) Then
            here$ = RVAL(here$, 1)
        ElseIf Recursive > 0 Then
            here$ = RVAL(here$, 1)
            x1 = Recursive
        End If
    End If
End If
 ' prepare function for static variables
If iRVAL(basestack.StaticInUse, 0) = 0 Then
    mystack.StaticInUse = RVAL(basestack.StaticInUse, 1) + "." + what$ + mystack.StaticInUse
  '  If Not basestack Is Basestack1 Then
        If Not basestack.StaticCollection Is Nothing Then
            StaticWork basestack, mystack, mystack.StaticInUse$
        End If
   ' End If
ElseIf basestack.OriginalCode = mystack.OriginalCode Then
    mystack.StaticInUse = basestack.StaticInUse
    Set mystack.StaticCollection = basestack.StaticCollection
Else
    mystack.StaticInUse = RVAL(basestack.StaticInUse, 1) + "." + what$ + mystack.StaticInUse
    If mystack.CallLocalLast Then
    mystack.StaticInUse = basestack.StaticInUse
    ElseIf Not basestack Is Basestack1 Then
        If Not basestack.StaticCollection Is Nothing Then
            StaticWork basestack, mystack, mystack.StaticInUse$
        End If
    End If
End If

If here$ <> ohere$ Or mystack.IamChild Or basestack.IamAnEvent Then
    subs = sb2used: snames = subHash.count
    If Not mystack.CallLocalLast Then
        With mystack
            .commnum = comhash.count
            .strfunnum = strfunid.count
            .numfunnum = funid.count
            .strnum = strid.count
            .numnum = numid.count
        End With
    End If
    i = 1: FK$(13) = vbNullString
    nokillvars = basestack.nokillvars: basestack.nokillvars = False
    If nokillvars Then
        mystack.ErrVars = basestack.ErrVars
        If sbf(x1).sbc Then
            numid.pushtopGlobal
            funid.pushtopGlobal
            strfunid.pushtopGlobal
            funid.pushtopGlobal
        End If
    Else
        mystack.ErrVars = var2used
    End If
    If Mid$(sbf(x1).sb, i) = vbNullString Then
        GoFunc = True
        If sbf(x1).Extern = 0 Then GoTo emptyfunc
    End If
    mystack.originalname$ = here$
    If usesamestack Then
        GoFunc = True
    ElseIf FastSymbol(rest$, ")") Then
        GoFunc = True
    ElseIf GoFunc Then
        MyEr "Missing )", "КЕъПЕИ )"
        GoFunc = False
        GoTo lastfun
    End If

    If FastSymbol(rest$, "<<", , 2) Then
        f = 1
        w$ = aheadstatus(rest$, True, f)
        w$ = Left$(rest$, f - 1)
        rest$ = Mid$(rest$, f)
        f = 1
        While FastSymbol(rest$, "<<", , 2)
            pa$ = aheadstatus(rest$, True, f)
            w$ = w$ + " << " + Left$(rest$, f - 1)
            rest$ = Mid$(rest$, f)
            f = 1
        Wend
        mystack.CallW = w$
        mystack.NoFuncError = True
        par = True
    End If
    
    Do
        If choosethis >= 0 Then
            mystack.UseGroupname = pa$
        Else
            mystack.UseGroupname = sbf(x1).sbgroup
            mystack.tpointer = sbf(x1).tpointer
        End If
        code$ = Mid$(sbf(x1).sb, i)
        If Len(code$) = 0 Then
            If sbf(x1).Extern > 0 Then
                If Not PrepareLambda(mystack, myl, sbf(x1).Extern, code$, c) Then
                    GoTo fastexit
                End If
            End If
        End If
        it = 1
        RetStackSize = mystack.RetStackTotal
againstream:
        ec$ = code$
        If Len(ec$) > 0 Then
            it = 1
            ok = False
            once = True
            i = 1
            Do
                bb$ = Mid$(ec$, i)
subsentry10:
                ok = False
                Select Case Execute(mystack, bb$, ok, False, loopthis)   ' this is a major point
                Case 0
thh:
                    code$ = bb$
                    it = 0
                    Set mystack.lastobj = Nothing
                    GoTo normalexit
                Case 1
                    If LastErNum <> 0 Then code$ = vbNullString
                    If once Then Exit Do
                    here$ = ohere$
                    Exit Do
                Case 2
                    If Not ok Then
                        i = 1
                        If Len(bb$) <> 0 Then
                            If bb$ = ChrW$(0) Then
                                If trace Then TestShowBypass = False
                                If RetStackSize = mystack.RetStackTotal And mystack.RetStack.LookTopVal < 0 Then
                                ' this is a return form other block
                                    it = 2
                                    SwapStrings code$, bb$
                                    GoTo fastexit
                                End If
                                If Not mystack.IsInRetStackString(small$) Then
                                    p = mystack.isPop3Long(S3, sbi)
                                    If p > 0 Then
                                        If S3 > 0 Then
                                            bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                        ElseIf S3 = 0 Then
                                            bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                        Else
                                            bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                        End If
                                        If trace Then
                                            TestShowBypass = True
                                            If TestShowBypass Then
                                                If S3 < 0 Then
                                                    TestShowSub = var(-S3).code
                                                ElseIf S3 = 0 Then
                                                    TestShowSub = ec$
                                                Else
                                                    TestShowSub = sbf(S3).sb
                                                End If
                                            End If
                                            mystack.addlen = sbi
                                        End If
                                        PopStage mystack
                                        GoTo subsentry10
                                    Else
fulty:
                                        MyEr "Fault in Return", "кэХОР СТГМ еПИСТЯОЖч"
                                        mystack.Flush
                                        Exit Do
                                    End If
                                Else
                                    If InStr(small$, " ") > 0 Then
                                        mystack.PushSecondThird S3, sbi
                                        If searchsub(mystack.OriginalCode, small$, i, S3, bb$) Then
                                            If Len(small$) <> 0 Then If Not MyRead(7, mystack, small$, 1) Then GoTo thh
                                            GoTo contSub
                                        ElseIf mystack.IamChild Then
                                            If searchsub(FindPrevOriginal(mystack), small$, i, S3, bb$) Then
                                                If Len(small$) <> 0 Then If Not MyRead(7, mystack, small$, 1) Then GoTo thh
contSub:
                                                If Len(bb$) = 0 Then
                                                    If S3 < 0 Then
                                                        bb$ = Mid$(var(-S3).code, i)
                                                    Else
                                                        bb$ = Mid$(sbf(S3).sb, i)
                                                    End If
                                                    sbi = 0
                                                Else
                                                    If S3 < 0 Then
                                                        sbi = Len(var(-S3).code) - i - Len(bb$)
                                                    Else
                                                        sbi = Len(sbf(S3).sb) - i - Len(bb$)
                                                    End If
                                                End If
                                                If trace Then
                                                    TestShowBypass = True
                                                    If TestShowBypass Then
                                                        If S3 < 0 Then
                                                            TestShowSub = var(-S3).code
                                                        Else
                                                            TestShowSub = sbf(S3).sb
                                                        End If
                                                    End If
                                                    mystack.addlen = Len(TestShowSub) - i + 1 - Len(bb$)
                                                End If
                                                GoTo subsentry10
                                            Else
therebad:
                                                badSubNotFound
                                                If mystack.IsDecimal Then
                                                    p = mystack.Pop3Long(S3, sbi)
                                                    If S3 > 0 Then
                                                        bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                                    ElseIf S3 = 0 Then
                                                        bb$ = Mid$(ec$, Len(ec$) - p + 1)
                                                    Else
                                                        bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                                    End If
                                                End If
                                                mystack.RetStackDrop 3 '5
                                                GoTo thh  ' see procmoduleentry myerror1: for additional code
                                                ' or exit do ???
                                            End If
                                        Else
                                            GoTo therebad
                                        End If
                                    End If
                                End If
                            ElseIf bb$ = "BREAK" Then
                                GoTo breakexit
                            Else
                                If subsfc Is Nothing Then Set subsfc = New FastCollection
                                If subsfc.ExistKey(bb$) Then
                                    i = subsfc.Value
                                    If subsfc.sValue = 0 Then
                                        If i = 0 Or i > Len(ec$) Then
                                            SwapStrings rest$, bb$
                                            '  bstack.addlen = nd&
                                            GoTo thh
                                        Else
                                            bb$ = Mid$(ec$, i)
                                            sbi = 0 ' ???? CHECK THIS
                                        End If
                                    Else
                                        S3 = subsfc.sValue
                                        If S3 < 0 Then
                                            If i = 0 Or i > Len(var(-S3).code$) Then
                                                SwapStrings rest$, bb$
                                                '  bstack.addlen = nd&
                                                GoTo thh
                                            Else
AGAINGOTOLAMBDA:
                                                If mystack.SubLevel > 0 Then
                                                    If Len(var(-S3).code$) - i > sbi Then
                                                        bb$ = Mid$(var(-S3).code$, i, Len(var(-S3).code$) - i - sbi)
                                                    Else
                                                        bb$ = Mid$(var(-S3).code$, i)
                                                        sbi = 0
                                                    End If
                                                Else
                                                    bb$ = Mid$(var(-S3).code$, i)
                                                    sbi = 0
                                                End If
                                            End If
                                        Else
                                            If i = 0 Or i > Len(sbf(S3).sb) Then
                                                SwapStrings rest$, bb$
                                                '  bstack.addlen = nd&
                                                GoTo thh
                                            End If
AGAINGOTO:
                                            If mystack.SubLevel > 0 Then
                                                If Len(sbf(S3).sb) - i > sbi Then
                                                    bb$ = Mid$(sbf(S3).sb, i, Len(sbf(S3).sb) - i - sbi)
                                                Else
                                                    bb$ = Mid$(sbf(S3).sb, i)
                                                    sbi = 0
                                                End If
                                            Else
                                                bb$ = Mid$(sbf(S3).sb, i)
                                                sbi = 0
                                            End If
                                        End If
                                    End If
                                    GoTo subsentry10
                                Else
                                    If S3 = 0 Then
                                        i = PosLabel(bb$, ec$)
                                        If i = 0 Or i > Len(ec$) Then
                                            GoTo checkother
                                        Else
                                            subsfc.ItemCreator2 bb$, i, 0
                                            bb$ = Mid$(ec$, i)
                                            sbi = 0
                                            GoTo subsentry10
                                        End If
                                    End If
checkother:
                                If S3 < 0 Then
                                    i = PosLabel(bb$, var(-S3).code$)
                                    If i = 0 Or i > Len(var(-S3).code$) Then
                                        SwapStrings rest$, bb$
                                        '  bstack.addlen = nd&
                                        GoTo thh
                                    End If
                                    subsfc.ItemCreator2 bb$, i, S3
                                    GoTo AGAINGOTOLAMBDA
                                Else
                                    i = PosLabel(bb$, sbf(S3).sb)
                                    If i = 0 Or i > Len(sbf(S3).sb) Then
                                        SwapStrings rest$, bb$
                                         '  bstack.addlen = nd&
                                        GoTo thh
                                    End If
                                    subsfc.ItemCreator2 bb$, i, S3
                                    GoTo AGAINGOTO
                                    
                                End If
                                
                                GoTo subsentry10
                            End If
                            End If
                        Else
                            loopthis = False
                        End If
                    Else ' ok is true
                        code$ = ""
                        once = ok
                        it = 2: Set mystack.lastobj = Nothing
                        GoTo breakexit
                    End If
                Case Else
                    If once Then Exit Do
                    here$ = ohere$
                    Exit Do
                End Select
                here$ = ohere$
                If myexit(mystack) Then it = 1: Exit Do
            Loop
        ElseIf mystack.UseofIf > 0 Then
            MissENDIF
            it = 0
        Else
            it = 1
        End If
breakexit:
normalexit:
fastexit:
        TestShowBypass = False
        If Not myl Is Nothing Then
            myl.CopyFromVar mystack, var()
            If c Is Nothing Then Set var(sbf(x1).Extern) = myl
        End If
        If Not basestack.CopyInOutCol Is Nothing Then CopyBack basestack
        Select Case it ''Execute(mystack, code$, False)
        Case 0
            Set mystack.lastobj = Nothing
            Set mystack.FuncObj = Nothing
            mystack.ThrowThreads  ' always throw threads
            If Not NERR Then   ' Nerr = true from command ERROR 0 means Fatal Error, shows a message and act as a crash!
                If Not myl Is Nothing Then
                    MyErMacro rest$, Chr(0) + "Problem in lambda", Chr(0) + "пЯЭБКГЛА СТГ КэЛДА"
                    FK$(13) = "EDIT " + sbf(myl.OriginalCode).goodname + ", " + CStr(-myl.lastlen - Len(rest$) + 1)
                    GoTo there1234
                End If
                If Len(mystack.UseGroupname) > 0 Then
                    If InStr(mystack.UseGroupname, ChrW(&H1FFF)) > 0 Then
                        pa$ = GetNextLine((sbf(Abs(mystack.OriginalCode)).sb))
                        If InStr(pa$, ",") = 0 Then
                            pa$ = "'11001EDIT " + GetModuleName(mystack, here$) + "," + Mid$(pa$, 11)
                        End If
                        FK$(13) = Mid$(pa$, 7) + "-" + LTrim$(Str(Len(NLtrim$(code$))))
                        If Right$(GetName(sbf(x1).goodname), 2) = "()" Then
                            MyErMacro rest$, "Problem in class in function " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), "пЯЭБКГЛА СТГ ЙКэСГ СТГ СУМэЯТГСГ " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        Else
                            MyErMacro rest$, "Problem in class in module " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), "пЯЭБКГЛА СТГ ЙКэСГ СТО ТЛчЛА " + Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        End If
                        GoTo there1234
                    End If
                End If
                pa$ = GetModuleName(mystack, here$)
                If Right$(pa$, 1) = "(" Then pa$ = pa$ + ")"
                pa$ = "EDIT " & pa$ & ", " + CStr(Len(sbf(x1).sb) + 1)
                If Left$(sbf(x1).sb, 10) = "'11001EDIT" Then
                    pa$ = Mid$(GetNextLine(sbf(x1).sb), 7) ''+ "+1"
                    sbf(x1).sb = Mid$(sbf(x1).sb, 3) ' needed because we measure length...look the preparation of Shift F1 below
                    Set sbf(x1).subs = Nothing
                    If what$ <> "" Then
                        If InStrRev(here$, ".") > 0 Then
                        ' any fucntion defined inside module or function has this direction
                        MyEr "in function " & Mid$(what$, InStrRev(what$, ".") + 1), "СТГ СУМэЯТГСГ " & Mid$(what$, InStrRev(what$, ".") + 1)
                    Else
                        MyEr "in function " & what$, "СТГ СУМэЯТГСГ " & what$
                    End If
                Else
                    If Right$(GetName(sbf(x1).goodname), 2) = "()" Then
                        MyEr "in function ", "СТГ СУМэЯТГСГ "
                    Else
                        MyEr "in module ", "СТО ТЛчЛА "
                    End If
                End If
            Else
                If Right$(here$, 1) = ")" Then
                    If what$ <> "" Then
                        MyEr "in function " & what$, "СТГ СУМэЯТГСГ " & what$
                    Else
                        MyEr "in function ", "СТГ СУМэЯТГСГ "
                    End If
                Else
                    MyEr "in module " & GetName(here$), "СТО ТЛчЛА " & GetName(here$)
                End If
            End If
            If (Len(sbf(x1).sb) - Len(code$)) < 0 Then ' Maybe in a galaxy far away
                FK$(13) = pa$
            Else  ' Or in Earth
                If Len(pa$) > 0 Then
                    ' prepare Shift F1 for a jump to the point of interest..the faulty one
                    If InStr(FK$(13), ",") > 0 Then
                        GoTo there1234
                        '' forget it
                        ''If Left$(pa$, InStr(pa$, ",")) = Left$(FK$(13), InStr(FK$(13), ",")) Then GoTo there1234
                    End If
                        If (Len(sbf(x1).sb) - Len(code$)) < 0 Then
                            FK$(13) = pa$
                        Else
                            DropLeft ",", FK$(13)
                            If FK$(13) <> "" Then FK$(13) = "+" & FK$(13)
                            FK$(13) = pa$ & "-" & LTrim$(Str(Len(code$))) + FK$(13)
                        End If
                    End If
                End If
there1234:
                If LastErNum = 0 Then MyErMacro rest$, "", ""
            End If
            GoFunc = False
            If Not basestack.CopyInOutCol Is Nothing Then CopyBack basestack
            here$ = ohere$
            If Not mystack.CallLocalLast Then
                With mystack
                    If .commnum <> comhash.count Then comhash.ReduceHash .commnum, sbf()
                    If .numfunnum <> funid.count Then funid.ReduceHash .numfunnum
                    If .strfunnum <> strfunid.count Then strfunid.ReduceHash .strfunnum
                    If .numnum <> numid.count Then numid.ReduceHash .numnum
                    If .strnum <> strid.count Then strid.ReduceHash .strnum
                End With
                If nokillvars Then
                    If sbf(x1).sbc Then
                        numid.poptopGlobal
                        funid.poptopGlobal
                        strfunid.poptopGlobal
                        strid.poptopGlobal
                    End If
                End If
            End If
            If var2used > Vars Then var2used = Vars
            varhash.ReduceHash Vname, var()
            If UBound(var()) <> varhash.MaxSpace Then
                    ReDim Preserve var(varhash.MaxSpace) As Variant
            End If
            sb2used = subs
            subHash.ReduceHash snames, sbf()
            If UBound(sbf()) <> subHash.MaxSpace Then
                    ReDim Preserve sbf(subHash.MaxSpace) As modfun
            End If
            basestack.soros.MergeTop mystack.soros
            Exit Do
        Case 1, 3
            If Len(w$) > 0 Then
                pa$ = block(code$)
                If FastSymbol(code$, "}") Then GoTo againstream
            End If
emptyfunc:
            here$ = mystack.originalname$
            mystack.ThrowThreads
            Set mystack.lastobj = mystack.FuncObj
            Set mystack.FuncObj = Nothing
            If MyIsObject(mystack.lastobj) Then
                If mystack.lastobj Is Nothing Then
                    vl = mystack.FuncValue
                Else
                    Set basestack.lastobj = mystack.lastobj
                End If
            Else
                vl = mystack.FuncValue
            End If
            here$ = ohere$
            If Not mystack.CallLocalLast Then
                With mystack
                    If .commnum <> comhash.count Then comhash.ReduceHash .commnum, sbf()
                    If .numfunnum <> funid.count Then funid.ReduceHash .numfunnum
                    If .strfunnum <> strfunid.count Then strfunid.ReduceHash .strfunnum
                    If .numnum <> numid.count Then numid.ReduceHash .numnum
                    If .strnum <> strid.count Then strid.ReduceHash .strnum
                End With
            End If
            If Not nokillvars Then
                If var2used > Vars Then var2used = Vars
                varhash.ReduceHash Vname, var()
                If UBound(var()) <> varhash.MaxSpace Then
                        ReDim Preserve var(varhash.MaxSpace) As Variant
                End If
                sb2used = subs
                subHash.ReduceHash snames, sbf()
                If UBound(sbf()) <> subHash.MaxSpace Then
                        ReDim Preserve sbf(subHash.MaxSpace) As modfun
                End If
            End If
            Exit Do
        Case 2
            mystack.ThrowThreads  ' for safety...
            i = 1
            If code$ <> "" Then
                If code$ = Chr$(0) Then
                    If basestack.IsInRetStackNumberLong(p) Then i = Len(sbf(x1).sb) - p + 1
                Else
                    If InStr(code$, vbCr) > 0 Then
                        i = rinstr(sbf(x1).sb, code$)
                        If i = 0 Then i = Len(sbf(x1).sb) + 1
                    Else
                        i = PosLabel(code$, sbf(x1).sb)
                    End If
                End If
            Else
                GoTo emptyfunc
            End If
        Case 12
            MyEr "Exit for out of for next loop", "╦НОДОР ЦИА щНЫ АПЭ цИА еПЭЛЕМО"
            GoFunc = False
            Exit Do
        End Select
    Loop
Else
    rest$ = what$ & " " & rest$
    GoFunc = False
End If
lastfun:
If trace Then SwapStrings backup$, TestShowSub: TestShowBypass = TSHB
End Function

Function RepPara(basestack As basetask, rest$) As Boolean
Dim x1 As Long, y1 As Long, i As Long, j As Long
Dim X As Double, Y As Double, ss$, s$, what$
Dim pppp As mArray, aa() As String, p As Variant
RepPara = True
        If Not IsExp(basestack, rest$, Y) Then
            ' new mode
            x1 = Abs(IsLabel(basestack, rest$, what$))
            If x1 = 3 Then
                    If GetVar(basestack, what$, i) Then
                        If FastSymbol(rest$, ",") Then
                            If IsStrExp(basestack, rest$, ss$) Then
                                  aa = Split(var(i), ss$)
                                    Do While FastSymbol(rest$, ",")
                                        RepPara = True
                                        If IsExp(basestack, rest$, p) Then
                                            p = Abs(p)
                                            If FastSymbol(rest$, ":=", , 2) Then
                                                If IsStrExp(basestack, rest$, s$) Then
                                                ' HERE PLACE PART TO ARRAY, MAKE IT BIGGER IF NEEDED
                                                    If UBound(aa) < p Then
                                                        ReDim Preserve aa(p)
                                                        aa(p) = s$
                                                        Else
                                                        aa(p) = s$
                                                        
                                                    End If
                                                
                                                Else
                                                     RepPara = False
                                                End If
                                            Else
                                                RepPara = False
                                            End If
                                        Else
                                            RepPara = False
                                            Exit Do
                                        End If
                                    Loop
                                If IsObject(var(i)) Then
                                var(i).EmptyDoc
                                var(i).textDoc = Join(aa, ss$)
                                Else
                                var(i) = Join(aa, ss$)
                                End If
                                Else
                                MissStringExpr
                            End If
                        Else
                        MissPar
                        End If
                    End If
            ElseIf x1 = 6 Then
                    If neoGetArray(basestack, what$, pppp) Then
                        If Not NeoGetArrayItem(pppp, basestack, what$, i, rest$) Then RepPara = False: Exit Function
                        If FastSymbol(rest$, ",") Then
                            If IsStrExp(basestack, rest$, ss$) Then
                                  aa = Split(pppp.item(i), ss$)
                                    Do While FastSymbol(rest$, ",")
                                        RepPara = True
                                        If IsExp(basestack, rest$, p) Then
                                            p = Abs(p)
                                            If FastSymbol(rest$, ":=", , 2) Then
                                                If IsStrExp(basestack, rest$, s$) Then
                                                ' HERE PLACE PART TO ARRAY, MAKE IT BIGGER IF NEEDED
                                                    If UBound(aa) < p Then
                                                        ReDim Preserve aa(p)
                                                        aa(p) = s$
                                                        Else
                                                        aa(p) = s$
                                                        
                                                    End If
                                                
                                                Else
                                                     RepPara = False
                                                End If
                                            Else
                                                RepPara = False
                                            End If
                                        Else
                                            RepPara = False
                                            Exit Do
                                        End If
                                    Loop
                                If IsObject(pppp.item(i)) Then
                                    pppp.item(i).EmptyDoc
                                    pppp.item(i).textDoc = Join(aa, ss$)
                                Else
                                    pppp.item(i) = Join(aa, ss$)
                                End If
                                Else
                                MissStringExpr
                            End If
                        Else
                        MissPar
                        End If
                        
                    End If
            Else
                MyEr "Need a string/document as variable/array item or a numeric expression, look help", "вЯЕИэФОЛАИ АКЖАЯИХЛГТИЙЭ ч щЦЦЯАЖО СЕ ЛЕТАБКГТч ч СЕ СТОИВЕъО ПъМАЙА ч ЛИА щЙЖЯАСГ АЯИХЛГТИЙч, ДЕР БОчХЕИА"
                RepPara = False
            End If
            Exit Function
            
        Else
         If FastSymbol(rest$, ",") Then
                    If IsExp(basestack, rest$, X) Then
                        X = Int(X)
                        If X < 1 Then
                        MyErMacro rest$, "the index base must be >=1", "Г БэСГ ДЕъЙТГ ПЯщПЕИ МА ЕъМАИ >=1"
                        Exit Function
                        End If
                     
                    End If
            Else
                X = 0
            End If
        
           
            x1 = Abs(IsLabel(basestack, rest$, what$))
            If x1 = 3 Then
                    If GetVar(basestack, what$, i) Then
                            If Typename(var(i)) = doc Then
                                    If Not FastSymbol(rest$, "=") Then
                                        MissSymbolMyEr "="
                                        RepPara = False
                                        Exit Function
                                    Else
                                            If Not IsStrExp(basestack, rest$, what$) Then
                                                MissStringExpr
                                                RepPara = False
                                                Exit Function
                                            Else
                                            
                                            s$ = GetNextLineNoTrim(what$)
                                                 j = var(i).ParagraphFromOrder(Y)
                                                 If j = -1 Then
                                                        
                                                           MyErMacro rest$, "no such paragraph" & Str(Y), "ДЕМ УПэЯВЕИ ТщТОИА ПАЯэЦЯАЖОР" & Str(Y)
                                                         Exit Function
                                                Else
                                                If X > 1 Then
                                                If what$ = vbNullString Then
                                                
                                                ss$ = var(i).TextParagraph(j)
                                                
                                                s$ = Left(ss$ + space$(X - 1), X - 1) + s$ + Mid$(ss$, Len(s$) + X)
                                                Else
                                                
                                                s$ = Left(var(i).TextParagraph(j) + space$(X - 1), X - 1) + s$
                                                
                                                End If
                                            
                                                End If
                                                ''var(i).ReWritePara j, s$
                                                var(i).TextParagraph(j) = s$
                                                SetNextLine what$
                                                While what$ <> ""
                                                    s$ = GetNextLineNoTrim(what$)
                                                    Y = Y + 1
                                                    j = var(i).ParagraphFromOrder(Y)
                                                    If j = -1 Then
                                                        var(i).AppendParagraph s$
                                                    Else
                                                        If what$ = vbNullString Then s$ = s$ + Mid$(var(i).TextParagraph(j), Len(s$) + 1)
                                                        ''var(i).ReWritePara j, s$
                                                        var(i).TextParagraph(j) = s$
                                                    End If
                                                    SetNextLine what$
                                                Wend
                                                
                                                End If
                                            End If
                                    End If
                            Else
                                 MissingDoc   ' only doc not string var
                                 RepPara = False
                                Exit Function
                            End If
                    Else
                        Nosuchvariable what$
                        RepPara = False
                        Exit Function
                    End If
            ElseIf x1 = 6 Then
                    If neoGetArray(basestack, what$, pppp) Then
                        If Not NeoGetArrayItem(pppp, basestack, what$, i, rest$) Then RepPara = False: Exit Function
                        If pppp.ItemType(i) = doc Then
                                    If Not FastSymbol(rest$, "=") Then
                                            MissSymbolMyEr "="
                                            RepPara = False
                                            Exit Function
                                            Else
                                If IsStrExp(basestack, rest$, what$) Then
                                            s$ = GetNextLineNoTrim(what$)
                                                 j = pppp.item(i).ParagraphFromOrder(Y)
                                                 
                                                If j = -1 Then
                                            
                                               MyErMacro rest$, "no such paragraph" & Str(Y), "ДЕМ УПэЯВЕИ ТщТОИА ПАЯэЦЯАЖОР" & Str(Y)
                                             Exit Function
                                             Else
                                                If X > 1 Then
                                                    If what$ = vbNullString Then
                                                        ss$ = pppp.item(i).TextParagraph(j)
                                                        s$ = Left(ss$ + space$(X - 1), X - 1) + s$ + Mid$(ss$, Len(s$) + X)
                                                    Else
                                                        s$ = Left(pppp.item(i).TextParagraph(j) + space$(X - 1), X - 1) + s$
                                                    End If
                                                End If
                                                ''pppp.item(i).ReWritePara j, s$
                                                pppp.item(i).TextParagraph(j) = s$
                                                SetNextLine what$
                                                While what$ <> ""
                                                    s$ = GetNextLineNoTrim(what$)
                                                    
                                                    Y = Y + 1
                                                    j = pppp.item(i).ParagraphFromOrder(Y)
                                                    If j = -1 Then
                                                    
                                                    pppp.item(i).AppendParagraph s$
                                                    Else
                                                    
                                                    If what$ = vbNullString Then s$ = s$ + Mid$(pppp.item(i).TextParagraph(j), Len(s$) + 1)
                                                    
                                                   '' pppp.item(i).ReWritePara j, s$
                                                     pppp.item(i).TextParagraph(j) = s$
                                                    End If
                                                    SetNextLine what$
                                                Wend
                                                
                                              End If
                                Else
                                    MissStringExpr
                                    RepPara = False
                                    Exit Function
                                
                                End If

                            End If
                        Else
                             MissingDoc   ' only doc not string var
                             RepPara = False
                            Exit Function
                        End If
                    End If
            Else
                MissingDoc   ' only doc not string var
                RepPara = False
                Exit Function
            End If
        End If
End Function
Function IdentifierGroup(basestack As basetask, what$, rest$, Lang As Long, alocal As Boolean, addlen As Long) As Boolean
    IdentifierGroup = True
    Select Case what$
    Case "&"
       IdentifierGroup = MyFunction(2, basestack, rest$, Lang, addlen)
        Exit Function
    Case "FUNCTION", "сумаятгсг"
        IdentifierGroup = MyFunction(-1, basestack, rest$, Lang, True, alocal, addlen)
        Exit Function
    Case "MODULE", "тлгла"
        IdentifierGroup = MyModule(basestack, rest$, Lang, True, alocal, addlen, True)
        Exit Function
    Case "SUPERCLASS", "упеяйкасг"
        IdentifierGroup = ProcClass(basestack, rest$, Lang, True)
    Exit Function
    Case "GROUP", "олада"
      IdentifierGroup = ProcGroup(0, basestack, rest$, Lang)
      Exit Function
    Case "CLASS", "йкасг"
        IdentifierGroup = ProcClass(basestack, rest$, Lang, False)
    Exit Function
    Case "DIM", "пимайас", "пимайес"
        IdentifierGroup = MyDim(basestack, rest$, Lang, alocal)
        Exit Function
    Case "йатастасг", "INVENTORY"
        IdentifierGroup = ProcInventory(basestack, rest$, Lang, alocal)
        Exit Function
    Case "диаяхяысг", "BUFFER"
        IdentifierGroup = ProcBuffer(basestack, rest$, Lang)
        Exit Function
    Case "EVENT", "цецомос"
     IdentifierGroup = myEvent(basestack, rest$, Lang, alocal)
     Exit Function
    Case "DOCUMENT", "еццяажо"
      IdentifierGroup = MyDocument(basestack, rest$, Lang)
    Case "LONG", "лайяус"
        IdentifierGroup = MyLong(basestack, rest$, Lang)
    Case "апаяихлгсг", "апая", "ENUMERATION", "ENUM"

    IdentifierGroup = ProcEnumGroup(basestack, rest$, LenB(here$) = 0)
    
    Exit Function
    End Select
End Function
Function Identifier(basestack As basetask, what$, rest$, Optional nocom As Boolean = False, Optional Lang As Long = 1) As Boolean
Dim x1 As Long, y1 As Long, it As Long, ohere$, s$, par As Boolean, p As Variant
If Not TaskMaster Is Nothing Then
If TaskMaster.PlayMusic Then
    TaskMaster.OnlyMusic = True
    TaskMaster.TimerTick
    TaskMaster.OnlyMusic = False
End If
End If
If what$ = vbNullString Then
    Identifier = IsLabel(basestack, rest$, what$)
     
    If Not Identifier Then Exit Function
    what$ = myUcase(what$)
    Lang = codeW(what$)
Else
    Identifier = True
    x1 = Len(rest$)
    If Left$(what$, 1) <> "@" Then
        If nocom Then GoTo JUMPHEREFORMODULESFAST
    Else
        what$ = Mid$(what$, 2)
    End If
End If
Select Case what$
Case "&"
   Identifier = MyFunction(2, basestack, rest$, Lang)
    Exit Function
Case "амакутгс", "PROFILER"  ' no Neo...
Identifier = True
If basestack.Prof Is Nothing Then
If FastSymbol(rest$, "!") Then
Set basestack.Prof = New clsProfiler
basestack.Prof.MARKONE
Else
FastSymbol rest$, "!"
Prof.MARKONE
End If
Else
basestack.Prof.MARKONE
End If
Exit Function
Case "FUNCTION", "сумаятгсг"
    Identifier = MyFunction(0, basestack, rest$, Lang)
    Exit Function
Case "MODULE", "тлгла"
    Identifier = MyModule(basestack, rest$, Lang)
    Exit Function
Case "SUPERCLASS", "упеяйкасг"
    Identifier = ProcClass(basestack, rest$, Lang, True)
Exit Function
Case "EVENT", "цецомос"
 Identifier = myEvent(basestack, rest$, Lang)
 Exit Function
Case "GROUP", "олада"
  Identifier = ProcGroup(0, basestack, rest$, Lang)
  Exit Function
Case "CLASS", "йкасг"
    Identifier = ProcClass(basestack, rest$, Lang, False)
Exit Function
Case "DIM", "пимайас", "пимайес"
    Identifier = MyDim(basestack, rest$, Lang)
    Exit Function
Case "йатастасг", "INVENTORY"
    Identifier = ProcInventory(basestack, rest$, Lang)
    Exit Function
Case "диаяхяысг", "BUFFER"
    Identifier = ProcBuffer(basestack, rest$, Lang)
    Exit Function
Case "WAIT", "амаломг"  '' copy to NeoWait
Identifier = MyDelay(basestack, rest$)
Exit Function
Case "REPORT", "амажояа"
Identifier = MyReport(basestack, rest$, Lang)
Exit Function
Case "LET", "стг", "стгм", "сто"  'ok
Identifier = MyLet(basestack, rest$, Lang)
Exit Function
Case "COMMIT", "амехесе"
Identifier = MyRead(3, basestack, rest$, Lang)
Exit Function
Case "ICON", "еийомидио"
Identifier = MyIcon(basestack, rest$)
Exit Function
Case "TITLE", "титкос"
Identifier = ProcTitle(basestack, rest$, Lang)
Exit Function
Case "ESCAPE", "диажуцг"
Identifier = MyEscape(rest$, Lang)
Case "HIDE", "сбгсе"
newHide basestack
Exit Function
Case "SHOW", "амаье"
newshow basestack
Exit Function
Case "WRITE", "цяаье"
Identifier = MyWrite(basestack, rest$, Lang)
Exit Function
Case "TEXT", "йеилемо", "HTML"  'ok
Identifier = ProcText(basestack, what$ = "HTML", rest$)
Exit Function
Case "STRUCTURE", "долг"  ' ok
Identifier = myStructure(basestack, rest$, Lang)
Exit Function
Case "басг", "BASE"   'ok
' меа басг
Identifier = NewBase(basestack, rest$, Lang)
Exit Function
Case "аявеио", "TABLE"   'ok
Identifier = NewTable(basestack, rest$, Lang)
' меос пимайас стгм басг
Exit Function
Case "ейтекесг", "EXECUTE"   'ok
 If IsLabelSymbolNew(rest$, "йыдийа", "CODE", Lang) Then
Identifier = ExecCode(basestack, rest$)
 Else
    CommExecAndTimeOut basestack, rest$
    Identifier = True
End If
' меа киста
Case "вяылатисе", "PSET"
    Identifier = MyPset(basestack, rest$)
Case "амайтгсг", "RETRIEVE"  'ok
getrow basestack, rest$, , , Lang
Exit Function
Case "амафгтгсг", "SEARCH"  'ok
getrow basestack, rest$, , "", Lang
Exit Function
Case "пяосхгйг", "APPEND"  'ok
' басг,пимайас,стоивеиа
par = Appfields(basestack, rest$)
Exit Function
Case "ажаияесг", "DELETE"  'ok
' басг, пимайас,поио , ти
par = DELfields(basestack, rest$)
Exit Function
Case "танг", "ORDER"  'ok
Identifier = MyOrder(basestack, rest$, Lang)
Exit Function
Case "епистяожг", "RETURN"  ' no need here
' басг,"SELECT пимайас",стоивеиа
If IsStrExp(basestack, rest$, s$) Then
append_table basestack, s$, rest$, True, Lang
End If
Exit Function
Case "сулпиесг", "COMPRESS"  'ok
BaseCompact basestack, rest$
Exit Function
Case "LAYER", "епипедо" ' ok
Identifier = ProcLayer(basestack, rest$)
Exit Function
Case "PRINTER", "ейтупытгс"  ' ok
Identifier = ProcPrinter(basestack, rest$)
Exit Function
Case "MOTION", "йимгсг"
Identifier = ProcMotion(basestack, rest$, Lang)
Exit Function
Case "ASSERT", "аниысг"
ProcAssert basestack, rest$
Exit Function
Case "PAGE", "секида" 'ok
ProcPage basestack, rest$, Lang
Exit Function
Case "PRINTING", "ейтупысг"
 Identifier = ProcPrinting(basestack, rest$, Lang)
 Exit Function
Case "FORMLABEL", "етийета.жоялас"
Identifier = ProcLabel(basestack, rest$)
Exit Function
Case "LEGEND", "епицяажг"
' NEW JUSTIFY...1 RIGHT,2 CENTER ,3 LEFT
Identifier = ProcLegend(basestack, rest$)
Exit Function
Case "MEDIA", "MOVIE", "таимиа", "MUSIC", "лоусийг"  ' ЛЭМО щМА ЙАИ ЛПОЯЕъ МА ПЕЯИЛщМЕИ ч МА ТО ДИЧНЕИ ЦИА эККО
Identifier = ProcMedia(basestack, rest$, Lang)
Exit Function
Case "PUT", "дысе"
Identifier = MyPut(basestack, rest$)
Exit Function
Case "жояла", "FORM"
Kform = True
Identifier = MakeForm(basestack, rest$)
Exit Function
Case "SUBDIR", "упойатакоцос"
    Identifier = ProcSubDir(basestack, rest$, Lang)
Exit Function
Case "DIR", "йатакоцос"
    Identifier = ProcDir(basestack, rest$, Lang)
Exit Function
Case "START", "аявг"
    
    Identifier = newStart(basestack, rest$)
    Exit Function
Case "REMOVE", "диацяажг"
    Identifier = ProcRemove(basestack, rest$, Lang)
Exit Function
Case "DEF", "йаме"
    Identifier = ProcDef(basestack, rest$, Lang)
    Exit Function
Case "LOAD", "жоятысе" '
Identifier = ProcLoad(basestack, rest$, Lang)
Exit Function
Case "SAVE", "сысе"
Identifier = ProcSave(basestack, rest$, Lang)
Exit Function
Case "OVERWRITE", "йатавыягсг"
Identifier = RepPara(basestack, rest$)
Exit Function
Case "INSERT", "паяелбокг"
Identifier = IdPara(basestack, rest$, Lang)
Exit Function
Case "LONG", "лайяус"
Identifier = MyLong(basestack, rest$, Lang)
Exit Function
Case "DOCUMENT", "еццяажо"
Identifier = MyDocument(basestack, rest$, Lang)
Exit Function
Case "STOCK", "стой"
Identifier = StockValues(basestack, rest$, Lang)
Exit Function
Case "LINK", "емысе"
Identifier = MyLink(basestack, rest$, Lang)
Exit Function
Case "REFER", "апедысе"
Identifier = MyRead(2, basestack, rest$, Lang)
Exit Function
Case "READ", "диабасе"
Identifier = MyRead(1, basestack, rest$, Lang)
Exit Function
Case "DOUBLE", "дипка"
SetDouble basestack.Owner
Exit Function
Case "NORMAL", "йамомийа"
SetNormal basestack.Owner
Exit Function
Case "ERROR", "кахос"
Identifier = MyError(basestack, rest$, Lang)
Exit Function
Case "SET", "хесе"
    it = 1
    aheadstatusANY rest$, it
    s$ = Left$(rest$, it - 1)
    If interpret(basestack, s$) Then
        rest$ = Mid$(rest$, it)
    Else
        rest$ = s$ + Mid$(rest$, it)
    End If
    
    Exit Function
Case "NEW", "мео"
    Identifier = MyNew(basestack, rest$, Lang)
    Exit Function
Case "EDIT", "суццяажг", "с"
    Identifier = ProcEdit(basestack, rest$, Lang)
    Exit Function
Case "SCAN", "саяысе"
    Identifier = MyScan(basestack, rest$)
    Exit Function
Case "пема", "PEN"
    Identifier = ProcPen(basestack, rest$)
    Exit Function
Case "охомг", "CLS"
    Identifier = ProcCls(basestack, rest$)
    Exit Function
Case "HEX", "дейаен"
    Identifier = RevisionPrint(basestack, rest$, 1, Lang)
    Exit Function
Case "PRINT", "тупысе", "?"
    Identifier = RevisionPrint(basestack, rest$, 0, Lang)
    Exit Function
Case "BACK", "BACKGROUND", "пеяихыяио"
    ProcBackGround basestack, rest$, Lang, Identifier
    Exit Function
Case "PUSH", "баке"
    par = MyPush(basestack, rest$)
    Exit Function
Case "DATA", "сеияа"
    par = MyData(basestack, rest$)
    Exit Function
Case "SWAP", "аккане"
    Identifier = MySwap(basestack, rest$, Lang)
    Exit Function
Case "CLOSE", "йкеисе"
    Identifier = MyClose(basestack, rest$, Lang)
    Exit Function
Case "SEEK", "летахесг"
    Identifier = MySeek(basestack, rest$)
    Exit Function
Case "APPEND.DOC", "пяосхесе.еццяажо"
    Identifier = ProcSaveDoc(1, basestack, rest$)
    Exit Function
Case "SAVE.DOC", "сысе.еццяажо"
    Identifier = ProcSaveDoc(0, basestack, rest$)
    Exit Function
Case "MERGE.DOC", "суцвымеусе.еццяажо"
    Identifier = ProcLoadDoc(1, basestack, rest$)
    Exit Function
Case "LOAD.DOC", "жоятысе.еццяажо"
    Identifier = ProcLoadDoc(0, basestack, rest$)
    Exit Function
Case "FIND", "еуяесг"
    Identifier = ProcFind(basestack, rest$)
    Exit Function
Case "WORDS", "кенеис"
    Identifier = ProcWords(basestack, rest$)
    Exit Function
Case "SORT", "танимолгсг"
    Identifier = ProcSort(basestack, rest$, Lang)
    Exit Function
Case "OVER", "памы"  'амтицяажеи тгм йояужг
    Identifier = ProcOver(basestack, rest$)
    Exit Function
Case "SHIFTBACK", "жеяеписы"  'летайимеи апо тгм йояужг
    Identifier = ProcShiftBack(basestack, rest$)
    Exit Function
Case "SHIFT", "жеяе"  'летайимеи стгм йояужг
    Identifier = ProcShift(basestack, rest$)
    Exit Function
Case "DROP", "пета"
    Identifier = ProcDrop(basestack, rest$, Lang)
    Exit Function
Case "SCREEN.PIXELS", "амакусг.охомгс"
    Identifier = ProcScreenRes(basestack, rest$)
    Exit Function
Case "SOUNDREC", "гвоцяажгсг"
    Identifier = ProcSoundRec(basestack, rest$, Lang)
    Exit Function
Case "KEYBOARD", "пкгйтяокоцио"
    Identifier = ProcKeyboard(basestack, rest$, Lang)
    Exit Function
Case "JOYPAD", "кабг"
    Identifier = ProcJoypad(basestack, rest$)
    Exit Function
Case "PIPE", "аукос"
    Identifier = ProcPipe(basestack, rest$)
    Exit Function
Case "GET", "паяе"
    Identifier = ProcGet(basestack, rest$)
    Exit Function
Case "мгла", "THREAD"
    Identifier = MyThread(basestack, rest$, Lang)
    Exit Function
Case "HOLD", "йяатгсе"
    Identifier = ProcHold(basestack)
    Exit Function
Case "RELEASE", "ажгсе"
    Identifier = ProcRelease(basestack)
    Exit Function
Case "USE", "вягсг"
    Identifier = ProcUSE(basestack, rest$, Lang)
    Exit Function
Case "OPEN.FILE", "амоицла.аявеиоу"
    Identifier = ProcOpenFile(basestack, rest$, Lang)
    Exit Function
Case "OPEN.IMAGE", "амоицла.еийомас"
    Identifier = ProcOpenImage(basestack, rest$, Lang)
    Exit Function
Case "FLUSH", "адеиасе"
    Identifier = ProcFlush(basestack, rest$, Lang)
    Exit Function
Case "PROPERTIES", "идиотгтес"  ''for printer
    Identifier = ProcPropeties(basestack, rest$)
    Exit Function
Case "SPEECH", "коцос"
    Identifier = ProcSpeech(basestack, rest$)
    Exit Function
Case "DOS", "йомсока"
    Identifier = ProcDos(basestack, rest$)
    Exit Function
Case "WIN", "сус", "сустгла"
    Identifier = ProcWin(basestack, rest$)
    Exit Function
Case "WINDOW", "паяахуяо"
    Kform = True
    ProcWindow basestack, rest$, basestack.Owner, Identifier
    Exit Function
Case "FIELD", "педио"
    Identifier = ProcField(basestack, rest$, Lang)
    Exit Function
Case "TEST", "дойилг"
    Identifier = procTestMe(basestack, rest$, what$)
    Exit Function
Case "MOUSE.ICON", "деийтг.лояжг"
    i3MouseIcon basestack, rest$, Lang
    Exit Function
Case "MOTION.W", "йимгсг.п"
    Identifier = procMotionW(basestack, rest$)
    Exit Function
Case "CLIPBOARD", "пяовеияо"
    Identifier = MyClipboard(basestack, rest$, Lang)
    Exit Function
Case "богхеиа", "HELP"
    Identifier = MyHelp(basestack, rest$, Lang)
    Exit Function
Case "CLEAR", "йахаяо"
    Identifier = MyClear(basestack, rest$)
    Exit Function
Case "DECLARE", "ояисе"  'OBJECT
    Identifier = MyDeclare(basestack, rest$, Lang)
    Exit Function
Case "REM", "сгл"
    NeoRem 0, rest$, 0, Identifier
    Exit Function
Case "VOLUME", "емтасг"
    Identifier = MyVol(basestack, rest$)
    Exit Function
Case "ABOUT", "пеяи"
    ProcAbout basestack, rest$, Lang
    Exit Function
Case "SMOOTH", "олака"
        If IsLabelSymbolNew(rest$, "ови", "OFF", Lang) Then
        GDILines = False
        ElseIf IsLabelSymbolNew(rest$, "маи", "ON", Lang) Then
        GDILines = True
        End If
    Exit Function
Case "OPTIMIZATION", "бектистопоигсг"  '' not a
        If IsLabelSymbolNew(rest$, "ови", "OFF", Lang) Then
        NoOptimum = True
        ElseIf IsLabelSymbolNew(rest$, "маи", "ON", Lang) Then
        NoOptimum = False
        End If
    Exit Function
Case "LINESPACE", "диастиво"  'ok
    Identifier = procLineSpace(basestack, rest$)
    Exit Function
Case "BOLD", "жаядиа"      'ok
    ProcBold basestack, rest$
    Exit Function
Case "MODE", "тупос"
    Identifier = ProcMode(basestack, rest$)
    Exit Function
Case "GRADIENT", "жомто"
    Identifier = ProcGradient(basestack, rest$)
    Exit Function
Case "CHOOSE.OBJECT", "епекене.амтийеилемо", "епикене.амтийеилемо"
    ProcChooseObj basestack, rest$, Lang
    Exit Function
Case "CHOOSE.FONT", "епекене.цяаллатосеияа", "епикене.цяаллатосеияа"
    ProcChooseFont basestack, Lang
    Exit Function
Case "INPUT", "еисацыцг"   ' ok
    Identifier = MyInput(basestack, rest$, Lang)
    Exit Function
Case "мглата", "THREADS"
    procthreads basestack.Owner, basestack, rest$, Lang
    Exit Function
Case "ояио.амадяолгс", "RECURSION.LIMIT"
    Identifier = ProcRecursionLimit(basestack, rest$, Lang)
    Exit Function
Case "LOCALE", "топийо"
    Identifier = ProcSalata(3, basestack, rest$)
    Exit Function
Case "CODEPAGE", "йыдийосекида"
    Identifier = ProcSalata(2, basestack, rest$)
    Exit Function
Case "CHARSET", "ваяайтгяес"
    Identifier = ProcSalata(1, basestack, rest$)
    Exit Function
Case "STEP", "бгла"
    Identifier = ProcStep(basestack, rest$, Lang)
    Exit Function
Case "MOVE", "хесг"
    Identifier = ProcMove(basestack, rest$)
    Exit Function
Case "покуцымо", "POLYGON"
    Identifier = ProcPoly(basestack, rest$, Lang)
    Exit Function
Case "CIRCLE", "йуйкос"
    Identifier = ProcCircle(basestack, rest$, Lang)
    Exit Function
Case "PLAYER", "паийтгс"
    Identifier = ProcPlayer(basestack, rest$, Lang)
    Exit Function
Case "IMAGE", "еийома"
    Identifier = ProcImage(basestack, rest$, Lang)
    Exit Function
Case "SPRITE", "диажамо", "диажамеиа"
    ' ok NeoSprite exist
    If IsStrExp(basestack, rest$, s$) Then
        sprite basestack, s$, rest$
    ElseIf IsExp(basestack, rest$, p) Then
        spriteGDI basestack, rest$
    End If
    If LastErNum1 <> 0 Then Identifier = False
    Exit Function
Case "COPY", "амтецяаье", "амтицяаье"
    Identifier = MyCopy(basestack, rest$, Lang)
    Exit Function
Case "паине", "PLAY"
    Identifier = MyPlayScore(basestack, rest$)
    Exit Function
Case "SCORE", "жымг"
    Identifier = MyScore(basestack, rest$)
    Exit Function
Case "TARGETS", "стовои"
    Identifier = ProcTargets(basestack, rest$, Lang)
    Exit Function
Case "LATIN", "катимийа"
    LATIN basestack '****************************************************************
    Exit Function
Case "GREEK", "еккгмийа"
    GREEK basestack
    Exit Function
Case "MODULES", "тлглата"
    Identifier = MyModules(basestack, rest$, Lang)
    Exit Function
Case "FILES", "аявеиа"
    Identifier = ProcFiles(basestack, rest$, Lang)
    Exit Function
Case "CAT", "йатакоцои", "йат"
    Identifier = ProcCat(basestack, rest$, Lang)
    Exit Function
Case "DRAWINGS", "сведиа"
    Identifier = MyDrawings(basestack, rest$, Lang)
    Exit Function
Case "BITMAPS", "еийомес"
    Identifier = MyBitmaps(basestack, rest$, Lang)
    Exit Function
Case "MOVIES", "таимиес"
    Identifier = MyMovies(basestack, rest$, Lang)
    Exit Function
Case "SOUNDS", "гвои"
    Identifier = MySounds(basestack, rest$, Lang)
    Exit Function
Case "WRITER", "суццяажеас"
    Identifier = ProcWriter(basestack, rest$, Lang)
    Exit Function
Case "LIST", "киста"
    Identifier = ProcList(basestack, rest$, Lang)
    Exit Function
Case "FRAME", "пкаисио" ' BOX X1,Y1,COL,BOX
    Identifier = MyFrame(basestack, rest$)
    Exit Function
Case "MARK", "сглади"
    Identifier = MyMark(basestack, rest$)
    Exit Function
Case "LINE", "цяаллг"
    Identifier = MyLineInput(basestack, rest$, Lang)
    Exit Function
Case "CURSOR", "дяолеас" ' CURSOR X,Y
    Identifier = MyCursor(basestack, rest$)
    Exit Function
Case "FILL", "баье"
    Identifier = ProcFill(basestack, rest$)
    Exit Function
Case "FLOODFILL", "целисе"
    Identifier = ProcFLOODFILL(basestack, rest$, Lang)
    Exit Function
Case "ваяане", "DRAW"   ' LINE X1,Y1,COL
    Identifier = ProcDraw(basestack, rest$, Lang)
    Exit Function
Case "WIDTH", "павос"
    Identifier = ProcDrawWidth(basestack, rest$)
    Exit Function
Case "йалпукг", "CURVE"
    Identifier = ProcCurve(basestack, rest$, Lang)
    Exit Function
Case "PATH", "COLOR", "вяыла", "ивмос"
    Identifier = ProcPath(basestack, rest$, Lang)
    Exit Function
Case "DESKTOP", "епижамеиа"
    Identifier = ProcDesktop(basestack, rest$, Lang)
    Exit Function
Case "CHOOSE.COLOR", "епекене.вяыла", "епикене.вяыла"
    Identifier = ProcChooseColor(basestack, rest$, Lang)
    Exit Function
Case "SAVE.AS", "апохгйеусг.ыс"
    Identifier = ProcSaveAs(basestack, rest$, Lang)
    Exit Function
Case "аккацг", "CHANGE"
    Identifier = ProcCHANGE(basestack, rest$, Lang)
    Exit Function
Case "STACK", "сыяос"
    Identifier = ProcStack(basestack, rest$, Lang)
    Exit Function
Case "ейдосг", "VERSION"
    Identifier = ProcVersion(basestack)
    Exit Function
Case "цяаллатосеияа"
    Identifier = ProcFont(basestack, rest$, 0&)
    Exit Function
Case "FONT"
    Identifier = ProcFont(basestack, rest$, 1&)
    Exit Function
Case "SCROLL", "йукисг"
    Identifier = ProcSrcoll(basestack, rest$, Lang)
    Exit Function
Case "EDIT.DOC", "диояхысе"
    Identifier = ProcEditDoc(basestack, rest$, Lang)
    Exit Function
Case "ITALIC", "пкациа"   '.......................
    Identifier = ProcItalic(basestack, rest$)
    Exit Function
Case "йкеиди", "FKEY"
    Identifier = ProcFKey(basestack, rest$, Lang)
    Exit Function
Case "OPEN", "амоине"
    Identifier = ProcOpen(basestack, rest$, Lang)
    Exit Function
Case "NAME", "омола"
    Identifier = ProcName(basestack, rest$, Lang)
    Exit Function
Case "WITH", "ле"
    Identifier = MyWith(basestack, rest$, Lang)
    Exit Function
Case "METHOD", "леходос"
    Identifier = MyMethod(basestack, rest$, Lang)
    Exit Function
Case "TUNE", "лекыдиа"
    Identifier = ProcTune(basestack, rest$)
    Exit Function
Case "гвос", "SOUND"
    Identifier = ProcSound(basestack, rest$)
    Exit Function
Case "DB.USER", "басг.вягстгс"
    Identifier = ProcDBUSER(basestack, rest$, Lang)
    Exit Function
Case "DB.PROVIDER", "басг.паяовос"
    Identifier = ProcDBprovider(basestack, rest$, Lang)
    Exit Function
Case "TONE", "томос"
    Identifier = ProcTone(basestack, rest$)
    Exit Function
Case "VIEW", "деине"
    Identifier = ProcView(basestack, rest$, Lang)
    Exit Function
Case "CHOOSE.ORGAN", "епекене.ояцамо", "епикене.ояцамо"
    Identifier = ProcChooseOrgan(basestack, rest$, Lang)
    Exit Function
Case "BROWSER", "амакоцио"
    Identifier = ProcBrowser(basestack, rest$, Lang)
    Exit Function
Case "лпип", "BEEP"
    Identifier = ProcBeep(basestack, rest$)
    Exit Function
Case "MENU", "епикоцг"
    Identifier = MyMenu(0, basestack, rest$, Lang)
    Exit Function
Case "THREAD.PLAN", "сведио.мглатым"
    Identifier = ProcThreadPlan(basestack, rest$, Lang)
    Exit Function
Case "яухлисеис", "SETTINGS"
    Identifier = ProcSettings(basestack, rest$, Lang)
    Exit Function
Case "PROTOTYPE", "пяытотупо"
    Identifier = ProcProto(basestack, rest$, Lang)
    Exit Function
Case "апаяихлгсг", "апая", "ENUMERATION", "ENUM"
    Identifier = ProcEnum(basestack, rest$, LenB(here$) = 0)
    Exit Function
Case Else
    x1 = Len(rest$)
    Identifier = True
JUMPHEREFORMODULESFAST:
            MakeThisSub basestack, what$
          If GetSub(what$, y1) Then
               it = 0
            ElseIf GetSub(here$ & "." & what$, y1) Then
                    it = 1
            ElseIf Len(basestack.UseGroupname) > 0 Then

            If InStr(what$, basestack.UseGroupname) = 1 Then
            what$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
            If GetSub(what$, y1) Then
                it = 0
            ElseIf GetSub(here$ & "." & what$, y1) Then
            it = 1
            Else
            GoTo conthereplease
            End If
            Else
            GoTo conthereplease
            End If
            Else
conthereplease:
                rest$ = what$ + rest$
                   MyEr "unknown module " & what$, "╒ЦМЫСТО ТЛчЛА " & what$
                   
                   Identifier = False
                   Exit Function
            End If
            If NORUN1 Then rest$ = vbNullString: Exit Function


            x1 = y1
            If Len(what$) = 0 Then Identifier = False: Exit Function
            '''funcno = funcno + 1
            what$ = myUcase(what$):   MakeThisSub basestack, what$
            ohere$ = here$
            If it = 0 Then
            If SecureNames Then
            
                If here$ = vbNullString Then
                s$ = what$
                Else
                s$ = RVAL33(here$, x1)
                End If
            Else
                s$ = what$
            End If
            
            Else
                s$ = ohere$ + "." & what$
            End If
            y1 = var2used
            par = PushParamGeneral(basestack, rest$, s$)
            y1 = y1 - var2used
            If LastErNum = -2 Then
                If Left$(rest$, 12) <> " : ERROR -2" Then rest$ = vbNullString
                    Identifier = True
                    Exit Function
                    Else
                If Not par Then Identifier = False: Exit Function
            End If
            here$ = s$
            With basestack
                 If .OriginalCode <> x1 And x1 <> 0 Then
                    .callohere = ohere$
                    .callx1 = x1
                    .ByName = y1
                    Identifier = True
                Else
                MyErMacro rest$, "Use Call command to call recuirsive in module", "вЯГСИЛОПОъГСЕ ТГМ йэКЕСЕ ЦИА АМАДЯОЛИЙч ЙКчСГ ТЛчЛАТОР"
                If here$ <> ohere$ Then here$ = ohere$
                Identifier = True
                End If
            End With
            Exit Function
NERR:

                        If MOUT And rest$ = vbNullString Then
                        Else
                                MyErMacro rest$, "unknown identifier " & what$, "╒ЦМЫСТО АМАЦМЫЯИСТИЙЭ " & what$
                        End If
                        Identifier = True
            
End Select


End Function

Function ReboundArr(bstack As basetask, Name$, arrcode As Long) As Boolean
On Error GoTo 0
Dim ss$
Name$ = myUcase(Name$)
If Left$(Name$, 5) = "ауто." Or Left$(Name$, 5) = "THIS." Then
    ss$ = bstack.UseGroupname & Mid$(Name$, 6)
Else
    If here$ = vbNullString Then
        ss$ = Name$
    Else
        ss$ = here$ & "." & Name$
    End If
End If

ReboundArr = varhash.findRebound(ss$, arrcode, var())

End Function
Function ReboundVar(bstack As basetask, Name$, q As Long) As Boolean
On Error GoTo 0
Dim ss$
Name$ = myUcase(Name$)
If Left$(Name$, 5) = "ауто." Or Left$(Name$, 5) = "THIS." Then
    ss$ = bstack.UseGroupname & Mid$(Name$, 6)
Else
    If here$ = vbNullString Then
        ss$ = Name$
    Else
        ss$ = here$ & "." & Name$
    End If
End If

ReboundVar = varhash.findRebound(ss$, q, var())

End Function
Function globalvarex(Name$, q As Variant) As Long
Dim makeitglobal As Boolean, ohere$
On Error GoTo 0
Dim j As Long

    j = AllocVar()
    If MyIsObject(q) Then
        Set var(j) = q
    Else
        If Right$(Name$, 1) = "%" Then
            On Error Resume Next
            q = MyRound(q)
            If Err.Number = 6 Then q = 0
            On Error GoTo 0
        End If
        var(j) = q
    End If

varhash.ItemCreator myUcase(Name$), j, , , True
globalvarex = j
End Function
Function globalvarEmpty(Name$) As Long
globalvarEmpty = AllocVar()
varhash.ItemCreator (Name$), globalvarEmpty, , , True
End Function
Function globalvar(Name$, q As Variant, Optional link As Boolean = False, Optional makeitglobal As Boolean = False, Optional ohere$ = vbNullString) As Long
On Error GoTo 0
Dim j As Long, m As Long
If Not link Then
    If ohere$ <> vbNullString Then
        If varhash.Find2(ohere$ + "." + Name$, m, makeitglobal) And Not link Then
            If Not makeitglobal Then
                j = m
            Else
                j = AllocVar()
                varhash.ItemCreator ohere$ + "." + Name$, j, link, False, True
            End If
        Else
            j = AllocVar()
            varhash.ItemCreator ohere$ + "." + Name$, j, link, False, False
        End If
        ohere$ = vbNullString
        If MyIsObject(q) Then
            Set var(j) = q
        Else
            If Right$(Name$, 1) = "%" Then
                On Error Resume Next
                q = MyRound(q)
                If Err.Number = 6 Then q = 0
                On Error GoTo 0
            End If
            var(j) = q
        End If
        globalvar = j
        Exit Function
    End If
    j = AllocVar()
    If MyIsObject(q) Then
        Set var(j) = q
    Else
        If Right$(Name$, 1) = "%" Then
            On Error Resume Next
            q = MyRound(q)
            If Err.Number = 6 Then q = 0
            On Error GoTo 0
        End If
        var(j) = q
    End If
Else
    If CStr(q) = vbNullString Then
        j = 0
    Else
        j = CLng(q)
    End If
End If
If Right$(Name$, 1) = "$" Then
    If strid.Find(Name$, m) Then
        If Len(here$) = 0 Or makeitglobal Then
            strid.ItemCreator2 Name$, -2
            varhash.ItemCreator2 strid, Name$, j, link, makeitglobal, True
        Else
            strid.ItemCreator2 Name$, -1
            varhash.ItemCreator here$ & "." & Name$, j, link, , True
        End If
        globalvar = j
        Exit Function
    End If
    If Len(here$) = 0 Or makeitglobal Then
        varhash.ItemCreator2 strid, Name$, j, link, makeitglobal, True
    Else
        varhash.ItemCreator here$ & "." & Name$, j, link, , True
    End If
Else
    If numid.Find(Name$, m) Then
        If Len(here$) = 0 Or makeitglobal Then
            numid.ItemCreator2 Name$, -2
            varhash.ItemCreator2 numid, Name$, j, link, makeitglobal, True
         Else
            numid.ItemCreator Name$, -1
            varhash.ItemCreator here$ & "." & Name$, j, link, , True
        End If
        globalvar = j
        Exit Function
    End If
    If Len(here$) = 0 Or makeitglobal Then
        varhash.ItemCreator2 numid, Name$, j, link, makeitglobal, True
    Else
        varhash.ItemCreator here$ & "." & Name$, j, link, , True
    End If
End If
globalvar = j
End Function
Function globalvarGroup(Name$, q As Variant, Optional link As Boolean = False, Optional makeitglobal As Boolean = False, Optional ohere$ = vbNullString) As Long
On Error GoTo 0
Dim j As Long, m As Long
If Not link Then
    If ohere$ <> vbNullString Then
        If varhash.Find2(ohere$ + "." + Name$, m, makeitglobal) And Not link Then
            If Not makeitglobal Then
                j = m
            Else
                j = AllocVar()
                varhash.ItemCreator ohere$ + "." + Name$, j, link, False, True
            End If
        Else
            j = AllocVar()
            varhash.ItemCreator ohere$ + "." + Name$, j, link, False, False
        End If
        ohere$ = vbNullString
        If MyIsObject(q) Then
            Set var(j) = q
        Else
            If Right$(Name$, 1) = "%" Then
                On Error Resume Next
                q = MyRound(q)
                If Err.Number = 6 Then q = 0
                On Error GoTo 0
            End If
            var(j) = q
        End If
        globalvarGroup = j
        Exit Function
    End If
    j = AllocVar()
    If MyIsObject(q) Then
        Set var(j) = q
    Else
        If Right$(Name$, 1) = "%" Then
            On Error Resume Next
            q = MyRound(q)
            If Err.Number = 6 Then q = 0
            On Error GoTo 0
        End If
        var(j) = q
    End If
Else
    If CStr(q) = vbNullString Then
        j = 0
    Else
        j = CLng(q)
    End If
End If

If here$ = vbNullString Then
varhash.ItemCreator (Name$), j, link, makeitglobal, True
ElseIf makeitglobal Then
varhash.ItemCreator (Name$), j, link, False, True
Else
varhash.ItemCreator here$ & "." & Name$, j, link, , True
End If
globalvarGroup = j
End Function
Function globalvarStr(Name$, q$, Optional link As Boolean = False, Optional makeitglobal As Boolean = False, Optional ohere$ = vbNullString) As Long
On Error GoTo 0
Dim j As Long, m As Long
If Not link Then
    If ohere$ <> vbNullString Then
        If varhash.Find2(ohere$ + "." + Name$, m, makeitglobal) And Not link Then
            If Not makeitglobal Then
                j = m
            Else
                j = AllocVar()
                varhash.ItemCreator ohere$ + "." + Name$, j, link, False, True
            End If
        Else
            j = AllocVar()
            varhash.ItemCreator ohere$ + "." + Name$, j, link, False, False
        End If
        ohere$ = vbNullString
        MoveStringToVariant q$, var(j)
        globalvarStr = j
        Exit Function
    End If
    j = AllocVar()
    MoveStringToVariant q$, var(j)
Else
    If Len(q$) = 0 Then
        j = 0
    Else
        j = CLng(q)
    End If
End If
If strid.Find(Name$, m) Then
If m > -1 Then strid.ItemCreator2 Name$, -1
End If
If here$ = vbNullString Or makeitglobal Then
    varhash.ItemCreator2 strid, Name$, j, link, makeitglobal, True
Else
    varhash.ItemCreator here$ & "." & Name$, j, link, , True
End If
globalvarStr = j
End Function
Function GlobalVarRefOnly(Name$, Optional gl As Boolean = False) As Long
On Error GoTo 0
Dim j As Long
j = AllocVar() ' var2used
 var(j) = CLng(0)  ' like an empty...
If here$ = vbNullString Or gl Then
varhash.ItemCreator myUcase(Name$), j, , gl, True
Else
varhash.ItemCreator here$ & "." & myUcase(Name$), j, , gl, True

End If
GlobalVarRefOnly = j
End Function
Sub GlobalVarRefLink(Name$, j As Long, Optional gl As Boolean = False)
On Error GoTo 0
If here$ = vbNullString Or gl Then
varhash.ItemCreator myUcase(Name$), j, True, gl
Else
varhash.ItemCreator here$ & "." & myUcase(Name$), j, True, gl

End If
End Sub
Sub GlobalVarRefLink2(Name$, j As Long, Optional gl As Boolean = False)
varhash.ItemCreator myUcase(Name$), j, True, gl

End Sub
Function LinkGroup(bstack As basetask, ByVal Name$, inpq As Variant, Optional usefinal As Boolean = False) As Boolean
Dim i As Long, Vlist As Boolean, FList, f$, aa$, v As Long
Dim s() As String, ThisGroup As Group, q As Group, ss$, it As Long, ohere$, itGroup As Group
Dim UnhidePrivate As Boolean, c As Constant

If Typename(inpq) <> mgroup Then Exit Function
Set q = inpq
If q.IamApointer Then
    Exit Function
End If
If bstack.tpointer <> 0 Then
If Typename(var(bstack.tpointer)) = mgroup Then
Set ThisGroup = var(bstack.tpointer)
UnhidePrivate = q.MatchTypes(ThisGroup.mytypes)
Set ThisGroup = Nothing
End If
End If
If Not usefinal Then
    If here$ = vbNullString Then
        Name$ = Name$ + "."
    Else
       Name$ = here$ & "." & myUcase(Name$) + "."
    End If
End If
cont1:



FList = q.FuncList
ohere$ = here$
here$ = Left$(Name$, Len(Name$) - 1)
For i = 1 To q.soros.Total
    aa$ = q.soros.StackItem(i)
    v = Split(aa$)(1)
    Vlist = True
    If MyIsObject(var(v)) Then
        Select Case Typename(var(v))
        Case mgroup
            Set ThisGroup = var(v)
            With ThisGroup
                ss$ = Split(aa$)(0)
                If Left$(ss$, 1) = "*" Then
                    ss$ = Mid$(ss$, 2)
                    If UnhidePrivate And AscW(ss$) = -65 Then
                        ss$ = Mid$(ss$, 2)
                    End If
                    If .IamApointer Then
                        varhash.ItemCreator Name$ + ss$, v, True
                    Else
                        it = globalvar(ss$, it)
                        MakeitObject2 var(it)
                        LinkGroup bstack, ss$, var(v)
                        Set itGroup = var(it)
                        itGroup.edittag = .edittag
                        itGroup.FuncList = .FuncList
                        itGroup.GroupName = ss$ + "."
                        Set itGroup.Sorosref = .soros.Copy
                        itGroup.HasValue = .HasValue
                        itGroup.HasSet = .HasSet
                        itGroup.HasStrValue = .HasStrValue
                        itGroup.HasParameters = .HasParameters
                        itGroup.HasParametersSet = .HasParametersSet
                        itGroup.HasRemove = .HasRemove
                        Set itGroup.Events = .Events
                        itGroup.highpriorityoper = .highpriorityoper
                        itGroup.HasUnary = .HasUnary
                        
                        itGroup.Patch = Name$ + ss$
                        If .HasStrValue Then
                              varhash.ItemCreator Name$ + ss$ + "$", it, True
                        End If
                        Set itGroup.mytypes = .mytypes
                    End If
                Else
                    it = globalvar(ss$, it)
                    MakeitObject2 var(it)
                    Set itGroup = var(it)
                    If .IamApointer Then
                        If .link.IamFloatGroup Then
                           Set itGroup.LinkRef = .link
                            itGroup.IamApointer = True
                            itGroup.isRef = True
                        Else
                            itGroup.edittag = .link.edittag
                            itGroup.FuncList = .link.FuncList
                            itGroup.GroupName = ss$ + "."
                            Set itGroup.Sorosref = .link.soros.Copy
                            itGroup.HasValue = .link.HasValue
                            itGroup.HasSet = .link.HasSet
                            itGroup.HasStrValue = .link.HasStrValue
                            itGroup.HasParameters = .link.HasParameters
                            itGroup.HasParametersSet = .link.HasParametersSet
                            itGroup.HasRemove = .link.HasRemove
                            Set itGroup.Events = .link.Events
                            itGroup.highpriorityoper = .link.highpriorityoper
                            itGroup.HasUnary = .link.HasUnary
                            itGroup.Patch = here$ + "." + ss$
                            If .link.HasStrValue Then
                                varhash.ItemCreator Name$ + ss$ + "$", it, True
                            End If
                            Set itGroup.mytypes = .link.mytypes
                        End If
                    Else
                        If UnhidePrivate And AscW(ss$) = -65 Then
                            ss$ = Mid$(ss$, 2)
                        End If
                        varhash.ItemCreator Name$ + ss$, v, True, , True
                    End If
                End If
            End With
        Case "lambda"
islambda:
            ss$ = Split(aa$)(0)
            If UnhidePrivate And AscW(ss$) = -65 Then
            ss$ = Mid$(ss$, 2)
            End If
            varhash.ItemCreator Name$ + ss$, v, True
            GlobalSub Name$ + ss$ + "()", "", Name$, , v
        Case "Constant"
            If var(v).flag Then
                GoTo islambda
            Else
                GoTo cont123
            End If
        Case Else
            GoTo cont123
        End Select
    Else
cont123:
        ss$ = Split(aa$)(0)
        varhash.ItemCreator Name$ + ss$, v, True, , True
        If UnhidePrivate And AscW(ss$) = -65 Then
            varhash.ItemCreator Name$ + Mid$(ss$, 2), v, True, , True
        End If
    End If
Next



Dim mm As Long
Dim als As Long
Dim subname$
If FList <> "" Then
If UnhidePrivate Then
subname$ = Replace(FList, ChrW(-65), "")
subname$ = Replace(Replace(subname$, Chr$(3), Name$), Chr$(2), Name$)
Else
subname$ = Replace(Replace(FList, Chr$(3), Name$), Chr$(2), Name$)
End If

s() = Split(subname$, Chr$(1))
For i = LBound(s$()) + 1 To UBound(s$())
If s(i) <> "" Then
mm = val(Split(s(i))(1))

als = AllocSub()
sbf(als) = sbf(Abs(mm))
ss$ = Split(s(i))(0)
 subHash.ItemCreator ss$, als, True

 
 End If
Next i

End If
here$ = ohere$
LinkGroup = Vlist Or FList <> ""

End Function

Sub GlobalArr(bstack As basetask, Name$, rst$, items As Long, q As Long, Optional useglobalname As Boolean = False, Optional Reverse As Boolean = False, Optional declareglobal As Boolean = False)
' new mArray..
Dim afto As New mArray, NewKey As Long
If rst$ = vbNullString And q = -1 Then
' Make an empty array
GoTo dummyarray
End If


Dim j As Long, i As Long, p As Variant, aa As Boolean, onemore As Long, pbase As Variant
If DimLikeBasic And ArrBase = 0 Then onemore = 1: Reverse = True
items = 1
i = 0
If FastSymbol(rst$, ChrW(8)) Then
pbase = afto.myarrbase
afto.RevOrder = Reverse
afto.PushEnd
i = 1
GoTo dummyarray
Else
    Do
        If IsExp(bstack, rst$, p, , True) Then
            pbase = afto.myarrbase
            If Fast2Label(rst$, "TO", 2, "еыс", 3, 3) Then
                pbase = -p
                onemore = 0
                If IsExp(bstack, rst$, p, , True) Then
                    If p < -pbase Then
                        j = -p
                        p = -pbase
                        pbase = j
                    End If
                    p = p + pbase + 1
                Else
                    missNumber
                    Exit Sub
                End If
            End If
            i = i + 1
            If onemore Then If p > 0 Then p = p + onemore
            items = items * Int(Abs(p))
            afto.PushDim CLng(p), pbase
            aa = True
        Else
            GoTo dummyarray
        End If
        If i > 9 Then Exit Do
    Loop Until Not FastSymbol(rst$, ",")
End If

If aa And FastSymbol(rst$, ")") Then
afto.RevOrder = Reverse
afto.PushEnd

   
dummyarray:
    NewKey = AllocVar()  ' version 8.1
    ' check if is already in ucase
    Name$ = myUcase(Name$)
    If here$ = vbNullString Or useglobalname Then
        ''If bstack.tpointer > 0 Then
        varhash.ItemCreator (Name$), NewKey, , declareglobal

        afto.arrname = Name$
    Else
        varhash.ItemCreator here$ + "." + bstack.GroupName + Name$, NewKey
        'afto.arrname = here$ + "." + bstack.GroupName + Name$
        afto.arrname = bstack.GroupName + Name$
    End If
    If q = -1 Then
            q = NewKey
    End If
    Set var(NewKey) = afto
    
Else
If FastSymbol(rst$, ",") Then
items = 0
MyEr "No more 10 dimensions allowed", "лщВЯИ 10 ДИАСТэСЕИР ЕПИТЯщПОМТАИ"
Else

    items = -1
    rst$ = ":?" & rst$
    End If
End If

End Sub
Sub GlobalArrResize(afto As mArray, bstack As basetask, Name$, rst$, items As Long)
' new mArray..

Dim j As Long, i As Long, p As Variant, aa As Boolean, onemore As Long, pbase As Variant
If DimLikeBasic And afto.myarrbase = 0 Then onemore = 1
items = 1
i = 0
afto.StartResize
If FastSymbol(rst$, ChrW(8)) Then
pbase = afto.myarrbase
i = 1
items = 0
afto.PushDim 0&, pbase
afto.PushEnd
Else
    Do
    If IsExp(bstack, rst$, p) Then
    If afto.IHaveGui And p <> 0 Then GoTo noredim
    pbase = afto.myarrbase
    If Fast2Label(rst$, "TO", 2, "еыс", 3, 3) Then
        pbase = -p
        onemore = 0
        If IsExp(bstack, rst$, p) Then
            If p < -pbase Then
            j = -p
            p = -pbase
            pbase = j
            
            End If
            p = p + pbase + 1
            
        Else
            missNumber
            Exit Sub
        End If
    End If
    i = i + 1
    If onemore Then If p > 0 Then p = p + onemore
    items = items * Int(Abs(p))
    afto.PushDim CLng(p), pbase
    aa = True
    Else
    GoTo fault
    End If
    If i > 9 Then Exit Do
    Loop Until Not FastSymbol(rst$, ",")

afto.PushEnd
fault:
If aa And FastSymbol(rst$, ")") Then


Else
     If FastSymbol(rst$, ",") Then
items = 0
MyEr "No more 10 dimensions allowed", "лщВЯИ 10 ДИАСТэСЕИР ЕПИТЯщПОМТАИ"
Else
    items = -1
    rst$ = ":?" & rst$
    End If
End If
End If
Exit Sub
noredim:
MyEr "No Redim allowed, use Declare Over/Under ", "дЕМ ЕПИТЯщПОМТАИ АККАЦщР, ВЯГСИЛОПОъГСЕ ТГМ ояисе памы/упо"
End Sub


Function neoGetArray(bstack As basetask, ByVal nm$, ga As mArray, Optional searchonly As Boolean = False, Optional ByVal useglobalname As Boolean = False, Optional useLocalOnly As Boolean = False, Optional rightexpression As Boolean, Optional feedback As Boolean) As Boolean
Dim k As Long, myobject As Object
Dim n$, hidden As Boolean
nm$ = myUcase(nm$)
If Len(nm$) = 0 Then SyntaxError: Exit Function
If useglobalname Or here$ = vbNullString Then
n$ = bstack.GroupName + nm$
ElseIf Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
'nm$ = bstack.UseGroupname + Mid$(nm$, 6)

GoTo here12
Else
hidden = Left$(nm$, 1) = ChrW(&H1FFF)
n$ = here$ + "." + bstack.GroupName + nm$
End If


If Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
here12:
    If useLocalOnly Then Exit Function
    If Len(bstack.UseGroupname) > 0 Then
    If Mid$(nm$, 6, 1) = ChrW(&HFFBF) Then
    n$ = bstack.UseGroupname + Mid$(nm$, 6)
      If Not varhash.Find3(n$, k, feedback) Then
 GoTo isagroupvalue
    ' varhash.Find3 Left$(n$, Len(n$) - 2), k, feedback
     
     End If
    Else
    n$ = bstack.UseGroupname + Mid$(nm$, 6)
    
     If Not varhash.Find3(n$, k, feedback) Then
     n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
     varhash.Find3 n$, k, feedback
     End If
     End If
     If k = 0 Then
     ' check for inventory

     n$ = bstack.UseGroupname + Mid$(nm$, 6)
isagroupvalue:
      If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find3(n$, k, feedback) Then
            If MyIsObject(var(k)) Then
            If var(k) Is Nothing Then
                Set ga = New mArray
                Set ga.GroupRef = Nothing
                ga.Arr = False
                neoGetArray = True
               
                Exit Function
            ElseIf TypeOf var(k) Is mHandler Then
                
                If var(k).t1 < 3 Then
                Set ga = New mArray
                Set ga.GroupRef = var(k)
                ga.Arr = False
                neoGetArray = True
                Exit Function
                Else
                k = 0
                End If
            ElseIf TypeOf var(k) Is Group Then
            GoTo checkGroup
            End If
            End If
        End If
        n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
              If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find3(n$, k, feedback) Then
            If TypeOf var(k) Is mHandler Then
            If var(k).t1 < 3 Then
                Set ga = New mArray
                Set ga.GroupRef = var(k)
                ga.Arr = False
                neoGetArray = True
                 Exit Function
                End If
            End If
            k = -1
        End If
     
     End If
    Else
    n$ = Mid$(nm$, 5)
      If bstack.GetDot(n$, 1) Then varhash.Find3 here$ + "." + n$, k, feedback Else Exit Function
    End If

ElseIf varhash.Find(n$, k) = False Then
If useLocalOnly Then
If Len(bstack.UseGroupname) > 0 Then
        If InStr(nm$, bstack.UseGroupname) = 1 Then
        n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, Len(bstack.UseGroupname) + 1)
        varhash.Find3 n$, k, feedback
        Else
        If n$ Like "*[$%](" Then
        n$ = Mid$(n$, 1, Len(n$) - 2)
        Else
        n$ = Mid$(n$, 1, Len(n$) - 1)
        End If
        If varhash.Find3(n$, k, feedback) Then
        GoTo contHandler
        End If
        
        End If
Else
If n$ Like "*[$%](" Then
n$ = Mid$(n$, 1, Len(n$) - 2)
Else
n$ = Mid$(n$, 1, Len(n$) - 1)
End If
If varhash.Find3(n$, k, feedback) Then
contHandler:
    If TypeOf var(k) Is mHandler Then
        If var(k).t1 < 3 Then
            Set ga = New mArray
            Set ga.GroupRef = var(k)
            ga.Arr = False
            neoGetArray = True
            Exit Function
        End If
    ElseIf TypeOf var(k) Is Group Then
checkGroup:
    If rightexpression Then
        If var(k).HasParametersSet Then
             Set ga = New mArray
                    Set ga.GroupRef = var(k)
                    ga.Arr = False
                    neoGetArray = True
                    Exit Function
            Else
        
            Exit Function
            End If
    ElseIf var(k).HasParameters Then
            Set ga = New mArray
                   Set ga.GroupRef = var(k)
                   
                   If Not hidden Then
                   ga.CodeName = var(k).FloatGroupName
                   If Len(ga.CodeName) = 0 Then ga.CodeName = n$
                   Else
                   ga.CodeName = vbNullString
                   End If
                   ga.Arr = False
                   neoGetArray = True
                   Exit Function
            Else
            
            Exit Function
    End If

    End If
    k = -1
End If
End If
Else
            If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If

' check group or handler

        If varhash.Find3(n$, k, feedback) Then
checkforglobal:
            If TypeOf var(k) Is mHandler Then
                If var(k).t1 < 3 Then
                        Set ga = New mArray
                        Set ga.GroupRef = var(k)

                        ga.Arr = False
                        
                        neoGetArray = True
                        Exit Function
                        Else
                        
                    End If
            Else
                If Typename(var(k)) = mgroup Then
checkgrouphere:
                    If var(k).HasParametersSet Then
                    ' process parameters
                    Set ga = New mArray
                    Set ga.GroupRef = var(k)
                    ga.Arr = False
                    neoGetArray = True
                    If rightexpression Then Exit Function
                    ElseIf var(k).HasParameters Then  ' this is for inventories
                     Set ga = New mArray
                    Set ga.GroupRef = var(k)
                    ga.CodeName = n$
                    ga.Arr = False
                    neoGetArray = True
                    End If
                    Exit Function
                Else
                   ' MyEr "Group has no parameters", "г ОЛэДА ДЕМ щВЕИ ПАЯАЛщТЯОУР"
                   If varhash.Find(nm$, k) Then
                   GoTo conthere
                   End If
                    Exit Function
                    End If
            End If
                
                k = -1
                n$ = bstack.GroupName + nm$
                ' not a mhandler
                    
        Else
        n$ = nm$
        If Not varhash.Find3(n$, k, feedback) Then
          If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find3(n$, k, feedback) Then GoTo checkforglobal
      n$ = nm$
      End If
        End If
End If
End If
conthere:
If k <= 0 Then

            If searchonly Then Exit Function
            If Not useLocalOnly Then
                        n$ = nm$
                        varhash.Find3 n$, k, feedback
        Else
    If bstack.StaticCollection Is Nothing Then Exit Function
    If bstack.ExistVar(Left$(nm$, Len(nm$) - 1)) Then
    bstack.ReadVar Left$(nm$, Len(nm$) - 1), var(0)
    If Typename(var(0)) = mHdlr Then
                Set ga = New mArray
                Set ga.GroupRef = var(0)
                ga.Arr = False
                neoGetArray = True
                var(0) = 0&
                Exit Function
    End If
    var(0) = 0&
                Exit Function
    End If
     Exit Function
        
            End If
End If


If k > 0 Then
If Typename(var(k)) = "Empty" Then
Set ga = New mArray: neoGetArray = True
Else
If TypeOf var(k) Is mArray Then
    Set ga = var(k)
Else
    Set myobject = var(k)
    If CheckIsmArray(myobject) Then
        Set ga = myobject
    Else
        NotArray
        Set myobject = Nothing
    Exit Function
    End If
    Set myobject = Nothing
End If

End If
  neoGetArray = True
           
ElseIf k = 0 Then
 If n$ Like "*[$%](" Then
            n$ = Mid$(n$, 1, Len(n$) - 2)
            Else
            n$ = Mid$(n$, 1, Len(n$) - 1)
            End If
        If varhash.Find(n$, k) Then
            If TypeOf var(k) Is mHandler Then
                If var(k).t1 < 3 Then
                    Set ga = New mArray
                    Set ga.GroupRef = var(k)
                    ga.Arr = False
                    neoGetArray = True
                    Exit Function
                End If
            End If
            k = -1
        End If


If n$ = vbNullString Then Exit Function
        nm$ = Mid$(n$, 1, Len(n$) - 1)
        If Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
    If useLocalOnly Then Exit Function
    If Len(bstack.UseGroupname) > 0 Then
    n$ = bstack.UseGroupname + Mid$(nm$, 6)
     If Not varhash.Find(n$, k) Then
     n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
     varhash.Find n$, k
     End If
    Else
    n$ = Mid$(nm$, 5)
      If bstack.GetDot(n$, 1) Then varhash.Find here$ + "." + n$, k Else Exit Function
    End If
End If
        If varhash.Find(n$, k) Then
        If TypeOf var(k) Is mHandler Then
        
        Set ga = New mArray
        Set ga.GroupRef = var(k)
        ga.Arr = False
        neoGetArray = True
        Exit Function
        End If
        End If
End If


End Function
Function neoGetArrayLinkOnly(bstack As basetask, ByVal nm$, link As Long, Optional useglobalname As Boolean = False, Optional useLocalOnly As Boolean = False) As Boolean
Dim k As Long
Dim n$
nm$ = myUcase(nm$)
If Len(nm$) > 5 And False Then
           ' not used any more
                If Left$(nm$, 5) = "THIS." Then
               
                    n$ = StripThis2(here$)
                    If n$ <> "" Then n$ = n$ & "." & bstack.GroupName & Mid$(nm$, 6) Else n$ = here$ & "." & nm$
                ElseIf Left$(nm$, 5) = "ауто." Then
           
                    n$ = StripThis2(here$)
                    If n$ <> "" Then n$ = n$ & "." & bstack.GroupName & Mid$(nm$, 6) Else n$ = here$ & "." & nm$
                Else
                If useglobalname Then
                    n$ = nm$
                    Else
                    'n$ = here$ & "." & nm$
                    n$ = here$ & "." & bstack.GroupName & nm$
                    End If
                End If

Else
If useglobalname Then
'n$ = bstack.GroupName + nm$
n$ = nm$
Else
If here$ = vbNullString Then
n$ = nm$
Else
'n$ = here$ & "." & nm$
n$ = here$ & "." & bstack.GroupName & nm$
End If
End If
End If

If varhash.Find(n$, k) = False And Len(bstack.UseGroupname) > 0 Then
    If Left$(nm$, 5) = "ауто." Or Left$(nm$, 5) = "THIS." Then
        If useLocalOnly Then Exit Function
        If StripThis2(bstack.UseGroupname) = vbNullString Then
            n$ = bstack.UseGroupname + Mid$(nm$, 6)
        Else
            n$ = StripThis2(bstack.UseGroupname) + "." + Mid$(nm$, 6)
        End If
        varhash.Find n$, k
    End If
End If
If k = 0 Then
    If Not useLocalOnly Then
        n$ = myUcase(nm$)
        varhash.Find n$, k
    End If
End If
If k > 0 Then
    link = k
    neoGetArrayLinkOnly = True
    
End If

End Function

Function CopyArrayItems(bstack As basetask, nm$) As String
Dim k As Long
If neoGetArrayLinkOnly(bstack, nm$, k) Then CopyArrayItems = CStr(k)

End Function

Function CopyArrayItemsNoFormated(bstack As basetask, nm$) As Long
Dim k As Long
If varhash.Find(nm$, k) Then
CopyArrayItemsNoFormated = k
ElseIf varhash.Find(nm$, k) Then
If TypeOf var(k) Is mHandler Then
CopyArrayItemsNoFormated = -k
End If
End If
End Function
Function ModuleSubAsap(n$, q As String, Optional sbgroupname As String = vbNullString, Optional Extern As Long) As Long
Dim j As Long, where As Long
j = AllocSub()
With sbf(j)
    .Extern = Extern
    .sb = q
    .sbc = 0
    .sbgroup = sbgroupname
    Set .subs = Nothing
    .goodname = n$
    .Changed = False
End With
subHash.ItemCreator n$, j
ModuleSubAsap = j
End Function
Function ModuleSub(Name$, q As String, Optional sbgroupname As String = vbNullString) As Long
Dim j As Long, n$, where As Long
n$ = myUcase(Name$, True)

j = AllocSub()
With sbf(j)
    .Extern = 0
    .sb = q
    .sbc = 0
    .sbgroup = sbgroupname
    Set .subs = Nothing
    .goodname = Name$
    .Changed = False
End With
subHash.ItemCreator n$, j
ModuleSub = j
End Function
Function GlobalSub(Name$, q As String, Optional sbgroupname As String = vbNullString, Optional ByVal nameonly$ = vbNullString, Optional Extern As Long = 0) As Long
Dim j As Long, n$, where As Long
n$ = myUcase(Name$, True)

j = AllocSub()
With sbf(j)
    .Extern = Extern
    .sb = q
    .sbc = 0
    .sbgroup = sbgroupname
    .tpointer = 0
    Set .subs = Nothing
    .goodname = Name$
    .Changed = False
End With
If Not nameonly$ = vbNullString Then
If sbgroupname = vbNullString Then
    nameonly$ = myUcase(nameonly$, True)
    If comhash.Find(nameonly$, where) Then
    If n$ = nameonly$ Then
    comhash.ItemCreator2 nameonly$, 0, 32
    Else
    comhash.ItemCreator2 nameonly$, 0, 33
    End If
    End If
    End If
End If
subHash.ItemCreator n$, j

GlobalSub = j
End Function

Function GetGlobalVar(nm$, i As Long) As Boolean

If varhash.Find(myUcase(nm$), i) Then
GetGlobalVar = True
End If
End Function

Function StripThis(ByVal n$) As String

Dim a$, B$, i&
a$ = n$
DropLeft "].", a$


'Exit Function
a$ = StripRVAL(a$)  ' we need that

If a$ = n$ Then
StripThis = vbNullString
Exit Function
Else
B$ = a$
End If
i& = InStr(n$, ".")
If i& > 0 Then

DropLeft ".", n$
i& = InStrRev(n$, ".") - 1
If i& > 0 Then
StripThis = B$ & "." & Left$(n$, i&)
Else
StripThis = B$
End If
Else
StripThis = B$
End If
End Function
Function StripThis2(ByVal n$) As String

Dim a$, B$, i&

If StripRVAL2(n$, a$) Then
StripThis2 = a$
Exit Function
End If
If a$ = n$ Then
StripThis2 = vbNullString
Exit Function
Else
B$ = a$
End If
i& = InStr(n$, ".")
If i& > 0 Then

DropLeft ".", n$
i& = InStrRev(n$, ".") - 1
If i& > 0 Then
StripThis2 = B$ & "." & Left$(n$, i&)
Else
StripThis2 = B$
End If
Else
StripThis2 = B$
End If
End Function

Function GetVar1(bstack As basetask, ByVal nm$, i As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False, Optional finalname As String, Optional checktype As Boolean = 0) As Boolean
If skip Then Exit Function
' called from unfloat
If varhash.Find2(nm$, i, checktype) Then GetVar1 = True
End Function
Function GetVar3(bstack As basetask, ByVal nm$, i As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False, Optional finalname As String, Optional checktype As Boolean = 0, Optional feedback As Boolean, Optional nosearch As Boolean, Optional statobj As Boolean = False) As Boolean
If skip Then Exit Function
If Not bstack.StaticCollection Is Nothing Then
    If bstack.ExistVar(nm$, statobj) Then i = -1: Exit Function
    
End If
Dim n$, cc As Long
  
cc = Len(nm$)
If cc > 5 Then
    If Left$(nm$, 5) = "ауто." Then
    GoTo cont1
    ElseIf Left$(nm$, 5) = "THIS." Then
cont1:
        If Len(bstack.UseGroupname) > 0 Then
            feedback = False
            n$ = bstack.UseGroupname + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
        Else
            n$ = StripThis2(here$)
            If n$ <> vbNullString Then
                n$ = n$ & "." & Mid$(nm$, 6)
            Else
                If IsLabel(bstack, Mid$(nm$, 6), n$) Then
                    n$ = here$ & "." & n$
                Else
                    n$ = here$ & "." & nm$
                End If
            End If
        End If
        
    Else
        If lookglobalonly Then
            n$ = nm$
        Else

           
            n$ = here$ + "." + nm$
        End If
    End If
ElseIf cc = 4 Then
    If nm$ = "ауто" Then
    GoTo cont2
    ElseIf nm$ = "THIS" Then
cont2:

        n$ = vbNullString
         If bstack.GetDotNew(n$, 1) Then
           If Len(n$) = 0 Then GetVar3 = False: Exit Function
            nm$ = Left$(n$, Len(n$) - 1)
            finalname = nm$
            feedback = True
        End If
    End If
    If lookglobalonly Then
        n$ = nm$
    Else
        n$ = here$ + "." + nm$
    End If
Else
    If lookglobalonly Then
        n$ = nm$
    Else
        'n$ = here$ & "." & bstack.GroupName & nm$
        n$ = here$ + "." + nm$
    End If

End If

If varhash.Find2(n$, cc, checktype, feedback) Then
there12:
    GetVar3 = True
    i = cc
ElseIf Not looklocalonly Then
    n$ = nm$
    If Len(bstack.UseGroupname) > 0 Then
        If InStr(n$, bstack.UseGroupname) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find(n$, cc) Then
                checktype = True
                i = cc
                GetVar3 = True
                nm$ = n$
            End If
        ElseIf InStr(bstack.UseGroupname, n$) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find2(n$, cc, checktype, feedback) Then
                i = cc
                GetVar3 = True
                nm$ = n$
            End If
        End If
    End If
    If Not GetVar3 Then
        If varhash.Find2(nm$, cc, checktype, feedback) Then
            i = cc
            GetVar3 = True
        ElseIf nosearch Then
            Exit Function
        ElseIf Len(bstack.UseGroupname) > 0 Then
            Exit Function
        ElseIf wide Then
            If SecureNames Then
                If bstack.IamChild Then
                cc = InStr(n$, ".")
                If cc = 0 Then
                            nm$ = sbf(iRVAL22(here$)).goodname
                            cc = InStr(nm$, ".")
                            nm$ = Mid$(nm$, cc + 1)
                            If cc > 0 Then
                            If varhash.Find2(nm$ + "." + n$, i, checktype, feedback) Then
                                GetVar3 = True
                                Exit Function
                                End If
                                End If
                ElseIf cc > 1 Then
                    n$ = Left$(n$, cc - 1): nm$ = Mid$(nm$, cc + 1)
                    End If
                    Dim m As Long
                    m = Abs(iRVAL22(here$))
                    i = 0
                    For cc = m - 1 To 1 Step -1
                        i = i - 1
                        If sbf(cc).goodname Like "*[.]" + n$ Then Exit For
                        If sbf(cc).goodname Like "*[.]" + ChrW(-65) + n$ Then Exit For
                    Next cc
                    If cc > 0 Then
                    
                        If cc > m + i Then i = 1
                            If varhash.Find2(StripThis2(here$) + "[" + CStr(m + i) + "][" + CStr(cc) + "]" + "." + nm$, i, checktype, feedback) Then
                                GetVar3 = True
                           ElseIf varhash.Find2(StripThis2(here$) + "[" + CStr(m + i) + "][" + CStr(cc) + "]" + "." + ChrW(-65) + nm$, i, checktype, feedback) Then
                                GetVar3 = True
                        Else
                            If Not Right$(sbf(cc).goodname, 1) <> "]" Then m = cc
                            Do While m > 1
                                m = m - 1
                                If varhash.Find2(StripThis2(here$) + "[" + CStr(m) + "][" + CStr(cc) + "]" + "." + nm$, i, checktype, feedback) Then
                                    GetVar3 = True
                                    Exit Do
                                ElseIf varhash.Find2(StripThis2(here$) + "[" + CStr(m) + "][" + CStr(cc) + "]" + "." + ChrW(-65) + nm$, i, checktype, feedback) Then
                                    GetVar3 = True
                                    Exit Do
                                End If
                            Loop
                        End If
                        Else
                       
                    End If
    
                    If Not GetVar3 Then i = 0
                End If
            End If
        End If
    End If
End If
'***********************

End Function
Function GetVar(bstack As basetask, ByVal nm$, i As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False, Optional finalname As String, Optional checktype As Boolean = 0, Optional feedback As Boolean, Optional nosearch As Boolean) As Boolean
If skip Then Exit Function
If Not bstack.StaticCollection Is Nothing Then
    If bstack.ExistVar(nm$) Then i = -1: Exit Function
End If
Dim n$, cc As Long
  
cc = Len(nm$)
If cc > 5 And i >= 0 Then
    If Left$(nm$, 5) = "ауто." Then
    GoTo cont1
    ElseIf Left$(nm$, 5) = "THIS." Then
cont1:
        If Len(bstack.UseGroupname) > 0 Then
            feedback = False
            n$ = bstack.UseGroupname + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
            If varhash.Find2(n$, cc, checktype) Then finalname = n$: GoTo there12
        Else
            n$ = StripThis2(here$)
            If n$ <> vbNullString Then
                n$ = n$ & "." & Mid$(nm$, 6)
            Else
                If IsLabel(bstack, Mid$(nm$, 6), n$) Then
                    n$ = here$ & "." & n$
                Else
                    n$ = here$ & "." & nm$
                End If
            End If
        End If
        
    Else
        If lookglobalonly Then
            n$ = nm$
        Else

           
            n$ = here$ + "." + nm$
        End If
    End If
Else
    If lookglobalonly Then
        n$ = nm$
    Else
        'n$ = here$ & "." & bstack.GroupName & nm$
        n$ = here$ + "." + nm$
    End If

End If

If varhash.Find2(n$, cc, checktype, feedback) Then
there12:
    GetVar = True
    i = cc
ElseIf Not looklocalonly Then
    n$ = nm$
    If Len(bstack.UseGroupname) > 0 Then
        If InStr(n$, bstack.UseGroupname) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find(n$, cc) Then
                checktype = True
                i = cc
                GetVar = True
                nm$ = n$
            End If
        ElseIf InStr(bstack.UseGroupname, n$) = 1 Then
            n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(n$, Len(bstack.UseGroupname) + 1)
            If varhash.Find2(n$, cc, checktype, feedback) Then
                i = cc
                GetVar = True
                nm$ = n$
            End If
        End If
    End If
    If Not GetVar Then
        If varhash.Find2(nm$, cc, checktype, feedback) Then
            i = cc
            GetVar = True
       ElseIf varhash.Find2(here$ + "." + nm$, cc, checktype, feedback) Then
            i = cc
            GetVar = True
        ElseIf nosearch Then
            Exit Function
        ElseIf Len(bstack.UseGroupname) > 0 Then
            Exit Function
        ElseIf wide Then
            If SecureNames Then
                If bstack.IamChild Then
                cc = InStr(n$, ".")
                If cc = 0 Then
                            nm$ = sbf(iRVAL22(here$)).goodname
                            cc = InStr(nm$, ".")
                            nm$ = Mid$(nm$, cc + 1)
                            If cc > 0 Then
                            If varhash.Find2(nm$ + "." + n$, i, checktype, feedback) Then
                                GetVar = True
                                Exit Function
                                End If
                                End If
                ElseIf cc > 1 Then
                    n$ = Left$(n$, cc - 1): nm$ = Mid$(nm$, cc + 1)
                    End If
                    Dim m As Long
                    m = Abs(iRVAL22(here$))
                    i = 0
                    For cc = m - 1 To 1 Step -1
                        i = i - 1
                        If sbf(cc).goodname Like "*[.]" + n$ Then Exit For
                        If sbf(cc).goodname Like "*[.]" + ChrW(-65) + n$ Then Exit For
                    Next cc
                    If cc > 0 Then
                    
                        If cc > m + i Then i = 1
                            If varhash.Find2(StripThis2(here$) + "[" + CStr(m + i) + "][" + CStr(cc) + "]" + "." + nm$, i, checktype, feedback) Then
                                GetVar = True
                           ElseIf varhash.Find2(StripThis2(here$) + "[" + CStr(m + i) + "][" + CStr(cc) + "]" + "." + ChrW(-65) + nm$, i, checktype, feedback) Then
                                GetVar = True
                        Else
                            If Not Right$(sbf(cc).goodname, 1) <> "]" Then m = cc
                            Do While m > 1
                                m = m - 1
                                If varhash.Find2(StripThis2(here$) + "[" + CStr(m) + "][" + CStr(cc) + "]" + "." + nm$, i, checktype, feedback) Then
                                    GetVar = True
                                    Exit Do
                                ElseIf varhash.Find2(StripThis2(here$) + "[" + CStr(m) + "][" + CStr(cc) + "]" + "." + ChrW(-65) + nm$, i, checktype, feedback) Then
                                    GetVar = True
                                    Exit Do
                                End If
                            Loop
                        End If
                        Else
                       
                    End If
    
                    If Not GetVar Then i = 0
                End If
            End If
        End If
    End If
End If
'***********************

End Function
Function FindGuiImage(basestack As basetask, Scr As Object) As Object
Dim p As Long
    p = GetCode(Scr)
    If p > 32 Then
        If getvar2(basestack, players(p).controlname, p, True) Then
           Set FindGuiImage = var(p)
        End If
     End If
End Function
Function getvar2(bstack As basetask, nm$, i As Long, Optional lookglobalonly As Boolean = False, Optional skip As Boolean, Optional looklocalonly As Boolean = False) As Boolean
If skip Then Exit Function
If Not bstack.StaticCollection Is Nothing Then
If bstack.ExistVar(nm$) Then i = -1: Exit Function
End If
Dim n$, cc As Long
cc = Len(nm$)
If cc > 5 Then
    If Left$(nm$, 5) = "ауто." Then
    GoTo cont1
    ElseIf Left$(nm$, 5) = "THIS." Then
cont1:
        If Len(bstack.UseGroupname) > 0 Then
                  n$ = bstack.UseGroupname + Mid$(nm$, 6)
                If varhash.Find(n$, cc) Then GoTo there12
                
                    n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, 6)
                If varhash.Find(n$, cc) Then GoTo there12
        Else
        
            n$ = StripThis2(here$)
            If n$ <> "" Then
                n$ = n$ & "." & Mid$(nm$, 6)
            
            Else
            If IsLabel(bstack, Mid$(nm$, 6), n$) Then ' NO NEED DOT ANY MORE..(WE USE DOTNEW)
                    n$ = here$ & "." & n$
            Else
                    n$ = here$ & "." & nm$
            End If
            End If
        End If
    Else
    If lookglobalonly Then
     n$ = nm$
    Else
        n$ = here$ & "." & nm$
        End If
    End If
ElseIf cc = 4 Then
    If nm$ = "ауто" Then
    GoTo cont2
    ElseIf nm$ = "THIS" Then
cont2:

       n$ = vbNullString

        If bstack.GetDotNew(n$, 1) Then
            If Len(n$) = 0 Then getvar2 = False: Exit Function
           nm$ = Left$(n$, Len(n$) - 1)
        End If
    End If
    If lookglobalonly Then
         n$ = nm$
        Else
    n$ = here$ & "." & nm$


    End If
Else
    If lookglobalonly Then
        n$ = nm$
    Else
        n$ = here$ + "." + nm$
    End If

End If

If varhash.Find(n$, cc) Then
there12:
    getvar2 = True
    i = cc
ElseIf Not looklocalonly Then
    If varhash.Find(nm$, cc) Then
    i = cc
    getvar2 = True
    ElseIf Len(bstack.UseGroupname) > 0 Then
        If InStr(nm$, bstack.UseGroupname) = 1 Then
        n$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(nm$, Len(bstack.UseGroupname) + 1)
        If varhash.Find(n$, cc) Then
        i = cc
        getvar2 = True
    End If
    End If
    End If
End If



End Function
Function GetlocalVar(nm$, i As Long) As Boolean
If varhash.Find(here$ & "." & myUcase(nm$), i) Then GetlocalVar = True
End Function
Function RVAL3(ByVal what$, ByVal s$, v As Long) As String
Dim ss$, n As Long

n = InStrRev(s$, "[")

If n = 0 Then
If what$ <> "" Then what$ = "." + what$ + "[1]"
RVAL3 = s$ + ChrW$(127) + CStr(v) + "[1]" + what$
Else
    ss$ = Left$(s$, n - 1&)
    what$ = Mid$(s$, InStr(s$, "].") + 1)
    If Len(what$) = Len(s$) Then what$ = vbNullString
    
    RVAL3 = ss$ & "[" & CStr(val(Mid$(s$, n + 1&)) + 1&) & "]" + what$
End If
End Function
Function RVAL33(ByVal s$, v As Long) As String
Dim ss$, n As Long, what$

n = InStrRev(s$, "[")

If n = 0 Then
RVAL33 = s$ + "[" + CStr(v) + "][" + CStr(v) + "]"
Else
    ss$ = Left$(s$, n - 1&)
   ' what$ = Mid$(s$, InStr(s$, "][") + 1)
    'If Len(what$) = Len(s$) Then what$ = "[0]"
    
    RVAL33 = RVAL(ss$, 1) & "[" + CStr(v) + "]"
End If
End Function
Function RVAL2(ByVal s$, v As Long) As String
Dim ss$
If InStr(s$, "[") = 0 Then
RVAL2 = s$
Else
ss$ = GetStrUntil("[", s$)
If val(s$) + v <= 0 Then
RVAL2 = ss$ + "."
Else
RVAL2 = ss$ & "[" & CStr(val(s$) + v) & "]."
End If
End If
End Function
Function iRVAL22(ByVal s$) As Long
    Dim n As Long
    
    
    
    iRVAL22 = val(Mid$(s$, InStrRev(s$, "[") + 1))
End Function
Function RVAL(ByVal s$, v As Long) As String
Dim ss$
If InStr(s$, "[") = 0 Then
RVAL = s$ & "[" & CStr(v) & "]"
Else
ss$ = GetStrUntil("[", s$)

RVAL = ss$ & "[" & CStr(val(s$) + v) & "]"
End If
End Function
Function TheSame(ByVal s$, ByVal q$) As Boolean
Dim part1 As String
part1 = StripRVAL(s$)
If part1 <> "" Then
    If InStr(part1, ".") > 0 Then
    ' all in part1
    Else
    DropLeft ".", s$
    part1 = part1 & "." & s$
    End If
    End If
TheSame = part1 = q$
End Function
Function StripRVAL2(s$, Result$) As Boolean
' return s$ number as string
' return function name...
'
Dim bb$, varname$
bb$ = s$
If InStr(s$, "[") = 0 Then
' look varlist to find group
Dim i As Long
i = InStrRev(s$, ".")
If i > 1 Then s$ = Left$(s$, i - 1)
If InStrRev(varname$, "." + s$ + " ") < 1 Then Exit Function
s$ = Mid$(varname$, InStrRev(varname$, Chr$(1), InStrRev(varname$, "." + s$ + " ")) + 1)
Result$ = GetStrUntil(" ", s$)
StripRVAL2 = True
If Not Typename(var(val(s$))) = mgroup Then StripRVAL2 = False: s$ = bb$: Result$ = vbNullString
Else
Result$ = GetStrUntil("[", s$)
End If

End Function
Function StripRVAL(ByVal s$) As String
Dim i
i = InStrRev(s$, "[")
If i = 0 Then
' do not delete this.....
    StripRVAL = s$
ElseIf i = 1 Then
Else
    StripRVAL = Left$(s$, i - 1)
End If
End Function
Function iRVAL(ByVal s$, v As Long) As Long
If InStr(s$, "[") = 0 Then
iRVAL = v
Else
DropLeft "[", s$
iRVAL = val(s$) + v
End If
End Function

Function GetSubFullName(nm$, fullname$) As Boolean
If Len(here$) > 0 Then
    If Len(here$) > Len(nm$) Then
        If Mid$(here$, Len(here$) - Len(nm$)) = "." + nm$ Then
            GetSubFullName = subHash.ExistKey(nm$)
          fullname = nm$: Exit Function
        End If
    End If
End If

If here$ <> "" Then
     GetSubFullName = subHash.ExistKey(here$ & "." & nm$)
  If GetSubFullName Then fullname$ = here$ & "." & nm$: Exit Function
End If

    GetSubFullName = subHash.ExistKey(nm$)
 If GetSubFullName Then fullname$ = nm$





End Function



Function GetSub2(bstack As basetask, nm$, i&) As Boolean
i& = 0
If Len(here$) > 0 Then
    If Len(here$) > Len(nm$) Then
        If Mid$(here$, Len(here$) - Len(nm$)) = "." + nm$ Then
               '
                i& = bstack.OriginalCode
                If bstack.IamLambda Then
                    GetSub2 = subHash.Find(bstack.FuncRec, i&)
                    If GetSub2 Then nm$ = bstack.FuncRec
                Else
                     nm$ = sbf(i&).goodname

                    GetSub2 = True
                End If
        End If
   ElseIf Right$(here$, 1) = "]" Then
   GetSub2 = subHash.Find(here$ + "." + nm$, i&)
    End If
End If

If i& = 0 And here$ <> "" Then
     GetSub2 = subHash.Find(here$ & "." & nm$, i&)
ElseIf i& <> 0 Then
    Exit Function
End If
If i& = 0 Then
    GetSub2 = subHash.Find(nm$, i&)
Else
    Exit Function
End If
If i& = 0 Then
   
Else
    Exit Function
End If

End Function

Function GetSub(nm$, i&) As Boolean
i& = 0
If Len(here$) > 0 Then
    If Len(here$) > Len(nm$) Then
        If Mid$(here$, Len(here$) - Len(nm$)) = "." + nm$ Then
               
            GetSub = subHash.Find(StripRVAL(here$) + "." + nm$, i&)
            
        End If
   ElseIf Right$(here$, 1) = "]" Then
   GetSub = subHash.Find(here$ + "." + nm$, i&)
    End If
End If
If GetSub Then Exit Function
If i& = 0 And here$ <> "" Then
     GetSub = subHash.Find(here$ & "." & nm$, i&)
ElseIf i& <> 0 Then
    Exit Function
End If
If i& = 0 Then
    GetSub = subHash.Find(nm$, i&)
       
End If

End Function

Function GetlocalSub(nm$, i&) As Boolean

If subHash.Find(here$ & "." & nm$, i&) Then GetlocalSub = True

End Function
Function GetGlobalSubAfterHere(basestack As basetask, nm$, i&) As Boolean

If basestack.IamAnEvent Or basestack.IamLambda Or basestack.IamAnEvent Then
    GetGlobalSubAfterHere = subHash.Find(nm$, i&)
    Exit Function
ElseIf subHash.Find(nm$, i&) Then
GetGlobalSubAfterHere = Not basestack.IamChild
End If

End Function

Function GetlocalSubExtra(nm$, i&) As Boolean
Dim n$
Dim subname$
subname$ = subHash.Show
n$ = "." & nm$ & " "
i& = InStr(subname$, n$)
If i& > 0 Then

GetlocalSubExtra = True
i& = val(Mid$(subname$, i& + Len(n$)))
Else
GetlocalSubExtra = False
End If
End Function
Function PosLabel(ByVal w$, B$, Optional ByVal lim As Long = 0) As Long
Dim i As Long, j As Long, jmp As Boolean
On Error Resume Next
If val(Left$(w$, 1)) = 0 Then w$ = w$ & ":": jmp = True
If lim = 0 Then lim = Len(B$)
PosLabel = lim + 1
If Left$(B$, Len(w$)) = w$ Then
    If Not jmp Then If Mid$(B$, Len(w$) + 1, 1) Like "[0-9]" Then GoTo conthere
    i = 1
    PosLabel = 1: Exit Function
Else
conthere:
Dim w1$
w1$ = Chr(10) + w$
Do
i = InStr(i + 1, B$, w1$)
If i > 0 Then
    If jmp Then Exit Do
    If Not Mid$(B$, i + Len(w$) + 1, 1) Like "[0-9]" Then Exit Do
    i = i + Len(w$)
Else
    Exit Do
End If
Loop
If i = 0 Then
Dim w2$
w1$ = " " & w$
w2$ = "0" & w$
Dim w3$
w3$ = ChrW(9) + w$
j = i
    Do
again00:
    i = InStr(j + 1, B$, w3$)
    If i > lim Then Exit Function
    If i = 0 Then
    i = j
    j = InStr(i + 1, B$, w1$)
    If j > lim Then Exit Function
     If j = 0 Then i = 0: Exit Do
    i = j
    End If
    
    If i < 2 Then Exit Do
    j = MyTrimRfrom(B$, 1, i + 1)

    
    
    If j < 2 Then Exit Do
    If Mid$(B$, j - 1, 1) = Chr(10) Then
    If Not jmp Then
    If Not Mid$(B$, i + Len(w$) + 1, 1) Like "[0-9]" Then Exit Do
    Else
    Exit Do
    End If
    End If
    j = j + Len(w$)
    
    Loop
    If i = 0 Then
    j = 0
    Do
    
shiftone:
    i = InStr(j + 1, B$, w2$)
    If i > lim Then Exit Function
    If i = 0 Then Exit Do
    If Mid$(B$, i + Len(w2$), 1) Like "[0-9]" Then j = j + 1: GoTo shiftone
    If i <= 1 Then Exit Do
    j = i - 1
    
    While j > 1 And Mid$(B$, j, 1) = "0"
            j = j - 1
    Wend
    If j < 2 Then Exit Do
    If Mid$(B$, j, 1) = Chr(10) Then Exit Do
    j = MyTrimRfrom(B$, 1, j) - 1
   
    If Mid$(B$, j, 1) = Chr(10) Then Exit Do
    j = i + Len(w2$)
    Loop
    End If
End If


End If
If jmp Then

If i > 0 Then
While Mid$(B$, MyTrimLi(B$, i + Len(w$) + 1), 1) Like thislabel$ And i > 0
    i = InStr(i + Len(w$) + 1, B$, Chr(10) + w$)
Wend
If i > lim Then Exit Function
If i > 0 Then PosLabel = i + 1

End If

Else
If i > lim Then Exit Function
If i > 1 Then PosLabel = i + 1
End If
End Function


Function logical(basestack As basetask, s$, D As Variant, Optional par As Long = 0, Optional flatobject As Boolean = False, Optional ByPass As Boolean = False) As Boolean
Dim B$, s2$, S3$ ' , OSTAC$
Dim ah As String
again11:
If ByPass Then
'Mid$(s$, 1, 1) = Right$(basestack.tmpstr, 1)
ah = aheadstatusFast(basestack.tmpstr)

Else
    ah = aheadstatusFast(s$)
End If
If InStr(ah, "l") = 0 Then
If InStr(ah, "N") > 0 Then

If Not IsNumber(basestack, s$, D, flatobject) Then
    Set basestack.lastobj = Nothing
    If LastErNum1 < 0 Then Exit Function
Else
    logical = True
End If
Else
If par > 0 Then
If Not GetArr(basestack, s$, D, s2$, 0) Then
    Set basestack.lastobj = Nothing
Else
    If Len(s$) > 0 Then
    If AscW(s$) = 8 Then
    par = par - 1
    ' what ????
    ByPass = True
    GoTo again11
   End If
    End If
    logical = True
End If

If logical Then
par = par - 1
End If
Exit Function
Else
logical = False
End If
End If
s$ = NLtrim$(s$)
Exit Function
Else
If Left$(ah, 2) = "SN" Then Exit Function
End If
On Error Resume Next

If Err.Number > 0 Then Exit Function
If Left$(ah, 1) <> "N" Then
 IsStrExp basestack, s$, B$, False
conthere:
logical = False
If Not mTextCompare Then
If FastSymbol(s$, "=") Then
    logical = False
    If IsStrExp(basestack, s$, s2$) Then
    logical = True
    D = B$ = s2$
    Exit Function
    Else
    If LastErNum = -2 Then logical = True
    Exit Function
    End If
ElseIf FastSymbol(s$, "<") Then
    logical = False
    If Left$(s$, 1) = "=" Then
        Mid$(s$, 1, 1) = " "
        If Left$(s$, 2) = " >" Then
            Mid$(s$, 2, 1) = " "
            If IsStrExp(basestack, s$, s2$) Then
                logical = True
                Select Case B$
                Case Is < s2$
                    D = -1
                Case Is = s2$
                    D = 0
                Case Else
                    D = 1
                End Select
                Exit Function
            Else
                If LastErNum = -2 Then logical = True
            Exit Function
            End If
        Else
            If IsStrExp(basestack, s$, s2$) Then
                logical = True
                D = B$ <= s2$
                Exit Function
            Else
                If LastErNum = -2 Then logical = True
                Exit Function
            End If
        End If
    ElseIf Left$(s$, 1) = ">" Then
        Mid$(s$, 1, 1) = " "
        If IsStrExp(basestack, s$, s2$) Then
            logical = True
            D = B$ <> s2$
            Exit Function
        Else
            If LastErNum = -2 Then logical = True
            Exit Function
        End If
    ElseIf IsStrExp(basestack, s$, s2$) Then
    logical = True
    D = B$ < s2$
    Exit Function
            Else
    If LastErNum = -2 Then logical = True
    Exit Function
    End If
ElseIf FastSymbol(s$, ">") Then
    logical = False
    If Left$(s$, 1) = "=" Then
        Mid$(s$, 1, 1) = " "
        If IsStrExp(basestack, s$, s2$) Then
            logical = True
            D = B$ >= s2$
            Exit Function
        Else
            If LastErNum = -2 Then logical = True
            Exit Function
        End If
    ElseIf IsStrExp(basestack, s$, s2$) Then
    logical = True
    D = B$ > s2$
    Exit Function
            Else
    If LastErNum = -2 Then logical = True
    Exit Function
    End If
ElseIf FastSymbol(s$, "~") Then
    logical = False
    If IsStrExp(basestack, s$, s2$) Then
    logical = True
    D = B$ Like s2$
    Exit Function
            Else
    If LastErNum = -2 Then logical = True
    Exit Function
    End If
End If
Else
If FastSymbol(s$, "=") Then
    logical = False
    If IsStrExp(basestack, s$, s2$) Then
    logical = True
    D = CompareStr2(B$, s2$) = 0
    Exit Function
    Else
    If LastErNum = -2 Then logical = True
    Exit Function
    End If
ElseIf FastSymbol(s$, "<") Then
    logical = False
    If Left$(s$, 1) = "=" Then
        Mid$(s$, 1, 1) = " "
        If Left$(s$, 2) = " >" Then
            Mid$(s$, 2, 1) = " "
            If IsStrExp(basestack, s$, s2$) Then
                logical = True
                D = CompareStr2(B$, s2$)
                Exit Function
            Else
                If LastErNum = -2 Then logical = True
                Exit Function
            End If
        ElseIf IsStrExp(basestack, s$, s2$) Then
            logical = True
            D = CompareStr2(B$, s2$) < 1
            Exit Function
        Else
            If LastErNum = -2 Then logical = True
            Exit Function
        End If
    ElseIf Left$(s$, 1) = ">" Then
        Mid$(s$, 1, 1) = " "
        If IsStrExp(basestack, s$, s2$) Then
            logical = True
            D = CompareStr2(B$, s2$) <> 0
            Exit Function
        Else
            If LastErNum = -2 Then logical = True
            Exit Function
        End If
    ElseIf IsStrExp(basestack, s$, s2$) Then
        logical = True
        D = CompareStr2(B$, s2$) = -1
        Exit Function
    Else
        If LastErNum = -2 Then logical = True
        Exit Function
    End If
ElseIf FastSymbol(s$, ">") Then
    logical = False
    If Left$(s$, 1) = "=" Then
        Mid$(s$, 1, 1) = " "
        If IsStrExp(basestack, s$, s2$) Then
            logical = True
            D = CompareStr2(B$, s2$) > -1
            Exit Function
        Else
            If LastErNum = -2 Then logical = True
            Exit Function
        End If
    ElseIf IsStrExp(basestack, s$, s2$) Then
        logical = True
        D = CompareStr2(B$, s2$) = 1
        Exit Function
    Else
        If LastErNum = -2 Then logical = True
    Exit Function
    End If
ElseIf FastSymbol(s$, "~") Then
    logical = False
    If IsStrExp(basestack, s$, s2$) Then
    logical = True
    D = B$ Like s2$
    Exit Function
            Else
    If LastErNum = -2 Then logical = True
    Exit Function
    End If
End If

End If

Else
'If s$ <> s2$ Then Stop
's$ = s2$
cont145:
If IsNumber(basestack, s$, D, flatobject) Then
logical = True
End If
End If
End Function

Function BlockParam(s$) As String
' need to be open
Dim i As Long, j As Long
j = 1
For i = 1 To Len(s$)
Select Case AscW(Mid$(s$, i, 1))
Case 0
Exit For
Case 34
i = InStr(i + 1, s$, Chr(34))
If i = 0 Then Exit Function
Case 40
j = j + 1
Case 41
j = j - 1
If j = 0 Then Exit For
Case 123
i = InStr(i + 1, s$, Chr$(125))
If i = 0 Then Exit Function
End Select
Next i
If j = 0 Then
BlockParam = Left$(s$, i - 1)
End If
End Function
Function block(s$) As String
Dim i As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
If Trim$(s$) = vbNullString Then Exit Function
c = Len(s$)
a1 = True
i = 1
Do
Select Case AscW(Mid$(s$, i, 1))
Case 32
' nothing
Case 34
Do While i < c
i = i + 1
If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
Loop

Case 47
If Mid$(s$, i + 1, 1) = "/" Then i = i + 1: GoTo a1111
Case 39, 92
a1111:
Do While i < c
i = i + 1
If Mid$(s$, i, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123


If jump Then
jump = False
' we have a multiline text
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, i, 1))
    Case 34
    Do While i < c
    i = i + 1
    If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    i = i + 1
    Loop Until i > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
i = i + 1
Loop Until i > c
If j = 1 Then
block = Left$(s$, i - 1)

s$ = Mid$(s$, i)
Else
block = vbNullString '' "Error " & chr(34) & "missing }" & chr(34)
End If



End Function
Function blockLen(s$) As Long
Dim i As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
If Trim$(s$) = vbNullString Then Exit Function
c = Len(s$)
a1 = True
i = 1
Do
Select Case AscW(Mid$(s$, i, 1))
Case 32
' nothing
Case 34
Do While i < c
i = i + 1
If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
Loop
Case 47
If Mid$(s$, i + 1, 1) = "/" Then i = i + 1: GoTo a1111
Case 39, 92
a1111:
Do While i < c
i = i + 1
If Mid$(s$, i, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123


If jump Then
jump = False
' we have a multiline text
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, i, 1))
    Case 34
    Do While i < c
    i = i + 1
    If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    i = i + 1
    Loop Until i > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
i = i + 1
Loop Until i > c
If j = 1 Then
blockLen = i
Else
blockLen = 0
End If



End Function

Function blockLen2(s$, Pos) As Long
Dim i As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
If Trim$(s$) = vbNullString Then Exit Function
c = Len(s$)
a1 = True
i = Pos
Do
Select Case AscW(Mid$(s$, i, 1))
Case 32
' nothing
Case 34
Do While i < c
i = i + 1
If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
Loop
Case 47
If Mid$(s$, i + 1, 1) = "/" Then i = i + 1: GoTo a1111
Case 39, 92
a1111:
Do While i < c
i = i + 1
If Mid$(s$, i, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123
If jump Then
jump = False
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, i, 1))
    Case 34
    Do While i < c
    i = i + 1
    If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    i = i + 1
    Loop Until i > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
i = i + 1
Loop Until i > c
If j = 1 Then
blockLen2 = i
Else
blockLen2 = 0
End If



End Function
Function BlockParam2(s$, Pos As Long) As Boolean
' need to be open
Dim i As Long, j As Long, ii As Long
j = 1
For i = Pos To Len(s$)
Select Case AscW(Mid$(s$, i, 1))
Case 0
Exit For
Case 34
again:
ii = InStr(i + 1, s$, """")
If ii = 0 Then Exit Function
 i = ii
If Mid$(s$, ii - 1, 1) = "`" Then GoTo again

Case 40
j = j + 1
Case 41
j = j - 1
If j = 0 Then Exit For
Case 123
i = i + 1
If blockStringPOS(s$, i) Then
Else
i = 0
End If
If i = 0 Then Exit Function
End Select
Next i
If j = 0 Then Pos = i: BlockParam2 = True
End Function

Function blockStringPOS(s$, Pos As Long) As Boolean
Dim i As Long, j As Long, c As Long
Dim a1 As Boolean
c = Len(s$)
a1 = True
i = Pos
If i > Len(s$) Then Exit Function
Do
Select Case AscW(Mid$(s$, i, 1))
Case 34
Do While i < c
i = i + 1
If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
Loop
Case 123
j = j - 1
Case 125
j = j + 1: If j = 1 Then Exit Do
End Select
i = i + 1
Loop Until i > c
If j = 1 Then
blockStringPOS = True
Pos = i
Else
Pos = Len(s$)
End If

End Function
Function block2(s$) As String
Dim i As Long, j As Long, c As Long
Dim a1 As Boolean
Dim jump As Boolean
Dim alter As Boolean
If Trim$(s$) = vbNullString Then Exit Function

c = Len(s$)
a1 = True
i = 1
Do
Select Case AscW(Mid$(s$, i, 1))
Case 32
' nothing
Case 34
Do While i < c
i = i + 1
If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
Loop
Case 47
If Mid$(s$, i + 1, 1) = "/" Then i = i + 1: GoTo a1111
Case 39, 92
a1111:
Do While i < c
i = i + 1
If Mid$(s$, i, 2) = vbCrLf Then Exit Do
Loop
Case 61
jump = True
Case 123


If jump Then
jump = False
' we have a multiline text
Dim target As Long
target = j
    Do
    Select Case AscW(Mid$(s$, i, 1))
    Case 34
    Do While i < c
    i = i + 1
    If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do
    Loop
    Case 123
    j = j - 1
    Case 125
    j = j + 1: If j = target Then Exit Do
    End Select
    i = i + 1
    Loop Until i > c
    If j <> target Then Exit Do
    Else
j = j - 1
End If


Case 125
j = j + 1: If j = 1 Then Exit Do
Case Else
jump = False

End Select
i = i + 1
Loop Until i > c
If j = 1 Then
block2 = Left$(s$, i - 1)
s$ = Mid$(s$, i)
'DoEvents
Else
block2 = vbNullString '' "Error " & chr(34) & "missing }" & chr(34)
End If



End Function
Function blockString(s$, endstr As Long, Optional i As Long = 1) As String
' endstr 34 or 125
Dim j As Long, c As Long, Start As Long
Start = i
Dim a1 As Boolean
c = Len(s$)
If i > c Then Exit Function
If c < 1 Then Exit Function
a1 = True
Do
Select Case AscW(Mid$(s$, i, 1))
Case 13
If endstr = 34 Then blockString = vbNullString: Exit Function
Case 34
If endstr = 34 Then
If i = 1 Then i = 2
j = 1: Exit Do
End If
Case 123
j = j - 1
Case 125
j = j + 1: If j = 1 And endstr = 125 Then Exit Do
End Select
i = i + 1
Loop Until i > c
If j = 1 Then
blockString = Mid$(s$, Start, i - Start)
s$ = Mid$(s$, i)
Else
s$ = Mid$(s$, i)
blockString = "Error " & Chr(34) & "missing " + Chr$(endstr) & Chr(34)
End If
If endstr = 125 Then
If Right$(blockString, 1) = " " Then
i = Len(blockString) - MyTrimRStr(blockString)
If i > 0 Then blockString = Replace$(blockString, Chr$(10) + space(i), Chr$(10))
ElseIf MyTrimRStr(Right$(blockString, 1)) = 1 Then
i = Len(blockString) - MyTrimRNoCr(blockString)
If i > 0 Then blockString = Replace$(blockString, Chr$(10) + Right$(blockString, i), Chr$(10))

End If
End If

End Function
Public Function MyTrimRStr(s$) As Long
Dim i&, l As Long
Dim p2 As Long, p1 As Integer, p4 As Long
  l = Len(s): If l = 0 Then MyTrimRStr = 1: Exit Function
  p2 = StrPtr(s): l = l - 1
  p4 = p2 + l * 2
  For i = p4 To p2 Step -2
  GetMem2 i, p1
  Select Case p1
    Case 32
    Case Else
     MyTrimRStr = (i - p2) \ 2 + 1
   Exit Function
  End Select
  Next i
 MyTrimRStr = l + 2
End Function
Public Function MyTrimRNoCr(s$) As Long
Dim i&, l As Long
Dim p2 As Long, p1 As Integer, p4 As Long
  l = Len(s): If l = 0 Then MyTrimRNoCr = 1: Exit Function
  p2 = StrPtr(s): l = l - 1
  p4 = p2 + l * 2
  For i = p4 To p2 Step -2
  GetMem2 i, p1
  Select Case p1
    Case 32, 160, 9
    Case Else
     MyTrimRNoCr = (i - p2) \ 2 + 1
   Exit Function
  End Select
  Next i
 MyTrimRNoCr = l + 2
End Function
Sub SetNextLine(c$)
Dim i
i = InStr(c$, vbCrLf)
If i = 0 Then c$ = vbNullString Else c$ = Mid$(c$, i + 2)
End Sub
Function SetNextLineCLR(c$) As Long
SetNextLineCLR = InStr(c$, vbCrLf)
If SetNextLineCLR > 0 Then Mid$(c$, 1, SetNextLineCLR + 1) = space(SetNextLineCLR + 1): SetNextLineCLR = SetNextLineCLR + 1
End Function
Function CopyUntilEndOfLine(a$) As String
Dim i As Long
i = InStr(a$, vbCrLf)
If i = 0 Then CopyUntilEndOfLine = a$ Else CopyUntilEndOfLine = Left$(a$, i - 1)
End Function
Sub SetNextLineNL(c$)
Dim i
i = InStr(c$, vbCrLf)
If i = 0 Then c$ = vbNullString Else c$ = Mid$(c$, i)
End Sub
Function GetNextLine(c$) As String
Dim i, j$
i = InStr(c$, vbCrLf)
If i = 0 Then GetNextLine = NLtrim$(c$): c$ = vbNullString Else GetNextLine$ = NLtrim$(Left$(c$, i - 1)): c$ = Mid$(c$, i)
End Function
Sub NoLines(c$)
Dim i
c$ = Trim$(c$)
Do While Left$(c$, 2) = vbCrLf
c$ = Trim$(Mid$(c$, 3))
Loop
End Sub

Sub RTarget(DDD As Object, tar As target)
' RENDER TARGET
Dim xl&, yl&, B As Long, f As Long, Tag$, id&
Dim X&, Y&, ox&, oy&
Dim prive As basket, D As Object
Dim c2&, v1&, v2&, vert&, mem As MemBlock
Dim zoom As Single
Set D = DDD.Owner
prive = players(GetCode(D))
With tar
id& = .id
Tag$ = .Tag
X& = .lX
Y& = .lY
xl& = .tx + 1
yl& = .ty
B = .back
f = .fore
c2& = .barC
v1& = .topval
v2& = .botval
vert& = .Vertical
prive.mypen = .pen
zoom = .imagesize / 100
Dim half As Long
half = 1 - (.ty - .lY + 1) Mod 2
Dim dd As Object
If .layer = 0 Then
Set dd = Form1.DIS
ElseIf .layer = -1 Then
Set dd = Form1
ElseIf .layer > 0 And .layer < 33 Then
Set dd = Form1.dSprite(.layer)
Else
Set dd = D
End If

prive.Xt = .Xt
prive.Yt = .Yt
prive.uMineLineSpace = .sUAddTwipsTop
prive.mx = 100
prive.my = 100
prive.SZ = .SZ
Set mem = .drawimage
End With
dd.FontSize = prive.SZ
LCTbasket dd, prive, Y&, X&

If f <> &H81000000 Then BoxBigNew dd, prive, xl& - 1, yl&, f
If B <> &H81000000 Then BoxColorNew dd, prive, xl& - 1, yl&, B
If Not mem Is Nothing Then
If mem.SubType > 0 Then
Dim upleft As Long, Up As Long, downright As Long, down As Long
Dim fx&, fy&

If zoom < 0 Then
        If c2& <> &H81000000 Then
            If vert& = 0 Then
                BoxColorNewBarHor D, prive, xl& - 1, yl&, c2&, v2&, v1&
            Else
                BoxColorNewBarVer D, prive, xl& - 1, yl&, c2&, v2&, v1&
            End If
        End If
        c2& = &H81000000
        zoom = -zoom
End If
upleft = (prive.curpos * prive.Xt) \ dv15
downright = (xl& * prive.Xt) \ dv15
Up = (prive.currow * prive.Yt) \ dv15
down = ((yl& + 1) * prive.Yt) \ dv15

fx& = (xl& - prive.curpos) * prive.Xt \ dv15
fy& = (yl& - prive.currow + 1) * prive.Yt \ dv15

   If zoom = 0 Then
    ' expand to target width
    mem.DrawImageToHdc dd, upleft, Up, fx&, fy&
    Else

Select Case id Mod 10
Case 4, 1, 7
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, down - fx& * zoom, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, downright - fy& * zoom - (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 6, 3, 9
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, Up + (fx& - fx& * zoom) \ 2, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 8
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, Up + prive.uMineLineSpace \ dv15, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fx& - fy&) \ 2 + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 5
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, Up + (fy& - fx&) \ 2 + (fx& - fx& * zoom) \ 2, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fx& - fy&) \ 2 + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
Case 2
If fx& < fy& Then
 mem.DrawImageToHdc dd, upleft + (fx& - fx& * zoom) \ 2, down - fx& * zoom - prive.uMineLineSpace \ dv15, fx& * zoom, fx& * zoom
Else
 mem.DrawImageToHdc dd, upleft + (fx& - fy&) \ 2 + (fy& - fy& * zoom) \ 2, Up + (fy& - fy& * zoom) \ 2, fy& * zoom, fy& * zoom
 End If
End Select
End If
End If
End If
If c2& <> &H81000000 Then
    If vert& = 0 Then
        BoxColorNewBarHor D, prive, xl& - 1, yl&, c2&, v2&, v1&
    Else
        BoxColorNewBarVer D, prive, xl& - 1, yl&, c2&, v2&, v1&
    End If
End If
If id& < 100 Then
    half = 0
    Tag$ = Left$(Tag$, xl& - X&)
    If Tag$ <> "" Then
    '1
    Select Case id& Mod 10
    Case 4, 5, 6
    Y& = (yl& + Y&) \ 2
    Case 7, 8, 9
    Y& = yl&
    Case Else
    End Select
    
    Select Case id& Mod 10
    Case 2, 5, 8
   
    X& = (xl& + X& - Len(Tag$)) \ 2
    Case 3, 6, 9
    X& = xl& - Len(Tag$)
    
    Case Else
    End Select
    If (id& Mod 10) > 0 Then
    LCTbasket dd, prive, Y&, X&
    dd.FontTransparent = True
    dd.forecolor = mycolor(prive.mypen)
       PlainBaSket dd, prive, Tag$, True, True
    End If
    End If
Else
        If Tag$ <> "" Then
    id& = id& Mod 100
    Select Case id& Mod 10
    Case 4, 5, 6
    Y& = (yl& + Y&) \ 2
    Case 7, 8, 9
    half = 0
    Y& = yl&
    Case Else
    half = 0
    End Select
    f = 3
    Select Case id& Mod 10
    Case 2, 5, 8
    f = 2
    Case 3, 6, 9
    f = 1
    Case Else
    End Select
    
    If (id& Mod 10) > 0 Then
    LCTbasket dd, prive, Y&, X&
    dd.FontTransparent = True
    dd.currentX = dd.currentX - dv15 * 2
    If half = 1 Then
    dd.currentY = dd.currentY + prive.Yt \ 2 '+ mybasket.uMineLineSpace \ 2
    End If
    dd.forecolor = mycolor(prive.mypen)
    
    If Not D Is dd Then
    Set DDD.Owner = dd
    wwPlain2 DDD, prive, Tag$, xl& - X&, 10000, , True, f, , , True
    Set DDD.Owner = D
    Else
    wwPlain2 DDD, prive, Tag$, xl& - X&, 10000, , True, f, , , True
    End If
    End If
End If
    

End If
PlaceBasket dd, players(GetCode(dd))
End Sub

Public Sub DropLeft(ByVal uStr As String, fromstr As String)
Dim i As Long
i = InStr(fromstr, uStr)
If i > 0 Then
fromstr = Mid$(fromstr, i + Len(uStr))
Else
fromstr = vbNullString
End If
End Sub
Public Function GetStrUntil(ByVal sStr As String, fromstr As String, Optional RemoveSstr As Boolean = True) As String
Dim i As Long

If fromstr = vbNullString Then GetStrUntil = vbNullString: Exit Function
i = InStr(fromstr, sStr)
If i < 2 Then
GetStrUntil = vbNullString
fromstr = vbNullString
Else
GetStrUntil = Left$(fromstr, i - 1)
If RemoveSstr Then
fromstr = Mid$(fromstr, Len(sStr) + i)
Else
fromstr = Mid$(fromstr, i)
End If
End If
End Function

Function NeoGetArrayItem(pp As mArray, bstack As basetask, v$, Offset As Long, rst$, Optional noObject As Boolean = False, Optional closepar As Boolean = True, Optional fromstr As Boolean, Optional rightexpr As Boolean = False, Optional idx As mIndexes) As Boolean
If pp Is Nothing Then
    MyEr "Internal Error: NeoGetArrayItem", "ЕСЫТЕЯИЙЭ КэХОР: NeoGetArrayItem": Exit Function
End If
If noObject And pp.IHaveClass Then Exit Function
Dim dn As Long, dd As Long, w3 As Long, sp$, lim As Long, usehandler As mHandler, usehandler1 As mHandler
Dim p As Variant
If Len(v$) > 0 Then sp$ = ")"
again123:
dd = 0
dn = 0
If Not pp.Arr Then
    Dim ppp$
    If TypeOf pp.GroupRef Is mHandler Then
        Set usehandler = pp.GroupRef
        If usehandler.t1 <> 1 Then Expected "Inventory", "йАТэСТАСГ": Exit Function
        If TypeOf usehandler.objref Is mHandler Then
            Set usehandler1 = usehandler.objref
            Set usehandler.objref = usehandler1.objref
        End If
            If IsExp(bstack, rst$, p) Then
                With usehandler.objref
                    If Not FastSymbol(rst$, "!") Then ppp$ = CStr(p): GoTo contlabel1
                    p = MyRound(p)
                    If Abs(p) < .count Then
                        If p < 0 Then
                            .index = .count + Int(p)
                        Else
                            .index = Int(p)
                        End If
                        .index = p
                        Offset = -.index - 100
                        .Done = True
                    Else
                        MyEr "Index out of limits", "дЕъЙТГР ЕЙТЭР ОЯъЫМ"
                    End If
                End With
            ElseIf IsStrExp(bstack, rst$, ppp$) Then
contlabel1:
                Set usehandler = pp.GroupRef
                With usehandler.objref
                    If Not .Find(ppp$) Then
                        MyEr "Key not exist", "дЕМ УПАЯВЕИ ТО ЙКЕИДъ"
                        NeoGetArrayItem = False
                        Exit Function
                    Else
                        Offset = -.index - 100
                        
                    End If
                    If Typename(.ValueObj) = mgroup Then
                        If .ValueObj.HasParametersSet Or .ValueObj.HasParameters Then
                            NeoGetArrayItem = True
                        End If
                    ElseIf FastSymbol(rst, ")(", , 2) Then
                        GoTo CheckThis
                    Else
                    .Done = True
                    End If
                End With
            End If
        ElseIf TypeOf pp.GroupRef Is Group Then
            If Not fromstr Then
            If rightexpr Then
            ElseIf pp.GroupRef.HasParameters Then
                    If Not pp.GroupRef.HasStrValue Then
                        If Len(rst$) > 0 Then
                            bstack.tmpstr = v$ + Left$(rst$, 1)
                            ppp$ = Left$(rst$, 1)
                            BackPort rst$
                            If IsNumber(bstack, rst$, p) Then
                                If Not bstack.lastpointer Is Nothing Then
                                    If bstack.lastpointer.IamApointer Then
                                        Set pp.GroupRef = bstack.lastpointer
                                    Else
                                        Set pp.GroupRef = bstack.lastobj
                                    End If
                                ElseIf Not bstack.lastobj Is Nothing Then
                                    If TypeOf pp.GroupRef Is Group Then
                                        Set pp.GroupRef = bstack.lastobj
                                    End If
                                End If
                                Set bstack.lastobj = Nothing
                                Set bstack.lastpointer = Nothing
                            Else
                                If Len(rst$) > 0 Then Mid$(rst$, 1, 1) = ppp$
                            End If
                        End If
                    End If
                End If
            End If
            Offset = -2
            NeoGetArrayItem = True
            Exit Function
        Else
contprop:
            Dim aProp As PropReference
            Set aProp = pp.GroupRef
            dn = 0

            If idx Is Nothing Then Set idx = New mIndexes
againprop:
            If IsExp(bstack, rst$, p) Then
                idx(dn) = p
                aProp.index = p
            ElseIf IsStrExp(bstack, rst$, ppp$) Then
                idx(dn) = ppp$
                aProp.index = ppp$
            Else
                idx.IndexOpt dn
                aProp.IndexOpt
            End If
            If FastSymbol(rst$, ",") Then dn = dn + 1: GoTo againprop
            Set aProp = Nothing
        End If
conthere:
        If closepar Then If Not FastSymbol(rst$, ")") Then MyEr "missing )", "КЕъПЕИ )": Exit Function
        NeoGetArrayItem = True
    ElseIf pp.SerialItem((0), dd, 5) Then
        dd = dd - 1
        Offset = 0
        If dd < 0 Then If Typename(pp.GroupRef) = mProp Then GoTo contprop
        Do While dn <= dd
            pp.GetDnum dn, w3, lim
            If IsExp(bstack, rst$, p, , True) Then
                If dn < dd Then
                    If Not FastSymbol(rst$, ",") Then MyEr "need index for " & v$ & sp$, "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " & v$ & sp$: Exit Function
                Else
                    If FastSymbol(rst$, ",") Then MyEr "too many indexes for array " & v$ & sp$, "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " & v$ & sp$: Exit Function
                    If Not FastSymbol(rst$, ")") Then MyEr "missing )", "КЕъПЕИ )": Exit Function
                End If
                On Error Resume Next
                If p < -lim Then
                    MyEr "index too low for array " & v$ & sp$, "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " & v$ & sp$: Exit Function
                End If
                If pp.PushOffset(Offset, dn, CLng(p)) Then
                    NeoGetArrayItem = True
                Else
                    MyEr "index too high for array " & v$ & sp$, "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " & v$ & sp$: Exit Function
                End If
            Else
                If Not LastErNum = -2 Then
                    MyEr "missing index for array " & v$ & sp$, "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " & v$ & sp$
                End If
                Exit Function
            End If
            dn = dn + 1
        Loop
    End If
    If lookOne(rst, "(") Then
CheckThis:
        ppp$ = Typename(pp.item(Offset))
        If ppp$ = myArray Then
            FastSymbol rst$, "("
            Set pp = pp.item(Offset)
            NeoGetArrayItem = False
            GoTo again123
        ElseIf ppp$ = mHdlr Then
            FastSymbol rst$, "("
            Set usehandler = pp.item(Offset)
            If usehandler.t1 = 3 Then
                If Typename(usehandler.objref) = myArray Then
                    Set pp = usehandler.objref
                Else
                    Exit Function
                End If
                Set usehandler = Nothing
            Else
                Set pp = New mArray
                pp.Arr = False
                Set pp.GroupRef = usehandler
            End If
            p = vbEmpty
            NeoGetArrayItem = pp.Arr
            GoTo again123
        ElseIf Typename(pp.item(Offset)) = mgroup Then
            NeoGetArrayItem = True
        End If
End If
End Function



Public Sub TaskMasterTick()
' This is the TimerFunction that will be
' called when SetTimer times out.
Static once As Boolean
If once Then Exit Sub
  If Not TaskMaster Is Nothing Then

    If Abs(MasterTimer - uintnew(CCur(timeGetTime))) > 50 Then
        If Not extreme Then once = True: DoEvents: once = False
        MasterTimer = uintnew(CCur(timeGetTime))
    End If
   ' Form1.Caption = MasterTimer
    TaskMaster.TimerTick
  End If

End Sub

Public Function VALIDATEmStiva(bs As basetask, p$, s$) As Boolean
Dim st As mStiva, ss$, j As Long, anything As Object, usehandler As mHandler

Set st = bs.soros
Dim i As Long, R$
If p$ <> "" Then
    ''s$ = VbNullString
    If st.Total < Len(p$) Then Exit Function
    Do While i < Len(p$)
    i = i + 1
    j = AscW(st.StackItemType(i))
If j <> 62 Then
    Select Case AscW(Mid$(p$, i, 1))
    Case 62
    ' OPTIONAL IS OK ??

    Case 66, 98, 916, 948
        If j <> 42 Then Exit Function
        If Typename$(st.StackItem(i)) = mHdlr Then
            If st.StackItem(i).t1 <> 2 Then Exit Function
        Else
            Exit Function
        End If
    
    Case 73, 105, 922, 954
        If j <> 42 Then Exit Function
        If Typename$(st.StackItem(i)) = mHdlr Then
            Set usehandler = st.StackItem(i)
            If usehandler.t1 = 3 Then
                Set anything = usehandler.objref
                If CheckDeepAny(anything) Then
                    If Typename$(anything) = "FastCollection" Then
                        If anything.StructLen <> 0 Then Exit Function
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
            ElseIf usehandler.t1 <> 1 Then
                Exit Function
            End If
        Else
            Exit Function
        End If
        Set usehandler = Nothing
    Case 67, 99, 931, 963
        If j <> 42 Then Exit Function
        If Typename$(st.StackItem(i)) = mHdlr Then
            Set usehandler = st.StackItem(i)
            If usehandler.t1 = 3 Then
                Set anything = usehandler.objref
                If CheckDeepAny(anything) Then
                    If Typename$(anything) = "mStiva" Then
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
            Else
                Exit Function
            End If
        Else
            Exit Function
        End If
        Set usehandler = Nothing
    Case 925, 957, 913, 945, 78, 110 '' number  - use spellunicode to make it
        If j = 42 Then
            If Typename(st.StackItem(i)) = mHdlr Then
                Set usehandler = st.StackItem(i)
                If usehandler.t1 <> 4 Then Exit Function
                Set usehandler = Nothing
            Else
                Exit Function
            End If
        ElseIf j <> 78 Then
            Exit Function
        End If
    Case 923, 955, 70, 102  ' change from L l to F f form lambda
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(i)), 1))
        If j <> 108 Then Exit Function
    Case 915, 947, 83, 115 '' string
        If j <> 83 Then Exit Function
    Case 928, 960, 65, 97  '' array
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(i)), 2))
        If j <> 65 Then
            If Typename$(st.StackItem(i)) = mHdlr Then
                Set usehandler = st.StackItem(i)
                If usehandler.t1 = 3 Then
                    Set anything = usehandler.objref
                    If CheckDeepAny(anything) Then
                        If Typename$(anything) = myArray Then
                        Else
                            Exit Function
                        End If
                    Else
                        Exit Function
                    End If
                Else
                    Exit Function
                End If
                Set usehandler = Nothing
            Else
                Exit Function
            End If
        End If
    Case 917, 69
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(i)), 2))
        If j <> 69 Then Exit Function
    Case 927, 959, 954, 71, 103, 67, 99
        If j = 42 Then j = AscW(Mid$(Typename(st.StackItem(i)), 1))
         If j <> 71 Then Exit Function
    Case 76, 924
    If j <> 76 Then Exit Function
    Case Else
        Exit Function
    End Select
    End If
    
    Loop
    s$ = " "
    VALIDATEmStiva = True
    Exit Function
Else
    Do
    i = i + 1
    If st.Total < i Then Exit Do
        ss$ = st.StackItemType(i)
        If ss$ = "*" Then
        
            ss$ = Left$(Typename(st.StackItem(i)), 2)
checkagain:
            If ss$ = "mA" Then ss$ = "A"
            If ss$ = "mE" Then ss$ = "E"
            If ss$ = "Gr" Then ss$ = "G"
            If ss$ = "la" Then ss$ = "F"
            If ss$ = "mS" Then ss$ = "C"
            If ss$ = "mH" Then
                Set usehandler = st.StackItem(i)
ch2:
                Select Case usehandler.t1
                Case 1
                ss$ = "I"
                Case 2
                ss$ = "B"
                Case 3
                Set anything = usehandler.objref
                If CheckDeepAny(anything) Then
                    ss$ = Left$(Typename(anything), 2)
                    If ss$ = "mH" Then Set usehandler = anything: GoTo ch2
                    Set usehandler = Nothing
                    GoTo checkagain
                End If
                Set usehandler = Nothing
                ss$ = "U"   ' "Undefined"
                Case 4
                ss$ = "N"
                Case Else
                ss$ = "U"   ' "Undefined"
                End Select
            End If
        End If
    R$ = R$ & Right$("?" + ss$, 1)
    Loop
    s$ = R$
End If
VALIDATEmStiva = R$ <> ""
End Function

Public Function VALIDATE(st$, p$, s$) As Boolean
Dim dummy As Double
Dim i As Long, j As Long, ok As Boolean
If Len(st$) = 0 Then
VALIDATE = True
End If
' NORMALIZE
s$ = vbNullString
ok = True
For i = 1 To Len(st$)
Select Case Mid$(st$, i, 1)
Case " ", ",", ChrW(160)

Case Is = Chr(34)
j = InStr(i + 1, st$, Chr(34), vbBinaryCompare)
If j = 0 Then Exit For
s$ = s$ & "S"
i = j + 1
            If p$ <> "" Then
                Select Case AscW(p$)
                Case 915, 947, 83, 115 '' string
                Case Else
                        ok = False: Exit For
                End Select
                    p$ = Mid$(p$, 2)
                    If p$ = vbNullString Then Exit For
             End If
 Case Is = Chr$(2)
            If Len(Mid$(st$, i + 1, 8)) = 8 Then
             i = i + CLng("&H" & Mid$(st$, i + 1, 8)) + 8
             s$ = s$ & "S"
             If p$ <> "" Then
                Select Case AscW(p$)
                Case 915, 947, 83, 115 '' string
                Case Else
                        ok = False: Exit For
                End Select
             p$ = Mid$(p$, 2)
             If p$ = vbNullString Then Exit For
             End If
             Else
             Exit For
             End If
Case Else
        If IsNumberD3(st$, i, j) Then
                If i = 0 Then i = j + 1
                i = i + j - 2
                s$ = s$ & "N"
                    If p$ <> "" Then
                Select Case AscW(p$)
                 Case 925, 957, 913, 945, 78, 110 '' number
                Case Else
                        ok = False: Exit For
                End Select
                         p$ = Mid$(p$, 2)
                         If p$ = vbNullString Then Exit For
                    End If
      Else
          Exit For
      End If
End Select
      

Next i
 ' TO P$ ха паяеи то упокоипо

   p$ = Mid$(st$, i + 1)
   st$ = Left$(st$, i)
    VALIDATE = ok
End Function

Public Function VALIDATEpart(st$, p$) As Boolean
Dim dummy As Double
Dim i As Long, j As Long, ok As Boolean, s$
If Len(st$) = 0 Then
VALIDATEpart = False   ' reverse logic here...
End If
' NORMALIZE
s$ = vbNullString
ok = True
For i = 1 To Len(st$)
If Mid$(st$, i, 1) = Chr$(2) Then
            If Len(Mid$(st$, i + 1, 8)) = 8 Then
             i = i + CLng("&H" & Mid$(st$, i + 1, 8)) + 8
             Else
             Exit For
             End If
      ElseIf IsNumberD3(st$, i, j) Then
      i = j + i - 2
      Else
      i = i - 1
      Exit For
      End If
      

Next i
p$ = Left$(st$, i)
    st$ = " " & Mid$(st$, i + 1)
    VALIDATEpart = p$ <> ""
End Function








Sub mywait(bstack As basetask, pp As Variant, Optional SLEEPSHORT As Boolean = False)
Dim p As Boolean, e As Boolean
On Error Resume Next
If bstack Is Nothing Then
If pp = 0 Then Exit Sub
End If
If bstack.Process Is Nothing Then
''If extreme Then MyDoEvents1 Form1

Else

Err.Clear
p = bstack.Process.Done
If Err.Number = 0 Then
e = True
If p <> 0 Then
Exit Sub
End If
End If
End If

pp = pp + CCur(timeGetTime)
If TaskMaster Is Nothing Then Set TaskMaster = New TaskMaster
Do


If TaskMaster.Processing And Not bstack.TaskMain Then
        If Not bstack.toprinter Then bstack.Owner.Refresh
        TaskMaster.TimerTick
       ' SleepWait 1

        MyDoEvents1 Form1

Else
        ' SleepWait 1

        MyDoEvents1 Form1

End If
If SLEEPSHORT Then Sleep 1
If e Then
p = bstack.Process.Done
If Err.Number = 0 Then
If p <> 0 Then
Exit Do
End If
End If
End If
Loop Until pp <= CCur(timeGetTime) Or NOEXECUTION

                       If exWnd <> 0 Then
                MyTitle$ bstack
                End If
End Sub
Sub ProcTask(bstack As basetask)
On Error GoTo procbliah
If TaskMaster.Processing Then
           TaskMaster.RestEnd1
 TaskMaster.TimerTick
ElseIf Not (bstack.IamChild Or bstack.IamAnEvent) Then
If REFRESHRATE > 25 Then k1 = 0
REFRESHRATE = 40
Sleep 1
ElseIf SLOW Or IsWine Then
Sleep 1
End If
TaskMaster.rest
If IsWine Then
DoEvents
Else
SleepWaitEdit bstack, 1
End If
TaskMaster.RestEnd
Exit Sub
procbliah:
 DoEvents
Sleep 1
End Sub
Sub ProcTask2(bstack As basetask)
On Error GoTo procbliah2
If bstack.IamThread And trace Then
    If SLOW Or IsWine Then Sleep 1
TaskMaster.rest
If IsWine Then
DoEvents
Else
SleepWaitEdit2 1
End If
TaskMaster.RestEnd
Exit Sub

ElseIf TaskMaster Is Nothing Then
If SLOW Or IsWine Then
Sleep 1
End If
DoEvents
Else
If TaskMaster.Processing Then
          TaskMaster.RestEnd1
 TaskMaster.TimerTickNow

ElseIf SLOW Or IsWine Then
Sleep 1
End If
TaskMaster.rest
If IsWine Then
DoEvents
Else
SleepWaitEdit2 1
End If
TaskMaster.RestEnd
End If
Exit Sub
procbliah2:
DoEvents
Sleep 1
End Sub

Sub ResetBreak()
Do While KeyPressedLong(&H13) <> 0
    MyDoEvents
Loop
End Sub
Private Sub MyDoEvents()
On Error GoTo there
If TaskMaster Is Nothing Then
    DoEvents
    Exit Sub
ElseIf Not TaskMaster.Processing And TaskMaster.QueueCount = 0 Then
    DoEvents
    Exit Sub
Else
    If TaskMaster.PlayMusic Then
        TaskMaster.OnlyMusic = True
        TaskMaster.TimerTick
        TaskMaster.OnlyMusic = False
    End If
    TaskMaster.StopProcess
    TaskMaster.TimerTick
    DoEvents
    TaskMaster.StartProcess
End If
Exit Sub
there:
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd1
End Sub
Function myexit(bstack As basetask) As Boolean
On Error Resume Next
If Not extreme Then

            If escok Then
                        If KeyPressed(&H1B) Then
                        If Modalid <> 0 Then
                         Modalid = 0
                         ShutEnabledGuiM2000
                         MyDoEvents
                           While KeyPressed(&H1B)
                                            MyDoEvents
                                    Wend
                        Else
                         NOEXECUTION = True
                           ShutEnabledGuiM2000 True
                         MyDoEvents
                                    If AVIRUN Then AVI.GETLOST
                                    NOEXECUTION = True
                                    While KeyPressed(&H1B)
                                            MyDoEvents
                                    Wend
                                    myexit = True
                                    Exit Function
                        End If
                        ElseIf NOEXECUTION Then
                          ShutEnabledGuiM2000 True
                         MyDoEvents
                        End If
             End If
End If
If bstack Is Nothing Then myexit = True: Exit Function
If TaskMaster Is Nothing Then Exit Function
If TaskMaster.OnlyMusic Then TaskMaster.TimerTick
If bstack.IamThread Then myexit = bstack.Process.Done Else myexit = False
End Function

Sub closeAll()
Dim i As Long
CloseAllHandlers
CloseAllConnections
End Sub
Function MakeitObjectGeneric(Number As Long) As Object
Dim aa As New mHandler, k As Long
aa.t1 = 3
On Error GoTo there
If Not MyIsObject(var(Number)) Then
Set var(Number) = aa
aa.t1 = 0
Else
If var(Number) Is Nothing Then
Number = -1

Else
Do While TypeOf var(Number) Is mHandler
If var(Number).indirect < 0 Then Exit Do
If k > 20 Then MyEr "too many references", "ПОККщР АМАЖОЯщР": Exit Do
Number = var(Number).indirect
k = k + 1
Loop
End If
there:
aa.indirect = Number
End If
Set aa.objref = Nothing
Set MakeitObjectGeneric = aa

End Function

Sub PlaceIteratorData(bstack As basetask, anything As Variant, st, en)
Dim usehandler As mHandler, usehandler1 As mHandler
Set usehandler = bstack.lastobj
If MyIsObject(anything) Then
Set usehandler1 = anything
Set usehandler.objref = usehandler1.objref
End If
With usehandler.objref
    If st < 0 Then st = .count + st Else st = st - 1
    If en < 0 Then en = .count + en Else en = en - 1
    If st < 0 Then st = 0: en = -2 '0
    If en < 0 Then en = -1 '0
    If st >= .count Then en = -1: st = .count - 1
    If en >= .count Then en = -1 ' .count - 1
    
End With
With usehandler
    .t1 = 3
     .indirect = -1
    .index_start = st
    .index_End = en
    .index_cursor = st
    .UseIterator = True
End With
If MyIsObject(anything) Then
    If TypeOf usehandler.objref Is FastCollection Then
        usehandler.t1 = 1
        Set usehandler.objref = anything
    ElseIf TypeOf usehandler.objref Is Enumeration Then
        Set usehandler.objref = New mHandler
        Set usehandler = usehandler.objref
        Set usehandler1 = anything
        Set usehandler.objref = usehandler1.objref
        usehandler.t1 = 4
        usehandler.index_cursor = st
    End If
End If

End Sub
Sub MakeitObjectInventory(var As Variant, Optional Queue As Boolean)
Dim aa As New mHandler
aa.t1 = 1 ' 1 for Inventory
Set aa.objref = New FastCollection
If Queue Then aa.objref.AllowAnyKey
Set var = aa
End Sub
Sub MakeitObjectBuffer(var As Variant)
Dim aa As New mHandler
aa.t1 = 2 ' 2 for Buffer
Set aa.objref = New MemBlock
Set var = aa
End Sub
Sub MakeitObjectLong(var As Variant)
Dim aa As Long
var = aa
End Sub
Sub MakeitObjectEvent(var As Variant)
Dim aa As New mEvent
Set var = aa
End Sub
Sub MakeitObject(var As Variant)
Dim aa As New Document
Set var = aa
var.textDoc = vbNullString
End Sub
Sub MakeitPropReference(var As Variant)
Dim aa As New PropReference
Set var = aa
End Sub
Sub CreateFormObject(var As Variant, id As Long)
Dim aa As Object
Select Case id
'Case 0
'Set aa = New Server  ' next time...
Case 1
Set aa = New GuiM2000

Case 2  '
Set aa = New GuiButton
Case 3
Set aa = New GuiTextBox
Case 4
Set aa = New GuiCheckBox
Case 5
Set aa = New GuiEditBox
Case 6
Set aa = New GuiListBox
Case 7
Set aa = New GuiDropDown
Case 8
Set aa = New GuiImage
End Select
Set var = aa
End Sub
Sub CreateFormOtherObject(var As Variant, THISOBJECT As Object)
Set var = THISOBJECT
End Sub

Sub CreateitObject(var As Variant, THISOBJECT As String, Optional ByVal cc As Variant)
Dim aa As Object
Dim nVal As String
If IsMissing(cc) Then
If Left$(THISOBJECT, 1) = "{" Then
    nVal = strProgIDfromSrting(THISOBJECT)
    If Len(nVal) > 0 Then THISOBJECT = nVal
End If
On Error Resume Next
Set aa = CreateObject(THISOBJECT)
If Err Then
MyEr Err.Description, Err.Description
End If

Else
Set aa = CreateObject(THISOBJECT, CStr(cc))
End If
Set var = aa
End Sub

Function CheckVarGroup(basestack As basetask, var As Variant, s As String, Optional Final As Boolean = False) As Long
Dim D As Document, c As Constant
                
If Typename(var) = doc Then
Set D = var
D.FasttextDoc = s

ElseIf Typename(var) = "lambda" Then
If Not basestack.lastobj Is Nothing Then
If TypeOf basestack.lastobj Is lambda Then
    Set var = basestack.lastobj
End If
End If
ElseIf Not basestack.lastobj Is Nothing Then
If TypeOf basestack.lastobj Is lambda Then
    Set var = basestack.lastobj
    Set basestack.lastobj = Nothing
    CheckVarGroup = 1
    ' means make function for lambda for group
End If
Else
MoveStringToVariant s, var
End If

If Final Then
    Set c = New Constant
    c.DefineOnce var
    Set var = c
End If
Set basestack.lastobj = Nothing
End Function
Sub CheckVar(var As Variant, s As String, Optional Append As Boolean)
If Typename(var) = doc Then
If var.IsEmpty Then
var.FasttextDoc = s
Else
Dim kk As Document
Set kk = var
kk.InsertDoc kk.LastParagraph, kk.TextParagraphLen(kk.LastParagraph) + 1, s
End If
ElseIf Append Then
If LenB(var) = 0 Then
MoveStringToVariant s, var
Else
var = var + s
End If
Else
MoveStringToVariant s, var
End If
End Sub
Function CheckVarOnlyNo(var As Variant, s As String) As Boolean
If Typename(var) = doc Then
If var.IsEmpty Then
var.textDoc = s
Else
var.InsertDoc var.LastParagraph, var.TextParagraphLen(var.LastParagraph) + 1, s
End If
ElseIf MyIsObject(var) Then
CheckVarOnlyNo = True
Else
MoveStringToVariant s, var
End If
End Function
Sub CheckVarLong(var As Variant, l As Long)

If MyIsObject(var) Then

Set var = Nothing
var = Empty
End If
var = l

End Sub




Sub MakeitObject2(var As Variant)
Dim aa As Object
Set aa = New Group
Set var = aa
End Sub
Sub prepareGroup(bstack As basetask, ByVal ohere$, vvv As Long, Optional glob As Boolean = False, Optional isAstr As Boolean = False, Optional alocal As Boolean = False)
Dim hv As Boolean
If Not glob Then
If alocal Then
Else
If here$ = vbNullString Then
    hv = GetVar(bstack, bstack.GroupName & ohere$, vvv, True)
Else
    hv = GetlocalVar(bstack.GroupName & ohere$, vvv)
 End If
End If
 End If
If hv Then
    If Not MyIsObject(var(vvv)) Then
        MakeitObject2 var(vvv)
    ElseIf Typename(var(vvv)) <> mgroup Then
        MakeitObject2 var(vvv)
        GoTo conthere
    ElseIf var(vvv).IamApointer Then
     PushStage bstack, False
     Dim myobject As Object
     Set myobject = var(vvv)
     UnFloatGroup bstack, ohere$, vvv, myobject, var(vvv).IamGlobal
     Set myobject = Nothing
     
    End If
Else
    vvv = GlobalVarRefOnly(bstack.GroupName & ohere$, glob)
    MakeitObject2 var(vvv)
conthere:
    If isAstr Then
    GlobalVarRefLink bstack.GroupName & ohere$ + "$", vvv, glob
    End If
 'If Not glob Then
 var(vvv).GroupName = ohere$ + "."
 var(vvv).HasStrValue = isAstr
End If
var(vvv).edittag = vbNullString
End Sub

Function ExecuteGroupStruct(bstack As basetask, ohere$, vvv As Long, rest$, ByVal addlen As Long, Lang As Long, Optional glob As Boolean = False, Optional alocal As Boolean = False) As Long
Dim w$, w1$, p As Variant, v As Long, s$, ss$, B$, i As Long, lcl As Boolean, j As Long, nm$, x1 As Long, y1 As Long, frm$, skip As Boolean
Dim uni As Boolean, prv As Boolean, stripstack1 As New basetask, hlp As String, vl As String, NoRec As Boolean, Final As Boolean
Dim highpriority As Boolean, ThisGroup As Group, RightAssociative As Boolean, removebypass As Boolean, c As Constant
Dim usehandler As mHandler, usehandler2 As mHandler, it As Long, classfun As Boolean

Const TT$ = "=-+*/<!,{" + vbCr
If Trim$(rest$) = vbNullString Then
If Typename$(var(vvv)) = mgroup Then
Else
    var(vvv) = CLng(0)
    End If
    ExecuteGroupStruct = 1
    Exit Function
End If
Set ThisGroup = var(vvv)
Dim myobject As Object
Dim OvarnameLen As Long, OarrnameLen As Long
Dim f$
Dim pppp As mArray
ThisGroup.IamCleared = False
bstack.CopyStrip stripstack1
OvarnameLen = varhash.count + 1 ' new way
If Len(here$) > 0 Then
 ThisGroup.Patch = here$ + "." + ohere$
Else
 ThisGroup.Patch = ohere$
End If
If bstack.GroupName <> "" Then
    bstack.GroupName = bstack.GroupName & ThisGroup.GroupName '' & "."
Else
    bstack.GroupName = ThisGroup.GroupName ''& "."
End If

ExecuteGroupStruct = 1
Do
there100:
    nm$ = vbNullString: frm$ = vbNullString: hlp$ = vbNullString
    ClearSpace rest$
there12345:
    If NocharsInLine(rest$) Then Exit Do
    v = IsLabelA(here$, rest$, w$)
    If v = 0 Then Exit Do
    Select Case w$
    Case "текийо", "текийг", "FINAL"
        i = v
        ss$ = w$
        v = IsLabelA(here$, rest$, w$)
        If prv Then
        w$ = ChrW(&HFFBF) + w$
        End If
        If v <> 0 Then Final = True: GoTo VarOnly
        v = i
        w$ = ss$
        i = 0
        GoTo VarOnly
    Case "PROPERTY", "идиотгта"
        i = IsLabelA("", rest$, w$)
        If i = 1 Or i = 3 Then
            If i = 1 Then
                hlp = "[" + w$ + "]"
                If Lang = 1 Then
                    vl = "value"
                Else
                    vl = "АНъА"
                End If
            Else
                hlp = "[" + Left$(w$, Len(w$) - 1) + "]$"
                If Lang = 1 Then
                    vl = "value$"
                Else
                    vl = "АНъА$"
                End If
            End If
            f$ = vbNullString
            If FastSymbol(rest$, "{") Then
                ClearSpace rest$
                nm$ = block(rest$)
                If IsLabelA1("", nm$, ss$) Then
                    ss$ = myUcase(ss$)
                    i = Len(nm$)
                    If FastSymbol(nm$, "(") Then
                        If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", i) Then
                            MyEr "Array with same name", "пъМАЙАР ЛЕ ъДИО ЭМОЛА"
                            ExecuteGroupStruct = 0
                            Exit Function
                        End If
                        frm$ = BlockParam(nm$)
                        If FastOperator(nm$, "{", Len(frm$) + 2) Then
                            nm$ = "{" + Mid$(nm$, Len(frm$) + 2)
                        Else
                            GoTo errDef
                        End If
                        If frm$ = vbNullString Then frm$ = " "
                    End If
                    Select Case ss$
                    Case "VALUE", "аниа"
                        If FastSymbol(nm$, "{") Then
                            If lookOne(nm$, "}") Then
                                f$ = f$ + ss$ + " (" + frm$ + "){link parent " + hlp + " to " + w$ + ": =" + w$ + "}" + vbCrLf
                            Else
                                f$ = f$ + ss$ + " (" + frm$ + ") {link parent " + hlp + " to " + w$ + ": " + vl + "=" + w$ + vbCrLf + block$(nm$) + vbCrLf + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "value {link parent " + hlp + " to " + w$ + ":=" + w$ + "}" + vbCrLf
                        End If
                    Case "SET", "хесе"
                        If FastSymbol(nm$, "{") Then
                            If frm$ <> "" Then
                                If frm$ = " " Then
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + w$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + w$ + "=" + vl + "}" + vbCrLf
                                Else
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + w$ + ": read " + vl + "," + frm$ + vbCrLf + block$(nm$) + vbCrLf + w$ + "=" + vl + "}" + vbCrLf
                                End If
                            Else
                                f$ = f$ + ss$ + " {link parent " + hlp + " to " + w$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + w$ + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "set {link parent " + hlp + " to " + w$ + ": read " + w$ + "}" + vbCrLf
                        End If
                    Case Else
                        rest$ = nm$ + Right$(rest$, i)
                        MyEr "unkown command, use set or value", "эЦМЫСТГ ЕМТОКч, ВЯГСИЛОПОъГСЕ ХщСЕ ч АНъА"
                        Exit Function
                    End Select
                    frm$ = vbNullString
                ElseIf IsSymbol(nm$, ",") Then
                    f$ = f$ + "value {link parent " + hlp + " to " + w$ + ":=" + w$ + "}" + vbCrLf
                End If
                ClearSpace nm$
                i = FastSymbol(nm$, ",")
                ClearSpace nm$
                If IsLabelA1("", nm$, ss$) Then
                    ss$ = myUcase(ss$)
                    i = Len(nm$)
                    If FastSymbol(nm$, "(") Then
                       If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", i) Then
                           MyEr "Array with same name", "пъМАЙАР ЛЕ ъДИО ЭМОЛА"
                           ExecuteGroupStruct = 0
                           Exit Function
                        End If
                        frm$ = BlockParam(nm$)
                        If FastOperator(nm$, "{", Len(frm$) + 2) Then
                            nm$ = "{" + Mid$(nm$, Len(frm$) + 2)
                        Else
                            GoTo errDef
                        End If
                        If frm$ = vbNullString Then frm$ = " "
                    End If
                    Select Case ss$
                    Case "VALUE", "аниа"
                        If FastSymbol(nm$, "{") Then
                            If lookOne(nm$, "}") Then
                                f$ = f$ + ss$ + " (" + frm$ + "){link parent " + hlp + " to " + w$ + ": =" + w$ + "}" + vbCrLf
                            Else
                                f$ = f$ + ss$ + " (" + frm$ + "){link parent " + hlp + " to " + w$ + ": " + vl + "=" + w$ + vbCrLf + block$(nm$) + vbCrLf + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "value {link parent " + hlp + " to " + w$ + ":=" + w$ + "}" + vbCrLf
                        End If
                    Case "SET", "хесе"
                        If FastSymbol(nm$, "{") Then
                            If frm$ <> "" Then
                                If frm$ = " " Then
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + w$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + w$ + "=" + vl + "}" + vbCrLf
                                Else
                                    f$ = f$ + ss$ + " () {link parent " + hlp + " to " + w$ + ": read " + vl + "," + frm$ + vbCrLf + block$(nm$) + vbCrLf + w$ + "=" + vl + "}" + vbCrLf
                                End If
                            Else
                                f$ = f$ + ss$ + " {link parent " + hlp + " to " + w$ + ": read " + vl + vbCrLf + block$(nm$) + vbCrLf + w$ + "=" + vl + "}" + vbCrLf
                            End If
                            FastSymbol nm$, "}"
                        Else
                            f$ = f$ + "set {link parent " + hlp + " to " + w$ + ": read " + w$ + "}" + vbCrLf
                        End If
                    Case Else
                        rest$ = nm$ + rest$
                        MyEr "unkown command, use set or value", "эЦМЫСТГ ЕМТОКч, ВЯГСИЛОПОъГСЕ ХщСЕ ч АНъА"
                        Exit Function
                    End Select
                    ClearSpace nm$
                    If IsLabelA1("", nm$, ss$) Then
                        rest$ = nm$ + Mid$(rest$, i)
                        MyEr "unkown command, use set or value", "эЦМЫСТГ ЕМТОКч, ВЯГСИЛОПОъГСЕ ХщСЕ ч АНъА"
                        Exit Function
                    End If
                ElseIf i Then
                    f$ = f$ + "set {link parent " + hlp + " to " + w$ + ": read " + w$ + "}" + vbCrLf
                End If
                FastSymbol rest$, "}"
                If FastSymbol(rest$, "=") Then
                    x1 = 1
                    aheadstatus rest$, , x1
                    frm$ = Mid$(rest$, 1, x1 - 1)
                    rest$ = Mid$(rest$, x1)
                    If frm$ = vbNullString Then MyEr "Nothing to assign", "тъПОТА ЦИА МА хщСЫ": Exit Function
                    If prv Then
                        f$ = vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    End If
                Else
                    If prv Then
                        f$ = vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    End If
                End If
                If prv Then
                    rest$ = f$ + "}" + "private:" + vbCrLf + rest$
                Else
                    rest$ = f$ + "}" + vbCrLf + rest$
                End If
            Else
                If FastSymbol(rest$, "=") Then
                    x1 = 1
                    aheadstatus rest$, , x1
                    frm$ = Mid$(rest$, 1, x1 - 1)
                    rest$ = Mid$(rest$, x1)
                    If frm$ = vbNullString Then MyEr "Nothing to assign", "тъПОТА ЦИА МА хщСЫ": Exit Function
                    If prv Then
                        f$ = vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + "=" + frm$ + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    End If
                Else
                    If prv Then
                        f$ = vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    Else
                        f$ = vbCrLf + "private:" + vbCrLf + hlp + vbCrLf + "public:" + vbCrLf + "group " + w$ + "{" + vbCrLf + f$
                    End If
                End If
                f$ = f$ + "value {link parent " + hlp + " to " + w$ + ":=" + w$ + "}" + vbCrLf
                f$ = f$ + "set {link parent " + hlp + " to " + w$ + ": read " + w$ + "}" + vbCrLf
                If prv Then
                    rest$ = f$ + vbCrLf + "}" + vbCrLf + "private:" + vbCrLf + rest$
                Else
                    rest$ = f$ + vbCrLf + "}" + vbCrLf + rest$
                End If
            End If
            hlp = vbNullString
            GoTo there100
        Else
            MyEr "No name for property", "вЫЯъР ЭМОЛА ИДИЭТГТАР"
            ExecuteGroupStruct = 0
            Exit Function
        End If
    Case "DECLARE", "ояисе"  'OBJECT
        bstack.priveflag = prv
        bstack.uniflag = uni
        bstack.finalFlag = Final
        If Not MyDeclare(bstack, rest$, Lang, True) Then   ' stripstack1
            bstack.priveflag = False
            bstack.uniflag = False
            bstack.finalFlag = False
            ExecuteGroupStruct = 0
            Exit Function
        End If
            stripstack1.priveflag = False
            stripstack1.uniflag = False
            stripstack1.finalFlag = False
         '   LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, False 'uni
    Case "SET", "хесе"
        Final = IsLabelSymbolNew(rest$, "текийо", "FINAL", Lang)
        If FastSymbol(rest$, "(") Then
            If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", i) Then
                MyEr "Array with same name", "пъМАЙАР ЛЕ ъДИО ЭМОЛА"
                ExecuteGroupStruct = 0
                Exit Function
            End If
            ss$ = BlockParam(rest$)
            ThisGroup.HasParametersSet = True
            If FastOperator(rest$, "{", Len(ss$) + 2) Then
                If ss$ <> "" Then
                    rest$ = "{Read " + ss$ + ":If Stack.Size>1 then Shift Stack.Size" + vbCrLf + Mid$(rest$, Len(ss$) + 2)
                Else
                    rest$ = "{If Stack.Size>1 then Shift Stack.Size " + vbCrLf + Mid$(rest$, 2)
                End If
            Else
                GoTo errDef
            End If
        End If
        f$ = ChrW(&H1FFF) + ":="
        x1 = 1
        ThisGroup.HasSet = True
        w$ = "&"
        GoTo funcoperator
    Case "VALUE", "аниа"
        Final = IsLabelSymbolNew(rest$, "текийг", "FINAL", Lang)
        If Final Then
            If FastSymbol(rest$, "(") Then GoTo contthere1
            GoTo contthere22
        End If
        If lookOne(rest$, "=") Then
            GoTo conthereplease
        ElseIf FastSymbol(rest$, "(") Then
contthere1:
            If varhash.Find(here$ + "." + Left$(ThisGroup.GroupName, Len(ThisGroup.GroupName) - 1) + "(", i) Then
                MyEr "Array with same name", "пъМАЙАР ЛЕ ъДИО ЭМОЛА"
                ExecuteGroupStruct = 0
                Exit Function
            End If
            ss$ = BlockParam(rest$)
            ThisGroup.HasParameters = True
            If FastOperator(rest$, "{", Len(ss$) + 2) Then
                If ss$ <> "" Then
                    rest$ = "{Read " + ss$ + vbCrLf + Mid$(rest$, Len(ss$) + 2)
                Else
                    Mid$(rest$, 1, 1) = "{"
                End If
            Else
errDef:
                MyEr "Missing Definition in { }", "кЕъПЕИ ОЯИСЛЭР СЕ { }"
                ExecuteGroupStruct = 0
                Exit Function
            End If
        End If
contthere22:
        If ThisGroup.HasStrValue Then
            f$ = ChrW(&H1FFF) + "$"
        Else
            f$ = ChrW(&H1FFF) + ChrW(&H1FFD)
        End If
        x1 = 1
        ThisGroup.HasValue = True
        w$ = "&"
        GoTo funcoperator
    Case "REMOVE", "диацяажг"
        x1 = 1
        w$ = vbNullString
        f$ = ChrW(&H1FFF) + "_%"
        Final = True
        removebypass = True
        highpriority = False
        ThisGroup.HasRemove = True
        GoTo funcoperator
    Case "OPERATOR", "текестгс"
        If prv Then
            MyEr "Private operator not allowed", "иДИЫТИЙЭР ТЕКЕСТчР ДЕМ ЕПИТЯщПЕТАИ"
            ExecuteGroupStruct = 0
            Exit Function
        End If
        Final = IsLabelSymbolNew(rest$, "текийос", "FINAL", Lang)
        x1 = 1
        If Not ISSTRINGA(rest$, f$) Then
            If IsLabelSymbolNew(rest$, "уьгкос", "HIGH", Lang) Then
                highpriority = True
                If Not ISSTRINGA(rest$, f$) Then GoTo error0001
                If Len(f$) > 2 Or Len(f$) = 0 Or Not MaybeIsSymbol(f$, "/*-+=~^&|<>") Then GoTo error0001
            ElseIf IsLabelSymbolNew(rest$, "дениос", "RIGHT", Lang) Then
                RightAssociative = True
                If Not ISSTRINGA(rest$, f$) Then GoTo error0001
                If Len(f$) > 2 Or Len(f$) = 0 Or Not MaybeIsSymbol(f$, "/*-+=~^&|<>") Then GoTo error0001
            ElseIf IsLabelSymbolNew(rest$, "ломадиаиос", "UNARY", Lang) Then
                f$ = "-:"
                ThisGroup.HasUnary = True
            ElseIf Not ISSTRINGA(rest$, f$) Then
error0001:
                MyEr "No Proper Symbol for operator, use string literal", "дЕМ БЯщХГЙЕ СЩЛБОКО ВЕИЯИСТч, ВЯГСИЛОПОъГСЕ АКЖАЯИХЛГТИЙЭ ЛЕ ДИПКэ ЕИСАЦЫЦИЙэ"
                ExecuteGroupStruct = 0
                Exit Function
            End If
        End If
        w$ = "&"
        If highpriority Then
            If InStr(ThisGroup.highpriorityoper, "[" + f$ + "]") = 0 Then ThisGroup.highpriorityoper = MergeOperators(ThisGroup.highpriorityoper, "[" + f$ + "]")
        ElseIf RightAssociative Then
            If InStr(ThisGroup.highpriorityoper, "[R" + f$ + "]") = 0 Then ThisGroup.highpriorityoper = MergeOperators(ThisGroup.highpriorityoper, "[R" + f$ + "]")
        End If
        f$ = ChrW(&H1FFF) + f$
        highpriority = False
        GoTo funcoperator
    Case "UNIQUE", "ломадийо"
        If Not IsOperator(rest$, ":") Then GoTo VarOnly
        prv = False
        uni = True
    GoTo there100
    Case "PRIVATE", "идиытийо"
        If Not IsOperator(rest$, ":") Then GoTo VarOnly
        uni = False
        prv = True
        GoTo there100
    Case "DEF", "йаме"
        MyEr "DEF can't be used in a CLASS", "г йэМЕ ДЕМ ЛПОЯЕъ МА ВЯГСИЛОПОИГХЕъ СЕ йКэСГ"
        ExecuteGroupStruct = 0
        Exit Function
    Case "PUBLIC", "дглосио"
        If Not IsOperator(rest$, ":") Then GoTo VarOnly
        NoRec = False
        uni = False
        prv = False
        GoTo there100
    Case "LOCAL", "топийа", "топийг", "топийес"
        lcl = True
        GoTo there12345
    Case "CLASS", "йкасг"
    
        If IsOperator(rest$, ":") Then
            NoRec = True
            uni = False
            prv = False
            GoTo there100
        ElseIf IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", Lang) Then
            MyEr "GLOBAL can't be used in a CLASS", "г ЙКэСГ СТГМ ОЛэДА ДЕМ ЛПОЯЕъ МА ЕъМАИ ЦЕМИЙч"
            ExecuteGroupStruct = 0
            Exit Function
        End If
        x1 = IsLabelA("", rest$, w$)
      

        If x1 = 1 Or x1 = 3 Then
        classfun = True
        j = 0
        frm$ = vbNullString
            If IsLabelSymbolNew(rest$, "тупос", "TYPE", Lang) Then
                MyEr "Use here a Group not a Class", "вЯГСИЛОПОъГСЕ ЛИА оЛэДА ЙАИ ЭВИ ЛИА йКэСГ"
                ExecuteGroupStruct = 0
                Exit Function
            ElseIf IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
            it = x1
Subclass:
                j = IsLabelA("", rest$, w1$)
                If j = 1 Then
                j = 0
                If GetSub(ohere$ + "." + w1$ + "()", j) Then
                ElseIf GetSub(w1$ + "()", j) Then
                End If
                If j > 0 Then
                If sbf(j).Extern > 0 Or Not sbf(j).IamAClass Then
                            MyEr w1$ + " isn't a class", "to " + w1$ + " ДЕМ ЕъМАИ ЙКэСГ"
                            ExecuteGroupStruct = 0
                            Exit Function
                End If
                
                x1 = InStr(sbf(j).sb, vbCrLf)
                y1 = rinstr(sbf(j).sb, vbCrLf + vbCrLf)
                If y1 > x1 And Len(sbf(j).sb) > y1 Then
                s$ = Mid$(sbf(j).sb, x1 + 2, y1 - x1)
                x1 = InStr(s$, "{")
                 If Lang = 1 Then
                        frm$ = block(Mid$(s$, x1 + 1)) + vbCrLf + "Public:" + vbCrLf + frm$
                    Else
                        frm$ = block(Mid$(s$, x1 + 1)) + vbCrLf + "дглосио:" + vbCrLf + frm$
                    End If
                End If
checkagainsub:
               If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then GoTo Subclass
            Else
                MyEr "class " + w1$ + " not found", "ДЕМ БЯщХГЙЕ Г ЙКэСГ " + w1$
                ExecuteGroupStruct = 0
                Exit Function
                End If
               
                End If
                x1 = it
                
            End If
            If here$ = vbNullString Then
                f$ = bstack.GroupName + w$
            Else
                f$ = w$
            End If
            If Lang = 1 Then
                If FastSymbol(rest$, "{") Then
                    ss$ = frm$ + block(rest$)
                    frm$ = vbNullString
                    If x1 = 1 Then
                        s$ = "}" + vbCrLf + vbCrLf + "if module(" + w$ + "." + w$ + ") then call! " + w$ + "." + w$ + vbCrLf + "=group(" + w$ + ")"
                        rest$ = f$ + " {" + "'11001EDIT " + GetModuleName(bstack, here$) + ",-" + Str$(Len(rest$)) + "'" + ",'" + CStr(Len(s$) + 30) + vbCrLf + " group " + w$ + " {" + "type:" + w$ + vbCrLf + ss$ & s$ + rest$
                    Else
                        nm$ = w$
                        w$ = Left$(w$, Len(w$) - 1)
                        s$ = "}" + vbCrLf + vbCrLf + "if module(" + w$ + "." + w$ + ") then call! " + w$ + "." + w$ + vbCrLf + "=group$(" + nm$ + ")"
                        rest$ = f$ + " {" + "'11001EDIT " + GetModuleName(bstack, here$) + Str$(Len(rest$)) + ",-" + Str$(Len(rest$)) + "'" + CStr(Len(s$) + 30) + vbCrLf + " group " + nm$ + " {" + "type:" + w$ + vbCrLf + ss$ + s$ + rest$
                    End If
                    nm$ = vbNullString
                    w$ = vbNullString
                    GoTo classcontclass
                Else
                    f$ = w$
                    w$ = "Group "
                End If
            Else
                If FastSymbol(rest$, "{") Then
                    ss$ = frm$ + block(rest$)
                    frm$ = vbNullString
                    If x1 = 1 Then
                        s$ = "}" + vbCrLf + "аМ тЛчЛА(" + w$ + "." + w$ + ") тЭТЕ йэКЕСЕ! " + w$ + "." + w$ + vbCrLf + "=оЛэДА(" + w$ + ")"
                        rest$ = f$ + " {" + "'11001EDIT " + GetModuleName(bstack, here$) + ",-" + Str$(Len(rest$)) + "'" + CStr(Len(s$) + 29) + vbCrLf + " оЛэДА " + w$ + " {" + "тЩПОР:" + w$ + vbCrLf + ss$ + s$ + rest$
                    Else
                        nm$ = w$
                        w$ = Left$(w$, Len(w$) - 1)
                        s$ = "}" + vbCrLf + "аМ тЛчЛА(" + w$ + "." + w$ + ") тЭТЕ йэКЕСЕ! " + w$ + "." + w$ + vbCrLf + "=оЛэДА$(" + nm$ + ")"
                        rest$ = f$ + " {" + "'11001EDIT " + GetModuleName(bstack, here$) + ",-" + Str$(Len(rest$)) + "'" + CStr(Len(s$) + 29) + vbCrLf + " оЛэДА " + nm$ + " {" + "тЩПОР:" + w$ + vbCrLf + ss$ + s$ + rest$
                    End If
                    w$ = vbNullString
                    GoTo classcontclass
                Else
                    f$ = w$
                    w$ = "олада "
                End If
            End If
            Do While FastSymbol(rest$, ",")
                If IsLabelA("", rest$, nm$) <> 1 Then
                    SyntaxError
                    ExecuteGroupStruct = 0
                    Exit Function
                End If
                f$ = f$ + w$ + nm$ + vbCrLf
            Loop
            If IsLabelSymbolNew(rest$, "тупос", "TYPE", Lang) Then
                 MyEr "Use here a Group not a Class", "вЯГСИЛОПОъГСЕ ЛИА оЛэДА ЙАИ ЭВИ ЛИА йКэСГ"
                ExecuteGroupStruct = 0
                Exit Function
            End If
            w$ = Trim$(w$)
            rest$ = f$ + rest$
            GoTo contVar
        Else
            SyntaxError
            ExecuteGroupStruct = 0
            Exit Function
        End If
    Case "TYPE", "тупос"
    If Not IsOperator(rest$, ":") Then GoTo VarOnly
    Do
    If FastPureLabel(rest$, ss$, , True) = 1 Then
        ThisGroup.PutIs = ss$
    End If
    Loop Until Not FastSymbol(rest$, ",")
    Case "REM", "сгл"
        If FastSymbol(rest$, "{") Then
            i = blockLen(rest$)
            If i > 0 Then
                Mid$(rest$, 1, i) = space$(i)
            Else
                MissString
                ExecuteGroupStruct = 0
                Exit Function
            End If
        End If
        SetNextLine rest$: GoTo there100
    Case "FUNCTION", "сумаятгсг"
        If IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", Lang) Then
            MyEr "GLOBAL can't be used in a Group", "г СУМэЯТГСГ СТГМ ОЛэДА ДЕМ ЛПОЯЕъ МА ЕъМАИ ЦЕМИЙч"
            ExecuteGroupStruct = 0
            Exit Function
        End If
        Final = IsLabelSymbolNew(rest$, "текийг", "FINAL", Lang)
classcontclass:
        x1 = Abs(IsLabelF(rest$, f$))
        If prv Then f$ = ChrW(&HFFBF) + f$
funcoperator:
        If x1 <> 0 Then
           If Len(ThisGroup.FuncList) > 0 And Not alocal Then ' maybe we have it
                If InStr(ThisGroup.FuncList, Chr$(2) + f$ + "() ") > 0 Then
                    If FastSymbol(rest$, "(") Then
                        frm$ = BlockParam(rest$)
                        If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$))
                        FastSymbol rest$, ")"
                        frm$ = Trim$(frm$)
                    Else
                        frm$ = vbNullString
                    End If
                    IsSymbol3 rest$, "{"
                    ss$ = block(rest$)
                    If FastSymbol(rest$, "}") Then
                        If GetSub(bstack.GroupName + f$ + "()", i) Then
                            bstack.IndexSub = i
                            If Not sbf(i).locked Then
                                If frm$ <> "" Then
                                    If Lang = 1 Then
                                        sbf(i).sb = "READ " + frm$ + vbCrLf + ss$
                                    Else
                                        sbf(i).sb = "диабасе " + frm$ + vbCrLf + ss$
                                    End If
                                Else
                                    sbf(i).sb = ss$
                                End If
                                Set sbf(i).subs = Nothing
                            End If
                            sbf(i).locked = Final
                            GoTo continuehere22
                        End If
                        MyEr "group struct error1", "ПЯОБКГЛА СТГ ДОЛч1"
                        ExecuteGroupStruct = 0: Exit Function
                    End If
                End If
            End If
            If bstack.OriginalCode < 0 Then
            '  ??? Stop
            ElseIf Left$(sbf(bstack.OriginalCode).sb, 10) = "'11001EDIT" Then
            
                hlp$ = vbNullString
                If FastSymbol(rest$, "(") Then
                    If Not FastSymbol(rest$, ")") Then
                        hlp$ = MyTrim(BlockParam(rest$))
                        If Len(hlp$) > 0 Then hlp$ = vbCrLf + "Read " + hlp$ + vbCrLf
                    Else
                        IsSymbol3 rest$, "("
                        IsSymbol3 rest$, ")"
                    End If
                    
                Else

                End If
                
                If Right$(rest$, 2) <> vbCrLf Then
                    B$ = GetNextLine((sbf(bstack.OriginalCode).sb)) '+ "+2"
                    i = InStrRev(B$, "'")
                    If i > 1 Then
                        j = val(Mid$(B$, i + 1))
                        B$ = Left$(B$, i - 1)
                    Else
                        j = 0
                    End If
                Else
                    B$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))
                End If
              '  nm$ = GetStrUntil(",", Mid$(b$, 12))
               ' GetSub nm$, i
            If hlp$ <> "" Then
                FastSymbol rest$, "("
                
                frm$ = BlockParam(rest$)
                Mid$(rest$, 1, Len(frm$) + 1) = space$(Len(frm$) + 1)

                
            Else
                hlp$ = vbCrLf

                
            
            End If
            IsSymbol3 rest, "{"
            i = Len(rest$)
            s$ = B$
            If Left$(s$, 10) = "'11001EDIT" Then
                'i = Len(rest$)
                's$ = GetNextLine(rest$)
               ' i = i - Len(rest$) + 1
                DropLeft "'", s$
                DropLeft "'", s$
                If s$ <> "" Then
                j = val(s$)
                B$ = Left$(B$, Len(B$) - Len(s$) - 1)
                End If
            End If
           
          
           B$ = "{" + B$ '+ "-" + LTrim(i + 1)
            If Left$(rest$, 10) = "'11001EDIT" Then
            s$ = GetNextLine(rest$)
            End If
            rest$ = B$ + hlp$ + rest$
        End If
        If here$ = vbNullString Then
            If w$ = vbNullString Then
                rest$ = f$ & " " & rest$
                w$ = "FUNCTION"
            Else
                rest$ = bstack.GroupName + f$ & " " & rest$
            End If
        Else
            rest$ = f$ & " " & rest$
            If w$ = vbNullString Then
                If Lang = 1 Then
                    w$ = "FUNCTION"
                Else
                    w$ = "сумаятгсг"
                End If
            End If
        End If
  
BYPASS3:
        ExecuteGroupStruct = Abs(IdentifierGroup(bstack, w$, rest$, Lang, alocal, addlen))
        If ExecuteGroupStruct = 0 Then Exit Function
        If GetSub(bstack.GroupName + f$ + "()", i) Then
            If sbf(i).locked Then Final = True
            If Final Then sbf(i).locked = True
            If Final Then
                If removebypass Or Not NoRec Then
                    If Not lcl Then
                        ThisGroup.FuncList = Chr$(1) + Chr$(2) + f$ + "() -" + CStr(i) + Chr$(1) + ThisGroup.FuncList
                    Else
                        ThisGroup.LocalList = ThisGroup.LocalList + vbCrLf + "Local Function " + f$ + "{" + sbf(i).sb + "}"
                    End If
                End If
            Else
            If classfun Then
            sbf(i).locked = True
            sbf(i).IamAClass = True
            classfun = False
           s$ = " @"
           Else
           s$ = vbNullString
           
            End If
                If Not NoRec Then
                    If Not lcl Then
                        ThisGroup.FuncList = Chr$(1) + Chr$(2) + f$ + "()" + Str(i) + s$ + Chr$(1) + ThisGroup.FuncList
                    Else
                        ThisGroup.LocalList = ThisGroup.LocalList + vbCrLf + "Local Function " + f$ + "{" + sbf(i).sb + "}"
                    End If
                End If
            End If
            If here$ = vbNullString Then
                sbf(i).sbgroup = bstack.GroupName
                sbf(i).tpointer = vvv
            Else
                sbf(i).sbgroup = here$ + "." + bstack.GroupName
                sbf(i).tpointer = vvv
            End If
        End If
    Else
        ExecuteGroupStruct = 0
    End If
    If ExecuteGroupStruct = 0 Then Exit Function
     

Case "MODULE", "тлгла"
If IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", Lang) Then
MyEr "GLOBAL can't be used in a Group", "г СУМэЯТГСГ СТГМ ОЛэДА ДЕМ ЛПОЯЕъ МА ЕъМАИ ЦЕМИЙч"
ExecuteGroupStruct = 0
Exit Function
End If
Final = IsLabelSymbolNew(rest$, "текийо", "FINAL", Lang)
x1 = Abs(IsLabelF(rest$, f$))
    If prv Then f$ = ChrW(&HFFBF) + f$
If x1 <> 0 Then
  If ThisGroup.FuncList <> "" And Not alocal Then  ' maybe we have it
  If InStr(ThisGroup.FuncList, Chr$(3) + f$ + " ") > 0 Then
    If FastSymbol(rest$, "(") Then
        frm$ = BlockParam(rest$)
        If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
        If Not FastSymbol(rest$, ")") Then
        End If
        frm$ = Trim$(frm$)
    Else
        frm$ = vbNullString
    End If
  
      IsSymbol3 rest$, "{"
    ss$ = block(rest$)
  '  If Right$(ss$, 2) <> vbCrLf Then ss$ = ss$ + vbCrLf
    If FastSymbol(rest$, "}") Then
             If GetSub(bstack.GroupName + f$, i) Then
                           bstack.IndexSub = i
                          If sbf(bstack.IndexSub).locked Then
                          Else
                          If frm$ <> "" Then
                            If Lang = 1 Then
                                sbf(i).sb = "READ " + frm$ + vbCrLf + ss$
                            Else
                                sbf(i).sb = "диабасе " + frm$ + vbCrLf + ss$
                            End If
                          Else
                          sbf(i).sb = ss$
                          End If
                          End If
                          Set sbf(i).subs = Nothing
                          GoTo continuehere22 'there12345
                          End If


 
    Rem never happen
     Rem   MyEr "group struct error2", "ПЯОБКГЛА СТГ ДОЛч2"
     Rem    ExecuteGroupStruct = 0: Exit Function

   End If
  End If
  Else
  ' we don't have it
  End If
  ' so is the first time, put it back
  If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
   
   ss$ = rest$
   hlp$ = vbNullString
   If FastSymbol(ss$, "(") Then
   If Not FastSymbol(ss$, ")") Then
                         hlp$ = BlockParam(ss$)
                            If hlp$ <> "" Then Mid$(ss$, 1, Len(ss$) + 2) = space$(Len(ss$) + 1)
                            FastSymbol ss$, ")"
                            
                        hlp$ = Trim$(hlp$)
                        If hlp$ <> "" Then hlp$ = vbCrLf + "Read " + hlp$ + vbCrLf
                        Else
                        IsSymbol3 rest$, "("
                        IsSymbol3 rest$, ")"
                        End If
   
   End If
     IsSymbol3 ss$, "{"
    frm$ = block(ss$)
    ' look here
  If Right$(frm$, 2) <> vbCrLf Then
        B$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb)) '+ "+2"
        i = InStrRev(B$, "'")
        If i > 1 Then
        j = val(Mid$(B$, i + 1))
           B$ = Left$(B$, i - 1)
           Else
          j = 0
        End If
  Else
        B$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))

        End If
        nm$ = GetStrUntil(",", Mid$(B$, 12))
      GetSub nm$, i
abc123:
      FastSymbol ss$, "("
      If hlp$ <> "" Then
      frm$ = BlockParam(rest)
      
      End If
        If hlp$ <> "" Then
      FastSymbol rest$, "("
      frm$ = BlockParam(rest$)
      
      Mid$(rest$, 1, Len(frm$) + 2) = space$(Len(frm$) + 2)
      Else
      hlp$ = vbCrLf
      End If
      i = Len(rest$)
      IsSymbol3 rest, "{"
      i = i - Len(rest$) + 1
      If Left$(rest$, 10) = "'11001EDIT" Then
      i = Len(rest$)
       s$ = GetNextLine(rest$)
       i = i - Len(rest$) + 1
       DropLeft "'", s$
       DropLeft "'", s$
       If s$ <> "" Then j = val(s$)
       
      End If
      
    ''  b$ = "{" '+ b$ + "-" + LTrim(Str$(addlen))
    
        
   ' rest$ = b$ + hlp$ + rest$
   rest$ = "{" + hlp$ + rest$
Else
    ss$ = rest$
    hlp$ = vbNullString
    If FastSymbol(ss$, "(") Then
        hlp$ = BlockParam(ss$)
        If hlp$ <> "" Then Mid$(ss$, 1, Len(ss$) + 2) = space$(Len(ss$) + 1)
        FastSymbol ss$, ")"
                            
                        hlp$ = Trim$(hlp$)
                        If hlp$ <> "" Then hlp$ = vbCrLf + "Read " + hlp$ + vbCrLf
   
   End If
         FastSymbol "(", ss$
      If hlp$ <> "" Then
      frm$ = BlockParam(rest)
      
      End If
        If hlp$ <> "" Then
      FastSymbol rest$, "("
      frm$ = BlockParam(rest$)
      
      Mid$(rest$, 1, Len(frm$) + 2) = space$(Len(frm$) + 2)
      Else
      hlp$ = vbCrLf
      End If
      IsSymbol3 rest, "{"
       B$ = "{"
    
        
    rest$ = B$ + hlp$ + rest$

  End If
  If here$ = vbNullString Then
  
  rest$ = bstack.GroupName + f$ & " " & rest$
  Else
  
  rest$ = f$ & " " & rest$
  End If
BYPASS4:
 ExecuteGroupStruct = Abs(IdentifierGroup(bstack, w$, rest$, Lang, alocal Or glob, addlen))
  If GetSub(bstack.GroupName + f$, i) Then
  If sbf(i).locked Then Final = True
  If Final Then sbf(i).locked = True
  
If Not NoRec Then
If Final Then
 If Not lcl Then
 ThisGroup.FuncList = Chr$(1) + Chr$(3) + f$ + " -" + CStr(i) + Chr$(1) + ThisGroup.FuncList
 Else
  ThisGroup.LocalList = ThisGroup.LocalList + vbCrLf + "Local Module " + f$ + "{" + sbf(i).sb + "}"
 End If
Else
 If Not lcl Then
 ThisGroup.FuncList = Chr$(1) + Chr$(3) + f$ + " " + CStr(i) + Chr$(1) + ThisGroup.FuncList
 Else
  ThisGroup.LocalList = ThisGroup.LocalList + vbCrLf + "Local Module " + f$ + "{" + sbf(i).sb + "}"
 End If
 End If
End If
        If here$ = vbNullString Then
   sbf(i).sbgroup = bstack.GroupName
   Else
    sbf(i).sbgroup = here$ + "." + bstack.GroupName
  End If
  sbf(i).tpointer = vvv
  End If

     Else
     ExecuteGroupStruct = 0
     End If
     If ExecuteGroupStruct = 0 Then Exit Function
Case "STRUCTURE", "долг"
bstack.priveflag = prv
bstack.uniflag = uni
bstack.finalFlag = Final
 If Not makestruct(bstack, rest$, Lang, glob Or here$ = "", alocal) Then ExecuteGroupStruct = 0: Exit Function
   bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
Case "EVENT", "цецомос", "EVENTS", "цецомота"

If ISSTRINGA(rest$, s$) Then
s$ = CleanStr(s$, " ")
If s$ <> vbNullString Then
ThisGroup.RegisterEvent s$
    Do While FastSymbol(rest$, ",")
        If ISSTRINGA(rest$, s$) Then
            s$ = CleanStr(s$, " ")
            If s$ <> vbNullString Then ThisGroup.RegisterEvent s$
        Else
            MyEr "Expected a string literal for event name", "пЕЯъЛЕМА АКЖАЯИХЛГТИЙЭ СЕ ЕИСАЦЫЦИЙэ ЦИА ЭМОЛА ЦЕЦОМЭТОР"
                    ExecuteGroupStruct = 0
                    Exit Function
        End If
    Loop
Else
    Set ThisGroup.Events = Nothing
End If
GoTo there100
Else
bstack.priveflag = prv
bstack.uniflag = uni
bstack.finalFlag = Final
   ExecuteGroupStruct = Abs(IdentifierGroup(bstack, w$, rest$, Lang, alocal, addlen))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
End If
Case "DIM", "пимайас", "пимайес"
' put back, change HERE$ and
contVar:
bstack.priveflag = prv
bstack.uniflag = uni
bstack.finalFlag = Final

ExecuteGroupStruct = Abs(MyDim(bstack, rest$, Lang, glob Or alocal))

  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
     If ExecuteGroupStruct = 0 Then Exit Function
Case "GROUP", "олада"
If Final Then
            NoObjectAssign
            ExecuteGroupStruct = 0
            Exit Function
            End If
     x1 = Abs(IsLabel(bstack, rest$, w$))
     hlp = vbNullString
     If x1 = 3 Then
     x1 = 1
     hlp = w$
     w$ = Left$(w$, Len(w$) - 1)
     End If
     If prv Then w$ = ChrW(&HFFBF) + w$
      If x1 = 1 Then
                         If IsLabelSymbolNew(rest$, "тупос", "TYPE", Lang) Then
                                            If IsStrExp(bstack, rest$, ss$) Then
                                            frm$ = bstack.GroupName
                                            prepareGroup bstack, w$, y1, glob, Len(hlp) > 0, alocal
                                          
                                            LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                            
                                            bstack.priveflag = prv
                                             ExecuteGroupStruct = Abs(ExecuteGroupStruct(bstack, bstack.GroupName & w$, y1, ss$, 0, Lang, glob, alocal))
                                            bstack.priveflag = False
                                                OvarnameLen = varhash.count + 1 'Len(VarName$) + 1   'we record ...
                                          
                                            
                                             bstack.GroupName = frm$
                                            End If
    
                            Else
                                    If FastSymbol(rest$, "{") Then
                      
                                          frm$ = bstack.GroupName
                                          If glob Then
                                            If GetVar(bstack, frm$ + w$, y1, True) Then
                                                ' skip preparegroup, we have the group
                                                If y1 > vvv Then GoTo contvvv
                                            End If
                                          End If
                                          prepareGroup bstack, w$, y1, False, Len(hlp) > 0, alocal
contvvv:
                                          
                                        LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                            addlen = Len(rest$)
                                            s$ = block(rest$)
                                            addlen = addlen - Len(s$)
               
                                        If Not Abs(ExecuteGroupStruct(bstack, bstack.GroupName & w$, y1, s$, addlen, Lang, glob, alocal)) = 0 Then
                                            ExecuteGroupStruct = FastSymbol(rest$, "}")
                                        End If
                                            OvarnameLen = varhash.count + 1  'we record ...
                                  
                                         bstack.GroupName = frm$
                                         If Typename(var(y1)) <> mgroup Then Set var(y1) = New Group
                                    Else
                                      prepareGroup bstack, w$, y1, glob, Len(hlp) > 0
                                        LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                            End If

                          
                        End If
             End If






     If ExecuteGroupStruct = 0 Then Exit Function
       ''LogGroup bstack, vvv, oHere$, OvarnameLen, OarrnameLen, lcl
Case "GLOBAL", "цемийо", "цемийг", "цемийес"
MyEr "No global variables in groups, create global group", "╪ВИ ЦЕМИЙщР ЛЕТАБКГТщР СЕ ОЛэДА - ЖТИэНЕ ЦЕМИЙч ОЛэДА"
ExecuteGroupStruct = 0
Exit Function
Case "LONG", "лайяус"
    ExecuteGroupStruct = Abs(MyLong(bstack, rest$, Lang, alocal))
    
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
       If ExecuteGroupStruct = 0 Then Exit Function
Case "йатастасг", "INVENTORY"
    ExecuteGroupStruct = Abs(ProcInventory(bstack, rest$, Lang, alocal))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
       If ExecuteGroupStruct = 0 Then Exit Function
Case "диаяхяысг", "BUFFER"
    ExecuteGroupStruct = Abs(ProcBuffer(bstack, rest$, Lang, alocal))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
       If ExecuteGroupStruct = 0 Then Exit Function
Case "DOCUMENT", "еццяажо"
    ExecuteGroupStruct = Abs(MyDocument(bstack, rest$, Lang, alocal))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
     If ExecuteGroupStruct = 0 Then Exit Function
Case "апаяихлгсг", "апая", "ENUMERATION", "ENUM"
  ExecuteGroupStruct = Abs(ProcEnumGroup(bstack, rest$, LenB(here$) = 0))
  bstack.priveflag = False
  bstack.uniflag = False
  bstack.finalFlag = False
       If ExecuteGroupStruct = 0 Then Exit Function
Case Else
' check if we have a class
conthereplease:
nm$ = vbNullString


If Len(rest$) > 0 Then
If Not MaybeIsSymbol(rest$, TT$) Then
   If GetSub(bstack.GroupName + w$ + "()", j) Then
   
        If Not sbf(j).IamAClass Then
grerror:
            MyEr w$ + " isn't a class", "to " + w$ + " ДЕМ ЕъМАИ ЙКэСГ"
            ExecuteGroupStruct = 0
            Exit Function
        End If
        f$ = "=" + bstack.GroupName + w$ + "()"
        
        j = IsLabelA(here$, rest$, w$)
        
            If (j And 3) = 0 Then Exit Do
            
            If j And 7 = 3 Then w$ = Replace(w$, "$", "")
            If uni Then
            Else
                If prv Then w$ = ChrW(&HFFBF) + w$
            End If
            If j > 4 Then
            
            Mid$(w$, Len(w$), 1) = " "
            rest$ = Left$(f$, Len(f$) - 1) + rest$
            Else
            rest$ = f$ + rest$
            End If
           
            
            w$ = RTrim(w$)
            nm$ = w$
            Set stripstack1 = bstack
            ''
    ElseIf GetSub(w$ + "()", j) Then
        If Not sbf(j).IamAClass Then
            GoTo grerror
        End If
        f$ = "=" + w$ + "()"
foundit:
        j = IsLabelA(here$, rest$, w$)
        If (j And 3) = 0 Then Exit Do

        If j And 7 = 3 Then w$ = Replace(w$, "$", "")
        If uni Then
            
        Else
           If prv Then w$ = ChrW(&HFFBF) + w$
        End If
        If j > 4 Then
            
            Mid$(w$, Len(w$), 1) = " "
            rest$ = Left$(f$, Len(f$) - 1) + rest$
            Else
            rest$ = f$ + rest$
            End If
           
            
            w$ = RTrim(w$)
            nm$ = w$
            Set stripstack1 = bstack
    ElseIf GetSub(bstack.GroupName + ChrW(&HFFBF) + w$ + "()", j) Then
        If Not sbf(j).IamAClass Then
            GoTo grerror
        End If
        f$ = "=" + bstack.GroupName + ChrW(&HFFBF) + w$ + "()"
        GoTo foundit
    
    Else
        If uni Then
        
    Else
        If prv Then w$ = ChrW(&HFFBF) + w$
    End If
    End If
Else
If uni Then
    
Else
    If prv Then w$ = ChrW(&HFFBF) + w$
End If

End If
Else
If uni Then
    
Else
    If prv Then w$ = ChrW(&HFFBF) + w$
End If
End If
VarOnly:
w$ = ohere$ & "." & w$
skip = False
Select Case v
Case 1
    p = 0#
    If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
    skip = True
               If IsLabelSymbolNew(rest$, "аяихлос", "DECIMAL", Lang, , , , False) Then
                    If FastSymbol(rest$, "=") Then If Not IsNumberD2(rest$, p) Then missNumber: Exit Function
                    p = CDec(p)
            ElseIf IsLabelSymbolNew(rest$, "дипкос", "DOUBLE", Lang, , , , False) Then
                            If FastSymbol(rest$, "=") Then If Not IsNumberD2(rest$, p) Then missNumber: Exit Function
                p = CDbl(p)
            ElseIf IsLabelSymbolNew(rest$, "апкос", "SINGLE", Lang, , , , False) Then
                        If FastSymbol(rest$, "=") Then If Not IsNumberD2(rest$, p) Then missNumber: Exit Function
                p = CSng(p)
            ElseIf IsLabelSymbolNew(rest$, "коцийос", "BOOLEAN", Lang, , , , False) Then
                    If FastSymbol(rest$, "=") Then If Not IsNumberD2(rest$, p) Then missNumber: Exit Function
                p = CBool(p)
            ElseIf IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang, , , , False) Then
                    If FastSymbol(rest$, "=") Then If Not IsNumberD2(rest$, p) Then missNumber: Exit Function
                p = CLng(p)
            ElseIf IsLabelSymbolNew(rest$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                    If FastSymbol(rest$, "=") Then If Not IsNumberD2(rest$, p) Then missNumber: Exit Function
                p = CInt(p)
            ElseIf IsLabelSymbolNew(rest$, "коцистийо", "CURRENCY", Lang, , , , False) Then
                If FastSymbol(rest$, "=") Then If Not IsNumberD2(rest$, p) Then missNumber: Exit Function
                p = CCur(p)
            Else
                If IsLabelA(here$, rest$, s$) Then
                    If GetVar(bstack, bstack.GroupName + s$, v, True) Then
                        If MyIsObject(var(v)) Then
                            If TypeOf var(v) Is mHandler Then
                                Set usehandler = var(v)
                                If usehandler.t1 = 4 Then
                                    CopyHandler var(v), bstack
                                    Set usehandler = bstack.lastobj
                                    Set bstack.lastobj = Nothing
                                    usehandler.index_start = 0
                                    usehandler.index_cursor = usehandler.objref.ZeroValue
                                    usehandler.sign = 1
                                    If FastSymbol(rest$, "=") Then
                                        If IsLabelA(here$, rest$, s$) Then
                                            If GetVar(bstack, bstack.GroupName + s$, v, True) Then
                                                If MyIsObject(var(v)) Then
                                                    Set p = var(v)
                                                    If TypeOf p Is mHandler Then
                                                        Set usehandler2 = p
                                                        If usehandler2.t1 = 4 Then
                                                            If Not usehandler.objref Is usehandler2.objref Then
                                                                s$ = usehandler.objref.EnumName
                                                                Expected s$, s$
                                                                Exit Function
                                                            End If
                                                            
                                                        Else
                                                            ExpectedEnumType
                                                            Exit Function
                                                        End If
                                                        usehandler2.CopyTo usehandler
                                                        Set p = usehandler
                                                        Set usehandler2 = Nothing
                                                    Else
                                                        ExpectedEnumType
                                                        Exit Function
                                                    End If
                                                Else
                                                    ExpectedEnumType
                                                    Exit Function
                                                End If
                                            Else
                                                ExpectedEnumType
                                                Exit Function
                                            End If
                                        Else
                                            ExpectedEnumType
                                            Exit Function
                                        End If
                                    Else
                                        Set p = usehandler
                                    End If
                                    If glob Then
                                        v = globalvar(w$, p)
                                    ElseIf here$ = vbNullString Then
''???? when???
                                    Else
                                        If alocal Then
                                            v = globalvar(w$, p)
                                        ElseIf Not GetlocalVar(w$, v) Then
                                            v = globalvar(w$, p)
                                        End If
                                        Set var(v) = p
                                    End If
                                    p = Empty
                                    GoTo continuehere
                                Else
                                    ExpectedEnumType
                                    Exit Function
                                End If
                                Set usehandler = Nothing
                            Else
                                ExpectedEnumType
                                Exit Function
                            End If
                        Else
                            ExpectedEnumType
                            Exit Function
                        End If
                        SyntaxError
                    End If
                Else
                    MyEr "No type found", "ДЕМ БЯчЙА ТЩПО"
                    Exit Function
                End If
            End If
        End If
        If glob Then
            v = globalvar(w$, p)
        ElseIf here$ = vbNullString Then
            If Not GetVar(bstack, w$, v) Then v = globalvar(w$, p) ': GetVar bstack, W$, v
        Else
            If alocal Then
            v = globalvar(w$, p)
        Else
            If Not GetlocalVar(w$, v) Then v = globalvar(w$, p)  ': GetlocalVar W$, v
        End If
        If Final Then
            If MyIsObject(var(v)) Then
                If Not TypeOf var(v) Is Constant Then MyEr "No Constant, it is an object", "дЕМ щВЫ СТАХЕЯч, АККэ АМТИЙЕъЛЕМО": Exit Function
            Else
                Set var(v) = New Constant
            End If
        End If
    End If
    If skip Then
    ' do nothing
    ElseIf FastSymbol(rest$, "=") Then
         If IsExp(stripstack1, rest$, p) Then
       
            If Not stripstack1.lastobj Is Nothing Then

                If TypeOf stripstack1.lastobj Is lambda Then
                    Set var(v) = stripstack1.lastobj
                    Set stripstack1.lastobj = Nothing
                    LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, False 'uni
              
  
                    If here$ = vbNullString Or glob Then
                        GlobalSub w$ + "()", "", bstack.GroupName, , v
                    Else
                        If Not alocal Then
                        If GetSub(here$ + "." + w$ + "()", i) Then
                            If rinstr(sbf(i).sbgroup, bstack.GroupName) + Len(bstack.GroupName) - 1 = Len(sbf(i).sbgroup) Then
                            GoTo conthere0001
                            End If
                        End If
                        End If
                       it = GlobalSub(here$ + "." + w$ + "()", "", here$ + "." + bstack.GroupName, , v)
                       sbf(it).tpointer = bstack.tpointer
                    End If
                    If Final Then
                    Set c = New Constant
                    c.DefineOnce var(v)
                    Set var(v) = c
                    End If
                    
conthere0001:
                    OvarnameLen = varhash.count + 1
                ElseIf TypeOf stripstack1.lastobj Is Group Then
                            If Final Then
                            NoObjectAssign
                            ExecuteGroupStruct = 0
                            Exit Function
                            End If
                    Set myobject = stripstack1.lastobj
                   ' If Typename(var(v)) = "Double" Then Set var(v) = New Group
                    
againgroup:
                    
                        If MyIsObject(var(v)) Then
                            
                            If TypeOf var(v) Is Group Then
                            LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                             If nm$ <> "" Then
                                UnFloatGroupReWriteVars stripstack1, nm$, v, myobject
                            ElseIf Len(stripstack1.UseGroupname) = 0 Then
                                        UnFloatGroupReWriteVars stripstack1, w$, v, myobject
                            Else
                                UnFloatGroupReWriteVars stripstack1, Mid$(w$, Len(ohere$ & ". ")), v, myobject
                            End If
                            Else
                                MissingGroup
                                ExecuteGroupStruct = 0
                                Exit Function
                            End If
                           ' LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                            OvarnameLen = varhash.count + 1  'we record ...
                        Else
                          If Typename(var(v)) = "Double" Then
                          Set var(v) = myobject
                          LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                          Set var(v) = Nothing
                          Else
                          LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                          End If
                          If nm$ <> "" Then
                          
                          UnFloatGroup stripstack1, ohere$ + "." + nm$, v, myobject
                     
                          ElseIf Len(stripstack1.UseGroupname) = 0 Then
                          UnFloatGroup stripstack1, w$, v, myobject
                          
                          Else
                          UnFloatGroup stripstack1, Mid$(w$, Len(ohere$ & ". ")), v, myobject
                          End If
                         
                   
                          OvarnameLen = varhash.count + 1  'we record ...
                         ' LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                            Set stripstack1.lastobj = Nothing
                            Set stripstack1 = New basetask
                            bstack.CopyStrip stripstack1
                            
                          If nm$ = vbNullString Then
                          
                          
                                  GoTo continuehere
                          End If
                          
                    End If
                   
                    If FastSymbol(rest$, ",") Then
                        j = IsLabelA(here$, rest$, nm$)
                        If (j And 3) <> 0 Then
                            nm$ = Replace(nm$, "$", "")
                            If uni Then
                            Else
                            If prv Then nm$ = ChrW(&HFFBF) + nm$
                            End If
                            If j > 4 Then
                            nm$ = Left$(nm$, Len(nm$) - 1)
                            rest$ = Left$(f$, Len(f$) - 1) + rest$
                            v = 1
                            w$ = nm$
                            GoTo VarOnly
                            Else
                            If here$ = vbNullString Then
                                If Not GetVar(stripstack1, ohere$ & "." & nm$, v) Then v = globalvarGroup(ohere$ & "." & nm$, p)   ': GetVar bstack, nm$, v
                            Else
                                If Not GetlocalVar(ohere$ & "." & nm$, v) Then v = globalvarGroup(ohere$ & "." & nm$, p)   ': GetlocalVar W$, v
                            End If
                            GoTo againgroup
                            End If

                        Else
                            SyntaxError
                            Exit Do
                        End If
                    End If
                    Set stripstack1.lastobj = Nothing
                    Set stripstack1 = New basetask
                    bstack.CopyStrip stripstack1
                    GoTo continuehere
                ElseIf Typename$(stripstack1.lastobj) = myArray Then
                        If Final Then
                            NoObjectAssign
                            ExecuteGroupStruct = 0
                            Exit Function
                        End If
                        Set usehandler = New mHandler
                        Set var(v) = usehandler
                        usehandler.t1 = 3
                        Set usehandler.objref = stripstack1.lastobj
                        Set stripstack1.lastobj = Nothing
                        Set usehandler = Nothing
                Else
                    If Final Then
                        NoObjectAssign
                        ExecuteGroupStruct = 0
                        Exit Function
                    End If
                    Set myobject = stripstack1.lastobj
                    If CheckIsmArrayOrStackOrCollection(myobject) Then
                        Set usehandler = New mHandler
                        Set var(v) = usehandler
                        If TypeOf myobject Is FastCollection Then
                            usehandler.t1 = 1
                        Else
                            usehandler.t1 = 3
                        End If
                        Set usehandler.objref = myobject
                        Set stripstack1.lastobj = Nothing
                        Set usehandler = Nothing
                    ElseIf TypeOf myobject Is mHandler Then
                        'Set usehandler = myobject
                        If CheckDeepAny(myobject) Then
                            Set var(v) = myobject
                            Set stripstack1.lastobj = Nothing
                        End If
                    End If
                End If
            ElseIf VarType(var(v)) = vbLong Then
                var(v) = CLng(p)
            Else
                If MyIsObject(var(v)) Then
                    If TypeOf var(v) Is Constant Then
                        var(v).DefineOnce p
                    End If
                Else
                If Final Then
                    Set var(v) = New Constant
                    var(v).DefineOnce p
                Else
                    var(v) = p
                    
                End If
                End If
            End If
        Else
            If LastErNum <> -2 Then NoValueForVar w$
            ExecuteGroupStruct = 0
            Exit Function
        End If
    Else
        ss$ = vbNullString
        i = MyTrimL(rest$)
                If InStr("/*-+=~^&|<>", Mid$(rest$, i, 1)) > 0 Then
                    If InStr("/*-+=~^&|<>!", Mid$(rest$, i + 1, 1)) > 0 Then
                        ss$ = Mid$(rest$, i, 2)
                        If ss$ = "=&" Then
                        ss$ = "="
                        Mid$(rest$, i, 1) = " "
                        Else
                        If Len(rest$) >= 2 Then Mid$(rest$, i, 2) = "  "
                        End If
                    Else
                        ss$ = Mid$(rest$, i, 1)
                        If Len(rest$) > 0 Then Mid$(rest$, i, 1) = " "
                    End If
                If ss$ <> "" Then
                    NoThatOperator ss$
                    ExecuteGroupStruct = 0
                    Exit Function
                End If
                Else
                    
                End If
    End If
    GoTo continuehere
Case 2
    rest$ = w$ & rest$: Exit Function
Case 3
        ss$ = vbNullString
         If MaybeIsSymbol(rest$, "=<") Then
            If FastSymbol(rest$, "<=", , 2) Then
                    NoThatOperator "<="
                    ExecuteGroupStruct = 0
                    Exit Function
            ElseIf FastSymbol(rest$, "=") Then
            ss$ = "="
            End If
        End If
       

If ss$ <> "" Then

    If ss$ = "=" Then
    
    If here$ = vbNullString Then
            If glob Then
           If IsStrExp(stripstack1, rest$, ss$) Then
              v = globalvarEmpty(w$)
          If CheckVarGroup(stripstack1, var(v), ss$, Final) = 1 Then
          GlobalSub w$ + "()", "", bstack.GroupName, , v
        
          End If
 
             
           End If
              
           
          ElseIf GetVar(bstack, w$, v) Then
            
                If IsStrExp(stripstack1, rest$, ss$) Then CheckVarGroup stripstack1, var(v), ss$
                
                If Final Then
                    Set var(v) = New Constant
                    var(v).DefineOnce ss$
                End If
            ElseIf IsStrExp(stripstack1, rest$, ss$) Then   ' when we do global a : set group a {k$="something"}

                CheckVarGroup stripstack1, var(globalvarEmpty(w$)), ss$
                
                
            End If
    Else
           If alocal Then
                If IsStrExp(stripstack1, rest$, ss$) Then GoTo contstr1
           ElseIf GetlocalVar(w$, v) Then
                If IsStrExp(stripstack1, rest$, ss$) Then CheckVar var(v), ss$
            ElseIf IsStrExp(stripstack1, rest$, ss$) Then
contstr1:
            
            If Not stripstack1.lastobj Is Nothing Then
                                         If TypeOf stripstack1.lastobj Is lambda Then
                                         If glob Then
                                         v = globalvarEmpty(w$)
                                         Else
                                         v = globalvarEmpty(here$ + "." + w$)
                                         End If
                                CheckVarGroup stripstack1, var(v), ss$, Final
                                '         v = globalvar(w$, Empty)
                                'Set var(v) = stripstack1.lastobj
                              '  Set stripstack1.lastobj = Nothing
                               LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                 If here$ = vbNullString Or glob Then
                                                GlobalSub w$ + "()", "", bstack.GroupName, , v
                                            Else
                                            
                                                GlobalSub here$ & "." & w$ + "()", "", here$ + "." + bstack.GroupName, , v
                                            End If

                                             OvarnameLen = varhash.count + 1
                                             ElseIf TypeOf stripstack1.lastobj Is Group Then
                                             ' here

                                             Set myobject = stripstack1.lastobj
                                             w$ = Replace(w$, "$", "")
                                             
                                       v = globalvar(w$, p)
againgroupstr:
                                               LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni
                                               'nm$ = Left$(nm$, Len(nm$) - 1)
                                               
                                               
                                              If nm$ <> "" Then
                        UnFloatGroup stripstack1, ohere$ + "." + nm$, v, myobject
                        ElseIf Len(stripstack1.UseGroupname) = 0 Then
                        UnFloatGroup stripstack1, w$, v, myobject
                        Else
                        UnFloatGroup stripstack1, bstack.GroupName + Mid$(w$, Len(ohere$ & ". ")), v, myobject
                        End If
                        
                  
                        OvarnameLen = varhash.count + 1  'we record ...
                                Set stripstack1.lastobj = Nothing
                                Set stripstack1 = New basetask
                                bstack.CopyStrip stripstack1
                        If nm$ = vbNullString Then

                                GoTo continuehere
                        End If
                         If FastSymbol(rest$, ",") Then
                         j = IsLabelA(here$, rest$, nm$)
                        If (j And 3) <> 0 Then
                        'If (IsLabelA(here$, rest$, nm$) And 3) <> 0 Then
                        nm$ = Replace(nm$, "$", "")
                                    If uni Then
                            Else
                                If prv Then nm$ = ChrW(&HFFBF) + nm$
                            End If
                        If j > 4 Then
                            nm$ = Left$(nm$, Len(nm$) - 1)
                            rest$ = Left$(f$, Len(f$) - 1) + rest$
                            v = 3
                            w$ = nm$
                            GoTo VarOnly
                            Else
                        frm$ = ohere$ & "." & nm$
                            If here$ = vbNullString Then
                                If Not GetVar(stripstack1, frm$, v) Then v = globalvar(frm$, p)   ': GetVar bstack, nm$, v
                            Else
                                If Not GetlocalVar(frm$, v) Then v = globalvar(frm$, p) ': GetlocalVar W$, v
                            End If
                            frm$ = vbNullString
                             
                            GoTo againgroupstr
                            End If
                        Else
                            SyntaxError
                            Exit Do
                        End If
                    End If
                    Set stripstack1.lastobj = Nothing
                    Set stripstack1 = New basetask
                    bstack.CopyStrip stripstack1
                    GoTo continuehere
                        
                        
                                             Else
                                     NoValueForVar w$
                       End If
               Else
                
                v = globalvar(w$, ss$)
                If Final Then
                Set var(v) = New Constant
                var(v).DefineOnce ss$
                End If
            End If
            End If
            End If
    End If
Else
' NO VALUE IS OK
If Not GetlocalVar(w$, v) Then
                v = globalvar(w$, ss$)
                        If Final Then
        If MyIsObject(var(v)) Then
        If Not TypeOf var(v) Is Constant Then MyEr "No Constant, it is an object", "дЕМ щВЫ СТАХЕЯч, АККэ АМТИЙЕъЛЕМО": Exit Function
        Else
        Set var(v) = New Constant
        End If
        Else
                var(v) = vbNullString
        End If
        

            End If
End If
Case 4
    p = 0#
If glob Then
     v = globalvar(w$, Round(p, 0), , True)
     If Final Then
                    
                    Set var(v) = New Constant
                    var(v).DefineOnce Round(p, 0)
                
     End If
ElseIf here$ = vbNullString Then
If Not GetVar(bstack, w$, v) Then v = globalvar(w$, p) '': GetVar bstack, W$, v
Else
If alocal Then
 v = globalvar(w$, p)
Else
If Not GetlocalVar(w$, v) Then v = globalvar(w$, p) '': GetlocalVar W$, v
End If
        If Final Then
        If MyIsObject(var(v)) Then
        If Not TypeOf var(v) Is Constant Then MyEr "No Constant, it is an object", "дЕМ щВЫ СТАХЕЯч, АККэ АМТИЙЕъЛЕМО": Exit Function
        Else
        Set var(v) = New Constant
        End If
        End If
End If
ss$ = vbNullString
        i = MyTrimL(rest$)
                If InStr("/*-+=~^&|<>", Mid$(rest$, i, 1)) > 0 Then
                    If InStr("/*-+=~^&|<>!", Mid$(rest$, i + 1, 1)) > 0 Then
                        ss$ = Mid$(rest$, i, 2)
                        If ss$ = "=&" Then
                        ss$ = "="
                        Mid$(rest$, i, 1) = " "
                        Else
                        Mid$(rest$, i, 2) = "  "
                        End If
                    Else
                        ss$ = Mid$(rest$, i, 1)
                        Mid$(rest$, i, 1) = " "
                    End If
                If ss$ <> "=" And ss$ <> "" Then
                    NoThatOperator ss$
                    ExecuteGroupStruct = 0
                    Exit Function
                End If
                Else
                    
                End If


            If ss$ = "=" Then
                If IsExp(stripstack1, rest$, p) Then
                If MyIsObject(var(v)) Then
                If TypeOf var(v) Is Constant Then
                  var(v).DefineOnce MyRound(p)
                
                End If
                Else
                 var(v) = MyRound(p)
                 End If
                If Err.Number = 6 Then ExecuteGroupStruct = 0:   Exit Function

                Else
                      If LastErNum <> -2 Then NoValueForVar w$
                      ExecuteGroupStruct = 0
                      Exit Function

            
            End If
End If
GoTo continuehere
Case 5
If Final Then
rest$ = Mid$(w$, Len(ohere$) + 2) + rest$
w$ = "DIM"
GoTo contVar
End If
    If neoGetArray(stripstack1, w$, pppp, , glob) Then
        If Not NeoGetArrayItem(pppp, stripstack1, w$, v, rest$) Then ExecuteGroupStruct = 0:  Exit Function
        On Error Resume Next
JUMPHERE:
        If Not FastSymbol(rest$, "=", True) Then
        SyntaxError
           ExecuteGroupStruct = 0: Exit Function
        End If
        Set myobject = Nothing
        If pppp.Arr Then
        If GetData(stripstack1, rest$, myobject) Then
            FeedArray pppp, v, myobject
        Else
            ExecuteGroupStruct = 0: Exit Function
        End If
        Else
          ' Why
          ' If Not IsExp(stripstack1, rest$, p) Then
          '      If LastErNum <> -2 Then MissNumExpr
          '      ExecuteGroupStruct = 0: Exit Function
          '  End If
           ' pppp.GroupRef.Value = p
           SyntaxError
           ExecuteGroupStruct = 0: Exit Function
        End If
        lcl = False
    Else
        MyEr "Can't find array " & w$ & ")", "дЕМ БЯъСЙЫ ПъМАЙА " & w$ & ")"
        ExecuteGroupStruct = 0:   Exit Function
    End If
GoTo continuehere
Case 6
If Final Then
rest$ = Mid$(w$, Len(ohere$) + 2) + rest$
w$ = "DIM"
GoTo contVar
End If
If neoGetArray(stripstack1, w$, pppp, , glob) Then
If Not NeoGetArrayItem(pppp, stripstack1, w$, v, rest$) Then ExecuteGroupStruct = 0:   Exit Function
    On Error Resume Next
    GoTo JUMPHERE
Else
ExecuteGroupStruct = 0:   Exit Function
End If
Case 7
If Final Then
rest$ = Mid$(w$, Len(ohere$) + 2) + rest$
w$ = "DIM"
GoTo contVar
End If
If neoGetArray(stripstack1, w$, pppp, , glob) Then
If Not NeoGetArrayItem(pppp, stripstack1, w$, v, rest$) Then ExecuteGroupStruct = 0:   Exit Function
On Error Resume Next
If Not FastSymbol(rest$, "=") Then ExecuteGroupStruct = 0: Exit Function
If Not IsExp(stripstack1, rest$, p) Then ExecuteGroupStruct = 0: Exit Function
p = MyRound(p)
If Err.Number > 0 Then ExecuteGroupStruct = 0: Exit Function
pppp.item(v) = p
Do While FastSymbol(rest$, ",")
If pppp.UpperMonoLimit > v Then
v = v + 1
If Not IsExp(stripstack1, rest$, p) Then ExecuteGroupStruct = 0: Exit Function
pppp.item(v) = MyRound(p)
Else
Exit Do
End If
Loop
Else
ExecuteGroupStruct = 0: Exit Function
End If
GoTo continuehere
Case Else

If MaybeIsSymbol(rest$, ",-+*/_!@()[];<>|~`") Then
SyntaxError
ExecuteGroupStruct = 0
Exit Function
End If
End Select
End Select
continuehere:
''\\\\\\\\\\\\\\\\

LogGroup bstack, vvv, ohere$, OvarnameLen, lcl, NoRec, uni

continuehere22:
If lookOne(rest$, "}") Then

ExecuteGroupStruct = 1
Exit Do
End If
If Not FastSymbol(rest$, ",") Then
Final = False
SetNextLine rest$
lcl = False
End If
ExecuteGroupStruct = 1
Loop Until Trim$(rest$) = vbNullString
End Function


Public Function CleanStr(sStr As String, noValidcharList As String) As String
Dim a$, i As Long '', ddt As Boolean
If noValidcharList <> "" Then
''If Len(sStr) > 20000 Then ddt = True
If Len(sStr) > 0 Then
For i = 1 To Len(sStr)
''If ddt Then If i Mod 321 = 0 Then Sleep 20
If InStr(noValidcharList, Mid$(sStr, i, 1)) = 0 Then a$ = a$ & Mid$(sStr, i, 1)

Next i
End If
Else
a$ = sStr
End If
CleanStr = a$
End Function
Sub CallByObject(bstack As basetask, ret As Boolean, that As stdCallFunction)
Dim Up As Long, getparam As Boolean, pp As Long
Dim k As Long, p As Variant, Final(0 To 63) As Variant
Dim x1 As Long, what$, curtype As Long, s$, link$, rtype As Variant
Dim thisref(0 To 63) As Long

If that.ReadType(that.count - 1) = -100 Then
Up = that.count - 1
getparam = True
Else
Up = that.count
End If
For k = 1 To Up
       
        If that.IsByRef(k - 1) Then
            ' look for label..and check it
           If bstack.IsInStackString(what$) Then
                   
                    If that.ReadType(k - 1) <= 4 Then
                            If GetGlobalVar(bstack.GroupName & what$, x1) Then
                                    thisref(k - 1) = x1 ' so that is used to restore value
                                    If MyIsObject(var(x1)) Then
                                         ' THIS IS NOT GOOD
                                    
                                    Else
                                        If that.ReadType(k - 1) = 2 Then
                                         Final(k - 1) = CLng(VarPtr(var(x1)) + 8)
                                        Else
                                             Final(k - 1) = var(x1)
                                            End If
                                             ' so if this is a long we place a variant long
                                           ' thisref(k - 1) = x1
                                     End If
                            Else
                            ' no such variable
                            End If
                    Else
                    ' error no array yet
                    
                    End If
            Else
            ' type mismatch
            ' exit - error
            End If
        Else
        Dim ii As Long
                Select Case that.ReadType(k - 1)
                Case 2
                   If Not bstack.IsInStackNumber(p) Then
                   
                    If Not bstack.IsInStackLong(ii) Then Exit For
                    Final(k - 1) = ii
                    Else
                    Final(k - 1) = CLng(p)
                   End If
                    
                Case 1, 5
                        If Not bstack.IsInStackNumber(p) Then
                   
                    If Not bstack.IsInStackLong(ii) Then Exit For
                    Final(k - 1) = ii
                    Else
                    Final(k - 1) = p
                    End If
                Case 4, 7
                      If Not bstack.IsInStackNumber(p) Then
                   
                    If Not bstack.IsInStackLong(ii) Then Exit For
                    Final(k - 1) = ii
                    Else
                    Final(k - 1) = MyRound(p)
                    End If
                Case Else
                    If Not bstack.IsInStackString(s$) Then Exit For
                    Final(k - 1) = s$
                End Select
        End If
Next k
If getparam Then
Do
If bstack.IsInStackLong(pp) Then
Final(k - 1) = pp
k = k + 1
ElseIf bstack.IsInStackNumber(p) Then
Final(k - 1) = p
k = k + 1
ElseIf bstack.IsInStackString(s$) Then
 Final(k - 1) = s$
k = k + 1
Else
Exit Do
End If
Loop Until bstack.soros.IsEmpty Or k = 63

Up = k - 1
End If

If k > Up Then
'all is ok
' make your call
If that.RetType = 0 Then
rtype = vbLong
Else
rtype = that.RetType
End If
If that.CallAddr = 0 Then
If Left$(that.func, 1) = "#" Then
that.CallAddr = GetFuncPtrOrd(that.LIB, that.func)
Else
that.CallAddr = GetFuncPtr(that.LIB, that.func)
End If
End If
If that.CallAddr = 0 Then Exit Sub
If that.CallType = 0 Then
x1 = Fast_stdCallW(that.CallAddr, rtype, Final(), Up)
Else
x1 = Fast_cdeclCallW(that.CallAddr, rtype, Final(), Up)
End If
If ret Then
If that.RetType = 0 Then
bstack.soros.PushVal CDbl(x1)   ' FEEDBACK TO STACK
Else
bstack.soros.PushStr GetBStrFromPtr(x1)
End If
End If
Else
'error message


Exit Sub
End If
For k = 1 To that.count
If that.IsByRef(k - 1) Then
' RESTORE VALUES...
    If that.ReadType(k - 1) < 5 Then
    If that.ReadType(k - 1) <> 2 Then var(thisref(k - 1)) = Final(k - 1)
    
    End If
End If
Next k

End Sub

Sub CallGlobal(s$)
Dim ohere$
ohere$ = here$
here$ = "@"
 Execute Basestack1, s$, False
 s$ = vbNullString
here$ = ohere$
End Sub
Public Sub ProcProperty(bstack As basetask, v(), vIndex As Long, FN$, rest$, language As Long, Optional hardlink As Boolean = False, Optional usethis As Long)
Dim var1() As Variant, s$, R As Double, l As Long, newref As Long, many As Long, y1 As Boolean, x1 As Long, y2 As Boolean
Dim var2() As String, ss$, sp As Variant, indirect As Boolean, s1$
Dim vv As Object, handlerFLAG As Boolean, usehandler As mHandler
Dim oo As Object, myVar As Variant
Set vv = v(vIndex)
Dim pppp As mArray

If TypeOf vv Is mHandler Then
Set usehandler = vv
If usehandler.indirect >= 0 Then
 vIndex = usehandler.indirect
    Set vv = var(usehandler.indirect)
   
Else
If usehandler.UseIterator Then
ElseIf usehandler.IamEnum Then
handlerFLAG = True
Else
    Set vv = usehandler.objref
End If
End If
 indirect = True
End If
If TypeOf vv Is PropReference Then
myVar = vv.Value
If IsObject(vv.lastobj) Then Set vv = vv.lastobjfinal Else MyEr "No Object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО": Exit Sub
End If
Do
ReDim var1(0 To 0)
Erase var2()
Set pppp = Nothing

If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, R) Then

                        If FastSymbol(rest$, "@") Then
                            Set oo = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            ReDim var1(0 To 1)
                            If IsExp(bstack, rest$, sp) Then
                                var1(0) = sp
                            ElseIf IsStrExp(bstack, rest$, ss$) Then
                                var1(0) = ss$
                            End If
                            If oo Is Nothing Then
                                var1(1) = R
                            Else
                            If TypeOf oo Is mHandler Then
                                Set bstack.lastobj = oo
                                Set var(1) = bstack.lastobjIndirect(var())
                            Else
                                Set var1(1) = oo
                            End If
                                Set oo = Nothing
                            End If
                    
                           CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 2
                         Else
                                If bstack.lastobj Is Nothing Then
conthere:
                                    var1(0) = R
                                    CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 1
                                Else
                                    Set var1(0) = bstack.lastobj
                                    If TypeOf var1(0) Is mHandler Then
                                    
                                    Set usehandler = var1(0)
                                    If usehandler.t1 = 4 Then GoTo conthere
                                  
                                    End If
                                    Set bstack.lastobj = Nothing
                                    CallByNameFixParamArray vv, FN$, VbSet, var1(), var2(), 1
                                    
                                End If
                                
                        End If
 
 
ElseIf IsStrExp(bstack, rest$, s$) Then

                        If FastSymbol(rest$, "@") Then
                            ReDim var1(0 To 1)
                            
                            If IsExp(bstack, rest$, sp) Then
                                var1(0) = sp
                            ElseIf IsStrExp(bstack, rest$, ss$) Then
                                var1(0) = ss$
                            End If
                            var1(1) = s$
                            CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 2
                        Else
                            var1(0) = s$
                            CallByNameFixParamArray vv, FN$, VbLet, var1(), var2(), 1
                        End If
End If
ElseIf IsLabelSymbolNew(rest$, "ыс", "AS", language) Then
' WE MAKE A NEW OBJECT
If TypeOf var(vIndex) Is GuiM2000 Then If UCase(FN$) = "VISIBLE" Then FN$ = "TrueVisible"
                                                    
If FN$ = vbNullString Then
l = usethis
ElseIf handlerFLAG Then
Set usehandler = vv
l = FindDISPID(usehandler.objref, FN$)
Set usehandler = Nothing
Else
l = FindDISPID(vv, FN$)

'FN$ = Typename(vv) & "." & UCase(FN$)
End If
If l <> -1 Then
' we have vv, fn$, l and we are looking for a label to make an object to that
y1 = IsLabelSymbolNew(rest$, "цемийо", "GLOBAL", language)

If Not y1 Then y2 = IsLabelSymbolNew(rest$, "мео", "NEW", language) Else y2 = False
x1 = Abs(IsLabel(bstack, rest$, s$))

If x1 < 5 Then
    If y1 Or y2 Then GoTo JUMPTHERE
    If GetlocalVar(s$, newref) Then
    ' so it is an object now
    If Not MyIsObject(var(newref)) Then
    MakeitPropReference var(newref)
    GoTo jumpheretoo
    ElseIf Typename(var(newref)) <> mProp Then
    If Typename(var(newref)) = mHdlr Then
    GoTo contenum
    Else
    MakeitPropReference var(newref)
    End If
    GoTo jumpheretoo
    End If
Else
JUMPTHERE:
''GlobalVar s$, 0   'we push a zero..GlobalVar create
''GetlocalVar s$, newref

If y1 Then
newref = GlobalVarRefOnly(s$, y1)
Else
newref = GlobalVarRefOnly(bstack.GroupName & s$)
End If
contenum:
If l = -4 Then
' get now object

sp = vbEmpty
If ReadPropObj(vv, -4, sp) Then
    Set usehandler = New mHandler
    Set var(newref) = usehandler
    usehandler.ConstructEnumerator sp
    Set usehandler = Nothing
Else
    NoEnumerator
End If

Else
MakeitPropReference var(newref)

jumpheretoo:
If hardlink Then

Set oo = v(vIndex)
If TypeOf oo Is mHandler Then
    Set usehandler = oo
    Set oo = usehandler.objref
    If usehandler.t1 <> 1 Then
        GoTo there
    End If
End If
    var(newref).ConstructObj oo, l
Set oo = Nothing
Else
If vv Is var(vIndex) Then
var(newref).Construct vIndex, l, indirect    ' this is the link vindex is an index to var()
Else
var(newref).ConstructObj vv, l
End If
End If
End If
End If
Else


If y2 Then
If FastSymbol(rest$, ")") Then GoTo contherenew
End If
 If neoGetArray(bstack, s$, pppp, here$ <> "") Then

 
If NeoGetArrayItem(pppp, bstack, s$, newref, rest$) Then

With pppp

  MakeitPropReference myVar
  If pppp.Arr Then Set .item(newref) = myVar
  
    If hardlink Then

Set oo = v(vIndex)
If TypeOf oo Is mHandler Then
Set usehandler = oo
With usehandler
If .indirect < 0 Then
    Set oo = .objref
Else
    If .indirect <= var2used Then
    '????
    End If
End If
End With
End If
myVar.ConstructObj oo, l
Set oo = Nothing
Else
myVar.Construct vIndex, l   ' this is the link vindex is an index to var()
End If
Set myVar = Nothing
End With
Set usehandler = Nothing
End If
ElseIf FastSymbol(rest$, ")") Then
''s$ = Left$(s$, Len(s$) - 1)
contherenew:
If pppp Is Nothing Then

GlobalArr bstack, s$, "0)", (1), (y1)
 If Not neoGetArray(bstack, s$, pppp, here$ <> "") Then GoTo there
End If




MakeitPropReference myVar

If hardlink Then

Set oo = v(vIndex)
If TypeOf oo Is mHandler Then
    Set usehandler = oo
    Set oo = usehandler.objref
    Set usehandler = Nothing
End If
myVar.ConstructObj oo, l
Set oo = Nothing
Else
myVar.Construct vIndex, l   ' this is the link vindex is an index to var()
End If

myVar.UseIndex = True

pppp.PushProp myVar

''
End If

End If
End If
ElseIf IsLabelSymbolNew(rest$, "паяе", "GET", language) Then
l = FindDISPID(vv, FN$)
FN$ = UCase(FN$)
If l <> -1 Then
Debug.Print "found IT"
End If
x1 = Abs(IsLabel(bstack, rest$, s$))
Beep
ElseIf IsLabelSymbolNew(rest$, "хесе", "SET", language) Then
y1 = IsLabelSymbolNew(rest$, "цемийо", "GLOBAL", language)
l = FindDISPID(vv, FN$)
FN$ = UCase(FN$)
If l <> -1 Then

x1 = Abs(IsLabel(bstack, rest$, s$))
If x1 < 5 Then
If Not FastSymbol(rest$, "(") Then
If Not ReadOneParameter(vv, l, s$, myVar) Then
If MyIsObject(myVar) Then
If myVar Is Err Then
    Set errbag = New ErrorBag
    errbag.CopyErr
    Set myVar = errbag
    Set errbag = Nothing
    Err.Clear
End If
Else
    MyEr s$, s$
    GoTo there
End If

End If
Else
GoTo contindex
End If
Else
contindex:
 If IsExp(bstack, rest$, sp) Then
  Err.Clear
        Set myVar = ReadOneIndexParameter(vv, l, s1$, sp, False)
                    If Err.Number Then
                        If MyIsObject(myVar) Then
                            If myVar Is Err Then
                                Set errbag = New ErrorBag
                                errbag.CopyErr
                                Set myVar = errbag
                                Set errbag = Nothing
                            End If
                        End If
                        Err.Clear
                        Set myVar = ReadOneIndexParameter(vv, l, s1$, sp, True)
                        If MyIsObject(myVar) Then
                            If myVar Is Err Then
                                Set errbag = New ErrorBag
                                errbag.CopyErr
                                Set myVar = errbag
                                Set errbag = Nothing
                            End If
                        End If
                        Err.Clear
                    End If
                            ElseIf IsStrExp(bstack, rest$, ss$) Then
                            On Error Resume Next
                Err.Clear
                Set myVar = ReadOneIndexParameter(vv, l, s1$, ss$, False)
                If Err.Number Then
                   If MyIsObject(myVar) Then
                            If myVar Is Err Then
                                Set errbag = New ErrorBag
                                errbag.CopyErr
                                Set myVar = errbag
                                Set errbag = Nothing
                            End If
                        End If
                        
                Err.Clear
                Set myVar = ReadOneIndexParameter(vv, l, s1$, ss$, True)
                               If MyIsObject(myVar) Then
                            If myVar Is Err Then
                                Set errbag = New ErrorBag
                                errbag.CopyErr
                                Set myVar = errbag
                                Set errbag = Nothing
                            End If
                        End If
                        
                Err.Clear
                End If
                            End If
                            If Not FastSymbol(rest$, ")") Then GoTo there
                         If x1 > 4 Then s$ = Left$(s$, Len(s$) - 1)
End If
      If GetlocalVar(s$, newref) Then
            'var(newref) = CDbl(myVar)
             If IsObject(myVar) Then
                Set var(newref) = myVar
            Else
            var(newref) = myVar
            End If
        Else
            newref = GlobalVarRefOnly(s$, y1)
            If IsObject(myVar) Then
                Set var(newref) = myVar
            Else
            var(newref) = myVar
            End If
    End If

End If
End If
 If FastSymbol(rest$, ",") Then
 If Not IsStrExp(bstack, rest$, FN$) Then Exit Do
 Else
 Exit Do
 End If
Loop
there:
Set oo = Nothing
Set pppp = Nothing
Set vv = Nothing
End Sub






Sub ProcMethod(bstack As basetask, v(), vIndex As Long, FN$, rest$, language As Long, ok As Boolean)
Dim var1() As Variant, s$, R As Double, l As Long, newref As Long, glob As Boolean, newvar As Boolean
Dim vv As Object, Result As Variant, retobject As Object, usehandler As mHandler
Dim namarg As Long
ok = True
Set vv = v(vIndex)
If TypeOf vv Is mHandler Then
Set usehandler = vv
If usehandler.indirect >= 0 Then

vIndex = usehandler.indirect
If var2used < usehandler.indirect Then
MyEr "weak reference  out of scope", "Г АМАЖОЯэ ЕъМАИ ЕЙТЭР СЙОПОЩ"
ok = False
Exit Sub
End If

Set vv = var(usehandler.indirect)

Else
Set vv = usehandler.objref
End If
End If
Set usehandler = Nothing
If vv Is Nothing Then Exit Sub
If TypeOf vv Is PropReference Then
Result = vv.Value
Result = Empty
If IsObject(vv.lastobj) Then Set vv = vv.lastobjfinal Else ok = False: MyEr "No Object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО": Exit Sub
End If

ReDim var1(0 To 0)
Dim var2() As String
ReDim var2(0 To 0)
' expression or label:=expression'

''Exit Sub
Dim what$, it As Long, items As Long, Y3 As Long, ok1 As Boolean

' we have parameters..(by value)
If FastSymbol(rest$, "(") Then  ' we have "(par1, par2...) as result"
        RealMeth bstack, rest$, var1(), var2(), items, namarg, ok1
        If Not ok1 Then Exit Sub
If Not FastSymbol(rest$, ")", True) Then Exit Sub
Result = CallByNameFixParamArray(vv, FN$, VbMethod, var1(), var2(), items, retobject, namarg, bstack.IamAnEvent)
ElseIf FastSymbol(rest$, ",") Then
RealMeth bstack, rest$, var1(), var2(), items, namarg, ok1  ' if we have as result then we get an error...
If Not ok1 Then Exit Sub
 Result = CallByNameFixParamArray(vv, FN$, VbMethod, var1(), var2(), items, retobject, namarg, bstack.IamAnEvent)
Else

 Result = CallByNameFixParamArray(vv, FN$, VbMethod, var1(), var2(), 0, retobject, namarg, bstack.IamAnEvent)

End If
If Not retobject Is Nothing Then
    Y3 = IsLabelSymbolNew(rest$, "лецецомота", "WITHEVENTS", language)
     If IsLabelSymbolNew(rest$, "ыс", "AS", language) Then
             glob = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", language)
             
              newvar = IsLabelSymbolNew(rest$, "мео", "NEW", language)
             
             If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                        If newvar Then
                            it = globalvar(what$, 0, , glob)
                            Set var(it) = retobject
                        ElseIf GetVar(bstack, what$, it) Then
                            Set var(it) = retobject
                        Else
                            it = globalvar(what$, 0, , glob)
                            Set var(it) = retobject
                        End If
                            
                                If Y3 <> 0 Then
                                            Dim ev As ComShinkEvent
                                    If GetShink(ev, it, what$) Then
                                            ' private
                                            ' no need for a name, we do not address it in any way.
                                            ' ev knows how to call handler
                                            If newvar Then
                                                it = globalvarGroup(ChrW(&HFFBF) + "_" + what$, s$, , glob)
                                            ElseIf Not GetVar(bstack, ChrW(&HFFBF) + "_" + what$, it) Then
                                                        
                                                        it = globalvarGroup(ChrW(&HFFBF) + "_" + what$, s$, , glob)
                                                        End If
                                                        
                                                    Set var(it) = ev
                                     Else
                                            MyEr "Can't handle events here", "дЕМ ЛПОЯЧ МА ВЕИЯИСТЧ ЦЕЦОМЭТА"
                                            ok = False
                                             
                                         '   End Sub
                                     End If
                                End If
            End If
     End If
Else
     If IsLabelSymbolNew(rest$, "ыс", "AS", language) Then
             glob = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", language)
             
              newvar = IsLabelSymbolNew(rest$, "мео", "NEW", language)
             
             Select Case Abs(IsLabel(bstack, rest$, what$))
             Case 1
                               If newvar Then
                                    globalvar what$, Result, , glob
                                ElseIf GetVar(bstack, what$, it) Then
                                    var(it) = Result
                                    
                                Else
                                    globalvar what$, Result, , glob
                                    
                                End If
              Case 4
                                If newvar Then
                                    globalvar what$, Int(Result), , glob
                                ElseIf GetVar(bstack, what$, it) Then
                                    var(it) = Int(Result)
                                Else
                                    globalvar what$, Int(Result), , glob
                                    
                                End If
              Case 3
                                If newvar Then
                                    globalvar what$, Result, , glob
                                ElseIf GetVar(bstack, what$, it) Then
                                    var(it) = Result
                                Else
                                    globalvar what$, Result, , glob
                                End If
              End Select
            
    End If
End If
End Sub

Sub RealMeth(bstack As basetask, rest$, var2() As Variant, var3() As String, NoNameditems As Long, namedargument As Long, ok As Boolean)
'  testmeth "122,&beta,121,alfa:=a+4, beta:=122"
Dim s$
Dim mm As mArray, usehandler As mHandler
Dim trap As Long, ss$, p As Variant, items As Long, ref As Boolean, i As Long, z As Variant, c As Long
ok = True
Do
again:
If FastSymbol(rest$, ",") Then
' second, or more is optional
        
        items = items + 1
        If UBound(var2()) < items Then ReDim Preserve var2(items + 1)
        OptVariant var2(items - 1)
        If namedargument = 0 Then NoNameditems = NoNameditems + 1
        GoTo again
End If
ref = FastSymbol(rest$, "&")

s$ = aheadstatus(rest$) + " "
Select Case Left$(s$, 1)
Case "S"
        If (trap Mod 2 = 0) And namedargument > 0 Then Exit Do  ' is a fault
        If ref Then
            i = IsLabel(bstack, rest$, ss$)
            If i > 0 Then
                If i > 4 Then If Not FastSymbol(rest$, ")", True) Then Exit Sub
                GetVar bstack, ss$, i
                c = 1
again2:
                If MyIsObject(var(i)) Then
                    If TypeOf var(i) Is mHandler Then
                        Set usehandler = var(i)
                        If usehandler.indirect <> -1 Then
                            i = usehandler.indirect
                            c = c + 1
                            If c < 20 Then Set usehandler = Nothing: GoTo again2 Else InternalEror: Exit Sub
                        End If
                        If usehandler.t1 = 3 Then
                            Set mm = usehandler.objref
                            mm.ExportStringArrayNow
                            mm.refArray = vbNullString
                            Set var2(items) = mm
                            Set mm = Nothing
                        Else
                            VarByRef VarPtr(var2(items)), var(i)
                        End If
                        Set usehandler = Nothing
                    ElseIf TypeOf var(i) Is mArray Then
                            Set mm = var(i)
                            mm.ExportStringArrayNow
                            mm.refArray = vbNullString
                            Set var2(items) = var(i)
                            Set mm = Nothing
                    Else
                        VarByRef VarPtr(var2(items)), var(i)
                    End If
                ElseIf VarType(var(i)) = vbDecimal Then
                    VarByRefDecimal VarPtr(var2(items)), var(i)
                Else
                    VarByRef VarPtr(var2(items)), var(i)
                End If
                If namedargument = 0 Then NoNameditems = NoNameditems + 1
            Else
                NoReference
                ok = False
                Exit Sub
            End If
        ElseIf IsStrExp(bstack, rest$, ss$) Then
        If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mArray Then
        Set mm = bstack.lastobj
        If mm.Arr Then
        mm.ExportStringArrayNow
        mm.refArray = 0&
        End If
        Set var2(items) = mm
        Set mm = Nothing
        
        Else
        var2(items) = ss$
        End If
        Else
        
            var2(items) = ss$
            End If
           If namedargument = 0 Then NoNameditems = NoNameditems + 1
        Else
            var2(items) = vbNullString
            s$ = vbNullString
        End If
        If trap > 0 Then trap = trap + 1
        items = items + 1
        If UBound(var2()) < items Then ReDim Preserve var2(items + 1)
Case "N"
        ' maybe is a named argument

        c = 1
        i = FastPureLabel(rest$, ss$, c, , , , False)
            If i > 0 Then
               If Mid$(rest$, c, 2) = ":=" Then
                    i = IsLabel(bstack, rest$, ss$)
                    rest$ = Mid$(rest$, 3)
                    
                    namedargument = namedargument + 1
                    If UBound(var3()) < namedargument Then ReDim Preserve var3(namedargument + 1)
                    var3(namedargument) = ss$
                    trap = 1
                    GoTo again
                Else
                   If ref Then
                   i = IsLabel(bstack, rest$, ss$)
                   If i > 4 Then If Not FastSymbol(rest$, ")", True) Then Exit Sub
                   GetVar bstack, ss$, i
                    
                    c = 1
again3:
                    If MyIsObject(var(i)) Then
                        If TypeOf var(i) Is mHandler Then
                            Set usehandler = var(i)
                            If usehandler.indirect <> -1 Then
                                i = var(i).indirect
                                c = c + 1
                                If c < 20 Then Set usehandler = Nothing: GoTo again3 Else InternalEror: Exit Sub
                            End If
                            If usehandler.t1 = 3 Then
                                Set mm = usehandler.objref
                                mm.ExportArrayNow
                                Set var2(items) = mm
                                Set mm = Nothing
                            ElseIf usehandler.t1 = 4 Then
                               ' usehandler.sign * usehandler.index_cursor
                                  var2(items) = usehandler.sign * usehandler.index_cursor
                            Else
                                VarByRef VarPtr(var2(items)), var(i)
                            End If
                            Set usehandler = Nothing
                        ElseIf TypeOf var(i) Is mArray Then
                            Set mm = var(i)
                            mm.ExportArrayNow
                            Set var2(items) = var(i)
                            Set mm = Nothing
                        Else
                                VarByRef VarPtr(var2(items)), var(i)
                        End If
                    ElseIf VarType(var(i)) = vbDecimal Then
                        VarByRefDecimal VarPtr(var2(items)), var(i)
                    Else
                        VarByRef VarPtr(var2(items)), var(i)
                    End If
                    If namedargument = 0 Then NoNameditems = NoNameditems + 1


                ElseIf Not ((trap Mod 2 = 0) And namedargument > 0) Then
                    If IsExp(bstack, rest$, p) Then
                        If bstack.lastobj Is Nothing Then
                             var2(items) = p
                        Else
                        If TypeOf bstack.lastobj Is mHandler Then
                            Set usehandler = bstack.lastobj

                            If usehandler.t1 = 4 Then
                                var2(items) = p
                            ElseIf usehandler.t1 = 3 Then
                                Set mm = usehandler.objref
                                Set var2(items) = mm
                                Set mm = Nothing
                            Else
                            Set var2(items) = bstack.lastobjIndirect(var())
                            End If
                        ElseIf TypeOf bstack.lastobj Is mArray Then
                            Set mm = bstack.lastobj
                            mm.refArray = 0&
                            mm.IsByValue = True
                            Set var2(items) = mm
                            Set mm = Nothing
                        Else
                            Set var2(items) = bstack.lastobj
                        End If
                        Set bstack.lastobj = Nothing
                    End If
                    If namedargument = 0 Then NoNameditems = NoNameditems + 1
                          If trap > 0 Then trap = trap + 1
                    End If
                Else
                    Exit Do
                End If
            End If
        Else
            If Not ((trap Mod 2 = 0) And namedargument > 0) Then
                If IsExp(bstack, rest$, p) Then
                    var2(items) = p
                    If namedargument = 0 Then NoNameditems = NoNameditems + 1
                    If trap > 0 Then trap = trap + 1
                Else
                    Exit Do
                End If
            Else
                Exit Do
            End If
        End If
        items = items + 1
        If UBound(var2()) < items Then ReDim Preserve var2(items + 1)
    End Select
    If Not FastSymbol(rest$, ",") Then Exit Do
Loop Until s$ = vbNullString
End Sub


Function ReadProp(fromIndex As Long, ByVal propIndex As Long, RETVAR As Variant) As Boolean
Dim o As Object, er$, usehandler As mHandler
On Error GoTo there
Set o = var(fromIndex)
If o Is Nothing Then

Exit Function
End If
If TypeOf o Is mHandler Then
Set usehandler = o
propIndex = -propIndex
If usehandler.UseIterator Then
Else
Set o = usehandler.objref
End If
Set usehandler = Nothing
End If
If o Is Nothing Then Exit Function
If TypeOf o Is PropReference Then
    If o.IsObj Then Set o = o.Value
End If
er$ = vbNullString
RETVAR = Empty
ReadProp = ReadOneParameter(o, propIndex, er$, RETVAR)
If MyIsObject(RETVAR) Then
If RETVAR Is Err Then
        Set errbag = New ErrorBag
        errbag.CopyErr
        Set RETVAR = errbag
        Set errbag = Nothing
        Err.Clear
End If
End If
If er$ <> "" Then
there:
BadGetProp
End If
End Function
Function ReadPropIndex(fromIndex As Long, ByVal propIndex As Long, myIndex As Variant, Optional maybeObject As Boolean, Optional retObj) As Variant
Dim o As Object, er$, check As Boolean, usehandler As mHandler
On Error GoTo there
Set o = var(fromIndex)
If o Is Nothing Then Exit Function
If TypeOf o Is mHandler Then
propIndex = -propIndex
Set usehandler = o
Set o = usehandler.objref
Set usehandler = Nothing
End If
er$ = vbNullString
check = True
If TypeOf o Is PropReference Then
Dim pp
pp = o.Value
Set o = o.lastobjfinal
End If
ReadPropIndex = ReadOneIndexParameter(o, propIndex, er$, myIndex, , check)

If Not check Then
    maybeObject = True
    ReadPropIndex = 0
    Set retObj = o
End If
If er$ <> "" Then
there:
BadGetProp
End If
End Function
Sub WriteProp(fromIndex As Long, ByVal propIndex As Long, Anyval As Variant)
Dim o As Object, er$, usehandler As mHandler
Set o = var(fromIndex)
If o Is Nothing Then Exit Sub
If TypeOf o Is mHandler Then
propIndex = -propIndex
Set usehandler = o
If usehandler.UseIterator Then
Else
Set o = usehandler.objref
End If
Set usehandler = Nothing
End If
'ChangeOneIndexParameter
ChangeOneParameter o, propIndex, Anyval, er$
If er$ <> "" Then
BadLetProp
End If
End Sub
Sub WritePropIndex(fromIndex As Long, ByVal propIndex As Long, Anyval As Variant, myIndex)
Dim o As Object, er$, usehandler As mHandler
Set o = var(fromIndex)
If o Is Nothing Then Exit Sub
If TypeOf o Is mHandler Then
propIndex = -propIndex
Set usehandler = o
Set o = usehandler.objref
Set usehandler = Nothing
End If
ChangeOneIndexParameter o, propIndex, Anyval, er$, myIndex
If er$ <> "" Then
BadLetProp
End If
End Sub
Function ReadPropIndexObj(o As Object, ByVal propIndex As Long, myIndex) As Variant
Dim er$
er$ = vbNullString
 ReadPropIndexObj = ReadOneIndexParameter(o, propIndex, er$, myIndex)
If er$ <> "" Then
BadGetProp
End If
End Function
Function ReadPropObj(o As Object, ByVal propIndex As Long, RETVAR As Variant) As Boolean
Dim er$
er$ = vbNullString
ReadPropObj = ReadOneParameter(o, propIndex, er$, RETVAR)
If MyIsObject(RETVAR) Then
If RETVAR Is Err Then
        Set errbag = New ErrorBag
        errbag.CopyErr
        Set RETVAR = errbag
        Set errbag = Nothing
        Err.Clear
End If
End If
If er$ <> "" Then
BadGetProp
End If
End Function
Sub WritePropObj(o As Object, ByVal propIndex As Long, Anyval As Variant)
Dim er$
ChangeOneParameter o, propIndex, Anyval, er$
If er$ <> "" Then
BadLetProp
End If
End Sub
Sub WritePropIndexObj(o As Object, ByVal propIndex As Long, Anyval As Variant, myIndex)
Dim er$
ChangeOneIndexParameter o, propIndex, Anyval, er$, myIndex
If er$ <> "" Then
BadLetProp
End If
End Sub

Sub MakeThisSub(ThatStack As basetask, rest$)

If Left$(rest$, 5) = "THIS." Then
Dim s$
If ThatStack.GetDotNew(s$, 1) Then

    rest$ = s$ & Mid$(rest$, 6)
    ElseIf ThatStack.GroupName = vbNullString Then
        rest$ = ThatStack.UseGroupname & Mid$(rest$, 6)
    Else
        rest$ = ThatStack.GroupName & Mid$(rest$, 6)
    End If

ElseIf Left$(rest$, 5) = "ауто." Then

If ThatStack.GetDotNew(s$, 1) Then

    rest$ = s$ & Mid$(rest$, 6)
    ElseIf ThatStack.GroupName = vbNullString Then
    rest$ = ThatStack.UseGroupname & Mid$(rest$, 6)

Else

    rest$ = ThatStack.GroupName & Mid$(rest$, 6)
End If

Else

End If
End Sub

Sub MakeThisSubNum(ThatStack As basetask, rest$)
If Left$(rest$, 1) = "T" Then
If Left$(rest$, 5) = "THIS." Then
    If Len(ThatStack.UseGroupname) > 0 Then
        rest$ = ThatStack.UseGroupname & Mid$(rest$, 6)
    Else
        rest$ = ThatStack.GroupName & Mid$(rest$, 6)
    End If
    End If
ElseIf Left$(rest$, 1) = "а" Then
If Left$(rest$, 5) = "ауто." Then
    If Len(ThatStack.UseGroupname) > 0 Then
       rest$ = ThatStack.UseGroupname & Mid$(rest$, 6)
    Else
        rest$ = ThatStack.GroupName & Mid$(rest$, 6)
    End If
End If
End If
End Sub
Function ColorHSL(bstack As basetask, n$, R As Variant) As Boolean
    Dim r2 As Variant, r3 As Variant, ss$, par As Boolean
    ColorHSL = True
    If IsExp(bstack, n$, R, , True) Then
        If FastSymbol(n$, ",") Then
            If IsExp(bstack, n$, r2, , True) Then
                If r2 < 0 Then r2 = 0
                If r2 > 100 Then r2 = 100
                If FastSymbol(n$, ",") Then
                    If IsExp(bstack, n$, r3, , True) Then
                        If r3 < 0 Then r3 = 0
                        If r3 > 100 Then r3 = 100
                        par = True
                        R = HSL(R, r2, r3)
                    End If
                End If
            End If
        End If
    End If
    If Not par Then ColorHSL = False: MissNumExpr: Exit Function
End Function
Function ColorRGB(bstack As basetask, n$, R As Variant) As Boolean
Dim r2 As Variant, r3 As Variant, ss$, par As Boolean
ColorRGB = True
    If IsExp(bstack, n$, R, , True) Then
            par = True
            If FastSymbol(n$, ",") Then
            par = IsExp(bstack, n$, r2, , True)
            If par And FastSymbol(n$, ",") Then
            par = IsExp(bstack, n$, r3, , True)
            End If
            R = rgb(Abs(R Mod 256), Abs(r2 Mod 256), Abs(r3 Mod 256))
            Else
            R = mycolor(R)
            End If
            If Not par Then ColorRGB = False: Exit Function
            
    ElseIf IsStrExp(bstack, n$, ss$) Then
            ' value in hexadecimal input as in html RGB
            ' we have to make BGR
    
            ss$ = Right$("00000000" & ss$, 8)
   R = CDbl(UNPACKLNG(Right$(ss$, 2)) * 65536#) + CDbl(UNPACKLNG(Mid$(ss$, 5, 2)) * 256#) + CDbl(UNPACKLNG(Mid$(ss$, 3, 2)))
   
         
             Else
              ColorRGB = False
              
    End If
End Function

Function globalArrByPointer(bs As basetask, basestack As basetask, what$, Optional newonly As Boolean = False, Optional checkforglobal As Boolean) As Boolean
Dim pppp As mArray, myobject As Object, wasAglobal As Boolean
   If bs.IsObjectRef(myobject) Then
   If newonly Then GoTo there1
   
             If neoGetArray(basestack, what$, pppp, , , , , wasAglobal) Then
             If Not checkforglobal Then If wasAglobal Then GoTo there1
                    If Not pppp Is Nothing Then
                        If TypeOf myobject Is mHandler Then
                        If CheckIsmArray(myobject) Then
                            Set var(varhash.lastNDX) = myobject
                            var(varhash.lastNDX).common = pppp.common
                            Else
                                  NotArray
                                  Exit Function
                        
                        End If
                        ElseIf TypeOf myobject Is mArray Then
                        myobject.CopyArray pppp
                        Else
                        NotArray
                        globalArrByPointer = False
                        Set myobject = Nothing
                        Exit Function
                        End If
                        Set myobject = Nothing
                        globalArrByPointer = True
                    End If
            Else
there1:
      
                GlobalArr basestack, basestack.GroupName & what$, "", 0, -1
                If neoGetArray(basestack, what$, pppp) Then  ''basestack.GroupName &
                        If TypeOf myobject Is mHandler Then
                        If CheckIsmArray(myobject) Then
                            Set var(varhash.lastNDX) = myobject
                                  Else
                                  NotArray
                                  Exit Function
                        
                        End If
                        ElseIf TypeOf myobject Is mArray Then
                        myobject.CopyArray pppp
                        Else
                        NotArray
                        globalArrByPointer = False
                        Set myobject = Nothing
                        Exit Function
                         End If
                         globalArrByPointer = True
                        Set myobject = Nothing
                End If
                
             End If
      
    End If
End Function
Public Sub CopyHandler(f As Variant, bstack As basetask)
Dim aa As mHandler, bb As mHandler
Set aa = f
aa.CopyTo bb
Set bstack.lastobj = bb
Set aa = Nothing
Set bb = Nothing
End Sub
Public Function CopyHandlerObj(f As Variant) As Object
Dim aa As mHandler, bb As mHandler
Set aa = f
aa.CopyTo bb
Set CopyHandlerObj = bb
Set aa = Nothing
Set bb = Nothing
End Function
Public Sub CopyLambdaAny(f As Variant, obj As Object)
Dim aa As lambda, bb As lambda
Set aa = f
aa.CopyTo bb, var()
Set obj = bb
Set aa = Nothing
Set bb = Nothing
End Sub
Public Sub CopyLambda(f As Variant, bstack As basetask)
Dim aa As lambda, bb As lambda
Set aa = f
aa.CopyTo bb, var()
Set bstack.lastobj = bb
Set aa = Nothing
Set bb = Nothing
End Sub

Public Sub CopyGroup2(mg As Variant, bstack As basetask)
Dim myGroup As Group
Set myGroup = mg
If myGroup.IamSuperClass Or myGroup.IamApointer Then
    Set bstack.lastobj = mg
    
    Exit Sub
End If
Dim Name$, k As Group, i As Long, j As Long, s$, v As Variant, w3 As Long
Dim B$(), vvl As Variant, delme As Document, myfirstArray As mArray, mySecondArray As mArray
Dim c$(), arrIndex As Long, choose$
Set k = New Group
Set k.Sorosref = myGroup.soros.Copy
Dim BI As Long
BI = 1

i = myGroup.soros.Total
k.BeginFloat i + 2
k.PokeItem 0, "Variables-Arrays"
k.PokeItem 1, i
For j = 2 To i * 2 + 1 Step 2
B$() = Split(k.soros.StackItem(BI), " ")
If Right$(B$(0), 1) = ")" Then
B$(0) = Left$(B$(0), Len(B$(0)) - 1)

End If
If Right$(B$(0), 1) <> "(" Then

k.PokeItem j, B$(0)

If Typename(var(val(B$(1)))) = doc Then 'preserve Documents
 MakeitObject vvl
 vvl.EmptyDoc
 vvl.textDoc = var(val(B$(1))).textDoc
 k.PokeItem j + 1, vvl
ElseIf Typename(var(val(B$(1)))) = mgroup Then
vvl = -1

CopyGroup2 var(val(B$(1))), bstack
Set vvl = bstack.lastobj
Set bstack.lastobj = Nothing
k.PokeItem j + 1, vvl
ElseIf Typename(var(val(B$(1)))) = mHdlr Then
Set vvl = CopyHandlerObj(var(val(B$(1))))
k.PokeItem j + 1, vvl
Else
k.PokeItem j + 1, var(val(B$(1)))
End If
Else


If val(B$(1)) = 0 Then
Set vvl = New mArray
ElseIf Typename$(var(val(B$(1)))) = "Empty" Then

ElseIf Typename$(var(val(B$(1)))) = myArray Then
    If Not var(val(B$(1))).common Then
        Set myfirstArray = var(val(B$(1)))
        Set mySecondArray = New mArray
        myfirstArray.CopyArray mySecondArray
        Set myfirstArray = Nothing
        Set vvl = mySecondArray
        Set mySecondArray = Nothing
    Else
        Set vvl = var(val(B$(1)))
    End If
Else
If MyIsObject(var(val(B$(1)))) Then Set vvl = var(val(B$(1)))

End If
k.PokeItem j, B$(0) + ")"
 k.PokeItem j + 1, vvl
Set vvl = Nothing


End If
BI = BI + 1
Next j
With myGroup
k.PokeItem j, myGroup.LocalList
k.PokeItem j + 1, GetFunctionList(.FuncList)
k.oldFuncRef = vbNullString
k.HasStrValue = .HasStrValue
k.HasValue = .HasValue
k.HasSet = .HasSet
k.HasParameters = .HasParameters
k.HasParametersSet = .HasParametersSet
k.HasRemove = .HasRemove
Set k.SuperClassList = .SuperClassList
Set k.Events = .Events
k.highpriorityoper = .highpriorityoper
k.HasUnary = .HasUnary
k.PointerPtr = ObjPtr(mg)
k.ToDelete = True
'Set k.mytypes = .mytypes
k.mergeTypes .mytypes
End With
Set bstack.lastobj = k
End Sub
Public Function CopyGroupObj(mg As Variant, Optional nofunc As Boolean = False) As Object
Dim myGroup As Group
Set myGroup = mg
If myGroup.IamSuperClass Or myGroup.IamApointer Then
    Set CopyGroupObj = myGroup
    
    Exit Function
End If
If myGroup.IamFloatGroup Then
    Set CopyGroupObj = myGroup
    
    Exit Function

End If
Dim Name$, k As Group, i As Long, j As Long, s$, v As Variant, w3 As Long
Dim B$(), vvl As Variant
Dim c$(), arrIndex As Long, choose$
Set k = New Group
Set k.Sorosref = myGroup.soros.Copy
Dim BI As Long
BI = 1

i = myGroup.soros.Total
k.BeginFloat i + 2
k.PokeItem 0, "Variables-Arrays"
k.PokeItem 1, i
For j = 2 To i * 2 + 1 Step 2
B$() = Split(k.soros.StackItem(BI), " ")
If Right$(B$(0), 1) = ")" Then
B$(0) = Left$(B$(0), Len(B$(0)) - 1)

End If
If Right$(B$(0), 1) <> "(" Then

k.PokeItem j, B$(0)



If Typename(var(val(B$(1)))) = doc Then 'preserve Documents
 MakeitObject vvl
 
 vvl.EmptyDoc
 vvl.textDoc = var(val(B$(1))).textDoc
 k.PokeItem j + 1, vvl
ElseIf Typename(var(val(B$(1)))) = mgroup Then
vvl = -1
Set vvl = CopyGroupObj(var(val(B$(1))))
k.PokeItem j + 1, vvl
ElseIf Typename(var(val(B$(1)))) = mHdlr Then
Set vvl = CopyHandlerObj(var(val(B$(1))))
k.PokeItem j + 1, vvl
Else
k.PokeItem j + 1, var(val(B$(1)))
End If
Else


If val(B$(1)) = 0 Then
Set vvl = New mArray
ElseIf Typename$(var(val(B$(1)))) = "Empty" Then
Else
Set vvl = var(val(B$(1)))

End If
k.PokeItem j, B$(0) + ")"
 k.PokeItem j + 1, vvl
Set vvl = Nothing


End If
BI = BI + 1
Next j
With myGroup
k.PokeItem j, myGroup.LocalList
'k.PokeItem j + 1, GetFunctionList(.FuncList)
If nofunc Then
' nothing
Else
    If ChangedFunctionList(.FuncList) Then
        k.PokeItem j + 1, GetFunctionList(.FuncList)
    Else
        If .oldFuncRef <> vbNullString Then
            k.PokeItem j + 1, .oldFuncRef
            k.oldFuncRef = vbNullString
        Else
            k.PokeItem j + 1, GetFunctionList(.FuncList)
        End If
    End If
End If
k.HasStrValue = .HasStrValue
k.HasValue = .HasValue
k.HasSet = .HasSet
k.HasParameters = .HasParameters
k.HasParametersSet = .HasParametersSet
k.HasRemove = .HasRemove
Set k.SuperClassList = .SuperClassList
Set k.Events = .Events
k.highpriorityoper = .highpriorityoper
k.HasUnary = .HasUnary
k.PointerPtr = ObjPtr(mg)
k.ToDelete = False
Set k.mytypes = .mytypes
End With
Set CopyGroupObj = k
End Function



Public Function CopyGroup0Obj(mg As Variant, usethisk As Variant) As Object
Dim myGroup As Group, grgroup As Group
Set myGroup = mg
Dim Name$, k As Group, i As Long, j As Long, s$, v As Variant, w3 As Long
Dim B$(), vvl As Variant
Dim c$(), arrIndex As Long, choose$
If TypeOf usethisk Is Group Then
Set k = usethisk
Else
Set k = New Group
End If

Dim BI As Long
BI = 1
i = myGroup.soros.Total
If Not k.IamFloatGroup Then Exit Function

k.PokeItem 0, "Variables-Arrays"


For j = 2 To i * 2 + 1 Step 2

B$() = Split(myGroup.soros.StackItem(BI), " ")
If Right$(B$(0), 1) = ")" Then
B$(0) = Left$(B$(0), Len(B$(0)) - 1)

End If
If Right$(B$(0), 1) <> "(" Then

If Typename(var(val(B$(1)))) = doc Then 'preserve Documents

ElseIf Typename(var(val(B$(1)))) = mgroup Then
vvl = -1

k.PeekItem j + 1, vvl
CopyGroup0Obj var(val(B$(1))), vvl

ElseIf Typename(var(val(B$(1)))) = mHdlr Then
Set vvl = CopyHandlerObj(var(val(B$(1))))
k.PokeItem j + 1, vvl
Else
k.PokeItem j + 1, var(val(B$(1)))
End If
Else


If val(B$(1)) = 0 Then
Set vvl = New mArray
ElseIf Typename$(var(val(B$(1)))) = "Empty" Then
Else
Set vvl = var(val(B$(1)))

End If
k.PokeItem j, B$(0) + ")"
 k.PokeItem j + 1, vvl
Set vvl = Nothing


End If
BI = BI + 1
Next j
Set CopyGroup0Obj = k

End Function
Public Function CopyGroup1(mg As Variant, usethisk As Variant) As Object
Dim myGroup As Group, grgroup As Group
Set myGroup = mg
Dim Name$, k As Group, i As Long, j As Long, s$, v As Variant, w3 As Long
Dim B$(), vvl As Variant
Dim c$(), arrIndex As Long, choose$
If TypeOf usethisk Is Group Then
Set k = usethisk
Else
Set k = New Group
End If

Dim BI As Long
BI = 1
i = myGroup.soros.Total
If Not k.IamFloatGroup Then Exit Function

k.PokeItem 0, "Variables-Arrays"

For j = 2 To i * 2 + 1 Step 2

B$() = Split(myGroup.soros.StackItem(BI), " ")
If Right$(B$(0), 1) = ")" Then
B$(0) = Left$(B$(0), Len(B$(0)) - 1)

End If
If Right$(B$(0), 1) <> "(" Then
If Typename(var(val(B$(1)))) = doc Then 'preserve Documents

ElseIf Typename(var(val(B$(1)))) = mgroup Then
vvl = -1

k.PeekItem j + 1, vvl
Set CopyGroup1 = CopyGroup1(var(val(B$(1))), vvl)

ElseIf Typename(var(val(B$(1)))) = mHdlr Then
Set vvl = CopyHandlerObj(var(val(B$(1))))
k.PokeItem j + 1, vvl
Else
k.PokeItem j + 1, var(val(B$(1)))
End If
Else


If val(B$(1)) = 0 Then
Set vvl = New mArray
ElseIf Typename$(var(val(B$(1)))) = "Empty" Then
Else
Set vvl = var(val(B$(1)))

End If
k.PokeItem j, B$(0) + ")"
 k.PokeItem j + 1, vvl
Set vvl = Nothing


End If
BI = BI + 1
Next j
Set CopyGroup1 = k
End Function
Sub UnFloatGroup(bstack As basetask, what$, i As Long, myobject1 As Object, Optional glob As Boolean = False, Optional Temp As Boolean = False, Optional MakeNew As Boolean)
Dim ThisGroup As Group, myobject As Group, it As Long
If (myobject1 Is Nothing) Then Exit Sub
If Not TypeOf myobject1 Is Group Then Exit Sub
Set myobject = myobject1

If myobject.IamApointer Then
    Set var(i) = myobject
    Exit Sub
End If
While Right$(what$, 1) = "."
    what$ = Left$(what$, Len(what$) - 1)
Wend
If Len(what$) = 0 Then Exit Sub
Dim ps As mStiva2, v As Long, s$, frm$, vvl As Variant, x1 As Long, ss$, frmarr$, sss$, j As Long
Dim grtype As Variant, ps2push As String, uni As Boolean, uni1 As Boolean, other As Group
Dim UnhidePrivate As Boolean

If bstack.tpointer <> 0 Then
If Typename(var(bstack.tpointer)) = mgroup Then
Set other = myobject
Set ThisGroup = var(bstack.tpointer)
UnhidePrivate = other.MatchTypes(ThisGroup.mytypes)
Set other = Nothing
End If
End If
Set var(i) = New Group
Set ThisGroup = var(i)
 ' ThisGroup.FlushEvents '   (it is a new one)
ThisGroup.IamGlobal = glob
' check this again
ThisGroup.ToDelete = myobject.ToDelete
If Not myobject.SuperClassList Is Nothing Then
    Set ThisGroup.SuperClassList = myobject.SuperClassList
    If myobject Is Nothing Then Exit Sub
    If myobject.IamSuperClass Then Set myobject = myobject.SuperClassList: uni = True
End If
Set ps = ThisGroup.soros
Dim subgroup As Object, pppp As mArray
Dim ohere$, oldgroupname$
ohere$ = here$

oldgroupname$ = bstack.GroupName
If bstack.GroupName <> "" Then

If Len(ohere$) = 0 Then
    ThisGroup.Patch = what$
Else
    ThisGroup.Patch = ohere$ + "." + what$
    End If
    bstack.GroupName = bstack.GroupName + what$ + "."
    
Else
    bstack.GroupName = what$ + "."
    If glob Or Len(ohere$) = 0 Then
    ThisGroup.Patch = what$
    Else
    ThisGroup.Patch = ohere$ + "." + what$
    End If
End If

With myobject
ThisGroup.HasRemove = .HasRemove
    If .IamFloatGroup Then
        .PeekItem 0, grtype
        .PeekItem 1, vvl
        For x1 = 2 To 1 + vvl * 2 Step 2
            .PeekItem x1, vvl    'here is the name
            s$ = vvl
            
            If s$ = vbNullString Then InternalError: s$ = "asap"
            If Temp Then If Left$(s$, 1) = "@" Then s$ = Mid$(s$, 2)
            If uni Then
                uni1 = Left$(s$, 1) = "@"
                If Temp And uni1 Then
                    uni1 = False: s$ = Mid$(s$, 2)
                End If
            End If
            If uni1 Then GoTo cont1010
            .PeekItem x1 + 1, vvl  'here is the value
                frm$ = Typename(vvl)
                If frm$ = myArray Then
                    s$ = Left$(s$, Len(s$) - 1)
                    ss$ = vbNullString
                    j = -1
                    If Temp Then
                    
                        GlobalArr bstack, ThisGroup.Patch + "." + s$, ss$, 0, j, True
                        Set var(j) = vvl
                    Else
                          Set subgroup = vvl
                          GlobalArr bstack, ThisGroup.Patch + "." + s$, ss$, 0, j, True
                          Set pppp = var(j)
                          subgroup.CopyArray pppp
                          Set subgroup = Nothing
                    End If
                    '
                    If AscW(s$) = -65 And UnhidePrivate Then
                    varhash.ItemCreator ThisGroup.Patch + "." + Mid$(s$, 2), j, True, , True
                    End If
                    ps.DataStr s$ + Str$(j)
                ElseIf frm$ = "lambda" Then
                    v = globalvarGroup(ThisGroup.Patch + "." + s$, 0, , True)
                    If AscW(s$) = -65 And UnhidePrivate Then
                        varhash.ItemCreator ThisGroup.Patch + "." + Mid$(s$, 2), v, True, , True
                        it = GlobalSub(ThisGroup.Patch + "." + Mid$(s$, 2) + "()", "", ThisGroup.Patch + ".", , v)
                    Else
                        it = GlobalSub(ThisGroup.Patch + "." + s$ + "()", "", ThisGroup.Patch + ".", , v)
                        End If
                        sbf(it).tpointer = i
                    GoTo conthere2
                ElseIf frm$ = mHdlr Then
                    Set vvl = CopyHandlerObj(vvl)
                    GoTo conthere1
                ElseIf frm$ = "mEvent" Then
                    CopyEvent vvl, bstack
                    Set vvl = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    If here$ = vbNullString Then
                        vvl.Upgrade bstack.GroupName
                    Else
                        vvl.Upgrade here$ + "." + bstack.GroupName
                    End If
                    GoTo conthere1
                Else  ' is not array so...
                    If frm$ = mgroup Then
                        Set other = vvl
                        Dim spare As Object
                        If Left$(s$, 1) = "*" Then
                            v = globalvarGroup(ThisGroup.Patch + "." + Mid$(s$, 2), 0, , True)
                            If AscW(Mid$(s$, 2, 1)) = -65 And UnhidePrivate Then
                                globalvarGroup ThisGroup.Patch + "." + Mid$(s$, 3), v, True, True
                            End If
                            If other.IamApointer Then
                                If ThisGroup.ToDelete Then
                                   myobject.PokeItem x1 + 1, 0
                                   other.ToDelete = True
                                End If
                                Set var(v) = vvl
                            Else
                                Set spare = vvl
                                here$ = ThisGroup.Patch
                                ' check this too
                                
                                    other.ToDelete = ThisGroup.ToDelete
                                
                                If AscW(Mid$(s$, 2, 1)) = -65 And UnhidePrivate Then
                                    UnFloatGroup bstack, Mid$(s$, 3), v, spare, glob, Temp, MakeNew
                                Else
                                    UnFloatGroup bstack, Mid$(s$, 2), v, spare, glob, Temp, MakeNew
                                End If
                                here$ = ohere$
                                Set other = Nothing
                                
    
                                Set spare = Nothing
                            End If
                            ps.DataStr s$ + Str(v)
                        Else
                            v = globalvarGroup(bstack.GroupName & s$, 0)
                            Set spare = vvl
                            here$ = ThisGroup.Patch
                            UnFloatGroup bstack, s$, v, spare, glob, Temp, MakeNew
                            here$ = ohere$
                            Set spare = Nothing
                            ps.DataStr "*" + s$ + Str(v)
                        End If
                    Else
                        If Right$(s$, 2) = "()" Then
                            s$ = Left$(s$, Len(s$) - 1)
                        End If
conthere1:
                       
                        v = globalvarGroup(ThisGroup.Patch + "." + s$, 0, , True)
                        If UnhidePrivate And AscW(s$) = -65 Then
                        globalvarGroup ThisGroup.Patch + "." + Mid$(s$, 2), v, True, True
                        End If
conthere2:
                        If MyIsObject(vvl) Then
                            Set var(v) = vvl
                        Else
                            var(v) = vvl
                        End If
                        ps.DataStr s$ + Str(v)
                    End If
                End If
            'End If
cont1010:
        Next x1
        If ohere$ = vbNullString Or Len(bstack.UseGroupname) > 0 Or glob Then
            here$ = vbNullString
        Else
            here$ = ohere$
        End If
        If MyIsObject(vvl) Then
        Set vvl = Nothing
        End If
        .PeekItem x1, vvl
        If Trim$(vvl) <> "" Then
            s$ = CStr(vvl)
            ExecuteGroupStruct bstack, what$, (i), s$, 0, 1
        End If
        .PeekItem x1 + 1, vvl
        ' save definitions
        ThisGroup.oldFuncRef = vvl
        If Trim$(vvl) <> "" Then
            s$ = CStr(vvl)
            bstack.GroupName = vbNullString
            While s$ <> ""
                here$ = ThisGroup.Patch
                x1 = IsLabelA1("", s$, ss$)
                
                If x1 <> 0 Then
                    sss$ = s$
                    If Len(ss$) > 6 Then
                    j = 0
                        x1 = IsLabelA1("", s$, ss$)
                        If UnhidePrivate And AscW(ss$) = -65 Then
                        Mid$(sss$, Len(sss$) - Len(s$) - Len(ss$) + 1, 1) = " "
                        End If
                        frm$ = vbNullString
                        If MyFunction(-2 * (&H1FFF = AscW(ss$)), bstack, sss$, 1, True, MakeNew) Then '' >6 len for function
                            x1 = bstack.IndexSub
                            If FastSymbol(sss$, ChrW(&H1FFD)) Then
                                sbf(x1).locked = True
                                frm$ = " " + Str$(-x1)
                            Else
                                frm$ = Str$(x1)
                            End If
                            If Asc(s$) <> 32 Then
                                If InStr(s$, " ") = 2 Then
                                    ss$ = ss$ + Left$(s$, 1)
                                    s$ = Mid$(s$, 2)
                                Else
                                    ss$ = ss$ + Left$(s$, 2)
                                    s$ = Mid$(s$, 3)
                                End If
                            End If
                            If sbf(x1).sbgroup = here$ + "." Then
                                If InStr(ThisGroup.FuncList, Chr$(2) + ss$ + "() ") = 0 Then
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + "()" + frm$ + Chr$(1) + ThisGroup.FuncList
                                End If
                            Else
                                ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + "()" + frm$ + Chr$(1) + ThisGroup.FuncList
                                sbf(x1).sbgroup = here$ + "."
                                sbf(x1).tpointer = i
                            End If
                        Else
                            x1 = 0
                        End If
                    Else
                        x1 = IsLabelA1("", s$, ss$)
                        If UnhidePrivate And AscW(ss$) = -65 Then
                        Mid$(sss$, Len(sss$) - Len(s$) - Len(ss$) + 1, 1) = " "
                        End If
                        If MyModule(bstack, sss$, 1, True, MakeNew) Then
                            x1 = bstack.IndexSub
                            sbf(x1).sbc = 1
                            If FastSymbol(sss$, ChrW(&H1FFD)) Then
                                sbf(x1).locked = True
                                frm$ = " " + Str$(-x1)
                            Else
                                frm$ = Str$(x1)
                            End If
                            If sbf(x1).sbgroup = here$ + "." Then
                                If InStr(ThisGroup.FuncList, Chr$(2) + ss$ + "() ") = 0 Then
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + Str(x1) + Chr$(1) + ThisGroup.FuncList
                                End If
                            Else
                                If sbf(x1).locked Then
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + frm$ + Chr$(1) + ThisGroup.FuncList
                                Else
                                    ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + frm$ + Chr$(1) + ThisGroup.FuncList
                                End If
                                sbf(x1).sbgroup = here$ + "."
                                sbf(x1).tpointer = i
                            End If
                        Else
                            x1 = 0
                        End If
                    End If
                    sss$ = NLtrim$(sss$) + " "
                    While AscW(sss$) = 13
                        SetNextLine sss$
                        sss$ = NLtrim$(sss$) + " "
                    Wend
                    If Len(bstack.UseGroupname) > 0 Or glob Then
                        here$ = vbNullString
                    Else
                       here$ = ohere$
                    End If
                    s$ = sss$
                Else
                    s$ = vbNullString
                End If
            Wend
        End If
    End If
End With
With ThisGroup
    .GroupName = what$ + "."
    .FloatGroupName = myobject.FloatGroupName
    If myobject.HasStrValue Then
        GlobalVarRefLink2 here$ + "$", i, glob
    End If
    .HasStrValue = myobject.HasStrValue
    .HasValue = myobject.HasValue
    .HasSet = myobject.HasSet
    .HasParameters = myobject.HasParameters
    .HasParametersSet = myobject.HasParametersSet
    Set .Events = myobject.Events
    .highpriorityoper = myobject.highpriorityoper
    .HasUnary = myobject.HasUnary
    .HasRemove = myobject.HasRemove Or .HasRemove
    Set .mytypes = myobject.mytypes
End With
SwapStrings here$, ohere$
bstack.GroupName = oldgroupname$
End Sub
Sub UnFloatGroupReWriteVars(bstack As basetask, what$, i As Long, myobject1 As Object, Optional mergesuper As Boolean = False, Optional MakeNew As Boolean, Optional bypassnew As Boolean = False)
Dim ThisGroup As Group, ohere$, addon As Boolean, myobject As Group
If myobject1 Is Nothing Then Exit Sub
If Not TypeOf myobject1 Is Group Then Exit Sub
Set myobject = myobject1
Set ThisGroup = var(i)
If myobject.IamApointer Then
    If ThisGroup.IamApointer Then Set var(i) = myobject: Exit Sub
    If myobject.link.IamFloatGroup And ThisGroup.soros.Total = 0 Then
        Set var(i) = myobject
        Exit Sub
    ElseIf myobject.link.IamFloatGroup Then
    If myobject.link Is NullGroup Then
        Set myobject = New Group
        myobject.BeginFloat 0
        myobject.EndFloat
    Else
        Set myobject = CopyGroupObj(myobject.link)
        End If
    Else
        SwapStrings ohere$, here$
        here$ = myobject.lasthere
        If GetVar(bstack, myobject.GroupName, i, , , True) Then
            CopyGroup2 myobject.link, bstack
        End If
        SwapStrings here$, ohere$
        If bstack.lastobj Is Nothing Then Exit Sub
        If Not TypeOf bstack.lastobj Is Group Then Exit Sub
        Set myobject = bstack.lastobj
        Set bstack.lastobj = Nothing
    End If
End If
If ThisGroup.IamApointer Then
    If ThisGroup.link.IamFloatGroup Then
        Set var(i).link = myobject
    Else
        SyntaxError
    End If
    Exit Sub
End If
While Right$(what$, 1) = "."
    what$ = Left$(what$, Len(what$) - 1)
Wend
If Len(what$) = 0 Then Exit Sub
If Not bypassnew Then
If Len(ThisGroup.Patch) > 0 Then

If Len(bstack.UseGroupname) > 0 Then
If bstack.tpointer = i Then
    bypassnew = bstack.ErrVars > bstack.tpointer
Else
bypassnew = (Left(ThisGroup.Patch, Len(bstack.UseGroupname)) = bstack.UseGroupname And Not bstack.nokillvars)
End If
End If
End If
End If
Dim ps As mStiva2, v As Long, s$, frm$, vvl As Variant, x1 As Long, ss$, frmarr$, sss$, j As Long
Dim grtype As Variant, ps2push As String, ff$, uni As Boolean, limit As Long   ' TT As Long
Set ps = var(i).soros
Dim subgroup As Object, pppp As mArray
Dim oldgroupname$, glob As Boolean
ohere$ = here$  ' get a backup

 glob = ThisGroup.IamGlobal
 uni = myobject.IamSuperClass
  If Not myobject.SuperClassList Is Nothing Then
  
 Set ThisGroup.SuperClassList = myobject.SuperClassList
 
  If myobject.IamSuperClass Then Set myobject = myobject.SuperClassList
 End If
If Len(bstack.UseGroupname) > 0 Or glob Then
    If Not glob Then
Else
here$ = vbNullString
End If

'If glob Then here$ = VbNullString
End If
 oldgroupname$ = bstack.GroupName
 
    If bstack.GroupName <> "" Then
  bstack.GroupName = bstack.GroupName & what$ & "."
  Else
  bstack.GroupName = what$ & "."
  End If
            If myobject Is Nothing Then GoTo exithere1
            With myobject
            ThisGroup.HasRemove = .HasRemove Or ThisGroup.HasRemove
            If Not .IamFloatGroup Then GoTo exithere1
            If .IamFloatGroup Then
                 addon = bstack.ErrVars < i Or Not glob
                .PeekItem 0, grtype
                .PeekItem 1, vvl
                For x1 = 2 To 1 + vvl * 2 Step 2
                    .PeekItem x1, vvl    'here is the name
                    s$ = vvl
                    If uni Then
                        If Left$(s$, 1) = "@" Then
                            If mergesuper Then
                                    s$ = Mid$(s$, 2)
                                Else
                                GoTo cont1010
                            End If
                        End If
                    End If
                    .PeekItem x1 + 1, vvl  'here is the value
                    If MyIsObject(vvl) Then
                        If vvl Is Nothing Then
                            GoTo cont1010
                        ElseIf TypeOf vvl Is mArray Then
                            s$ = Left$(s$, Len(s$) - 1)
                            ss$ = vbNullString
                            If here$ = vbNullString And Len(bstack.UseGroupname) > 0 Then
                                If neoGetArrayLinkOnly(bstack, bstack.UseGroupname + s$, j) Then GoTo conthere1111
                            End If
                            
                            If Not neoGetArrayLinkOnly(bstack, ThisGroup.Patch + "." + s$, j) Then
                                If bypassnew Then GoTo cont1010
                                j = -1
                                Set subgroup = vvl
                                
                                GlobalArr bstack, ThisGroup.Patch + "." + s$, ss$, 0, j, True
                                Set pppp = var(j)
                                subgroup.CopyArray pppp
                                Set subgroup = Nothing
                            Else
conthere1111:
                                Set subgroup = vvl
                                Set pppp = var(j)
                                subgroup.CopyArray pppp
                                Set subgroup = Nothing
                            End If
                            If addon Then ps.DataStrUn s$ + Str$(j)
                ElseIf TypeOf vvl Is lambda Then
                    If GetVar1(bstack, bstack.GroupName & s$, v) And here$ = vbNullString Then
                    ElseIf Not GetVar1(bstack, s$, v) Then
                        If bypassnew Then GoTo cont1010
                        v = globalvarGroup(bstack.GroupName & s$, 0)
                        If here$ = vbNullString Then
                            GlobalSub bstack.GroupName & s$ + "()", "", bstack.GroupName, , v
                        Else
                            GlobalSub here$ & "." & bstack.GroupName & s$ + "()", "", here$ + "." + bstack.GroupName, , v
                        End If
                    End If
                    Set var(v) = vvl
                    If addon Then ps.DataStrUn s$ + Str(v)
                Else  ' is not array so...
                    '' drop *
                    If AscW(s$) = 42 Then s$ = Mid$(s$, 2)
                    ps2push = bstack.GroupName + s$
                    If GetVar1(bstack, ps2push, v) Then
                    ElseIf GetVar1(bstack, here$ + "." + ps2push, v) Then
                    ElseIf Not GetVar1(bstack, s$, v) Then
                        If bypassnew Then GoTo cont1010
                        v = globalvarGroup(ps2push, 0)
                    End If
                    If TypeOf vvl Is Group Then
                        Dim spare As Object
                        Set spare = vvl
                        
                        If Typename(var(v)) <> mgroup Then
                        
                        ss$ = here$
                        If Len(bstack.GroupName) > 1 Then
                            here$ = bstack.GroupName
                            here$ = Left$(here$, Len(here$) - 1)
                            
                        End If

                            
                            UnFloatGroup bstack, s$, v, spare, , , MakeNew
                            here$ = ss$
                        Else
                            UnFloatGroupReWriteVars bstack, s$, v, spare, , MakeNew, bypassnew
                        End If
                        Set spare = Nothing
                        If addon Then ps.DataStrUn "*" + s$ + Str(v)
                        GoTo cont1010
                    ElseIf TypeOf vvl Is mHandler Then
                        Set vvl = CopyHandlerObj(vvl)
                    ElseIf TypeOf vvl Is mEvent Then
                        CopyEvent vvl, bstack
                        Set vvl = bstack.lastobj
                        Set bstack.lastobj = Nothing
                        If here$ = vbNullString Then
                            vvl.Upgrade bstack.GroupName
                        Else
                            vvl.Upgrade here$ + "." + bstack.GroupName
                        End If
                    ElseIf TypeOf vvl Is Constant Then
                    If Typename(var(v)) = "Constant" Then GoTo cont1010
                    End If
                    Set var(v) = vvl
                    If addon Then ps.DataStrUn s$ + Str(v)
                End If
            Else
                If AscW(s$) = 42 Then s$ = Mid$(s$, 2)  ' CHECK THIS FOR ERROR
                ps2push = bstack.GroupName + s$
                If GetVar1(bstack, ps2push, v) Then
                ElseIf GetVar1(bstack, here$ + "." + ps2push, v) Then
                ElseIf Not GetVar1(bstack, s$, v) Then
                    If bypassnew Then GoTo cont1010
                    v = globalvarGroup(ps2push, 0)
                End If
                var(v) = vvl
                If addon Then ps.DataStrUn s$ + Str(v)
            End If
cont1010:
        Next x1
    End If
    If ohere$ = vbNullString Or glob Then
        here$ = vbNullString
    Else
       here$ = ohere$
    End If
    .PeekItem x1, vvl
    If Trim$(vvl) <> "" Then
        s$ = CStr(vvl)
        ExecuteGroupStruct bstack, what$, (i), s$, 0, 1
    End If
    .PeekItem x1 + 1, vvl
    If Trim$(vvl) <> "" Then
        s$ = CStr(vvl)
        bstack.GroupName = vbNullString
        While s$ <> ""
            If ohere$ = vbNullString Or glob Then
                here$ = oldgroupname$ + what$
            Else
                here$ = ohere$ + "." + oldgroupname$ + what$
            End If
            x1 = IsLabelA1("", s$, ss$)
            If x1 <> 0 Then
                sss$ = s$
                If Len(ss$) > 6 Then
                        x1 = IsLabelA1("", s$, ss$)
                        frm$ = vbNullString
                        If MyFunction(-2 * (&H1FFF = AscW(ss$)), bstack, sss$, 1, True, MakeNew, , bypassnew) Then     '' >6 len for function
                        If Asc(s$) <> 32 Then
                            If InStr(s$, " ") = 2 Then
                                ss$ = ss$ + Left$(s$, 1)
                                s$ = Mid$(s$, 2)
                            Else
                                ss$ = ss$ + Left$(s$, 2)
                                s$ = Mid$(s$, 3)
                            End If
                        End If
                            x1 = bstack.IndexSub
                            sbf(x1).Changed = True
                        If FastSymbol(sss$, ChrW(&H1FFD)) Then
                            sbf(x1).locked = True
                            frm$ = " " + Str$(-x1)
                        Else
                            frm$ = Str$(x1)
                        End If
                        If Not sbf(x1).sbgroup = here$ + "." Then
                            If addon Then ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + "()" + frm$ + Chr$(1) + ThisGroup.FuncList
                            sbf(x1).sbgroup = here$ + "."
                            sbf(x1).tpointer = i
                        End If
                    Else
                        x1 = 0
                    End If
                Else
                    x1 = IsLabelA1("", s$, ss$)
                    If MyModule(bstack, sss$, 1, True, MakeNew, , , bypassnew) Then
                        x1 = bstack.IndexSub
                        sbf(x1).sbc = 1
                        sbf(x1).Changed = True
                        If FastSymbol(sss$, ChrW(&H1FFD)) Then
                            sbf(x1).locked = True
                            frm$ = " " + Str$(-x1)
                        Else
                            frm$ = Str$(x1)
                        End If
                        If Not sbf(x1).sbgroup = here$ + "." Then
                            If addon Then ThisGroup.FuncList = Chr$(1) + Chr$(2) + ss$ + frm$ + Chr$(1) + ThisGroup.FuncList
                            sbf(x1).sbgroup = here$ + "."
                            sbf(x1).tpointer = i
                        End If
                    Else
                        x1 = 0
                    End If
                End If
                sss$ = NLtrim$(sss$) + " "
                While AscW(sss$) = 13
                    SetNextLine sss$
                    sss$ = NLtrim$(sss$) + " "
                Wend
                If Len(bstack.UseGroupname) > 0 Or glob Then
                    here$ = vbNullString
                Else
                   here$ = ohere$
                End If
                s$ = sss$
            Else
                s$ = vbNullString
            End If
        Wend
    End If
End With
With ThisGroup
    .IamCleared = False
    .HasValue = myobject.HasValue Or .HasValue
    .HasSet = myobject.HasSet Or .HasSet
    .HasStrValue = myobject.HasStrValue Or .HasStrValue
    .HasParameters = myobject.HasParameters Or .HasParameters
    .HasParametersSet = myobject.HasParametersSet Or .HasParametersSet
    If Not myobject.Events Is Nothing Then
        If .Events Is Nothing Then
            Set .Events = myobject.Events
        End If
    End If
    .highpriorityoper = MergeOperators(myobject.highpriorityoper, .highpriorityoper)
    .HasUnary = myobject.HasUnary Or .HasUnary
    .HasRemove = myobject.HasRemove Or .HasRemove
    If Not bypassnew Then
    .mergeTypes myobject.mytypes
    End If
End With

exithere1:
SwapStrings here$, ohere$
bstack.GroupName = oldgroupname$

End Sub
Function ChangedFunctionList(ByVal s$) As Boolean
ChangedFunctionList = True
Exit Function
Dim c$, k$(), Final As Long
Do While s$ <> "" And Not ChangedFunctionList
If ISSTRINGA(s$, c$) Then ChangedFunctionList = sbf(Abs(val(Split(c$, " ")(1)))).Changed
Loop

End Function


Function GetFunctionList(ByVal s$) As String
Dim c$, f$, k$(), qq$, Final As Long, tmp$, oldl As Long, mtrim As Long
Dim final2 As Long
While s$ <> ""
If ISSTRINGA(s$, c$) Then
k$() = Split(c$, " ")
Final = val(k$(1))
If Not Right$(sbf(Abs(Final)).sb, 2) = vbCrLf Then
qq$ = vbCrLf
End If
final2 = Final < 0
If Right$(k$(0), 1) = ")" Then
If UBound(k$) = 2 Then
f$ = "Function " + Mid$(k$(0), 2, Len(k$(0)) - 3) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + ChrW(&H1FFD) + ChrW(&H1FFD) + f$

Else
If final2 Then
f$ = "Function " + Mid$(k$(0), 2, Len(k$(0)) - 3) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + ChrW(&H1FFD) + f$
Else
f$ = "Function " + Mid$(k$(0), 2, Len(k$(0)) - 3) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + f$
End If
End If
Else
If final2 Then
f$ = "Module " + Mid$(k$(0), 2, Len(k$(0)) - 1) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + ChrW(&H1FFD) + f$
Else
f$ = "Module " + Mid$(k$(0), 2, Len(k$(0)) - 1) + " {" + sbf(Abs(Final)).sb + qq$ + "}" + f$
End If
End If
End If

Wend
GetFunctionList = f$
End Function
Sub ResetFunctionList(s$)
Dim c$, k$(), Final As Long
While s$ <> ""
If ISSTRINGA(s$, c$) Then
k$() = Split(c$, " ")
Final = val(k$(1))
With sbf(Abs(Final))
.sb = vbNullString
.sbc = 0

.sbgroup = vbNullString
.goodname = vbNullString
.locked = False
.tpointer = 0
.IamAClass = False
Set .subs = Nothing
End With
End If
Wend

End Sub
Sub MakeMyTitle(s$, Lang As Long)
     If InStr(s$, "(") > 0 Then
            If shortlang Then
            If Lang Then Form1.TEXT1.Title = "F. " + s$ + " F12 " Else Form1.TEXT1.Title = "с. " + s$ + " "
            Else
            If Lang Then Form1.TEXT1.Title = "Function " + s$ + " F12 " Else Form1.TEXT1.Title = "сУМэЯТГСГ " + s$ + " "
            End If
            Else
            If shortlang Then
            If Lang Then Form1.TEXT1.Title = "M. " + s$ + " F12 " Else Form1.TEXT1.Title = "т. " + s$ + " "
            Else
            If Lang Then Form1.TEXT1.Title = "Module " + s$ + " F12 " Else Form1.TEXT1.Title = "тЛчЛА " + s$ + " "
            End If
            End If
End Sub
Function SBcode(i As Long) As String
If i < 0 Then
SBcode = var(-i).code$
Else
SBcode = sbf(i).sb
End If
End Function
Function GlobalHandler(basestack As basetask, rest$, Lang As Long, typeHandler As Long) As Boolean
Dim x1 As Long, ss$, i As Long, s$, what$, par As Boolean
Do
x1 = Abs(IsLabel(basestack, rest$, what$))
If x1 <> 1 Then GlobalHandler = False: Exit Function
ss$ = here$
here$ = vbNullString

i = globalvar(basestack.GroupName & what$, s$, , True)
Select Case typeHandler
Case 1
MakeitObjectInventory var(i)
here$ = ss$
If FastSymbol(rest$, "=") Then
Set basestack.lastobj = var(i)
GlobalHandler = AddInventory(basestack, rest$)
Exit Function
End If
Case 2
MakeitObjectBuffer var(i)
here$ = ss$
Case 3
MakeitObjectInventory var(i), True
here$ = ss$
If FastSymbol(rest$, "=") Then
Set basestack.lastobj = var(i)
GlobalHandler = AddInventory(basestack, rest$)
Exit Function
End If

Case Else
here$ = ss$
End Select
Loop Until Not FastSymbol(rest$, ",")
If rest$ <> "" Then
If Not MaybeIsSymbol(rest$, ":" + vbCr) Then
SyntaxError
Else
GlobalHandler = True
End If
Else
GlobalHandler = True
End If

 


End Function
Function GlobalEVENT(basestack As basetask, rest$, Lang As Long) As Boolean
Dim x1 As Long, ss$, i As Long, s$, what$

x1 = Abs(IsLabel(basestack, rest$, what$))
If x1 <> 1 Then GlobalEVENT = False: Exit Function
ss$ = here$
here$ = vbNullString
i = globalvar(basestack.GroupName & what$, s$, , True)
MakeitObjectEvent var(i)
here$ = ss$
GlobalEVENT = ProcEvent(basestack, rest$, Lang, i)
 


End Function

Function dimString(typo$) As String
Dim pppp As mArray, pp, i As Long, p, lim As Long
Dim B$(), vl$
B$() = Split(typo$, " ")

Set pppp = var(val(B$(1)))
      pppp.SerialItem pp, CLng(p), 5
         Dim a$()
         If pp < 1 Then dimString$ = B$(0) + ")": Exit Function
         ReDim a$(pp - 1)
      For i = 0 To pp - 1
      pppp.GetDnum i, p, lim
      'pppp.SerialItem p, i, 6
      a$(i) = Trim$(Str$(-lim)) + " TO " + Trim$(Str$(p - lim - 1))
      Next i
      pppp.SerialItem p, CLng(0), 2
      If InStr(B$(0), "$") > 0 Then
      vl$ = "{" + CStr(p) + "} "
      Else
      If IsNumeric(p) Then
       vl$ = "=" + Str(p) + " "
       Else
       vl$ = "=0 "
      End If
      End If
      If pp > 1 Then
      dimString = B$(0) + Join(a$(), ",") + ")" + vl$
      Else
      dimString = B$(0) + a$(0) + ")" + vl$
      End If
End Function
Sub LogGroup(bstack As basetask, vvv As Long, ohere$, OvarnameLen As Long, lcl As Boolean, ByPass As Boolean, unique As Boolean)
If ByPass Then GoTo bye

'unique = False

'
Dim ss$, w$, i As Long, nm$, nt$, CM$, nt1$, j As Long, k As Long, dropit As Long
Dim s() As String
      With var(vvv)

  
        
        If here$ <> "" Then
        w$ = UCase(here$ & "." & ohere$ & ".")
        Else
        w$ = UCase(ohere$ & ".")
        End If
            If OvarnameLen <= varhash.count Then
                    
            For i = OvarnameLen To varhash.count  ' or not
            
                 varhash.ReadVar i - 1, ss$, dropit
                 
                If Left(ss$, Len(w$)) = w$ Then
                j = dropit
                    nt$ = Typename$(var(j))
                 If Not lcl Then
                                         If nt$ = mgroup Then
                                         If Right$(ss$, 1) <> "$" Then
                                         
                                        .soros.DataStr "*" + Mid$(ss$, Len(w$) + 1) + Str(j)
                                        Else
                                        
                                        End If
                                        Else
                                        If unique Then
                                        .soros.DataStr "@" + Mid$(ss$, Len(w$) + 1) + Str(j)
                                        Else
                                        .soros.DataStr Mid$(ss$, Len(w$) + 1) + Str(j)
                                        End If
                                       
                                        End If
                            Else
                             nm$ = Mid$(ss$, Len(w$) + 1)
                          
                                If nt1$ <> nt$ Then .LocalList = .LocalList + vbCrLf: CM$ = vbNullString
                           If i = OvarnameLen Then CM$ = "Local " Else CM$ = ", "
                           If nt$ = "Long" Then
                           If CM$ = "," Then nt1$ = vbNullString Else nt1$ = nt$ + " "
                           .LocalList = .LocalList + CM$ + nt1$ + nm$ + "=" + Trim$(Str(var(j)))
                           ElseIf nt$ = myArray Then
                            .LocalList = .LocalList + vbCrLf + "local DIM " + dimString(nm$ + Str$(j)) + vbCrLf
                           ElseIf nt$ = doc Then
                           If CM$ = "," Then nt1$ = vbNullString Else nt1$ = nt$ + " "
                           .LocalList = .LocalList + CM$ + nt1$ + nm$ + "=" + "{" + CStr(var(j)) + "}"
                           ElseIf InStr(nm$, "$") Then
                                .LocalList = .LocalList + CM$ + nm$ + "=" + "{" + CStr(var(j)) + "}"
                           Else
                                .LocalList = .LocalList + CM$ + nm$ + "=" + CStr(var(j))
                            End If
                            nt1$ = nt$
                End If
                End If
            Next i

            If lcl Then .LocalList = .LocalList + vbCrLf
            End If
        
           
           '
           

End With
bye:
OvarnameLen = varhash.count + 1 'Len(VarName$) + 1   'we record ...AGAIN

End Sub
Function FindNameForGroup(bstack As basetask, w$) As Boolean
Dim ss() As String, w2 As Long
  If InStr(w$, ChrW(&H1FFF)) > 0 Then
        If InStr(w$, ".") > 0 Then
        ss() = Split(w$, ".")
            If GetVar(bstack, ss(0), w2) Then
                If Typename(var(w2)) = mgroup Then
                   If var(w2).FloatGroupName <> "" Then ss(0) = var(w2).FloatGroupName: FindNameForGroup = True
                   w$ = Join(ss(), ".")
                            If InStr(w$, ChrW(&H1FFF)) > 0 Then
                             w$ = vbNullString
                            Else
                             FindNameForGroup = True
                             End If
                 Else
                 w$ = vbNullString
                End If
                                 Else
                 w$ = vbNullString
            End If
                             Else
                 w$ = vbNullString
    End If
    End If
End Function
Sub i3MouseIcon(basestack As basetask, rest$, Lang As Long)
On Error Resume Next
Dim Scr As Object, s$, X As Double, aPic As StdPicture, i As Long
Set Scr = basestack.Owner

If basestack.toprinter Then
    oxiforPrinter
Else
        If IsLabelSymbolNew(rest$, "йяуье", "HIDE", Lang) Then
                    If FastSymbol(rest$, "!") Then
                    Set Form1.mouseicon = Form1.Picture2.mouseicon
                    Form1.mousepointer = 99
                    Set Form1.DIS.mouseicon = Form1.Picture2.mouseicon
                    Form1.DIS.mousepointer = 99
                    For i = 1 To PobjNum
                    Set Form1.dSprite(i).mouseicon = Form1.Picture2.mouseicon
                    Form1.dSprite(i).mousepointer = 99
                    Next i
                    Else
                    Set Scr.mouseicon = Form1.Picture2.mouseicon
                    Scr.mousepointer = 99
                    With players(GetCode(Scr))
                        .HideIcon = True
                    End With
                End If
                 
        ElseIf IsLabelSymbolNew(rest$, "деине", "SHOW", Lang) Then
            If FastSymbol(rest$, "!") Then
                    
                    With players(-1)
                    
                    If Form1.mouseicon = Form1.Picture2.mouseicon And Not .HideIcon Then
                        Form1.mousepointer = .LastIcon
                        Set Form1.mouseicon = .LastIconPic
                        
                        End If
                    End With
                    
                    With players(0)
                    If Form1.DIS.mouseicon = Form1.Picture2.mouseicon And Not .HideIcon Then
                        Form1.DIS.mousepointer = .LastIcon
                        Set Form1.DIS.mouseicon = .LastIconPic
                        End If
                    End With
                    For i = 1 To PobjNum
                    
                    With players(val("0" & Form1.dSprite(i).Tag))
                        If Form1.dSprite(i).mouseicon = Form1.Picture2.mouseicon And Not .HideIcon Then
                        Form1.dSprite(i).mousepointer = .LastIcon
                       Set Form1.dSprite(i).mouseicon = .LastIconPic
                        End If
                    End With
                    Next i
                    
            Else
                
                    With players(GetCode(Scr))
                    If Scr.mouseicon = Form1.Picture2.mouseicon Then
                     .HideIcon = False
                     If .LastIcon = 99 And Scr.mousepointer = 99 Then
                        Set Scr.mouseicon = .LastIconPic
                     ElseIf .LastIcon = 99 Then
                        Set Scr.mouseicon = .LastIconPic
                        Scr.mousepointer = 99
                     Else
                        Scr.mousepointer = .LastIcon
                     End If
                     
                      
                     
                    End If
                    End With
                End If
                
        ElseIf IsStrExp(basestack, rest$, s$) Then
                If s$ <> vbNullString Then
                    s$ = CFname(s$)
                    If s$ <> vbNullString Then
                    If LCase(Right$(s$, 4)) = ".ico" Or LCase(Right$(s$, 4)) = ".cur" Then
                        Set aPic = LoadPicture(GetDosPath(s$))
                    Else
                        
                        Set aPic = LoadMyPicture(GetDosPath(s$))
                        End If
                        
                        If aPic Is Nothing Then MissCdib: Exit Sub
                        If Not FastSymbol(rest$, ";") Then
                        If LCase(Right$(s$, 4)) = ".ico" Then Set Scr.mouseicon = Form1.Picture2.mouseicon: Scr.mousepointer = 99
                        End If
                        Set Scr.mouseicon = aPic
                        Scr.mousepointer = 99
                        With players(GetCode(Scr))
                            Set .LastIconPic = aPic
                            .LastIcon = 99
                        End With
                    Else
                    MissFile
                    End If
                Else
                    Set Scr.mouseicon = Nothing
                    Scr.mousepointer = 1
                    With players(GetCode(Scr))
                        Set .LastIconPic = Nothing
                        .LastIcon = 1
                    End With
                End If
                
                
    ElseIf IsExp(basestack, rest$, X) Then
                basestack.LastState = False
                On Error Resume Next
                If CLng(X) = 99 Then
                With players(GetCode(Scr))
                If .LastIconPic Is Nothing Then
                Set Scr.mouseicon = Form1.PrinterDocument1.mouseicon
                Set .LastIconPic = Form1.PrinterDocument1.mouseicon
                Else
                Set Scr.mouseicon = .LastIconPic
                End If
                Scr.mousepointer = 99
                
                    .LastIcon = CLng(X)
                End With
                Else
                Scr.mousepointer = CLng(X)
                If Err Then MyEr "Bad icon bumber", "пЯЭБКГЛА ЛЕ ТОМ АЯИХЛЭ": Err.Clear: Exit Sub
                With players(GetCode(Scr))
                    .LastIcon = CLng(X)
                End With
                End If
    Else
             MyEr "Missing  filename or icon number", "кЕъПЕИ ЭМОЛА АЯВЕъОУ ч АЯИХЛЭР ЕИЙОМИДъОУ"
    End If
End If
End Sub
Function procTestMe(bstack As basetask, rest$, what$) As Boolean
Dim ss$
procTestMe = True

If Not Form1.Visible Then
newshow Basestack1
k1 = 0
End If
If FastSymbol(rest$, "!") Then
untest:
If trace Then
With Form2
    If pagio$ = "GREEK" Then
    .gList2.HeadLine = "╦КЕЦВОР"
    Else
    .gList2.HeadLine = "Control"
    End If
    If TestShowCode And here$ <> "" Then
        Form2.gList3(2).BackColor = &H606060
    Else
        Form2.gList3(2).BackColor = &H3B3B3B
        End If
    .label1(0) = vbNullString
    .label1(1) = vbNullString
    .label1(2) = vbNullString
    .Hide
     Set .Process = Nothing
     End With
 
STq = False
STEXIT = False
STbyST = False
trace = False
End If
Exit Function
End If
If bypassST Then GoTo bb1
    STq = False
    STEXIT = False
    STbyST = True
    Form2.Show , Form1

If here$ = vbNullString Then

 TestShowSub = vbNullString
 TestShowStart = 0
 Form2.testpad.Text = vbNullString
 Form2.testpad.Show
 Form2.testpad.SetRowColumn 1, 1
 
 End If
MyDoEvents
' gList2.HeadLine
 If bstack.IamLambda Then
  If pagio$ = "GREEK" Then
  Form2.label1(0) = "сумаятгсг калда"
  Else
  Form2.label1(0) = "LAMBDA FUNCTION"
  End If
  Else
Form2.label1(0) = GetName$(here$)
End If
Form2.label1(1) = what$
Form2.label1(2) = GetStrUntil(vbCrLf, rest$ & vbCrLf, False)
Dim back$
bb1:
If ISSTRINGA(rest$, ss$) Then IsSymbol rest$, ","
If ss$ <> "" Then
With Form2
    If pagio$ = "GREEK" Then
        .gList2.HeadLine = "╦КЕЦВОР: " + ss$
    Else
        .gList2.HeadLine = "Control: " + ss$
    End If
 If Not bypassST Then TestShowCode = True
End With

If TestShowCode And here$ <> "" Then

Form2.gList3(2).BackColor = &H606060
If Len(TestShowSub) >= WaitShow And WaitShow > 0 Then
        TestShowStart = rinstr(TestShowSub, Mid$(rest$, 2)) - 1
Else
    WaitShow = 0
    
    ss$ = GetNextLine((sbf(Abs(bstack.OriginalCode)).sb))
    If Left$(ss$, 10) = "'11001EDIT" Then
    
    TestShowSub = Mid$(sbf(Abs(bstack.OriginalCode)).sb, Len(ss$) + 3)
    Else
         TestShowSub = ss$
    End If
    If bstack.addlen Then
        If Len(TestShowSub) - bstack.addlen - Len(rest$) > 0 Then
            TestShowStart = Len(TestShowSub) - bstack.addlen - Len(rest$) + 1
        Else
            TestShowStart = 1
        End If
    Else
        TestShowStart = Len(TestShowSub) - Len(rest$) + 1
    End If
    If TestShowStart <= 0 Then
        TestShowStart = rinstr(TestShowSub, Mid$(rest$, 2)) - 1
    End If
    
    End If
Else
 TestShowSub = vbNullString
 End If
 Set Form2.Process = bstack
stackshow bstack
MyDoEvents
Form1.Show , Form5
Form2.gList2.RefreshNow
what$ = vbNullString
If FastPureLabel(rest$, what$, , , , , False) = 1 Then
rest$ = ": " + rest$
If Not trace Then
trace = True

procTestMe = Execute(bstack, what$, True) = 1
GoTo untest
Else


End If
ElseIf what$ <> "" Then
com1020:
Dim m As Long, s$
Do
m = 1

 what$ = aheadstatus(rest$, , m)

 If m > 1 Then
 If Asc(LTrim(Left$(rest$, m))) < 32 Then Exit Do
 STq = True
 If s$ <> "" Then
 s$ = s$ + ", " + LTrim$(Left$(rest$, m - 1))
 Else
s$ = s$ + LTrim$(Left$(rest$, m - 1))
End If
Mid$(rest$, 1, m - 1) = space$(m - 1)
STbyST = False
End If
If Not FastSymbol(rest$, ",") Then Exit Do
Loop Until m = 1
If Not Form2.Visible Then Form2.Show , Form1
Form2.Compute.vartext = s$
rest$ = NLtrim(rest$)
trace = True


TestShowCode = False
Form2.gList4.ListIndex = 1
End If

Else
If FastPureLabel(rest$, what$, , , , , False) = 1 Then
TestShowCode = True
rest$ = ": " + rest$
trace = True
 Set Form2.Process = bstack
stackshow bstack
MyDoEvents
Form1.Show , Form5
Else
GoTo com1020
End If

End If

End Function
Function procMotionW(bstack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, myform As GuiM2000, where As Long
Dim Scr As Object
If TypeOf bstack.Owner Is GuiM2000 Then
procMotionW = True
Set myform = bstack.Owner
myform1:
where = FindFormSScreen(myform)
  If Not IsExp(bstack, rest$, X) Then X = myform.Left
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, Y) Then procMotionW = False: Exit Function
        Else
        
        Y = myform.Top
    End If
    If FastSymbol(rest$, ";") Then
    X = ((ScrInfo(where).Width - 1) - myform.Width) / 2 + ScrInfo(where).Left
    Y = ((ScrInfo(where).Height - 1) - myform.Height) / 2 + ScrInfo(where).Top
    If X < ScrInfo(where).Left Then X = ScrInfo(where).Left
    If Y < ScrInfo(where).Top Then Y = ScrInfo(where).Top
    End If
    
myform.move X, Y
ElseIf val("0" + bstack.Owner.Tag) > 32 Then
Set Scr = bstack.Owner.Parent
If Scr Is Nothing Then Exit Function
While Not TypeOf Scr Is GuiM2000
Set Scr = Scr.Parent
If Scr Is Nothing Then Exit Function
Wend
procMotionW = True
Set myform = Scr
GoTo myform1
ElseIf TypeOf bstack.Owner Is MetaDc Then
oxiforMetaFiles
Exit Function
Else
'If Not Form1.Visible Then Exit Function
procMotionW = True
'Form1.Visible = True
'If Form3.Visible Then Form3.skiptimer = True: Form3.WindowState = 0
Console = FindFormSScreen(Form1)

If Form1.WindowState <> 0 Then Form1.WindowState = 0 ': mydoevents
If IsWine Then Sleep 50: Form1.SetFocus

If Form1.WindowState = 0 Then
    If Not IsExp(bstack, rest$, X) Then X = Form1.Left
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, Y) Then procMotionW = False: Exit Function
        Else
        
        Y = Form1.Top
    End If
    
    If FastSymbol(rest$, ";") Then
    X = ((ScrInfo(Console).Width - 1) - Form1.Width) / 2 + ScrInfo(Console).Left
    Y = ((ScrInfo(Console).Height - 1) - Form1.Height) / 2 + ScrInfo(Console).Top
    End If
' LETS MOVE

If IsWine And Form1.Width = ScrInfo(Console).Width Then Form1.Width = ScrInfo(Console).Width - dv15
If Form1.Top > VirtualScreenHeight() - 100 Then Form1.Top = ScrInfo(Console).Top
If IsWine Then
If X = ScrInfo(Console).Left And Y = ScrInfo(Console).Top Then
Form1.move X, Y
If form5iamloaded Then Form5.RestorePos
Sleep 10
End If
End If
Form1.move X, Y
If form5iamloaded Then Form5.RestorePos
Console = FindFormSScreen(Form1)
    If FastSymbol(rest$, ";") Then
    X = ((ScrInfo(Console).Width - 1) - Form1.Width) / 2 + ScrInfo(Console).Left
    Y = ((ScrInfo(Console).Height - 1) - Form1.Height) / 2 + ScrInfo(Console).Top
    If X < ScrInfo(where).Left Then X = ScrInfo(where).Left
    If Y < ScrInfo(where).Top Then Y = ScrInfo(where).Top
    If Form1.Top > VirtualScreenHeight() - 100 Then Form1.Top = ScrInfo(Console).Top
    Form1.move X, Y
    End If
Form1.Up
If IsWine Then Sleep 10
End If
End If
End Function
Function procLineSpace(bstack As basetask, rest$) As Boolean
Dim X As Double
procLineSpace = True
If IsExp(bstack, rest$, X) Then

    If CLng(X) < 0 Or CLng(X) > 60 * dv15 Then
    OutOfLimit
    Else
    X = (X \ 30) * 60
    X = CLng(X) / 2
    
   SetText bstack.Owner, CLng(X)
    
    End If
ElseIf FastSymbol(rest$, "!") Then
   SetText bstack.Owner, 4 * Screen.TwipsPerPixelY
Else
MissNumExpr
procLineSpace = False

Exit Function
End If


End Function

Function ProcLabel(basestack As basetask, rest$) As Boolean
Dim s$, frm$, p As Variant, X As Double, Y As Double, sX As Double, sY As Double
Dim Scr As Object, prive As basket
Set Scr = basestack.Owner
prive = players(GetCode(Scr))
ProcLabel = True
If Not IsStrExp(basestack, rest$, s$) Then Exit Function


frm$ = Replace(s$, ChrW(&HFFFFF8FB), ChrW(&H2007))
s$ = vbNullString
X = 0
If FastSymbol(rest$, ",") Then
    If Not IsStrExp(basestack, rest$, s$) Then
    If TypeOf Scr Is GuiM2000 Then
        If Len(prive.FontName) > 0 Then
            s$ = prive.FontName
        Else
            s$ = Scr.Controls(1).FontName
        End If
    Else
    s$ = prive.FontName
    End If
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, X) Then
         If TypeOf Scr Is GuiM2000 Then
                 If Len(prive.FontName) > 0 Then
                    X = prive.SZ
                 Else
                    X = Scr.Controls(1).FontSize
                End If
         Else
            X = prive.SZ
        End If
        End If
        
            Y = 0
            
                If FastSymbol(rest$, ",") Then
                    If Not IsExp(basestack, rest$, p) Then p = 0
                  If FastSymbol(rest$, ",") Then
                    If IsExp(basestack, rest$, sY) Then
                        nPlain basestack, frm$, s$, X, Y, CLng(p), True, CLng(sY \ DXP)
                    Else
                        nPlain basestack, frm$, s$, X, Y, CLng(-p - 1)
                    End If
                 Else
                    nPlain basestack, frm$, s$, X, Y, CLng(-p - 1)
                 End If
                Else
                    nPlain basestack, frm$, s$, X, Y, -1
                End If
    Else
        nPlain basestack, frm$, s$, X, 0, -1
    End If
Else
nPlain basestack, frm$, prive.FontName, prive.SZ, X, -1
End If
PlaceBasket Scr, prive
End Function
Function ProcLegend(basestack As basetask, rest$) As Boolean
Dim s$, frm$, p As Variant, X As Double, Y As Double, sX As Double, sY As Double
Dim Scr As Object, prive As basket
Set Scr = basestack.Owner
prive = players(GetCode(Scr))
ProcLegend = True
If FastSymbol(rest$, "!") Then
ProcLegend = False
If IsStrExp(basestack, rest$, s$) Then
      If InStr(s$, ChrW(&HFFFFF8FB)) > 0 Then s$ = Replace(s$, ChrW(&HFFFFF8FB), ChrW(&H2007))

    ProcLegend = True
    If Not FastSymbol(rest$, ",") Then ProcLegend = False: Exit Function
    If IsExp(basestack, rest$, p) Then
    X = p
    If Not FastSymbol(rest$, ",") Then
    Y = 1
    ElseIf Not IsExp(basestack, rest$, Y) Then
       ProcLegend = False: Exit Function
    End If
    Else
    X = prive.mx
    If Not FastSymbol(rest$, ",") Then ProcLegend = False: Exit Function
    If Not IsExp(basestack, rest$, Y) Then ProcLegend = False: Exit Function
    End If
    wPlain Scr, prive, s$, (X), Y - 1
End If
Else
If Not IsStrExp(basestack, rest$, s$) Then Exit Function


frm$ = Replace(s$, ChrW(&HFFFFF8FB), ChrW(&H2007))
s$ = vbNullString
X = 0
If FastSymbol(rest$, ",") Then
If Not IsStrExp(basestack, rest$, s$) Then Exit Function
End If
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, X) Then Exit Function
End If
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, Y) Then Exit Function
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, p) Then Exit Function
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, sX) Then Exit Function
If FastSymbol(rest$, ",") Then
If Not IsExp(basestack, rest$, sY) Then Exit Function
nPlain basestack, frm$, s$, X, Y, CLng(p), sX <> False, CLng(sY \ DXP)
Else
nPlain basestack, frm$, s$, X, Y, CLng(p), sX <> False
End If
Else
nPlain basestack, frm$, s$, X, Y, CLng(p)
End If
Else
nPlain basestack, frm$, s$, X, Y
End If
Else

nPlain basestack, frm$, s$, X
End If
End If
If FastSymbol(rest$, ";") Then
''NO REFRESH
Else
If Not extreme Then If Not basestack.toprinter Then MyRefresh basestack ' MyDoEvents1 Scr
End If
PlaceBasket Scr, prive
End Function

Function ProcPrinting(basestack As basetask, rest$, Lang As Long) As Boolean
Dim xp As Printer, Scr As Object
Set Scr = basestack.Owner
  ProcPrinting = True
 If ThereIsAPrinter = False Then Exit Function
If IsLabelSymbolNew(rest$, "маи", "ON", Lang) And pname <> "" And Not basestack.toprinter Then
                            basestack.toprinter = True
                            For Each xp In Printers
                            If xp.DeviceName = pname And xp.Port = Port Then Set Printer = xp
                            Next xp
                            getfirstpage

                            Set Scr = Form1.PrinterDocument1
                            
                            If players(-2).Xt = 0 Then
                            players(-2) = players(0)  'COPY dis
                            With players(-2)
                                .curpos = 0
                                .currow = 0
                                .XGRAPH = 0
                                .YGRAPH = 0
                              Form1.PrinterDocument1.FontSize = .SZ * szFactor
                              .SZ = Form1.PrinterDocument1.FontSize
                            End With
                            
                            End If
                            
                            PlaceBasket Form1.PrinterDocument1, players(-2)
                            SetText Form1.PrinterDocument1
                            ''SetTextSZ scr, players(0).SZ
                            LCTbasket Form1.PrinterDocument1, players(-2), 0, 0
                            Printer.currentX = 0
                            Printer.currentY = 0
ElseIf IsLabelSymbolNew(rest$, "ови", "OFF", Lang) And basestack.toprinter Then
                    getenddoc
                    Set Scr = Form1.DIS
                    basestack.toprinter = False
                    SetNormal Scr
                    
ElseIf IsLabelSymbolNew(rest$, "диейоье", "BREAK", Lang) And basestack.toprinter Then
                    pnum = 0
                    oprinter.ClearUp
                    Form1.PrinterDocument1.Picture = LoadPicture("")
                    Set Scr = Form1.DIS
                    basestack.toprinter = False
                    SetNormal Scr
                    Else
                    ProcPrinting = False
                    End If
Exit Function


End Function

Function ExecuteEmfBlock(basestack As basetask, rest$, it As Long, ww, hh) As Object
Dim mDC As New MetaDc, Scr As Object, prive As basket
Dim oldprintFlag As Boolean, bNo&, nd&, OldGDILines As Boolean, once As Boolean
Set Scr = basestack.Owner
bNo = GetCode(Scr)
prive = players(bNo)
oldprintFlag = basestack.toprinter
If oldprintFlag Then basestack.toprinter = False
Dim www As Long, hhh As Long
www = ww
hhh = hh
mDC.create prive.mypen, www, hhh
ww = www
hh = hhh
prive.IamEmf = True
Set mDC.Font = Scr.Font
GetCode mDC
players(mDC.prive) = prive
With players(mDC.prive)
If ww <> 0 Then .MAXXGRAPH = CLng(ww)
If hh <> 0 Then .MAXYGRAPH = CLng(hh)
mDC.Width = .MAXXGRAPH
mDC.Height = .MAXYGRAPH
.curpos = 0
.currow = 0
.XGRAPH = 0
.YGRAPH = 0
End With

Set basestack.Owner = mDC
SetText mDC

If Not TaskMaster Is Nothing Then
If TaskMaster.Processing Or TaskMaster.QueueCount <> 0 Then
 TaskMaster.StopProcess
End If
End If
  '  OldGDILines = GDILines
  '  GDILines = True
            Call executeblock(it, basestack, rest$, False, once, , True)
   ' GDILines = OldGDILines
    If it = 2 Then
        If rest$ = "" Then
            If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
        Else
            rest$ = ": Goto " + rest$
            If trace Then WaitShow = 2: TestShowSub = rest$
        End If
        
                it = 1
        End If
   

    players(mDC.prive) = Zero
    players(mDC.prive).used = False
    
    Set basestack.Owner = Scr

    If it = 0 Then
    MyEr "Problem in drawing", "пЯЭБКГЛА СТО СВщДИО"
    
    End If
        Set ExecuteEmfBlock = mDC.getEmfObj()
If oldprintFlag Then basestack.toprinter = True
        If Not TaskMaster Is Nothing Then
            If TaskMaster.Processing Or TaskMaster.QueueCount <> 0 Then
                TaskMaster.StartProcess
            End If
        End If


End Function
Function ProcLayer(basestack As basetask, rest$) As Boolean
Dim i As Long, p As Variant, x1 As Long, y1 As Long, X As Double, Y As Double
Dim s$, f As Long, pa$, sX As Double, it As Long, w3 As Long, ya As Long, AddTwipsTopL As Long
Dim Scr As Object, scr1 As Object, nd&, oldprintFlag As Boolean, oldBackFlag As Boolean
Dim prive As basket, orig As Long
oldprintFlag = basestack.toprinter
If oldprintFlag Then basestack.toprinter = False
oldBackFlag = basestack.toback
If oldBackFlag Then basestack.toback = False
ProcLayer = True
Set Scr = basestack.Owner
prive = players(GetCode(Scr))  ' backup
If Not IsExp(basestack, rest$, p) Then
    prive = players(0)
    p = 0 ' dis
    Set basestack.lastobj = Nothing
End If
If basestack.lastobj Is Nothing Then
    If p > 32 Or p < 0 Then p = 0 ' dis
    Else
        If Typename(basestack.lastobj) = mHdlr Then
            i = basestack.lastobj.indirect
            If i >= 0 And i <= var2used Then
                If MyIsObject(var(i)) Then
                    Set scr1 = var(i)
                    p = GetCode(scr1)
                    If TypeOf scr1 Is GuiM2000 Then
                    ElseIf TypeOf scr1 Is GuiImage Then
                        Set scr1 = Scr.pbox
                        scr1.Tag = CLng(p)
                    End If
                    If p = 0 Then
                        Set scr1 = Nothing
                    End If
                Else
                    Set scr1 = Nothing
                    p = 0
                End If
            End If
        Else
            Set scr1 = basestack.lastobj
            p = GetCode(scr1)
            If TypeOf scr1 Is GuiM2000 Then
            ElseIf TypeOf scr1 Is GuiImage Then
                Set scr1 = scr1.pbox
                scr1.Tag = CLng(p)
            End If
            If p = 0 Then
                Set scr1 = Nothing
            End If
        End If
    End If
    Set basestack.lastobj = Nothing
    w3 = basestack.tolayer
    basestack.tolayer = CLng(p)
    If lookOne(rest$, "{") Then
    If p > 32 Then
        If players(p).MAXXGRAPH = 0 Then
            SetTextBasketBack scr1, players(0)
            If TypeOf scr1 Is VB.PictureBox Then
            scr1.Cls
            
            End If
            SetText scr1, prive.MineLineSpace, True
            With players(p)
            .ShowCaret = False
            .italics = False
            .bold = False
            .curpos = 0
            .currow = 0
            .mysplit = 0
            .osplit = 0
            .XGRAPH = 0
            .YGRAPH = 0
            .lastprint = True
            .Paper = Form1.DIS.BackColor
            .mypen = players(0).mypen
            .mypentrans = players(0).mypentrans
            .ReportTab = ReportTabWidth
            End With
            With Prefresh(p)
            .k1 = uintnew(timeGetTime + REFRESHRATE): .RRCOUNTER = 1
            End With
            scr1.BackColor = Form1.DIS.BackColor
            scr1.currentX = 0
            scr1.currentY = 0
         End If
    ElseIf p > 0 Then
        f = FindSpriteByTag(CLng(p))
        If f = 0 Then
        f = GetNewLayerObj(CLng(p), Scr.Width, Scr.Height)
        SetTextBasketBack Form1.dSprite(f), prive   ' load form prive to dSprite
        With players(p)
            Form1.dSprite(f).Font.Italic = .italics
            Form1.dSprite(f).Font.bold = .bold
        End With
        SetText Form1.dSprite(f), prive.MineLineSpace, True    'load Players() with first values
        With players(p)
            .curpos = 0
            .currow = 0
            .mysplit = 0
            .osplit = 0
            .Paper = Form1.DIS.BackColor
            .mypen = players(0).mypen
            .mypentrans = players(0).mypentrans
            .ReportTab = ReportTabWidth
        End With
    With Prefresh(p)
        .k1 = uintnew(timeGetTime + REFRESHRATE): .RRCOUNTER = 1
        End With
    Form1.dSprite(f).BackColor = Form1.DIS.BackColor
End If
orig = p
p = f
End If


If p = 0 Then
Set basestack.Owner = Form1.DIS

ElseIf p < 33 Then
Set basestack.Owner = Form1.dSprite(p)
Else
Set basestack.Owner = scr1
End If
nd& = basestack.addlen
it = Execute(basestack, rest$, False, True, , True)
basestack.addlen = nd&
            If it = 2 Then
                        If rest$ = "" Then
                        rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                        Else
                        rest$ = ": Goto " + rest$
                         If trace Then WaitShow = 2: TestShowSub = rest$
                        End If
                        it = 1
                        End If
MyDoEvents2 basestack.Owner
GdiFlush
basestack.tolayer = w3
Set basestack.Owner = Scr
If it = 0 Then
ProcLayer = False
End If
End If
If oldprintFlag Then basestack.toprinter = True
If oldBackFlag Then basestack.toback = True


End Function
Sub procthreads(Scr As Object, bstack As basetask, rest$, Lang As Long)
If TaskMaster Is Nothing Then Exit Sub
If TaskMaster.QueueCount >= 0 Then

If IsLabelSymbolNew(rest$, "сбгсе", "ERASE", Lang) Then
TaskMaster.Dispose
bstack.ThrowThreads
Exit Sub
End If
If Lang = 0 Then
        PlainBaSket Scr, players(GetCode(Scr)), "NHMATA се епенеяцасиа:" & CStr(TaskMaster.QueueCount)
        Else
        PlainBaSket Scr, players(GetCode(Scr)), "THREADS PROCESSING:" & CStr(TaskMaster.QueueCount)
        End If
        If bstack.ThreadsStr(Lang) <> "" Then
        crNew bstack, players(GetCode(Scr))
        PlainBaSket Scr, players(GetCode(Scr)), bstack.ThreadsStr(Lang)
        End If
Else
        If Lang = 0 Then
        PlainBaSket Scr, players(GetCode(Scr)), "типота се епенеяцасиа"
        Else
        PlainBaSket Scr, players(GetCode(Scr)), "NOTHING PROCESSING"
        End If
End If
crNew bstack, players(GetCode(Scr))
' was mydoevents 2
MyDoEvents1 Scr
Set Scr = Nothing
End Sub

Function ProcPage(basestack As basetask, rest$, Lang As Long) As Boolean
ProcPage = True
Dim Scr As Object, X As Double, skip As Boolean
Set Scr = basestack.Owner
If basestack.toprinter Then getnextpage: skip = True
If IsLabelSymbolNew(rest$, "йахетг", "PORTRAIT", Lang, , , , False) Then
    Portrait basestack
ElseIf IsLabelSymbolNew(rest$, "ояифомтиа", "LANDSCAPE", Lang, , , , False) Then
    Landscape basestack
ElseIf IsNumber(basestack, rest$, X) Then
    If X = 1 Then Portrait basestack Else Landscape basestack
ElseIf Not skip Then
    ClearScr Scr, mycolor(PaperOne)
End If
Set Scr = Nothing
End Function

Function ProcMotion(basestack As basetask, rest$, Lang As Long) As Boolean
Dim Scr As Object, x1 As Long, y1 As Long, p As Variant
Set Scr = basestack.Owner
ProcMotion = True
If Lang = 1 And IsLabelSymbolLatin(rest$, "CENTER") Then
ProcMotion = ProcMode(basestack, Str$(players(GetCode(Scr)).SZ) & "," & Str$(Scr.Width) & "," & Str$(Scr.Height))
ElseIf IsLabelSymbol(rest$, "йемтяо") Then
ProcMotion = ProcMode(basestack, Str$(players(GetCode(Scr)).SZ) & "," & Str$(Scr.Width) & "," & Str$(Scr.Height))
Else
If IsExp(basestack, rest$, p) Then x1 = CLng(p) Else x1 = Scr.Left
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p) Then
y1 = CLng(p)
Else
Set Scr = Nothing
ProcMotion = False
Exit Function
End If
Else
y1 = Scr.Top
End If
Scr.move x1, y1
End If
MyRefresh basestack
 'MyDoEvents1 Scr
Set Scr = Nothing


End Function


Function ProcPen(basestack As basetask, rest$) As Boolean
Dim Scr As Object, x1 As Long, y1 As Long, p As Variant, ss$, it As Long, nd&, once As Boolean
ProcPen = True
Set Scr = basestack.Owner
If IsExp(basestack, rest$, p, , True) Then
    If FastSymbol(rest$, "{") Then
        ss$ = block(rest$)
        TraceStore basestack, nd&, rest$, 0
        rest$ = Mid$(rest$, 2)
        
         y1 = GetCode(Scr)
            x1 = players(y1).mypen
           
            players(y1).mypen = CLng(mycolor(p))
            TextColor Scr, players(y1).mypen
            
            Call executeblock(it, basestack, ss$, False, once, , True)
            TraceRestore basestack, nd&
            players(y1).mypen = x1
            TextColor Scr, x1
                If it = 2 Then
                If ss$ = "" Then
                    If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                Else
                    rest$ = ": Goto " + ss$
                    If trace Then WaitShow = 2: TestShowSub = rest$
                End If
                
                        it = 1
                End If
            If it <> 1 Then ProcPen = False: rest$ = ss$ + rest$
        
    Else
    Dim mp As Long
            mp = CLng(mycolor(p))
         With players(GetCode(Scr))
                        p = .mypentrans
            If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, , True) Then
                p = Abs(p): If p > 255 Then p = 255
                
                End If
            
            End If
     
       .mypen = mp
       .mypentrans = CLng(p)
       End With
        
        TextColor Scr, mp
    End If
Else
    If FastSymbol(rest$, ",") Then
     If IsExp(basestack, rest$, p, , True) Then
                p = Abs(p): If p > 255 Then p = 255
                players(GetCode(Scr)).mypentrans = CLng(p)
                ProcPen = True
                Exit Function
         End If
    End If
    ProcPen = False
End If
Set Scr = Nothing
End Function

Function blockStringAhead(s$, pos1 As Long) As Long
Dim i As Long, j As Long, c As Long
c = Len(s$)
i = pos1
If i > c Then blockStringAhead = c: Exit Function
Do

Select Case AscW(Mid$(s$, i, 1))
Case 34
Do While i < c
i = i + 1
If AscW(Mid$(s$, i, 1)) = 34 Then Exit Do

Loop
Case 123
j = j - 1
Case 125
j = j + 1: If j = 0 Then Exit Do
End Select
i = i + 1
Loop Until i > c
If j = 0 Then
pos1 = i
blockStringAhead = True
Else
blockStringAhead = False
End If


End Function



Function ProcEdit(basestack As basetask, rest$, Lang As Long) As Boolean
Dim s$, x1 As Long, y1 As Long, o As Long, frm$, i As Long, par As Boolean, p As Variant
Dim Scr As Object, ss$, prev$, bb As CodeBlock
ProcEdit = True
If FastSymbol(rest$, "!") Then
If FastSymbol(rest$, "!") Then SHOWCODE = Not SHOWCODE
If IsExp(basestack, rest$, p, , True) Then
EditTabWidth = Abs(p)

If Not FastSymbol(rest$, ",") Then Exit Function
End If
ProcEdit = False
Exit Function
End If
If Not (basestack.IamChild Or basestack.IamAnEvent) Then abt = False: mHelp = False: lastAboutHTitle = vbNullString
Set Scr = basestack.Owner
If Left$(Typename(Scr), 3) = "Gui" Then oxiforforms: Exit Function
If TypeOf basestack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
Form1.EditTextWord = False ' edit code
Form1.TEXT1.TabWidth = EditTabWidth
Form1.TabControl = EditTabWidth
s$ = aheadstatus(rest$, False, y1)
If y1 > 2 And Left$(s$, 1) = "S" Then
If Mid$(rest$, y1 - 1, 1) = "(" Or Mid$(rest$, y1 - 2, 2) = "()" Then s$ = "ok"

End If

If Left$(s$, 1) = "S" Then
    
    If IsStrExp(basestack, rest$, s$) Then
        If s$ <> "" Then
            If ExtractPath(s$) = vbNullString Then
                If CFname(s$) <> "" Then
                    s$ = CFname(s$)
                ElseIf mylcasefILE(s$) = ExtractName(s$, True) Then
                    s$ = mcd + s$
                End If
                If ExtractType(s$) = vbNullString Then
                    MyEr "missing file type (.gsb or .txt or .gm2)", "ДЕМ УПэЯВЕИ ТЩПОР АЯВЕъОУ (.gsb Г .txt Г .gm2)"
                    Set Scr = Nothing
                    Exit Function
                End If
            End If
            s$ = ExtractPath(s$) + ExtractName(s$, True)
            ' check if path exist
            ' uSE THE MYDIR.ISDIR
            If Dir$(ExtractPath(s$), vbDirectory) = vbNullString Then
            ' error
                MyEr "wrong path to save", "КэХОР ТЭПОР ЦИА СЧСИЛО"
                Set Scr = Nothing
                Exit Function
            ElseIf ExtractName(s$, True) = vbNullString Then
                MyEr "missing file name", "ВэХГЙЕ ТО ЭМОЛА АЯВЕъОУ"
                Set Scr = Nothing
                Exit Function
            End If
          Dim oldclid As Long
          oldclid = Clid
            If CFname(s$) <> "" Then
            s$ = CFname(s$)
             frm$ = ReadUnicodeOrANSI(s$, True, x1)
             ' CHECK TO SEE IF THIS IS A PASSWORD PROTECTED PROGRAMM
             For i = 1 To Len(frm$)
             If AscW(Mid$(frm$, i, 1)) < 128 Then
             Exit For
             End If
             Next i
             If i > Len(frm$) Then
             If Lang = 1 Then
             MsgBoxN "not text found", 0
             Else
             MsgBoxN "ДЕМ БЯчЙА ЙЕъЛЕМО", 0
             End If
             Set Scr = Nothing
             Exit Function
             End If
           ' par = Len(frm$) = FileLen(GetDosPath(s$)) ' not unicode
            par = x1 = 3
     
            Else
            frm$ = vbNullString
            par = False
            End If
            Form1.EditTextWord = LCase(ExtractType(s$)) <> "gsb"
            Form1.TEXT1.Title = ExtractName(s$, True) + " "
            If x1 = 0 Then x1 = -5
            Form1.ResetMarks
            Form1.TEXT1.glistN.UseTab = UseTabInForm1Text1
            If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, p) Then
            o = CLng(p)
            End If
            End If
            
            If o < 1 Then o = 0
            If o > Len(frm$) Then o = Len(frm$) + 1
            With players(GetCode(basestack.Owner))
            ScreenEdit basestack, frm$, 0, .mysplit, .mx - 1, .my - 1, o, x1
            End With
            Form1.ResetMarks
            If frm$ <> "" And Abs(x1) >= 0 And Not CancelEDIT Then
                If par Then
                    i = FreeFile
                        If Not WeCanWrite(s$) Then Set Scr = Nothing: Exit Function
                        On Error Resume Next
                        Open GetDosPath(s$) For Output As i
                        If Err.Number > 0 Then
                            Err.Clear
                            MyEr "Bad filename", "кэХОР СТО ЭМОЛА АЯВЕъОУ"
                            Set Scr = Nothing
                            Exit Function
                        End If
                        Print #i, frm$;
                        Close i
                    Else
                    par = SaveUnicode(s$, frm$, x1)
                End If
                
            End If
        End If
        Set Scr = Nothing
        Clid = oldclid
        Exit Function
    Else
    Set Scr = Nothing
    Exit Function
    End If
End If

    If s$ <> "" Then
x1 = Abs(IsLabel(basestack, rest$, s$))
        If x1 > 0 Then
        If x1 > 3 Then
            s$ = Replace$(s$, "(", "")
            If FastSymbol(rest$, ")") Then
            End If
            s$ = s$ & "()"
            End If
        Else
        Set Scr = Nothing
        Exit Function
        End If
        MakeThisSub basestack, s$  'NO GOOD..
        If GetSub(s$, x1) Then
jump1:
            If x1 < lckfrm And lckfrm <> 0 Then
            MyEr s$ & " is locked", s$ & " ЕъМАИ ЙКЕИДЫЛщМО"
            rest$ = vbNullString
            Set Scr = Nothing
            Exit Function
            End If
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
            y1 = Abs(IsLabel(basestack, rest$, frm$))
              If y1 <> 0 Then
           '' frm$ = myUcase(frm$)
             GetSub frm$, x1
             
            If x1 = 0 Then
            If y1 > 3 Then frm$ = frm$ + ")"
            GetSubFullName s$, ss$
            If ss$ <> Mid$(frm$, Len(ss$) - Len(s$) + 1) Then
                Check2SaveModules = True
                subHash.RenameKey ss$, Mid$(frm$, Len(ss$) - Len(s$) + 1)
            End If
            End If
            End If
            Set Scr = Nothing
            Exit Function
            ElseIf FastSymbol(rest$, ",") Then
            i = 1
                If IsExp(basestack, rest$, p) Then
                    i = Int(p)
                    If i < 0 Then i = Len(sbf(x1).sb) + i
                    If i < 0 Then i = 0
                    If i > Len(sbf(x1).sb) Then i = Len(sbf(x1).sb) + 1
                End If
                sbf(x1).sbc = i
            End If
            If sbf(x1).sbc = 0 Then sbf(x1).sbc = -1
        MakeMyTitle s$, Lang
        Form1.TEXT1.glistN.UseTab = UseTabInForm1Text1
        
        With players(GetCode(basestack.Owner))
            prev$ = sbf(x1).sb
            ScreenEdit basestack, prev$, 0, .mysplit, .mx - 1, .my - 1, sbf(x1).sbc, , , , True
            End With
            If SHOWCODE Then
            Set bb = New CodeBlock
            bb.Construct (sbf(x1).sb)
            bb.ExportStr basestack
            End If
            If prev$ <> sbf(x1).sb Then
            Set sbf(x1).subs = Nothing
            sbf(x1).sb = prev$
            Check2SaveModules = True
            End If
            FK$(13) = "@EDIT " & s$ & "," & CStr(i)
        Else
        If InStr(s$, ".") > 0 Then
        frm$ = s$
        s$ = GetStrUntil(".", frm$)
        If GetSub(s$, x1) Then
        GoTo jump1
        End If
        End If
            If FastSymbol(rest$, ",") Then
             If IsExp(basestack, rest$, p) Then
             End If
            End If
            i = -1
           MakeMyTitle s$, Lang
           Form1.TEXT1.glistN.UseTab = UseTabInForm1Text1
           With players(GetCode(basestack.Owner))
            ScreenEdit basestack, frm$, 0, .mysplit, .mx - 1, .my - 1, i ', , , , Len(frm$) = 0
            End With
            If frm$ <> "" Then
            MakeThisSub basestack, s$
                If here$ = vbNullString And InStr(s$, "(") = 0 Then
                    x1 = GlobalSub(s$, frm$, , s$)
                Else
                    x1 = ModuleSub(s$, frm$)
                End If
                Check2SaveModules = True

                If x1 <> 0 Then sbf(x1).sbc = i: Set sbf(x1).subs = Nothing
                FK$(13) = "@EDIT " & s$ & "," & CStr(i)
                Else
                FK$(13) = "@EDIT " & s$
            End If
        End If
    ElseIf Not (basestack.IamChild Or basestack.IamAnEvent) Then
        Form1.TEXT1.glistN.UseTab = False
        frm$ = Mid$(Replace$(QUERYLIST, vbCr, vbCrLf), 3)
        Form1.ShadowMarks = True
        If UserCodePage = 1253 Then
        Form1.TEXT1.Title = "къСТА ЕМТОКЧМ "
        Else
        Form1.TEXT1.Title = "Command List "
        End If
        With players(GetCode(basestack.Owner))
        ScreenEdit basestack, frm$, 0, .mysplit, .mx - 1, .my - 1
        End With
        Form1.ShadowMarks = False
        QUERYLIST = vbCr + Replace$(frm$, vbCrLf, vbCr)
    End If

End Function
Function ProcModuleEntry(basestack As basetask, ohere$, x1 As Long, rest$, Optional Lang As Long = -1, Optional thisIsEvent As Boolean = False) As Boolean
On Error GoTo there22

If LastErNum = -1 Then GoTo there22
Dim bs As basetask, loopthis As Boolean
Dim subs As Long, snames As Long, Vname As Long
Dim i As Long, p As Long, S3 As Long, bb$, pa$, small$, sbi As Long
Dim exitnow As Boolean
Dim restart As Boolean
Dim backup$, TSHB As Boolean
If trace Then SwapStrings backup$, TestShowSub: TSHB = TestShowBypass
TestShowBypass = False
'LastErName = VbNullString: LastErNameGR = VbNullString
If CurrentStackSize > stacksize Then
    MyEr "Function's Stack is Full - 15", "г СТОъБА ТЫМ СУМАЯТчСЕЫМ щВЕИ ЦЕЛъСЕИ - 15"
    ProcModuleEntry = False:
    here$ = ohere$
    GoTo modfun
End If
' ******************************************* module entry..............
If x1 = 0 Then x1 = basestack.callx1: ohere$ = basestack.callohere: basestack.callx1 = 0
i = 1
Set bs = New basetask
With bs
    .ByName = basestack.ByName
    .IamAnEvent = thisIsEvent
    Set .Parent = basestack
    Set .Sorosref = basestack.soros   'same stack
    Set .Owner = .Parent.Owner
    .originalname$ = ohere$
    .SetV2
    Vname = .Vname
    .ErrVars = .Vars
    basestack.ByName = 0
    .ByName = 0
    .commnum = comhash.count
    .strfunnum = strfunid.count
    .numfunnum = funid.count
    .strnum = strid.count
    .numnum = numid.count
    If sbf(x1).sbc Then
        numid.pushtopGlobal
        funid.pushtopGlobal
        strfunid.pushtopGlobal
        funid.pushtopGlobal
    Else
        numid.pushtop
        funid.pushtop
        strfunid.pushtop
        funid.pushtop
    End If
    subs = sb2used: snames = subHash.count
    .UseGroupname = sbf(x1).sbgroup
    .tpointer = sbf(x1).tpointer
    .OriginalCode = x1
    If Not basestack.StaticCollection Is Nothing Then
        StaticWork basestack, bs, here$
    End If
    .StaticInUse$ = here$
End With
If SecureNames Then
    If basestack.IamThread Then
        here$ = Str$(basestack.Process.id) + here$
        Mid$(here$, 1, 1) = "_"
    End If
End If
If Lang <> -1 Then
    If IsSymbol(rest$, ";") Then
        Do
            If IsLabel(basestack, rest$, small$, True) = 1 Then
                If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                    If Abs(IsLabelBig(basestack, rest$, pa$)) <> 1 Then GoTo myerror1
                     MakeThisSub basestack, pa$
                Else
                    pa$ = small$
            End If
                    If subHash.Find(ohere$ & "." & pa$, i) Then
                        MyModule bs, small$ + " {}", Lang
                        sbf(bs.IndexSub).locked = True
                        sbf(bs.IndexSub).sb = sbf(i).sb
                        sbf(bs.IndexSub).sbc = sbf(i).sbc
                        sbf(bs.IndexSub).sbgroup = sbf(i).sbgroup
                         
                    ElseIf subHash.Find(pa$, i) Then
                        MyModule bs, small$ + " {}", Lang
                        sbf(bs.IndexSub).locked = True
                        sbf(bs.IndexSub).sb = sbf(i).sb
                        sbf(bs.IndexSub).sbc = sbf(i).sbc
                        sbf(bs.IndexSub).sbgroup = sbf(i).sbgroup
                    End If
                End If
        Loop Until Not IsSymbol(rest$, ",")
    End If
End If
i = 1
If myexit(bs) Then
    ProcModuleEntry = False: GoTo modfun
End If
restart = True
S3 = x1
Do
    bb$ = Mid$(sbf(S3).sb, i)
againmod:
    If LastErNum = -1 Then GoTo myerror1
    exitnow = False
    Select Case Execute(bs, bb$, exitnow, False, loopthis, , restart)
    Case 0
myerror1:
        If bs.ErrorOriginal = 0 Then If sbi > 0 Then bb$ = bb$ + space$(sbi)
        If MOUT And Not NOEXECUTION Then
            MOUT = False
            rest$ = vbNullString: MyEr "", ""
            Exit Do
        End If
        If sb2used <> 0 And Not NERR Then
            If Len(bs.UseGroupname) > 0 Then
                If InStr(bs.UseGroupname, ChrW(&H1FFF)) > 0 Then
                    pa$ = GetNextLine((sbf(Abs(bs.OriginalCode)).sb))
                    FK$(13) = Mid$(pa$, 7) + "-" + CStr(Len(bb$))
                    MyErMacro rest$, "Problem in class in module " + GetName(here$), "пЯЭБКГЛА СТГ ЙКэСГ СТО ТЛчЛА " + GetName(here$)
                    ProcModuleEntry = True
                    GoTo thh1
                End If
            End If
            If bs.ErrorOriginal > 0 Then
            If bs.ErrorOriginal <> bs.OriginalCode Then
            If Left$(bb$, 10) <> ": Error -1" Then bb$ = ": Error -1 " + bb$
            If bs.IamChild Then If bs.Parent.OriginalCode <> bs.ErrorOriginal Then bs.Parent.ErrorOriginal = bs.ErrorOriginal
            rest$ = bb$: ProcModuleEntry = False
            GoTo th0
            End If
            End If
            
            pa$ = "EDIT " & GetModuleName(bs, here$) & ", " + CStr(Len(sbf(x1).sb) + 1)
            If ohere$ <> "" Then
                If Left$(sbf(x1).sb, 10) = "'11001EDIT" Then
                    pa$ = Mid$(GetNextLine(sbf(x1).sb), 7)
                    sbf(x1).sb = Mid$(sbf(x1).sb, 3)
                    Set sbf(x1).subs = Nothing
                    If SecureNames Then
                        MyEr "in module " & GetName(here$), "СТО ТЛчЛА " & GetName(here$)
                    Else
                        MyEr "in module " & GetName(ohere$) & "." & GetName(here$), "СТО ТЛчЛА " & GetName(ohere$) & "." & GetName(here$)
                    End If
                Else
                    MyEr "in module " & GetName(sbf(x1).goodname), "СТО ТЛчЛА " & GetName(sbf(x1).goodname)
                End If
            Else
                If here$ = vbNullString Then
                    MyEr "in command prompt", "СТГМ ЕИСАЦЫЦч ЕМТОКЧМ"
                Else
                    MyEr "in module " & GetName(sbf(x1).goodname), "СТО ТЛчЛА " & GetName(sbf(x1).goodname)
                End If
            End If
            If InStr(FK$(13), ",") > 0 Then
                GoTo thh
            End If
            If (Len(sbf(x1).sb) - Len(bb$)) < 0 Then
                FK$(13) = pa$
            Else
                DropLeft ",", FK$(13)
                If FK$(13) <> "" Then FK$(13) = "+" & FK$(13)
                FK$(13) = pa$ & "-" & CStr(Len(bb$)) + FK$(13)
            End If
        Else
            If sb2used > 0 Then
                MyEr "in module " & GetName(here$), "СТО ТЛГЛА " & GetName(here$)
            Else
                MyEr "", ""
            End If
        End If
th0:
        bs.UseofIf = 0
        GoTo thh
    Case 1, 3
thh:
        TestShowBypass = False
        If bs.IamChild Then
            If Not bs.soros Is bs.Parent.soros Then
                Set bs.Parent.Sorosref = bs.soros
            End If
        End If
        If LastErNum <> 0 And bs.ErrorOriginal = 0 Then
            rest$ = vbNullString
            bs.UseofIf = 0
        End If
        If Not exitnow Then If bs.UseofIf > 0 Then MissENDIF: ProcModuleEntry = False
thh1:
        On Error Resume Next
        If Not basestack.CopyInOutCol Is Nothing Then CopyBack basestack
        With bs
            .ThrowThreads
            MOUT = False
            var2used = .Vars
            varhash.ReduceHash Vname, var()
            If UBound(var()) <> varhash.MaxSpace Then
                    ReDim Preserve var(varhash.MaxSpace) As Variant
            End If
            sb2used = subs
            subHash.ReduceHash snames, sbf()
            If UBound(sbf()) <> subHash.MaxSpace Then
                    ReDim Preserve sbf(subHash.MaxSpace) As modfun
            End If
            If .commnum <> comhash.count Then comhash.ReduceHash .commnum, sbf()
            If .numfunnum <> funid.count Then funid.ReduceHash .numfunnum
            If .strfunnum <> strfunid.count Then strfunid.ReduceHash .strfunnum
            If .strnum <> strid.count Then strid.ReduceHash .strnum
            If sbf(x1).sbc Then
                numid.poptopGlobal
                funid.poptopGlobal
                strfunid.poptopGlobal
                strid.poptopGlobal
            Else
                numid.poptop
                funid.poptop
                strfunid.poptop
                strid.poptop
            End If
        End With
        Set bs = Nothing
        here$ = ohere$
        Exit Do
    Case 2
        i = 1
        If Len(bb$) <> 0 Then
            If bb$ = ChrW$(0) Then
                If trace Then TestShowBypass = False
                If Not bs.IsInRetStackString(small$) Then
                    p = bs.isPop3Long(S3, sbi)
                    If p > 0 Then
                        If S3 > 0 Then
                            bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                       ' ElseIf S3 = 0 Then
                       '     Stop
                        Else
                            bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                        End If
                        If trace Then
                            TestShowBypass = True
                            If TestShowBypass Then
                                If S3 < 0 Then
                                    TestShowSub = var(-S3).code
                                Else
                                    TestShowSub = sbf(S3).sb
                                End If
                            End If
                            bs.addlen = sbi
                        End If
                        PopStage bs
                        GoTo againmod
                    Else
fulty:
                        MyEr "Fault in Return", "кэХОР СТГМ еПИСТЯОЖч"
                        bs.Flush
                        Exit Do
                    End If
                Else
                    If InStr(small$, " ") > 0 Then
                        bs.PushSecondThird S3, sbi
                        If searchsub(x1, small$, i, S3, bb$) Then
                            If Len(small$) <> 0 Then If Not MyRead(7, bs, small$, 1) Then GoTo thh
                            GoTo contSub
                            ' x1 here is wrong...Check this
                        'ElseIf x1 <> basestack.OriginalCode And basestack.OriginalCode <> 0 Then
                            ElseIf basestack.IamChild Then  ' maybe I use this line not above
                            If searchsub(FindPrevOriginal(bs), small$, i, S3, bb$) Then
                                If Len(small$) <> 0 Then If Not MyRead(7, bs, small$, 1) Then GoTo thh
contSub:
                                If Len(bb$) = 0 Then
                                    If S3 < 0 Then
                                        bb$ = Mid$(var(-S3).code, i)
                                    Else
                                        bb$ = Mid$(sbf(S3).sb, i)
                                    End If
                                    sbi = 0
                                Else
                                    If S3 < 0 Then
                                        sbi = Len(var(-S3).code) - i - Len(bb$)
                                    Else
                                        sbi = Len(sbf(S3).sb) - i - Len(bb$)
                                    End If
                                End If
                                If trace Then
                                    TestShowBypass = True
                                    If TestShowBypass Then
                                        If S3 < 0 Then
                                            TestShowSub = var(-S3).code
                                        Else
                                            TestShowSub = sbf(S3).sb
                                        End If
                                    End If
                                    bs.addlen = Len(TestShowSub) - i + 1 - Len(bb$)
                                End If
                                GoTo againmod
                            Else
therebad:
                            badSubNotFound
                            If bs.IsDecimal Then
                            p = bs.Pop3Long(S3, sbi)
                            If S3 > 0 Then
                                bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                             ElseIf S3 = 0 Then
                       
                            Else
                                bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                            End If
                            End If
                            bs.RetStackDrop 3 '5
                            GoTo myerror1
                            End If
                        Else
                            GoTo therebad
                            
                        End If
                    End If
                End If
            ElseIf bb$ = "BREAK" Then
                    GoTo thh1
            Else
                If sbf(S3).subs Is Nothing Then
                    Set sbf(S3).subs = New FastCollection
                End If
                If sbf(S3).subs.ExistKey(bb$) Then
                    If IsNumeric(sbf(S3).subs.Value) Then
                        i = sbf(S3).subs.Value
                        x1 = S3
                    Else
                        i = val(Split(sbf(S3).subs.Value)(0))
                        x1 = val(Split(sbf(S3).subs.Value)(1))
                    End If
                   
                Else
                    If InStr(bb$, vbCr) > 0 Then
                        i = rinstr(sbf(S3).sb, bb$)
                        If i = 0 Then i = Len(sbf(S3).sb) + 1
                    Else
                        i = PosLabel(bb$, sbf(S3).sb)
                    End If
                    sbf(S3).subs.AddKey bb$, i
                    x1 = S3
                End If
                If trace Then
                    bs.addlen = 0
                    TestShowBypass = True
                    TestShowSub = sbf(S3).sb
                End If
                If bs.SubLevel > 0 Then
                    If x1 = S3 Then
                        If Len(sbf(S3).sb) - i > sbi Then
                            bb$ = Mid$(sbf(S3).sb, i, Len(sbf(S3).sb) - i - sbi)
                            GoTo againmod
                        Else
                            sbi = 0
                        End If
                    Else
                        sbi = 0
                    End If
                Else
                    sbi = 0
                End If
            End If
        Else
            If Not loopthis Then GoTo thh1
            loopthis = False
        End If
    Case 12
        MyEr "Exit for out of for next loop", "╦НОДОР ЦИА щНЫ АПЭ цИА еПЭЛЕМО"
        Exit Do
    End Select
    If Not restart Then
        restart = True
        bs.IFCTRL = False
        bs.jump = False
        If bs.RetStackTotal > 0 Then
            bs.UseofIf = 0
            bs.Flush
        End If
    End If
Loop
ProcModuleEntry = True
modfun:
If trace Then SwapStrings backup$, TestShowSub: TestShowBypass = TSHB
Exit Function
there22:
If Err Then
    MyEr Err.Description, Err.Description
    Err.Clear
    If Not bs Is Nothing Then GoTo thh
End If
GoTo modfun
End Function
Function PushParamGeneralV70(basestack As basetask, rest$, rest1$) As Boolean
Dim ps As mStiva
Set ps = New mStiva
If Len(rest1$) > 0 Then
If lookOne(rest1$, ")") Then PushParamGeneralV70 = True: GoTo conthere
If Not PushParamGeneralV7(basestack, rest1$, ps) Then Exit Function
End If
If Len(rest$) > 0 Then
If lookOne(rest$, ")") Then PushParamGeneralV70 = True: GoTo conthere
If Not PushParamGeneralV7(basestack, rest$, ps) Then Exit Function
End If
conthere:
PushParamGeneralV70 = True
With basestack
  If .SorosNothing Then

    Set .Sorosref = ps
  Else
     .soros.MergeTop ps
  End If
End With

End Function
Private Function PushParamSUB(basestack As basetask, rest$) As Boolean
PushParamSUB = True

Dim ps As mStiva, p As Variant, s$, usehandler As mHandler, usestiva As mStiva
    Set ps = New mStiva
    
    Set basestack.lastobj = Nothing
                Do
            If FastSymbol(rest$, "?") Then
                        ps.DataOptional
            ElseIf FastSymbol(rest$, "!") Then
                If IsExp(basestack, rest$, p) Then
                If basestack.lastobj Is Nothing Then
                   ps.DataValLong p
                ElseIf TypeOf basestack.lastobj Is mHandler Then
                    Set usehandler = basestack.lastobj
                    If TypeOf usehandler.objref Is mStiva Then
                        ps.MergeBottom usehandler.objref
                    ElseIf TypeOf usehandler.objref Is mArray Then
                     ps.MergeBottomCopyArray usehandler.objref
                        Else
                            PushParamSUB = False
                            MyEr "Expected Stack Object after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО ТЩПОУ сЫЯОЩ ЛЕТэ ТО !"
                            Set basestack.lastobj = Nothing
                            Exit Function
                    End If
                    Set usehandler.objref = Nothing
                ElseIf TypeOf basestack.lastobj Is mArray Then
                     ps.MergeBottomCopyArray basestack.lastobj
                     
                End If
                Set basestack.lastobj = Nothing
                End If
                ElseIf IsExp(basestack, rest$, p) Then
        If Not basestack.lastobj Is Nothing Then
        If TypeOf basestack.lastobj Is mStiva Then
            Set usestiva = basestack.lastobj
            ps.MergeBottom usestiva
            Set usestiva = Nothing
        ElseIf Not basestack.lastpointer Is Nothing Then
            ps.DataObj basestack.lastobj
            Set basestack.lastpointer = Nothing
            
        ElseIf Not basestack.lastobj Is Nothing Then
           ps.DataObj basestack.lastobj

        End If
       Set basestack.lastobj = Nothing
       
        Else
            ps.DataVal p
            
         End If
    ElseIf Not LastErNum <> 0 Then
    If IsStrExp(basestack, rest$, s$, Len(basestack.tmpstr) = 0) Then
       
       
       If Not basestack.lastpointer Is Nothing Then
            ps.DataObj basestack.lastobj
            Set basestack.lastpointer = Nothing
        ElseIf Not basestack.lastobj Is Nothing Then
           ps.DataObj basestack.lastobj
        Else
            ps.DataStr s$
        End If
        Set basestack.lastobj = Nothing
    ElseIf lookOne(rest$, ",") Then
        ps.DataOptional
    ' here
    End If
    Else
  If LastErNum <> 0 Then
    
     PushParamSUB = False
  Exit Do
    End If
    End If
      If LastErNum <> -2 And LastErNum <> 0 Then
      MyEr "Error in input list", "пЯЭБКГЛА СТИР ПАЯАЛщТЯОУР"
      
      PushParamSUB = False
      Exit Do
      End If
    If Not FastSymbol(rest$, ",") Then Exit Do
                Loop
             With basestack
             If .SorosNothing Then
           
               Set .Sorosref = ps
             Else
                .soros.MergeTop ps
             End If
             End With
            
End Function
Private Function PushParamGeneralV7(basestack As basetask, rest$, ps As mStiva) As Boolean
PushParamGeneralV7 = True
Dim p As Variant, s$, usehandler As mHandler, usestiva As mStiva
Dim ParentStack As basetask
Set ParentStack = basestack.Parent
Set ParentStack.lastobj = Nothing
            Do
            If FastSymbol(rest$, "?") Then
                ps.DataOptional
            ElseIf FastSymbol(rest$, "!") Then
                If IsExp(ParentStack, rest$, p) Then
                    If ParentStack.lastobj Is Nothing Then
                        ps.DataValLong p
                    ElseIf TypeOf ParentStack.lastobj Is mHandler Then
                        Set usehandler = ParentStack.lastobj
                        If TypeOf usehandler.objref Is mStiva Then
                            ps.MergeBottom usehandler.objref
                        ElseIf TypeOf usehandler.objref Is mArray Then
                            ps.MergeBottomCopyArray usehandler.objref
                        Else
                            PushParamGeneralV7 = False
                            MyEr "Expected Stack Object after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО ТЩПОУ сЫЯОЩ ЛЕТэ ТО !"
                            Set ParentStack.lastobj = Nothing
                            ParentStack.modfuncall = False
                            Exit Function
                        End If
                        Set usehandler.objref = Nothing
                    ElseIf TypeOf ParentStack.lastobj Is mArray Then
                          ps.MergeBottomCopyArray ParentStack.lastobj
                    End If
                    Set ParentStack.lastobj = Nothing
                End If
        ElseIf IsExp(ParentStack, rest$, p) Then
            If Not ParentStack.lastobj Is Nothing Then
                If TypeOf ParentStack.lastobj Is mStiva Then
                    Set usestiva = ParentStack.lastobj
                    ps.MergeBottom usestiva
                    Set usestiva = Nothing
                ElseIf Not ParentStack.lastpointer Is Nothing Then
                    ps.DataObj ParentStack.lastobj
                    Set ParentStack.lastpointer = Nothing
                    Set ParentStack.lastobj = Nothing
                Else
                    ps.DataObj ParentStack.lastobj
                    Set ParentStack.lastobj = Nothing
                End If
                Set ParentStack.lastobj = Nothing
            Else
                ps.DataVal p
            End If
    ElseIf Not LastErNum <> 0 Then
    ParentStack.modfuncall = True
    If IsStrExp(ParentStack, rest$, s$, Len(ParentStack.tmpstr) = 0) Then
       If Not ParentStack.lastpointer Is Nothing Then
            ps.DataObj ParentStack.lastobj
            Set ParentStack.lastpointer = Nothing
            Set ParentStack.lastobj = Nothing
        ElseIf Not ParentStack.lastobj Is Nothing Then
            ps.DataObj ParentStack.lastobj
            Set ParentStack.lastobj = Nothing
        Else
        ps.DataStr s$
        End If
    ElseIf lookOne(rest$, ",") Then
        ps.DataOptional
    ' here
    End If
     ParentStack.modfuncall = False
    Else
  If LastErNum <> 0 Then
     PushParamGeneralV7 = False
  Exit Do
    End If
    End If
      If LastErNum <> -2 And LastErNum <> 0 Then
      MyEr "Error in input list", "пЯЭБКГЛА СТИР ПАЯАЛщТЯОУР"
      PushParamGeneralV7 = False
      End If
    If Not FastSymbol(rest$, ",") Then Exit Do
                Loop
             Set ParentStack = Nothing
End Function
Function PushParamGeneral(basestack As basetask, rest$, Optional ByVal temphere$) As Boolean
PushParamGeneral = True

Dim ps As mStiva, p As Variant, s$, ok As Long, usehandler As mHandler, usestiva As mStiva
    Set ps = New mStiva
    Set basestack.lastobj = Nothing
    Do
        If FastSymbol(rest$, "%") Then
            p = IsLabel(basestack, rest$, s$, True)
            ok = 1
            If p < 4 Then
                ExecuteVar ok, p, basestack, s$, rest$, (ok), 1, True, False, 0, "", 0, (temphere)
                If ok <> 1 Then PushParamGeneral = False: basestack.modfuncall = False: Exit Function
                ps.DataOptional
            Else
                MyEr "Array can't pass by name", "о ПъМАЙАР ДЕМ ЛПОЯЕъ МА ПЕЯэСЕИ ЛЕ ЭМОЛА"
                PushParamGeneral = False: basestack.modfuncall = False: Exit Function
            End If
        ElseIf FastSymbol(rest$, "?") Then
            ps.DataOptional
        ElseIf FastSymbol(rest$, "!") Then
            If IsExp(basestack, rest$, p) Then
                If basestack.lastobj Is Nothing Then
                   ps.DataValLong p
                ElseIf TypeOf basestack.lastobj Is mHandler Then
                    Set usehandler = basestack.lastobj
                    If TypeOf usehandler.objref Is mStiva Then
                        ps.MergeBottom usehandler.objref
                    ElseIf TypeOf usehandler.objref Is mArray Then
                        ps.MergeBottomCopyArray usehandler.objref
                    Else
                        PushParamGeneral = False: basestack.modfuncall = False
                        MyEr "Expected Stack Object after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО ТЩПОУ сЫЯОЩ ЛЕТэ ТО !"
                        Set basestack.lastobj = Nothing
                        Exit Function
                    End If
                    Set usehandler.objref = Nothing
                ElseIf TypeOf basestack.lastobj Is mArray Then
                    ps.MergeBottomCopyArray basestack.lastobj
                End If
                Set basestack.lastobj = Nothing
            End If
        ElseIf IsExp(basestack, rest$, p) Then
            If Not basestack.lastobj Is Nothing Then
                If TypeOf basestack.lastobj Is mStiva Then
                    Set usestiva = basestack.lastobj
                    ps.MergeBottom usestiva
                    Set usestiva = Nothing
                ElseIf Not basestack.lastpointer Is Nothing Then
                    ps.DataObj basestack.lastobj
                    Set basestack.lastpointer = Nothing
                ElseIf Not basestack.lastobj Is Nothing Then
                    ps.DataObj basestack.lastobj
                End If
                Set basestack.lastobj = Nothing
            Else
                ps.DataVal p
            End If
        ElseIf Not LastErNum <> 0 Then
            basestack.modfuncall = True
            If IsStrExp(basestack, rest$, s$, Len(basestack.tmpstr) = 0) Then
                If Not basestack.lastpointer Is Nothing Then
                    ps.DataObj basestack.lastobj
                    Set basestack.lastpointer = Nothing
                ElseIf Not basestack.lastobj Is Nothing Then
                    ps.DataObj basestack.lastobj
                Else
                    ps.DataStr s$
                End If
                Set basestack.lastobj = Nothing
            ElseIf lookOne(rest$, ",") Then
                ps.DataOptional
    ' here
            End If
            basestack.modfuncall = False
        Else
            If LastErNum <> 0 Then
                PushParamGeneral = False
            Exit Do
        End If
    End If
    If LastErNum <> -2 And LastErNum <> 0 Then
        MyEr "Error in input list", "пЯЭБКГЛА СТИР ПАЯАЛщТЯОУР"
        PushParamGeneral = False
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
Loop
With basestack
    If .SorosNothing Then
        Set .Sorosref = ps
    Else
        .soros.MergeTop ps
    End If
End With
End Function

Sub PushParamStraight(basestack As basetask, rest$)
Dim p As Variant, s$
    Dim ps As mStiva
    Set ps = basestack.soros
    basestack.modfuncall = True
                Do
                    If IsExp(basestack, rest$, p) Then
                            If Not basestack.lastpointer Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastpointer = Nothing
                                Set basestack.lastobj = Nothing
                            ElseIf Not basestack.lastobj Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastobj = Nothing
                            Else
                                ps.DataVal p
                            End If
                    ElseIf IsStrExp(basestack, rest$, s$, Len(basestack.tmpstr) = 0) Then
                    
                            If Not basestack.lastpointer Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastpointer = Nothing
                                Set basestack.lastobj = Nothing
                            ElseIf Not basestack.lastobj Is Nothing Then
                                ps.DataObj basestack.lastobj
                                Set basestack.lastobj = Nothing
                            Else
                                ps.DataStr s$
                            End If

                    Else
                    
                            Exit Do
                    End If
                    If Not FastSymbol(rest$, ",") Then Exit Do
                Loop
        basestack.modfuncall = False
             Set ps = Nothing
End Sub

Function searchsub(ByVal where As Long, w$, Final As Long, site As Long, code$, Optional needfunc As Boolean = False) As Boolean
Static aCopy As New Document
Dim EndPoint As Long
Dim ww$(), vv()
ww$() = Split(w$)
If where = 0 Or w$ = "" Then
Exit Function
Else
If where < 0 Then
    With var(-where)
    If .subs Is Nothing Then
        Set .subs = New FastCollection
    Else
        If UBound(ww$()) = 0 Then
            w$ = ww$(0)
        ElseIf needfunc Then
            w$ = "@" + ww$(1)
        Else
            w$ = ww$(1)
        End If
        If .subs.ExistKey(UCase(w$)) Then
        
            vv = .subs.Value
            Final = vv(0)
            site = vv(1)
            w$ = vv(2)
            code$ = vv(3)
            searchsub = True
        Exit Function
        End If
        w$ = Join(ww$)
    End If
    End With
Else
    With sbf(where)
    If .subs Is Nothing Then
        Set .subs = New FastCollection
    Else
        If UBound(ww$()) = 0 Then
            w$ = ww$(0)
        ElseIf needfunc Then
            w$ = "@" + ww$(1)
        Else
            w$ = ww$(1)
        End If
        If .subs.ExistKey(UCase(w$)) Then
            '  EndPoint ???????????
            vv = .subs.Value
            Final = vv(0)
            site = vv(1)
            w$ = vv(2)
            code$ = vv(3)
        WaitShow = 0
        searchsub = True
        Exit Function
        End If
        w$ = Join(ww$)
    End If
    End With
    End If
End If

Dim len1 As Long, there1 As Long, a$
Dim there As Long, Curs As Long, Curs2 As Long
Dim a1 As Long, B As Long, c As Long, D As Long
Dim ss$, Dump$
len1 = Len(ww$(0))
If len1 = 1 Then
' looking for simple sub
    If ww$(0) = "S" Then
          ' labelname: /// return  (maybe more than one labels
        Set aCopy = New Document
        With aCopy
            .EmptyDoc
            If where > 0 Then
                .textDocFast = sbf(where).sb
            Else
                .textDocFast = var(-where).code$
            End If
            .lcid = 1032
            ww$(1) = ww$(1) + ":"
            Do While .FindIdentifier(ww$(1), False, there, Curs)
                If NLtrim$(Left$(.TextParagraph(there), Curs - 1)) = vbNullString Then
                    Final = -1
                    .FindPos .FirstParagraphLine(there) + 2, 1, Final, a1, B, c, D
                    Final = Final + 1 ' because mid$ starts from 1
                    w$ = vbNullString
                    searchsub = True
                    GoTo register
                End If
            Loop
        End With
    Else
        ' looking Number ///return (maybe more than one return statements)
        If where > 0 Then
            Final = PosLabel(ww$(1), sbf(where).sb)
        Else
            Final = PosLabel(ww$(1), var(-where).code$)
        End If
        
        If Final <> 1 Then
            
            If where > 0 Then
                If Final > Len(sbf(where).sb) Then Exit Function
            Else
                If Final > Len(var(-where).code$) Then Exit Function
            End If
            w$ = vbNullString
            searchsub = True
            GoTo register
        End If
    End If
    Exit Function
End If
' No we have something better
'Set aCopy = New Document

With aCopy
    .EmptyDoc
    .textDocFast = a$
    If where > 0 Then
        .textDocFast = sbf(where).sb
    Else
        .textDocFast = var(-where).code$
    End If
    .lcid = 1032
paliedo:
    there = 0
    Curs = 0
    Do
        If .FindIdentifier(ww$(0), False, there, Curs) Then
            ss$ = Left$(aCopy.TextParagraph(there), Curs - 1)
            IsNumberLabel ss$, Dump$
            If Trim$(ss$) = vbNullString Then
                Curs2 = Curs
                there1 = there
                If .FindIdentifier(ww$(1), True, there1, Curs2) Then
                    If there1 <> there Then
                        Curs = 0
                    Else
                        Final = -1
                        .FindPos .FirstParagraphLine(there1) + 2, 1, Final, a1, B, c, D
                        Final = Final + 1 ' because mid$ starts from 1
                        w$ = BlockParam(Trim(Mid$(.TextParagraph(there), Curs2 + Len(ww(1)))))
                        searchsub = True
                        Exit Do
                    End If
                End If
            End If
        Else
            If ww$(0) = "яоутима" Then
                ww$(0) = "яоут╨ма"
                GoTo paliedo
            ElseIf ww$(0) = "сумаятгсг" Then
                ww$(0) = "сум╒ятгсг"
                GoTo paliedo
            End If
            Exit Do
        End If
    Loop
End With
register:
If searchsub Then
If where > 0 Then
site = where
sitehere:
        If sbf(site).subs Is Nothing Then Set sbf(site).subs = New FastCollection
        code$ = vbNullString
        If Len(ww$(0)) > 1 Then
            EndPoint = Final
            If Not aheadstatusENDSUBorFUN(sbf(where).sb, EndPoint, -(AscW(ww$(0)) < 128), needfunc) Then
                If needfunc Then MisEndFunc Else MisEndSub
                searchsub = False
                Exit Function
            End If
            code$ = Mid$(sbf(where).sb, Final, EndPoint - Final)
        End If
        
        If needfunc Then
            sbf(site).subs.AddKey "@" + UCase(ww$(1)), Array(Final, where, w$, code$)
        Else
            sbf(site).subs.AddKey UCase(ww$(1)), Array(Final, where, w$, code$)
        End If
ElseIf where < 0 Then
site = where
sitethere:
    If var(-site).subs Is Nothing Then Set var(-site).subs = New FastCollection
        code$ = vbNullString
        If Len(ww$(0)) > 1 Then
            EndPoint = Final
            If Not aheadstatusENDSUBorFUN(var(-where).code$, EndPoint, -(AscW(ww$(0)) < 128), needfunc) Then
                If needfunc Then MisEndFunc Else MisEndSub
                searchsub = False
                Exit Function
            End If
            code$ = Mid$(var(-where).code$, Final, EndPoint - Final)
        End If
        If needfunc Then
            var(-site).subs.AddKey "@" + UCase(ww$(1)), Array(Final, where, w$, code$)
        Else
            var(-site).subs.AddKey UCase(ww$(1)), Array(Final, where, w$, code$)
        End If
    End If
End If
End Function

Function executeblock(Exec As Long, bstack As basetask, B$, once As Boolean, kolpo As Boolean, Optional ByVal stepbystep As Boolean = False, Optional skipblock As Boolean = False, Optional noblock As Boolean = True) As Boolean
executeblock = True
Dim i As Long, LL As Long, oldLL As Long, p As Long
Dim x2 As Long, y2 As Long, monce As Long, w3 As Long
Dim myLevel As Long, oldexec As Long, loopthis As Boolean, RetStackSize As Long
Dim subs As FastCollection
Dim oldjump As Long, oldifctrl As Long, olduseofif As Long
Dim S3 As Long, bb$, small$, ex2 As Long, sbi As Long
' save state in execution stack
oldjump = bstack.jump: oldifctrl = bstack.IFCTRL: olduseofif = bstack.UseofIf
RetStackSize = bstack.RetStackTotal
If Exec = 0 Then Exec = 1
oldexec = Exec: myLevel = bstack.SubLevel: i = 1
If noblock Then monce = once Else monce = True

If Not skipblock Then  ' find block
    ex2 = blockLen(B$)
    If bstack.addlen <> 0 Then
        LL = bstack.addlen + Len(B$) - ex2 + 1
    Else
        LL = Len(B$) - ex2 + 1
    End If
Else
    LL = bstack.addlen
End If
oldLL = bstack.addlen
If ex2 > 0 Then ex2 = ex2 - 1 Else ex2 = Len(B$)
sbi = ex2
Do
    bb$ = Mid$(B$, i, ex2 - i + 1)
fromfirst0:
            
    kolpo = once: once = False
    bstack.addlen = LL
   
    w3 = Execute(bstack, bb$, kolpo, stepbystep, loopthis, noblock)
    If NOEXECUTION Then w3 = 0
    
    bstack.addlen = oldLL
    Select Case w3
    Case 0
error1:
        If bstack.RetStackTotal - RetStackSize > 0 Then
            bstack.UseofIf = olduseofif
            bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
        End If
        If myLevel <> bstack.SubLevel Then
            B$ = bb$
            Exec = 0
            Exit Function
        End If
        If NocharsInLine(bb$) Then
            B$ = vbNullString
        Else
            If LastErNum = -2 Then
                SwapStrings B$, bb$
            ElseIf LL >= oldLL Then
                B$ = bb$ + space$(LL - oldLL)
            Else
                B$ = vbNullString$
            End If
        End If
        Exec = 0
        Exit Function
    Case 1
ALFA12:
        If LastErNum = -2 Then
            If NocharsInLine(bb$) Then
                B$ = vbNullString
            Else
                If Left$(bb$, 12) = " : ERROR -2" Then
                    B$ = bb$
                ElseIf ex2 < Len(bb$) Then
                    B$ = vbNullString
                Else
                    B$ = Mid$(B$, ex2 - Len(bb$) + 1)
                End If
            End If
            Exec = 0
            Exit Function
        End If
        Exec = oldexec ''1
        If kolpo And monce And Exec = 1 Then
            SwapStrings B$, bb$
            once = True
            Exit Function
        ElseIf kolpo And NocharsInLine(bb$) Then
            If RetStackSize < bstack.RetStackTotal Then PopStagePart bstack, bstack.RetStackTotal - RetStackSize
            Exec = w3
            Exit Do
        End If
        If NocharsInLine(bb$) And kolpo Then
            B$ = vbNullString
        Else
            If stepbystep Then
                B$ = bb$
            Else
                B$ = Right$(B$, Len(B$) - ex2)
            End If
        End If
        Exit Do
    Case 2
        If bb$ = "BREAK" Then
            Exec = 2
            If noblock Then
                B$ = vbNullString
            Else
                SwapStrings B$, bb$
            End If
            once = True
            kolpo = True
            Exit Function
        ElseIf bb$ = "NEXT" Then
            SwapStrings B$, bb$
            If RetStackSize < bstack.RetStackTotal Then
                Exec = 2
                PopStagePartContinue bstack, bstack.RetStackTotal - RetStackSize
            Else
                Exec = 2
            End If
            Exit Do
        End If
        
        If Not kolpo Then
            If Len(bb$) > 0 Then
                If bb$ = ChrW$(0) Then
                    'bstack.addlen = 0
                    If trace Then TestShowBypass = False
                    If RetStackSize >= bstack.RetStackTotal Then
                        If bstack.IsDecimal Then
                            ' this is a return form other block
                            Exec = 2
                            B$ = bb$
                            Exit Function
                        End If
                    ElseIf Not bstack.IsDecimal Then
                        If RetStackSize < bstack.RetStackTotal Then PopStagePartContinue bstack, bstack.RetStackTotal - RetStackSize
                    Else
''                        Stop
                    End If
                    i = 1
from123:
                    If Not bstack.IsInRetStackString(small$) Then
                        p = bstack.Pop3Long(S3, sbi)
                        If p < 0 Then
                            Exec = 0
                            If RetStackSize <> bstack.RetStackTotal Then
                                MyEr "Problem in return stack", "пЯЭБКГЛА СТО СЫЯЭ ЕПИСТЯОЖчР"
                            End If
                            bstack.Flush
                            B$ = vbNullString
                            Exit Function
                        End If
                        If LastErNum = -1 Then
                            bstack.RetStack.PushLong p
                            Exec = 0
                            Exit Function
                        End If
jumphere1:
                        If S3 = 0 And sbi > 0 Then
                        
                        End If
                        Exec = 1
                        i = ex2 - p + 1
                        PopStage bstack
                        If loopthis Or stepbystep Or x2 = 2 Then
                            bb$ = Mid$(B$, i, ex2 - i + 1)
                            bstack.addlen = oldLL
                            GoTo fromfirst0
                        Else
                            bb$ = Mid$(B$, p + 1, ex2 - p)
                        End If
                        If bb$ = vbCrLf Then Exit Do
                    Else
findelsesub0:
                        If InStr(small$, " ") > 0 Then
                            bstack.PushSecondThird S3, sbi
                            S3 = bstack.OriginalCode
                            If searchsub(S3, small$, i, S3, bb$) Then
                                If Len(small$) <> 0 Then
                                    If Not MyRead(7, bstack, small$, 1) Then
                                        Exec = 0
                                        Exit Function
                                    End If
                                End If
                                GoTo contSub
                            ElseIf bstack.IamChild Then
                                If searchsub(FindPrevOriginal(bstack), small$, i, S3, bb$) Then
                                If Len(small$) <> 0 Then
                                    If Not MyRead(7, bstack, small$, 1) Then
                                        Exec = 0
                                        Exit Function
                                    End If
                                End If
contSub:
                                If Len(bb$) = 0 Then
                                    If S3 < 0 Then
                                        bb$ = Mid$(var(-S3).code, i)
                                    Else
                                        bb$ = Mid$(sbf(S3).sb, i)
                                    End If
                                    sbi = 0
                                Else
                                    If S3 < 0 Then
                                        sbi = Len(var(-S3).code) - i - Len(bb$)
                                    Else
                                        sbi = Len(sbf(S3).sb) - i - Len(bb$)
                                    End If
                                End If
                                kolpo = False
                                
                                If trace Then
                                    TestShowBypass = True
                                    If TestShowBypass Then
                                    If S3 < 0 Then
                                        TestShowSub = var(-S3).code
                                    Else
                                        TestShowSub = sbf(S3).sb
                                    End If
                                    End If
                                    bstack.addlen = Len(TestShowSub) - i + 1 - Len(bb$)
                                End If
                                
                                y2 = y2 + 1
subsub02:
                                Exec = 0
                                x2 = Execute(bstack, bb$, kolpo)
                                If x2 = 2 Then
                                    If bb$ = Chr$(0) Then
                                        If trace Then TestShowBypass = False
                                        If bstack.IsInRetStackString(small$) Then GoTo findelsesub0
                                        y2 = y2 - 1
                                        If y2 = 0 Then GoTo from123  'normal level
                                            p = bstack.isPop3Long(S3, sbi)
                                            If p > 0 Then
                                                If S3 > 0 Then
                                                
                                                    bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                                ElseIf S3 = 0 Then
                                                    GoTo jumphere1
                                                Else
                                                    bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                                End If
                                                If trace Then
                                                    TestShowBypass = True
                                                    If TestShowBypass Then
                                                        If S3 < 0 Then
                                                            TestShowSub = var(-S3).code
                                                        Else
                                                            TestShowSub = sbf(S3).sb
                                                        End If
                                                    End If
                                                    bstack.addlen = sbi
                                                End If
                                                
                                                PopStage bstack
                                                Exec = 1
                                                GoTo subsub02
                                            Else
                                                Exit Do
                                            End If
                                        ElseIf InStr(bb$, " ") > 0 Then
                                            GoTo findelsesub0
                                        Else
                                             If subs Is Nothing Then Set subs = New FastCollection
                                             If subs.ExistKey(bb$) Then
                                                i = subs.Value
                                                If subs.sValue = 0 Then
                                                    If i = 0 Or i > ex2 Then
                                                        B$ = bb$
                                                        Exec = 2
                                                        Exit Do
                                                    Else
                                                        bb$ = Mid$(B$, i, ex2 - i + 1)
                                                    End If
                                                Else
                                                    S3 = subs.sValue
                                                    If S3 < 0 Then
                                                        If i = 0 Or i > Len(var(-S3).code$) Then
                                                            B$ = bb$
                                                            Exec = 2
                                                            Exit Do
                                                        End If
                                                        GoTo AGAINGOTOLAMBDA
                                                    Else
                                                        If i = 0 Or i > Len(sbf(S3).sb) Then
                                                            B$ = bb$
                                                            Exec = 2
                                                            Exit Do
                                                        End If
                                                        GoTo AGAINGOTO
                                                    End If
                                                    
                                                End If
                                                GoTo subsub02
                                            Else
                                                If S3 = 0 Then
                                                ' priority in the code
                                                    i = PosLabel(bb$, B$, ex2)
                                                    If i = 0 Or i > ex2 Then
                                                        GoTo checkother
                                                    Else
                                                        subs.ItemCreator2 bb$, i, 0
                                                        bb$ = Mid$(B$, i, ex2 - i + 1)
                                                        GoTo subsub02
                                                    End If
                                                    
                                                End If
                                                
checkother:
                                                If S3 < 0 Then
                                                    i = PosLabel(bb$, var(-S3).code$)
                                                    If i = 0 Or i > Len(var(-S3).code$) Then
                                                        B$ = bb$
                                                        Exec = 2
                                                        Exit Do
                                                    End If
AGAINGOTOLAMBDA:
                                                    subs.ItemCreator2 bb$, i, S3
                                                    If Len(var(-S3).code$) - i > sbi Then
                                                    bb$ = Mid$(var(-S3).code$, i, Len(var(-S3).code$) - i - sbi)
                                                    Else
                                                    bb$ = Mid$(var(-S3).code$, i)
                                                    sbi = 0
                                                    End If
                                                ElseIf S3 > 0 Then
                                                    i = PosLabel(bb$, sbf(S3).sb)
                                                    If i = 0 Or i > Len(sbf(S3).sb) Then
                                                        B$ = bb$
                                                        Exec = 2
                                                        Exit Do
                                                    End If
                                                    subs.ItemCreator2 bb$, i, S3
AGAINGOTO:
                                                    If Len(sbf(S3).sb) - i > sbi Then
                                                    bb$ = Mid$(sbf(S3).sb, i, Len(sbf(S3).sb) - i - sbi)
                                                    Else
                                                    bb$ = Mid$(sbf(S3).sb, i)
                                                    sbi = 0
                                                    End If
                                                Else ' cascade to upper level
                                                    B$ = bb$
                                                    Exec = 2
                                                    Exit Do
                                                End If
                                                GoTo subsub02
                                            End If
                                        End If
                                    ElseIf x2 = 1 Then
                                        If LastErNum <> -2 Then
                                        ' not good, we have to find which blocks
                                        ' 7 to 5 reduced
                                            bstack.RetStackDrop 5 * bstack.SubLevel - myLevel
                                            ' b$ = ec$  ' why??
                                            Exec = oldexec
                                            Exit Function
                                        End If
                                        ' NO RETURN...DROP STACK
                                        bstack.RetStackDrop 2
                                        Exit Do
                                    ElseIf x2 = 0 Then
                                        If bstack.ErrorOriginal <> 0 Then
                                        B$ = bb$
                                        ElseIf S3 <> 0 Then
                                        
                                           ' If bstack.OriginalCode <> S3 Then
                                            bstack.ErrorOriginal = S3
                                                'If S3 < 0 Then
                                                '    b$ = Mid$(var(-S3).code, Len(var(-S3).code) - sbi - Len(bb$))
                                                'Else
                                                B$ = bb$ + space(sbi + 1) 'Mid$(sbf(S3).sb, Len(sbf(S3).sb) - sbi - Len(bb$))
                                                'End If
                                            'Else
                                            'b$ = bb$  '+ space(sbi)
                                            'End If
                                        Else
                                        bstack.ErrorOriginal = 0
                                        B$ = bb$ + space(sbi)
                                        End If
                                        Exec = 0
                                        Exit Function
                                    End If
                                Else
                                    badSubNotFound
                                    Exec = 0
                                    If bstack.IsDecimal Then
                                         p = bstack.Pop3Long(S3, sbi)
                                         If S3 > 0 Then
                                             bb$ = Mid$(sbf(S3).sb, Len(sbf(S3).sb) - p - sbi + 1, p)
                                          ElseIf S3 = 0 Then
                                            bb$ = Mid$(B$, p + 1, ex2 - p)
                                         Else
                                             bb$ = Mid$(var(-S3).code$, Len(var(-S3).code$) - p - sbi + 1, p)
                                         End If
                                    End If
                                    bstack.RetStackDrop 3 '5
                                    GoTo error1
                                End If
                            Else
                                bstack.RetStackDrop 3 '5
                                Exit Do
                            End If
                        Else
                            bstack.RetStackDrop 1
                            B$ = Chr$(0)
                            Exec = 2
                            Exit Function
                        End If
                    End If
                ElseIf lookOne(bb$, "}") Or NocharsInLine(bb$) Then
                    i = 1
                    bb$ = Left$(B$, ex2)
                Else
                    If monce = True Then
                        B$ = bb$
                        Exec = w3
                        Exit Do
                    End If
                    If subs Is Nothing Then Set subs = New FastCollection
                    If subs.ExistKey(bb$) Then
                        i = subs.Value
                        If i = 0 Or i > ex2 Then
                            B$ = bb$
                            Exec = 2
                            Exit Do
                        Else
                            bb$ = Mid$(B$, i, ex2 - i + 1)
                            GoTo fromfirst0
                        End If
                    Else
                        i = PosLabel(bb$, B$, ex2)
                        If i = 0 Or i > ex2 Then
                            B$ = bb$
                            Exec = 2
                            Exit Do
                        Else
                            subs.ItemCreator2 bb$, i, 0
                            bb$ = Mid$(B$, i, ex2 - i + 1)
                            GoTo fromfirst0
                        End If
                    End If
                End If
            Else
                If noblock Then
                    If loopthis And w3 = 2 Then
                        oldexec = 2
                        If Len(NLtrim$(bb$)) > 0 Then
                            GoTo fromfirst0
                        End If
                        loopthis = False
                        i = 1
                        oldexec = 1
                    Else
                        i = 1
                    End If
                Else
                    If w3 = 2 Then w3 = 6
                    Exec = w3
                    Exit Function
                End If
            End If
        Else
            If monce Then
                If loopthis And kolpo Then Exec = 5: B$ = bb$: Exit Function
                kolpo = False
            Else
                once = kolpo
            End If
            If myexit(bstack) Then Exec = oldexec: Exit Do
            Exec = 2: B$ = bb$: Exit Function
        End If
    Case Else
        If w3 = 12 Then
            B$ = bb$
            Exec = 12
            Exit Do
        ElseIf w3 = 3 And bb$ = "CONTINUE" Then
            If noblock Then
                B$ = Mid$(B$, ex2 + 1)
            Else
                B$ = bb$
            End If
            If RetStackSize < bstack.RetStackTotal Then PopStagePartContinue bstack, bstack.RetStackTotal - RetStackSize
            If myexit(bstack) Then Exec = oldexec: Exit Do
            Exec = 3: Exit Do
        ElseIf w3 = 3 And NocharsInLine(bb$) Then
            bb$ = Mid$(B$, ex2 + 1)
            w3 = 1
            GoTo ALFA12   ' FROM REVISION 121
        ElseIf w3 = 5 Then
            oldexec = 5
            If Len(NLtrim$(bb$)) > 0 Then GoTo fromfirst0
            Exec = 5
            Exit Function
        End If
        If IsSymbol(B$, "}") Then
            Exec = 1: Exit Do
            If once Then Exit Do
        Else
            B$ = Right$(B$, Len(B$) - Len(bb$))
        End If
        Exit Do
    End Select
   
    If myexit(bstack) Then Exec = oldexec: Exit Do
    If monce Then Exit Do
Loop
If Exec > 1 Then
    If bstack.RetStackTotal - RetStackSize > 0 Then
        bstack.UseofIf = olduseofif
        bstack.RetStackDrop bstack.RetStackTotal - RetStackSize
    End If
End If
bstack.jump = oldjump
bstack.IFCTRL = oldifctrl

executeblock = False
End Function
Function StockValues(bstack As basetask, B$, Lang As Long) As Boolean
' Stock  A[$|%| ]() in  A,B$,C(3)   copy values to stock array...and

' Stock  A[$|%| ]() out  A,B$,C(3),...  copy values to variables and make empty space in stock

' Stock A[$|%| ]()  keep  N,  B[$|%| ]()
' Stock A[$|%| ]()  sweep  N [,  value ]   fill a copy of value to n items or empty slots
Dim w$, pppp As mArray, v As Long, VN As Long, i As Long, what$, pppp1 As mArray, v1 As Long
Dim bs As New basetask, p As Variant, p1 As Variant, soros As mStiva, ww$, ss$, usehandler As mHandler
If Abs(IsLabel(bstack, B$, what$)) > 4 Then
        If neoGetArray(bstack, what$, pppp) Then
If Not pppp.Arr Then NeedAnArray1: Exit Function
                If NeoGetArrayItem(pppp, bstack, what$, v, B$) Then
againhere:
                            If IsLabelSymbolNew(B$, "апо", "IN", Lang) Then
                            
                                If what$ = vbNullString Then Exit Function   ' no for no named array
                                Set soros = bstack.soros
                                Set bstack.Sorosref = bs.soros
                                ' Need bstack and not bs because bstack has more info inside.
                                    If MyData(bstack, B$) Then
                                     Set bstack.Sorosref = soros
                                     Set soros = Nothing
                                                   VN = v + bs.soros.Total - 1
                                                   If pppp.UpperMonoLimit >= VN Then
                                                            With bs.soros
                                                                     i = 1
                                                                     For v = v To VN
                                                                              If Not .StackItemTypeIsObject(i) Then
                                                                                       pppp.item(v) = .StackItem(i)
                                                                              Else
                                                                            If TypeOf .StackItem(i) Is mArray Then
                                                                            If .StackItem(i).Arr Then
                                                                                Set pppp1 = New mArray
                                                                                .StackItem(i).CopyArray pppp1
                                                                                Set pppp.item(v) = pppp1
                                                                                Else
                                                                                       Set pppp.item(v) = .StackItem(i)
                                                                                End If
                                                                            Else
                                                                                       Set pppp.item(v) = .StackItem(i)
                                                                                       End If
                                                                                       
                                                                              End If
                                                                              i = i + 1
                                                                     Next v
                                                            End With
                                                   Else
                                                            MyEr "Stock out of space", "тО СТОЙ щЛЕИМЕ АПЭ ВЧЯО"
                                                            Exit Function
                                                   End If
                                                    StockValues = True
                                                    Exit Function
                                    End If
                            ElseIf IsLabelSymbolNew(B$, "се", "OUT", Lang) Then
                                                  
                                                                     Do
                                                                        If MyIsObject(pppp.item(v)) Then
                                                                       
                                                                                        Select Case Abs(IsLabel(bstack, B$, w$))
                                                                                        Case 1, 4
                                                                                        If GetVar(bstack, w$, i, , , , ww$) Then
                                                                                        If Typename$(var(i)) = mgroup Then
                                                                                            ss$ = bstack.GroupName
                                                                                            If ww$ <> "" Then w$ = ww$
                                                                                            If Len(var(i).GroupName) > Len(w$) Then
                                                                                                If var(i).IamRef Then
                                                                                                    ww$ = here$
                                                                                                    here$ = vbNullString
                                                                                                    UnFloatGroupReWriteVars bstack, w$, i, pppp.item(v)
                                                                                                    here = ww$
                                                                                                Else
                                                                                                    UnFloatGroupReWriteVars bstack, w$, i, pppp.item(v)
                                                                                                End If
                                                                                            Else
                                                                                                bstack.GroupName = Left$(w$, Len(w$) - Len(var(i).GroupName) + 1)
                                                                                                w$ = Left$(var(i).GroupName, Len(var(i).GroupName) - 1)
                                                                                                If Len(var(i).GroupName) > 0 Then
                                                                                                    ww$ = here$
                                                                                                    here$ = vbNullString
                                                                                                    UnFloatGroupReWriteVars bstack, w$, i, pppp.item(v)
                                                                                                    here = ww$
                                                                                                Else
                                                                                                    bstack.GroupName = ss$
                                                                                                    GroupWrongUse
                                                                                                    StockValues = False
                                                                                                    Exit Function
                                                                                                End If
                                                                                            End If
                                                                                            bstack.GroupName = ss$
                                                                                          Else
                                                                                                bs.soros.PushObj pppp.item(v)
                                                                                                bs.soros.Copy2TopItem 1
                                                                                                Set var(i) = bs.soros.PopObj
                                                                                                bs.soros.drop 1
                                                                                           
                                                                                           
                                                                                        End If
                                                                                        Else
                                                                                            i = globalvar(w$, 0)
                                                                                            
                                                                                                bs.soros.PushObj pppp.item(v)
                                                                                                bs.soros.Copy2TopItem 1
                                                                                                If TypeOf pppp.itemObject(v) Is mArray Then
                                                                                                    If pppp.item(v).Arr Then
                                                                                                        Set usehandler = New mHandler
                                                                                                        Set var(i) = usehandler
                                                                                                        usehandler.t1 = 3
                                                                                                        Set usehandler.objref = bs.soros.PopObj
                                                                                                    Else
                                                                                                        Set var(i) = bs.soros.PopObj
                                                                                                    End If
                                                                                                Else
                                                                                                Set var(i) = bs.soros.PopObj
                                                                                                End If
                                                                                                bs.soros.drop 1
                                                                                        End If
                                                                                        Case 3
                                                                                        If GetVar(bstack, w$, i) Then Set var(i) = pppp.item(v)
                                                                                        Case 5, 6, 7
                                                                                         If neoGetArray(bstack, w$, pppp1) Then
                                                                                         If Not pppp1.Arr Then NeedAnArray1: Exit Function
                                                                                            If IsSymbol(B$, ")") Then
                                                                                                bs.soros.PushObj pppp.item(v)
                                                                                                        If Not globalArrByPointer(bs, bstack, w$) Then MissingArray
                                                                                                Else
                                                                                                        If NeoGetArrayItem(pppp1, bstack, w$, v1, B$) Then
                                                                                                               Set pppp1.item(v1) = pppp.item(v)
                                                                                                        End If
                                                                                                End If
                                                                                        ElseIf IsSymbol(B$, ")") Then
                                                                                                        bs.soros.PushObj pppp.item(v)
                                                                                                        If Not globalArrByPointer(bs, bstack, w$) Then MissingArray
                                                                                                End If

                                                                                        
                                                                                        End Select
                                                                        Else
                                                                        Select Case Abs(IsLabel(bstack, B$, w$))
                                                                                        Case 1, 3, 4
                                                                                        If GetVar(bstack, w$, i) Then
                                                                                        Else
                                                                                        i = globalvar(w$, 0)
                                                                                        End If
                                                                                        If MyIsObject(var(i)) Then
                                                                                        
                                                                                        If TypeOf var(i) Is Document Then
                                                                                            var(i).EmptyDoc
                                                                                            var(i).textDoc = pppp.item(v)
                                                                                        Else
                                                                                        
                                                                                        End If
                                                                                        Else
                                                                                        var(i) = pppp.item(v)
                                                                                        End If
                                                                                        Case 5, 6, 7
                                                                                         If neoGetArray(bstack, w$, pppp1) Then
                                                                                         If Not pppp1.Arr Then MissingArray: Exit Function
                                                                                         If lookOne(B$, ")") Then
                                                                                         If NeoGetArrayItem(pppp1, bstack, w$ + ")", v1, "") Then
                                                                                         
                                                                                         Else
                                                                                         i = -1
                                                                                         GlobalArr bstack, w$, vbNullString, 0, i
                                                                                         Set var(i) = pppp.item(v)
                                                                                         
                                                                                         End If
                                                                                         Else
                                                                                                If NeoGetArrayItem(pppp1, bstack, w$, v1, B$) Then
                                                                                                     pppp1.item(v1) = pppp.item(v)
                                                                                                End If
                                                                                         End If
                                                                                         End If
                                                                                        End Select
                                                                        
                                                                        End If
                                                                        v = v + 1
                                                                          If pppp.UpperMonoLimit < v Then
                                                                          If lookOne(B$, ",") Then
                                                                                UpperArrayLimit
                                                                          Exit Function
                                                                          End If
                                                                          End If
                                                                        Loop Until Not FastSymbol(B$, ",")
                                                  
                                                    ElseIf IsLabelSymbolNew(B$, "циа", "KEEP", Lang) Then
                                                    
                                                    If IsExp(bstack, B$, p) Then
                                                            If p <> MyRound(p) Or p < 0 Then
                                                                        MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                                                                        Exit Function
                                                            End If
                                                                     If IsSymbol(B$, ",") Then
                                                                     If Abs(IsLabel(bstack, B$, w$)) > 4 Then
                                                                        If neoGetArray(bstack, w$, pppp1) Then
                                                                        If Not pppp1.Arr Then NeedAnArray1: Exit Function
                                                                         If NeoGetArrayItem(pppp1, bstack, w$, v1, B$) Then
                                                                                   If Not (v1 + p - 1 <= pppp1.UpperMonoLimit) Then
                                                                                                MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                                                                                                Exit Function
                                                                                   Else
                                                                                   If pppp1 Is pppp Then
                                                                                   If v = v1 Then
                                                                                   ' do nothing
                                                                                   ElseIf Abs(v - v1) < p Then
                                                                                   'from top
                                                                                   If v1 > v Then
                                                                                               For i = p - 1 To 0 Step -1
                                                                                                                With pppp
                                                                                                                If MyIsObject(.item(i + v)) Then
                                                                                                                If i + v < v1 Then
                                                                                                                    bs.soros.PushObj .item(i + v)
                                                                                                                    bs.soros.Copy2TopItem 1
                                                                                                                    Set pppp1.item(i + v1) = bs.soros.PopObj
                                                                                                                    bs.soros.drop 1
                                                                                                                Else
                                                                                                                       Set pppp1.item(i + v1) = .item(i + v)
                                                                                                                End If
                                                                                                                Else
                                                                                                                     pppp1.item(i + v1) = .item(i + v)
                                                                                                                End If
                                                                                                                End With
                                                                                               Next i
                                                                                    Else  ' v > V1
                                                                                            For i = 0 To p - 1
                                                                                                                With pppp
                                                                                                                If MyIsObject(.item(i + v)) Then
                                                                                                                If p + v1 <= v + i Then
                                                                                                                    bs.soros.PushObj .item(i + v)
                                                                                                                    bs.soros.Copy2TopItem 1
                                                                                                                    Set pppp1.item(i + v1) = bs.soros.PopObj
                                                                                                                    bs.soros.drop 1
                                                                                                                    Else
                                                                                                                    Set pppp1.item(i + v1) = .item(i + v)
                                                                                                                    End If
                                                                                                                Else
                                                                                                                    pppp1.item(i + v1) = .item(i + v)
                                                                                                                End If
                                                                                                                End With
                                                                                               Next i
                                                                                    
                                                                                    End If
                                                                                   Else
                                                                                            For i = 0 To p - 1
                                                                                                                With pppp
                                                                                                                If MyIsObject(.item(i + v)) Then
                                                                                                                    bs.soros.PushObj .item(i + v)
                                                                                                                    bs.soros.Copy2TopItem 1
                                                                                                                    Set pppp1.item(i + v1) = bs.soros.PopObj
                                                                                                                    bs.soros.drop 1
                                                                                                                Else
                                                                                                                    pppp1.item(i + v1) = .item(i + v)
                                                                                                                End If
                                                                                                                End With
                                                                                               Next i
                                                                                   End If

                                                                                   Else
                                                                                               For i = 0 To p - 1
                                                                                                                With pppp
                                                                                                                If MyIsObject(.item(i + v)) Then
                                                                                                                    bs.soros.PushObj .item(i + v)
                                                                                                                    bs.soros.Copy2TopItem 1
                                                                                                                    Set pppp1.item(i + v1) = bs.soros.PopObj
                                                                                                                    bs.soros.drop 1
                                                                                                                    
                                                                                                                Else
                                                                                                                      pppp1.item(i + v1) = .item(i + v)
                                                                                                                End If
                                                                                                                End With
                                                                                               Next i
                                                                                    End If
                                                                                    StockValues = True
                                                                                    Exit Function
                                                                                    End If
                                                                                                End If
                                                                                  End If
                                                                                  ElseIf Right$(w$, 1) = "$" Then
                                                                                   If GetVar(bstack, w$, v1) Then
                                                                                    var(v1) = vbNullString
                                                                                        Else
                                                                                        v1 = globalvar(w$, "")
                                                                                        End If
                                                                                        VN = Right$(what$, 3) = "$"
                                                                                         If p - 1 + v > pppp.UpperMonoLimit Then
                                                                                          MyEr "Invalid copy number", "лГ щЦЙУЯОР ДЕъЙТГР АМТИЦЯАЖчР"
                                                                                         Exit Function
                                                                                         End If
                                                                                    For i = 0 To p - 1
                                                                                                                With pppp
                                                                                                                If MyIsObject(.item(i + v)) Then
                                                                                                                        If VN Then var(v1) = var(v1) + Sput("") Else var(v1) = var(v1) & " 0"
                                                                                                                Else
                                                                                                                  
                                                                                                                     Select Case Typename(.item(i + v))
                                                                                                                     Case "Double"
                                                                                                                     var(v1) = var(v1) + " " + Trim$(Str(.item(i + v)))
                                                                                                                     Case "String"
                                                                                                                     w$ = .item(i + v)
                                                                                                                     If IsNumberD2(w$, p) Then
                                                                                                                     var(v1) = var(v1) + " " + .item(i + v)
                                                                                                                     Else
                                                                                                                     var(v1) = var(v1) + Sput(.item(i + v))
                                                                                                                     End If
                                                                                                                     Case Else
                                                                                                                     If VN Then var(v1) = var(v1) + Sput("") Else var(v1) = var(v1) & " 0"
                                                                                                              
                                                                                                                     ''var(V1) = var(V1) & " " & Trim$(Str$(.item(i + V)))
                                                                                                                     End Select
                                                                                                                End If
                                                                                                                End With
                                                                                               Next i
                                                                                               
                                                                                   StockValues = True
                                                                                    Exit Function
                                                                                  End If
                                                   End If
                                                   End If

                                                    
                                                    ElseIf IsLabelSymbolNew(B$, "хесе", "SWEEP", Lang) Then
                                                    If what$ = vbNullString Then Exit Function   ' no for no named array
                                                            If IsExp(bstack, B$, p) Then
                                                                            If p <> MyRound(p) Or p < 0 Then
                                                                                   MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                                                                                   Exit Function
                                                                            End If
                                                         
                                                                If Not (v + p - 1 <= pppp.UpperMonoLimit) Then
                                                                            MyEr "Invalid index", "лГ щЦЙУЯОР ДЕъЙТГР"
                                                                            Exit Function
                                                                Else
                                                                    If Not IsSymbol(B$, ",") Then
                                                                                                                For i = 0 To p - 1
                                                                                                               If MyIsObject(pppp.item(i + v)) Then
                                                                                                               Set pppp.item(i + v) = Nothing
                                                                                                               End If
                                                                                                                pppp.item(i + v) = Empty
                                                                                                                Next i
                                                                    
                                                                    Else
                                                                    
                                                                            i = 1
                                                                            what$ = aheadstatus(B$, False, i)
                                                                            Set bstack.lastobj = Nothing
                                                                            If what$ <> "" Then
                                                                                            If Left$(what$, 1) = "N" Then
                                                                                                        If IsNumber(bstack, B$, p1) Then
                                                                                                                If bstack.lastobj Is Nothing Then
                                                                                                                For i = 0 To p - 1
                                                                                                                pppp.item(i + v) = p1
                                                                                                                Next i
                                                                                                                Else
                                                                                                            bs.soros.PushObj bstack.lastobj
                                                                                                                Set bstack.lastobj = Nothing
                                                                                                                For i = 0 To p - 1
                                                                                                                bs.soros.Copy2TopItem 1
                                                                                                                Set pppp.item(i + v) = bs.soros.PopObj
                                                                                                                Next i
                                                                                                                End If
                                                                                                        End If
                                                                                            Else
                                                                                                        If IsString(bstack, B$, what$) Then
                                                                                                                If bstack.lastobj Is Nothing Then
                                                                                                                For i = 0 To p - 1
                                                                                                               
                                                                                                                pppp.item(i + v) = what$
                                                                                                                Next i
                                                                                                                Else
                                                                                                                                                bs.soros.PushObj bstack.lastobj
                                                                                                                Set bstack.lastobj = Nothing
                                                                                                                For i = 0 To p - 1
                                                                                                                bs.soros.Copy2TopItem 1
                                                                                                                Set pppp.item(i + v) = bs.soros.PopObj
                                                                                                                Next i
                                                                                                                End If
                                                                                                                End If
                                                                                                        End If
                                                                                            End If
                                                                                    End If
                                                                                    End If
                                                          
                                                            End If
                                                        End If
                                                    End If
                                                    StockValues = True
                                Else
                            B$ = what$ + B$
                            If IsExp(bstack, B$, p) Then
                            what$ = vbNullString
                            If Typename(bstack.lastobj) = myArray Then Set pppp = bstack.lastobj: Set bstack.lastobj = Nothing: GoTo againhere
                            
                            ElseIf IsStrExp(bstack, B$, what$) Then
                            what$ = vbNullString
                            If Typename(bstack.lastobj) = myArray Then Set pppp = bstack.lastobj: Set bstack.lastobj = Nothing: GoTo againhere
                            End If
                            End If
                           
                    End If
            
End Function
Public Function SubsExist() As Boolean
SubsExist = subHash.count > 0
End Function
Sub TraceStore(B As basetask, v As Long, c$, o&)
     v = B.addlen
         B.addlen = Len(c$) - o& + B.addlen

End Sub
Sub TraceRestore(B As basetask, v As Long)
         B.addlen = v
End Sub
Sub ProcBackGround(bstack As basetask, rest$, Lang As Long, afier As Boolean)
Dim s$, nd&, p As Variant, i As Long, x1 As Long, X As Double, Y As Double, f As Long, y1 As Long, sX As Double, ss$, pa$, it As Long
Dim Scr As Object, frm$, w3 As Long, ya As Long, AddTwipsTopL As Long, once As Boolean, oldprintFlag As Boolean
Set Scr = bstack.Owner
afier = True
Dim prive As basket
If IsLabelSymbolNew(rest$, "лоусийг", "MUSIC", Lang) Then
    If IsStrExp(bstack, rest$, s$) Then
        'OPEN OR REPLACE
        If s$ <> "" Then
            If ExtractType(s$) = vbNullString Then s$ = s$ & ".avi"
            If CFname(s$) = vbNullString Then
                s$ = mcd & s$: If CFname(s$) = vbNullString Then Exit Sub
            Else
                s$ = CFname(s$)
            End If
            If s$ <> "" Then
                MediaBack1.closeMovie
                MediaBack1.FileName = s$
                MediaBack1.openMovie
                MediaBack1.playMovie
            End If
        Else
            afier = False
            Exit Sub
        End If
    Else
        ' CLOSE
        MediaBack1.closeMovie
    End If
Else
    oldprintFlag = bstack.toprinter
    If oldprintFlag Then bstack.toprinter = False
    If Not IsExp(bstack, rest$, p) Then p = 0   '' no change
    If lookOne(rest$, "{") Then
        '' check players(-2)
          
        If players(-1).SZ = 0 Or Not NoBackFormFirstUse Then
            If players(-1).Paper <> Form1.BackColor Or Not NoBackFormFirstUse Then
                Form1.BackColor = players(-1).Paper
            End If
            prive = players(GetCode(Scr))
         
            NoBackFormFirstUse = True
            SetTextBasketBack Form1, prive
            SetText Form1, prive.MineLineSpace, True    'load Players() with first values
            With players(-1)
                .mypentrans = 255
                .curpos = 0
                .currow = 0
                .mysplit = 0
                .osplit = 0
                .Paper = prive.Paper
                .ReportTab = ReportTabWidth
            End With
            With Prefresh(-1)
                .k1 = uintnew(timeGetTime + REFRESHRATE): .RRCOUNTER = 1
            End With
            
        End If
        If p > 0 Then
            SetTextSZ Form1, CSng(p)
        End If
        w3 = bstack.tolayer
        bstack.toback = True
        Set bstack.Owner = Form1
     
        nd& = bstack.addlen
        it = Execute(bstack, rest$, False, True, , True)
        bstack.addlen = nd&
        If it = 2 Then
            If rest$ = "" Then
                rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
            Else
                rest$ = ": Goto " + rest$
                If trace Then WaitShow = 2: TestShowSub = rest$
            End If
            it = 1
        End If
    End If
    MyDoEvents2 bstack.Owner
    Set bstack.Owner = Scr
    bstack.tolayer = w3
    bstack.toback = False
    afier = it = 1
    oldprintFlag = bstack.toprinter
    If oldprintFlag Then bstack.toprinter = False
End If
End Sub

Sub SetSizeAndHotSpot(thisbasket As basket, maxx As Long, MaxY As Long, Optional ByVal HotSpotX = 0, Optional ByVal HotSpotY = 0)
With thisbasket
.MAXXGRAPH = maxx
.MAXYGRAPH = MaxY
If Not IsMissing(HotSpotX) Then .X = CLng(HotSpotX)  ' this is hotspot
If Not IsMissing(HotSpotY) Then .Y = CLng(HotSpotY)
End With
End Sub
Sub FeedBasket(DDD As Object, thisbasket As basket, alinespace As Long)
With thisbasket
.FontName = DDD.FontName
.SZ = DDD.FontSize
.charset = DDD.Font.charset
.MineLineSpace = alinespace
.uMineLineSpace = alinespace
''.Paper = ddd.BackColor
FrameText DDD, .SZ, 0, 0, -.Paper, (DDD.Name <> "Form1")

End With
End Sub
Sub PlaceBasketPrive(DDD As Object, thisbasket As basket)
On Error Resume Next
With thisbasket
If Not DDD.FontName = .FontName And DDD.Font.charset = .charset And DDD.FontSize = .SZ Then
DDD.Font.charset = 0
DDD.FontSize = 9
DDD.FontName = .FontName
DDD.Font.charset = .charset
DDD.FontSize = .SZ
End If
' these I have to delete after change
End With
End Sub
Sub PlaceBasket(DDD As Object, thisbasket As basket)
On Error Resume Next
With thisbasket
If Not (DDD.FontName = .FontName And DDD.Font.charset = .charset And DDD.Font.Size = .SZ) Then
StoreFont .FontName, .SZ, .charset
DDD.Font.charset = 0
DDD.FontSize = 9
DDD.FontName = .FontName
DDD.Font.charset = .charset
DDD.FontSize = .SZ
End If
DDD.forecolor = .mypen
End With
End Sub
Function GetCode(dq As Object) As Long
Dim u As Long
    If dq Is Form1.DIS Or dq Is Nothing Then
        GetCode = 0
    ElseIf dq Is Form1 Then
        GetCode = -1
    ElseIf dq Is Form1.PrinterDocument1 Then
        GetCode = -2
    ElseIf (TypeOf dq Is GuiM2000) Or (TypeOf dq Is GuiImage) Then
        On Error Resume Next
        u = dq.prive
        ' check this again
        If Err > 0 Then Err.Clear: oxiforforms: GetCode = -1: Set dq = Form1: Exit Function
        If u = 0 Then
        For u = 33 To 1032
        If Not players(u).used Then Exit For
        Next u
        If u = 1033 Then ResourceLimit: GetCode = -1: Set dq = Form1: Exit Function
        players(u) = Zero
        dq.prive = u
        
        
        players(u).used = True
        End If
        
        GetCode = u
    ElseIf TypeOf dq Is MetaDc Then
        On Error Resume Next
        u = dq.prive
        ' check this again
        If Err > 0 Then Err.Clear: oxiforMetaFiles: GetCode = -1: Set dq = Form1: Exit Function
        If u = 0 Then
            For u = 33 To 1032
                If Not players(u).used Then Exit For
            Next u
            If u = 1033 Then ResourceLimit: GetCode = -1: Set dq = Form1: Exit Function
            dq.prive = u
            players(u) = Zero
            players(u).used = True
        End If
        GetCode = u
    ElseIf TypeOf dq Is PictureBox Then
        If dq.Name = "dSprite" Then
            GetCode = dq.index
        Else
            GetCode = CLng("0" & dq.Tag)
        End If
    End If
End Function




Static Function MyRound(a As Variant, Optional ByVal i As Integer = 0)
Dim c As Variant, j As VbVarType
Dim n(1 To 28) As Single, D(1 To 28) As Double, cur(1 To 28) As Currency, dec(1 To 28) As Variant
Dim SG(-1 To 1) As Single, sg4(-1 To 1) As Double, sg8(-1 To 1) As Currency
j = VarType(a)
If j < vbSingle Then MyRound = a: Exit Function
On Error GoTo there
If n(1) = 0 Then
    SG(-1) = CSng(-0.5)
    SG(1) = CSng(0.5)
    sg4(-1) = -0.5
    sg4(1) = 0.5
    sg8(-1) = CCur(-0.5)
    sg8(1) = CCur(0.5)
    For c = 1& To 6&
        n(c) = CSng(10 ^ c)
    Next c
    For c = 7& To 27&
        n(c) = CSng(-1)
    Next c
        n(c) = CSng(10 ^ 5)
        n(10) = CSng(10 ^ 5)
    For c = 1& To 13&
        D(c) = CDbl(10 ^ c)
    Next c
    For c = 14& To 27&
        D(c) = CDbl(-1)
    Next c
    D(c) = CDbl(10 ^ 13)
    
    For c = 1& To 3&
        cur(c) = CCur(10 ^ c)
    Next c
    For c = 4& To 28&
        cur(c) = CCur(-1)
    Next c
    For c = 1& To 28&
        dec(c) = CDec(10 ^ c)
    Next c
End If
    If i = 0 Then
        MyRound = Sgn(a) * Int(Abs(a) + 0.5)
        Exit Function
    Else
        c = Fix(a)
        Select Case j
        Case vbSingle
            If n(i) > 0 Then
                c = SG(Sgn(a))
                MyRound = Fix(a * n(i) + c) / n(i)
            Else
                MyRound = a
            End If
            Exit Function
        Case vbDouble
            c = sg4(Sgn(a))
 
            If D(i) > 0 Then
                MyRound = Fix(a * D(i) + c) / D(i)
            Else
                MyRound = a
            End If
            Exit Function
        Case vbCurrency
            If cur(i) > 0 Then
                c = sg8(Sgn(a))
                MyRound = Fix(a) + Fix((a - Fix(a)) * cur(i) + c) / cur(i)
            Else
                MyRound = a
            End If
            Exit Function
        Case vbDecimal
            c = sg8(Sgn(a))
            MyRound = Fix(a) + Fix((a - Fix(a)) * dec(i) + c) / dec(i)
            Exit Function
        Case Else
            MyRound = a
            Exit Function
        End Select
    End If
there:
Err.Clear
MyRound = a
If i < 0 Or i > 28 Then MyEr "Round Place exit range 0 to 28", "г ХщСГ СТЯОЦЦУКОПОъГСГР ЕЙТЭР ПЕЯИОВчР АПЭ 0 щЫР 28"
End Function


Function AllocVar()
var2used = var2used + 1
  If UBound(var()) <= var2used + 20 Then
            varhash.Expand UBound(var()) * 2
            On Error Resume Next
            If UBound(var()) <> varhash.MaxSpace Then
                    ReDim Preserve var(varhash.MaxSpace) As Variant
            End If
            If Err.Number > 0 Then
                NOEXECUTION = True
                MyEr Err.Description, Err.Description
                Err.Clear
                Exit Function
            End If
            
        End If
       AllocVar = var2used
End Function
Function AllocSub() As Long
    'On Error Resume Next
    If UBound(sbf()) <= sb2used + 1 Then
        subHash.Expand UBound(sbf()) * 2
        If UBound(sbf()) <> subHash.MaxSpace Then
            ReDim Preserve sbf(subHash.MaxSpace) As modfun
        End If
    End If
    sb2used = sb2used + 1
    AllocSub = sb2used
End Function

Function ProcEventVarSet(bstack As basetask, i As Long) As mEvent

If i = -1 Then  '
    If Typename(bstack.lastobj) = "mEvent" Then
    Set ProcEventVarSet = bstack.lastobj
    Else
    MyEr "Not found an object Event", "дЕМ БЯчЙА щМА АМТИЙЕъЛЕМО цЕЦОМЭР"
    Exit Function
    End If
Else
    Set ProcEventVarSet = var(i)
End If
End Function
Function ProcEvent(bstack As basetask, rest$, Lang As Long, i As Long) As Boolean
'look for { }, or hold
Dim aa As mEvent, s$, lastname$, dd As Long, pm As Long, pf As Long
ProcEvent = True
Dim ss$, rd$, ss1$
If FastSymbol(rest$, "{") Then
Set aa = ProcEventVarSet(bstack, i)
aa.BypassInit 10
aa.VarIndex = i
If here$ = vbNullString Then
    aa.NoHere = bstack.GroupName
Else
    aa.NoHere = here$ + "." + bstack.GroupName
End If
aa.Enabled = True
ss$ = NLtrim$(block(rest$))
rd$ = vbNullString
While ss$ <> ""
If FastSymbol(ss$, vbCrLf, , 2) Then
ss$ = NLtrim(ss$)
ElseIf IsLabelSymbolNew(ss$, "диабасе", "READ", Lang) Then
If Lang = 1 Then
If rd$ = vbNullString Then rd$ = "READ "
Else
If rd$ = vbNullString Then rd$ = "диабасе "
End If

Do
dd = 1
      s$ = aheadstatus(ss$, , dd)
      If s$ <> "" Then
      pm = pm + 1
      If FastPureLabel(ss$, ss1$, , , , , False) Then
   
            If pm < 2 Then
            rd$ = rd$ + Left$(ss$, dd - 1)
            Else
            rd$ = rd$ + "," + Left$(ss$, dd - 1)
            End If
      
      ss$ = Mid$(ss$, dd)
      Else
      ProcEvent = False
      Exit Function
      End If
      Else
      Exit Do
      End If
   Loop Until Not FastSymbol(ss$, ",")

ElseIf IsLabelSymbolNew(ss$, "сумаятгсг", "FUNCTION", Lang) Then
'' check only for blocks
pf = pf + 1
If FastSymbol(ss$, "{") Then
s$ = "{" + rd$ + vbCrLf + block(ss$) + "}" + here$ + "." + bstack.GroupName
If Not FastSymbol(ss$, "}") Then ProcEvent = False: Exit Function
aa.GenItemCreator LTrim$(Str(pf * 123)), s$
While ss$ <> ""
If FastSymbol(ss$, vbCrLf, , 2) Then
    ss$ = NLtrim(ss$)
ElseIf IsLabelSymbolNew(ss$, "сумаятгсг", "FUNCTION", Lang) Then
        If FastSymbol(ss$, "{") Then
            s$ = "{" + rd$ + vbCrLf + block(ss$) + "}"
            If Not FastSymbol(ss$, "}") Then ProcEvent = False: Exit Function
            ' БэКЕ щМА key
            pf = pf + 1
            aa.GenItemCreator LTrim$(Str(pf * 123)), s$
        Else
            ProcEvent = False: Exit Function
        End If
Else
    ProcEvent = False: Exit Function
End If
Wend
End If
Else
    ProcEvent = False: Exit Function
End If
Wend
aa.ParamBlock rd$, pm




Set aa = Nothing

If Not FastSymbol(rest$, "}") Then ProcEvent = False: Exit Function
' do something
' find Read command and some Functions
ElseIf IsLabelSymbolNew(rest$, "ажгсе", "RELEASE", Lang) Then
    Set aa = ProcEventVarSet(bstack, i)
    aa.Enabled = True
ElseIf IsLabelSymbolNew(rest$, "йяатгсе", "HOLD", Lang) Then
    Set aa = ProcEventVarSet(bstack, i)
    aa.Enabled = False
ElseIf IsLabelSymbolNew(rest$, "йахаяо", "CLEAR", Lang) Then
    Set aa = ProcEventVarSet(bstack, i)
    aa.Enabled = False
    aa.BypassInit 10
ElseIf IsLabelSymbolNew(rest$, "мео", "NEW", Lang) Then
    Set aa = ProcEventVarSet(bstack, i)
    Do
        dd = 1
        ss$ = aheadstatus(rest$, , dd)
        If ss$ = "S" Then
            lastname$ = here$ + "." + MyTrim(myUcase(Left(rest$, dd - 1), True))
            If Not IsStrExp(bstack, rest$, s$) Then ProcEvent = False: Exit Function
            If Not lookOne(s$, "{") Then
            If GetSub(s$, pm) Then
                If sbf(pm).Extern > 0 Then
                    s$ = "{ call extern" + Str$(sbf(pm).Extern) + "}" + sbf(pm).sbgroup
                Else
                    s$ = "{" + sbf(pm).sb + "}" + sbf(pm).sbgroup
                End If
            Else
            s$ = "{CALL VOID " + s$ + "}"
            End If
            End If
        ElseIf ss$ = "N" Then
            ss$ = "&" + Left$(rest$, dd)
            If Not IsString(bstack, (ss$), s$) Then
                ProcEvent = False: Exit Function
            Else
                lastname$ = subHash.LastKnown
            End If
            rest$ = Mid$(rest$, dd)
        Else
            s$ = vbNullString
        End If
        If Len(s$) > 1 Then
            If Not aa.StandBy("(FREE)", lastname$, s$) Then aa.GenItemCreator lastname$, s$
        Else
            ProcEvent = False
            Exit Function
        End If
    Loop Until Not FastSymbol(rest$, ",")
    Set aa = Nothing
ElseIf IsLabelSymbolNew(rest$, "пета", "DROP", Lang) Then
    Set aa = ProcEventVarSet(bstack, i)
    Do
        dd = 1
        ss$ = aheadstatus(rest$, , dd)
        If ss$ = "S" Then
              lastname$ = here$ + "." + MyTrim(myUcase(Left(rest$, dd - 1), True))
              If Not IsStrExp(bstack, rest$, s$) Then ProcEvent = False: Exit Function
        ElseIf ss$ = "N" Then
              ss$ = "&" + Left$(rest$, dd)
              If Not IsString(bstack, (ss$), s$) Then
                  ProcEvent = False: Exit Function
              Else
                  lastname$ = subHash.LastKnown
              End If
              rest$ = Mid$(rest$, dd)
        Else
                s$ = vbNullString
        End If
        If Len(s$) > 1 Then
            aa.StandBy lastname$, "(FREE)", "" ' no erroro if not found
        Else
            ProcEvent = False
            Exit Function
        End If
    Loop Until Not FastSymbol(rest$, ",")
    Set aa = Nothing
    Exit Function
End If
Set aa = Nothing
End Function
Sub CopyEvent(a As Variant, bstack As basetask)
Dim alfa As New mEvent, i As Long
Dim aa As mEvent
Set aa = a
'' now put code to copy a to alfa
alfa.BypassInit CLng(a.CurMaxSpace)
Dim aaa() As GenItem, bbb() As Long, mytop As Long
aa.CopySpaceUp aaa(), bbb(), mytop
alfa.CopySpaceDown aaa(), bbb(), mytop
alfa.ParamBlock aa.ParamsRead, aa.params
alfa.NoHere = aa.NoHere
Set bstack.lastobj = alfa
Set aa = Nothing
End Sub
Function CallEvent(bstack As basetask, rest$, Lang As Long, ByVal i As Long) As Boolean
If i > -1 Then
If Typename(var(i)) <> "mEvent" Then
Exit Function
End If
Else
If Typename(bstack.lastobj) <> "mEvent" Then
Exit Function
End If
End If
CallEvent = True
Dim a As mEvent, n$, f$, bb As mStiva, oldbstack As mStiva, nowtotal As Long, oldstatic As FastCollection
FastSymbol rest$, ","
If i < 0 Then
Set a = bstack.lastobj
i = var2used + CLng(Rnd(1000))
Else
Set a = var(i)
End If
''bstack.Look2Parent = True
If Not PushParamGeneral(bstack, rest$) Then

CallEvent = False
Set a = Nothing
Exit Function

End If
''bstack.Look2Parent = False
Dim j As Long, k, s1$, klm As Long
Set oldbstack = bstack.soros
Set oldstatic = bstack.StaticCollection

Dim ohere$
ohere$ = here$
If a Is Nothing Then Exit Function
For j = 0 To a.count - 1

here$ = "EV" + CStr(i) + "." + CStr(j)
If a.Enabled Then
Set bstack.StaticCollection = Nothing
a.ReadVar j, n$, f$
If f$ <> "" Then
Set bb = New mStiva
Set bstack.Sorosref = bb
            bb.Copy2TopNItems2FromStiva a.params, oldbstack
            PushStage bstack, False
            s1$ = Mid$(f$, 2, rinstr(f$, "}") - 2)
            klm = ModuleSubAsap("A_()", s1$, Trim$(Mid$(f$, Len(s1$) + 3)))
            
            If Not ProcModuleEntry(bstack, "A_()", klm, "", , True) Then
                PopStage bstack
                bb.Flush
                GoTo conthere
            End If
            PopStage bstack

bb.Flush
End If
End If
Next j
conthere:
Set bstack.Sorosref = oldbstack
Set bstack.StaticCollection = oldstatic
Set oldstatic = Nothing
Set oldbstack = Nothing
bstack.soros.drop a.params
Set bb = Nothing

here$ = ohere$
End Function
Public Function CallEventFromGui(gui As GuiM2000, a As mEvent, aString$) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
olescok = escok
escok = False
extr = extreme
extreme = True
tr = trace
If tr Then If Rnd * 100 > 3 Then trace = False
On Error Resume Next

CallEventFromGui = True
Dim n$, f$, bb As mStiva, oldbstack As mStiva, nowtotal As Long
Dim bstack As basetask
Set bstack = New basetask
With bstack
    .IamAnEvent = True
Set .Owner = Basestack1.Owner
'Set .StaticCollection = a.StaticCollection
End With
Dim i As Long
If a Is Nothing Then GoTo conthere1
i = a.VarIndex
bstack.soros.DataStr aString$
If gui.index >= 0 Then
bstack.soros.DataVal gui.index
End If
bstack.soros.DataObj gui

Set oldbstack = bstack.soros
Dim j As Long, s1$, klm As Long
Dim ohere$
ohere$ = here$
For j = 0 To a.count - 1
here$ = "EV" + CStr(i) + "." + CStr(j)
If a.Enabled Then
a.ReadVar j, n$, f$
If f$ <> "" Then
Set bb = New mStiva
If Not a.StaticCollection Is Nothing Then
If a.StaticCollection.ExistKey(n$) Then
Set bstack.StaticCollection = a.StaticCollection.ValueObj
End If
End If
Set bstack.Sorosref = bb
            bb.Copy2TopNItems2FromStiva a.params, oldbstack
            PushStage bstack, False
            s1$ = Mid$(f$, 2, rinstr(f$, "}") - 2)
            klm = ModuleSubAsap("A_()", s1$, Trim$(Mid$(f$, Len(s1$) + 3)))
            If Not ProcModuleEntry(bstack, "A_()", klm, "", , True) Then
                PopStage bstack
                bb.Flush
                GoTo conthere
            End If
            PopStage bstack
bb.Flush
End If
End If
If Not bstack.StaticCollection Is Nothing Then
        If a.StaticCollection Is Nothing Then Set a.StaticCollection = New FastCollection
        If Not a.StaticCollection.ExistKey(n$) Then
            a.StaticCollection.AddKey n$, bstack.StaticCollection
        End If
End If

Next j
conthere:
Set bstack.Sorosref = oldbstack
Set oldbstack = Nothing
bstack.soros.drop a.params
Set bb = Nothing
here$ = ohere$
conthere1:
extreme = extr
If tr Then
'If STEXIT Then trace = tr
trace = tr
End If
'Set Basestack1.StaticCollection = bstack.StaticCollection

'bstack.IamAnEvent = oldstatus
escok = olescok
End Function
Public Function CallEventFromGuiOne(gui As GuiM2000, a As mEvent, aString$) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
CallEventFromGuiOne = True
olescok = escok
escok = False
tr = trace
extr = extreme
extreme = True
If tr Then If Rnd * 100 > 3 Then trace = False
Dim n$, f$, F1$, bb As mStiva, uIndex As Long
Dim bstack As basetask
Set bstack = New basetask
Set bstack.Owner = Form1.DIS
'Set bstack.StaticCollection = a.StaticCollection
bstack.IamAnEvent = True
Dim i As Long
If a Is Nothing Then GoTo conthere0
i = a.VarIndex
uIndex = gui.index
If uIndex >= 0 Then
bstack.soros.DataVal CDbl(uIndex)
uIndex = 1
End If
uIndex = uIndex + 1
F1$ = gui.modulename
bstack.soros.DataObj gui

Dim j As Long, k As Long, s1$, klm As Long, s2$
Dim ohere$
ohere$ = here$
here$ = "EV" + CStr(i)
If a.Enabled Then
            PushStage bstack, False
            FastPureLabel aString$, f$, , , , , False
            n$ = Mid$(aString$, Len(f$) + 1)
            n$ = Left$(n$, Len(n$) - 1)
            If n$ <> "" Then
           If uIndex > 0 Then
            n$ = "Data " + n$ + " : ShiftBack Stack.Size" + Str(1 - uIndex) + "," + Str$(uIndex) + vbCrLf
            Else
            n$ = "Data " + n$ + " : ShiftBack Stack.Size" + vbCrLf
            End If
            End If
            If F1$ <> "" Then f$ = myUcase(F1$ + "." + f$ + ")", True) Else f$ = myUcase(f$ + ")", True)
            If Not GetSub(f$, klm) Then
            PopStage bstack: CallEventFromGuiOne = False: GoTo conthere
            End If
            s1$ = sbf(klm).sb
            If Left$(s1$, 10) = "'11001EDIT" Then
            SetNextLine s1$
            End If
              If Not a.StaticCollection Is Nothing Then
                If a.StaticCollection.ExistKey(f$) Then
                Set bstack.StaticCollection = a.StaticCollection.ValueObj
                End If
                End If
            If F1$ <> "" Then s1$ = n$ + "Module " + F1$ + vbCrLf + sbf(klm).sb Else s1$ = n$ + sbf(klm).sb
            If Execute(bstack, s1$, False, False) = 0 Then
            If F1$ = vbNullString Then
            MyEr "Problem in Event " + aString$, "пЯЭБКГЛА СТО ЦЕЦОМЭР " + aString$
            Else
            MyEr "Problem in Event " + aString$ + " in module " + F1$, "пЯЭБКГЛА СТО ЦЕЦОМЭР " + aString$ + " СТО ТЛчЛА " + F1$
            End If
            bstack.soros.Flush
                PopStage bstack
                GoTo conthere
            End If
            PopStage bstack
End If
conthere:
If Len(f$) > 0 Then
If Not bstack.StaticCollection Is Nothing Then
        If a.StaticCollection Is Nothing Then Set a.StaticCollection = New FastCollection
        If Not a.StaticCollection.ExistKey(f$) Then
            a.StaticCollection.AddKey f$, bstack.StaticCollection
        End If
End If
End If
Set bstack = Nothing
here$ = ohere$
conthere0:
If tr Then
'If STEXIT Then
trace = tr
End If
extreme = extr
escok = olescok
End Function
Public Function CallEventFromGuiNow(gui As GuiM2000, a As mEvent, aString$, vrs()) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
olescok = escok
escok = False
CallEventFromGuiNow = True
extr = extreme
extreme = True
tr = trace
If tr Then If Rnd * 100 > 3 Then trace = False
Dim n$, f$, F1$, bb As mStiva, oldbstack As mStiva, nowtotal As Long
Dim bstack As basetask
Set bstack = New basetask
Set bstack.Owner = Form1.DIS
bstack.IamAnEvent = True
Dim i As Long
If a Is Nothing Then GoTo conthere0
i = a.VarIndex
F1$ = gui.modulename
Set oldbstack = bstack.soros
Dim j As Long, k As Long, s1$, klm As Long, s2$
Dim ohere$
ohere$ = here$
here$ = "EV" + CStr(i)
If a.Enabled Then
a.ReadVar 0, n$, f$
If f$ <> "" Then
Set bb = New mStiva
Set bstack.Sorosref = bb
            PushStage bstack, False
            For k = LBound(vrs()) To UBound(vrs()) - 1
            If VarType(vrs(k)) = vbString Then
            globalvarGroup "EV" + CStr(i + k) + "$", vrs(k)
            bb.DataStr here$ + "." + "EV" + CStr(i + k) + "$"
            Else
            globalvarGroup "EV" + CStr(i + k), vrs(k)
            bb.DataStr here$ + "." + "EV" + CStr(i + k)
            End If
            
            
            Next k
            bb.DataObj gui
             
            FastPureLabel aString$, f$, , , , , False
            n$ = Mid$(aString$, Len(f$) + 1)
            If Len(n$) > 0 Then
            
            n$ = Left$(n$, Len(n$) - 1)
            If n$ <> "" Then n$ = "Push " + n$ + vbCrLf
         End If
            If F1$ <> "" Then f$ = myUcase(F1$ + "." + f$ + ")", True) Else f$ = myUcase(f$ + ")", True)
  
            If Not GetSub(f$, klm) Then PopStage bstack: bb.Flush: CallEventFromGuiNow = False: GoTo conthere
            '' look for '11001EDIT
            s1$ = sbf(klm).sb
            If Left$(s1$, 10) = "'11001EDIT" Then
            SetNextLine s1$
            End If
            If F1$ <> "" Then s1$ = n$ + "Module " + F1$ + vbCrLf + sbf(klm).sb Else s1$ = n$ + sbf(klm).sb
            
          Dim nn As Long
                If Not a.StaticCollection Is Nothing Then
                If a.StaticCollection.ExistKey(f$) Then
                Set bstack.StaticCollection = a.StaticCollection.ValueObj
                End If
                End If
            If Execute(bstack, s1$, False, False) = 0 Then
           MyEr "Problem in Event " + aString$, "пЯЭБКГЛА СТО ЦЕЦОМЭР " + aString$
            
            
                PopStage bstack
                bb.Flush
                GoTo conthere
            End If
                  here$ = "EV" + CStr(i)
       For k = LBound(vrs()) To UBound(vrs()) - 1
        If VarType(vrs(k)) = vbString Then
            GetlocalVar "EV" + CStr(i + k) + "$", j
            vrs(k) = var(j)
        Else
            GetlocalVar "EV" + CStr(i + k), j
             vrs(k) = var(j)
            End If
           
            Next k
            PopStage bstack

            bb.Flush
End If
End If

conthere:

Set bstack.Sorosref = oldbstack
here$ = ohere$
conthere0:
If Len(f$) > 0 Then
If Not bstack.StaticCollection Is Nothing Then
        If a.StaticCollection Is Nothing Then Set a.StaticCollection = New FastCollection
        If Not a.StaticCollection.ExistKey(f$) Then
            a.StaticCollection.AddKey f$, bstack.StaticCollection
        End If
End If
End If
Set oldbstack = Nothing
Set bb = Nothing

If tr Then
'If STEXIT Then trace = tr
trace = tr
End If
extreme = extr
escok = olescok
End Function

Sub ProcMethodArray(bstack As basetask, pppp As mArray, index As Long, co$, rest$, Lang As Long, ifier0 As Boolean)
Dim VR(1)
Set VR(0) = pppp.item(index)
On Error Resume Next
ProcMethod bstack, VR(), 0, co$, rest$, Lang, ifier0
 ifier0 = (Err = 0) And ifier0
          Err.Clear
End Sub
Sub ProcPropertyArray(bstack As basetask, pppp As mArray, index As Long, co$, rest$, Lang As Long, ifier0 As Boolean, Optional usethis As Long)
        Dim VR(1)
        If VarType(pppp.item(index)) <> vbEmpty Then
        
        Set VR(0) = pppp.item(index)
        On Error Resume Next
          ProcProperty bstack, VR(), 0, co$, rest$, Lang, True, usethis
  ifier0 = Err = 0
          Err.Clear
          Else
          MyEr "No Object found", "дЕМ БЯчЙА АМТИЙЕъЛЕМО"
          End If
End Sub
Private Function ProcPtr(ByVal nAddress As Long) As Long
    ProcPtr = nAddress
End Function

Function CallByPtr(nSubAddress As Long, basestack As basetask, rest$, Lang As Long) As Boolean
Dim resp As Boolean
If TaskMaster.PlayMusic Then
                    TaskMaster.OnlyMusic = True
                        TaskMaster.TimerTick
                        TaskMaster.OnlyMusic = False
End If
CallWindowProc nSubAddress, VarPtr(basestack), VarPtr(rest$), VarPtr(Lang), VarPtr(resp)
CallByPtr = resp
End Function

Sub NeoWait(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim basestack As basetask, p As Variant
Set basestack = ObjFromPtr(basestackLP)
If IsExp(basestack, rest$, p) Then
mywait basestack, p
Else
mywait basestack, 0
End If
Set basestack = Nothing
resp = True
End Sub

Sub CallNext(basestack As basetask, rest$, resp As Boolean, v1 As Variant, v2 As String)
Dim i As Long, p As Variant, par As Boolean, f As Long, B$
Dim flag As Boolean, it As Long, what$, s$, x1 As Long, ss$, bs As basetask, vvl As Variant, X As Double
s$ = v2
i = Abs(IsLabel(basestack, s$, what$))
GoTo there
reenter1:

i = Abs(IsLabel(basestack, rest$, what$))
there:
If i = 3 And Len(rest$) > 0 Then
If AscW(rest$) = 46 Then
If Not IsStrExp(basestack, (what$), what$) Then MissPar:  Exit Sub
rest$ = what$ + rest$
GoTo reenter1
End If
End If
' call function as module
'**********************************************************

    ss$ = what$ & ")"
    
     If FastSymbol(rest$, ",") Then
    
    End If
    ''ss$ = myucase(ss$)

    resp = True
    MakeThisSub basestack, ss$
    it = CLng(GetSub(ss$, x1))
    
    If Not it Then it = CLng(GetlocalSub(ss$, x1))
 
    If it Then
        Set bs = New basetask
        Set bs.Parent = basestack
        If basestack.IamThread Then Set bs.Process = basestack.Process
        If Not TheSame(here$, ss$) Then Set bs.Sorosref = basestack.soros
        Set bs.Owner = basestack.Owner
             bs.OriginalCode = x1
             If flag Then
             bs.UseGroupname = basestack.UseGroupname
             bs.GroupName = basestack.GroupName
             bs.SetV
             Call GoFunc(bs, ss$, rest$, vvl, , x1)
            
             Else
             bs.UseGroupname = sbf(x1).sbgroup
             bs.tpointer = sbf(x1).tpointer
             bs.SetV
        Call GoFunc(bs, ss$, rest$, vvl)
        End If
            If Not bs.StaticCollection Is Nothing Then
        basestack.SetVarobJ "%_" + bs.StaticInUse, bs.StaticCollection
        End If
        Set bs = Nothing
        If Not par Then
        If Typename(vvl) = "Empty" Then resp = False: Exit Sub
        If InStr(ss$, "$") > 0 Then
   
        v2 = CStr(vvl)
        Else
        
            v1 = CDbl(vvl)
   
        End If
        End If
        Else
        ' ??
        End If
End Sub

Sub NeoCall(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
Dim basestack As basetask, i As Long, p As Variant, par As Boolean, f As Long, op As Object, op1 As Object
Dim flag As Boolean, it As Long, what$, s$, x1 As Long, ss$, bs As basetask, vvl As Variant, X As Double
Dim c As Constant, myl As lambda, a As Group, usethis As stdCallFunction
Set basestack = ObjFromPtr(basestackLP)
If Fast2VarNoTrim(rest$, "текестг", 7, "OPERATOR", 8, 9, f) Then
    If ISSTRINGA(rest$, s$) Then
contoper:
        If ThisPointer(basestack, x1) Then
            If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p) Then
                    If basestack.lastobj Is Nothing Then
                        NeedAGroupFromExpression
                        Set basestack.lastobj = Nothing
                        Exit Sub
                    End If
                    If TypeOf basestack.lastobj Is Group Then
                        basestack.soros.PushObj basestack.lastobj
                        Set basestack.lastobj = Nothing
                        
                        NeoCall2 basestack, var(x1).Patch + "." + ChrW(&H1FFF) + s$ + "()", (True)
                        resp = True
                    Else
                        NeedAGroupFromExpression
                    End If
                Else
                    MissNumExpr
                End If
            Else
                NeoCall2 basestack, "." + ChrW(&H1FFF) + s$ + "()", (True)
                resp = True
            End If
            Set basestack.lastobj = Nothing
            Exit Sub
        Else
            OnlyInAGroup
            Exit Sub
        End If
    ElseIf IsLabelSymbolNew(rest$, "ломадиаио", "UNARY", Lang) Then
        s$ = "-:": GoTo contoper
    Else
        SyntaxError
        Exit Sub
    End If
End If

    resp = True
    If FastSymbol(rest$, "!") Then basestack.nokillvars = True
    par = False: f = 0
    ss$ = vbNullString
    
    If IsLabelSymbolNewExp(rest$, "йемг", "VOID", Lang, ss$) Then par = True
    If IsLabelSymbolNewExp(rest$, "енытеяийг", "EXTERN", Lang, ss$) Then
        basestack.nokillvars = False
        If IsExp(basestack, rest$, p) Then
            i = CLng(p)
            If i >= 0 Or i <= p Then
                If Not MyIsObject(var(i)) Then
                InternalError
                ElseIf TypeOf var(i) Is stdCallFunction Then
                    Set usethis = var(i)
                    On Error Resume Next
                    Err.Clear
                    CallByObject basestack, Not par, usethis
                    Set basestack = Nothing
                    If Err.Number <> 0 Then
                        MyEr Err.Description, Err.Description
                    End If
                    Exit Sub
                Else
                    If TypeOf var(i) Is Constant Then
                        Set c = var(i)
                        If Not c.flag Then
                            InternalError
                            resp = False
                            Exit Sub
                        End If
                        Set myl = c.Value
                    End If
                    If (TypeOf var(i) Is lambda) Or Not myl Is Nothing Then
                        ' call lamda
                        If myl Is Nothing Then Set myl = var(i)
                        PushStage basestack, False
                        flag = False
                        it = 1
                        rest$ = vbNullString
                        myl.Name = here$
                        myl.CopyToVar basestack, here$ = vbNullString, var()
                        basestack.OriginalCode = -i
                        basestack.FuncRec = subHash.LastKnown
                        ss$ = myl.code$
                        Call executeblock(it, basestack, ss$, False, flag, , True)
                        myl.CopyFromVar basestack, var()
                        If it = 0 Then
                            Set basestack.lastobj = Nothing
                            Set basestack.FuncObj = Nothing
                            basestack.ThrowThreads
                            MyErMacro rest$, Chr(0) + "Problem in lambda", Chr(0) + "пЯЭБКГЛА СТГ КэЛДА"
                            FK$(13) = "EDIT " + sbf(var(i).OriginalCode).goodname + ", " + CStr(-var(i).lastlen - Len(ss$) + 1)
                            myl.lastlen = Len(ss$)
                            PopStage basestack
                            Set basestack = Nothing
                            resp = False
                            Exit Sub
                        End If
                        If c Is Nothing Then Set var(i) = myl ' not allow change when running
                        PopStage basestack
                        Set basestack = Nothing
                        Exit Sub
                    Else
                        InternalError
                        ' INVALID FUNCTION HANDLE
                    End If
                End If
            Else
                ' INVALID FUNCTION HANDLE
                InternalError
            End If
        End If
    ElseIf IsLabelSymbolNewExp(rest$, "цецомос", "EVENT", Lang, ss$) Then
        i = Abs(IsLabel(basestack, rest$, what$))
        If i = 1 Then
            If Not GetVar(basestack, basestack.GroupName & what$, i) Then
                MissPar
            Else
                If Typename(var(i)) <> "mEvent" Then
                    MyEr "Can't find Event", "дЕМ ЛПОЯЧ МА БЯЫ ТО цЕЦОМЭР"
                Else
                    resp = CallEvent(basestack, rest$, Lang, i)
                End If
            End If
        ElseIf i = 5 Then
            If GetEventFromArray(basestack, rest$, what$) Then
                resp = CallEvent(basestack, rest$, Lang, -1)
            End If
        ElseIf i = 0 Then
            If ISSTRINGA(rest$, s$) Then
                If ThisPointer(basestack, i) Then
                    s$ = myUcase(s$)
                    Set op = var(i)
                    Set a = op
                    Set op = Nothing
                    If Not a.EventFuncPos(s$, ss$, x1) Then
                    ' check parent
                        If Len(basestack.UseGroupname) > 0 Then
                            what$ = Mid$(basestack.UseGroupname, 1, Len(basestack.UseGroupname) - 1)
                            If GetVar(basestack, what$, x1) Then
                                If Len(what$) > Len(var(x1).GroupName) Then what$ = Left$(what$, Len(what$) - Len(var(x1).GroupName))
                            End If
                            Do While GetVar(basestack, what$, x1)
                                If Typename$(var(x1)) <> mgroup Then Exit Do
                                Set a = var(x1)
                                If a.EventFuncPos(s$, ss$, x1) Then
                                    If sbf(x1).goodname = ss$ Then GoTo contcallhere
                                End If
                               If Len(what$) > Len(var(x1).GroupName) Then
                               what$ = Left$(what$, Len(what$) - Len(var(x1).GroupName))
                               Else
                               what$ = ""
                               End If
                            Loop
                        End If
                        Set a = Nothing
ThrowPar:
                        ' THROW PARAMETERS HERE
                        Set bs = New basetask
                        Set bs.Owner = basestack.Owner
                        If bs Is Nothing Then Set bs = basestack
                        Set bs.Parent = basestack
                        it = IsLabelSymbolNew(rest$, "диадовийо", "CASCADE", Lang)
                        bs.Look2Parent = True
                        
                        FastSymbol rest$, ","
                        If Not PushParamGeneralV70(bs, rest$, "") Then Exit Sub
                        Set bs = Nothing
                    ElseIf Not sbf(x1).goodname = ss$ Then
                        GoTo ThrowPar
                    Else
contcallhere:
                    Set bs = New basetask
                    Set bs.Owner = basestack.Owner
                    If bs Is Nothing Then Set bs = basestack
                    bs.UseGroupname = sbf(x1).sbgroup
                    bs.tpointer = sbf(x1).tpointer
                    bs.OriginalCode = x1
                    Set bs.Parent = basestack
                    it = IsLabelSymbolNew(rest$, "диадовийо", "CASCADE", Lang)
                    If it Then Set bs.Sorosref = basestack.soros
                    bs.Look2Parent = True
                    FastSymbol rest$, ","
                    If Not PushParamGeneralV70(bs, rest$, "") Then
                        bs.Look2Parent = False
                        Exit Sub
                    End If
                    bs.strg = False
                    bs.fHere = Left$(ss$, rinstr(ss$, ".") - 1)
                    s$ = here$
                    here$ = bs.fHere
                    bs.Look2Parent = False
                    PushStage basestack, False
                    bs.SetSkip
                    executeblock (0), bs, (sbf(x1).sb), (False), (flag)
                    PopStage basestack
                    here$ = s$
                    Set bs = Nothing
                    Exit Sub
                End If
            End If
        End If
    Else
        MissPar
    End If
    Set basestack = Nothing
    Exit Sub
Else
    flag = IsLabelSymbolNew(rest$, "топийа", "LOCAL", Lang)
    If IsLabelSymbolNew(rest$, "сумаятгсг", "FUNCTION", Lang) Then f = 3
reenter1:
    i = Abs(IsLabel(basestack, rest$, what$))

    If i = 3 And Len(rest$) > 0 Then
reenter0:
        If AscW(rest$) = 46 Then
            If Not IsStrExp(basestack, (what$), what$) Then MissPar: Set basestack = Nothing:  Exit Sub
            i = Abs(IsLabel(basestack, rest$, s$))
            what$ = what$ + "." + s$
            If i = 3 And Len(rest$) > 0 Then GoTo reenter0
            s$ = vbNullString
        End If
    End If
reenter1Skip:
    If i = 0 Or i = 2 Then
        If i = 0 Then
            If Not IsStrExp(basestack, rest$, what$) Then MissPar: Set basestack = Nothing:  Exit Sub
        End If
        s$ = what$
        i = Abs(IsLabel(basestack, s$, what$))
        If i = 0 Then
            If FastSymbol(s$, "{") Then
reenter2:
                ss$ = block(s$)
                If FastSymbol(s$, "}") And ss$ <> "" Then
                    PushStage basestack, False
                    x1 = ModuleSubAsap("A_()", ss$, Trim$(s$))
                    Set bs = New basetask
                    Set bs.Parent = basestack
                    If basestack.IamThread Then Set bs.Process = basestack.Process
                    Set bs.Sorosref = basestack.soros  ' same stack
                    Set bs.Owner = basestack.Owner
                    bs.UseGroupname = sbf(x1).sbgroup
                    bs.tpointer = sbf(x1).tpointer
                    bs.OriginalCode = x1
                    bs.SetV
                    If par Then
                        Call GoFunc(bs, what$, rest$, vvl, , x1)
                    Else
                        '' no static for this type of call
                        bs.originalname = "()"
                        Call GoFunc(bs, what$, rest$, vvl, , x1)
                        If Not vvl = Empty And Not flag Then
                            vvl = CStr(vvl)
                            X = InStr(vvl, "|")
                            If X = 0 Then
                                MyEr "ERROR " & vvl, "кахос " & vvl
                            Else
                                MyEr "ERROR " & Left$(vvl, X - 1), "кахос " & Mid$(vvl, X + 1)
                            End If
                            resp = False
                            PopStage basestack   ' this always kill vars
                            Set basestack = Nothing:  Exit Sub
                        End If
                    End If
                    Set bs = Nothing
                    basestack.nokillvars = False
                    If LastErNum = -1 Then
                        Set basestack = Nothing
                        resp = False: Set basestack = Nothing: Exit Sub
                    End If
                    resp = True
                    PopStage basestack   ' this always kill vars
                    Set basestack = Nothing:  Exit Sub
                Else
                    s$ = "Error" + "{Bad Call}, {СТГ ЙКчСГ}"
                End If
            Else
                s$ = "Error" + "{Bad Call}, {СТГ ЙКчСГ}"
            End If
        End If
        ' 2
       If Len(s$) > 0 Then basestack.restpart = s$
    End If
    If f > 0 And i < 5 Then i = i + 4: what$ = what$ & "("
    If i = 1 Then
        If Right$(what$, 1) = ChrW(&H1FFF) Then
            i = InStr(rest$, "()")
            If i > 0 And i < 4 Then
                what$ = what$ + Left$(rest$, i + 1)
                rest$ = Mid$(rest$, i + 1)  ' leave last )
            End If
        End If
        FastSymbol rest$, ","
        MakeThisSub basestack, what$
        it = GetlocalSub(what$, x1)
        If Not it Then
            If SecureNames And basestack.IamChild Then
            x1 = InStrRev(here$, "][")
            If x1 > 0 Then
             x1 = val(Mid$(here$, x1 + 2))
             End If
             End If
            If here$ = what$ Then
            ElseIf x1 > 0 Then
                If Not InStr(sbf(x1).goodname, what$) - 2 = Len(here$) And Not Right$(sbf(x1).goodname, Len(what$) + 1) = "." + what$ Then
                    i = x1
                    s$ = what$
                    If Replace(here$, ChrW(&HFFBF), "") = what$ Then
                        it = True: x1 = basestack.OriginalCode
                    ElseIf Len(basestack.UseGroupname) > 0 Then
                        If InStr(what$, basestack.UseGroupname) = 1 Then
                            what$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
                            it = GetSub(what$, x1)
                        End If
                    End If
                    If it = 0 Then
                        what$ = s$
                        If basestack.fHere <> "" Then
                            If sbf(i).goodname = StripThis2(basestack.fHere + "[") + "." + s$ Then
                                x1 = i: it = True
                            End If
                        Else
                            If sbf(i).goodname = StripThis2(here$ + "[") + "." + s$ Then
                                x1 = i: it = True
                            Else
                                it = subHash.Find(what$, x1)
                            End If
                        End If
                    End If
                    If it = 0 Then it = GetSub(what$, x1)
                Else
                     it = True
                End If
            ElseIf Left$(basestack.fHere$, InStr(basestack.fHere$ + "[", "[") - 1) = what$ Then  ' GetStrUntil("[", basestack.fHere$ + "[")
                it = True: x1 = basestack.OriginalCode
            ElseIf Not SecureNames Then
                If iRVAL(here$, 0) > 0 Then
                    For i = -iRVAL(here$, 0) To -1
                        it = GetSub(RVAL2(here$, i) + what$, x1)
                        If it Then Exit For
                    Next i
                End If
                If it = 0 Then it = GetSub(what$, x1)
            Else
                it = GetSub(what$, x1)
            End If
            If it = 0 Then
                If Replace(here$, ChrW(&HFFBF), "") = what$ Then
                    it = True: x1 = basestack.OriginalCode
                ElseIf Len(basestack.UseGroupname) > 0 Then
                    If InStr(what$, basestack.UseGroupname) = 1 Then
                        s$ = what$
                        If Len(basestack.UseGroupname) > 0 Then what$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
                        it = GetSub(what$, x1)
                        If it = 0 Then it = GetSub(s$, x1): what$ = s$
                    End If
                End If
            End If
        End If
        If it Then
            resp = True
            Set bs = New basetask
            Set bs.Parent = basestack
            If basestack.IamThread Then Set bs.Process = basestack.Process
            Set bs.Sorosref = basestack.soros  ' same stack
            Set bs.Owner = basestack.Owner
            bs.UseGroupname = sbf(x1).sbgroup
            bs.tpointer = sbf(x1).tpointer
            bs.OriginalCode = x1
            bs.SetV
             If Len(here$) = 0 Then
               ' bs.StaticInUse = what$
                here$ = what$
                Call GoFunc(bs, what$, rest$, vvl, , x1)
                here$ = vbNullString
            ElseIf x1 >= 0 Then
                If flag Then
                    bs.UseGroupname = basestack.UseGroupname
                    bs.GroupName = basestack.GroupName
                    bs.StaticInUse = basestack.StaticInUse
                    Set bs.StaticCollection = basestack.StaticCollection
                    bs.CallLocalLast = True
                    bs.strfunnum = basestack.strfunnum
                    bs.strnum = basestack.strnum
                    bs.numnum = basestack.numnum
                    bs.numfunnum = basestack.numfunnum
                    bs.commnum = basestack.commnum
                    Call GoFunc(bs, "()", rest$, vvl, , x1)
                    basestack.FuncValue = vvl
                    Set basestack.FuncObj = bs.lastobj
                    
                    If LastErNum Then
                        MyEr Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        resp = False
                        GoTo exithere
                    End If
                Else
                    bs.UseGroupname = sbf(x1).sbgroup
                    bs.tpointer = sbf(x1).tpointer
                     If Left$(what$, 1) <> "_" Then
                        If SecureNames And basestack.IamThread Then
                            what$ = "_" + what$ + LTrim$(basestack.Process.id)
                        End If
                    End If
                    bs.StaticInUse = what$
                    Call GoFunc(bs, "", rest$, vvl, , x1)
                    If LastErNum Then
                        MyEr Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), ""), Replace(GetName(sbf(x1).goodname), ChrW(&HFFBF), "")
                        resp = False
                        GoTo exithere
                    End If
                End If
            Else
                Call GoFunc(bs, what$, rest$, vvl)
            End If
myerror1:
            Set bs = Nothing
            basestack.nokillvars = False
            If LastErNum = -1 Then
                Set basestack = Nothing
                resp = False: Set basestack = Nothing: Exit Sub
            End If
        Else
            resp = True
            ' new :    MyEr "not found " + what$, "ДЕМ БЯщХГЙЕ ТО " + what$
            If Len(rest$) = 0 Then
                rest$ = what$
            Else
                basestack.tmpstr = "@" + what$ + Left$(rest$, 1)
                BackPort rest$
            End If
            'rest$ =  rest$
        End If
        Set basestack = Nothing:  Exit Sub
    ElseIf i = 3 Then
        If IsStrExp(basestack, what$, s$) Then
            If Len(s$) > 0 Then
                If FastSymbol(s$, "{") Then GoTo reenter2
                i = Abs(IsLabel(basestack, s$, what$))
                If Len(s$) > 0 Then basestack.restpart = s$
                s$ = vbNullString
                If i = 3 And Len(rest$) > 0 Then
                GoTo reenter0
                End If
                GoTo reenter1Skip
            Else
                basestack.nokillvars = False
                resp = False
                Set basestack = Nothing:  Exit Sub
            End If
        Else
            ' error
            basestack.nokillvars = False
            resp = False
            Set basestack = Nothing:  Exit Sub
        End If
    ElseIf i > 3 Then
    ' call function as module
    '**********************************************************
        ss$ = what$ & ")"
        FastSymbol rest$, ","
        MakeThisSub basestack, ss$
        it = CLng(GetSub(ss$, x1))
        If Not it Then it = CLng(GetlocalSub(ss$, x1))
        If it = 0 Then
            If StripThis(here$) = ss$ Then
                it = True: x1 = basestack.OriginalCode
            ElseIf Replace(here$, ChrW(&HFFBF), "") = ss$ Then
                it = True: x1 = basestack.OriginalCode
            ElseIf InStr(what$, basestack.UseGroupname) = 1 And Not basestack.UseGroupname = vbNullString Then
                If Len(basestack.UseGroupname) > 0 Then ss$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(ss$, Len(basestack.UseGroupname) + 1)
                it = GetSub(ss$, x1)
            Else
                If Left$(what$, 1) = "T" Or Left$(what$, 1) = "а" Then
                    If Left$(what$, 5) = "THIS." Or Left$(what$, 5) = "ауто." Then
                        ss$ = Left$(what$, 5) + ChrW(&HFFBF) + Mid$(what$, 6) + ")"
                        MakeThisSub basestack, ss$
                        it = GetSub(ss$, x1)
                    End If
                Else
                    If Lang = 1 Then
                        If what$ = "LAMBDA(" Then
again111:
                            If basestack.IamLambda Then
                            ss$ = basestack.FuncRec
                            it = GetSub(ss$, x1)
                            Else
                                ss$ = Mid$(here$, rinstr(here$, "].") + 2)
                                If Right$(here$, 2) = "()" Then
                                    If Right$(here$, 2) = "()" And basestack.UseGroupname = vbNullString Then
                                        ss$ = sbf(basestack.OriginalCode).goodname
                                        x1 = basestack.OriginalCode
                                        it = 1
                                    Else
                                        it = GetSub(ss$, x1)
                                        If Not it Then
                                            If here$ Like "*." + ss$ Then
                                                x1 = basestack.OriginalCode
                                                it = 1
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        ElseIf what$ = "LAMBDA$(" Then
                            GoTo again111
                        End If
                    Else
                        If what$ = "калда(" Then
                            GoTo again111
                        ElseIf what$ = "калда$(" Then
                            GoTo again111
                        End If
                    End If
                End If
            End If
        End If
        If it Then
            Set bs = New basetask
            Set bs.Parent = basestack
            bs.IamAnEvent = basestack.IamAnEvent
            If basestack.IamThread Then Set bs.Process = basestack.Process
            If Not TheSame(here$, ss$) Then Set bs.Sorosref = basestack.soros
            Set bs.Owner = basestack.Owner
            bs.OriginalCode = x1
            bs.SetV
            If flag Then
                bs.UseGroupname = basestack.UseGroupname
                bs.GroupName = basestack.GroupName
                bs.CallLocalLast = True
                bs.strfunnum = basestack.strfunnum
                bs.strnum = basestack.strnum
                bs.numnum = basestack.numnum
                bs.numfunnum = basestack.numfunnum
                bs.commnum = basestack.commnum
                Set bs.StaticCollection = basestack.StaticCollection
                Call GoFunc(bs, ss$, rest$, vvl, , x1)
                    basestack.FuncValue = vvl
                    Set basestack.FuncObj = bs.lastobj
                    vvl = Empty
            Else
                bs.UseGroupname = sbf(x1).sbgroup
                bs.tpointer = sbf(x1).tpointer
                Call GoFunc(bs, ss$, rest$, vvl, True, x1)
            End If
            Set bs = Nothing
            If Not par Then
                If InStr(ss$, "$") > 0 Then
                    If vvl <> "" Then  ' no zero we have error
                        X = InStr(vvl, "|")
                        If X = 0 Then
                            MyEr "ERROR " & vvl, "кахос " & vvl
                        Else
                            MyEr "ERROR " & Left$(vvl, X - 1), "кахос " & Mid$(vvl, X + 1)
                        End If
                        resp = False
                        basestack.nokillvars = False
                        Set basestack = Nothing: Exit Sub
                    End If
                Else
                    If val(vvl) <> 0 Then  ' no zero we have error
                        MyEr "ERROR " & Trim$(Str$(val(vvl))), "кахос " & Trim$(Str$(val(vvl)))
                        resp = False
                        basestack.nokillvars = False
                        Set basestack = Nothing:  Exit Sub
                    End If
                End If
            End If
        Else
            If Not flag Then
                MyEr "Nothing to call", "тъПОТА ЦИА МА ЙАКщСЫ"
                resp = False
            Else
                rest$ = vbNullString
            End If
        End If
    ElseIf IsStrExp(basestack, rest$, s$) Then
        If f = 3 Then s$ = s$ & "("
        FastSymbol rest$, ","
        If s$ <> "" Then
            If InStr(s$, ").") > 0 And f <> 3 Then
                If Right$(s$, 1) = ")" Then
                    rest$ = s$ & " " & rest$
                    GoTo reenter1
                Else
                    rest$ = ": " + s$ & " " & rest$
                End If
            Else
                If Right$(s$, 1) = ")" Then
                    rest$ = Left$(s$, Len(s$) - 1) & " " & rest$
                Else
                    rest$ = s$ & " " & rest$
                End If
                GoTo reenter1
            End If
        End If
    Else
        rest$ = ": " & rest$
    End If
End If
exithere:
basestack.nokillvars = False
Set basestack = Nothing

End Sub
Sub NeoCall2(basestack As basetask, rest$, resp As Boolean)
Dim i As Long, p As Variant, par As Boolean, f As Long
Dim flag As Boolean, it As Long, what$, s$, x1 As Long, ss$, bs As basetask, vvl As Variant, X As Double
resp = True
i = Abs(IsLabel(basestack, rest$, what$))
If i = 1 Then

If Right$(what$, 1) = ChrW(&H1FFF) Then
i = InStr(rest$, "()")
If i > 0 And i < 4 Then
what$ = what$ + Left$(rest$, i + 1)
Mid$(rest$, 1, i) = space(i)
End If

End If
JUMPHERE:
    MakeThisSub basestack, what$
   it = GetlocalSub(what$, x1)
  
    If Not it Then it = GetSub(what$, x1)
 If Not it Then
 If here$ = what$ Then
  it = True: x1 = basestack.OriginalCode
 Else
 For i = -iRVAL(here$, 0) To -1
 
    it = GetSub(RVAL2(here$, i) + what$, x1)
    If it Then Exit For
    Next i
   End If
  If it = 0 Then
 If StripThis(here$) = what$ Then
 it = True: x1 = basestack.OriginalCode
 ElseIf Replace(here$, ChrW(&HFFBF), "") = what$ Then
 it = True: x1 = basestack.OriginalCode
 ElseIf InStr(what$, basestack.UseGroupname) = 1 Then
 what$ = basestack.UseGroupname + ChrW(&HFFBF) + Mid$(what$, Len(basestack.UseGroupname) + 1)
 it = GetSub(what$, x1)
 End If
 End If
 End If

    If it Then
       
        resp = True
        Set bs = New basetask
        Set bs.Parent = basestack
        If basestack.IamThread Then Set bs.Process = basestack.Process
        Set bs.Sorosref = basestack.soros  ' same stack
        Set bs.Owner = basestack.Owner
        bs.UseGroupname = sbf(x1).sbgroup
        bs.tpointer = sbf(x1).tpointer
        bs.OriginalCode = x1
        bs.SetV
        If LenB(here$) = 0 Then
            here$ = what$
            Call GoFunc(bs, what$, rest$, vvl, , x1)
            here$ = vbNullString
        ElseIf x1 >= 0 Then
               ' bs.UseGroupname = sbf(x1).sbgroup
                'bs.tpointer = sbf(x1).tpointer
                bs.StaticInUse = what$
                Call GoFunc(bs, "", rest$, vvl, , x1)
        Else
            Call GoFunc(bs, what$, rest$, vvl)
        End If
myerror1:
       ' If Not bs.StaticCollection Is Nothing Then
       '     basestack.Parent.SetVarobJ "%_" + bs.StaticInUse, bs.StaticCollection
       ' End If
        Set bs = Nothing
       
        If LastErNum = -1 Then
    
            resp = False: Exit Sub
        End If
    Else
        resp = False
        rest$ = ":" & what$ & " " & rest$
    End If
ElseIf i = 7 Then
what$ = what$ + ")"
GoTo JUMPHERE
End If

 


End Sub

Function myStructure(basestack As basetask, rest$, Lang As Long) As Boolean
Dim base As String
If IsStrExp(basestack, rest$, base) Then
    myStructure = TABLENAMES(base, basestack, rest$, Lang)
     
Else
    myStructure = makestruct(basestack, rest$, Lang, here$ = "", False)
End If
End Function

Private Function Between(a, B, c, Optional exclude) As Boolean
If IsMissing(exclude) Then
Between = a >= B And a <= c
Else
Between = (a >= B And a <= c) And Not a = exclude
End If
End Function
Function StructPage(basestack As basetask, rest$, Lang As Long, ByVal Offset, ByRef offset2, offsetlist As FastCollection, ByVal lasthead$) As Boolean
Dim what$, offset1 As Long, i As Long, s$, B$, p As Variant, w2 As Long, maxoffset As Long, probeoffset As Long, usehandler As mHandler
Dim itissingle As Boolean
    B$ = NLtrim$(block(rest$))
   If Not FastSymbol(rest$, "}") Then Exit Function
again:
    If FastSymbol(B$, vbCrLf, , 2) Then
    Do
        While FastSymbol(B$, vbCrLf, , 2)
        Wend
    Loop Until Not NocharsInLine(B$) Or B$ = vbNullString
again1:
    itissingle = False
    If MaybeIsSymbol(B$, "/\'") Then
    
    SetNextLineNL B$
    Do
        While FastSymbol(B$, vbCrLf, , 2)
        Wend
    Loop Until Not NocharsInLine(B$) Or B$ = vbNullString
 
    GoTo again1
    ElseIf FastSymbol(B$, "{") Then
    ' IS A NEW PAGE
    probeoffset = 0
    If StructPage(basestack, B$, Lang, Offset, probeoffset, offsetlist, lasthead$) Then
        If probeoffset > maxoffset Then maxoffset = probeoffset
        ' leave offset as is
    GoTo again
    Else
    Exit Function
    End If
    ElseIf Between(FastPureLabel(B$, what$), 1, 3, 2) Then
    Do
    '' check type, or by default use 2
    If IsLabelSymbolNew(what$, "долг", "STRUCTURE", Lang, , , , False) Then
    If FastPureLabel(B$, what$) = 1 Then
    If FastSymbol(B$, "{") Then
        probeoffset = 0
        If offsetlist.ExistKey(lasthead$ + what$) Then
        MyEr "double name is same struct", "ДИПКч ЕИСАЦЫЦч ОМЭЛАТОР"
        StructPage = False
        Set offsetlist = Nothing
        Exit Function
        End If

        If StructPage(basestack, B$, Lang, Offset, probeoffset, offsetlist, lasthead$ + what$ + ".") Then
            If probeoffset > maxoffset Then maxoffset = probeoffset
            ' leave offset as is
    
            offsetlist.AddKey myUcase(lasthead$ + what$, True), CVar(Offset)
            If offsetlist.Done Then
            offsetlist.sValue = probeoffset - Offset
            ' keytype not used for strucrures except for single values
            ' so Eval() can read single from 4 bytes
            If itissingle Then offsetlist.KeyTypeValue = CInt(vbSingle): itissingle = False
            End If
        GoTo again
        Else
        Exit Function
        End If
    Else
        Exit Function
    End If
        Else
        Exit Function
    End If

    ElseIf IsLabelSymbolNew(B$, "ыс", "AS", Lang, , , , False) Then
    itissingle = False
                            If IsLabelSymbolNew(B$, "ьгжио", "BYTE", Lang, , , , False) Then
                                     offset1 = 1
                                ElseIf IsLabelSymbolNew(B$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                                     offset1 = 2
                                ElseIf IsLabelSymbolNew(B$, "лайяус", "LONG", Lang, , , , False) Then
                                     offset1 = 4
                                ElseIf IsLabelSymbolNew(B$, "апкос", "SINGLE", Lang, , , , False) Then
                                     offset1 = 4
                                     itissingle = True
                                ElseIf IsLabelSymbolNew(B$, "цяалла", "STRING", Lang, , , , False) Then
                                     offset1 = -4
                                ElseIf IsLabelSymbolNew(B$, "дипкос", "DOUBLE", Lang, , , , False) Then
                                     offset1 = 8
                                Else
                                If Abs(IsLabel(basestack, B$, s$)) = 1 Then
                                If GetVar3(basestack, basestack.GroupName + s$, i) Then
                                If IsExp(basestack, basestack.GroupName + s$, p) Then
                                    If basestack.lastobj Is Nothing Then GoTo comehere
                                    If Not TypeOf basestack.lastobj Is mHandler Then GoTo comehere
                                    Set usehandler = basestack.lastobj
                                    If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                    If usehandler.objref.StructLen = 0 Then GoTo comehere
                                    offset1 = usehandler.objref.StructLen
                                    Set usehandler = Nothing
                                    Set basestack.lastobj = Nothing
                                    Else
                                    GoTo comehere
                                End If
                                Else
                                If IsExp(basestack, s$, p) Then
                                    If basestack.lastobj Is Nothing Then GoTo comehere
                                    If Not TypeOf basestack.lastobj Is mHandler Then GoTo comehere
                                    Set usehandler = basestack.lastobj
                                    If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                    If usehandler.objref.StructLen = 0 Then GoTo comehere
                                offset1 = usehandler.objref.StructLen
                                    Set basestack.lastobj = Nothing
                                    Set usehandler = Nothing
                                    Else
                                    GoTo comehere
                                End If
                                End If
                                Else
comehere:
                                    SyntaxError
                 
                                   Exit Function
                                   End If
                                   End If
    
    Else
    
    offset1 = 2
    End If
    w2 = offset1  ' negative offset for strings
    p = 1
    If FastSymbol(B$, "*") Then
    If Not IsExp(basestack, B$, p) Then
           MissNumExpr
        Exit Function
    Else
    p = MyRound(p)
    If p * Abs(offset1) + Offset > &H1FFFFFFF Then  ' half gigabyte for struct (is very big too)
        MyEr "Too big number for struct", "лЕЦэКО МОЩЛЕЯО ЦИА ДОЛч"
        Exit Function
    ElseIf p < 0 Then
        MyEr "Too big number for struct", "лЕЦэКО МОЩЛЕЯО ЦИА ДОЛч"
        Exit Function
    Else
        offset1 = offset1 * CLng(p)
    End If
    End If
    End If
    If offsetlist.ExistKey(lasthead$ + what$) Then
    MyEr "double name is same struct", "ДИПКч ЕИСАЦЫЦч ОМЭЛАТОР"
    StructPage = False
    Set offsetlist = Nothing
    Exit Function
    End If
    
    offsetlist.AddKey myUcase(lasthead$ + what$, True), CVar(Offset)
    If offsetlist.Done Then offsetlist.sValue = w2
    If itissingle Then offsetlist.KeyTypeValue = CInt(vbSingle): itissingle = False
    Offset = Offset + Abs(offset1)
    SetNextLineNL B$
    Do
        While FastSymbol(B$, vbCrLf, , 2)
        Wend
    Loop Until Not NocharsInLine(B$) Or B$ = vbNullString
    Loop Until Not Between(FastPureLabel(B$, what$), 1, 3, 2)
        If maxoffset < Offset Then
    offset2 = Offset
    Else
    offset2 = maxoffset
    End If
    StructPage = True
    GoTo again1
   End If
    If maxoffset < Offset Then
    offset2 = Offset
    Else
    offset2 = maxoffset
    End If
    StructPage = True
   
    If offset2 < maxoffset Then
        offset2 = maxoffset
        StructPage = True
    End If
    End If
    

End Function

Function MyLet(bstack As basetask, rest$, Lang As Long) As Boolean
Dim what$, ss$, i As Long, x1 As Long, flag As Boolean
MyLet = True
Do
   x1 = Abs(IsLabelBig(bstack, rest$, what$))
    
    If x1 <> 0 Then
            If x1 > 4 Then
                    ss$ = BlockParam(rest$)
                    what$ = what$ + ss$ + ")"
                    Mid$(rest$, 1, Len(ss$) + 1) = space(Len(ss$) + 1)
                    Do While IsSymbol(rest$, ".")
                    x1 = IsLabel(bstack, rest$, ss$)
                    If x1 > 0 Then what$ = what$ + "." + ss$ Else Exit Do
                            If x1 > 4 Then
                            ss$ = BlockParam(rest$)
                            what$ = what$ + ss$ + ")"
                                Mid$(rest$, 1, Len(ss$) + 1) = space(Len(ss$) + 1)
                            End If
                    Loop
            End If
    
If FastSymbol(rest$, "=") Then

    i = 1
    aheadstatus rest$, False, i
    If i > 1 Then
ss$ = Left$(rest$, i - 1)
                'I2 bstack, "PUSH", ss$, flag, lang
                flag = MyPush(bstack, ss$)
                If LastErNum = -2 Then
                rest$ = ss$ + Mid$(rest$, i)
                MyLet = flag
                Exit Function
                ElseIf NLtrim(ss$) <> vbNullString Then
                SyntaxError
                Exit Function
                End If
              If MyLet Then
              
              MyLet = MyRead(6, bstack, (what$), 1, what$, x1)
            
            
             rest$ = Mid$(rest$, i)
             Else
             MyEr "Nothing to assign", "тъПОТА ЦИА МА ДЧСЫ"
             Exit Function
             End If
    Else
            MyEr "Expecting expression", "пЕЯъЛЕМА щЙЖЯАСГ"
            MyLet = False
    End If
  
End If

End If
Loop Until Not FastSymbol(rest$, ",")
End Function
Function MyThread(bstack As basetask, rest$, Lang As Long) As Boolean
Dim frm$, ss$, what$, i As Long, p As Variant, X As Double, par As Boolean, bs As basetask
MyThread = True
     If FastSymbol(rest$, "{") Then
        frm$ = NLtrim$(block(rest$))
        If FastSymbol(rest$, "}") Then
                par = False
                If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                Else
                    MyEr "can't find clause AS variable_name", "ДЕМ ЛПОЯЧ МА БЯЧ ТО ЛщЯОР ыс ОМОЛА_ЛЕТАБКГТчР"
                   
                    MyThread = False
               
                    Exit Function
                End If
                Select Case Abs(IsLabel(bstack, rest$, what$)) ' is Ifier
                Case 1
                        p = GetTaskId + 20000
                        If GetVar(bstack, what$, i) Then ' if exist
                            var(i) = p
                        Else
                            globalvar what$, p     ' or make one
                        End If
                        Set bs = New basetask   ' bs is the basetask of the thread but thread process class arn't constructed yet
                        Set bs.Parent = bstack  ' link to current basestask
                        bstack.PushThread CLng(p), what$  'push thread id and Ifier to threads collection in current basetask
                        sThreadInternal bs, p, 0, frm$, -1&, here$, False ' thread construction - also we have a connection to
                        
                        
                        Set bs = Nothing
                        ss$ = vbNullString
                        If IsLabelSymbolNewExp(rest$, "йахе", "INTERVAL", Lang, ss$) Then
                        GoTo chekInterval
                        ElseIf IsLabelSymbolNewExp(rest$, "ейтекесг", "EXECUTE", Lang, ss$) Then
                        
                        If FastSymbol(rest$, "{") Then
                        frm$ = NLtrim$(block(rest$))
                        If FastSymbol(rest$, "}") Then
                            TaskMaster.Message CLng(p), 5, , frm$
                            Else
                            SyntaxError
                            MyThread = False
                        End If
                        Else
                        TaskMaster.Message CLng(p), 4, , rest$
                        End If
                        End If
                Case Else
                       MissingnumVar
                        
                        MyThread = False
  
                     Exit Function
                End Select
        End If
ElseIf IsExp(bstack, rest$, p) Then
ss$ = vbNullString
    If IsLabelSymbolNewExp(rest$, "сбгсе", "ERASE", Lang, ss$) Then
       If Not bstack.ThrowOne(CLng(p)) Then
       TaskMaster.ThrowOne (CLng(p))
       End If
    ElseIf IsLabelSymbolNewExp(rest$, "йяата", "HOLD", Lang, ss$) Then
        TaskMaster.Message CLng(p), 0
    ElseIf IsLabelSymbolNewExp(rest$, "ейтекесг", "EXECUTE", Lang, ss$) Then
     
     If FastSymbol(rest$, "{") Then
                        frm$ = NLtrim$(block(rest$))
                        If FastSymbol(rest$, "}") Then
                            TaskMaster.Message CLng(p), 5, , frm$
                            Else
                            SyntaxError
                            MyThread = False
                        End If
                        Else
                        TaskMaster.Message CLng(p), 4, , rest$
                        End If
    ElseIf IsLabelSymbolNewExp(rest$, "нейима", "RESTART", Lang, ss$) Then
        TaskMaster.Message CLng(p), 2
    ElseIf IsLabelSymbolNewExp(rest$, "йахе", "INTERVAL", Lang, ss$) Then
chekInterval:
        If IsExp(bstack, rest$, X) Then
            If X < 2 Then X = 2
            TaskMaster.Message CLng(p), 3, CLng(X)
        Else
            MisInterval
            MyThread = False
        End If
    Else
        NoClauseInThread
      
        MyThread = False

    End If
End If
what$ = vbNullString
End Function
Function ObjFromPtr(ByVal Ptr As Long) As Object
    ObjSetAddRef ObjFromPtr, Ptr
End Function
Sub ProcBold(bstack As basetask, rest$)
Dim p As Variant
If IsExp(bstack, rest$, p) Then
bstack.myBold = (p <> 0)
Else
bstack.myBold = Not bstack.myBold
p = CDbl(bstack.myBold)
End If
players(GetCode(bstack.Owner)).bold = Abs(p <> 0)
bstack.Owner.Font.bold = Abs(p <> 0)

End Sub

Function ProcPoly(bstack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, sX As Double, sY As Double, X As Double, Y As Double, x1 As Integer, p As Variant, f As Long
Dim Col As Long, Scr As Object, trans As Long
ProcPoly = True
trans = 255
Set Scr = bstack.Owner
If IsExp(bstack, rest$, p) Then
Col = mycolor(p)

End If
If Not FastSymbol(rest$, ",") Then SyntaxError: ProcPoly = False: Exit Function
If IsLabelSymbolNew(rest$, "цымиа", "ANGLE", Lang) Then par = True
Scr.fillstyle = vbSolid
Scr.fillcolor = Col
f = 32
ReDim PLG(f)
x1 = 1
With players(GetCode(Scr))
trans = .mypentrans
PLG(0).X = Scr.ScaleX(.XGRAPH, 1, 3)
PLG(0).Y = Scr.ScaleY(.YGRAPH, 1, 3)
Do
If x1 >= f Then f = f * 2: ReDim Preserve PLG(f)
If IsExp(bstack, rest$, p) Then
X = p

If Not FastSymbol(rest$, ",") Then SyntaxError: ProcPoly = False: Set Scr = Nothing: Exit Function
    If IsExp(bstack, rest$, p) Then
        If par Then
      
            sX = X / PI2
            sX = (sX - Fix(sX)) * PI2
            .XGRAPH = .XGRAPH + Cos(sX) * p
            .YGRAPH = .YGRAPH - Sin(sX) * p
        Else
            .XGRAPH = .XGRAPH + CLng(X)
            .YGRAPH = .YGRAPH + CLng(p)
        End If
        PLG(x1).X = Scr.ScaleX(.XGRAPH, 1, 3)
        PLG(x1).Y = Scr.ScaleY(.YGRAPH, 1, 3)
    
    Else
         MissNumExpr
         Set Scr = Nothing
        ProcPoly = False: Exit Function
    End If
Else
MissNumExpr
Set Scr = Nothing
ProcPoly = False: Exit Function
End If

x1 = x1 + 1
Loop Until Not FastSymbol(rest$, ",")
x1 = x1 - 1
PLG(x1) = PLG(0)
Dim mGDILines As Boolean
'If GDILines And Not (scr.DrawWidth < 2 And TypeOf scr Is MetaDc) Then

'End If

'If Not TypeOf scr Is MetaDc Then
' use .IamEmf
    'If GDILines Or .mypentrans < 255 Then
     '   mGDILines = Not .NoGDI
    'Else
     '   mGDILines = scr.DrawStyle <> 5 And scr.DrawWidth > 1
    'End If
    
If .IamEmf Then
   'mGDILines = Not .NoGDI And Not (scr.DrawStyle > 0 And scr.DrawWidth = 1)
   mGDILines = Not .NoGDI And Not ((Scr.DrawStyle > 0 And Scr.DrawWidth = 1) And Not Scr.DrawStyle)
ElseIf GDILines Or (trans < 255) Then
    mGDILines = Not .NoGDI
Else
    mGDILines = Scr.DrawWidth > 1

End If
    
'End If
Dim pencol As Long, bstyle As Long
If .pathfillstyle = 1 And .IamEmf Then mGDILines = False

If mGDILines Then
pencol = .mypen

    If .pathgdi > 0 Then Col = .pathcolor: bstyle = .pathfillstyle Else bstyle = Scr.fillstyle
    M2000Pen trans, Col
 If trans < 255 And bstyle = 5 Then M2000Pen trans, pencol Else M2000Pen 255, pencol
    DrawPolygonGdi Scr.hdc, pencol, Col, bstyle, Scr.DrawWidth, Scr.DrawStyle, PLG(), CLng(x1 + 1)
    

Else
If Polygon(Scr.hdc, PLG(0), x1) = 0 Then
    ProcPoly = True: BadGraphic: Set Scr = Nothing: Exit Function
End If
End If
Scr.fillstyle = vbSolid
End With
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing
End Function
Sub DrawFrameForEmf(Scr As Object, ByVal X As Long, ByVal Y As Long, ByVal x1 As Long, ByVal y1 As Long)
Dim PLG(4) As POINTAPI
X = X / dv15
Y = Y / dv15
x1 = x1 / dv15
y1 = y1 / dv15
PLG(0).X = X
PLG(0).Y = Y
PLG(1).X = x1
PLG(1).Y = Y
PLG(2).X = x1
PLG(2).Y = y1
PLG(3).X = X
PLG(3).Y = y1
Scr.fillstyle = vbSolid
Scr.fillcolor = 0
Polygon Scr.hdc, PLG(0), 4
End Sub
Function ProcCircle(bstack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, sX As Double, sY As Double, X As Double, Y As Double, x1 As Long, p As Variant
Dim Col As Long, Col2 As Long, Scr As Object, isarc As Boolean, trans As Long
ProcCircle = True
par = False
If IsLabelSymbolNew(rest$, "целисла", "FILL", Lang) Then
If IsExp(bstack, rest$, p) Then X = p
If Not FastSymbol(rest$, ",") Then MissNumExpr: ProcCircle = False: Exit Function
par = True
End If
x1 = 0
Y = 1
Dim errorbit As Boolean
With players(GetCode(bstack.Owner))
Col = .mypen
trans = .mypentrans

If IsExp(bstack, rest$, p) Then x1 = p
If FastSymbol(rest$, ",") Then errorbit = True: If IsExp(bstack, rest$, p) Then Y = p: errorbit = False

If FastSymbol(rest$, ",") Then
errorbit = True
If IsExp(bstack, rest$, p) Then Col = mycolor(CLng(p)): trans = 255: errorbit = False
End If
sX = 0
sY = 0
isarc = False
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sX = p: isarc = True Else MissNumExpr: ProcCircle = False: Exit Function
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sY = p: isarc = True Else MissNumExpr: ProcCircle = False: Exit Function
If Not isarc And errorbit Then MissNumExpr: ProcCircle = False: Exit Function
sX = sX / PI2
sX = (sX - Fix(sX)) * PI2
sY = sY / PI2
sY = (sY - Fix(sY)) * PI2
Set Scr = bstack.Owner
Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH
If x1 <= 0 Or Y < 0.001 Then Exit Function
Dim mGDILines As Boolean
If .IamEmf Then
   mGDILines = Not .NoGDI And Not ((Scr.DrawStyle > 0 And Scr.DrawWidth = 1) And Not Scr.DrawStyle)
ElseIf GDILines Or (trans < 255) Then
    mGDILines = Not .NoGDI
Else
    mGDILines = Scr.DrawWidth > 1

End If

If par Then
    Scr.fillstyle = vbSolid
    Scr.fillcolor = mycolor(X)
    If sX = sY Then sY = PI2
    If sX = sY Or Abs(sX - sY) + 0.0001 > PI2 Then
        If mGDILines Then
            If Not par Then M2000Pen trans, Col Else M2000Pen 255, Col
            Col2 = .pathcolor
            M2000Pen trans, Col2
            If Y > 1 Then
                If .pathgdi > 0 Then
                    DrawEllipseGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                Else
                     Col2 = mycolor(X)
                     M2000Pen trans, Col2
                    DrawEllipseGdi Scr.hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                End If
            Else
                If .pathgdi > 0 Then
                    'If .IamEmf Then
                        ' rev 49 ver 10
                        ' Dim St As Long
                       ' St = Scr.DrawStyle
                       ' Scr.DrawStyle = 5
                       ' DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y)
                       ' Scr.DrawStyle = St
                        DrawEllipseGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                    'Else
                        DrawEllipseGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                    'End If
                Else
                    Col2 = mycolor(X)
                    M2000Pen trans, Col2
                    DrawEllipseGdi Scr.hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3)
                End If
            End If
        Else
            sX = MyMod(sX + Pi * 2, 2 * Pi)
            sY = MyMod(sY + Pi * 2, 2 * Pi)
            If TypeOf Scr Is MetaDc Then
                DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y)
            Else
                Scr.Circle (.XGRAPH, .YGRAPH), x1, Col, , , Y
            End If
        End If
    Else
            If sX = 0 Then sX = 0.0001
            If sY = 0 Then sY = PI2
            If mGDILines Then
            ' revision 30, version 9.3 fixed
            If Not par Then M2000Pen trans, Col Else M2000Pen 255, Col
            Col2 = .pathcolor
            M2000Pen trans, Col2
            If Y > 1 Then
            If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                Else
                Col2 = mycolor(X)
                    M2000Pen trans, Col2
                
                    DrawArcPieGdi Scr.hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3), -sX, -sY
                End If
            Else
                If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                Else
                    Col2 = mycolor(X)
                    M2000Pen trans, Col2
                    DrawArcPieGdi Scr.hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                End If
            End If
        Else
            sX = MyMod(sX + Pi * 2, 2 * Pi)
            sY = MyMod(sY + Pi * 2, 2 * Pi)
            If Round(sY, 13) = Round(Pi / 2, 13) Then sY = sY - 1 / (Abs(x1) / 8#)
                If TypeOf Scr Is MetaDc Then
                    DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y), (-sX), (-sY)
                Else
                    Scr.Circle (.XGRAPH, .YGRAPH), x1, Col, -sX, -sY, Y
                End If
            End If
        End If
        Scr.fillstyle = 1
    Else
        Scr.fillstyle = 1
        If mGDILines Then
            If Not par Then M2000Pen trans, Col Else M2000Pen 255, Col
            If .pathgdi > 0 Then
                Col2 = .pathcolor
                M2000Pen trans, Col2
            Else
                Col2 = 0
            End If
            If sX = sY Or Abs(sX - sY) + 0.0001 > PI2 Then
            If Y > 1 Then
            If .pathgdi > 0 Then
                    DrawEllipseGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                Else
                    DrawEllipseGdi Scr.hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                End If
            Else
                If .pathgdi > 0 Then
                    DrawEllipseGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3)
                Else
                    DrawEllipseGdi Scr.hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3)
                End If
            End If
        Else
            If Y > 1 Then
                If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3), -sX, -sY
                Else
                    DrawArcPieGdi Scr.hdc, Col, Col2, 1, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1 / Y, 1, 3), Scr.ScaleY(.YGRAPH - x1, 1, 3), Scr.ScaleX(x1 * 2 / Y, 1, 3), Scr.ScaleY(x1 * 2, 1, 3), -sX, -sY
                End If
            Else
                If .pathgdi > 0 Then
                    DrawArcPieGdi Scr.hdc, Col, Col2, .pathfillstyle, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                Else
                    DrawArcPieGdi Scr.hdc, Col, Col2, vbSolid, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH - x1, 1, 3), Scr.ScaleY(.YGRAPH - x1 * Y, 1, 3), Scr.ScaleX(x1 * 2, 1, 3), Scr.ScaleY(x1 * 2 * Y, 1, 3), -sX, -sY
                End If
            End If
        End If
    Else
        sX = MyMod(sX + Pi * 2, 2 * Pi)
        sY = MyMod(sY + Pi * 2, 2 * Pi)
        If Round(sY, 13) = Round(Pi / 2, 13) Then sY = sY - 1 / (Abs(x1) / 8#)
        If TypeOf Scr Is MetaDc Then
            DrawCircleApi Scr, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleY(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Col, (Y), (sX), (sY)
        Else
            Scr.Circle (.XGRAPH, .YGRAPH), x1, Col, sX, sY, Y
        End If
    End If
End If
End With
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing

End Function
Function ProcDraw(bstack As basetask, rest$, Lang As Long) As Boolean
Dim Col As Long, x1 As Long, sX As Double, sY As Double, f As Long, y1 As Long
Dim p As Variant, Scr As Object, trans As Long

ProcDraw = True

With players(GetCode(bstack.Owner))
x1 = 0
y1 = 1
Col = .mypen
trans = .mypentrans
If IsLabelSymbolNew(rest$, "еыс", "TO", Lang) Then
If IsExp(bstack, rest$, p) Then x1 = p Else x1 = .XGRAPH
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, p) Then y1 = p Else y1 = .YGRAPH
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, p) Then
            Col = mycolor(p)
            If FastSymbol(rest$, ",") Then
                If IsExp(bstack, rest$, p) Then
                    p = Abs(p): If p > 255 Then p = 255
                    trans = p
                Else
                    ProcDraw = False: Exit Function
                End If
            End If
        Else
            ProcDraw = False: Exit Function
        End If
    End If
Else
 y1 = .YGRAPH
End If

Set Scr = bstack.Owner
Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH

If GDILines And Not (Scr.DrawWidth < 2 And TypeOf Scr Is MetaDc) Then
M2000Pen trans, Col
DrawLineGdi Scr.hdc, Col, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleX(.YGRAPH, 1, 3), Scr.ScaleX(x1, 1, 3), Scr.ScaleX(y1, 1, 3)
.XGRAPH = x1
.YGRAPH = y1
Else
If TypeOf Scr Is MetaDc Then
Dim mm As MetaDc
Set mm = Scr
mm.Line2 .XGRAPH, .YGRAPH, x1, y1, mycolor(Col)
.XGRAPH = x1
.YGRAPH = y1
Else
Scr.Line (.XGRAPH, .YGRAPH)-(x1, y1), mycolor(Col)
.XGRAPH = Scr.currentX
.YGRAPH = Scr.currentY

End If

End If
'MyDoEvents1 Scr
MyRefresh bstack
Set Scr = Nothing
Exit Function
ElseIf IsLabelSymbolNew(rest$, "цымиа", "ANGLE", Lang) Then
If IsExp(bstack, rest$, p) Then sX = p Else ProcDraw = False: Exit Function
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sY = p Else ProcDraw = False: Exit Function
sX = sX / PI2
sX = (sX - Fix(sX)) * PI2
x1 = Cos(sX) * sY
y1 = -Sin(sX) * sY
Else
If IsExp(bstack, rest$, p) Then x1 = p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p
End If
If FastSymbol(rest$, ",") Then
    If IsExp(bstack, rest$, p) Then
        Col = mycolor(p)
        If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, p) Then
                p = Abs(p): If p > 255 Then p = 255
                trans = p
            Else
                ProcDraw = False: Exit Function
            End If
        End If
    Else
        ProcDraw = False: Exit Function
    End If
End If

Set Scr = bstack.Owner
Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH


If GDILines Or TypeOf Scr Is MetaDc And Not (Scr.DrawWidth = 1 And Scr.DrawStyle > 1 And trans = 255) Then
M2000Pen trans, Col
DrawLineGdi Scr.hdc, Col, Scr.DrawWidth, Scr.DrawStyle, Scr.ScaleX(.XGRAPH, 1, 3), Scr.ScaleX(.YGRAPH, 1, 3), Scr.ScaleX(.XGRAPH + x1, 1, 3), Scr.ScaleX(.YGRAPH + y1, 1, 3)
.XGRAPH = .XGRAPH + x1
.YGRAPH = .YGRAPH + y1
ElseIf TypeOf Scr Is MetaDc Then
x1 = x1 + .XGRAPH
y1 = y1 + .YGRAPH
Set mm = Scr
mm.Line2 .XGRAPH, .YGRAPH, x1, y1, mycolor(Col)
.XGRAPH = x1
.YGRAPH = y1
Else
Scr.Line (.XGRAPH, .YGRAPH)-Step(x1, y1), mycolor(Col)
.XGRAPH = Scr.currentX
.YGRAPH = Scr.currentY
End If
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing
End With

End Function
Function ProcStep(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, sY As Double, sX As Double
ProcStep = True
With players(GetCode(bstack.Owner))
If IsLabelSymbolNew(rest$, "цымиа", "ANGLE", Lang) Then
If IsExp(bstack, rest$, p) Then sX = p Else ProcStep = False: MissNumExpr: Exit Function
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then sY = p Else ProcStep = False: MissNumExpr: Exit Function
sX = sX / PI2
sX = (sX - Fix(sX)) * PI2
.XGRAPH = .XGRAPH + Cos(sX) * sY
.YGRAPH = .YGRAPH - Sin(sX) * sY
Else
If IsExp(bstack, rest$, p) Then .XGRAPH = .XGRAPH + p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then .YGRAPH = .YGRAPH + p Else ProcStep = False: MissNumExpr: Exit Function
End If
End With


End Function
Function ProcMove(bstack As basetask, rest$) As Boolean
ProcMove = True
Dim p As Variant
With players(GetCode(bstack.Owner))
If FastSymbol(rest$, "!") Then
 .XGRAPH = .curpos * .Xt
 .YGRAPH = .currow * .Yt
ElseIf IsExp(bstack, rest$, p) Then .XGRAPH = p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then .YGRAPH = p Else ProcMove = False: MissNumExpr: Exit Function
End If
End With
End Function
Function MyRead(jump As Long, bstack As basetask, rest$, Lang As Long, Optional ByVal what$, Optional usex1 As Long, Optional exist As Boolean = False) As Boolean
Dim ps As mStiva, bs As basetask, f As Boolean, ohere$, par As Boolean, flag As Boolean, flag2 As Boolean, ok As Boolean
Dim s$, ss$, pa$, x1 As Long, y1 As Long, i As Long, myobject As Object, it As Long, useoptionals As Boolean, optlocal As Boolean
Dim m As mStiva, checktype As Boolean, allowglobals As Boolean, isAglobal As Boolean, look As Boolean, ByPass As Boolean
Dim usehandler As mHandler, ff As Long, usehandler1 As mHandler
MyRead = True
Dim p As Variant, X As Double
Dim pppp As mArray
ohere$ = here$
Dim Col As Long
Dim ihavetype As Boolean
look = jump = 1 Or jump = 7
On jump GoTo read, refer, commit, readnew, readlocal, readlet, readfromsub, link
Exit Function

commit:
If Len(bstack.UseGroupname) > 0 Then
    f = True
    Col = 1
    Set bs = bstack
    GoTo contFromRebound
Else
    BadReBound
    MyRead = False
End If
Exit Function

link:
flag2 = True

refer:
Col = 1
GoTo read123

readlocal:
flag = True
GoTo read123

readfromsub:
If FastSymbol(rest$, "?") Then useoptionals = True

readnew:
flag2 = True
GoTo read123

readlet:
allowglobals = True
Set bs = bstack
x1 = usex1
If x1 > 3 Then x1 = Abs(IsLabel(bstack, rest$, what$))
'***********************
Select Case x1
Case 1
    If bs.IsObjectRef(myobject) Then
        MyRead = True
        If GetVar3(bstack, what$, i, , , flag, s$, checktype, isAglobal, True, ok) Then
            If Typename$(myobject) = Typename(var(i)) Then
                If Typename$(var(i)) = mgroup Then
                    ss$ = bstack.GroupName
                    If s$ <> "" Then what$ = s$
                    If Len(var(i).GroupName) > Len(what$) Then
                        If var(i).IamRef Then
                            s$ = here$
                            here$ = vbNullString
                            UnFloatGroupReWriteVars bstack, what$, i, myobject
                            here = s$
                        Else
                            UnFloatGroupReWriteVars bstack, what$, i, myobject
                        End If
                        myobject.ToDelete = True
                    Else
                        bstack.GroupName = Left$(what$, Len(what$) - Len(var(i).GroupName) + 1)
                        If Len(var(i).GroupName) > 0 Then
                            what$ = Left$(var(i).GroupName, Len(var(i).GroupName) - 1)
                            s$ = here$
                            here$ = vbNullString
                            UnFloatGroupReWriteVars bstack, what$, i, myobject
                            here = s$
                            myobject.ToDelete = True
                        ElseIf var(i).IamApointer And myobject.IamApointer Then
                            Set var(i) = myobject
                        Else
                            Set myobject = Nothing
                            bstack.GroupName = ss$
                            GroupWrongUse
                            MyRead = False
                            Exit Function
                        End If
                    End If
                    Set myobject = Nothing
                    bstack.GroupName = ss$
                ElseIf Typename$(var(i)) = mHdlr Then
                    Set usehandler = myobject
                    Set usehandler1 = var(i)
                    If usehandler1.ReadOnly Then
                        MyRead = False
                        ReadOnly
                        Exit Function
                    ElseIf usehandler1.t1 = usehandler.t1 Then
                        If usehandler1.t1 = 4 Then
                            If usehandler1.objref Is usehandler.objref Then
                                Set var(i) = myobject
                            ElseIf usehandler1.objref.EnumName = usehandler.objref.EnumName Then
                                If usehandler1.objref.ExistFromOther(usehandler.index_cursor) Then
                                    Set usehandler.objref = usehandler1.objref
                                    Set var(i) = usehandler
                                Else
                                    GoTo er103
                                End If
                            Else
                                GoTo er103
                            End If
                        Else
                            Set var(i) = myobject
                        End If
                    ElseIf usehandler1.t1 <> 4 And myobject.t1 = 3 Then
                        Set var(i) = myobject
                    Else
                        GoTo er103
                    End If
                    Set usehandler = Nothing
                    Set usehandler1 = Nothing
                Else
                    Set var(i) = myobject
                End If
            ElseIf x1 = 1 And CheckIsmArray(myobject) Then
                Set usehandler = New mHandler
                Set var(i) = usehandler
                usehandler.t1 = 3
                Set usehandler.objref = myobject
                Set myobject = Nothing
                Set usehandler = Nothing
            Else
                If TypeOf myobject Is mHandler Then
                    Set usehandler = myobject
                    If usehandler.t1 = 4 Then
                        p = usehandler.index_cursor
                        Set myobject = Nothing
                        Set usehandler = Nothing
                        GoTo itisinumber
                    End If
                End If
                GoTo er103
            End If
        Else
            i = globalvar(what$, 0)
            If Typename$(myobject) = mgroup Then
                If myobject.IamApointer Then
                    Set var(i) = myobject
                Else
                    UnFloatGroup bstack, bstack.GroupName & what$, i, myobject, here$ = vbNullString Or Len(bstack.UseGroupname) > 0, , True
                    myobject.ToDelete = True
                End If
            ElseIf Typename$(myobject) = "mEvent" Then
                Set var(i) = myobject
            ElseIf Typename$(myobject) = "lambda" Then
                Set var(i) = myobject
                If ohere$ = vbNullString Then
                    GlobalSub what$ + "()", "", , , i
                Else
                    GlobalSub ohere$ & "." & bstack.GroupName & what$ + "()", "", , , i
                End If
            ElseIf Typename$(myobject) = mHdlr Then
                Set usehandler = myobject
                If usehandler.indirect > -1 Then
                    Set var(i) = MakeitObjectGeneric(usehandler.indirect)
                Else
                    Set var(i) = usehandler
                End If
            ElseIf Typename$(myobject) = myArray Then
                Set usehandler = New mHandler
                Set var(i) = usehandler
                usehandler.t1 = 3
                Set usehandler.objref = myobject
                Set usehandler = Nothing
            Else
                Set var(i) = myobject
            End If
        End If
    ElseIf bs.IsNumber(p) Then
itisinumber:
        If GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True, ok) Then
            If MyIsObject(var(i)) Then
                If TypeOf var(i) Is Group Then
                    If var(i).HasSet Then
                        Set m = bstack.soros
                        Set bstack.Sorosref = New mStiva
                        bstack.soros.PushVal p
                        NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + ":=()", ok
                        Set bstack.Sorosref = m
                        Set m = Nothing
                    Else
                        GoTo there182741
                    End If
                Else
there182741:
                    If TypeOf var(i) Is Constant Then
                        CantAssignValue
                        Exit Function
                    ElseIf TypeOf var(i) Is mHandler Then
                        Set usehandler = var(i)
                        If usehandler.t1 <> 4 Then GoTo er104
                        Set myobject = usehandler.objref.SearchValue(p, ok)
                        If ok Then
                            Set var(i) = myobject
                        Else
                            GoTo er112
                        End If
                    Else
                        GoTo er104
                    End If
                End If
            Else
                If checktype Then
                    If ihavetype Then
                        If VarType(var(i)) <> VarType(p) Then
                            GoTo er109
                        ElseIf AssignTypeNumeric(p, VarType(var(i))) Then
                            var(i) = p
                        Else
                            GoTo er105
                        End If
                    ElseIf AssignTypeNumeric(p, VarType(var(i))) Then
                        var(i) = p
                    Else
                        GoTo er105
                    End If
                Else
                    var(i) = p
                End If
            End If
        ElseIf i = -1 Then
                bstack.SetVar what$, p
        Else
                If Not exist Then globalvar what$, p Else Nosuchvariable what$
        End If
    End If
Case 3
    If bs.IsString(s$) Then
        MyRead = True
        If GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True) Then
            If MyIsObject(var(i)) Then
                If TypeOf var(i) Is Group Then
                    Set m = bstack.soros
                    Set bstack.Sorosref = New mStiva
                    bstack.soros.PushStr s$
                    NeoCall2 bstack, Left$(what$, Len(what$) - 1) + "." + ChrW(&H1FFF) + ":=()", ok
                    Set bstack.Sorosref = m
                    Set m = Nothing
                ElseIf TypeOf var(i) Is Constant Then
                    CantAssignValue
                    MyRead = False
                    Exit Function
                Else
                    CheckVar var(i), s$
                End If
            Else
                var(i) = s$
            End If
        ElseIf i = -1 Then
            bstack.SetVar what$, s$
        Else
            If Not exist Then globalvar what$, s$ Else Nosuchvariable what$
        End If
    Else
        bstack.soros.drop 1
        MissStackStr
        MyRead = False
    End If
   
Case 4
    If bs.IsNumber(p) Then
        MyRead = True
        If GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True) Then
            var(i) = MyRound(p)
        ElseIf i = -1 Then
            bstack.SetVar what$, p
        Else
        If Not exist Then globalvar what$, MyRound(p) Else Nosuchvariable what$
        End If
    Else
        bstack.soros.drop 1
        MissStackNumber
        MyRead = False
    End If
Case 5, 7
    MyRead = False
    If FastSymbol(rest$, ")") Then
        MyRead = globalArrByPointer(bs, bstack, what$, flag2, allowglobals): If Not MyRead Then SyntaxError: Exit Function
    Else
        If neoGetArray(bstack, what$, pppp) And Not flag2 Then
            If Not NeoGetArrayItem(pppp, bs, what$, it, rest$) Then Exit Function
        Else
            Exit Function
        End If
        If IsOperator(rest$, ".") Then
            If Not pppp.ItemType(it) = mgroup Then
                MyEr "Expected group", "пЕЯъЛЕМА ОЛэДА"
                MyRead = False: Exit Function
            Else
                i = 1
                aheadstatus rest$, False, i
                ss$ = Left$(rest$, i - 1)
                MyRead = SpeedGroup(bstack, pppp, "@READ", ".", ss$, it) <> 0
                Set pppp = Nothing
                rest$ = Mid$(rest$, i)
            End If
        Else
            If bs.IsObjectRef(myobject) Then
                If Typename$(myobject) = mgroup Then
                    If myobject.IamFloatGroup Then
                        Set pppp.item(it) = myobject
                        Set myobject = Nothing
                    Else
                        BadGroupHandle
                        MyRead = False
                        Set myobject = Nothing
                        Exit Function
                    End If
                    ElseIf Typename$(myobject) = "lambda" Then
                        Set pppp.item(it) = myobject
                        Set myobject = Nothing
                    ElseIf Typename$(myobject) = myArray Then
                                  If myobject.Arr Then
                        Set pppp.item(it) = CopyArray(myobject)
                    Else
                        Set pppp.item(it) = myobject
                    End If
                    Set myobject = Nothing
                ElseIf Typename$(myobject) = mHdlr Then
                    Set usehandler = myobject
                    If usehandler.indirect > -0 Then
                        Set pppp.item(it) = usehandler
                    Else
                        p = usehandler.t1
                        If CheckDeepAny(myobject) Then
                            If TypeOf myobject Is mHandler Then
                                Set pppp.item(it) = myobject
                            Else
                                Set usehandler = New mHandler
                                Set pppp.item(it) = usehandler
                                usehandler.t1 = p
                                Set usehandler.objref = myobject
                                Set usehandler = Nothing
                            End If
                            Set myobject = Nothing
                        End If
                    End If
                ElseIf Typename$(myobject) = mProp Then
                    Set pppp.item(it) = myobject
                    Set myobject = Nothing
                End If
            ElseIf Not bs.IsNumber(p) Then
                If bs.IsString(s$) Then
                    pppp.item(it) = s$
                Else
                    bstack.soros.drop 1
                    MissStackNumber
                    MyRead = False
                    Exit Function
                End If
            ElseIf x1 = 7 Then
                pppp.item(it) = Round(p)
            Else
                pppp.item(it) = p
            End If
        End If
        MyRead = True
    End If
 Case 6
    MyRead = False
    If FastSymbol(rest$, ")") Then
        MyRead = globalArrByPointer(bs, bstack, what$, flag2): If Not MyRead Then SyntaxError: Exit Function
    Else
        If neoGetArray(bstack, what$, pppp) And Not flag2 Then
            If Not NeoGetArrayItem(pppp, bs, what$, it, rest$) Then Exit Function
        Else
            Exit Function
        End If
        If Not bs.IsString(s$) Then
            If bs.IsObjectRef(myobject) Then
                If Typename$(myobject) = "lambda" Then
                    Set pppp.item(it) = myobject
                    Set myobject = Nothing
                ElseIf Typename$(myobject) = mgroup Then
                    Set pppp.item(it) = myobject
                    Set myobject = Nothing
                ElseIf Typename$(myobject) = myArray Then
                    If myobject.Arr Then
                        Set pppp.item(it) = CopyArray(myobject)
                    Else
                        Set pppp.item(it) = myobject
                    End If
                    Set myobject = Nothing
                ElseIf Typename$(myobject) = mHdlr Then
                    Set usehandler = myobject
                    If usehandler.indirect > -0 Then
                        Set pppp.item(it) = myobject
                    Else
                        p = usehandler.t1
                        If CheckDeepAny(myobject) Then
                            If TypeOf myobject Is mHandler Then
                                Set pppp.item(it) = myobject
                            Else
                                Set usehandler = New mHandler
                                Set pppp.item(it) = usehandler
                                usehandler.t1 = p
                                Set usehandler.objref = myobject
                                Set usehandler = Nothing
                            End If
                            Set myobject = Nothing
                        End If
                    End If
                ElseIf Typename$(myobject) = mProp Then
                    Set pppp.item(it) = myobject
                    Set myobject = Nothing
                Else
                    MissStackStr
                    Exit Function
                End If
            Else
                bstack.soros.drop 1
                MissStackStr
                Exit Function
            End If
        Else
            If Not MyIsObject(pppp.item(it)) Then
                pppp.item(it) = s$
            ElseIf pppp.ItemType(it) = mgroup Then
            ' do something
            Else
                Set pppp.item(it) = New Document
                CheckVar pppp.item(it), s$
            End If
        End If
        MyRead = True
    End If
'*****************************************************
    End Select
    p = 0#
    Exit Function
read:
If FastSymbol(rest$, "?") Then useoptionals = True

flag2 = Fast2Label(rest$, "мео", 3, "NEW", 3, 3)
If Not flag2 Then flag = Fast2Label(rest$, "топийа", 6, "LOCAL", 5, 6)
read123:
Set bs = bstack
contFromRebound:
par = Fast2Label(rest$, "апо", 3, "FROM", 4, 4)
If par And f Then
SyntaxError
MyRead = False
Exit Function
End If
If par Then
' make it general...
x1 = Abs(IsLabelBig(bstack, rest$, ss$, , , , par))

If x1 > 0 And x1 <> 1 Then rest$ = ss$ + " " + rest$
If x1 = 1 Then

 If getvar2(bstack, ss$, i, , , flag) Then
 If MyIsObject(var(i)) Then
            ' need to make new stack frame with pointers to
        If Typename(var(i)) <> mgroup Then MyRead = True: Exit Function
        Set ps = New mStiva
        If ohere$ <> "" And Not var(i).IamGlobal Then
        Set myobject = var(i).PrepareSoros(var(), ohere$ + ".")
        Else
        Set myobject = var(i).PrepareSoros(var(), "")
        End If
                
        With myobject
               For x1 = 1 To .Total
                  s$ = .StackItem(x1) + " "
                  If Left$(s$, 1) = "*" Then '' we have a group
                  s$ = Split(Mid$(s$, 2))(0)
                  Else
                  s$ = Split(s$)(0)
                  End If

 ''we place references

                If Right$(s$, 2) = "()" Then
                        ps.DataStr Left$(s$, Len(s$) - 2)
                ElseIf Right$(s$, 1) = "(" Then
                        ps.DataStr Left$(s$, Len(s$) - 1)
                Else
                        ps.DataStr s$
                End If
 ''bstack.Soros.DataStr .StackItem(X1)
            Next x1
        End With
Set myobject = Nothing
 Set bs = New basetask
    Set bs.Sorosref = ps
    If FastSymbol(rest$, ";") Then
    bstack.soros.MergeTop ps
    
    MyRead = True
    Exit Function
    End If
    If Not FastSymbol(rest$, ",") Then
    MissPar
    MyRead = False
 Exit Function
    End If
    
 Else
 MissingGroup
 MyRead = False
 Exit Function
 End If
 Else
 MissingGroup
 MyRead = False
 Exit Function
 End If
 Col = 1 ' this is a switch... look down
 
ElseIf IsStrExp(bstack, rest$, ss$) Then
Set ps = New mStiva
Do While ss$ <> ""
If ISSTRINGA(ss$, pa$) Then
ps.DataStr pa$
ElseIf IsNumberD(ss$, X) Then
ps.DataVal X
Else
Exit Do
End If
Loop
Set bs = New basetask
Set bs.Sorosref = ps
    If Not FastSymbol(rest$, ",") Then
    MissPar
    MyRead = False
 Exit Function
    End If
End If
End If
' from here is not Myread = True
Do
again1:
MyRead = False
ihavetype = False
If look Then If FastSymbol(rest$, "?") Then useoptionals = True
If FastSymbol(rest$, ",") Then bs.soros.drop 1: GoTo again1
If FastSymbol(rest$, "&") Or Col = 1 Then
' so now for GROUP variables we use only by reference
Select Case Abs(IsLabel(bstack, rest$, what$))
Case 1
If bs.IsString(s$) Then
     
          
    
    If GetGlobalVar(s$, i) Then
    
conthereifglobal:
        If flag2 Then
            If Not f Then
                If Not flag Then
                    If ohere$ <> "" Then
                        GoTo contpush12
                    Else
                        NoSecReF
                        Exit Do
                    End If
                End If
            End If
        ElseIf GetVar3(bstack, what$, it, , , flag, , , , True) And Not f Then
               If Not flag Then
                          If GetlocalVar(what$, y1) = False And ohere$ <> "" Then
                                   GoTo contpush12
                              Else
                                  NoSecReF
                                 Exit Do
                            End If
                End If
                
   
   Else
contpush12:
       what$ = myUcase(what$)
backfromstr:
                If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                   If Not MyIsObject(var(i)) Then
                        p = var(i)
checkconstant:
                        Select Case VarType(p)
                        Case vbDecimal
                            If Not Fast2Varl(rest$, "аяихлос", 7, "DECIMAL", 7, 7, ff) Then MyRead = False: MissType: Exit Function
                        Case vbDouble
                            If Not Fast2Varl(rest$, "дипкос", 6, "DOUBLE", 6, 6, ff) Then MyRead = False: MissType: Exit Function
                        Case vbSingle
                            If Not Fast2Varl(rest$, "апкос", 5, "SINGLE", 6, 6, ff) Then MyRead = False: MissType: Exit Function
                        Case vbBoolean
                            If Not Fast2Varl(rest$, "коцийос", 7, "BOOLEAN", 7, 7, ff) Then MyRead = False: MissType: Exit Function
                        Case vbLong
                            If Not Fast2Varl(rest$, "лайяус", 6, "LONG", 4, 6, ff) Then MyRead = False: MissType: Exit Function
                        Case vbInteger
                            If Not Fast2Varl(rest$, "айеяаиос", 8, "INTEGER", 7, 8, ff) Then MyRead = False: MissType: Exit Function
                        Case vbCurrency
                            If Not Fast2Varl(rest$, "коцистийо", 9, "CURRENCY", 8, 9, ff) Then MyRead = False: MissType: Exit Function
                        Case Else
                            p = IsLabel(bstack, rest$, (what$))  ' just throw any name
                        End Select
                    Else
                        If TypeOf var(i) Is Group Then
                            If Fast2Varl(rest$, "олада", 5, "GROUP", 5, 5, ff) Then
                            If var(i).IamApointer Then
                                If var(i).link.IamFloatGroup Then GoTo errgr
                                    If Len(var(i).lasthere) = 0 Then
                                        If Not GetVar(bstack, var(i).GroupName, i, True) Then GoTo errgr
                                    Else
                                        If Not GetVar(bstack, var(i).lasthere + "." + var(i).GroupName, i, True) Then GoTo errgr

                                    End If
                                 End If
                            ElseIf Fast2Varl(rest$, "деийтгс", 7, "POINTER", 7, 7, ff) Then
                                     If Not var(i).IamApointer Then MyRead = False: MissType: Exit Function
                            Else
                            If FastSymbol(rest$, "*") Then
                                If FastPureLabel(rest$, s$, , True) <> 1 Then SyntaxError: MyRead = False: Exit Function
                                If Not var(i).IamApointer Then GoTo errgr
                                If var(i).link.IamFloatGroup Then
                                    If Not var(i).link.TypeGroup(s$) Then GoTo errgr
                                Else
                                    If Len(var(i).lasthere) = 0 Then
                                    If GetVar(bstack, var(i).GroupName, it, True) Then
                                        If Not var(it).TypeGroup(s$) Then GoTo errgr
                                    Else
                                        GoTo noref01
                                    End If
                                    Else
                                        If GetVar(bstack, var(i).lasthere + "." + var(i).GroupName, it, True) Then
                                            If Not var(it).TypeGroup(s$) Then GoTo errgr
                                        Else
                                            GoTo noref01
                                        End If
                                    End If
                                    it = 0
                                End If

                            ElseIf FastPureLabel(rest$, s$, , True) = 1 Then
                                    If var(i).IamApointer Then

                                    If var(i).link.IamFloatGroup Then
                                        MyRead = False: MissType: Exit Function
                                    End If
                                        If Len(var(i).lasthere) = 0 Then
                                            If Not GetVar(bstack, var(i).GroupName, i, True) Then
                                                GoTo errgr
                                            End If
                                        ElseIf Not GetVar(bstack, var(i).lasthere + "." + var(i).GroupName, i, True) Then
                                                GoTo errgr
                                        End If
                                    End If
                                    If Not var(i).TypeGroup(s$) Then GoTo errgr
                            Else
                                    MyRead = False: MissType: Exit Function
                            End If
                            End If
                        ElseIf TypeOf var(i) Is mHandler Then
                            Set usehandler = var(i)
                            If TypeOf usehandler.objref Is mArray Then
                                If Not Fast2Varl(rest$, "пимайас", 7, "ARRAY", 5, 7, ff) Then MyRead = False: MissType: Exit Function
                            ElseIf TypeOf usehandler.objref Is FastCollection Then
                                If Not Fast2Varl(rest$, "йатастасг", 9, "INVENTORY", 9, 9, ff) Then
                                     If Not Fast2Varl(rest$, "киста", 5, "LIST", 4, 5, ff) Then
                                        If Not Fast2Varl(rest$, "оуяа", 4, "QUEUE", 5, 5, ff) Then
                                            MyRead = False: MissType: Exit Function
                                        ElseIf Not usehandler.objref.IsQueue Then
                                            MyRead = False: MissType: Exit Function
                                            Exit Function
                                        End If
                                    ElseIf usehandler.objref.IsQueue Then
                                        MyRead = False: MissType: Exit Function
                                        Exit Function
                                    End If
                                End If
                            ElseIf TypeOf usehandler.objref Is mStiva Then
                                If Not Fast2Varl(rest$, "сыяос", 5, "STACK", 5, 5, ff) Then MyRead = False: MissType: Exit Function
                            ElseIf TypeOf usehandler.objref Is MemBlock Then
                                If Not Fast2Varl(rest$, "диаяхяысг", 9, "BUFFER", 6, 9, ff) Then MyRead = False: MissType: Exit Function
                            ElseIf usehandler.t1 = 4 Then
                              If Not FastType(rest$, usehandler.objref.EnumName) Then MyRead = False: MissType: Exit Function
                   
                            Else
                                p = IsLabel(bstack, rest$, (what$)) ' just throw any name
                            End If
                        ElseIf TypeOf var(i) Is lambda Then
                            If Not Fast2Varl(rest$, "калда", 5, "LAMBDA", 6, 6, ff) Then MyRead = False: MissType: Exit Function
                        
                        ElseIf TypeOf var(i) Is mEvent Then
                            If Not Fast2Varl(rest$, "цецомос", 7, "EVENT", 5, 5, ff) Then MyRead = False: MissType: Exit Function
                        ElseIf TypeOf var(i) Is Constant Then
                            p = var(i)
                            GoTo checkconstant
                        Else
                            p = IsLabel(bstack, rest$, (what$)) ' just throw any name
                        End If
                    End If
                End If
       If Not LinkGroup(bstack, what$, var(i)) Then
            If f Then

                If Not ReboundVar(bstack, what$, i) Then globalvar what$, i, True
            Else
    
                globalvar what$, i, True
                If Typename(var(i)) = "lambda" Then
islambda:
                
                    If ohere$ = vbNullString Then
                        GlobalSub what$ + "()", "", , , i
                    Else
                        GlobalSub ohere$ & "." & bstack.GroupName & what$ + "()", "", , , i
                    End If
                ElseIf Typename(var(i)) = "Constant" Then
                    If var(i).flag Then GoTo islambda
                End If
                
            End If
        Else
            it = globalvar(what$, it)
            MakeitObject2 var(it)
            If var(i).IamApointer Then
            If var(i).link.IamFloatGroup Then
               Set var(it).LinkRef = var(i).link
                var(it).IamApointer = True
                var(it).isRef = True
            Else
            With var(i).link
            
                var(it).edittag = .edittag
                var(it).FuncList = .FuncList
                var(it).GroupName = myUcase(what$) + "."
                Set var(it).Sorosref = .soros.Copy
                var(it).HasValue = .HasValue
                var(it).HasSet = .HasSet
                var(it).HasStrValue = .HasStrValue
                var(it).HasParameters = .HasParameters
                var(it).HasParametersSet = .HasParametersSet
                var(it).HasRemove = .HasRemove
                        Set var(it).Events = .Events
            
                var(it).highpriorityoper = .highpriorityoper
                var(it).HasUnary = .HasUnary
                If Len(here$) > 0 Then
                var(it).Patch = here$ + "." + what$
                Else
                var(it).Patch = what$
                End If
                Set var(it).mytypes = .mytypes
            End With
            End If
            
            Else
            With var(i)
            
                var(it).edittag = .edittag
                var(it).FuncList = .FuncList
                var(it).GroupName = myUcase(what$) + "."
                Set var(it).Sorosref = .soros.Copy
                var(it).HasValue = .HasValue
                var(it).HasSet = .HasSet
                var(it).HasStrValue = .HasStrValue
                var(it).HasParameters = .HasParameters
                var(it).HasParametersSet = .HasParametersSet
                var(it).HasRemove = .HasRemove
                        Set var(it).Events = .Events
            
                var(it).highpriorityoper = .highpriorityoper
                var(it).HasUnary = .HasUnary
                If Len(here$) > 0 Then
                var(it).Patch = here$ + "." + what$
                Else
                var(it).Patch = what$
                End If
                Set var(it).mytypes = .mytypes
            End With
             var(it).IamRef = Len(bstack.UseGroupname) > 0
             End If
            If var(i).HasStrValue Then
                globalvar what$ + "$", it, True
            End If
            
        End If
        MyRead = True
    End If
     Else
        If Left$(s$, 1) = "#" Then  ' for copy in
            s$ = Mid$(s$, 2)
            If IsNumberNew(bstack, (s$), p, 1, False) Then
                ss$ = "_" + Str$(var2used)
                If bstack.SubLevel > 0 Then
                    MyEr "not for Read statement", "ЭВИ ЦИА ТГМ дИэБАСЕ"
                    MyRead = False
                    Exit Function
                End If
                i = globalvar(ss$, 0#, , True)
                If bstack.IamChild Then FeedCopyInOut bstack.Parent, s$, i, ""
                UnFloatGroup bstack, ss$, i, bstack.lastobj, True, , True
                bstack.lastobj.ToDelete = True
                GoTo conthereifglobal
            End If
        Else
            If GetVar3(bstack, s$, i, True, , , , , , True) Then GoTo conthereifglobal
        End If
noref01:
         NoReference
        MyRead = False
        Exit Function
     End If
    Else
If bs.IsObjectRef(myobject) Then

If TypeOf myobject Is Group Then
If myobject.IamApointer Then
i = AllocVar()
Set var(i) = myobject
Set myobject = Nothing
GoTo backfromstr
End If
GoTo er103
Else
If Not GetVar3(bstack, what$, i, , , flag, , , , True) Then i = globalvar(what$, 0)
If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
If Not FastPureLabel(rest$, ss$) = 1 Then
    GoTo er110
Else
CheckItemType bstack, CVar(myobject), vbNullString, s$, , ok
If ok Then
    If ss$ <> s$ Then GoTo er103

ElseIf UCase(ss$) <> UCase(s$) Then GoTo er103
End If
End If
End If
End If
CreateFormOtherObject var(i), myobject
 MyRead = True
Set myobject = Nothing
Else
    GoTo noref01
    End If
    End If

Case 3, 4
    If bs.IsString(s$) Then
        If GetGlobalVar(s$, i) Then
            If flag2 Then
            If Not f Then
                If Not flag Then
                    If ohere$ <> "" Then
                            'GoTo contpush12
               If MyIsObject(var(i)) Then
                    If Typename(var(i)) = "lambda" Then
                        If ohere$ = vbNullString Then
                            GlobalSub what$ + "()", "", , , i
                        Else
                            GlobalSub ohere$ & "." & bstack.GroupName & what$ + "()", "", , , i
                        End If
                        globalvar what$, i, True
                    ElseIf Typename(var(i)) = mgroup Then
                        what$ = Left$(what$, Len(what$) - 1)
                        GoTo backfromstr
                    Else
                        globalvar what$, i, True
                    End If
                Else
                     globalvar what$, i, True
                 End If
               MyRead = True
               Else
                        NoSecReF
                        Exit Do
                    End If
                End If
            End If
        ElseIf GetVar3(bstack, what$, it, , , flag, , , , True) And Not f Then
            If Not flag Then
                          If GetlocalVar(what$, y1) = False And ohere$ <> "" Then

                                GoTo contherestr
                              Else
                                  NoSecReF
                                 Exit Do
                            End If
                End If
                NoSecReF
                Exit Do
            Else
                If f Then
                    If Not ReboundVar(bstack, what$, i) Then globalvar what$, i, True
                Else
contherestr:

            If MyIsObject(var(i)) Then
                    If Typename(var(i)) = "lambda" Then
                         If ohere$ = vbNullString Then
                             GlobalSub what$ + "()", "", , , i
                         Else
                             GlobalSub ohere$ & "." & bstack.GroupName & what$ + "()", "", , , i
                         End If
                         globalvar what$, i, True
                    ElseIf Typename(var(i)) = mgroup Then
                         what$ = Left$(what$, Len(what$) - 1)
                         GoTo backfromstr
                    Else
                         globalvar what$, i, True
                     End If
                Else
                globalvar what$, i, True
                End If
                End If
                MyRead = True
            End If
        Else
            GoTo noref01
        End If
    Else
        GoTo noref01
    End If
Case 5, 6, 7
    If bs.IsString(s$) Then  ' get the pointer!!!!!
        If lookOne(s$, "{") Then
            If Not FastSymbol(rest$, ")") Then
                GoTo er107
            Else
                s$ = Left$(what$, Len(what$) - 1) + " " + s$
conter00:
                If f Then
                    ss$ = here$
                    here$ = vbNullString
                    If Not MyFunction(0, bstack, s$, 1, , flag2) Then
                        GoTo er106
                        Exit Do
                    Else
                        sbf(bstack.IndexSub).sbgroup = s$
                        i = Len(s$)
                        If i > 0 Then
                            If varhash.Find(Left$(s$, i - 1), i) Then sbf(bstack.IndexSub).tpointer = i
                        Else
                            sbf(bstack.IndexSub).tpointer = 0
                        End If
                    End If
                    here$ = ss$
                Else
                    If Not MyFunction(0, bstack, s$, 1, , flag2) Then
                        GoTo er106
                        Exit Do
                    Else
                        sbf(bstack.IndexSub).sbgroup = s$
                        i = Len(s$)
                        If i > 0 Then
                            If varhash.Find(Left$(s$, i - 1), i) Then sbf(bstack.IndexSub).tpointer = i
                        Else
                            sbf(bstack.IndexSub).tpointer = 0
                        End If
                    End If
                End If
                MyRead = True
            End If
        Else
            i = CopyArrayItemsNoFormated(bstack, s$)
            If i <> 0 Then
                If Not FastSymbol(rest$, ")") Then GoTo er107
                If f And i > 0 Then '' look about f - work for refer but no refer can be done...why???
                    If Not ReboundArr(bstack, what$, i) Then GoTo arrconthere
                Else
arrconthere:
                what$ = myUcase(what$)
                If ohere$ = vbNullString Then
                    If varhash.ExistKey(what$) Then
                      If flag2 And Not f And Not flag Then
                        If i < 0 Then i = -i
                           varhash.ItemCreator what$, i
                           ' what$ now is empty string
                    Else
                        GoTo er108
                        End If
                    Else
                        varhash.ItemCreator what$, i
                    End If
                Else
                    If varhash.ExistKey(ohere$ & "." & what$) Then
                    If flag2 And Not f And Not flag Then
                        i = Abs(i)
                           varhash.ItemCreator ohere$ & "." & what$, i, True, True
                    Else
                        GoTo er108
                    End If
                    Else
                      i = Abs(i)
                    varhash.ItemCreator ohere$ & "." & what$, i, True, True
                    End If
                End If

            End If
            MyRead = True
        Else
        ' get function
        If GetSub(s$, i) Then
        If Len(sbf(i).sbgroup) > 0 Then
        If sbf(i).Extern > 0 Then
        s$ = Left$(what$, Len(what$) - 1) + " { call extern" + Str$(sbf(i).Extern) + "}" + sbf(i).sbgroup
        Else
        s$ = Left$(what$, Len(what$) - 1) + " {" + sbf(i).sb + "}" + sbf(i).sbgroup
        End If
        Else
        If sbf(i).Extern > 0 Then
        s$ = Left$(what$, Len(what$) - 1) + " { call extern" + Str$(sbf(i).Extern) + "}"
        Else
        s$ = Left$(what$, Len(what$) - 1) + " {" + sbf(i).sb + "}"
        End If
        End If
        GoTo conter00
        End If
        End If
    End If
End If
Case Else
    Exit Do
End Select
Else
' here not for LET any more
read2:
x1 = Abs(IsLabel(bstack, rest$, what$))
'If x1 <> 0 Then
'    If what$ <> myUcase(what$) Then Stop
'End If
Select Case x1
Case 1
    If bs.IsObjectRef(myobject) Then
        MyRead = True
        If flag2 Then
        GoTo comehere
        ElseIf flag Then
            p = 0#
           i = globalvar(what$, p)
           GoTo contread123
        End If
       If GetVar3(bstack, what$, i, , , flag, s$, checktype, isAglobal, True, ok) Then
        If isAglobal And Not allowglobals Then
        GoTo comehere
        End If
contread123:
                If Typename$(myobject) = Typename(var(i)) Then
                    If Typename$(var(i)) = mgroup Then
                                 ss$ = bstack.GroupName
                                 If Len(s$) > 0 Then what$ = s$
                                 If Len(var(i).GroupName) > Len(what$) Then
                                    ff = 1
                                    If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                                   If FastSymbol(rest$, "*") Then
                                        If FastPureLabel(rest$, s$, , True) <> 1 Then SyntaxError: MyRead = False: Exit Function
                                            If s$ = "POINTER" Then
                                                If Not myobject.IamApointer Then GoTo errgr
                                            ElseIf s$ = "деийтгс" Then
                                                If Not myobject.IamApointer Then GoTo errgr
                                            
                                            ElseIf myobject.IamApointer Then
                                                If Not myobject.link.TypeGroup(s$) Then
                                                    GoTo errgr
                                                End If
                                            Else
                                                GoTo errgr
                                            End If
                                    Else
                                        If FastPureLabel(rest$, s$, , True) <> 1 Then SyntaxError: MyRead = False: Exit Function
                                            If s$ = "POINTER" Then
                                                If Not myobject.IamApointer Then GoTo errgr
                                            ElseIf s$ = "деийтгс" Then
                                                If Not myobject.IamApointer Then GoTo errgr
                                            ElseIf s$ = "GROUP" Then
                                                ' get pointer too
                                            ElseIf s$ = "олада" Then
                                                ' get pointer too
                                            ElseIf myobject.IamApointer Then
                                                If Not myobject.link.TypeGroup(s$) Then
                                                    GoTo errgr
                                                End If
                                            ElseIf Not myobject.TypeGroup(s$) Then
                                                GoTo errgr

                                            End If
                                   End If
                                    End If
                                    If var(i).IamRef Then
                                        SwapStrings s$, here$
                                        here$ = vbNullString
                                        UnFloatGroupReWriteVars bstack, what$, i, myobject
                                        SwapStrings here, s$
                                        s$ = vbNullString
                                    Else
                                        UnFloatGroupReWriteVars bstack, what$, i, myobject
                                        myobject.ToDelete = True
                                    End If
                                Else
                                    If Len(var(i).Patch) > 0 Then what$ = var(i).Patch
                                    bstack.GroupName = Left$(what$, Len(what$) - Len(var(i).GroupName) + 1)
                                    If Len(var(i).GroupName) > 0 Then
                                        ff = 1
                                        If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                                            If FastPureLabel(rest$, s$, , True) <> 1 Then SyntaxError: MyRead = False: Exit Function
                                            If Not myobject.TypeGroup(s$) Then GoTo errgr
                                        End If
                                        what$ = Left$(var(i).GroupName, Len(var(i).GroupName) - 1)
                                        SwapStrings s$, here$
                                        here$ = vbNullString
                                        UnFloatGroupReWriteVars bstack, what$, i, myobject, , , ByPass
                                        myobject.ToDelete = True
                                        ByPass = False
                                        SwapStrings here, s$
                                        s$ = vbNullString
                                    ElseIf var(i).IamApointer And myobject.IamApointer Then
                                    ff = 1
                                    If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
    
                                    FastSymbol rest$, "*"
      
                                    If FastPureLabel(rest$, s$, , True) <> 1 Then SyntaxError: MyRead = False: Exit Function
      
                                    If myobject.link.IamFloatGroup Then
                                    
                                    If Not myobject.link.TypeGroup(s$) Then
                                        If s$ = "POINTER" Then
                                        ElseIf s$ = "деийтгс" Then
                                        Else
                                        GoTo errgr
                                        End If
                                    End If
                                    Else
                                        If Len(myobject.lasthere) = 0 Then
                                            If GetVar(bstack, myobject.GroupName, it, True) Then
                                                If Not var(i).TypeGroup(s$) Then GoTo errgr
                                            End If
                                        ElseIf GetVar(bstack, myobject.lasthere + "." + myobject.GroupName, it, True) Then
                                                If Not var(i).TypeGroup(s$) Then GoTo errgr
                                        End If
                                    End If
                                    
                                    End If
                                    Set var(i) = myobject
                                    
                                    Else
                                        Set myobject = Nothing
                                        bstack.GroupName = ss$
                                        GroupWrongUse
                                        MyRead = False
                                        Exit Function
                                    End If
                                End If
                                Set myobject = Nothing
                                bstack.GroupName = ss$
    
                   
                    ElseIf Typename$(var(i)) = mHdlr Then
                        Set usehandler = myobject
                        Set usehandler1 = var(i)
                        If usehandler1.ReadOnly Then
                            MyRead = False
                           ReadOnly
                           Exit Function
                           
                        ElseIf usehandler1.t1 = usehandler.t1 Then
                            If usehandler1.t1 = 4 Then
                                If usehandler1.objref Is usehandler.objref Then
                                    Set var(i) = myobject
                                ElseIf usehandler1.objref.EnumName = usehandler.objref.EnumName Then
                                    If usehandler1.objref.ExistFromOther(usehandler.index_cursor) Then
                                        Set usehandler.objref = usehandler1.objref
                                        Set var(i) = usehandler
                                    Else
                                        GoTo er103
                                    End If
                                Else
                                    GoTo er103
                                End If
                            Else
                            
                                Set var(i) = myobject
                           End If
                        ElseIf usehandler1.t1 <> 4 And usehandler.t1 = 3 Then
                           Set var(i) = myobject
                        Else
                          GoTo er103
                        End If
                    Else
                    Set var(i) = myobject
                    End If
                    If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                    
                    If Not FastPureLabel(rest$, s$) = 1 Then
                        GoTo er110
                    End If
                    ' no second time
                    If Not myobject Is Nothing Then
                    If TypeOf myobject Is mHandler Then
                        
                        Set usehandler = myobject
                        s$ = myUcase(s$)
                        If usehandler.t1 = 1 Then
                        ff = 0
                        
                        If Not Fast2Varl(s$, "йатастасг", 9, "INVENTORY", 9, 9, ff) Then
                        If usehandler.objref.IsQueue Then
                            If Not Fast2Varl(s$, "оуяа", 4, "QUEUE", 5, 5, ff) Then GoTo er103
                        Else
                            If Not Fast2Varl(s$, "киста", 5, "LIST", 4, 5, ff) Then GoTo er103
                        End If
                        End If
                        ElseIf usehandler.t1 = 3 Then
                        ff = 0
                        If Fast2Varl(s$, "пимайас", 7, "ARRAY", 5, 7, ff) Then
                            If Not CheckIsmArray(myobject) Then GoTo er103
                        ElseIf Fast2Varl(s$, "сыяос", 5, "STACK", 5, 5, ff) Then
                            If Not CheckIsmStiva(myobject) Then GoTo er103
                        Else
                            GoTo er103
                        End If
                        ElseIf usehandler.t1 = 4 Then
                        Else
                        GoTo er103
                        End If
                    End If
                    End If
                    
                    End If
                ElseIf x1 = 1 And CheckIsmArray(myobject) Then
               
                    ''bstack.lastobj.CopyArray pppp
                    Set usehandler = New mHandler
                    Set var(i) = usehandler
                    usehandler.t1 = 3
                    Set usehandler.objref = myobject
                    Set usehandler = Nothing
                    If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                        If Not Fast2Varl(rest$, "пимайас", 7, "ARRAY", 5, 7, ff) Then GoTo er103
                    End If
                    Set myobject = Nothing
                ElseIf MyIsNumeric(var(i)) Then
                If Not myobject Is Nothing Then
                If TypeOf myobject Is Group Then
                If myobject.IamApointer Then
                Set var(i) = myobject
                GoTo cont10101
                End If
                End If
                End If
                GoTo er103
                Else
                     MyRead = False
                     If Typename(var(i)) = "Nothing" Then
                     MissingObjRef
                     Else
                    GoTo er103
                    End If
                    Exit Function
                    
                End If
cont10101:
        Else
        If i = -1 Then
        ff = 0
        If TypeOf myobject Is mHandler Then
        Set usehandler = myobject
        If Fast2Varl(rest$, "ыс", 2, "AS", 2, 2, ff) Then
                If usehandler.t1 = 1 Then
                    If Not Fast2Varl(rest$, "йатастасг", 9, "INVENTORY", 9, 9, ff) Then
                         If Not Fast2Varl(rest$, "киста", 5, "LIST", 4, 5, ff) Then
                            If Not Fast2Varl(rest$, "оуяа", 4, "QUEUE", 5, 5, ff) Then
                                WrongObject
                                MyRead = False
                                Exit Function
                            ElseIf Not usehandler.objref.IsQueue Then
                                WrongObject
                                MyRead = False
                                Exit Function
                            End If
                        ElseIf usehandler.objref.IsQueue Then
                            WrongObject
                            MyRead = False
                            Exit Function
                        End If
                    End If
                ElseIf usehandler.t1 = 2 Then
                    If Not Fast2Varl(rest$, "диаяхяысг", 9, "BUFFER", 6, 9, ff) Then
                            WrongObject
                            MyRead = False
                            Exit Function
                    End If
                ElseIf usehandler.t1 = 3 Then
                    If Not Fast2Varl(rest$, "пимайас", 7, "ARRAY", 5, 7, ff) Then
                    If Not Fast2Varl(rest$, "сыяос", 5, "STACK", 5, 5, ff) Then
                    
                            WrongObject
                            MyRead = False
                            Exit Function
                    End If
                    End If
                    
                ElseIf usehandler.t1 = 4 Then
                    If Not FastType(rest$, usehandler.objref.EnumName) Then
                    
                        p = usehandler.index_cursor
                        Set myobject = Nothing
                        Set usehandler = Nothing
                        GoTo conthereEnum
                    End If
                End If
        End If
        Set usehandler = Nothing
        bstack.SetVarobJ what$, myobject
        GoTo loopcont123
        ElseIf TypeOf myobject Is Group Then
        If Fast2Varl(rest$, "ыс", 2, "AS", 2, 2, ff) Then
            If Fast2Varl(rest$, "деийтгс", 7, "POINTER", 7, 7, ff) Then GoTo checkpointer
            WrongObject
            MyRead = False
            Exit Function
        End If
checkpointer:
        If myobject.IamApointer Then
        If myobject.link.IamFloatGroup Then
            bstack.SetVarobJ what$, myobject
           GoTo loopcont123
        End If
        End If
        End If
        If FastPureLabel(rest$, ss$, , True) = 1 Then
        If check2(ss$, "ыс", "AS") Then GoTo er110
        End If
        WrongObject
        MyRead = False
        Exit Function
        End If
        
comehere:
        i = globalvar(what$, 0)
        If Typename$(myobject) = mgroup Then
            If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                If Fast2Varl(rest$, "деийтгс", 7, "POINTER", 7, 7, ff) Then
                    If Not myobject.IamApointer Then
errgr:
                          WrongObject
                          MyRead = False
                          Exit Function
                    End If
                    GoTo contpointer
                    ElseIf Not Fast2Varl(rest$, "олада", 5, "GROUP", 5, 5, ff) Then
                        If FastSymbol(rest$, "*") Then
                               If FastPureLabel(rest$, s$, , True) <> 1 Then SyntaxError: MyRead = False: Exit Function
                                If Not myobject.IamApointer Then GoTo errgr
                                If myobject.link.IamFloatGroup Then
                                    If Not myobject.link.TypeGroup(s$) Then GoTo errgr
                                Else
                                    If Len(myobject.lasthere) = 0 Then
                                    If GetVar(bstack, myobject.GroupName, it, True) Then
                                        If Not var(it).TypeGroup(s$) Then GoTo errgr
                                    End If
                                    ElseIf GetVar(bstack, myobject.lasthere + "." + myobject.GroupName, it, True) Then
                                            If Not var(it).TypeGroup(s$) Then GoTo errgr
                                    End If
                                    it = 0
                                End If
                            GoTo contpointer
                        ElseIf myobject.IamApointer Then
                            If FastPureLabel(rest$, s$, , True) = 1 Then
                                If myobject.link.IamFloatGroup Then
                                    If Not myobject.link.TypeGroup(s$) Then GoTo errgr
                                    GoTo oop0
                                ElseIf Len(myobject.lasthere) = 0 Then
                                    If GetVar(bstack, myobject.GroupName, i, True) Then
                                        If Not var(i).TypeGroup(s$) Then GoTo errgr
                                        CopyGroup2 var(i), bstack
                                        GoTo oop1
                                    Else
                                        GoTo errgr
                                    End If
                                ElseIf GetVar(bstack, myobject.lasthere + "." + myobject.GroupName, i, True) Then
                                    If Not var(i).TypeGroup(s$) Then GoTo errgr
                                    CopyGroup2 var(i), bstack
                                    GoTo oop1
                                Else
                                    GoTo errgr
                                End If
                                
                            Else
                                SyntaxError
                                MyRead = False
                                Exit Function
                            End If
                        ElseIf FastPureLabel(rest$, s$, , True) <> 1 Then
                              GoTo errgr
                        Else
                              If Not myobject.TypeGroup(s$) Then GoTo errgr
                        End If
                    End If
                    If myobject.IamApointer Then
                        If myobject.link.IamFloatGroup Then
oop0:
                            If myobject.link Is NullGroup Then
                                Set myobject = New Group
                                myobject.BeginFloat 0
                                myobject.EndFloat
                                UnFloatGroup bstack, bstack.GroupName & what$, i, myobject, here$ = vbNullString Or Len(bstack.UseGroupname) > 0
                            Else
                                UnFloatGroup bstack, bstack.GroupName & what$, i, myobject.link, here$ = vbNullString Or Len(bstack.UseGroupname) > 0
                            End If
                        Else
                            CopyPointerRef bstack, myobject
oop1:
                            UnFloatGroup bstack, bstack.GroupName & what$, i, bstack.lastobj, here$ = vbNullString Or Len(bstack.UseGroupname) > 0
                            bstack.lastobj.ToDelete = True
                        End If
                    Else
                        UnFloatGroup bstack, bstack.GroupName & what$, i, myobject, here$ = vbNullString Or Len(bstack.UseGroupname) > 0, , True
                        myobject.ToDelete = True
                    End If
                    
                Else
contpointer:
                    If myobject.IamApointer Then
                        Set var(i) = myobject
                    Else
                        UnFloatGroup bstack, bstack.GroupName & what$, i, myobject, Not (here$ = vbNullString Xor Len(bstack.UseGroupname) > 0), , True
                        myobject.ToDelete = True
                    End If
               End If
               ' var(i).IamRef = Len(bstack.UseGroupname) > 0
            ElseIf Typename$(myobject) = "mEvent" Then
                If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                    If Not Fast2Varl(rest$, "цецомос", 7, "EVENT", 5, 5, ff) Then
                        WrongObject
                        Exit Function
                    End If
                End If
                Set var(i) = myobject
            ElseIf Typename$(myobject) = "lambda" Then
                            If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                    If Not Fast2Varl(rest$, "калда", 5, "LAMBDA", 6, 6, ff) Then
                        WrongObject
                        Exit Function
                    End If
                End If
                Set var(i) = myobject
                If ohere$ = vbNullString Then
                    GlobalSub what$ + "()", "", , , i
                Else
                    GlobalSub ohere$ & "." & bstack.GroupName & what$ + "()", "", , , i
                End If
            ElseIf Typename$(myobject) = mHdlr Then
            Set usehandler1 = myobject
            If MyIsObject(var(i)) Then
                If TypeOf var(i) Is mHandler Then
                    Set usehandler = var(i)
                        If usehandler.ReadOnly Then
                            ReadOnly
                            MyRead = False
                            Exit Function
                        End If
                    End If
                End If
                If usehandler1.indirect > -1 Then
                    If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                        If IsLabel(bstack, rest$, ss$) = 0 Then
                            GoTo er110
                        End If
                        If LCase(Typename(var(usehandler1.indirect))) <> LCase(ss$) Then
                            WrongObject
                            MyRead = False
                        Exit Function
                End If
             End If
                Set var(i) = MakeitObjectGeneric(usehandler1.indirect)
                Else
                If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
      
                If usehandler1.t1 = 1 Then
                    If Not Fast2Varl(rest$, "йатастасг", 9, "INVENTORY", 9, 9, ff) Then
                         If Not Fast2Varl(rest$, "киста", 5, "LIST", 4, 5, ff) Then
                            If Not Fast2Varl(rest$, "оуяа", 4, "QUEUE", 5, 5, ff) Then
                                WrongObject
                                MyRead = False
                                Exit Function
                            ElseIf Not usehandler1.objref.IsQueue Then
                                WrongObject
                                MyRead = False
                                Exit Function
                            End If
                        ElseIf usehandler1.objref.IsQueue Then
                            WrongObject
                            MyRead = False
                            Exit Function
                        End If
                    End If
                ElseIf usehandler1.t1 = 2 Then
                    If Not Fast2Varl(rest$, "диаяхяысг", 9, "BUFFER", 6, 9, ff) Then
                            WrongObject
                            MyRead = False
                            Exit Function
                    End If
                ElseIf usehandler1.t1 = 3 Then
                    
                    If Fast2Varl(rest$, "пимайас", 7, "ARRAY", 5, 7, ff) Then
                        If Not CheckIsmArray(myobject) Then GoTo er103
                        Set usehandler = New mHandler
                        Set usehandler.objref = myobject
                        usehandler.t1 = 3
                        Set myobject = usehandler
                        Set usehandler = Nothing
                        Set usehandler1 = Nothing
                    ElseIf Fast2Varl(rest$, "сыяос", 5, "STACK", 5, 5, ff) Then
                        If Not CheckIsmStiva(myobject) Then GoTo er103
                        Set usehandler = New mHandler
                        Set usehandler.objref = myobject
                        usehandler.t1 = 3
                        Set myobject = usehandler
                        Set usehandler = Nothing
                        Set usehandler1 = Nothing
                    ElseIf Typename(usehandler1.objref) = mHdlr Then
                        Set usehandler1 = usehandler1.objref
                        If usehandler1.t1 = 4 Then
                            If FastType(rest$, usehandler1.objref.EnumName) Then
                                Set usehandler = New mHandler
                                usehandler.t1 = 4
                                Set myobject = usehandler1.objref
                                usehandler.index_cursor = myobject.Value
                                Set usehandler.objref = myobject
                                usehandler.index_start = myobject.index
                                usehandler.sign = 1
                                Set myobject = usehandler
                                GoTo t14
                            End If
                         End If
                   Else
                        WrongObject
                        MyRead = False
                        Exit Function
                    End If
                    
                ElseIf usehandler1.t1 = 4 Then
                    If FastPureLabel(rest$, s$, , True) = 1 Then
                    If Not s$ = myUcase(usehandler1.objref.EnumName, True) Then
                    If GetSub(s$ + "()", i) Then
                    If sbf(i).IamAClass Then
                        GoTo er113
                    End If
                    ElseIf GetSub(bstack.GroupName + s$ + "()", i) Then
                    If sbf(i).IamAClass Then
                        GoTo er113
                    End If
                    End If
                        GoTo er112
                    End If
                    Else
                        GoTo er112
                    End If
                    If FastSymbol(rest$, "=") Then
                    ' drop type
                    If FastPureLabel(rest$, s$, , , True) <> 1 Then
                        MyRead = False
                        SyntaxError
                        Exit Function
                    End If
                    End If
                End If
                End If
t14:
                Set var(i) = myobject
                End If
            ElseIf Typename$(myobject) = myArray Then
                   
                   If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                    If Not Fast2Varl(rest$, "пимайас", 7, "ARRAY", 5, 7, ff) Then
                        WrongObject
                        Exit Function
                    End If
            End If
                Set usehandler = New mHandler
                Set var(i) = usehandler
                usehandler.t1 = 3
                Set usehandler.objref = myobject
                Set usehandler = Nothing
            Else
             If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                    If Not Fast2Varl(rest$, "деийтгс", 7, "POINTER", 7, 7, ff) Then
                    ElseIf IsLabel(bstack, rest$, ss$) = 0 Then
                        GoTo er110
                    End If
                
                If LCase(Typename(myobject)) <> LCase(ss$) Then
                        WrongObject
                        MyRead = False
                        Exit Function
                End If
            End If
                Set var(i) = myobject
            
            End If
            
            
            
            
            Set myobject = Nothing
        End If
    ElseIf bs.IsNumber(p) Then
    If Not lookOne(rest$, ",") Then
    ' FF used again
        If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
conthereEnum:
            ihavetype = True

            If Not FastPureLabel(rest$, s$, , , True) = 1 Then
            SyntaxError
            Exit Function
            End If
            ss$ = myUcase(s$, AscW(s$) > 255)
            Select Case ss$
            Case "аяихлос", "DECIMAL"
                If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
                p = CDec(p)
            Case "дипкос", "DOUBLE"
                If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
                p = CDbl(p)
            Case "апкос", "SINGLE"
                If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
                p = CSng(p)
            Case "коцийос", "BOOLEAN"
                If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
                p = CBool(p)
            Case "лайяус", "LONG"
                If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
                p = CLng(p)
            Case "айеяаиос", "INTEGER"
                If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
                p = CInt(p)
            Case "коцистийо", "CURRENCY"
                If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
                p = CCur(p)
            Case Else
                ss$ = s$
                it = True
                  If MyIsNumeric(p) Then X = p: it = False
                  If IsEnumAs(bstack, ss$, p, ok, rest$) Then
                    If Not it Then
                    
                        Set usehandler = p
                        p = X
                        Set usehandler = usehandler.objref.SearchValue(p, ok)
                        Set myobject = usehandler
                        If ok Then
                            Set p = myobject
                            
                            ' GoTo loopcont123
                        Else
                            ExpectedEnumType
                            MyRead = False
                            Exit Function
                        End If
                    
                    End If
                  Else
messnotype:
                  MyEr "No type [" + s$ + "] found", "ДЕМ БЯчЙА ТЩПО [" + s$ + "]"
                  Exit Function
                  End If
            End Select
        ElseIf FastSymbol(rest$, "=") Then
            If Not IsNumberD2(rest$, (p)) Then missNumber: Exit Function
        End If
    End If
        MyRead = True
        If flag2 Then
            globalvar what$, p
        ElseIf GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True, ok) Then
            If isAglobal And Not allowglobals Then
                 globalvar what$, p
            ElseIf MyIsObject(var(i)) Then
                If var(i) Is Nothing Then
                    MissingObjRef
                ElseIf TypeOf var(i) Is Group Then
                    If var(i).HasSet Then
                       
                        Set m = bstack.soros
                        Set bstack.Sorosref = New mStiva
                        bstack.soros.PushVal p
                        NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + ":=()", ok
                        Set bstack.Sorosref = m
                        Set m = Nothing
                    Else
                        GoTo there18274
                    End If
                Else
there18274:
                    If TypeOf var(i) Is Constant Then
                        CantAssignValue
                    ElseIf TypeOf var(i) Is mHandler Then
                        Set usehandler = var(i)
                        If usehandler.t1 <> 4 Then GoTo er104
                        If MyIsObject(p) Then
                            If Not TypeOf p Is mHandler Then
                                    ' errorhere
                                End If
                                Set usehandler1 = p
                                If usehandler.objref Is usehandler1.objref Then
                                    Set myobject = usehandler1
                                Else
                                    p = Empty
                                    If Not usehandler1.t1 = 4 Then
                                    'error here
                                    End If
                                    p = usehandler1.index_cursor
                                    Set myobject = usehandler.objref.SearchValue(p, ok)
                                End If
                            Else
                                Set myobject = usehandler.objref.SearchValue(p, ok)
                            End If
                            Set usehandler1 = Nothing
                                If ok Then
                                    Set var(i) = myobject
                                    GoTo cont112233
                                Else
                                    GoTo er112
                                End If
                            Else
                                GoTo er104
                            End If
                            Exit Function
                            End If
                        Else
                            If checktype Then
                                If ihavetype Then
                                    If VarType(var(i)) <> VarType(p) Then
                                        GoTo er109
                                    ElseIf AssignTypeNumeric(p, VarType(var(i))) Then
                                    var(i) = p
                                Else
                                    GoTo er105
                                End If
                            ElseIf AssignTypeNumeric(p, VarType(var(i))) Then
                                var(i) = p
                            Else
                                GoTo er105
                            End If
                        Else
                            var(i) = p
                        End If
                    End If
                ElseIf i = -1 Then
                    If ok Then
                       bstack.SetVarobJvalue what$, p
                    Else
                        bstack.SetVar what$, p
                    End If
                Else
                    globalvar what$, p
                End If
cont112233:
                p = 0#
            ElseIf bs.IsOptional Then
                MyRead = True
                If Not lookOne(rest$, ",") Then
                    If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                        ihavetype = True
                        If Not FastPureLabel(rest$, s$, , , True) = 1 Then
                            If FastSymbol(rest$, "*") Then
                                If FastPureLabel(rest$, ss$, , True) = 1 Then
                                    ' pointer
                                    GoTo cont234356
                                End If
                            End If
                            SyntaxError
                            Exit Function
                        End If
                        ss$ = myUcase(s$, AscW(s$) > 255)
                        Select Case ss$
                        Case "аяихлос", "DECIMAL"
                                If FastSymbol(rest$, "=") Then
                                    If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                                    optlocal = Not useoptionals: useoptionals = True
                                End If
                                p = CDec(p)
                        Case "дипкос", "DOUBLE"
                                If FastSymbol(rest$, "=") Then
                                    If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                                    optlocal = Not useoptionals: useoptionals = True
                                End If
                                p = CDbl(p)
                        Case "апкос", "SINGLE"
                                If FastSymbol(rest$, "=") Then
                                    If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                                    optlocal = Not useoptionals: useoptionals = True
                                End If
                                p = CSng(p)
                        Case "коцийос", "BOOLEAN"
                                If FastSymbol(rest$, "=") Then
                                    If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                                    optlocal = Not useoptionals: useoptionals = True
                                End If
                                p = CBool(p)
                        Case "лайяус", "LONG"
                                If FastSymbol(rest$, "=") Then
                                    If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                                    optlocal = Not useoptionals: useoptionals = True
                                End If
                            p = CLng(p)
                        Case "айеяаиос", "INTEGER"
                                If FastSymbol(rest$, "=") Then
                                    If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                                    optlocal = Not useoptionals: useoptionals = True
                                End If
                            p = CInt(p)
                        Case "коцистийо", "CURRENCY"
                            If FastSymbol(rest$, "=") Then
                                If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                                optlocal = Not useoptionals: useoptionals = True
                            End If
                            p = CCur(p)
                                   
                        Case Else
cont234356:
                        
                            If Not flag2 And GetVar3(bstack, what$, i, , , flag, , , isAglobal, True, ok) Then
                                If isAglobal Then
                                    GoTo er110
                                Else
                                    If MyIsNumeric(var(i)) Then
                                    If IsEnumAs(bstack, s$, p, ok, rest$) Then
                                    If ok Then
                                        Set var(i) = p
            
                                    End If
                                    End If
                                    
                                    ElseIf TypeOf var(i) Is Group Then
                                        If Not ss$ = "олада" Then
                                            If Not ss$ = "GROUP" Then
                                                If var(i).IamApointer Then
                                                    If Not ss$ = "деийтгс" Then
                                                        If Not ss$ = "POINTER" Then
                                                            If Not var(i).link.TypeGroup(ss$) Then
                                                                MyRead = False: MissType: Exit Function
                                                            End If
                                                        End If
                                                    End If
                                                Else
                                                    MyRead = False: MissType: Exit Function
                                                End If
                                            End If
                                        End If
                                    ElseIf TypeOf var(i) Is mHandler Then
                                        Set usehandler = var(i)
                                        If TypeOf usehandler.objref Is mArray Then
                                            If Not ss$ = "пимайас" Then
                                                If Not ss$ = "ARRAY" Then
                                                    MyRead = False: MissType: Exit Function
                                                End If
                                            End If
                                        ElseIf TypeOf usehandler.objref Is FastCollection Then
                                            If Not ss$ = "йатастасг" Then
                                                If Not ss$ = "INVENTORY" Then
                                                    If Not ss$ = "киста" Then
                                                        If Not ss$ = "LIST" Then
                                                            If Not ss$ = "оуяа" Then
                                                                If Not ss$ = "QUEUE" Then
                                                                    MyRead = False: MissType: Exit Function
                                                                End If
                                                            End If
                                                            If Not usehandler.objref.IsQueue Then
                                                                MyRead = False: MissType: Exit Function
                                                            End If
                                                        Else
                                                            GoTo islist
                                                        End If
islist:
                                                        If usehandler.objref.IsQueue Then
                                                            MyRead = False: MissType: Exit Function
                                                            Exit Function
                                                        End If
                                                    End If
                                                End If
                                            End If
                                        ElseIf TypeOf usehandler.objref Is MemBlock Then
                                            If Not ss$ = "диаяхяысг" Then
                                                If Not ss$ = "BUFFER" Then
                                                    MyRead = False: MissType: Exit Function
                                                End If
                                            End If
                                        ElseIf TypeOf usehandler.objref Is Enumeration Then
                                            If usehandler.objref.EnumName = s$ Then
                                                If FastSymbol(rest$, "=") Then
                                                    If FastPureLabel(rest$, ss$, , , True) <> 1 Then
                                                        MyRead = False: SyntaxError: Exit Function
                                                    End If
                                                Else
                                                   MyRead = False: SyntaxError: Exit Function
                                                End If
                                            Else
                                                MyRead = False: MissType: Exit Function
                                            End If
                                            Set usehandler = var(i)
                                        
                                        Else
                                            p = IsLabel(bstack, rest$, (what$)) ' just throw any name
                                        End If
                                        Set usehandler = Nothing
                                    ElseIf TypeOf var(i) Is lambda Then
                                            If Not ss$ = "калда" Then
                                                If Not ss$ = "LAMBDA" Then
                                                    MyRead = False: MissType: Exit Function
                                                End If
                                            End If
                                    ElseIf TypeOf var(i) Is mEvent Then
                                            If Not ss$ = "цецомос" Then
                                                If Not ss$ = "EVENT" Then
                                                    MyRead = False: MissType: Exit Function
                                                End If
                                            End If
                                    ElseIf TypeOf var(i) Is Constant Then
                                        p = var(i)
                                        GoTo checkconstant
                                        
                                    ElseIf IsEnumAs(bstack, (s$), p, ok, rest$) Then
                                    If ok Then
                                    CheckItemType bstack, var(i), vbNullString, ss$, , ok
                                    If s$ = ss$ Then
                                        Set var(i) = p
                                    End If
            
                                    End If
                                       ' just throw any name
                                       
                                    End If
                             GoTo loopcont123
                         End If
                        
                    Else
                                
                                If i = -1 Then
                                If Len(ss$) = 0 Then
                                    FastPureLabel rest$, s$, , , True
                                    ss$ = myUcase(s$, True)
                                End If
                                bstack.ReadVar what$, p
                                Set myobject = p
                                Set usehandler = myobject
                                ff = 0
                                If Not check2(ss$, "деийтгс", "POINTER") Then
                                    If usehandler.t1 = 1 Then
                                        If Not check2(ss$, "йатастасг", "INVENTORY") Then
                                             If Not check2(ss$, "киста", "LIST") Then
                                                If Not check2(ss$, "оуяа", "QUEUE") Then
                                                    WrongObject
                                                    MyRead = False
                                                    Exit Function
                                                ElseIf Not usehandler.objref.IsQueue Then
                                                    WrongObject
                                                    MyRead = False
                                                    Exit Function
                                                End If
                                            ElseIf usehandler.objref.IsQueue Then
                                                WrongObject
                                                MyRead = False
                                                Exit Function
                                            End If
                                        End If
                                    ElseIf usehandler.t1 = 2 Then
                                        If Not check2(ss$, "диаяхяысг", "BUFFER") Then
                                                WrongObject
                                                MyRead = False
                                                Exit Function
                                        End If
                                    ElseIf usehandler.t1 = 3 Then
                                        If Not check2(ss$, "пимайас", "ARRAY") Then
                                            If Not check2(s$, "сыяос", "STACK") Then
                                                WrongObject
                                                MyRead = False
                                                Exit Function
                                            End If
                                        End If
                                    End If
                                ElseIf usehandler.t1 = 4 Then
                                If Not FastType(s$, usehandler.objref.EnumName) Then
                                
                                    p = usehandler.index_cursor
                                    Set usehandler = Nothing
                                    Set myobject = Nothing
                                    GoTo conthereEnum
                                End If
                            End If
                                GoTo loopcont123
                                ElseIf check2(ss$, "олада", "GROUP") Then
                                useoptionals = False
                                ElseIf check2(ss$, "пимайас", "ARRAY") Then
                                useoptionals = False
                                ElseIf check2(ss$, "йатастасг", "INVENTORY") Then
                                useoptionals = False
                                ElseIf check2(ss$, "диаяхяысг", "BUFFER") Then
                                useoptionals = False
                                ElseIf check2(ss$, "калда", "LAMBDA") Then
                                useoptionals = False
                                ElseIf check2(ss$, "цецомос", "EVENT") Then
                                useoptionals = False
                                ElseIf check2(ss$, "киста", "LIST") Then
                                useoptionals = False
                                ElseIf check2(ss$, "оуяа", "QUEUE") Then
                                useoptionals = False
                                ElseIf IsEnumAs(bstack, s$, p, ok, rest$) Then
                                    If ok Then
                                        optlocal = Not useoptionals: useoptionals = True
                                    Else
                                        GoTo err10
                                    End If
                                Else
                               GoTo er110
                            End If
                            
                           ' MyEr "Object is null", "тО АМТИЙЕъЛЕМО ЕъМАИ эТИЛО!"
                            
                           ' MyRead = False
                            'Exit Function
                            
                        End If
                        End Select
                    ElseIf FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                            optlocal = Not useoptionals: useoptionals = True
                        End If
                    Else
                        p = 0#
                    End If
                    If flag2 Then
                        globalvar what$, p
                        If Not useoptionals Then GoTo err100
                    ElseIf GetVar3(bstack, what$, i, , , flag, , , isAglobal, True, ok) Then
                    If isAglobal Then
                        If Not useoptionals Then GoTo err10
                        globalvar what$, p
                    ElseIf ihavetype Then
                        If VarType(p) <> VarType(var(i)) Then
                            If Not AssignTypeNumeric(var(i), VarType(p)) Then
                            MyRead = False
                            Exit Function
                        End If
                    End If
                End If
                ' just skip read for this value
            ElseIf i = -1 Then
                If Not ok Then
                    bstack.SetVar what$, p
                End If
                If Not useoptionals Then GoTo err100
            Else
                If VarType(p) = vbEmpty Then p = 0#
                globalvar what$, p
                 If Not useoptionals Then GoTo err10
            End If
            p = 0#
        Else
            bstack.soros.drop 1
            MissStackNumber
            MyRead = False
            Exit Do
        End If
Case 3
    If bs.IsString(s$) Then
        If FastSymbol(rest$, "=") Then optlocal = Not useoptionals: useoptionals = True: If Not ISSTRINGA(rest$, (s$)) Then GoTo er111
contstrhere:
        MyRead = True
        If flag2 Then
            globalvar what$, s$
        ElseIf GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True, ok) Then
        If isAglobal And Not allowglobals Then
            globalvar what$, s$
        ElseIf MyIsObject(var(i)) Then
                If TypeOf var(i) Is Group Then
                        Set m = bstack.soros
                        Set bstack.Sorosref = New mStiva
                        bstack.soros.PushStr s$
                        NeoCall2 bstack, Left$(what$, Len(what$) - 1) + "." + ChrW(&H1FFF) + ":=()", ok
                        Set bstack.Sorosref = m
                        Set m = Nothing
                ElseIf TypeOf var(i) Is Constant Then
                CantAssignValue
                MyRead = False
                Exit Function
                Else
                    CheckVar var(i), s$
                End If
            Else
                var(i) = s$
            End If
        ElseIf i = -1 Then
            bstack.SetVar what$, s$
        Else
            globalvar what$, s$
        End If
    ElseIf bs.IsOptional Then
    s$ = vbNullString
       If FastSymbol(rest$, "=") Then
        If Not ISSTRINGA(rest$, s$) Then GoTo er111
       optlocal = Not useoptionals: useoptionals = True
       End If
     
       MyRead = True
       
        If flag2 Then
            If Not useoptionals Then GoTo err100
            globalvar what$, s$
        ElseIf GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True) Then
            If isAglobal And Not allowglobals Then
               globalvar what$, s$
                End If
        ElseIf i = -1 Then
      
        Else
            If Not useoptionals Then GoTo err10
            globalvar what$, s$
        End If
    ElseIf bs.IsObjectRef(myobject) Then
        If Typename$(myobject) = "lambda" Then
            If flag2 Then
               i = globalvar(what$, s$)
            ElseIf GetVar3(bstack, what$, i, , , flag) Then
                CheckVar var(i), s$
            Else
                i = globalvar(what$, s$)
            End If
            Set var(i) = myobject
            If ohere$ = vbNullString Then
                GlobalSub what$ + "()", "", , , i
            Else
                GlobalSub ohere$ & "." & bstack.GroupName & what$ + "()", "", , , i
            End If
            MyRead = True
        ElseIf Typename$(myobject) = mgroup Then
        Set bstack.lastobj = myobject
         Set myobject = Nothing
         If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
                    If Not Fast2Varl(rest$, "олада", 5, "GROUP", 5, 5, ff) Then SyntaxError: Exit Function
        
            If Not ProcGroup(100, bstack, what$, Lang) Then
                MyRead = False
                Set bstack.lastobj = Nothing
                Exit Function
            End If
                Set myobject = Nothing
                MyRead = True
           
        Else
                 If Not ProcGroup(100, bstack, what$, Lang) Then
                MyRead = False
                Set bstack.lastobj = Nothing
                Exit Function
            End If
                Set myobject = Nothing
                MyRead = True
        End If
         Else
                MyRead = False
            End If
    Else
         If FastSymbol(rest$, "=") Then
         optlocal = Not useoptionals: useoptionals = True: If Not ISSTRINGA(rest$, s$) Then GoTo er111
         GoTo contstrhere
         
         Else
    bstack.soros.drop 1
        MissStackStr
        MyRead = False
        Exit Do
        End If
    End If
Case 4
    If bs.IsNumber(p) Then
        If Not lookOne(rest$, ",") Then
        
        If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
            If Fast2Varl(rest$, "аяихлос", 7, "DECIMAL", 7, 7, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If

                    p = CDec(p)
            ElseIf Fast2Varl(rest$, "дипкос", 6, "DOUBLE", 6, 6, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If

                p = CDbl(p)
            ElseIf Fast2Varl(rest$, "апкос", 5, "SINGLE", 6, 6, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CSng(p)
            ElseIf Fast2Varl(rest$, "коцийос", 7, "BOOLEAN", 7, 7, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CBool(p)
            ElseIf Fast2Varl(rest$, "лайяус", 6, "LONG", 4, 6, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CLng(p)
            ElseIf Fast2Varl(rest$, "айеяаиос", 8, "INTEGER", 7, 8, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CInt(p)
            ElseIf Fast2Varl(rest$, "коцистийо", 9, "CURRENCY", 8, 9, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CCur(p)
            Else
            GoTo er110
            End If
            ElseIf FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, (p), True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If

    End If
    
        MyRead = True
        If flag2 Then
            globalvar what$, MyRound(p)
        ElseIf GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True, ok) Then
            If isAglobal And Not allowglobals Then
                globalvar what$, MyRound(p)
            Else
                var(i) = MyRound(p)
            End If
        ElseIf i = -1 Then
            bstack.SetVar what$, p
        Else
            globalvar what$, MyRound(p)
        End If
    ElseIf bs.IsOptional Then

        MyRead = True
        If Not lookOne(rest$, ",") Then
        If Fast2VarNoTrim(rest$, "ыс", 2, "AS", 2, 3, ff) Then
            If Fast2Varl(rest$, "аяихлос", 7, "DECIMAL", 7, 7, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                    p = CDec(p)
            ElseIf Fast2Varl(rest$, "дипкос", 6, "DOUBLE", 6, 6, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CDbl(p)
            ElseIf Fast2Varl(rest$, "апкос", 5, "SINGLE", 6, 6, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CSng(p)
            ElseIf Fast2Varl(rest$, "коцийос", 7, "BOOLEAN", 7, 7, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CBool(p)
            ElseIf Fast2Varl(rest$, "лайяус", 6, "LONG", 4, 6, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CLng(p)
            ElseIf Fast2Varl(rest$, "айеяаиос", 8, "INTEGER", 7, 8, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CInt(p)
                
            ElseIf Fast2Varl(rest$, "коцистийо", 9, "CURRENCY", 8, 9, ff) Then
                    If FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
                p = CCur(p)
            Else
            GoTo er110
            Exit Function
            End If
        ElseIf FastSymbol(rest$, "=") Then
                        If Not IsNumberD2(rest$, p, True) Then missNumber: Exit Function
                        optlocal = Not useoptionals: useoptionals = True
                    End If
          Else
            p = 0#
        End If
        
            p = MyRound(p)
        If flag2 Then
         If Not useoptionals Then GoTo err100
            globalvar what$, p
        ElseIf GetVar3(bstack, what$, i, , , flag, , checktype, isAglobal, True) Then
            If isAglobal And Not allowglobals Then
               globalvar what$, p
                End If
        ElseIf i = -1 Then
            
        Else
        If Not useoptionals Then GoTo err100
        If VarType(p) = vbEmpty Then p = 0#
        
            globalvar what$, p
        End If
    Else
        bstack.soros.drop 1
        MissStackNumber
        MyRead = False
        Exit Do
    End If
Case 5, 7
    MyRead = False
    If FastSymbol(rest$, ")") Then
        MyRead = globalArrByPointer(bs, bstack, what$, flag2, allowglobals): If Not MyRead Then SyntaxError: Exit Do
    Else
        If neoGetArray(bstack, what$, pppp) And Not flag2 Then
            If Not NeoGetArrayItem(pppp, bs, what$, it, rest$) Then Exit Do
        Else
            Exit Do
        End If
    If IsOperator(rest$, ".") Then
        If Not pppp.ItemType(it) = mgroup Then
            MyEr "Expected group", "пЕЯъЛЕМА ОЛэДА"
            MyRead = False: Exit Function
        Else
             i = 1
            aheadstatus rest$, False, i
            ss$ = Left$(rest$, i - 1)
            MyRead = SpeedGroup(bstack, pppp, "@READ", ".", ss$, it) <> 0
            Set pppp = Nothing
            rest$ = Mid$(rest$, i)
            GoTo loopcont123
        End If
    End If
    If bs.IsObjectRef(myobject) Then
        If Typename$(myobject) = mgroup Then
            If myobject.IamFloatGroup Then
                Set pppp.item(it) = myobject
                Set myobject = Nothing
                MyRead = True
            Else
                BadGroupHandle
                MyRead = False
                Set myobject = Nothing
                Exit Function
            End If
            GoTo loopcont123
        ElseIf Typename$(myobject) = "lambda" Then
            Set pppp.item(it) = myobject
            Set myobject = Nothing
            MyRead = True
            GoTo loopcont123
        ElseIf Typename$(myobject) = myArray Then
            If myobject.Arr Then
                Set pppp.item(it) = CopyArray(myobject)
            Else
                Set pppp.item(it) = myobject
            End If
            Set myobject = Nothing
            MyRead = True
            GoTo loopcont123
        ElseIf Typename$(myobject) = mHdlr Then
            If myobject.indirect > -0 Then
                Set pppp.item(it) = myobject
            Else
                p = myobject.t1
                If CheckDeepAny(myobject) Then
                    If TypeOf myobject Is mHandler Then
                        Set pppp.item(it) = myobject
                    Else
                        Set usehandler = New mHandler
                        Set pppp.item(it) = usehandler
                        usehandler.t1 = p
                        Set usehandler.objref = myobject
                        Set usehandler = Nothing
                    End If
                    Set myobject = Nothing
                End If
            End If
            MyRead = True
            GoTo loopcont123
        ElseIf Typename$(myobject) = mProp Then
            Set pppp.item(it) = myobject
            Set myobject = Nothing
            MyRead = True
            GoTo loopcont123
        End If
    ElseIf bs.IsOptionalForArray(useoptionals) Then
        ' do nothing
        MyRead = True
    Else
        If Not bs.IsNumber(p) Then
            bstack.soros.drop 1
                MissStackNumber
                MyRead = False
                Exit Do
            ElseIf x1 = 7 Then
                pppp.item(it) = Round(p)
            Else
                pppp.item(it) = p
            End If
        End If
        MyRead = True
    End If
Case 6
    MyRead = False
    If FastSymbol(rest$, ")") Then
        MyRead = globalArrByPointer(bs, bstack, what$, flag2): If Not MyRead Then SyntaxError: Exit Do
    Else
        If neoGetArray(bstack, what$, pppp) And Not flag2 Then
            If Not NeoGetArrayItem(pppp, bs, what$, it, rest$) Then Exit Do
        Else
            Exit Do
        End If
        If Not bs.IsString(s$) Then
            If bs.IsObjectRef(myobject) Then
                If Typename$(myobject) = "lambda" Then
                    Set pppp.item(it) = myobject
                    Set myobject = Nothing
                ElseIf Typename$(myobject) = mgroup Then
                    Set pppp.item(it) = myobject
                    Set myobject = Nothing

            ElseIf Typename$(myobject) = myArray Then
                    If myobject.Arr Then
                        Set pppp.item(it) = CopyArray(myobject)
                    Else
                        Set pppp.item(it) = myobject
                    End If
                    Set myobject = Nothing
                ElseIf Typename$(myobject) = mHdlr Then
                    If myobject.indirect > -0 Then
                    Set pppp.item(it) = myobject
                    Else
                    p = myobject.t1
                    If CheckDeepAny(myobject) Then
                    If TypeOf myobject Is mHandler Then
                    Set pppp.item(it) = myobject
                    Else
                        Set usehandler = New mHandler
                        Set pppp.item(it) = usehandler
                        usehandler.t1 = p
                        Set usehandler.objref = myobject
                        Set usehandler = Nothing
                    End If
                    Set myobject = Nothing
                    End If
                    
                    End If
              ElseIf Typename$(myobject) = mProp Then
                    Set pppp.item(it) = myobject
                    Set myobject = Nothing
                Else
                    MissStackStr
                    Exit Do
                End If
          ElseIf bs.IsOptionalForArray(useoptionals) Then
            MyRead = True
            Else
            bstack.soros.drop 1
                MissStackStr
                Exit Do
            End If

        Else
            If Not MyIsObject(pppp.item(it)) Then
                pppp.item(it) = s$
            ElseIf pppp.ItemType(it) = mgroup Then
            ' do something
            Else
                Set pppp.item(it) = New Document
                CheckVar pppp.item(it), s$
            End If
        End If
        MyRead = True
    End If

End Select
End If
loopcont123:
If MaybeIsSymbol(rest$, "@&!#~") Then SyntaxError: MyRead = False
If optlocal Then useoptionals = False

Loop Until Not FastSymbol(rest$, ",")
Exit Function
err10:
            MyEr "Variable " & what$ & " can't initialized", "г ЛЕТАБКГТч " & what$ & " ДЕМ АЯВИЙОПОИХГЙЕ"
            MyRead = False
            Exit Function
err100:
            MyEr "Parameter is not optional", "г ПАЯэЛЕТЯОР ЕъМАИ АПАЯАъТГТГ"
            MyRead = False
            Exit Function
er103:
            MyEr "Wrong object type", "кэХОР ТЩПОР АМТИЙЕИЛщМОУ"
            MyRead = False
            Exit Function
er104:
            MyEr "Can't assign value to object", "дЕМ ЛПОЯЧ МА ДЧСЫ ТИЛч СЕ АМТИЙЕъЛЕМО"
            MyRead = False
            Exit Function
er105:
            MyEr "Cant' Assign number", "дЕМ ЛПОЯЧ МА ХщСЫ ТИЛч ЙАТэ ТО ДИэБАСЛА ТИЛЧМ"
            MyRead = False
            Exit Function
er106:
            MyEr "No function definition founded", "дЕМ БЯщХГЙЕ ОЯИСЛЭР СУМэЯТГСГР"
            MyRead = False
            Exit Function
er107:
            MyEr "Syntax error, use )", "сУМТАЙТИЙЭ КэХОР БэКЕ )"
            MyRead = False
            Exit Function
er108:
            MyEr "Try other array name", "дОЙъЛАСЕ эККО ЭМОЛА ПъМАЙА"
            MyRead = False
            Exit Function
er109:
            MyEr "Cant' change type of variable", "дЕМ ЛПОЯЧ МА АККэНЫ ТЩПО ЛЕТАБКГТчР"
            MyRead = False
            Exit Function
er110:
            MyEr "need a type after as", "ВЯЕИэФОЛАИ щМА ТЩПО ЛЕТэ ТГМ ЫР"
            MyRead = False
            Exit Function
er111:
            MyEr "Missing String literal", "дЕМ БЯчЙА СТАХЕЯч АКЖАЯИХЛГТИЙч"
            MyRead = False
er112:
            MyEr "Wrong Enumeration type", "кэХОР ТЩПОР АПАЯИХЛГТч"
            MyRead = False
            Exit Function
er113:
            MyEr "Expected Group of type " + s$, "пЕЯъЛЕМА оЛэДА ТЩПОУ " + s$
            MyRead = False
            Exit Function
End Function
Function AssignTypeNumeric(v, i As Long) As Boolean
If VarType(v) = i Then AssignTypeNumeric = True: Exit Function
On Error GoTo there
If VarType(v) = vbString Then v = Format$(v)
Select Case i
Case vbBoolean
v = CBool(v)
Case vbCurrency
v = CCur(v)
Case vbDecimal
v = CDec(v)
Case vbLong
v = CLng(v)
Case vbSingle
v = CSng(v)
Case vbInteger
v = CInt(v)
Case Else
v = CDbl(v)
End Select
AssignTypeNumeric = True
Exit Function
there:
If Err = 6 Then
Err.Clear
OverflowLong i = vbInteger
Exit Function
End If
MyEr "Can't convert value", "дЕМ ЛПОЯЧ МА ЛЕТАТЯщЬЫ ТГМ ТИЛч"
End Function
Function AssignTypeNumeric2(v, i As Long) As Boolean
If VarType(v) = i Then AssignTypeNumeric2 = True: Exit Function
On Error GoTo there
If VarType(v) = vbString Then v = Format$(v)
Select Case i
Case vbBoolean
v = CBool(v)
Case vbCurrency
v = CCur(v)
Case vbDecimal
v = CDec(v)
Case vbLong
v = CLng(v)
Case vbSingle
v = CSng(v)
Case vbInteger
v = CInt(v)
Case Else
v = CDbl(v)
End Select
AssignTypeNumeric2 = True
Exit Function
there:
End Function
Function MyPush(bstack As basetask, rest$) As Boolean
Dim s$, p As Variant, usehandler As mHandler
MyPush = True
Do
     If FastSymbol(rest$, "!") Then
                If IsExp(bstack, rest$, p) Then
                 If bstack.lastobj Is Nothing Then
                   bstack.soros.PushValLong CLng(p)
                ElseIf TypeOf bstack.lastobj Is mHandler Then
                    Set usehandler = bstack.lastobj
                    If TypeOf usehandler.objref Is mStiva Then
                        bstack.soros.MergeTop usehandler.objref
                    ElseIf TypeOf usehandler.objref Is mArray Then
                     bstack.soros.MergeTopCopyArray usehandler.objref
                        Else
                            MyPush = False
                            MyEr "Expected Stack Object or Array after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО сЫЯЭ ч ПъМАЙА ЛЕТэ ТО !"
                            Set bstack.lastobj = Nothing
                            Exit Function
                  
                    End If
                    Set bstack.lastobj = Nothing
                    Set usehandler = Nothing
                ElseIf TypeOf bstack.lastobj Is mArray Then
                    bstack.soros.MergeTopCopyArray bstack.lastobj
                    Set bstack.lastobj = Nothing
                End If
                End If
                ElseIf IsExp(bstack, rest$, p) Then
                If bstack.lastobj Is Nothing Then
                        bstack.soros.PushVal p
                Else
                    If TypeOf bstack.lastobj Is mStiva Then
                    Set bstack.Sorosref = bstack.lastobj
                    ElseIf TypeOf bstack.lastobj Is VarItem Then
                        bstack.soros.PushObjVarItem bstack.lastobj
                    Else
                        If TypeOf bstack.lastobj Is Group Then
                            bstack.lastobj.ToDelete = False
                        End If
                        bstack.soros.PushObj bstack.lastobj
                        Set bstack.lastpointer = Nothing
                    End If
                         Set bstack.lastobj = Nothing
                         
                End If
        ElseIf IsStrExp(bstack, rest$, s$, Len(bstack.tmpstr) = 0) Then
                If bstack.lastobj Is Nothing Then
                        bstack.soros.PushStr s$
                Else
                        If TypeOf bstack.lastobj Is Group Then
                                bstack.lastobj.ToDelete = False
                        End If
                        bstack.soros.PushObj bstack.lastobj
                         Set bstack.lastobj = Nothing
                           Set bstack.lastpointer = Nothing
                End If
        Else
        MyPush = LastErNum1 = 0
                Exit Do
        End If
        If Not FastSymbol(rest$, ",") Then Exit Do
Loop
End Function
Function MyData(bstack As basetask, rest$) As Boolean
Dim s$, p As Variant, usehandler As mHandler ', vvl As Variant, photo As Object
MyData = True
Do
    If FastSymbol(rest$, "!") Then
                If IsExp(bstack, rest$, p) Then
                    If bstack.lastobj Is Nothing Then
                        bstack.soros.DataValLong p
                    ElseIf TypeOf bstack.lastobj Is mHandler Then
                    Set usehandler = bstack.lastobj
                        If TypeOf usehandler.objref Is mStiva Then
                            bstack.soros.MergeBottom usehandler.objref
                        ElseIf TypeOf usehandler.objref Is mArray Then
                            bstack.soros.MergeBottomCopyArray usehandler.objref
                        Else
                            MyData = False
                            MyEr "Expected Stack Object or Array after !", "пЕЯъЛЕМА АМТИЙЕъЛЕМО сЫЯЭ ч ПъМАЙА ЛЕТэ ТО !"
                            Set bstack.lastobj = Nothing
                            Exit Function
                        End If
                        Set bstack.lastobj = Nothing
                        Set usehandler = Nothing
                    ElseIf TypeOf bstack.lastobj Is mArray Then
                        bstack.soros.MergeBottomCopyArray bstack.lastobj
                        Set bstack.lastobj = Nothing
                    End If
                        
                     End If
                ElseIf IsExp(bstack, rest$, p) Then
                  If bstack.lastobj Is Nothing Then
                      bstack.soros.DataVal p
                 Else
                   If TypeOf bstack.lastobj Is mStiva Then
                   Set bstack.Sorosref = bstack.lastobj
                   ElseIf TypeOf bstack.lastobj Is VarItem Then
                    bstack.soros.DataObjVaritem bstack.lastobj
                      Else
                      If TypeOf bstack.lastobj Is Group Then
                            bstack.lastobj.ToDelete = False
                        End If
                      bstack.soros.DataObj bstack.lastobj
                    Set bstack.lastpointer = Nothing
                    End If
                      Set bstack.lastobj = Nothing
                End If
        ElseIf IsStrExp(bstack, rest$, s$, Len(bstack.tmpstr) = 0) Then
                If bstack.lastobj Is Nothing Then
                        bstack.soros.DataStr s$
                Else
                If TypeOf bstack.lastobj Is Group Then
                            bstack.lastobj.ToDelete = False
                        End If
                        bstack.soros.DataObj bstack.lastobj
                        Set bstack.lastobj = Nothing
                          Set bstack.lastpointer = Nothing
                End If
        Else
                MyData = LastErNum1 = 0
                Exit Do
        End If
        If Not FastSymbol(rest$, ",") Then Exit Do
        
Loop
End Function
Function MyClear(bstack As basetask, rest$) As Boolean
Dim curbstack As basetask, i As Long, y1 As Long, what$, it As Long, pppp As mArray, myobject As mStiva
Dim usehandler As mHandler
'Dim bs As basetask
MyClear = True


Do
y1 = Abs(IsLabel(bstack, rest$, what$))


If y1 = 3 Then
      If GetVar(bstack, what$, i) Then
        If Typename(var(i)) = doc Then
        Set var(i) = New Document
        var(i).lcid = LCID_DEF
        var(i).textDoc = vbNullString
        Else
        var(i) = vbNullString
        End If
       Else
        globalvar what$, ""
        
       End If
ElseIf y1 < 5 And y1 > 0 Then
      If GetVar(bstack, what$, i) Then
        If MyIsObject(var(i)) Then
        ' PUT ZERO TO VARIABLES INSIDE GROUP
       If Typename(var(i)) = "lambda" Then
       Set var(i) = Nothing
       Dim ok As Boolean
       var(i) = CLng(0)
       ElseIf Typename(var(i)) = mgroup Then
        If Not var(i).IamCleared Then
        CallClear bstack, what$, var(i)

        
        
        If var(i).IamApointer Then
        Set var(i) = New Group
        
        Else
       var(i).ResetGroup
       End If
        End If
       ElseIf Typename(var(i)) = mHdlr Then
       Set usehandler = var(i)
       If usehandler.t1 = 1 Then
       If usehandler.ReadOnly Then
            ReadOnly
            MyClear = False
            Exit Function
        End If
        If usehandler.UseIterator Then
            ReadOnly
            MyClear = False
            Exit Function
        End If
            If usehandler.objref.IsQueue Then
            Set var(i) = Nothing
            MakeitObjectInventory var(i), True
            Else
            Set var(i) = Nothing
            MakeitObjectInventory var(i)
            End If
           
       ElseIf usehandler.t1 = 2 Then
       
        Set usehandler = New mHandler
        Set var(i) = usehandler
         usehandler.t1 = 2
            Set usehandler.objref = New MemBlock
       Else
       If usehandler.UseIterator Then
       Set var(i) = Nothing
       var(i) = CLng(0)
       Else

       If Typename$(usehandler.objref) = myArray Then
            Set usehandler.objref = New mArray
       ElseIf Typename$(usehandler.objref) = "mStiva" Then
                Set usehandler.objref = New mStiva
       
       End If
       End If
       End If
       Else
       'If Typename$(var(i)) = mProp Then
      ' var(i) = Empty
      ' Else
         var(i) = Empty
       '  End If
       End If
        Else
        If VarType(var(i)) = vbLong Then
        var(i) = CLng(0)
        Else
            var(i) = 0#
            End If
        End If
        
       Else
        globalvar what$, it
       End If
ElseIf y1 = 5 Or y1 = 7 Then
  If neoGetArray(bstack, what$, pppp) Then
  If Not pppp.Arr Then NotArray: MyClear = False: Exit Function
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then MyClear = False: Exit Function
                        If pppp.ItemType(it) = mgroup Then
                            Set pppp.item(it) = Nothing
                            EmptyVariantArrayItem pppp, it


                         ElseIf pppp.ItemType(it) = "lambda" Then
                         Set pppp.item(it) = Nothing
                         EmptyVariantArrayItem pppp, it
                         Else
                         SyntaxError
                         MyClear = False
                         End If
                 
       Else
       SyntaxError
       MyClear = False
       End If
ElseIf y1 = 6 Then
        If neoGetArray(bstack, what$, pppp) Then
        If Not pppp.Arr Then NotArray: MyClear = False: Exit Function
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then MyClear = False: Exit Function
                         If pppp.ItemType(it) = mgroup Then
                            Set pppp.item(it) = Nothing
                            EmptyVariantArrayItem pppp, it
                         ElseIf pppp.ItemType(it) = doc Then
                             Set pppp.item(it) = New Document
                             pppp.item(it).textDoc = vbNullString
                         ElseIf pppp.ItemType(it) = "lambda" Then
                            Set pppp.item(it) = Nothing
                            EmptyVariantArrayItem pppp, it
                         Else
                         pppp.item(it) = vbNullString
                         End If
                 
       Else
       SyntaxError
       MyClear = False
       End If
ElseIf y1 > 0 Then
  SyntaxError
       MyClear = False
Else
Form1.List1.Clear
If bstack.IamThread Then
If Not bstack.StaticCollection Is Nothing Then
Set bstack.StaticCollection = Nothing
 End If
ElseIf bstack.IamAnEvent Then

 
If Not bstack.StaticCollection Is Nothing Then
If Not bstack.Parent Is Nothing Then
    If Not bstack.Parent.StaticCollection Is Nothing Then
    If bstack.Parent.StaticCollection.ExistKey("%_" + here$) Then
            bstack.Parent.StaticCollection.RemoveWithNoFind
    End If
    End If
    End If
    Set bstack.StaticCollection = Nothing
  
    Else
 MyEr "Only static variables can clear in an event", "лЭМО СТАТИЙщР ЛПОЯЧ МА СБчСЫ СЕ щМА ЦЕЦОМЭР"
End If
Else
bstack.clearbasket

Set curbstack = bstack

again1234:

 If curbstack.IamChild Then
 If curbstack.IamThread Then Set curbstack = Nothing: Exit Function

 If Not curbstack.Parent.IamChild And Not curbstack.Parent.IamAnEvent Then
        Set EventStaticCollection = New FastCollection
 End If
 If curbstack.IamAnEvent Then Set curbstack = Nothing: Exit Function
 With curbstack
   'Set .StaticCollection = Nothing
      If .SkipClear > 0 Then Set curbstack = Nothing: Exit Function
      
      var2used = curbstack.Vars
      varhash.ReduceHash curbstack.Vname, var()
      
   End With

'Set curbstack = curbstack.Parent
'If here$ = vbNullString Then GoTo again1234
'If curbstack.SkipClear = 0 Then
'var2used = curbstack.Vars
'varhash.ReduceHash curbstack.Vname, var()
'End If
Exit Function
End If
GarbageFlush
Set curbstack = Nothing
Set EventStaticCollection = New FastCollection
Set bstack.StaticCollection = Nothing

varhash.ReduceHash 0, var()
varhash.BigSize 3000
var2used = 0
ReDim var(3000) As Variant

Set curbstack = bstack
again12345:
 If curbstack.IamChild Then
            With curbstack
                 If .Vars = 0 Then Set curbstack = Nothing: Exit Function
                     .Vars = 0
   
            End With
            Set curbstack = curbstack.Parent
            GoTo again12345
End If
Set curbstack = Nothing
End If
Exit Do
End If
If Not MyClear Then Exit Do
Loop Until Not FastSymbol(rest$, ",")
End Function
Function MyMethod(bstack As basetask, rest$, Lang As Long) As Boolean

Dim i As Long, s$, pppp As mArray, pa$, ok As Boolean, R As Variant
i = Abs(IsLabel(bstack, rest$, s$))
MyMethod = True
ok = True
If i = 1 Or i = 3 Then
 If GetVar(bstack, s$, i) Then
        If MyIsObject(var(i)) Then
            If var(i) Is Nothing Then
                MissingObj
            Else
                IsSymbol3 rest$, ","
                If IsStrExp(bstack, rest$, pa$) Then
     
              ProcMethod bstack, var(), i, pa$, rest$, Lang, ok
          MyMethod = ((Err = 0) And ok)
          Err.Clear
          
                End If
            End If
        Else
            MyMethod = False
            MissingObjRef
        End If
        Exit Function
        Else
  Nosuchvariable s$
 End If
 ElseIf i = 5 Or i = 6 Then
  If neoGetArray(bstack, s$, pppp) Then
again11:
    If NeoGetArrayItem(pppp, bstack, s$, i, rest$) Then
    If FastSymbol(rest$, "(") Then
    If MyIsObject(pppp.item(i)) Then
    Dim pppp1 As mArray
    If TypeOf pppp.itemObject(i) Is mArray Then
        Set pppp = pppp.item(i)
    Else
        pppp1.Arr = False
        Set pppp1.GroupRef = pppp.item(i)
        Set pppp = pppp1
        Set pppp1 = Nothing
    End If
    GoTo again11
    End If
    End If
             IsSymbol3 rest$, ","
            If IsStrExp(bstack, rest$, pa$) Then
                ProcMethodArray bstack, pppp, i, pa$, rest$, Lang, MyMethod
              End If
     End If
  Else
   MyMethod = False
      MissingObj
  End If

End If

End Function
Function GetEventFromArray(basestack As basetask, rest$, what$) As Boolean
Dim pppp As mArray, x1 As Long
 If neoGetArray(basestack, what$, pppp) Then
  If Not NeoGetArrayItem(pppp, basestack, what$, x1, rest$, True) Then Exit Function
    If MyIsObject(pppp.item(x1)) Then
    GetEventFromArray = True
    Set basestack.lastobj = pppp.item(x1)
    Exit Function
    Else
    MyEr "Not an Event object", "╪ВИ щМА АМТИЙЕъЛЕМО цЕЦОМЭР"
 Exit Function
    End If
 End If
End Function
Function myEvent(basestack As basetask, rest$, Lang As Long, Optional alocal As Boolean)
Dim x1 As Long, what$, i As Long, s$
myEvent = True
 x1 = Abs(IsLabel(basestack, rest$, what$))
 If x1 <> 1 Then
 If x1 = 5 Then
 Dim pppp As mArray
 If neoGetArray(basestack, what$, pppp) Then
  If Not NeoGetArrayItem(pppp, basestack, what$, x1, rest$, True) Then Exit Function
    If MyIsObject(pppp.item(x1)) Then
    Set basestack.lastobj = pppp.item(x1)
    myEvent = ProcEvent(basestack, rest$, Lang, -1)
    Exit Function
    Else
    MyEr "Not an Event object", "╪ВИ щМА АМТИЙЕъЛЕМО цЕЦОМЭР"
    myEvent = False: Exit Function
    End If
 End If
 Else
    myEvent = False: Exit Function
 End If
 End If
 If basestack.priveflag Then what$ = ChrW(&HFFBF) + what$
 If alocal Then
 i = globalvar(basestack.GroupName & what$, s$)
 MakeitObjectEvent var(i)
 ElseIf GetlocalVar(basestack.GroupName & what$, i) Then
 ' we found it
  ElseIf GetVar(basestack, basestack.GroupName & what$, i) Then
  ' we found it
  Else
   i = globalvar(basestack.GroupName & what$, s$)
   MakeitObjectEvent var(i)
 End If
 myEvent = ProcEvent(basestack, rest$, Lang, i)
End Function
Function MyReport(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, prive As Long, X As Double, Y As Double, y1 As Long, x1 As Long, it As Long
Dim s$, i As Long, pa$, sX As Double
MyReport = False
prive = GetCode(bstack.Owner)
If FastSymbol(rest$, "!") Then
    If IsExp(bstack, rest$, p, , True) Then
        ReportTabWidth = Abs(p)
        players(prive).ReportTab = ReportTabWidth
        MyReport = True
    End If
    Exit Function
End If
If IsExp(bstack, rest$, p) Then
    If Not FastSymbol(rest$, ",") Then MissPar:: Exit Function
Else
    p = 0
End If
If IsStrExp(bstack, rest$, s$) Then
    X = bstack.Owner.Width
    If lookOne(rest$, ";") Then SyntaxError: Exit Function
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, X) Then: Exit Function
        With players(prive)
            If X <= .mx Then
                X = X * .Xt - 2 * dv15
                bstack.Owner.currentX = bstack.Owner.currentX + dv15
            End If
        End With
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(bstack, rest$, Y) Then: Exit Function
        y1 = Y - 1
        If IsLabelSymbolNew(rest$, "цяаллг", "LINE", Lang) Then
            If Not IsExp(bstack, rest$, sX) Then Exit Function
            x1 = sX - 1
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), x1, , , True
                bstack.tmpstr = "@READ " + Left$(rest$, 1)
                BackPort rest$
                If Not executeblock(i, bstack, rest$, True, False, , True) Then
                ' error ??
                End If
            Else
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), x1
            End If
        Else
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), , it, , True
                bstack.tmpstr = "@READ " + Left$(rest$, 1)
                BackPort rest$
                If Not executeblock(i, bstack, rest$, True, False, , True) Then
                ' error ?
                End If
            Else
                wwPlain bstack, players(prive), s$, CLng(X), y1, , , CLng(p), , it
            End If
        End If
        players(prive).LastReportLines = CDbl(it)
    Else
        wwPlain bstack, players(prive), s$, CLng(X), 100000, True, , CLng(p), , it
        players(prive).LastReportLines = -1
    End If
    MyReport = True
Else
    If LastErNum <> 0 Then LastErNum = 0: Exit Function      'ifier=true
End If

End Function
Function MyInput(bstack As basetask, rest$, Lang As Long) As Boolean
Dim i As Long, p As Variant, pp As Variant, s$, ss$, what$, f As Long, x1 As Long, Y As Double, X As Double
Dim frm$, par As Boolean, pppp As mArray, prive As Long, it As Long, w$, mystack As mStiva
If IsLabelSymbolNew(rest$, "ле", "WITH", Lang) Then
    If IsStrExp(bstack, rest$, s$) Then
        inpcsvsep$ = Left$(s$, 1)
        If FastSymbol(rest$, ",") Then If IsStrExp(bstack, rest$, s$) Then inpcsvDec$ = Left$(s$, 1): MyInput = True
        inpcsvuseescape = False
        If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then inpcsvuseescape = CBool(p): MyInput = True
         If FastSymbol(rest$, ",") Then MyInput = False: If IsExp(bstack, rest$, p) Then inpcleanstrings = CBool(p): MyInput = True
    End If
    Exit Function
End If
Fkey = 0
If inpcsvsep$ = vbNullString Then inpcsvsep$ = ","
If inpcsvDec$ = vbNullString Then inpcsvDec$ = "."

MyInput = True
With players(GetCode(bstack.Owner))
If IsLabelSymbolNew(rest$, "текос", "END", Lang) Then
    
    If Not NOEDIT Then
    
    NOEDIT = True
    Else
    If QRY Then QRY = False  ''INK$ = Chr$(13) '
    If GFQRY Then GFQRY = False
    End If
    Exit Function
End If
prive = GetCode(bstack.Owner)
If Not releasemouse Then If Not Form1.Visible Then newshow Basestack1
MyInput = False '*************
rest$ = NLtrim$(rest$)

If FastSymbol(rest$, "!") Then
        x1 = 0
        frm$ = vbNullString
        If bstack.toprinter = True Then oxiforPrinter:   Exit Function
        If prive > 32 Then
            If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
            If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
            If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
        End If
        
        f = Abs(IsLabel(bstack, rest$, what$))
        Select Case f
        Case 1, 4
                     If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                     If Not IsExp(bstack, rest$, p) Then p = .mx
                     X = p
                     
                             Y = 0
                    If FastSymbol(rest$, ",") Then
                     If Not IsExp(bstack, rest$, p) Then x1 = 29
                     x1 = p
                     If x1 < 1 Or x1 > 29 Then x1 = 29
                     Else
                     x1 = 29
                    End If
                    
                     Form1.ShadowMarks = True
                    
                    If Y < 1 And x1 = 0 Then Y = 1
                     If GetVar(bstack, what$, i) Then
                     
                     s$ = LTrim$(Str(var(i)))
                     If VarType(var(i)) = vbLong Or VarType(var(i)) = vbInteger Then f = 4
                     If VarType(var(i)) = vbBoolean Then f = 4: x1 = 1: s$ = LTrim$(Str(Abs(CLng(var(i)))))
                       If Not NoUseDec Then
                                If OverideDec Then
                                    s$ = Replace(s$, ".", NowDec$)
                                 End If
                            Else
                                s$ = Replace(s$, ".", QueryDecString)
                            End If
       
                     p = var(i)
                     Do
                     s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 4)
                     Loop Until ValidNum(s$, True, f = 4, VarType(p))
                            If Not NoUseDec Then
                                If OverideDec Then
                                   s$ = Replace(s$, NowDec$, ".")
                                 End If
                            Else
                                s$ = Replace(s$, QueryDecString, ".")
                            End If
                            
                               ValidNumberOnly s$, p, f = 4
                             Select Case VarType(var(i))
                             Case vbInteger
                             var(i) = CInt(p)
                             Case vbLong
                             var(i) = CLng(p)
                             Case vbSingle
                             var(i) = CSng(p)
                             Case vbCurrency
                             var(i) = CCur(p)
                             Case vbDouble
                             var(i) = CDbl(p)
                             Case vbDecimal
                             var(i) = CDec(p)
                             Case vbBoolean
                             var(i) = CBool(p)
                             Case Else
                             var(i) = p
                             End Select
                               
                               
                             
                             
                     Else
                     If i = -1 Then
                     If f = 4 Then
                      s$ = LTrim$(Str(ReadVarInt(bstack, what$)))
                     Else
                     
                      s$ = LTrim$(Str(ReadVarDouble(bstack, what$)))
                      End If
                      p = ReadVarDouble(bstack, what$)
                      If VarType(p) = vbLong Or VarType(p) = vbInteger Then f = 4
                                       If Not NoUseDec Then
                                If OverideDec Then
                                    s$ = Replace(s$, ".", NowDec$)
                                 End If
                            Else
                                s$ = Replace(s$, ".", QueryDecString)
                            End If
                      Do
                     s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 4)
                     Loop Until ValidNum(s$, True, f = 4)
                           If Not NoUseDec Then
                                If OverideDec Then
                                   s$ = Replace(s$, NowDec$, ".")
                                 End If
                            Else
                                s$ = Replace(s$, QueryDecString, ".")
                            End If
                            If VarType(p) = vbLong Or VarType(p) = vbInteger Then
                            ValidNumberOnly s$, p, f = 4
                            On Error Resume Next
                            p = CLng(p)
                            If Err.Number = 6 Then
                                    OverflowLong
                                    MyInput = False
                               End If
                            Else
                              ValidNumberOnly s$, p, f = 4
                              End If
                             bstack.SetVar what$, p
                             
                     Else
                     s$ = vbNullString
                      Do
                     s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 4)
                     Loop Until ValidNum(s$, True, f = 4)
                           If Not NoUseDec Then
                                If OverideDec Then
                                   s$ = Replace(s$, NowDec$, ".")
                                 End If
                            Else
                                s$ = Replace(s$, QueryDecString, ".")
                            End If
                              ValidNumberOnly s$, p, f = 4
                             globalvar what$, (p)
                     End If
                     End If
                     MyInput = True
                     Form1.ShadowMarks = False
        Case 3
                     If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                     If Not IsExp(bstack, rest$, p) Then p = .mx
                     X = p
                     If Not FastSymbol(rest$, ",") Then
                             Y = 0
                             x1 = 50
                             If IsLabelSymbolNew(rest$, "лгйос", "LEN", Lang, , , , False) Then
                                     If FastSymbol(rest$, "=") Then
                                             If IsExp(bstack, rest$, p) Then
                                                     x1 = Abs(MyRound(p))
                                             Else
                                                     MissNumExpr
                                                     Exit Function
                                             End If
                                     Else
                                             MissSymbolMyEr "="
                                             Exit Function
                                     End If
                             End If
                             p = -1&
                     ElseIf Not IsExp(bstack, rest$, Y) Then
                             MissPar
                             Exit Function
                     Else
                            p = -1&
                            If FastSymbol(rest$, ",") Then
                                If FastSymbol(rest$, ",") Then
comehere:
                                    If Not IsExp(bstack, rest$, p, , True) Then MissPar: Exit Function
                                    p = MyRound(p)
                                Else
                                    If Not IsStrExp(bstack, rest$, frm$) Then MissPar: Exit Function
                                    If FastSymbol(rest$, ",") Then GoTo comehere
                                End If
                            Else
                                If Len(var(i)) > 0 Then x1 = -Len(var(i))
                            End If
                           
                     End If
                     Form1.ShadowMarks = True
                     Form1.TEXT1.TabWidth = 8
                     Form1.TabControl = 8
                     If Y < 1 And x1 = 0 Then Y = 1
                     If GetVar(bstack, what$, i) Then
                             var(i) = iText(bstack, var(i), (X), (Y), frm$, x1, , , p)
                     Else
                     If i = -1 Then

                     bstack.SetVar what$, iText(bstack, ReadVarStr(bstack, what$), (X), (Y), frm$, x1, , , p)
                     Else
                             globalvar what$, iText(bstack, "", (X), (Y), frm$, x1, , , p)
                     End If
                     End If
                     MyInput = True
                     Form1.ShadowMarks = False
        Case 5, 7 ' NUMBER IN ARRAY
                            If neoGetArray(bstack, what$, pppp) Then
                            If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Exit Function
                    Else
                        MyEr "No such Array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                            Exit Function
                    End If
                    If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                    If Not IsExp(bstack, rest$, p) Then p = .mx
                    X = p
                     Y = 0
                     
                    If FastSymbol(rest$, ",") Then
                     If Not IsExp(bstack, rest$, p) Then x1 = 29
                     x1 = p
                     If x1 < 1 Or x1 > 29 Then x1 = 29
                     Else
                     x1 = 29
                    End If
                Form1.ShadowMarks = True
                If Y < 1 And x1 = 0 Then Y = 1
                    s$ = LTrim$(Str(pppp.itemnumeric(it)))
                    p = pppp.itemnumeric(it)
                    If VarType(p) = vbLong Or VarType(p) = vbInteger Then f = 7
                    If VarType(var(i)) = vbBoolean Then f = 7: x1 = 1: s$ = LTrim$(Str(Abs(CLng(pppp.itemnumeric(it)))))
                    Do
                        s$ = iText(bstack, s$, (X), (Y), "", x1, True, f = 7)
                    Loop Until ValidNum(s$, True, f = 7, VarType(p))
                        If Not NoUseDec Then
                            If OverideDec Then
                                s$ = Replace(s$, NowDec$, ".")
                            End If
                        Else
                            s$ = Replace(s$, QueryDecString, ".")
                        End If
                        ValidNumberOnly s$, p, f = 7
                        Select Case VarType(pppp.item(it))
                        Case vbInteger
                            pppp.item(it) = CInt(p)
                        Case vbLong
                            pppp.item(it) = CLng(p)
                        Case vbSingle
                            pppp.item(it) = CSng(p)
                        Case vbCurrency
                            pppp.item(it) = CCur(p)
                        Case vbDouble
                            pppp.item(it) = CDbl(p)
                        Case vbDecimal
                            pppp.item(it) = CDec(p)
                        Case vbBoolean
                            pppp.item(it) = CBool(p)
                        Case Else
                            pppp.item(it) = p
                        End Select
           
                        Form1.ShadowMarks = False
                        MyInput = True
                Case 6
                    If neoGetArray(bstack, what$, pppp) Then
                        If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then
                            Exit Function
                        End If
                    Else
                        MyEr "No such Array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                        Exit Function
                    End If
                    If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
                    If Not IsExp(bstack, rest$, p) Then p = .mx
                    X = p
                    If Not FastSymbol(rest$, ",") Then
                        Y = 0
                        x1 = 50
                        If IsLabelSymbolNew(rest$, "лгйос", "LEN", Lang, , , , False) Then
                                If FastSymbol(rest$, "=") Then
                                        If IsExp(bstack, rest$, p) Then
                                            x1 = Abs(MyRound(p))
                                        Else
                                            MissNumExpr
                                            Exit Function
                                        End If
                                Else
                                        MissSymbolMyEr "="
                                        Exit Function
                                End If
                        ElseIf Not IsExp(bstack, rest$, Y) Then
                                MissPar
                                Exit Function
                        Else
                                If FastSymbol(rest$, ",") Then
                                        If Not IsStrExp(bstack, rest$, frm$) Then MissPar: Exit Function
                                        Else
                            If Len(CStr(pppp.item(it))) > 0 Then x1 = -Len(CStr(pppp.item(it)))
                        
                                End If
                        End If
                End If
                Form1.ShadowMarks = True
                    Form1.TEXT1.TabWidth = 8
                     Form1.TabControl = 8
                If Y < 1 And x1 = 0 Then Y = 1
                s$ = iText(bstack, LTrim$(Str(pppp.item(it))), (X), (Y), frm$, x1)
                Form1.ShadowMarks = False
                If pppp.ItemType(it) = doc Then
                        Set pppp.item(it) = New Document
                        If s$ <> "" Then pppp.item(it).textDoc = s$
                Else
                        pppp.item(it) = s$
                End If
                MyInput = True
        End Select
        Exit Function
                    '********************************************
ElseIf FastSymbol(rest$, "#") Then
    If Not IsExp(bstack, rest$, p) Then MissPar: Exit Function
    If Not FastSymbol(rest$, ",") Then MissPar: Exit Function
    f = CLng(p)
    If Fkind(f) = FnoUse Or Fkind(f) = Foutput Or Fkind(f) = Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": MyInput = False: Exit Function
    par = True
Else
    If bstack.toprinter = True Then oxiforPrinter:   Exit Function
    If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
    End If
        If ISSTRINGA(rest$, frm$) Then
            If Not Fast2Symbol(rest$, ",", 1, ";", 1) Then MissPar: Exit Function
        Else
            frm$ = "?"
        End If
        par = False
    End If
    w$ = vbNullString
    Fkey = -1
    If bstack.toprinter = True And Not par Then
        oxiforPrinter
        Fkey = 0
        Exit Function
    End If
    If (Left$(Typename(bstack.Owner), 3) = "Gui") And Not par Then oxiforforms: Fkey = 0: Exit Function
    If (TypeOf bstack.Owner Is MetaDc) And Not par Then oxiforMetaFiles: Exit Function
    MyInput = False
    Do
        Select Case Abs(IsLabel(bstack, rest$, what$))
        Case 1
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = 0#
            If p <> 0 Then p = p - p
            If par Then
                If uni(f) Then
                        getUniRealComma f, s$
                Else
                        getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                    w$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!@#$|\{}[]'~`%^&()=_:;", True)
                    If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False: Fkey = 0: Exit Function
                End If
                If GetVar(bstack, what$, i) Then
                    If MyIsObject(var(i)) Then
                        If Typename(var(i)) = mgroup Then
                            If var(i).HasSet Then
                                Set mystack = bstack.soros
                                Select Case Typename(p)
                                Case "Long"
                                    s$ = s$ + "&"
                                Case "Currency"
                                    s$ = s$ + "#"
                                Case "Decimal"
                                    s$ = s$ + "@"
                                Case "Single"
                                    s$ = s$ + "~"
                                Case "Integer"
                                    s$ = s$ + "%"
                                End Select
                                If par Then
                                    If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                                Else
                                    If Not IsNumberCheck(s$, pp) Then pp = p
                                End If
                                bstack.soros.PushVal pp
                                Set bstack.lastobj = Nothing
                                NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + ":=()", MyInput
                                Set bstack.Sorosref = mystack
                                Set mystack = Nothing
                            Else
                                BadGroupHandle
                                MyInput = False
                                Fkey = 0: Exit Function
                                End If
                        ElseIf Typename(var(i)) = "Constant" Then
                                CantAssignValue
                        End If
                    Else
                        Select Case Typename(var(i))
                        Case "Long"
                            s$ = s$ + "&"
                        Case "Currency"
                            s$ = s$ + "#"
                        Case "Decimal"
                            s$ = s$ + "@"
                        Case "Single"
                            s$ = s$ + "~"
                        Case "Integer"
                            s$ = s$ + "%"
                        End Select
                        If par Then
                            If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                        Else
                            If Not IsNumberCheck(s$, pp) Then pp = p
                        End If
                        var(i) = pp
                    End If
                Else
                    If i = -1 Then
                        bstack.ReadVar what$, pp
                        Select Case Typename(pp)
                        Case "Long"
                            s$ = s$ + "&"
                        Case "Currency"
                            s$ = s$ + "#"
                        Case "Decimal"
                            s$ = s$ + "@"
                        Case "Single"
                            s$ = s$ + "~"
                        Case "Integer"
                            s$ = s$ + "%"
                        End Select
                        If IsNumberCheck(s$, p) Then bstack.SetVar what$, pp
                    Else
                        Select Case Typename(p)
                        Case "Long"
                            s$ = s$ + "&"
                        Case "Currency"
                            s$ = s$ + "#"
                        Case "Decimal"
                            s$ = s$ + "@"
                        Case "Single"
                            s$ = s$ + "~"
                        Case "Integer"
                            s$ = s$ + "%"
                        End Select
                        If par Then
                            If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                        Else
                            If Not IsNumberCheck(s$, pp) Then pp = p
                        End If
                        globalvar what$, pp
                    End If
                End If
                MyInput = True
        Case 3
            If par Then
                If uni(f) Then
                    getUniStringComma f, s$, inpcleanstrings
                Else
                    getAnsiStringComma f, s$, inpcleanstrings
                End If
                If inpcsvuseescape Then s$ = EscapeStrToString(s$)
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                    QUERY bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), IIf(lookOne(rest$, ","), ",", Chr$(0)) + Chr$(34) + "{}"
            End If
            If GetVar(bstack, what$, i) Then
                If MyIsObject(var(i)) Then
                    If Typename(var(i)) = mgroup Then
                        If var(i).HasSet Then
                            Set mystack = bstack.soros
                            If bstack.lastobj Is Nothing Then
                                bstack.soros.PushStr s$
                            Else
                                If TypeOf bstack.lastobj Is Group Then
                                    bstack.lastobj.ToDelete = False
                                End If
                                bstack.soros.PushObj bstack.lastobj
                                Set bstack.lastobj = Nothing
                            End If
                            NeoCall2 bstack, Left$(what$, Len(what$) - 1) + "." + ChrW(&H1FFF) + ":=()", MyInput
                            Set bstack.Sorosref = mystack
                            Set mystack = Nothing
                        Else
                            BadGroupHandle
                            MyInput = False
                            Fkey = 0: Exit Function
                        End If
                    ElseIf Typename(var(i)) = "Constant" Then
                        CantAssignValue
                    End If
                Else
                    CheckVar var(i), s$
                End If
            Else
                If i = -1 Then
                    bstack.SetVar what$, s$
                Else
                    globalvar what$, s$
                End If
            End If
            MyInput = True
        Case 4
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = 0#
            If p <> 0 Then p = p - p
            If par Then
                If uni(f) Then
                    getUniRealComma f, s$
                Else
                    getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                w$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!.@#$|\{}[]'~`%^&()=_:;", True)
                If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False:    Fkey = 0: Exit Function
            End If
            If GetVar(bstack, what$, i) Then
                Select Case Typename(var(i))
                Case "Long"
                    s$ = s$ + "&"
                Case "Currency"
                    s$ = s$ + "#"
                Case "Decimal"
                    s$ = s$ + "@"
                Case "Single"
                    s$ = s$ + "~"
                Case "Integer"
                    s$ = s$ + "%"
                End Select
                If par Then
                    If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                Else
                    If Not IsNumberCheck(s$, pp) Then pp = p
                End If
                var(i) = MyRound(pp)
            Else
                If i = -1 Then
                    bstack.ReadVar what$, pp
                    Select Case Typename(pp)
                    Case "Long"
                        s$ = s$ + "&"
                    Case "Currency"
                        s$ = s$ + "#"
                    Case "Decimal"
                        s$ = s$ + "@"
                    Case "Single"
                        s$ = s$ + "~"
                    Case "Integer"
                        s$ = s$ + "%"
                    End Select
                If IsNumberCheck(s$, p) Then bstack.SetVar what$, pp
                    bstack.SetVar what$, MyRound(pp)
                Else
                    Select Case Typename(p)
                    Case "Long"
                        s$ = s$ + "&"
                    Case "Currency"
                        s$ = s$ + "#"
                    Case "Decimal"
                        s$ = s$ + "@"
                    Case "Single"
                        s$ = s$ + "~"
                    Case "Integer"
                        s$ = s$ + "%"
                    End Select
                    If par Then
                        If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
                    Else
                        If Not IsNumberCheck(s$, pp) Then pp = p
                    End If
                    If Typename(p) <> Typename(pp) Then
                        Overflow
                    Else
                        globalvar what$, MyRound(pp)
                    End If
                End If
            End If
            MyInput = True
        Case 5
            If neoGetArray(bstack, what$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Fkey = 0: Exit Function
            Else
                MyEr "No such array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                Fkey = 0:  Exit Function
            End If
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = 0#
            MyInput = True
            If par Then
                If uni(f) Then
                    getUniRealComma f, s$
                Else
                    getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                w$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!@#$|\{}[]'~`%^&()=_:;", True)
                If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False: Fkey = 0: Exit Function
            End If
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = pppp.item(it)
            p = p - p
            Select Case Typename(p)
            Case "Long"
                s$ = s$ + "&"
            Case "Currency"
                s$ = s$ + "#"
            Case "Decimal"
                s$ = s$ + "@"
            Case "Single"
                s$ = s$ + "~"
            Case "Integer"
                s$ = s$ + "%"
            End Select
            If par Then
                If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
            Else
                If Not IsNumberCheck(s$, pp) Then pp = p
            End If
            pppp.item(it) = pp
            MyInput = True
        Case 6
            If neoGetArray(bstack, what$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Fkey = 0: Exit Function
            Else
                MyEr "No such array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                Fkey = 0: Exit Function
            End If
            MyInput = True
            If par Then
                If uni(f) Then
                    getUniStringComma f, s$, inpcleanstrings
                Else
                    getAnsiStringComma f, s$, inpcleanstrings
                End If
                If inpcsvuseescape Then s$ = EscapeStrToString(s$)
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                    QUERY bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), IIf(lookOne(rest$, ","), ",", Chr$(0)) + Chr$(34) + "{}"
            End If
            If MyIsObject(pppp.item(it)) Then
                If pppp.ItemType(it) = mgroup Then
                    If pppp.item(it).HasSet Then
                        what = Left$(what$, Len(what$) - 2)
                        Set mystack = bstack.soros
                        PushParamGeneral bstack, rest$
                        If Not FastSymbol(rest$, ")", True) Then
                            Set bstack.Sorosref = mystack
                            MyInput = False: Exit Function
                        End If
                        bstack.soros.DataStr s$
                        NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + ":=()", MyInput
                        Set bstack.Sorosref = mystack
                        Set mystack = Nothing
                Else
                    GroupCantSetValue
                End If
            ElseIf pppp.ItemType(it) = doc Then
                Set pppp.item(it) = New Document
                    If s$ <> "" Then pppp.item(it).textDoc = s$
                End If
            Else
                pppp.item(it) = s$
            End If
            MyInput = True
        Case 7
            If neoGetArray(bstack, what$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, what$, it, rest$) Then Fkey = 0: Exit Function
            Else
                MyEr "No such array", "дЕМ УПэЯВЕИ ТщТОИОР ПъМАЙАР"
                Exit Function
            End If
            If par Then
                If uni(f) Then
                    getUniRealComma f, s$
                Else
                    getAnsiRealComma f, s$
                End If
            Else
                prive = GetCode(bstack.Owner)
                If players(prive).lastprint Then
                    LCTbasket bstack.Owner, players(prive), players(prive).currow, players(prive).curpos
                    players(prive).lastprint = False
                End If
                w$ = QUERY(bstack, frm$, s$, 256, False, IIf(lookOne(rest$, ","), "," + vbCr, vbCr), "+*/!@#$|\{}[.]'~`%^&()=_:;", True)
                If LenB(Trim(s$)) = 0 Then ErrNum: MyInput = False: Fkey = 0: Exit Function
            End If
            If FastSymbol(rest$, "=") Then IsNumberCheck rest$, p Else p = pppp.item(it)
            p = p - p
            Select Case Typename(p)
            Case "Long"
                s$ = s$ + "&"
            Case "Currency"
                s$ = s$ + "#"
            Case "Decimal"
                s$ = s$ + "@"
            Case "Single"
                s$ = s$ + "~"
            Case "Integer"
                s$ = s$ + "%"
            End Select
            If par Then
                If Not IsNumberCheck(s$, pp, inpcsvDec$) Then pp = p
            Else
                If Not IsNumberCheck(s$, pp) Then pp = p
            End If
            pppp.item(it) = MyRound(pp)
            MyInput = True
        End Select
        If FastSymbol(rest$, ",") Then
            w$ = vbNullString
            If Not par Then frm$ = " "
        ElseIf FastSymbol(rest$, ";") Then
            If Not par Then
                w$ = ";"
                frm$ = " "
            End If
        Else
            If Not par Then If Not w$ = ";" Then crNew bstack, players(prive)
            w$ = vbNullString
            Fkey = 0: Exit Function
        End If
    Loop
    Fkey = 0
    Exit Function
End With

End Function
Function MyCopy(bstack As basetask, rest$, Lang As Long) As Boolean
Dim p As Variant, Scr As Object, photo As cDIBSection, s$, it As Long, what$
MyCopy = True
Dim x1 As Long, y1 As Long, x2 As Long, y2 As Long, pppp As mArray, y22 As Single
            If IsStrExp(bstack, rest$, s$) Then
             If Left$(s$, 4) = "cDIB" And Len(s$) > 12 Then
                Set photo = New cDIBSection
                If cDib(s$, photo) Then
                If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
                If IsStrExp(bstack, rest$, s$) Then
                       photo.SaveDib s$
                       Set photo = Nothing
                       End If
                       End If
                       Exit Function
                Else
                        noImage s$
                        Exit Function
                End If
             Else
                If ExtractType(s$) = vbNullString Then s$ = s$ + ".bmp"
                FixPath s$
                If Not CanKillFile(s$) Then FilePathNotForUser:  Exit Function
            
             
            On Error Resume Next
            
            Set photo = New cDIBSection
            photo.CopyPicture bstack.Owner
            photo.SaveDib s$
            Set photo = Nothing
            Exit Function
            End If
Else
If IsExp(bstack, rest$, p) Then x1 = p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p

If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
Select Case Abs(IsLabel(bstack, rest$, s$))
Case 3
    If GetVar(bstack, s$, it) Then
    
    Set photo = New cDIBSection
    Set Scr = bstack.Owner
    With players(GetCode(Scr))
    x1 = Scr.ScaleX(x1 + .XGRAPH, 1, 3) - Scr.ScaleX(.XGRAPH, 1, 3)
    y1 = Scr.ScaleX(y1 + .YGRAPH, 1, 3) - Scr.ScaleX(.YGRAPH, 1, 3)
    If photo.create(CLng(x1), CLng(y1)) Then
    photo.LoadPictureBlt Scr.hdc, CLng(Scr.ScaleX(.XGRAPH, 1, 3)), CLng(Scr.ScaleX(.YGRAPH, 1, 3))
    
    If photo.bitsPerPixel <> 24 Then Conv24 photo
    
    var(it) = DIBtoSTR(photo)
    ' DOSE OK
    End If
    End With
     Set photo = Nothing
     Set Scr = Nothing
    Exit Function
    Else
    what$ = s$
    MyCopy = False
    Exit Function
    End If
Case 6
    ' апо пимайа
    Dim W6 As Long
    If neoGetArray(bstack, s$, pppp) Then
           If Not NeoGetArrayItem(pppp, bstack, s$, W6, rest$) Then Exit Function
    
    
      Set photo = New cDIBSection
      Set Scr = bstack.Owner
      With players(GetCode(Scr))
    x1 = Scr.ScaleX(x1 + .XGRAPH, 1, 3) - Scr.ScaleX(.XGRAPH, 1, 3)
    y1 = Scr.ScaleX(y1 + .YGRAPH, 1, 3) - Scr.ScaleX(.YGRAPH, 1, 3)
    If photo.create(CLng(x1), CLng(y1)) Then
            photo.LoadPictureBlt Scr.hdc, CLng(Scr.ScaleX(.XGRAPH, 1, 3)), CLng(Scr.ScaleX(.YGRAPH, 1, 3))

            If photo.bitsPerPixel <> 24 Then Conv24 photo
                If MyIsObject(pppp.item(W6)) Then
                        MyEr "can't copy image to " + pppp.ItemType(W6), "ДЕМ ЛПОЯЧ МА АМТИЦЯэЬЫ ЕИЙЭМА СЕ " + pppp.ItemType(W6)
                        MyCopy = False
                Else
                        pppp.item(W6) = DIBtoSTR(photo)
                End If
            ' DOSE OK
        End If
        End With
        Set photo = Nothing
        Set Scr = Nothing
        Exit Function
    
        Else
    what$ = s$
    MyCopy = False
    Exit Function
    End If

End Select
ElseIf IsLabelSymbolNew(rest$, "ле", "USE", Lang) Then

If IsStrExp(bstack, rest$, s$) Then
 Set photo = New cDIBSection

If cDib(s$, photo) Then
y22 = 0!
  Set Scr = bstack.Owner
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y22 = p
    If y2 = 0 Then y2 = 100
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y2 = p Else y2 = 100

 If Not (y22 = 0 And y2 = 100) Then
     RotateDib1 bstack, photo, y22, y2, Scr.BackColor
     End If
      photo.PaintPicture Scr.hdc, CLng(Scr.ScaleX(x1, 1, 3)), CLng(Scr.ScaleX(y1, 1, 3))

End If
Set photo = Nothing
Set Scr = Nothing
Else
 MyCopy = False: MissNumExpr: Exit Function
End If
ElseIf IsLabelSymbolNew(rest$, "епамы", "TOP", Lang) Then

If IsStrExp(bstack, rest$, s$) Then
 Set photo = New cDIBSection
Set Scr = bstack.Owner
If cDib(s$, photo) Then
y22 = 0!
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y22 = p
    If y2 = 0 Then y2 = 100
    If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y2 = p Else y2 = 100
    
If Not (y22 = 0 And y2 = 100) Then
     RotateDib1 bstack, photo, y22, y2, , CLng(x1), CLng(y1)
       End If
        photo.PaintPicture Scr.hdc, MyRound((Scr.ScaleX(x1, 1, 3)), 0), MyRound((Scr.ScaleX(y1, 1, 3)), 0) '', photo.Width * y2 \ 100, photo.Height * y2 \ 100
     
 
End If
Set photo = Nothing
Set Scr = Nothing
Else
 MyCopy = False: MissNumExpr: Exit Function
End If
Else
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then x2 = p

If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y2 = p Else MyCopy = False: MissNumExpr: Exit Function

If x2 = 0 Or y2 = 0 Then MyCopy = False: MissNumExpr: Exit Function
ICOPY bstack.Owner, x1, y1, x2, CLng(y2)
End If
End If
MyDoEvents1 bstack.Owner

End Function




Function MyFunction(entrypoint As Long, bstack As basetask, rest$, Lang As Long, Optional noskipcommand = False, Optional MakeNew As Boolean, Optional addlen As Long = 0, Optional ByPass As Boolean) As Boolean
Dim y1 As Long, par As Boolean, what$, s$, ss$, pa$, x1 As Long, i As Long, frm$
Dim ohere$, ox As Long
ohere$ = here$
MyFunction = True
        If entrypoint = 1 Then
                par = True
                y1 = True
        ElseIf entrypoint = 2 Then
        ' operators
        par = IsLabelSymbolNew(rest$, "меа", "NEW", Lang)
            i = InStr(rest$, " ")
            If i = 1 Then
                i = InStr(2, rest$, " ")
                what$ = Mid$(rest$, 2, i - 2) ' + "()"
            Else
             what$ = Left$(rest$, i - 1) ' + "()"
            End If
            rest$ = Mid$(rest$, i + 1)
            GoTo operators
        ElseIf entrypoint = -1 Then
        par = Len(ohere$) = 0
        GoTo alocal
        Else
                y1 = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", Lang)
                par = IsLabelSymbolNew(rest$, "меа", "NEW", Lang)
        End If
        If y1 <> 0 Then
                ' FUNCTION GLOBAL "ALFA[212].other" {definition} so we can place [ ] in a definition..
                ' FOR INTERNAL USE..
                    If lookOne(rest$, Chr(34)) Then
                        ISSTRINGA rest$, what$
                            x1 = 1
                        If Right$(what$, 1) = "$" Then
                            x1 = 3
                        ElseIf Right$(what$, 1) = "%" Then
                            x1 = 4
                        End If
                        what$ = what$ & "()"
                        If FastSymbolNoTrimAfter(rest$, "{") Then
                                ss$ = block(rest$)
                                If Len(ss$) = 0 Then
                                    ss$ = blockString(rest$, Asc("}"))
                                End If
                                i = Len(rest$) + addlen
                                If Not FastSymbol(rest$, "}") Then
                                        MyFunction = False
                                Else
                                ''*****************************************************************************
                       
                                If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                                                s$ = vbNullString
                                        Else
                                                pa$ = sbf(Abs(bstack.OriginalCode)).sb
                                                If Not Left$(ss$, 10) = "'11001EDIT" Then
                                                         s$ = GetNextLine(pa$) & "-" & CStr(i - 2) + vbCrLf
                                                End If
                                        End If
                                ElseIf Not bstack.LoadOnly Then
                                        If Left$(ss$, 10) <> "'11001EDIT" Then
                                                s$ = "'11001EDIT " & GetModuleName(bstack, ohere$) & ",-" & CStr(i + addlen - 2) + vbCrLf
                                        End If
                                End If
                                bstack.IndexSub = ModuleSub(what$, s$ + ss$)
                            End If
                            Exit Function
                        Else
                        GoTo missdef
                        End If
                End If
        End If
alocal:
        x1 = Abs(IsLabelF(rest$, what$))
        
If x1 = 1 Or x1 = 3 Or x1 = 4 Then   ' C() C%() C$()
operators:
              If Not noskipcommand Then
                If x1 = 1 Then
                If funid.Find(what$ + "(", i, bstack.numfunnum) Then
                 If i > 0 Then funid.ItemCreator what$ + "(", -Abs(i)
                End If
                ElseIf x1 = 3 Then
                If strfunid.Find(what$ + "(", i, bstack.strfunnum) Then
                 If i > 0 Then strfunid.ItemCreator what$ + "(", -Abs(i)
               End If
                End If
                End If
                what$ = what$ & "()"
                MakeThisSub bstack, what$
                
                If y1 Then  ' We have a global function
                        If Not GetGlobalSubAfterHere(bstack, what$, x1) Then
                                    If FastSymbol(rest$, "(") Then
                                        frm$ = BlockParam(rest$)
                                    If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                                    If Not FastSymbol(rest$, ")", True) Then
                                        MyFunction = False
                                        Exit Function
                                    End If
                                    
                                    frm$ = Trim$(frm$)
                                    End If
                                If FastSymbolNoTrimAfter(rest$, "{") Then
                                        ss$ = block(rest$)
                                        If Len(ss$) = 0 Then
                                            ss$ = blockString(rest$, Asc("}"))
                                        End If
                                        y1 = Len(rest$) + addlen
                                        If Not FastSymbol(rest$, "}") Then
                                                MyFunction = False
                                        Else
                                                '  If Right$(ss$, 2) <> vbCrLf Then ss$ = ss$ + vbCrLf
                                                  If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                                                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                                                                s$ = vbNullString
                                                        Else
                                                                pa$ = sbf(Abs(bstack.OriginalCode)).sb
                                                                If Not Left$(ss$, 10) = "'11001EDIT" Then
                                                                         s$ = GetNextLine(pa$) & "-" & CStr(y1 - 2 + addlen) + vbCrLf
                                                                End If
                                                        End If
                                                ElseIf bstack.OriginalCode > 0 And Not bstack.LoadOnly And here$ <> "" Then
                                                        If Left$(ss$, 10) <> "'11001EDIT" Then
                                                                s$ = "'11001EDIT " & GetModuleName(bstack, ohere$) & ",-" & CStr(y1 - 2 + addlen) + vbCrLf
                                                        End If
                                                End If
                                                If frm$ <> "" Then
                                                
                                                If Lang = 1 Then
                                                     s$ = s$ + "Read " + frm$ + vbCrLf
                                           
                                                Else
                                                     s$ = s$ + "дИэБАСЕ " + frm$ + vbCrLf
                                                End If
                                                End If
                                                If i < 0 And Len(here$) <> 0 Then
                                                bstack.IndexSub = ModuleSub(here$ + "." + what$, s$ + ss$)
                                                Else
                                                
                                             bstack.IndexSub = ModuleSub(what$, s$ + ss$)
                                             
                                             
                                             End If
                                    
                                        End If
                                Else
missdef:
                                       MyEr what$ & " missing definition", what$ & " КЕъПЕИ О ОЯИСЛЭР"
                                End If
                         Else
                                If FastSymbol(rest$, "(") Then
                                    frm$ = BlockParam(rest$)
                                If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                                If Not FastSymbol(rest$, ")", True) Then
                                        MyFunction = False
                                        Exit Function
                                End If
                                frm$ = Trim$(frm$)
                                End If
                                If FastSymbolNoTrimAfter(rest$, "{") Then
                                        what$ = block(rest$)
                                        If Len(what$) = 0 Then
                                            what$ = blockString(rest$, Asc("}"))
                                        End If
                                        If Len(frm$) <> 0 Then
                                            If Lang = 1 Then
                                                what$ = "Read " + frm$ + vbCrLf + what$
                                            Else
                                                what$ = "дИэБАСЕ " + frm$ + vbCrLf + what$
                                            End If
                                            frm$ = vbNullString
                                        End If
                                        If Not FastSymbol(rest$, "}") Then
                                                MyFunction = False
                                        Else
                                                If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                                sbf(x1).sb = what$: bstack.IndexSub = x1
                                                Set sbf(x1).subs = Nothing
                                        End If
                                Else
                                    MyEr what$ & " missing definition", what$ & " КЕъПЕИ О ОЯИСЛЭР"
                                End If
                        End If
                        Exit Function
                Else
                If par Then
                If entrypoint = 2 Then
                x1 = ModuleSub(what$, "")
                Else
                If Len(here$) = 0 Then
                x1 = ModuleSub(what$, "")   'bstack.GroupName &
                Else
                x1 = ModuleSub(here$ & "." & bstack.GroupName & what$, "")
                End If
                End If
                GoTo jump1
                
                        ElseIf here$ = vbNullString And subHash.Find(what$, x1) And Not MakeNew Then
                        
jump1:
                                If x1 >= lckfrm And lckfrm <> 0 Then   ' when we load a scrabled program..we have locked functions/modules
                                          '  MyEr what$ & " is locked", what$ & " ЕъМАИ ЙКЕИДЫЛщМО"
                                            rest$ = vbNullString
                                            MyFunction = False: Exit Function
                                End If
                                If FastSymbol(rest$, "(") Then
                                    frm$ = BlockParam(rest$)
                                    If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                                    If Not FastSymbol(rest$, ")", True) Then
                                        MyFunction = False
                                        Exit Function
                                    End If
                                    frm$ = Trim$(frm$)
                                    Else
                                    frm$ = vbNullString
                                    
                                End If

                                If FastSymbolNoTrimAfter(rest$, "{") Then
                                
                                            what$ = block(rest$) + " "
                                            If Len(what$) = 1 Then
                                                what$ = blockString(rest$, Asc("}")) + " "
                                            End If
                                                If Len(frm$) <> 0 Then
                                                    If Lang = 1 Then
                                                        what$ = "Read " + frm$ + vbCrLf + what$
                                                    Else
                                                        what$ = "дИэБАСЕ " + frm$ + vbCrLf + what$
                                                    End If
                                                    frm$ = vbNullString
                                                End If
                                            If Not FastSymbol(rest$, "}") Then
                                                    MyFunction = False
                                            Else
                                                    If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                                    sbf(x1).Changed = True
                                                    sbf(x1).sb = what$: bstack.IndexSub = x1
                                                    Set sbf(x1).subs = Nothing
                                            End If
                                    Else
                                            MyFunction = False
                                    End If
                                    Exit Function
                        ElseIf GetlocalSub(bstack.GroupName & what$, x1) And Not MakeNew Then
                     
                                If FastSymbol(rest$, "(") Then
                                ox = 1
                                    frm$ = BlockParam(rest$)
                                    If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                                    If Not FastSymbol(rest$, ")", True) Then
                                        MyFunction = False
                                        Exit Function
                                    End If
                                frm$ = Trim$(frm$)
                                  Else
                                frm$ = vbNullString
                                End If
                                                   
                                
                                    If FastSymbolNoTrimAfter(rest$, "{") Then
                                           If sbf(x1).locked Or sbf(x1).Extern > 0 Then
                                         what$ = block(rest$)
                                        If Len(what$) = 0 Then
                                            what$ = blockString(rest$, Asc("}"))
                                        End If
                                        bstack.IndexSub = x1
                                       FastSymbol rest$, "}", True
                                     Exit Function
                                    End If
                                        If Len(frm$) <> 0 Then
                                            If Lang = 1 Then
                                            rest$ = "Read " + frm$ + vbCrLf + rest$
                                            Else
                                            rest$ = "дИэБАСЕ " + frm$ + vbCrLf + rest$
                                            End If
                                            frm$ = vbNullString
                                        End If

                                       ' If x1 >= lckfrm And lckfrm <> 0 Then
                                       '     MyEr what$ & " is locked", what$ & " ЕъМАИ ЙКЕИДЫЛщМО"
                                       '     rest$ = vbNullString
                                       '     MyFunction = False
                                       '     Exit Function
                                       ' End If
                                        i = Len(rest$)
                                        
                                        what$ = block(rest$) + " "
                                        If Len(what$) = 1 Then
                                            what$ = blockString(rest$, Asc("}")) + " "
                                        End If
                                        While Left$(what$, 10) = "'11001EDIT"
                                                SetNextLine what$
                                        Wend
                                        If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                        what$ = "'11001EDIT " & GetModuleName(bstack, ohere$) & ",-" & CStr(i - 2 + addlen) + vbCrLf + what$
                                        If Not FastSymbol(rest$, "}") Then
                                                MyFunction = False
                                        Else
                                            If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                            sbf(x1).Changed = True
                                            sbf(x1).sb = what$
                                                bstack.IndexSub = x1
                                            Set sbf(x1).subs = Nothing
                                            End If
                                        
                                        
                                    
                                    Else
                                    '' or MyFunction=false
                                    If bstack.IndexSub = x1 Then
                                     bstack.IndexSub = 0
                                    
                                    End If
                                    
                                    If ox = 0 Then
                                    GoTo missdef
                                    Else
                                    rest$ = vbNullString
                                    End If
                                     '       rest$ = ":" & bstack.GroupName & what$ & " " & rest$
                                    End If
                                    Exit Function
                        ElseIf FastSymbol(rest$, "(") Then
                            frm$ = BlockParam(rest$)
                             If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                            If Not FastSymbol(rest$, ")", True) Then
                                        MyFunction = False
                                        Exit Function
                            End If
                            frm$ = Trim$(frm$)
                            If FastSymbolNoTrimAfter(rest$, "{") Then GoTo jumpheretoo
                            rest$ = ""
                        ElseIf FastSymbolNoTrimAfter(rest$, "{") Then
jumpheretoo:
                        
                                    If here$ = vbNullString Then
                                                s$ = block(rest$)
                                                If Len(s$) = 0 Then
                                                    s$ = blockString(rest$, Asc("}"))
                                                End If
                                                 If frm$ <> "" Then

                                                    s = "READ " + frm$ + vbCrLf + s$
                                                 End If
                                                If Right$(s$, 2) <> vbCrLf Then s$ = s$ + vbCrLf
                                                ' NEED TO HAVE A HEADER ******************************************************************************
                                                bstack.IndexSub = ModuleSub(what$, s$)
                                    Else
                                                ss$ = block(rest$)
                                                    If Len(ss$) = 0 Then
                                                        ss$ = blockString(rest$, Asc("}"))
                                                    End If
                                                i = Len(rest$)
                                             '   If Right$(ss$, 2) <> vbCrLf Then ss$ = ss$ + vbCrLf
                                                If Left$(sbf(Abs(bstack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                                                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                                                                s$ = vbNullString
                                                        Else
                                                                pa$ = sbf(Abs(bstack.OriginalCode)).sb
                                                                If Not Left$(ss$, 10) = "'11001EDIT" Then
                                                                     '   If addlen = 0 Then addlen = -2
                                                                         s$ = GetNextLine(pa$) & "-" & CStr(i + addlen) + vbCrLf
                                                                         
                                                                End If
                                                        End If
                                                ElseIf Not bstack.LoadOnly Then
                                                        If Left$(ss$, 10) <> "'11001EDIT" Then
                                                                
                                                                
                                                                s$ = "'11001EDIT " & GetModuleName(bstack, ohere$) & ",-" & CStr(i + addlen + 2 * (Len(bstack.UseGroupname) > 0)) + vbCrLf
                                                        End If
                                                End If
                                                If frm$ <> "" Then
                                                        If Lang = 1 Then
        
                                                        s$ = s$ + vbCrLf + "Read " + frm$ + vbCrLf
                   
                                                        Else
        
                                                        s$ = s$ + vbCrLf + "дИэБАСЕ " + frm$ + vbCrLf
                                                        End If

                                                End If
                                                If Not ByPass Then
                                                If Len(here$) = 0 Then
                                                bstack.IndexSub = ModuleSub(bstack.GroupName & what$, s$ + ss$)
                                                Else
                                                bstack.IndexSub = ModuleSub(here$ & "." & bstack.GroupName & what$, s$ + ss$)
                                                End If
                                                End If
                                    End If
                                    If Not FastSymbol(rest$, "}") Or ByPass Then MyFunction = False
                                 
                                    If FastSymbol(rest$, ChrW(8189) + ChrW(8189), False, 2) Then
                                    sbf(bstack.IndexSub).IamAClass = True
                                    sbf(bstack.IndexSub).locked = True
                                    End If
                                    
                                    Exit Function
                            Else
                             MyFunction = False
                                If entrypoint = 2 Then
                                   MyEr "missing definition", "КЕъПЕИ О ОЯИСЛЭР"
                                   Exit Function
                                  End If
                                   
                                 GoTo missdef
                            End If
                End If
        Else
                rest$ = what$ & " " & rest$
                MyFunction = False
        End If

End Function


Function ProcView(bstack As basetask, rest$, Lang As Long) As Boolean
If bstack.toprinter Then oxiforPrinter: Exit Function
If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
If TypeOf bstack.Owner Is VB.PictureBox Then
On Error GoTo ttt
If CLng("0" & bstack.Owner.Tag) > 33 Then
oxiforImages: Exit Function
End If
End If
Err.Clear
ttt:
GetNames bstack, rest$, Form1.List1, Lang
mywait bstack, CDbl(100)
If Not FastSymbol(rest$, ";") Then ProcView = MyMenu(2, bstack, rest$, Lang) Else ProcView = True
End Function


Function ProcProto(bstack As basetask, rest$, Lang As Long) As Boolean
ProcProto = True
Dim s$, w$, v As Long
If FastSymbol(rest$, "{") Then
s$ = block(rest$)
If Right$(s$, 1) = " " Then
v = Len(s$) - MyTrimRStr(s$)
If v > 0 Then s$ = Replace$(s$, Chr$(10) + space(v), Chr$(10))
ElseIf Right$(s$, 1) = vbTab Then
v = Len(s$) - MyTrimRNoCr(s$)
If v > 0 Then s$ = Replace$(s$, Chr$(10) + String$(v, vbTab), Chr$(10))

End If
v = 0
Else
MissingCodeBlock
ProcProto = False
Exit Function
End If
If FastSymbol(rest$, "}", True) Then
    If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
        If FastPureLabel(rest$, w$, , , True) = 3 Then
            w$ = myUcase(w$, True)
            
            If GetVar(bstack, w$, v, True) Then
            GoTo cont1
            ElseIf GetlocalVar(w$, v) Then
cont1:
             If CheckVarOnlyNo(var(v), s$) Then
                If Typename(var(v)) = "Constant" Then
                    CantAssignValue
                Else
                    NoObjectAssign
                End If
                ProcProto = False
                Exit Function
            End If
            Else
            v = globalvar(w$, v, , True)
            var(v) = s$
            End If
            
        Else
        MyEr "No string name (using $)", "дЕМ БЯчЙА ЭМОЛА АКЖАЯИХЛГТИЙОЩ"
        
        End If
    Else
        MyEr "Missing AS", "кЕъПЕИ ТО ыР"
        ProcProto = False
        Exit Function
    End If
    Else
    ProcProto = False
End If
End Function
Function ProcBuffer(bstack As basetask, rest$, Lang As Long, Optional alocal As Boolean) As Boolean
ProcBuffer = True
Dim s$, what$, i As Long, p As Variant, pp As Long, par As Long, what2$, Runnable As Boolean, itissingle As Boolean
Dim usehandler As mHandler, useBuffer As MemBlock
If IsLabelSymbolNew(rest$, "йыдийа", "CODE", Lang) Then Runnable = True
If IsLabelSymbolNew(rest$, "йемг", "CLEAR", Lang) Then par = &H8

     Do While Abs(IsLabel(bstack, rest$, what$)) = 1
     If bstack.priveflag Then what$ = ChrW(&HFFBF) + what$
                    If alocal Then
                        GoTo makeitnow
                    ElseIf GetlocalVar(bstack.GroupName & what$, i) Then
                        If Not MyIsObject(var(i)) Then MakeitObjectBuffer var(i)
                    ElseIf GetVar(bstack, bstack.GroupName & what$, i, True) Then
                        If Not MyIsObject(var(i)) Then MakeitObjectBuffer var(i)
                    Else
makeitnow:
                        i = globalvar(bstack.GroupName & what$, s$)
                        MakeitObjectBuffer var(i)
                    End If
                    If TypeOf var(i) Is mHandler Then
                        Set usehandler = var(i)
                        If TypeOf usehandler.objref Is MemBlock Then GoTo contok
                    
                    End If
                        Expected "Buffer", "дИэЯХЯЫСГ ЛМчЛГР"
                        Exit Function
                    
contok:
                    Set usehandler = var(i)
                    Set useBuffer = usehandler.objref
                    ' GET TYPE OF  BUFFER
                    ' Char (1 byte) String (2 bytes)  Long (4 Bytes)
                    pp = 1
                    If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                        If IsLabelSymbolNew(rest$, "ьгжио", "BYTE", Lang, , , , False) Then
                            pp = 1
                        ElseIf IsLabelSymbolNew(rest$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                            pp = 2
                        ElseIf IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang, , , , False) Then
                            pp = 4
                        ElseIf IsLabelSymbolNew(rest$, "апкос", "SINGLE", Lang, , , , False) Then
                            itissingle = True
                            pp = 4
                        ElseIf IsLabelSymbolNew(rest$, "цяалла", "STRING", Lang, , , , False) Then
                            
                            pp = -4
                        ElseIf IsLabelSymbolNew(rest$, "дипкос", "DOUBLE", Lang, , , , False) Then
                            pp = 8
                        ElseIf Abs(IsLabel(bstack, rest$, what2$)) = 1 Then
                        If GetVar3(bstack, bstack.GroupName + what2$, i) Then
                        
                        If IsExp(bstack, bstack.GroupName + what2$, p) Then
                                If bstack.lastobj Is Nothing Then GoTo comehere
                                If Not TypeOf bstack.lastobj Is mHandler Then GoTo comehere
                                Set usehandler = bstack.lastobj
                                If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                If usehandler.objref.StructLen = 0 Then GoTo comehere
                               pp = usehandler.objref.StructLen
                               Set useBuffer.structref = usehandler.objref
                               useBuffer.UseStruct = True
                               Set bstack.lastobj = Nothing
                               Set usehandler = Nothing
                        End If
                        
                        Else
                            If IsExp(bstack, what2$, p) Then
                                If bstack.lastobj Is Nothing Then GoTo comehere
                                If Not TypeOf bstack.lastobj Is mHandler Then GoTo comehere
                                Set usehandler = bstack.lastobj
                                If Not TypeOf usehandler.objref Is FastCollection Then GoTo comehere
                                If usehandler.objref.StructLen = 0 Then GoTo comehere
                               pp = usehandler.objref.StructLen
                               Set useBuffer.structref = usehandler.objref
                               useBuffer.UseStruct = True
                               Set bstack.lastobj = Nothing
                               Set usehandler = Nothing
                        End If
                        End If
                        Else
comehere:
                        SyntaxError
                            ProcBuffer = False
                                Exit Function
                        End If
                    
                    If FastSymbol(rest$, "*") Then
                        If IsExp(bstack, rest$, p) Then
                        ' we get the size here
                        If p <= 0 Then
                            MyEr "No Zero or Negative number for size", "╪ВИ ЛГДщМ ч АЯМГТИЙЭ АЯИХЛЭ ЦИА ЛчЙОР"
                            ProcBuffer = False
                            Exit Function
                        Else
                         '' MAKE IT
                    If useBuffer.ItemSize <> 0 Then
                    If useBuffer.ItemSize = Abs(pp) Then
                    useBuffer.ResizeItems CLng(p), par
                    End If
                    Else
                        If itissingle Then
                            useBuffer.Construct pp, CLng(p), par, Runnable, vbSingle
                        Else
                            useBuffer.Construct pp, CLng(p), par, Runnable
                        End If
                        End If
                        End If
                        Else
                            MissPar
                            ProcBuffer = False
                            Exit Function
                        End If
                        
                    Else
                    If useBuffer.status = 0 Then
                        If itissingle Then
                            useBuffer.Construct pp, 1, par, Runnable, vbSingle
                        Else
                            useBuffer.Construct pp, 1, par, Runnable
                        End If
                        End If
                    End If
                End If
     
     
     If Not FastSymbol(rest$, ",") Then Exit Do
     Loop

End Function
Function ProcInventory(bstack As basetask, rest$, Lang As Long, Optional alocal As Boolean) As Boolean
ProcInventory = True
Dim s$, what$, i As Long, p As Variant, Queue As Boolean, serr As Boolean, usehandler As mHandler
    Queue = IsLabelSymbolNew(rest$, "оуяа", "QUEUE", Lang)
     Do While Abs(IsLabel(bstack, rest$, what$)) = 1
     serr = False
conthere:
     If bstack.priveflag Then what$ = ChrW(&HFFBF) + what$
     If Not FastSymbol(rest$, "<") Then  ' get local var first
            If alocal Then
            i = globalvar(bstack.GroupName & what$, s$) ' MAKE ONE
             GoTo makeitnow1
            ElseIf GetlocalVar(bstack.GroupName & what$, i) Then
       
            If Not MyIsObject(var(i)) Then GoTo makeitnow1
            If FastSymbol(rest$, "=") Then
             GoTo there12
             Else
                If MyIsObject(var(i)) Then
                If TypeOf var(i) Is mHandler Then
                Set usehandler = var(i)
                    If usehandler.t1 = 1 Then
                        If Not usehandler.objref Is Nothing Then
                            usehandler.objref.drop 0
                        End If
                    End If
                    End If
                End If
             GoTo makeitnow1
             End If
           ' use global inventory for global ' change from revision 19-version 8.7
            ElseIf here$ = vbNullString Then
            If Not GetVar(bstack, bstack.GroupName & what$, i) Then
            ' If Not MyIsObject(var(i)) Then GoTo makeitnow1
            'GoTo there12
            GoTo lookglobal
            End If
             GoTo makeitnow1
            Else
lookglobal:
            i = globalvar(bstack.GroupName & what$, s$)     ' MAKE ONE  '
                    If Not MyIsObject(var(i)) Then GoTo makeitnow1
             If FastSymbol(rest$, "=") Then
             GoTo there12
             Else
             GoTo makeitnow1
             End If
            End If
            ElseIf GetVar(bstack, bstack.GroupName & what$, i, True) Then
            
            If MyIsObject(var(i)) Then
                If TypeOf var(i) Is mHandler Then
                 Set usehandler = var(i)
                    If usehandler.t1 = 1 Then
                        If Not usehandler.objref Is Nothing Then
                            usehandler.objref.drop 0
                        End If
                    End If
                Set usehandler = Nothing
                End If
            End If
             GoTo makeitnow1
            Else
        
                i = globalvar(bstack.GroupName & what$, s$) ' MAKE ONE
                If i <> 0 Then
makeitnow1:
                    MakeitObjectInventory var(i), Queue
' here look for block
                    If FastSymbol(rest$, "=") Then
there12:
                    
                        Set bstack.lastobj = var(i)
                        ' new addition we can change an inventory to a queue inventory
                        ' but not the other way
                        Set usehandler = bstack.lastobj
                       If Queue Then usehandler.objref.AllowAnyKey
                       Set usehandler = Nothing
                       serr = True
                        ProcInventory = AddInventory(bstack, rest$, serr)
                        If serr Then Exit Function
                        serr = Not Abs(IsLabel(bstack, rest$, what$)) = 1
                        If serr Then Exit Do
                        GoTo conthere

                    Else
                    ' nothing
                    End If
                End If
            End If
     
     If Not FastSymbol(rest$, ",") Then Exit Do
     serr = True

     Loop
If serr Then SyntaxError: ProcInventory = False
End Function


Function ProcSettings(bstack As basetask, rest$, Lang As Long) As Boolean
Dim it As Long
TweakLang = Lang
With bstack.Owner
    it = .FontItalic
    .FontItalic = 0
    notweak = True
    MoveFormToOtherMonitorOnly TweakForm
    If Not Form1.Visible Then
    TweakForm.Show , Form5
    
    Else
    TweakForm.Show 1, Form1
    End If
   
    If Not notweak Then
        If Form1.Visible Then
            Form1.myBreak bstack
            original bstack, ""
        End If
    Else
        .FontItalic = it
    End If
End With
ProcSettings = True
End Function
Function ProcThreadPlan(bstack As basetask, rest$, Lang As Long) As Boolean
If IsLabelSymbolNew(rest$, "таутовяомо", "CONCURRENT", Lang) Then
If TaskMaster.QueueCount <> 0 Then
If Not Interrupted Then MyEr "Threads exist, can't change thread plan", "уПэЯВОУМ МчЛАТА, ДЕМ ЛПОЯЕъР МА АККэНЕИР СВщДИО"
Else
Interrupted = True
End If

ElseIf IsLabelSymbolNew(rest$, "диадовийо", "SEQUENTIAL", Lang) Then
If TaskMaster.QueueCount <> 0 Then
If Interrupted Then MyEr "Threads exist, can't change thread plan", "уПэЯВОУМ МчЛАТА, ДЕМ ЛПОЯЕъР МА АККэНЕИР СВщДИО"
Else
Interrupted = False
End If
End If
ProcThreadPlan = True
End Function

Function ProcSound(bstack As basetask, rest$) As Boolean
Dim s$, ss, h As mHandler, m As MemBlock
If IsStrExp(bstack, rest$, s$) Then
PlaySoundNew s$
ProcSound = True
ElseIf IsExp(bstack, rest$, ss) Then
If Not bstack.lastobj Is Nothing Then
If TypeOf bstack.lastobj Is mHandler Then
    Set h = bstack.lastobj
    If h.t1 = 2 Then
        Set m = h.objref
        PlaySoundNew2 m.GetPtr(0)
        ProcSound = True
    Else
        WrongObject
    End If
End If
    Set bstack.lastobj = Nothing
End If

End If

End Function

Function ProcOpen(bstack As basetask, rest$, Lang As Long) As Boolean
Dim s$, what$, it As Long, p As Variant, x1 As Long, i As Long, skip As Boolean, excl As Boolean
Dim id$, mUni As Long
If IsStrExp(bstack, rest$, s$) Then
    If s$ <> "" Then
        FixPath s$
    Else
        skip = True
        i = -2
    End If
    If IsLabelSymbolNew(rest$, "циа", "FOR", Lang, True) Then
        If skip Then
            id$ = vbNullString
            If Not IsLabelSymbolNewExp(rest$, "еуяиа", "WIDE", Lang, id$) Then
                IsLabelSymbolNewExp rest$, "еуяеиа", "WCHAR", Lang, id$
            End If
        Else
            id$ = vbNullString
            mUni = IsLabelSymbolNewExp(rest$, "еуяиа", "WIDE", Lang, id$)
            'SPELLING CORRECTION FOR GREEK WORD..
            If Not mUni Then mUni = IsLabelSymbolNewExp(rest$, "еуяеиа", "WCHAR", Lang, id$)
            If mUni Then id$ = vbNullString
        End If
        If IsLabelSymbolNewExp(rest$, "еисацыцг", "INPUT", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If skip Then BadFilename: Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang, True) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If GetVar(bstack, what$, it) Then
                    Else
                        it = globalvar(what$, i)
                    End If
                    If CFname(GetDosPath(s$)) <> "" Then
                        On Error Resume Next
                        var(it) = MyOpenFile(s$, Finput, Abs(excl), 1, mUni)
                        If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                    End If
                End If
            End If
        ElseIf IsLabelSymbolNewExp(rest$, "сулпкгяысг", "APPEND", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If Not skip Then If Not CanKillFile(s$) Then FilePathNotForUser:  Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang, True) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If GetVar(bstack, what$, it) Then
                    Else
                        it = globalvar(what$, i)
                    End If
                    If Not skip Then
                    If CFname(GetDosPath(s$)) <> "" Then
                        On Error Resume Next
                        If Not WeCanWrite(GetDosPath(s$)) Then ProcOpen = False: Exit Function
                        var(it) = MyOpenFile(s$, Fappend, Abs(excl), 1, mUni)
                        If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                    End If
                    End If
                Else
                    ExpectedVariable
                    Exit Function
                End If
            Else
                Exit Function
            End If
        ElseIf IsLabelSymbolNewExp(rest$, "енацыцг", "OUTPUT", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If Not skip Then If Not CanKillFile(s$) Then FilePathNotForUser:  Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang, True) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If GetVar(bstack, what$, it) Then
                    Else
                        it = globalvar(what$, i)
                    End If
                    On Error Resume Next
                    If Not skip Then
                       If Not NeoUnicodeFile(s$) Then NoCreateFile: Exit Function
                       On Error Resume Next
                       var(it) = MyOpenFile(s$, Foutput, Abs(excl), 1, mUni)
                       If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                    End If
                Else
                    ExpectedVariable
                    Exit Function
                End If
            Else
                Exit Function
            End If
        ElseIf IsLabelSymbolNewExp(rest$, "педиа", "RANDOM", Lang, id$) Then
            excl = 1 + IsLabelSymbolNew(rest$, "апойкеистийа", "EXCLUSIVE", Lang)
            If skip Then BadFilename: Exit Function
            If Not CanKillFile(s$) Then FilePathNotForUser: Exit Function
            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang, True) Then
                IsSymbol rest$, "#"
                If Abs(IsLabel(bstack, rest$, what$)) = 1 Then
                    If GetVar(bstack, what$, it) Then
                    Else
                        it = globalvar(what$, i)
                    End If
                    If IsLabelSymbolNew(rest$, "лгйос", "LEN", Lang, , , , False) Then
                        If FastSymbol(rest$, "=", True) Then
                            If IsExp(bstack, rest$, p) Then
                                p = Abs(p)
                                If mUni Then p = p * 2
                                If p > 32767 Then p = 32767
                                    x1 = p
                                Else
                                    Exit Function
                                End If
                            Else
                                MissNumExpr
                                Exit Function
                            End If
                            On Error Resume Next
                            If CFname(s$) = vbNullString Then
                                If Not NeoUnicodeFile(s$) Then NoCreateFile: Exit Function
                            End If
                            var(it) = MyOpenFile(s$, Frandom, Abs(excl), x1, mUni)
                            If Err.Number > 0 Then MyEr Err.Description, Err.Description: Exit Function
                        Else
                            MissNumExpr
                            ExpectedVariable
                            Exit Function
                        End If
                    Else
                        Exit Function
                    End If
                Else
                    ExpectedVariable
                Exit Function
            End If
        Else
            MyEr "Choose a way to open  file", "дИэКЕНЕ щМАМ ТЯЭПО ЦИА МА АМОъНЕИР ТО АЯВЕъО"
            Exit Function
        End If
        ProcOpen = True
    Else
        SyntaxError
    End If
Else
    MissStringExpr
End If
End Function
Function ProcItalic(bstack As basetask, rest$) As Boolean
Dim p As Variant
If IsExp(bstack, rest$, p) Then
    bstack.myitalic = (p <> 0)
Else
    bstack.myitalic = Not bstack.myitalic
    p = CDbl(bstack.myitalic)
End If
players(GetCode(bstack.Owner)).italics = Abs(p <> 0)
bstack.Owner.Font.Italic = (p <> 0)
ProcItalic = True
End Function
Function ProcEditDoc(bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, s$, sX As Double, i As Long, dum As Boolean, frm$
Dim x1 As Long, y1 As Long, p As Variant, Col As Long, OldValue As Boolean
Dim pppp As mArray
prive = GetCode(bstack.Owner)
If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
    End If
With players(prive)

                Form1.EditTextWord = Not IsLabelSymbolNew(rest$, "йыдийа", "CODE", Lang)
                dum = False
                    y1 = Abs(IsLabel(bstack, rest$, s$))
                     
                    If y1 = 6 Then
                                If neoGetArray(bstack, s$, pppp) Then
                                 If Not NeoGetArrayItem(pppp, bstack, s$, i, rest$) Then Exit Function
                                Else
                                MissingDoc
                                
                                Exit Function
                                End If
                    End If
                    If FastSymbol(rest$, ",") Then
                        If Not IsExp(bstack, rest$, sX) Then    ' FROM
                      If FastSymbol(rest$, ",") Then
                      GoTo conteditdoc
                      Else
                             MissNumExpr
                            
                            Exit Function
                      End If
                        End If
                    Else
                
                    
                 sX = 0
                    End If
                    If FastSymbol(rest$, ",") Then
conteditdoc:
                        If Not IsStrExp(bstack, rest$, frm$) Then
                        If FastSymbol(rest$, ",") Then GoTo conteditdoc2
                        End If
                          Else
                    Form1.ResetMarks
                     frm$ = vbNullString
                    
                    End If
                    If FastSymbol(rest$, ",") Then
conteditdoc2:
                        If Not IsExp(bstack, rest$, p) Then    ' FROM
                            MissStringExpr
                            
                            Exit Function
                            Else
                            Col = CLng(p)
                            dum = True
                        End If
                        
                    Else
                    Form1.ResetMarks
                    End If
                        If y1 = 3 Then
                            If GetVar(bstack, s$, i) Then
                                If Typename(var(i)) = doc Then
                                If var(i).LastSelStart > 0 And sX = 0 Then
                                x1 = var(i).LastSelStart
                                    Else
                                    If sX = 0 Then sX = -1
                                    x1 = sX
                                End If
                                   Form1.TEXT1.Title = frm$ + " "
                                    Form1.TEXT1.TabWidth = 8 + 2 * dum
                                    Form1.TabControl = 8 + 2 * dum
                                      OldValue = Form1.nobypasscheck
                                  Form1.nobypasscheck = False
                                  ScreenEditDOC bstack, var(i), 0, .mysplit, .mx - 1, .my - 1, x1, dum, Col
                                  Form1.nobypasscheck = OldValue
                                    var(i).LastSelStart = x1
                                    var(i).ColorEvent = False
                                    ProcEditDoc = True
                                Else
                                    MissingDoc
                                    
                                End If
                            Else
                                   MissFuncParameterStringVar
                                    
                            End If
                        ElseIf y1 = 6 Then
                                    If pppp.ItemType(i) = doc Then
                                                  If pppp.item(i).LastSelStart > 0 And sX = 0 Then
                                x1 = pppp.item(i).LastSelStart
                               
                                    Else
                                    If sX = 0 Then sX = -1
                                    x1 = sX
                                End If
                                    Form1.TEXT1.Title = frm$ + " "
                                    Form1.TEXT1.TabWidth = 8 + 2 * dum
                                    Form1.TabControl = 8 + 2 * dum
                                    OldValue = Form1.nobypasscheck
                                  Form1.nobypasscheck = False
                                  ScreenEditDOC bstack, pppp.item(i), 0, .mysplit, .mx - 1, .my - 1, x1, dum, Col
                                  Form1.nobypasscheck = OldValue
                                    pppp.item(i).LastSelStart = x1
                                     pppp.item(i).ColorEvent = False
                                    ProcEditDoc = True
                                    
                                      Else
                                      MissingDoc
                                      
                                      End If
                               
                                    
                    Else
                          MissPar
                          
                    End If
End With
End Function
Function ProcVersion(bstack As basetask) As Boolean
Dim prive
prive = GetCode(bstack.Owner)
' from 8.8 rev 6 change
'PlainBaSket bstack.Owner, players(prive), CStr(App.Major) & "." & CStr((App.Minor \ 1000) - 1) & " (" & CStr(App.Minor Mod 1000) & ")"
PlainBaSket bstack.Owner, players(prive), CStr(App.Major) & "." & CStr((App.Minor \ 100)) & " (" & CStr(App.Minor Mod 100) & ")"
crNew bstack, players(prive)
ProcVersion = True
End Function
Function ProcSrcoll(bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, p As Variant, dum As Boolean
ProcSrcoll = True
If bstack.toprinter Then
MyEr "No scrolling for printer document", "╪ВИ ЙЩКИСГ ЦИА ТО щЦЦЯАЖО ЕЙТЩПЫСГР"
ProcSrcoll = False
Else
prive = GetCode(bstack.Owner)
If IsLabelSymbolNew(rest$, "йаты", "DOWN", Lang) Then
    ScrollDownNew bstack.Owner, players(prive)
ElseIf IsLabelSymbolNew(rest$, "выяисла", "SPLIT", Lang) Then
If IsExp(bstack, rest$, p) Then
With players(prive)
    If p < 0 Then p = .my + p
    If p >= 0 And p < .my Then .mysplit = p
End With
Else
ProcSrcoll = False
SyntaxError
End If
Else
 dum = IsLabelSymbolNew(rest$, "амы", "UP", Lang)
ScrollUpNew bstack.Owner, players(prive)


End If
End If

End Function
Function ProcStack(bstack As basetask, rest$, Lang As Long) As Boolean
Dim ss$, frm$, ps As mStiva, it As Long, X As Variant, x0 As Double, s$, once As Boolean, prive As Long
Dim x1 As Long, pa$, what$, i As Long, pppp As mArray, f As Long, myobject As Object, nd&, usehandler As mHandler
ProcStack = True
   If IsLabelSymbolNew(rest$, "меос", "NEW", Lang) Then
   If FastSymbol(rest$, "{") Then
ss$ = block(rest$)
Set ps = bstack.soros
Set bstack.Sorosref = New mStiva
TraceStore bstack, nd&, rest$, 0
rest$ = Mid$(rest$, 2)
Call executeblock(it, bstack, ss$, False, once, , True)
bstack.addlen = nd&
Set bstack.Sorosref = ps
Set ps = Nothing
If it = 2 Then
If ss$ = "" Then
If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
Else
rest$ = ": Goto " + ss$
If trace Then WaitShow = 2: TestShowSub = rest$
End If

it = 1
End If
If it <> 1 Then ProcStack = False: rest$ = ss$ + rest$
Exit Function
End If
'End If
   Else
If FastSymbol(rest$, "!") Then
If VALIDATEpart(rest$, s$) Then
Do While s$ <> ""
If ISSTRINGA(s$, pa$) Then
bstack.soros.DataStr pa$
ElseIf IsNumberD2(s$, X) Then
bstack.soros.DataVal X
X = vbEmpty
Else
Exit Do
End If
Loop
Else
again:

If IsExp(bstack, rest$, X) Then
If bstack.lastobj Is Nothing Then
    'SyntaxError
Else
If TypeOf bstack.lastobj Is mHandler Then
    Set usehandler = bstack.lastobj
    If TypeOf usehandler.objref Is mArray Then
        
        bstack.soros.MergeBottomCopyArray usehandler.objref
    ElseIf TypeOf usehandler.objref Is mStiva Then
        bstack.soros.MergeBottom usehandler.objref
    End If
    Set usehandler = Nothing
ElseIf TypeOf bstack.lastobj Is mArray Then
    bstack.soros.MergeBottomCopyArray bstack.lastobj
End If
Set bstack.lastobj = Nothing
If FastSymbol(rest$, ",") Then FastSymbol rest$, "!": GoTo again

    Exit Function
End If
End If
ProcStack = False
End If
Exit Function
Else
' STACK A$
' stack a$, "NN"
If lookOne(rest$, ".") Then
If IsStrExp(bstack, rest$, ss$) Then
    GoTo isAstring
ElseIf IsExp(bstack, rest$, X) Then
    GoTo isAnobject
Else
    SyntaxError
    ProcStack = False
End If
Exit Function
Else
x1 = Abs(IsLabel(bstack, rest$, what$))
End If
If x1 = 3 Then
    If Not FastSymbol(rest$, "+") Then
        If GetVar(bstack, what$, it) Then
            ss$ = var(it)
            If FastSymbol(rest$, ",") Then
                If Not IsStrExp(bstack, rest$, pa$) Then ProcStack = False: Exit Function
            End If
            If VALIDATE(ss$, pa$, frm$) Then
                IsSymbol3 pa$, ","
                    If Typename(var(it)) = doc Then
                        Set var(it) = New Document
                        var(it).textDoc = pa$
                    Else
                        var(it) = pa$
                    End If
                    Set ps = New mStiva
                i = 1
                Do While i <= Len(frm$) And ss$ <> ""
                    If Mid$(frm$, i, 1) = "S" Then
                        If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                    Else
                        X = vbEmpty
                        If IsNumberD2(ss$, X) Then ps.DataVal X
                    End If
                    IsSymbol ss$, ","
                    i = i + 1
                Loop
                With bstack
                    If .SorosNothing Then
                        Set .Sorosref = ps
                    Else
                        .soros.MergeTop ps
                    End If
                End With
            Else
                MyEr "Stack can't read choosen types", "о СЫЯЭР ДЕМ ЛПОЯЕъ МА ДИАБэСЕИ ТОУР ЕПИКЕЦЛщМОУР ТЩПОУР"
                ProcStack = False
                Exit Function
            End If
        Else
            Nosuchvariable what$
        End If
    Else
        If Not GetVar(bstack, what$, it) Then ProcStack = False: Exit Function
        what$ = var(it)
        
        If IsStrExp(bstack, rest$, ss$) Then
            pa$ = vbNullString
            ss$ = what$ + ss$
            If VALIDATE(ss$, pa$, frm$) Then
                Set ps = New mStiva
                i = 1
                Do While i <= Len(frm$) And ss$ <> ""
                    If Mid$(frm$, i, 1) = "S" Then
                        If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                    Else
                        If IsNumberD(ss$, x0) Then ps.DataVal x0
                    End If
                    IsSymbol ss$, ","
                    i = i + 1
                Loop
                With bstack
                     If .SorosNothing Then
                        Set .Sorosref = ps
                     Else
                        .soros.MergeTop ps
                     End If
                End With
            End If
        Else
            ProcStack = False
            Exit Function
        End If
    End If
ElseIf x1 = 6 Then
    If neoGetArray(bstack, what$, pppp) Then
        If Not NeoGetArrayItem(pppp, bstack, what$, f, rest$) Then ProcStack = False: Exit Function
        ss$ = pppp.item(f)
        If FastSymbol(rest$, ",") Then
            If Not IsStrExp(bstack, rest$, pa$) Then ProcStack = False: Exit Function
        End If
        
        If VALIDATE(ss$, pa$, frm$) Then
            IsSymbol3 pa$, ","
            If pppp.ItemType(f) = doc Then
                s$ = pppp.item(f)
                Set pppp.item(f) = New Document
                If s$ <> "" Then
                    pppp.item(f).textDoc = s$
                End If
            Else
                pppp.item(f) = pa$
            End If
            Set ps = New mStiva
            i = 1
            Do While i <= Len(frm$) And ss$ <> ""
                If Mid$(frm$, i, 1) = "S" Then
                    If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                Else
                    If IsNumberD(ss$, x0) Then ps.DataVal x0
                End If
                IsSymbol ss$, ","
                i = i + 1
            Loop
            With bstack
                If .SorosNothing Then
                    Set .Sorosref = ps
                Else
                    .soros.MergeTop ps
                End If
            End With
        'stack$(bstack) = ss$ & stack$(bstack)
        Else
            MyEr "String has no valid stack", "тО АКЖАЯИХЛГТИЙЭ ДЕМ щВЕИ щЦЙУЯА СТОИВЕъА СЫЯОЩ"
        End If
    Else
    GoTo conthere
    End If
Else
conthere:
  If Len(what$) > 0 Then rest$ = what$ & rest$
    If IsStrExp(bstack, rest$, ss$) Then
isAstring:
        pa$ = vbNullString
        If VALIDATE(ss$, pa$, frm$) Then
                Set ps = New mStiva
                i = 1
                Do While i <= Len(frm$) And ss$ <> ""
                If Mid$(frm$, i, 1) = "S" Then
                    If ISSTRINGA(ss$, pa$) Then ps.DataStr pa$
                Else
                    If IsNumberD(ss$, x0) Then ps.DataVal x0
                End If
                IsSymbol ss$, ","
                i = i + 1
                Loop
                With bstack
                    If .SorosNothing Then
                        Set .Sorosref = ps
                    Else
                        .soros.MergeTop ps
                    End If
                End With
                'stack$(bstack) = ss$ & stack$(bstack)
        
        Else
            ProcStack = False

        End If
                    Exit Function
    ElseIf IsExp(bstack, rest$, X) Then
isAnobject:
        Set myobject = bstack.lastobj
        Set bstack.lastobj = Nothing
        If Err Then MyEr "Not a stack", "дЕМ ЕъМАИ СЫЯЭР": Exit Function
        If CheckDeepAny(myobject) Then
            If Not TypeOf myobject Is mStiva Then MyEr "Not a stack", "дЕМ ЕъМАИ СЫЯЭР": Exit Function
            If FastSymbol(rest$, "{") Then
                ss$ = block(rest$)
                TraceStore bstack, nd&, rest$, 0
                If FastSymbol(rest$, "}") Then
                    Set ps = bstack.soros
                    Set bstack.Sorosref = myobject
                    
                    
                    Call executeblock(it, bstack, ss$, False, once, , True, True)
                    
                    Set bstack.Sorosref = ps
                    Set ps = Nothing
                    If it = 2 Then
                        If ss$ = "" Then
                        If once Then rest$ = ": Break": If trace Then WaitShow = 2: TestShowSub = vbNullString
                        Else
                        rest$ = ": Goto " + ss$
                        If trace Then WaitShow = 2: TestShowSub = rest$
                        End If
                        
                        it = 1
                        End If
                    If it <> 1 Then ProcStack = False: rest$ = ss$ + rest$
            
                End If
                bstack.addlen = nd&
            Else
            bstack.soros.MergeBottom myobject
                'MyEr "No Block {}", "дЕМ УПэЯВЕИ ЛПКОЙ ЕМТОКЧМ { }"
            End If
        Else
            MyEr "Nothing found", "дЕМ БЯчЙА ТъПОТА"
        End If
        Exit Function
End If
    i = 0
    With bstack.soros
    s$ = vbNullString
    Do
    i = i + 1
    If .Total < i Then Exit Do
    
    Select Case .StackItemType(i)
    Case "?"
    s$ = s$ & "(?) "
    Case "N", "L", "D"
    s$ = s$ & Trim$(Str(.StackItem(i))) & " "
    Case "S"
    ss$ = .StackItem(i)
        If Len(ss$) > 78 Then
        s$ = s$ & Chr(34) + Left$(ss$, 75) & ".." & Chr(34)
        Else
        s$ = s$ & Chr(34) + ss$ & Chr(34)
        End If
    Case ">"
    If Lang = 1 Then
    ss$ = "[Optional]"
    Else
    ss$ = "[пЯОАИЯЕТИЙЭ]"
    End If
        
        s$ = s$ & ss$
        
    
    Case Else
        Set myobject = .StackItem(i)
        If Not myobject Is Nothing Then
            If TypeOf myobject Is mHandler Then
                Set usehandler = myobject
                If usehandler.indirect > -1 Then
                    If MyIsObject(var(usehandler.indirect)) Then
                        If usehandler.indirect <= var2used Then
                            s$ = s$ + "*[" + Typename(var(usehandler.indirect)) + "]"
                        Else
                            s$ = s$ + "*[Error]"
                        End If
                    Else
                        s$ = s$ + "*[Nothing]"
                    End If
                Else
                    Select Case usehandler.t1
                    Case 1
                        s$ = s$ + "*[Inventory]"
                    Case 2
                        s$ = s$ + "*[Buffer]"
                    Case Else
                        s$ = s$ + "*[" + Typename(usehandler.objref) + "]"
                    End Select
                End If
            Else
                s$ = s$ + "*[" + Typename(myobject) + "]"
            End If
        Else
        s$ = s$ + "*[Nothing]"
        End If
    End Select
    Set usehandler = Nothing
    Loop
    
    Set myobject = Nothing
    End With
    prive = GetCode(bstack.Owner)
    PlainBaSket bstack.Owner, players(prive), s$
    crNew bstack, players(prive)
   ' PlainBaSket bstack.Owner, players(prive), "cash:" + Str$(TrushCount)
    'crNew bstack, players(prive)
    Exit Function
    End If
End If
End If

End Function
Function ProcFLOODFILL(bstack As basetask, rest$, Lang As Long) As Boolean
Dim x1 As Long, y1 As Long, Col As Long, p As Variant, par As Boolean

With players(GetCode(bstack.Owner))
par = IsLabelSymbolNew(rest$, "вяыла", "COLOR", Lang)
x1 = .XGRAPH
y1 = .YGRAPH
Col = .mypen
If IsExp(bstack, rest$, p) Then x1 = CLng(p)
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = CLng(p)
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then Col = CLng(p) Else MissNumExpr: Exit Function
Ffill bstack.Owner, (x1), (y1), Col, par
End With
MyDoEvents1 bstack.Owner
ProcFLOODFILL = True
End Function
Function ProcFill(bstack As basetask, rest$) As Boolean
Dim prive As Long, X As Double, p As Variant, Y As Double, x1 As Long, y1 As Long, par As Boolean, Col As Long
Dim Scr As Object, ss$
Set Scr = bstack.Owner
prive = GetCode(Scr)
With players(prive)
If FastSymbol(rest$, "@") Then par = True
x1 = 0
y1 = 1
Col = players(prive).mypen
If IsExp(bstack, rest$, p) Then x1 = p
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then y1 = p

Scr.currentX = .XGRAPH
Scr.currentY = .YGRAPH
If par Then

'*****************
Y = 5
If FastSymbol(rest$, ",") Then If Not IsExp(bstack, rest$, Y) Then Y = 5
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, X) Then
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, p) Then
MyFill Scr, (x1), (y1), (Y), (X), (p)
Else
    MissNumExpr
    Exit Function
End If
Else
MyFill Scr, (x1), (y1), (Y), (X)
End If
ElseIf IsStrExp(bstack, rest$, ss$) Then
MyFill Scr, (x1), (y1), (Y), ss$
Else
MyFill Scr, (x1), (y1), 5, "?"
End If
Else
MyFill Scr, (x1), (y1), 6, 0
End If

'*******************
Else
If FastSymbol(rest$, ",") Then If IsExp(bstack, rest$, p) Then Col = p Else MissNumExpr: Exit Function
If FastSymbol(rest$, ",") Then 'ok
par = False
    If Not IsExp(bstack, rest$, X) Then
        If Col = 0 Then X = rgb(255, 255, 255) Else X = 0
        Else
        par = True
    End If
    Y = True
    If FastSymbol(rest$, ",") Then 'ok
        If IsExp(bstack, rest$, Y) Then
            Y = Y <> 0
            par = True
        End If
    End If
    p = True
    If FastSymbol(rest$, ",") Then
        If IsExp(bstack, rest$, p) Then
            p = p <> 0
            par = True
        End If
    End If
    If par Then
    If CBool(p) And Not .NoGDI Then
    If Y Then
    GdiPlusGradient bstack.Owner.hdc, .XGRAPH / dv15, .YGRAPH / dv15, (x1 + .XGRAPH) / dv15, (y1 + .YGRAPH) / dv15, GDIP_ARGB1(.mypentrans, CLng(mycolor(Col))), GDIP_ARGB1(.mypentrans, CLng(mycolor(X))), -CLng(Y <> 0)
    Else
    GdiPlusGradient bstack.Owner.hdc, .XGRAPH / dv15, .YGRAPH / dv15, (x1 + .XGRAPH) / dv15, (y1 + .YGRAPH) / dv15, GDIP_ARGB1(.mypentrans, CLng(mycolor(X))), GDIP_ARGB1(.mypentrans, CLng(mycolor(Col))), -CLng(Y <> 0)
    End If
    Else
If .NoGDI And .IamEmf Then
DrawFrameForEmf Scr, .XGRAPH, .YGRAPH, x1 + .XGRAPH, y1 + .YGRAPH
Else

   TwoColorsGradientPart Scr, CBool(p), -CLng(Y <> 0), .XGRAPH, .YGRAPH, x1 + .XGRAPH, y1 + .YGRAPH, mycolor(Col), mycolor(X)
End If
   End If
    .XGRAPH = .XGRAPH + x1
    .YGRAPH = .YGRAPH + y1
    MyRefresh bstack
    'MyDoEvents1 Scr
    Set Scr = Nothing
    ProcFill = True
    Exit Function
    End If
    Set Scr = Nothing
MissNumExpr:  Exit Function
Else
If TypeOf Scr Is MetaDc Then
jump:
    Dim mm As MetaDc
    Set mm = Scr
    x1 = x1 + .XGRAPH
    y1 = y1 + .YGRAPH
    'mm.Line2 .XGRAPH, .YGRAPH, x1, y1, mycolor(Col), True
    
    mm.fillstyle = vbSolid
    mm.fillcolor = mycolor(Col)
    DrawFrameForEmf Scr, .XGRAPH, .YGRAPH, x1, y1
  .XGRAPH = x1
    .YGRAPH = y1
Else
Scr.Line (.XGRAPH, .YGRAPH)-Step(x1 - dv15, y1 - dv15), mycolor(Col), BF
.XGRAPH = Scr.currentX + dv15
.YGRAPH = Scr.currentY + dv15
End If
End If
End If


End With
MyRefresh bstack
'MyDoEvents1 Scr
Set Scr = Nothing
ProcFill = True
End Function
Function MyCursor(bstack As basetask, rest$) As Boolean
Dim prive As Long, x1 As Long, y1 As Long, p As Variant
prive = GetCode(bstack.Owner)
MyCursor = True
With players(prive)
If FastSymbol(rest$, "!") Then
 .curpos = .XGRAPH \ .Xt
  .currow = (.YGRAPH) \ .Yt '(.Yt + .uMineLineSpace)
ElseIf IsExp(bstack, rest$, p) Then
x1 = CLng(p) Mod 1000 '' Mod (.mx + 1)
If FastSymbol(rest$, ",") Then
If IsExp(bstack, rest$, p) Then
y1 = CLng(p) Mod 1000   ''Mod (.my + 1)
.curpos = x1
.currow = y1

Else
MyCursor = False
End If
Else
.curpos = x1
End If
.lastprint = False
Else
If FastSymbol(rest$, ",") Then
    If IsExp(bstack, rest$, p) Then
    y1 = CLng(p) Mod 1000   ''Mod (.my + 1)
    .currow = y1
    Else
    MyCursor = False
    End If
End If
.lastprint = False
End If
End With
LCTbasketCur bstack.Owner, players(prive)
End Function
Function MyMenu(entrypoint As Long, bstack As basetask, rest$, Lang As Long) As Boolean
Dim prive As Long, p As Variant, par As Boolean, x1 As Long, y1 As Long, Col As Long
Dim frm$, it As Long, s$, f As Long
MyMenu = True
If entrypoint = 1 Then GoTo ekei
If bstack.toprinter Then
oxiforPrinter
 MyMenu = False
Exit Function
End If
prive = GetCode(bstack.Owner)
If prive > 32 Then
    If Left$(Typename(bstack.Owner), 3) = "Gui" Then oxiforforms: Exit Function
    If TypeOf bstack.Owner Is MetaDc Then oxiforMetaFiles: Exit Function
    If TypeOf bstack.Owner Is VB.PictureBox Then oxiforImages: Exit Function
End If
            If IsLabelSymbolNew(rest$, "деине", "SHOW", Lang) Then
                If Form1.List1.Visible Then
                        If IsStrExp(bstack, rest$, s$) Then
                            p = Form1.List1.Find(s$)
                        ElseIf IsExp(bstack, rest$, p) Then
                            p = p - 1
                        Else
                            SyntaxError
                            MyMenu = False
                        End If
                        If p <> -1 Then
                            If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then  ' CHANGE MENU ITEM IN AN OPEN MENU
                                If IsStrExp(bstack, rest$, s$) Then
                                    Form1.List1.list(CLng(p)) = s$
                                Else
                                   MissStringExpr
                                  MyMenu = False
                                End If
                            End If
                            If Not FastSymbol(rest$, ";") Then Form1.List1.ShowThis CLng(p + 1) Else Form1.List1.ShowMe2
                        End If
                Else
                        If Form1.List1.listcount > 0 Then  ' YOU CAN OPEN A MENU WITH A START ITEM OTHER THAN 1
                            If IsStrExp(bstack, rest$, s$) Then
                                p = Form1.List1.Find(s$)
                            ElseIf IsExp(bstack, rest$, p) Then
                                p = p - 1
                            Else
                               SyntaxError
                               MyMenu = False
                            End If
                            If p <> -1 Then
                                If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then  ' CHANGE MENU ITEM IN AN OPEN MENU
                                ' IN A THREAD OR IN A @ VARIANT
                                    If IsStrExp(bstack, rest$, s$) Then
                                        Form1.List1.list(CLng(p)) = s$
                                    Else
                                        MissStringExpr
                                        MyMenu = False
                                    End If
                                Else
                                    If p < Form1.List1.listcount Then Form1.List1.ListIndex = CLng(p)
                                End If
                        End If
                        frm$ = Form1.List1.Tag
                End If
                GoTo ekei
        End If
    ElseIf IsLabelSymbolNew(rest$, "пкаисио", "FRAME", Lang) Then
            Form1.List1.BorderStyle = 1 - Abs(IsLabelSymbolNew(rest$, "ови", "OFF", Lang))
    ElseIf IsLabelSymbolNew(rest$, "баье", "FILL", Lang) Then
        If IsExp(bstack, rest$, p) Then
        Form1.List1.CapColor = mycolor(p)
        LEVCOLMENU = 1
        If FastSymbol(rest$, ",") Then
            If IsExp(bstack, rest$, p) Then
                   Form1.List1.BackColor = mycolor(p)
                   LEVCOLMENU = 2
                           If FastSymbol(rest$, ",") Then
                                If IsExp(bstack, rest$, p) Then
                                   Form1.List1.forecolor = mycolor(p)
                                   LEVCOLMENU = 3
                                   Else
                                   MissNumExpr
                                               MyMenu = False
                                   End If
                        End If
            
                   Else
                   MissNumExpr
                               MyMenu = False
                   End If
            End If
     
        Else
        MissNumExpr
                    MyMenu = False
        End If
        ElseIf IsLabelSymbolNew(rest$, "титкос", "TITLE", Lang) Then
        If Not IsStrExp(bstack, rest$, s$) Then Exit Function
        If Right$(s$, 2) = vbCrLf Then s$ = Left$(s$, Len(s$) - 2)
        Form1.List1.Enabled = Form1.List1.Visible
    
        Form1.List1.HeadLine = s$
        Form1.List1.FloatList = Not IsLabelSymbolNew(rest$, "йяатгсе", "HOLD", Lang)
        ElseIf IsLabelSymbolNew(rest$, "епикене", "SELECT", Lang) Then
        '' If Form1.List1.LeaveonChoose Then

         Form1.List1.PressSoft

        '' End If
        Else
If FastSymbol(rest$, "@") Then
    par = True
    If Not IsStrExp(bstack, rest$, s$) Then Exit Function
    frm$ = s$
    If FastSymbol(rest$, "!") Then GoTo ekei
    If Not FastSymbol(rest$, ",") Then Exit Function
    
    Else
    par = False
    End If
    If FastSymbol(rest$, "+") Then
    If Not IsStrExp(bstack, rest$, s$) Then Exit Function

    Form1.List1.additemFast s$
       While FastSymbol(rest$, ",")
    If Not IsStrExp(bstack, rest$, s$) Then MyMenu = False: Exit Function
    Form1.List1.additemFast s$
    Wend
   If Form1.List1.LeaveonChoose Then GoTo ekei Else Exit Function
    
    End If
    If Not FastSymbol(rest$, "!") Then
    If Form1.List1.Enabled = True Then
    Form1.List1.Visible = False
    If Not par Then Form1.List1.HeadLine = vbNullString
    End If
    If entrypoint = 2 Then GoTo ekei
    Form1.List1.Enabled = False
    
    Form1.List1.Clear

    If Not IsStrExp(bstack, rest$, s$) Then
  bstack.Owner.TabStop = False
    Form1.List1.Tag = vbNullString
    Form1.List1.HeadLine = vbNullString: Form1.KeyPreview = True: Exit Function
    End If
    
    
    Form1.List1.additemFast s$
    If TextWidth(bstack.Owner, s$) > f Then f = TextWidth(bstack.Owner, s$)
    While FastSymbol(rest$, ",")
    If Not IsStrExp(bstack, rest$, s$) Then MyMenu = False: Exit Function
    Form1.List1.additemFast s$
    If TextWidth(bstack.Owner, s$) > f Then f = TextWidth(bstack.Owner, s$)
    Wend
    'f = f \ .xt + 1
    Else
ekei:
    it = Form1.List1.listcount
    f = 0
    If it > 0 Then
    With Form1.List1
            
            For it = it - 1 To 0 Step -1
            If TextWidth(bstack.Owner, .list(it)) > f Then f = TextWidth(bstack.Owner, .list(it))
            
            Next
    End With
    End If
    End If
    
    
    it = Form1.List1.listcount
With players(prive)
If .lastprint Then
x1 = (bstack.Owner.currentX + .Xt - dv15) \ .Xt
If x1 < 0 Then x1 = 0
If x1 > .mx Then x1 = .mx - 1
Else
x1 = .curpos

End If
y1 = .currow
If x1 < 0 Then
  x1 = 0
  ElseIf x1 > .mx Then
  x1 = .mx - 1
  Else
  
  ''    GetXYb scr, players(prive), .curpos, .currow
    End If
    f = Int(f / TextWidth(bstack.Owner, "W") + 0.5)
    If it > 0 Then
            If f < 4 Then f = 4  ' 4 chars minimum
            If f > .mx Then f = .mx  ' .mx maximum
            If f + x1 > .mx Then x1 = .mx - f - 1
            If it > .my \ 2 Then it = .my \ 2
            If CLng(.my - y1) < it Then  ' need space above
                 y1 = .currow - it
            End If

            If Not Form1.Visible Then newshow Basestack1: MyDoEvents
            bstack.Owner.Refresh
                If Not Form1.List1.Visible Then
                    If Not bstack.Owner.Visible Then bstack.Owner.Visible
                    If bstack.tolayer Then bstack.Owner.ZOrder 0
                End If
                With Form1.List1
            .Enabled = True
            .NoPanRight = False
            .NoFreeMoveUpDown = True
            .FreeMouse = True
            .SingleLineSlide = True
            SetTextBasketBack bstack.Owner, players(prive)
            .overrideTextHeight = .overrideTextHeight   ' fonttest.TextHeight("fj")
            End With
            Form1.lastitem = 0
    ListChoise bstack, frm$, x1, y1, f + x1, it + y1 - 1
    INK$ = vbNullString
    ''UINK$ = VbNullString
    MINK$ = vbNullString
    End If
    '------------------------
End With

End If
End Function

Function ProcDrop(basestack As basetask, rest$, Lang As Long) As Boolean
Dim X As Double, usehandler As mHandler, tmp As FastCollection

If Not IsExp(basestack, rest$, X) Then

X = 1
Else
If Not basestack.lastobj Is Nothing Then
If TypeOf basestack.lastobj Is mHandler Then
Set usehandler = basestack.lastobj
    If usehandler.ReadOnly Then
        ReadOnly
        ProcDrop = False
        Exit Function
    End If
    If usehandler.t1 <> 1 Then OnlyForInventory: Exit Function
    If TypeOf usehandler.objref Is FastCollection Then
        Set tmp = usehandler.objref
        If IsLabelSymbolNew(rest$, "еыс", "TO", Lang) Then
            If IsExp(basestack, rest$, X) Then
                tmp.drop X + 1
                ProcDrop = True
            Else
                MissNumExpr
            End If
        Else
            FastSymbol rest$, ","  ' optional
            If IsExp(basestack, rest$, X) Then
                tmp.drop tmp.count - X + 1
                ProcDrop = True
            Else
                tmp.drop tmp.count
                ProcDrop = True
            End If
        End If
    End If
End If
Exit Function
End If
End If

If X < 0 Then
     
        MyEr "No many items to drop from stack", "дЕМ УПэЯВОУМ ТИЛщР МА ПЕТэНЫ АПЭ ТО СЫЯЭ"
Exit Function
End If

If X = 0 Then
    ' do nothing
    ProcDrop = True
Else
If X > basestack.soros.Total Then
MissStackItem
Exit Function
    ElseIf X = basestack.soros.Total Then
    basestack.soros.Flush
    Else
    basestack.soros.drop CLng(X)
    End If
    ProcDrop = True
    End If

End Function
Function ProcShift(basestack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, i As Long
ProcShift = True
If Not IsExp(basestack, rest$, X) Then X = basestack.soros.Total
If X <= 0 Then
     
        MyEr "No negatives or zero", "╪ВИ АЯМГТИЙОъ ч ЛГДщМ"
Exit Function
End If
If X > basestack.soros.Total Then
MissStackItem

Exit Function
    Else

    If FastSymbol(rest$, ",") Then
        If IsExp(basestack, rest$, Y) Then
        Y = Int(Y)
        If Y < 0 Then
        Y = Abs(Y)
        X = X - 1
        If CLng(X + Y) > basestack.soros.count Then Y = basestack.soros.count - X
        For i = X + 1 To X + Y
        
         basestack.soros.MakeTopItem CLng(i)
      
        Next i
        Else
           'y = y - 1
If CLng(X + Y - 1) > basestack.soros.count Then Y = basestack.soros.count - X + 1

        For i = Y To 1 Step -1
        
         basestack.soros.MakeTopItem CLng(X + Y - 1)
      
        Next i

        End If
    End If
    Else
        basestack.soros.MakeTopItem CLng(X)
    End If
    End If


End Function
Function ProcShiftBack(basestack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, i As Long
ProcShiftBack = True
If Not IsExp(basestack, rest$, X) Then X = basestack.soros.Total
If X <= 0 Then
     
        MyEr "No negatives or zero", "╪ВИ АЯМГТИЙОъ ч ЛГДщМ"

Exit Function
End If
If X > basestack.soros.Total Then
MissStackItem

Exit Function
    Else
    
    
        If FastSymbol(rest$, ",") Then
        If IsExp(basestack, rest$, Y) Then
        If Y < 0 Then
        Y = Abs(Int(Y))
        X = X - 1
          If CLng(X + Y) > basestack.soros.count Then Y = basestack.soros.count - X
        For i = Y To 2 Step -1
        
         basestack.soros.MakeTopItemBack CLng(i + X)
      
        Next i
        If X > 0 Then basestack.soros.MakeTopItemBack CLng(i + X)
        Else
        Y = Int(Y)
        If CLng(X + Y - 1) > basestack.soros.count Then Y = basestack.soros.count - X + 1

        For i = 1 To Y
        basestack.soros.MakeTopItemBack CLng(X + Y - 1)
        Next i
     
        End If
    End If
    Else
    basestack.soros.MakeTopItemBack CLng(X)
    End If
    End If
End Function
Function ProcOver(basestack As basetask, rest$) As Boolean
Dim X As Double, Y As Double, i As Long
ProcOver = True
If Not IsExp(basestack, rest$, X) Then X = 1
    If X <= 0 Then
         
            MyEr "No negatives or zero", "╪ВИ АЯМГТИЙОъ ч ЛГДщМ"
    Exit Function
    End If
    If X > basestack.soros.Total Then
        MissStackItem
        
        Exit Function
    Else
        If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, Y) Then
            Y = Int(Y)
                For i = 1 To Y
                    basestack.soros.Copy2TopItem CLng(X)
                Next i
            Else
                MissPar
            End If
        Else
            basestack.soros.Copy2TopItem CLng(X)
        End If
    End If

End Function
Function ProcWords(basestack As basetask, rest$) As Boolean
Dim x1 As Long, y1 As Long, s$, sX As Double, i As Long, p As Variant, pppp As mArray
ProcWords = True
    y1 = Abs(IsLabel(basestack, rest$, s$))

    If y1 = 6 Then
                If neoGetArray(basestack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, basestack, s$, i, rest$) Then Exit Function
                Else
                MissingDoc
                Exit Function
                End If
    End If
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, sX) Then    ' FROM
            MissNumExpr
            Exit Function
        End If
    Else
 sX = 1
    End If
    
        If y1 = 3 Then
            If GetVar(basestack, s$, i) Then
                If Typename(var(i)) = doc Then
                basestack.soros.Begin 1
                var(i).ExportWords2ObjectAddItem basestack.soros, sX <> 0
                var(i).ResetWords
                    
                Else
                    MissingDoc
                    Exit Function
                End If
            Else
                   MissFuncParameterStringVar
                   Exit Function
                    
            End If
        ElseIf y1 = 6 Then
                    If pppp.ItemType(i) = doc Then
                        basestack.soros.Begin 1
                         pppp.item(i).ExportWords2ObjectAddItem basestack.soros, sX <> 0
                         pppp.item(i).ResetWords
                      Else
                      MissingDoc
                      Exit Function
                      End If
               
                    
    Else
                    
                MissPar
                Exit Function
    End If

End Function
Function ProcPropeties(basestack As basetask, rest$) As Boolean
Dim s$
  If IsStrExp(basestack, rest$, s$) Then
  LoadArray MyDM(), s$
  Else
  SyntaxError
  Exit Function
  End If
ProcPropeties = True
End Function
Function ProcFlush(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pppp As mArray, what$, it As Long, y1 As Long
If IsLabelSymbolNew(rest$, "кахос", "ERROR", Lang) Then
         NOEXECUTION = False
         NERR = False
           LastErNum1 = 0
         LastErNum = 0
            LastErName = vbNullString
            LastErNameGR = vbNullString
ElseIf IsLabelSymbolNew(rest$, "сйоупидиа", "GARBAGE", Lang) Then
    GarbageFlush2
Else
Do
    y1 = Abs(IsLabel(basestack, rest$, what$))
    If y1 = 0 Then
     If it = 0 Then basestack.soros.Flush
    Else
        If y1 = 3 Then
            If GetVar(basestack, what$, it) Then
                If Typename(var(it)) = doc Then
                    var(it).EmptyDoc
                Else
                      SyntaxError
                        Exit Function
                End If
            Else
                  SyntaxError
                        Exit Function
            End If
        ElseIf y1 = 6 Then
        If neoGetArray(basestack, what$, pppp) Then
        If Not pppp.Arr Then NotArray: Exit Function
                If Not NeoGetArrayItem(pppp, basestack, what$, it, rest$) Then Exit Function
                         If pppp.ItemType(it) = doc Then
                         Set pppp.item(it) = New Document
                         pppp.item(it).EmptyDoc
                         Else
                      SyntaxError
                        Exit Function
                         End If
                 
       Else
       SyntaxError
        Exit Function
       End If
        End If
    End If
    Loop Until Not FastSymbol(rest$, ",")
End If
ProcFlush = True
End Function
Function ProcOpenImage(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pa$, ss$, frm$, s$, w$, Scr As Object, x1 As Long
Dim aaa() As String
If IsSelectorInUse Then
SelectorInUse
Exit Function
End If
olamazi
 
frm$ = mcd
DialogSetupLang Lang

IsStrExp basestack, rest$, s$
If FastSymbol(rest$, ",") Then If IsStrExp(basestack, rest$, pa$) Then frm$ = pa$
If frm$ <> "" Then If Not isdir(frm$) Then NoSuchFolder: Exit Function
If FastSymbol(rest$, ",") Then If IsStrExp(basestack, rest$, pa$) Then ss$ = pa$
If FastSymbol(rest$, ",") Then If Not IsStrExp(basestack, rest$, w$) Then MissNumExpr:  Exit Function
If TypeOf basestack.Owner Is GuiM2000 Then
Set Scr = basestack.Owner
Else
         If Form1.Visible Then
        Set Scr = Form1
        Else
        Set Scr = Nothing
        End If
End If
If InStr(w$, "|") > 0 Then
If InStr(w$, "(*.") > 0 Then
aaa() = Split(w$, "(*.")
Else
aaa() = Split(w$, "|")
End If
w$ = vbNullString
If UBound(aaa()) > LBound(aaa()) Then
w$ = "|"
For x1 = LBound(aaa()) + 1 To UBound(aaa())
w$ = w$ & UCase(Left$(aaa(x1), InStr(aaa(x1), ")") - 1) & "|")
Next x1
End If
End If
    If OpenImage(basestack, Scr, frm$, s$, ss$, w$) Then
    ' push to stack
    If multifileselection Then
    If ReturnListOfFiles <> "" Then
    aaa() = Split(ReturnListOfFiles, "#")
    If UBound(aaa()) > LBound(aaa()) Then

For x1 = UBound(aaa()) To LBound(aaa()) + 1 Step -1
    basestack.soros.PushStr aaa(x1)
Next x1
basestack.soros.PushVal UBound(aaa()) - LBound(aaa())
basestack.soros.PushStr aaa(x1)
End If
Else
    basestack.soros.PushStr ReturnFile
    End If
    Else
    basestack.soros.PushStr ReturnFile
    End If
    Else
    basestack.soros.PushStr ""
    End If

Set Scr = Nothing
ProcOpenImage = True
End Function
Function ProcRelease(basestack As basetask) As Boolean
' make this for each Guim2000 form also
If basestack.Owner.Name = "DIS" Then
    Form1.MY_BACK.PaintPicture Form1.DIS.hdc
ElseIf Typename(basestack.Owner) = "GuiM2000" Then
    Dim a As GuiM2000
    Set a = basestack.Owner
    If a.Sizable Then
        MyEr "Not for User forms with resize function", "╪ВИ ЦИА ЖЭЯЛЕР ВЯчСТГ ЛЕ ДУМАТЭТГТА АККАЦчР ЛЕЦщХОУР"
    Else
    
        a.MY_BACK.PaintPicture a.hdc
    End If
    Set a = Nothing
ElseIf basestack.Owner Is Form1 Then
Form1.Back_Back.PaintPicture Form1.hdc
ElseIf TypeOf basestack.Owner Is VB.PictureBox Then
    On Error GoTo there1
    Dim p As Long
    p = GetCode(basestack.Owner)
    If p > 32 Then
        If getvar2(basestack, players(p).controlname, p, True) Then
            Dim B As GuiImage
            Set B = var(p)
            If Not B.MY_BACK Is Nothing Then
                With B
                    .MY_BACK.PaintPicture .pbox.hdc
                    Set B = Nothing
                End With
            End If
        End If
    End If
End If
ProcRelease = True
Exit Function
there1:
Err.Clear
End Function
Function ProcHold(basestack As basetask) As Boolean
' make this for each Guim2000 form also
Dim p As Long
If basestack.Owner.Name = "DIS" Then
    Form1.MY_BACK.ClearUp
    If Form1.MY_BACK.create(Form1.DIS.Width / DXP, Form1.DIS.Height / DYP) Then
        Form1.MY_BACK.LoadPictureBlt Form1.DIS.hdc
        If Form1.MY_BACK.bitsPerPixel <> 24 Then Conv24 Form1.MY_BACK
    End If
ElseIf Typename(basestack.Owner) = "GuiM2000" Then
    Dim a As GuiM2000
    Set a = basestack.Owner
    If a.MY_BACK Is Nothing Then Set a.MY_BACK = New cDIBSection
        If a.Sizable Then
            MyEr "Not for User forms with resize function", "╪ВИ ЦИА ЖЭЯЛЕР ВЯчСТГ ЛЕ ДУМАТЭТГТА АККАЦчР ЛЕЦщХОУР"
        Else
            With a
            .MY_BACK.ClearUp
                If .MY_BACK.create(.Width / DXP, .Height / DYP) Then
                    .MY_BACK.LoadPictureBlt .hdc
                    If .MY_BACK.bitsPerPixel <> 24 Then Conv24 .MY_BACK
                End If
                Set a = Nothing
            End With
    End If
ElseIf basestack.Owner Is Form1 Then
    Form1.Back_Back.ClearUp
    If Form1.Back_Back.create(Form1.Width / DXP, Form1.Height / DYP) Then
        Form1.Back_Back.LoadPictureBlt Form1.hdc
        If Form1.Back_Back.bitsPerPixel <> 24 Then Conv24 Form1.Back_Back
    End If
ElseIf TypeOf basestack.Owner Is VB.PictureBox Then
On Error GoTo there1
p = GetCode(basestack.Owner)
If p > 32 Then
If getvar2(basestack, players(p).controlname, p, True) Then
    Dim B As GuiImage
    Set B = var(p)
    If B.MY_BACK Is Nothing Then Set B.MY_BACK = New cDIBSection
    With B
    .MY_BACK.ClearUp
        If .MY_BACK.create(.pbox.Width / DXP, .pbox.Height / DYP) Then
            .MY_BACK.LoadPictureBlt .pbox.hdc
            If .MY_BACK.bitsPerPixel <> 24 Then Conv24 .MY_BACK
        End If
        Set B = Nothing
    End With
End If
End If
End If
ProcHold = True
Exit Function
there1:
Err.Clear
End Function
Function ProcGet(basestack As basetask, rest$) As Boolean
Dim pppp As mArray, it As Long, what$, p As Variant, f As Variant, par As Boolean, s$, Arr As Boolean
Dim flag As Boolean, usehandler As mHandler, pp As Variant
IsSymbol3 rest$, "#"

If IsExp(basestack, rest$, p) Then
    f = Int(p)
    If Fkind(f) = FnoUse Or Fkind(f) = Foutput Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": ProcGet = False: Exit Function
    If Not FastSymbol(rest$, ",") Then GoTo ex123
    Select Case IsLabel(basestack, rest$, what$)
    Case 1  ' check to see if is a handler
        If GetVar(basestack, what$, it) Then
            pp = 0
            If Typename(var(it)) = mHdlr Then
                If var(it).ReadOnly Then
                    ReadOnly
                    GoTo ex123
                End If
            End If
            Set usehandler = var(it)
            flag = True
        End If
        par = False
    Case 5  'check for handler
        what$ = Left$(what$, Len(what$) - 1)
        If GetVar(basestack, what$, it) Then
            pp = 0
                If IsExp(basestack, rest$, pp) Then
                    ' nothing here
                    Arr = True
                End If
                If Not FastSymbol(rest$, ")") Then GoTo ex123
                If Not Typename(var(it)) = mHdlr Then GoTo ex123
                If var(it).ReadOnly Then
                    ReadOnly
                    GoTo ex123
                End If
                Set usehandler = var(it)
                flag = True
            End If
            par = False
        Case 3
            If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": ProcGet = False: Exit Function
            par = True: If Not GetVar(basestack, what$, it) Then it = globalvar(what$, "")
        Case 6
            If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": ProcGet = False: Exit Function
            par = False: If neoGetArray(basestack, what$, pppp) Then If Not NeoGetArrayItem(pppp, basestack, what$, it, rest$) Then GoTo ex123
        Case Else
            MissingStrVar
            GoTo ex123
        End Select
        If FastSymbol(rest$, ",") Then
            If IsExp(basestack, rest$, p) Then
                FileSeek(f) = (Int(p) - 1@) * Fstep(f) + 1@
            ElseIf Not flag Then
                MissNumExpr
                GoTo ex123
            End If
        End If
        If flag Then
            Dim buf As MemBlock
            Dim aa() As Byte
            Set buf = usehandler.objref
            With buf
                ' pp is offset
                If Fstep(f) = 1 Then
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, p) Then
                            p = Int(Abs(p))
                        If FastSymbol(rest$, ",") Then
                            If IsExp(basestack, rest$, pp) Then
                                pp = Int(Abs(pp))
                                If pp = 0 Then GoTo wrong
                                If .ValidArea(p, CLng(pp)) Then
                                    .GetData (f), p, CLng(pp)
                                Else
                                    GoTo wrong
                                End If
                            Else
                                MissNumExpr
                                ProcGet = False
                                GoTo ex123
                            End If
                        Else
                            MissNumExpr
                            ProcGet = False
                            GoTo ex123
                        End If
                    Else
                        MissNumExpr
                        ProcGet = False
                        GoTo ex123
                    End If
                Else
                    On Error Resume Next
                    .GetData (f), .GetBytePtr(0), .SizeByte
                End If
            Else
                If Arr Then
                    p = 1
                    If FastSymbol(rest$, ",") Then
                        If Not IsExp(basestack, rest$, p) Then
                            MissNumExpr
                            GoTo ex123
                        End If
                    End If
                    p = Int(Abs(p))
                    If p = 0 Then GoTo wrong
                    If .ValidArea2(pp, Fstep(f) * p) Then
                        .GetData (f), .GetPtr(pp), Fstep(f) * p
                    Else
wrong:
                        MyEr "Wrong size-position for loading the buffer", "кэХОР ЛщЦЕХОР-ХщСГ ЦИА МА ЖОЯТЫХЕъ Г дИэЯХЯЫСГ"
                        GoTo ex123
                    End If
                Else
                    .GetData (f), .GetPtr(0), .SizeByte
                End If
            End If
        End With
    Else
        Dim FH As Long
        FH = Module10.ReadFileHandler(CLng(f))
        If FH = 0 Then Exit Function
        FileReadString FH, s$, Fstep(f)
        If Not uni(f) Then
            If FastSymbol(rest$, ",") Then
                If Not IsExp(basestack, rest$, p, , True) Then MissPar: Exit Function
                On Error Resume Next
                s$ = StrConv(s$, vbUnicode, CLng(p))
                If Err Then Err.Clear: NoValidLocale: Exit Function
            Else
                s$ = StrConv(s$, vbUnicode, Clid)
            End If
        End If
        If par Then
            CheckVar var(it), s$
        Else
            If pppp.ItemType(it) = doc Then
                Set pppp.item(it) = New Document
                If s$ <> "" Then pppp.item(it).textDoc = s$
            Else
                pppp.item(it) = s$
            End If
        End If
    End If
End If
ProcGet = True
ex123:
Set pppp = Nothing
Set usehandler = Nothing
Set basestack.lastobj = Nothing
End Function
Function ProcPipe(basestack As basetask, rest$) As Boolean
Dim stac1$, ss$, p As Variant, s$
If IsStrExp(basestack, rest$, ss$) Then
If FastSymbol(rest$, ",") Then
stac1$ = vbNullString
Do
If IsExp(basestack, rest$, p, , True) Then
stac1$ = stac1$ & " " & Trim$(Str$(p))
ElseIf IsStrExp(basestack, rest$, s$) Then
stac1$ = stac1$ & Sput(s$)
Else
Exit Do
End If
If Not FastSymbol(rest$, ",") Then Exit Do
Loop

If VALIDATE(stac1$, "", s$) Then
ProcPipe = Trans2pipe(ss$, Sput(ss$) + Sput(s$) + stac1$)
Exit Function
End If
End If
End If
ProcPipe = True

End Function

Function ProcGroup(entrypoint As Long, basestack As basetask, rest$, Lang As Long) As Boolean
Dim s$, x1 As Long, y1 As Long, what$, flag As Boolean, ss$, i As Long, par As Boolean
Dim p As Variant, HasStrName As Boolean, strName$, NewStat As Boolean, addlen As Long
ProcGroup = True

Dim Y3 As Long
If entrypoint = -1 Then NewStat = True: entrypoint = 0
If entrypoint < 199 Then
If entrypoint = 1 Then flag = True
Y3 = IsLabelSymbolNew(rest$, "лецецомота", "WITHEVENTS", Lang)
If IsLabelSymbolNew(rest$, "ауто", "THIS", Lang) Then
    If Len(basestack.UseGroupname) > 0 Then
        MyEr "Not in a Group Definition: Remove Group This { }", "╪ВИ СЕ ОЯИСЛЭ ОЛэДАР: аЖАъЯЕСЕ ТГМ оЛэДА аУТЭ {} "
        Exit Function
    Else
    s$ = vbNullString
' s$ = "."
     If basestack.GetDotNew(s$, 1) Then
 
            If Len(s$) = 0 Then: Exit Function '' why

            what$ = Left$(s$, Len(s$) - 1)
            x1 = 1
        Else
            MyEr "Used in a For statement, For Group { this= or =this }", "вЯГСИЛОПОИЕъТАИ ЕМТЭР ЕМЭР циа ОЛэДА { АУТЭ= ч =АУТЭ} "
            Exit Function
        End If
    End If
Else
    x1 = Abs(IsLabel(basestack, rest$, what$))
End If

Else
what$ = rest$
If Right$(what$, 1) = "$" Then
HasStrName = True
strName$ = what$
what$ = Left$(what$, Len(what$) - 1)
End If
flag = entrypoint = 199
If GetVar(basestack, basestack.GroupName & rest$, i, flag) Then
If MyIsObject(var(i)) Then
    If Not TypeOf var(i) Is Group Then
        SyntaxError
        Exit Function
    End If
Else
  Set var(i) = New Group
End If
ElseIf Not GetVar(basestack, basestack.GroupName & what$, i, flag) Then
  i = globalvar(basestack.GroupName & what$, CLng(0), False, flag)
  Set var(i) = New Group
Else
If MyIsObject(var(i)) Then
    If Not TypeOf var(i) Is Group Then
        SyntaxError
        Exit Function
    End If
Else
  Set var(i) = New Group
End If

End If
If entrypoint = 199 Then

                                var(i).IamGlobal = True
                                UnFloatGroupReWriteVars basestack, basestack.GroupName & what$, i, basestack.lastobj
  

                                Set basestack.lastobj = Nothing
ElseIf entrypoint = 200 Then
                          If basestack.lastobj.IamApointer Then
                          If Not basestack.lastobj.link.IamFloatGroup Then
                          CopyPointerRef basestack, basestack.lastobj
                          End If
                          End If
                                UnFloatGroup basestack, basestack.GroupName & what$, i, basestack.lastobj, var(i).IamGlobal
                            
                                Set basestack.lastobj = Nothing
                                If Len(basestack.UseGroupname) <> 0 Then
                                 var(i).IamRef = True
                            
                                 globalvar what$, CVar(i), True, True
                                 
                             
                                 End If
End If
ProcGroup = True
Exit Function
End If
again:
If x1 = 3 Then
HasStrName = True
strName$ = what$
what$ = Left$(what$, Len(what$) - 1)
x1 = 1
End If
If x1 = 1 Then
    If IsLabelSymbolNew(rest$, "тупос", "TYPE", Lang) Then
        If IsStrExp(basestack, rest$, ss$) Then
            s$ = basestack.GroupName
            prepareGroup basestack, what$, y1, flag, HasStrName
            var(y1).IamGlobal = flag
            ProcGroup = ExecuteGroupStruct(basestack, basestack.GroupName & what$, y1, ss$, 0, Lang) <> 0
            basestack.GroupName = s$
        End If
        
    Else
        par = Not FastSymbol(rest$, "+")
        If FastSymbol(rest$, "{") Then
            If par Then
            '' GROUP
              
                
                prepareGroup basestack, what$, y1, flag, HasStrName, NewStat

                var(y1).IamGlobal = flag
                
                If flag Then ss$ = here$: here$ = vbNullString
                addlen = Len(rest$)
                s$ = block(rest$)
                addlen = addlen - Len(s$)
                If ExecuteGroupStruct(basestack, basestack.GroupName + what$, y1, s$, addlen, Lang, flag, NewStat) = 0 Then
                    If flag Then here$ = ss$
                    
                    var(y1).edittag = "'11001EDIT " + here$ + ", " + CStr(Len(rest$) - addlen - Len(s$))
                    ProcGroup = False
                    Exit Function
                End If
                If flag Then here$ = ss$
                ProcGroup = FastSymbol(rest$, "}")
            var(y1).FlushEvents
                  If Y3 = -1 Then
          On Error Resume Next
            
            MakeThunk what$, y1, basestack.UseGroupname, basestack.tpointer
        
        
        End If
    '    If Len(here$) = 0 Then
        'var(y1).Patch = basestack.GroupName & what$
     '   Else
       ' var(y1).Patch = here$ + "." + basestack.GroupName & what$
      '  End If
                
            Else
            '' CLASS
                    ss$ = block(rest$)
                    s$ = basestack.GroupName
                    
                    prepareGroup basestack, what$, y1, flag, HasStrName
                    var(y1).IamGlobal = flag
                    If ExecuteGroupStruct(basestack, basestack.GroupName & what$, y1, ss$, 0, Lang, flag) = 0 Then
                       rest$ = ss$ + rest$
                    Else
                        ProcGroup = FastSymbol(rest$, "}")
                    End If
            End If
            basestack.GroupName = s$
            If var(y1).IamApointer Then
            Set var(y1) = CopyGroup0Obj(var(y1), p)
            
            PopStage basestack
            End If
       Else
            If GetVar(basestack, basestack.GroupName & what$, i, flag) Then
            ProcGroup = True
            Else
contthere:
''what$ = basestack.GroupName & what$
                i = globalvar(basestack.GroupName & what$, CLng(0), False, flag)
                Set var(i) = New Group
                var(i).IamGlobal = flag
                If FastSymbol(rest$, "=") Then
                    If IsExp(basestack, rest$, p) Then
                        If Not basestack.lastobj Is Nothing Then
                            If Typename(basestack.lastobj) = mgroup Then
                                If basestack.lastobj.IamApointer Then
     
                                    If basestack.lastobj.link.IamFloatGroup Then
                                    Set basestack.lastobj = basestack.lastobj.link
                                    Else
                                    Dim ohere$, w2 As Long
                            
                                    ohere$ = here$
                                        here$ = basestack.lastobj.lasthere
                                        If GetVar(basestack, basestack.lastobj.GroupName, w2, , , True) Then
                                        
                                        CopyGroup2 var(w2), basestack
                                        End If
                                    here$ = ohere$
   
                                    End If
                                    Set basestack.lastpointer = Nothing
                                End If
                               
                                UnFloatGroup basestack, basestack.GroupName & what$, i, basestack.lastobj, flag
                               Set basestack.lastobj = Nothing
                            End If
                        End If
                    End If
                    If Len(basestack.UseGroupname) <> 0 Then
                                 var(i).IamRef = True
                            
                                 If Not flag Then globalvar what$, CVar(i), True, True
                                 
                             
                                 End If
                    var(i).FlushEvents
                    If Y3 = -1 Then
                    On Error Resume Next
                    MakeThunk what$, i, basestack.UseGroupname, basestack.tpointer
                    End If
                ElseIf FastSymbol(rest$, "->", , 2) Then
                    If Y3 = -1 Then
                    If IsExp(basestack, rest$, p) Then
                        If Not basestack.lastobj Is Nothing Then
                            If Typename(basestack.lastobj) = mgroup Then
                                
                               
                                UnFloatGroup basestack, basestack.GroupName & what$, i, basestack.lastobj, flag
                               Set basestack.lastobj = Nothing
                            End If
                        End If
                    End If
                    var(i).ResetEvents
                    On Error Resume Next
                    MakeThunk what$, i, basestack.UseGroupname, basestack.tpointer
                    Else
                    MyEr "Used only with Group WithEvents", "вЯГСИЛОПОИЕъТАИ ЛЭМО ЛЕ ТГМ оЛэДА лЕцЕЦОМЭТА"
                    ProcGroup = False
                    End If
                    
                ElseIf entrypoint = 99 Then

                                var(i).IamGlobal = True
                                UnFloatGroup basestack, basestack.GroupName & what$, i, basestack.lastobj, True
  

                                Set basestack.lastobj = Nothing
                ElseIf entrypoint = 100 Then
                          If basestack.lastobj.IamApointer Then
                          If Not basestack.lastobj.link.IamFloatGroup Then
                          CopyPointerRef basestack, basestack.lastobj
                          End If
                          End If
                                UnFloatGroup basestack, basestack.GroupName & what$, i, basestack.lastobj, here$ = vbNullString
                            
                                Set basestack.lastobj = Nothing
                Else
                             var(i).GroupName = what$ + "."
                             If HasStrName Then
                             
                             GlobalVarRefLink what$ + "$", i, flag
                             End If
                             If FastSymbol(rest$, ",") Then
                             x1 = Abs(IsLabel(basestack, rest$, what$))
                            If x1 = 1 Or x1 = 3 Then GoTo again
                            SyntaxError
                            ProcGroup = False
                            Exit Function
                            End If
                            If Len(var(i).Patch) = 0 Then
                            If flag Then
                            
                            Else
                            var(i).Patch = here$ + "." + basestack.GroupName + what$
                            End If
                            End If
                End If
            
                Exit Function
            End If
      
        End If
        
    End If
End If
  
End Function
Sub MakeThunk(where$, vvv As Long, ByVal GroupName$, ByVal tpointer As Long)
Dim EventObj As FastCollection, m As Group, it As Long
Set m = var(vvv)
Set EventObj = m.Events
If EventObj Is Nothing Then Exit Sub
Dim i As Long, j As Long, part$
If here$ <> "" Then where$ = here$ + "." + where$
With EventObj
    For i = 0 To .count - 1
    .index = i
    .Done = True
    If .Value = vbNullString Then
        .Value = where$ + "_" + .KeyToString + "()"
        If GetSub(.Value, it) Then
            .sValue = it
        Else
            .sValue = ModuleSub(.Value, "", GroupName$)
            sbf(.sValue).tpointer = tpointer
        End If
        
        
    End If
    Next i
    .Done = False
End With
End Sub
Function MyModule(basestack As basetask, rest$, Lang As Long, Optional noskipcommand = False, Optional MakeNew As Boolean, Optional addlen As Long = 0, Optional skipglob As Boolean = False, Optional ByPass As Boolean) As Boolean
Dim s$, pa$, ss$, x1 As Long, par As Boolean, what$, ohere$, i As Long, X3 As Long, frm$
ohere$ = here$
MyModule = True
If skipglob Then
        par = Len(ohere$) = 0
Else
        x1 = IsLabelSymbolNew(rest$, "цемийо", "GLOBAL", Lang)
        par = IsLabelSymbolNew(rest$, "мео", "NEW", Lang)
End If
If x1 <> 0 Then
        If lookOne(rest$, Chr(34)) Then
                ISSTRINGA rest$, what$
                GoTo bypass1
        End If
End If
X3 = IsLabelF(rest$, what$)
If X3 = 1 Then
If Right$(what$, 1) = "(" Then
If FastSymbol(rest$, ")") Then what$ = what$ + ")"
End If

        If x1 Then
bypass1:

                If Not GetGlobalSubAfterHere(basestack, what$, x1) Then
                    If noskipcommand Then
                        x1 = ModuleSub(what$, "")
                    Else
                        x1 = GlobalSub(what$, "", , what$)
                    End If
                    basestack.IndexSub = x1
                    sbf(x1).sbc = 1
                End If
                If FastSymbol(rest$, "(") Then
                                frm$ = BlockParam(rest$)
                             If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                            If Not FastSymbol(rest$, ")", True) Then
                                MyModule = False
                                Exit Function
                            End If
                           frm$ = Trim$(frm$)

                        End If
                        
                If FastSymbolNoTrimAfter(rest$, "{") Then
                ss$ = block(rest$)
                If Len(ss$) = 0 Then
                    ss$ = blockString(rest$, Asc("}"))
                End If
                i = Len(rest$)
                
                'If Right$(ss$, 2) <> vbCrLf Then ss$ = ss$ + vbCrLf
                If Left$(sbf(Abs(basestack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                                s$ = vbNullString
                        Else
                                pa$ = sbf(Abs(basestack.OriginalCode)).sb
                                If Not Left$(ss$, 10) = "'11001EDIT" Then
                                            s$ = GetNextLine(pa$) & "-" & CStr(i) + vbCrLf
                                End If
                        End If
                Else
                        If Left$(ss$, 10) <> "'11001EDIT" Then
                                If LenB(here$) = 0 Then
                                ElseIf basestack.OriginalCode > 0 And Not basestack.LoadOnly Then
                                s$ = "'11001EDIT " & GetModuleName(basestack, ohere$) & ",-" & CStr(i + addlen - 2) + vbCrLf
                                End If
                        End If
                End If
                            If frm$ <> "" Then
                                If Lang = 1 Then
                                s$ = s$ + vbCrLf + "Read " + frm$ + vbCrLf
                                Else
                                s$ = s$ + vbCrLf + "дИэБАСЕ " + frm$ + vbCrLf
                                End If
                                End If
                
                 sbf(x1).sb = s$ + ss$: basestack.IndexSub = x1
                 Set sbf(x1).subs = Nothing
                         If Not FastSymbol(rest$, "}") Then MyModule = False
                        
                Else
                        MyEr what$ & " missing definition", what$ & " КЕъПЕИ О ОЯИСЛЭР"
                End If
                Exit Function
        Else
          If par Then
                If noskipcommand Then
                    x1 = ModuleSub(what$, "")
                    sbf(x1).sbc = 1
                Else
                If Len(here$) = 0 Then
                
                    x1 = GlobalSub(what$, "", , what$)
                    Else
                    x1 = GlobalSub(here$ + "." + what$, "", , what$)
                    GoTo jump1
                    End If
                End If
                GoTo JUMP0
                ElseIf here$ = vbNullString And GetSub(what$, x1) And Not MakeNew Then
JUMP0:
                        If x1 >= lckfrm And lckfrm <> 0 Then
                                MyEr what$ & " is locked", what$ & " ЕъМАИ ЙКЕИДЫЛщМО"
                                rest$ = vbNullString
                                MyModule = False: Exit Function
                        End If
                        If FastSymbolNoTrimAfter(rest$, "{") Then
                            what$ = block(rest$)
                            If Len(what$) = 0 Then
                                what$ = blockString(rest$, Asc("}"))
                            End If
                        If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                   If Not FastSymbol(rest$, "}") Then
                                           MyModule = False
                                      Else
                                    If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                            sbf(x1).Changed = True
                                            sbf(x1).sb = what$: basestack.IndexSub = x1
                                            Set sbf(x1).subs = Nothing
                                End If
                               
                                        
                        Else
                                rest$ = ":" & what$ & " " & rest$      ''why
                        End If
                        Exit Function
                ElseIf GetlocalSub(basestack.GroupName & what$, x1) And Not MakeNew Then
jump1:
                 If FastSymbol(rest$, "(") Then
                                frm$ = BlockParam(rest$)
                                If Len(frm$) = 0 Then
                                    frm$ = blockString(rest$, Asc("}"))
                                End If
                             If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                            If Not FastSymbol(rest$, ")", True) Then
                                MyModule = False
                                Exit Function
                            
                            End If
                           frm$ = Trim$(frm$)

                        End If
                        If FastSymbolNoTrimAfter(rest$, "{") Then
                        If x1 >= lckfrm And lckfrm <> 0 Then
                                MyEr what$ & " is locked", what$ & " ЕъМАИ ЙКЕИДЫЛщМО"
                                rest$ = vbNullString
                                MyModule = False: Exit Function
                        End If
                                i = Len(rest$) ''
                                what$ = block(rest$) + " "
                                  If Len(what$) = 1 Then
                                    what$ = blockString(rest$, Asc("}")) + " "
                                End If
                                ' here for locked
                                If Not sbf(x1).locked Then
                                While Left$(what$, 10) = "'11001EDIT"
                                        SetNextLine what$
                                Wend
                                If Right$(what$, 2) <> vbCrLf Then what$ = what$ + vbCrLf
                                s$ = "'11001EDIT " & GetModuleName(basestack, ohere$) & ",-" & CStr(i + addlen - 2)
                                  If frm$ <> "" Then
                                If Lang = 1 Then
                                what$ = s$ + vbCrLf + "Read " + frm$ + vbCrLf + what$
                                Else
                                what$ = s$ + vbCrLf + "дИэБАСЕ " + frm$ + vbCrLf + what$
                                End If
                                Else
                                what$ = s$ + vbCrLf + what$
                                End If
                                If Not FastSymbol(rest$, "}") Then
                                        MyModule = False
                                Else
                                sbf(x1).Changed = True
                                sbf(x1).sb = what$
                                basestack.IndexSub = x1
                                Set sbf(x1).subs = Nothing
                                
                                End If
                                Else
                                If Not FastSymbol(rest$, "}") Then
                                        MyModule = False
                                Else
                                      basestack.IndexSub = x1
                                End If
                                End If
                        Else
                                rest$ = ":" & basestack.GroupName & what$ & " " & rest$
                        End If
                        Exit Function
                        ElseIf FastSymbol(rest$, "(") Then
                            frm$ = BlockParam(rest$)
                             If frm$ <> "" Then Mid$(rest$, 1, Len(frm$)) = space$(Len(frm$)) ': If InStr(frm$, "=") > 0 Then frm$ = "? " + frm$
                            If Not FastSymbol(rest$, ")", True) Then
                                MyModule = False
                                Exit Function
                            End If
                            frm$ = Trim$(frm$)
                            If FastSymbolNoTrimAfter(rest$, "{") Then GoTo jumpheretoo
                ElseIf FastSymbolNoTrimAfter(rest$, "{") Then
jumpheretoo:
                        If here$ = vbNullString Then
                                pa$ = block(rest$)
                            If Len(pa$) = 0 Then
                                pa$ = blockString(rest$, Asc("}"))
                            End If
                                If frm$ <> "" Then pa$ = "READ " + frm$ + vbCrLf + pa$
                                If Right$(pa$, 2) <> vbCrLf Then pa$ = pa$ + vbCrLf
                                
                                If noskipcommand Then
                                    basestack.IndexSub = ModuleSub(what$, pa$)
                                Else
                                    basestack.IndexSub = GlobalSub(what$, pa$, , what$)
                                End If
                        Else
                                ss$ = block(rest$)
                                If Len(ss$) = 0 Then
                                    ss$ = blockString(rest$, Asc("}"))
                                End If

                                i = Len(rest$)
                              '  If Right$(ss$, 2) <> vbCrLf Then ss$ = ss$ + vbCrLf
                                If Left$(sbf(Abs(basestack.OriginalCode)).sb, 10) = "'11001EDIT" Then
                                        If InStr(here$, ChrW(&H1FFF)) > 0 Then
                                                s$ = vbNullString
                                        Else
                                                pa$ = sbf(Abs(basestack.OriginalCode)).sb
                                                If Not Left$(ss$, 10) = "'11001EDIT" Then
                                                            s$ = GetNextLine(pa$) & "-" & CStr(i) + vbCrLf
                                                End If
                                        End If
                                ElseIf Not basestack.LoadOnly Then
                                        If Left$(ss$, 10) <> "'11001EDIT" Then
                                        If addlen = 0 Then addlen = -1
                                                s$ = "'11001EDIT " & GetModuleName(basestack, ohere$) & ",-" & CStr(i + addlen) + vbCrLf
                                        End If
                                End If
                                If frm$ <> "" Then
                                If Lang = 1 Then
                                s$ = s$ + "Read " + frm$ + vbCrLf
                                Else
                                s$ = s$ + "дИэБАСЕ " + frm$ + vbCrLf
                                End If
                                End If
                                If noskipcommand Then
                                If Not ByPass Then
                                    If basestack.GroupName = vbNullString Then
                                        basestack.IndexSub = ModuleSub(here$ & "." & what$, s$ + ss$)
                                    Else
                                        basestack.IndexSub = ModuleSub(here$ & "." & basestack.GroupName & what$, s$ + ss$)
                                    End If
                                    sbf(basestack.IndexSub).sbc = 1
                                    End If
                                Else
                                    If basestack.GroupName = vbNullString Then
                                        basestack.IndexSub = GlobalSub(here$ & "." & what$, s$ + ss$, , what$)
                                    Else
                                        basestack.IndexSub = ModuleSub(here$ & "." & basestack.GroupName & what$, s$ + ss$)
                                    End If
                                End If
                               
                        End If
                        If Not FastSymbol(rest$, "}") Or ByPass Then MyModule = False
                        Exit Function
                Else
                    If basestack.StaticCollection Is Nothing Then ConnectStatic basestack, myUcase(what$)
                    basestack.connectnow = True
                    here$ = what$
                End If
        End If
Else
        If what$ <> "" Then rest$ = what$ & " :" & rest$
        If IsStrExp(basestack, rest$, s$) Then
         
                    If basestack.StaticCollection Is Nothing Then ConnectStatic basestack, myUcase(s$)
                    basestack.connectnow = True
                    here$ = myUcase(s$)
        Else
                rest$ = what$ & " " & rest$
                MyModule = False
        End If
End If
End Function
Function MyEscape(rest$, Lang As Long) As Boolean
MyEscape = True
If Lang = 1 Then
If IsLabelSymbolLatin(rest$, "ON") Then
escok = True
ElseIf IsLabelSymbolLatin(rest$, "OFF") Then
escok = False
Else
MyEscape = False
End If
Else
If IsLabelSymbol(rest$, "маи") Then
escok = True
ElseIf IsLabelSymbol(rest$, "ови") Then
escok = False
Else
MyEscape = False
End If
End If
End Function
Function MyPut(basestack As basetask, rest$) As Boolean
Dim s$, f As Long, p As Variant, i As Long, pp As Variant, it As Long, flag As Boolean, Arr As Boolean
Dim usehandler As mHandler, what$
MyPut = False
 IsSymbol3 rest$, "#"
If IsExp(basestack, rest$, p, , True) Then
    f = CLng(p)
    If Fkind(f) = FnoUse Or Fkind(f) = Finput Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": Exit Function
If Not FastSymbol(rest$, ",") Then Exit Function
    i = 1
    what$ = aheadstatus(rest$, , i)
    If Left$(what$, 1) = "N" Then
Select Case IsLabel(basestack, rest$, what$)
    Case 1  ' check to see if is a handler
    If GetVar(basestack, what$, it) Then
     pp = 0
     If Typename(var(it)) = mHdlr Then
    
        If var(it).ReadOnly Then
                     ReadOnly
                             GoTo ex123
                     End If
        End If
      Set usehandler = var(it)
     
     flag = True
    End If

    Case 5  'check for handler
    what$ = Left$(what$, Len(what$) - 1)
    If GetVar(basestack, what$, it) Then
    pp = 0
    If IsExp(basestack, rest$, pp, , True) Then
    ' nothing here
    Arr = True
    End If
    If Not FastSymbol(rest$, ")") Then GoTo ex123
    If Not Typename(var(it)) = mHdlr Then GoTo ex123
        
           If var(it).ReadOnly Then
                        ReadOnly
                                GoTo ex123
                        End If
        Set usehandler = var(it)
        flag = True
    End If
    
    Case Else
        SyntaxError
        GoTo ex123
    End Select
    Else
    If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": MyPut = False: Exit Function
     If Not IsStrExp(basestack, rest$, s$) Then GoTo ex123
    End If
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, , True) Then
      FileSeek(f) = (CCur(p) - 1@) * Fstep(f) + 1@
ElseIf Not flag Then
    GoTo ex123
End If
End If

If flag Then
Dim buf As MemBlock
Dim aa() As Byte
Set buf = usehandler.objref

With buf
If Fstep(f) = 1 Then
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, , True) Then
p = Int(Abs(p))
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, pp, , True) Then
pp = Int(Abs(pp))
If .ValidArea(p, CLng(pp)) Then
    .putData f, p, CLng(pp)
Else
GoTo wrong
End If

Else
MissNumExpr
GoTo ex123
End If
Else
MissNumExpr
GoTo ex123
End If
Else
MissNumExpr
GoTo ex123
End If
Else
.putData f, .GetBytePtr(0), .SizeByte
End If

Else
    If Arr Then
    p = 1
    If FastSymbol(rest$, ",") Then
        If Not IsExp(basestack, rest$, p, , True) Then
                MissNumExpr
                MyPut = False
                GoTo ex123
        End If
    End If
    p = Int(Abs(p))
    If p = 0 Then GoTo wrong
        If .ValidArea2(pp, Fstep(f) * p) Then
            .putData f, .GetPtr(pp), Fstep(f) * p
        Else
wrong:
            MyEr "Wrong size-position for loading the buffer", "кэХОР ЛщЦЕХОР-ХщСГ ЦИА МА ЖОЯТЫХЕъ Г дИэЯХЯЫСГ"
            GoTo ex123
        End If
    Else
        .putData f, .GetPtr(0), .SizeByte
    End If
End If
End With
' use pp for
Else
If Fkind(f) <> Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": MyPut = False: Exit Function
If uni(f) Then
s$ = Left$(s$, Fstep(f) \ 2)
s$ = s$ & space$(Fstep(f) \ 2 - Len(s$))
Else
s$ = Left$(s$, Fstep(f))
s$ = s$ & space$(Fstep(f) - Len(s$))
End If
If FastSymbol(rest$, ",") Then
If IsExp(basestack, rest$, p, , True) Then
FileSeek(f) = (CCur(p) - 1@) * Fstep(f) + 1@
Else
GoTo ex123
End If
End If
If Not uni(f) Then
If FastSymbol(rest$, ",") Then
    If Not IsExp(basestack, rest$, p, , True) Then MissPar: Exit Function
    On Error Resume Next
    s$ = StrConv(s$, vbFromUnicode, CLng(p))
    If Err Then Err.Clear: NoValidLocale: Exit Function
Else
    s$ = StrConv(s$, vbFromUnicode, Clid)
    End If
End If
i = Module10.ReadFileHandler(CLng(f))
Module10.FileWriteString i, s$
End If
MyPut = True
End If
ex123:
Set usehandler = Nothing
Set basestack.lastobj = Nothing
End Function

Function ProcDir(basestack As basetask, rest$, Lang As Long) As Boolean
Dim pa$, w$, par As Boolean, s$, ss$, i As Long, p As Variant, what$, x1 As Long
If IsLabelSymbolNew(rest$, "вягстг", "USER", Lang) Then
If IsSupervisor Then
dset
Else
    mcd = userfiles
    End If
    ProcDir = True
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "йуяио", "MASTER", Lang) Then

    userfiles = GetSpecialfolder(CLng(26)) & "\M2000\"
    ProcDir = True
    Exit Function
ElseIf IsLabelSymbolNew(rest$, "упокоцистг", "COMPUTER", Lang) Then
 If IsSupervisor Then pa$ = "#" Else BadCommand: ProcDir = False: Exit Function
Else
    pa$ = vbNullString
End If
If FastSymbol(rest$, "?") Or pa$ <> "" Then
If IsSelectorInUse Then
ProcDir = False
SelectorInUse
Exit Function
End If
ProcDir = True
    If pa$ = "#" Then
    w$ = "#"
    pa$ = vbNullString
    Else
    p = CBool(IsStrExp(basestack, rest$, w$))
    End If
    If pa$ = vbNullString Then If FastSymbol(rest$, ",") Then p = CBool(IsStrExp(basestack, rest$, pa$))
    olamazi
    DialogSetupLang Lang
    par = False
    If w$ <> "" Then
    
        If Right$(w$, 1) = "?" Then
            w$ = Trim$(Left$(w$, Len(w$) - 1))
    mcd = w$ '' userfiles = W$
            par = True
        End If
    Else
    If IsSupervisor Then w$ = "\" Else w$ = userfiles
    End If

s$ = vbNullString
    If Form1.Visible Then
    If w$ = "#" Then
        If IsSupervisor Then
          If FolderSelector(basestack, Form1, "", "*", pa$, False) Then
            s$ = ReturnFile
        End If
        Else
        BadCommand
        ProcDir = False
        Exit Function
        End If
    Else
    If w$ <> "" Then If Not isdir(w$) Then BadPath: ProcDir = False: Exit Function
    If Not CanKillFile(w$) Then FilePathNotForUser: ProcDir = False: Exit Function
        If FolderSelector(basestack, Form1, mcd, w$, pa$, par) Then
            s$ = ReturnFile
        End If
    End If
    ElseIf form5iamloaded Then
      If w$ <> "" Then If Not isdir(w$) Then BadPath: ProcDir = False: Exit Function

      If Not CanKillFile(w$) Then FilePathNotForUser: ProcDir = False: Exit Function
        If FolderSelector(basestack, Form5, mcd, w$, pa$, par) Then
           s$ = ReturnFile
        End If
    End If
    s$ = mylcasefILE(s$)
            If s$ <> "" Then
            AddDirSep s$
                ''If Right(s$, 1) <> "\" Then s$ = s$ & "\"
                If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
                      Select Case Abs(IsLabel(basestack, rest$, what$))
                        Case 3
                        ProcDir = True
                            If GetVar(basestack, what$, i) Then
                            CheckVar var(i), s$
                            Else
                            globalvar what$, s$
                    
                            End If
                        Case Else
                            MissingStrVar
                            ProcDir = True
                            Exit Function
                        End Select
                 Else
                   mcd = s$
        
                   ProcDir = True
                   Exit Function
                End If
            End If
Else
x1 = Abs(IsLabelFileName(basestack, rest$, ss$, , w$))
If x1 = 1 Then
ss$ = w$
ElseIf x1 = 0 Or x1 = 3 Or x1 = 6 Then
rest$ = ss$ + rest$
x1 = IsStrExp(basestack, rest$, ss$)
End If

'If Left$(ss$, 1) = "." Then x1 = 1
If Left$(ss$, 2) = ".." And mcd = userfiles And Not IsSupervisor Then ProcDir = True: Exit Function ' no error
FixPath ss$
If x1 = 0 Then
IsSymbol3 rest$, "."
If FastSymbol(rest$, "*") Then
rest$ = Chr(34) + "*" + Chr(34) + rest$
ElseIf Not FastSymbol(rest$, "!") Then
rest$ = Chr(34) + "GSB" + Chr(34) + rest$
End If
 x1 = 1: ss$ = mcd
 par = True
End If
If x1 <> 0 Then
AddDirSep ss$
    If isdir(ss$) Then
        If Right(ss$, 1) <> "\" Then ss$ = ss$ & "\"
        If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
                Select Case Abs(IsLabel(basestack, rest$, what$))
                Case 3
                ProcDir = True
                    If GetVar(basestack, what$, i) Then
                    CheckVar var(i), ss$
                    Else
                    globalvar what$, ss$
            
                    End If
                Case Else
               MissingStrVar
               ProcDir = False
            Exit Function
                End Select
          
        Else
        If CanKillFile(ss$) Then
            mcd = ss$
            ProcDir = True
            If par = True Then
            'GOTO FILES
            If UserPath = "." Then
            If Lang Then
            ss$ = Chr(34) & "Dir User: " & Tcase(Originalusername) & Chr(34)
                Else
            ss$ = Chr(34) & "йАТэКОЦОР вЯчСТГ: " & Tcase(Originalusername) & Chr(34)
            End If
            Else
            If IsSupervisor Then
            If Lang Then
            ss$ = Chr(34) & "Dir: " & UserPath2 & Chr(34)
                Else
            ss$ = Chr(34) & "йАТэКОЦОР: " & UserPath2 & Chr(34)
            End If
            Else
            If Lang Then
            ss$ = Chr(34) & "Dir User: " & Tcase(Originalusername) & ": " & mylcasefILE(UserPath2) & Chr(34)
                Else
            ss$ = Chr(34) & "йАТэКОЦОР вЯчСТГ: " & Tcase(Originalusername) & ": " & mylcasefILE(UserPath2) & Chr(34)
            End If
            End If
            End If
          
            par = MyReport(basestack, ss$, Lang)
            par = ProcFiles(basestack, rest$, Lang)
            par = ProcCat(basestack, "", Lang)
            End If
            Else
            
         mcd = ss$
            ProcDir = True
            If par Then
            If Lang Then
            ss$ = "{Read Only Folder: " & mcd & "}"
            Else
            ss$ = "{йАТэКОЦОР ЛЭМО ЦИА АМэЦМЫСГ: " & mcd & "}"
            End If
            par = MyReport(basestack, ss$, Lang)
            par = ProcFiles(basestack, rest$, Lang)
            par = ProcCat(basestack, "", Lang) Or par
            
            End If
            End If
            Exit Function
          
        End If
     Else
     BadPath
            ProcDir = False
            Exit Function
    End If
    End If
End If

End Function

Function ProcClass(basestack As basetask, rest$, Lang As Long, super As Boolean) As Boolean
Dim i As Long, ss$, y1 As Long, what$, w$, ohere$, w2$, subs As Long, snames As Long, s$, pre$
Dim k As Long, m As Long, once As Boolean, Skipfirsttype As Boolean, wt$
If super Then
    subs = sb2used: snames = subHash.count:
    Dim R As Variant
    Dim SuperGroup As Object
    
End If
once = True
ohere$ = here$
ProcClass = True
y1 = IsLabelSymbolNew(rest$, "цемийг", "GLOBAL", Lang)

Select Case IsLabelA("", rest$, w$)
Case 1
againhere:
            If FastSymbol(rest$, "{") Then
            ' new code for finding position on error using shift+f1
            ss$ = block(rest$)
            If once Then
            If UCase(Left$(ss$, 5)) = "TYPE:" Or myUcase(Left$(ss$, 6), True) = "тупос:" Then
            Skipfirsttype = True
            End If
            once = False
            End If
              i = Len(rest$)
              If Skipfirsttype Then
                wt$ = vbNullString
              Else
                If Lang = 1 Then
                  wt$ = "type:" + w$ + vbCrLf
                Else
                  wt$ = "ТЩПОР:" + w$ + vbCrLf
                End If
              End If
              If here$ = vbNullString Or basestack.LoadOnly Then
                If Lang = 1 Then
                    s$ = vbCrLf + "if module(" + w$ + "." + w$ + ") then call! " + w$ + "." + w$ + vbCrLf + "=group(" + w$ + ")"
                    rest$ = w$ + "{" + vbCrLf + "group " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                 Else
                    s$ = vbCrLf + "аМ тЛчЛА(" + w$ + "." + w$ + ") тЭТЕ йэКЕСЕ! " + w$ + "." + w$ + vbCrLf + "=оЛэДА(" + w$ + ")"
                    rest$ = w$ + "{" + vbCrLf + "ОЛэДА " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                  End If
              Else
              If Lang = 1 Then
              s$ = vbCrLf + "if module(" + w$ + "." + w$ + ") then call! " + w$ + "." + w$ + vbCrLf + "=group(" + w$ + ")"
                     rest$ = w$ + "{'11001EDIT " & GetModuleName(basestack, ohere$) & ",-" & CStr(i) + "' " + CStr(Len(s$) + 2) + vbCrLf + "group " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                Else
                s$ = vbCrLf + "аМ тЛчЛА(" + w$ + "." + w$ + ") тЭТЕ йэКЕСЕ! " + w$ + "." + w$ + vbCrLf + "=оЛэДА(" + w$ + ")"
                      rest$ = w$ + "{'11001EDIT " & GetModuleName(basestack, ohere$) & ",-" & CStr(i) + "' " + CStr(Len(s$) + 2) + vbCrLf + "ОЛэДА " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ + "}" + vbCrLf + s$ + rest$
                End If
                End If
                If MyFunction(1, basestack, rest$, Lang) Then
                    ProcClass = True
                    sbf(basestack.IndexSub).IamAClass = True
                End If
                Skipfirsttype = False
         ElseIf IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                i = IsLabelA("", rest$, what$)
                If i < 5 Then
                If GetSub(what$ + "()", i) Then
                                 If sbf(i).Extern > 0 Or Not sbf(i).IamAClass Then
                                    w$ = what$
                                    GoTo conterror
                                 Else
         
                                    k = InStr(sbf(i).sb, vbCrLf)
                                    m = rinstr(sbf(i).sb, vbCrLf + vbCrLf)
                                    If m > k And Len(sbf(i).sb) > m Then
                                        s$ = Mid$(sbf(i).sb, k + 2, m - k)
                                        k = InStr(s$, "{")
                                        If k > 0 Then
                                        
                                        If Lang = 1 Then
                                            pre$ = block(Mid$(s$, k + 1)) + vbCrLf + "Public:" + vbCrLf + pre$
                                        Else
                                            pre$ = block(Mid$(s$, k + 1)) + vbCrLf + "дглосио:" + vbCrLf + pre$
                                        End If
                                        GoTo againhere
                                        Else
                                        s$ = ""
                                        End If
                                    Else
                                        w$ = what$
                                        GoTo conterror
                                    End If
                                 End If
                Else
                w$ = what$
                GoTo conterror
                End If
                Else
                w$ = what$
                GoTo conterror
                End If
         End If
Case 3
w2$ = Left$(w$, Len(w$) - 1)
againhere1:
        If FastSymbol(rest$, "{") Then
            ss$ = block(rest$)
            If once Then
            If UCase(Left$(ss$, 5)) = "TYPE:" Or myUcase(Left$(ss$, 6), True) = "тупос:" Then
            Skipfirsttype = True
            End If
            once = False
            End If
                
            i = Len(rest$)
              If Skipfirsttype Then
                wt$ = vbNullString
              Else
                If Lang = 1 Then
                  wt$ = "type:" + w2$ + vbCrLf
                Else
                  wt$ = "ТЩПОР:" + w2$ + vbCrLf
                End If
              End If
                
                If here$ = vbNullString Or basestack.LoadOnly Then
                If Lang = 1 Then
               s$ = "if module(" + w2$ + "." + w2$ + ") then call! " + w2$ + "." + w2$ + vbCrLf + "=group$(" + w2$ + ")"
                        rest$ = w$ + "{" + vbCrLf + "group " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ & "}" + vbCrLf + s$ + rest$
               Else
                s$ = "аМ тЛчЛА(" + w2$ + "." + w2$ + ") тЭТЕ йэКЕСЕ! " + w2$ + "." + w2$ + vbCrLf + "=оЛэДА$(" + w2$ + ")"
                      rest$ = w$ + "{" + vbCrLf + "ОЛэДА " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ & "}" + vbCrLf + s$ + rest$
                End If
                Else
               If Lang = 1 Then
               s$ = "if module(" + w2$ + "." + w2$ + ") then call! " + w2$ + "." + w2$ + vbCrLf + "=group$(" + w2$ + ")"
                        rest$ = w$ + "{'11001EDIT " & GetModuleName(basestack, ohere$) & ",-" & CStr(i) + "' " + CStr(Len(s$) + 2) + vbCrLf + "group " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ & "}" + vbCrLf + s$ + rest$
               Else
                s$ = "аМ тЛчЛА(" + w2$ + "." + w2$ + ") тЭТЕ йэКЕСЕ! " + w2$ + "." + w2$ + vbCrLf + "=оЛэДА$(" + w2$ + ")"
                      rest$ = w$ + "{'11001EDIT " & GetModuleName(basestack, ohere$) & ",-" & CStr(i) + "' " + CStr(Len(s$) + 2) + vbCrLf + "ОЛэДА " + w$ + "  {" + pre$ + vbCrLf + wt$ + ss$ & "}" + vbCrLf + s$ + rest$
                End If
                End If
                If MyFunction(1, basestack, rest$, Lang) Then
                    ProcClass = True
                    sbf(basestack.IndexSub).IamAClass = True
                End If
                Skipfirsttype = False
         ElseIf IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
                i = IsLabelA("", rest$, what$)
                If i < 5 Then
                If GetSub(what$ + "()", i) Then
                                 If sbf(i).Extern > 0 Or Not sbf(i).IamAClass Then
                                    w$ = what$
                                    GoTo conterror
                                 Else

                                    k = InStr(sbf(i).sb, vbCrLf)
                                    m = rinstr(sbf(i).sb, vbCrLf + vbCrLf)
                                    If m > k And Len(sbf(i).sb) > m Then
                                        s$ = Mid$(sbf(i).sb, k + 2, m - k)
                                        k = InStr(s$, "{")
                                        If k > 0 Then
                                        
                                        If Lang = 1 Then
                                            pre$ = block(Mid$(s$, k + 1)) + vbCrLf + "Public:" + vbCrLf + pre$
                                        Else
                                            pre$ = block(Mid$(s$, k + 1)) + vbCrLf + "дглосио:" + vbCrLf + pre$
                                        End If
                                        GoTo againhere1
                                        Else
                                        s$ = ""
                                        End If
                                    Else
                                        w$ = what$
                                        GoTo conterror
                                    End If
                                 End If
                Else
                w$ = what$
                GoTo conterror
                End If
                Else
                w$ = what$
                GoTo conterror
                End If
                '
        End If

Case Else
conterror:
        MyEr "No proper name " + w$ + " for class in class definition", "аМТИЙАМОМИЙЭ ЭМОЛА " + w$ + " ЦИА ЙКэСГ СТОМ ОЯИСЛЭ ЙКэСГР"
        ProcClass = False
End Select
If super Then

' make a variable

If Right$(w$, 1) = "$" Then
'Dim s As String
If IsStrExp(basestack, w$ + "()", s) Then
GoTo conthere
End If
ElseIf IsExp(basestack, w$ + "()", R) Then
conthere:
If basestack.lastobj Is Nothing Then
' error
Else

                sb2used = subs
                    subHash.ReduceHash snames, sbf()
                     If UBound(sbf()) / 3 > sb2used And UBound(sbf()) > 499 Then
                               ReDim Preserve sbf(UBound(sbf()) / 2 + 1) As modfun
                       End If
                       
If TypeOf basestack.lastobj Is Group Then
' make a pointet to group
Set SuperGroup = basestack.lastobj
Set basestack.lastobj = Nothing

Dim mm As Variant

If y1 Then
        i = globalvar(w$, mm, , True)
        Set var(i) = New Group
        
        Set var(i).SuperClassList = SuperGroup
        var(i).IamSuperClass = True
Else
        i = globalvar(w$, mm)
         Set var(i) = New Group
        Set var(i).SuperClassList = SuperGroup
        var(i).IamSuperClass = True

End If

Else
' something wrong

End If
End If
End If
End If

End Function
Function ProcDef(basestack As basetask, rest$, Lang As Long) As Boolean
Dim i As Long, what$, y1 As Long, ss$, s$, p, ps$, first
ProcDef = True
y1 = IsLabel(basestack, rest$, what$)
If y1 >= 5 Then
s$ = BlockParam(rest$)
rest$ = Mid$(rest$, Len(s$) + 1)
If FastSymbol(rest$, ")", True) Then
If FastSymbol(rest$, "=", True) Then
ss$ = vbNullString
Do
i = 1
aheadstatus rest$, False, i
ss$ = ss$ + Left$(rest$, i - 1)
rest$ = Mid$(rest$, i)
If Not FastSymbol(rest$, ",") Then Exit Do
ss$ = ss$ + ", "
Loop
If Trim$(s$) = vbNullString Then
ProcDef = MyFunction(0, basestack, Left$(what$, Len(what$) - 1) + " { =" + ss$ + "}", 1)
Else
ProcDef = MyFunction(0, basestack, Left$(what$, Len(what$) - 1) + " {  @read " + s$ + vbCrLf + "=" + ss$ + "}", 1)
End If
Exit Function
End If
End If
ElseIf y1 > 0 Then
first = 0#
'MyEr "Need name for function with parenthesis", "хщКЫ ЭМОЛА СУМэЯТГСГР ЛЕ ПАЯЕМХщСЕИР"
If LenB(here$) = 0 Or basestack.IamThread Then MyEr "Def make Variables only in Modules and Functions", "г йэМЕ ЖТИэВМЕИ ЛЕТАБКГТщР ЛЭМО СЕ тЛчЛАТА ЙАИ сУМАЯТчСЕИР": ProcDef = False: Exit Function
Dim that As Variant, oldthat As Variant, ByPass As Boolean, lcl As Boolean, notdef As Boolean, notdefone As Boolean
lcl = IsLabelSymbolNew(what$, "топийа", "LOCAL", Lang)
If lcl Then y1 = IsLabel(basestack, rest$, what$)
If y1 < 5 Then
    If y1 = 3 Then
        that = vbNullString
        GoTo jumpnow
    ElseIf IsLabelSymbolNew(what$, "аяихло", "DECIMAL", Lang) Then
    that = CDec(0)
    ElseIf IsLabelSymbolNew(what$, "дипко", "DOUBLE", Lang) Then
    that = 0#
    ElseIf IsLabelSymbolNew(what$, "апко", "SINGLE", Lang) Then
    that = CSng(0)
    ElseIf IsLabelSymbolNew(what$, "коцийо", "BOOLEAN", Lang) Then
    that = CBool(0)
    ElseIf IsLabelSymbolNew(what$, "лайяу", "LONG", Lang) Then
    that = CLng(0)
    ElseIf IsLabelSymbolNew(what$, "айеяаио", "INTEGER", Lang) Then
    that = CInt(0)
    ElseIf IsLabelSymbolNew(what$, "коцистийо", "CURRENCY", Lang) Then
    that = CCur(0)
    ElseIf IsLabelSymbolNew(what$, "цяалла", "STRING", Lang) Then
    that = vbNullString
    Else
    ByPass = True
    that = 0#
    GoTo jumpnow
    End If
    first = that
    ByPass = True
    notdefone = True
    notdef = True
    y1 = IsLabel(basestack, rest$, what$)
jumpnow:
    oldthat = that
    Do While y1 < 5
    
    If ByPass Then
        notdef = True
        If IsLabelSymbolNew(rest$, "ыс", "AS", Lang) Then
        If IsLabelSymbolNew(rest$, "аяихлос", "DECIMAL", Lang, , , , False) Then
        that = CDec(0)
        ElseIf IsLabelSymbolNew(rest$, "дипкос", "DOUBLE", Lang, , , , False) Then
        that = 0#
        ElseIf IsLabelSymbolNew(rest$, "апкос", "SINGLE", Lang, , , , False) Then
        that = CSng(0)
        ElseIf IsLabelSymbolNew(rest$, "коцийос", "BOOLEAN", Lang, , , , False) Then
        that = CBool(0)
        ElseIf IsLabelSymbolNew(rest$, "лайяус", "LONG", Lang, , , , False) Then
        that = CLng(0)
        ElseIf IsLabelSymbolNew(rest$, "айеяаиос", "INTEGER", Lang, , , , False) Then
        that = CInt(0)
        ElseIf IsLabelSymbolNew(rest$, "коцистийо", "CURRENCY", Lang, , , , False) Then
        that = CCur(0)
        ElseIf IsLabelSymbolNew(rest$, "цяалла", "STRING", Lang, , , , False) Then
        that = vbNullString
        
       Else
      If Not IsEnumAs(basestack, rest$, that) Then
               ExpectedEnumType
            Exit Function
        End If
        End If
     ElseIf y1 = 3 Then
    
        that = vbNullString
        Else
         notdef = notdefone
    End If
    ElseIf y1 <> 3 Then
    If VarType(that) = vbEmpty Then
    that = 0#
    End If
    End If
    If VarType(that) = vbString Then
    If y1 = 1 Then what$ = what$ + "$"
    End If
    
    If Not lcl Then If GetlocalVar(what$, i) Then MyEr "Variable " + what$ + " already defined", "уПэЯВЕИ чДГ Г ЛЕТАБКГТч " + what$: ProcDef = False: Exit Function
    i = AllocVar()
    If y1 = 3 Then
    that = vbNullString
    If strid.Find(what$, (i), (i)) Then
        strid.ItemCreator what$, -2
    End If
    ElseIf y1 = 1 Then
    If numid.Find(what$, (i), (i)) Then
        numid.ItemCreator what$, -2
    End If
    End If
    varhash.ItemCreator here$ + "." + what$, i, , , True
    If MyIsObject(that) Then
    Set p = that
    Else
    p = that
    End If
    If Not MyIsNumeric(that) Then
    that = first
    End If

    If FastSymbol(rest$, "=") Then
    If IsNumeric(p) Then
    If Not IsNumberD2(rest$, p, notdef, True) Then missNumber: Exit Function
    On Error Resume Next
    that = oldthat
    If Err.Number > 0 Then
        If Err.Number = 6 Then
            Overflow
            ProcDef = False
            Exit Function
        End If
    End If
    Else
    If Not ISSTRINGA(rest$, ps$) Then missNumber: Exit Function
        p = ps$
    End If
   
    End If
    If MyIsObject(p) Then
    Set var(i) = p
    p = vbEmpty
    that = oldthat
    Else
    var(i) = p
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
    y1 = IsLabel(basestack, rest$, what$)
    If MyIsObject(that) Then
    Set that = Nothing
    that = first
    Else
    that = first
    End If
    Loop
End If
If y1 > 4 Then MyEr "Not arrays with def", "╪ВИ ПъМАЙЕР ЛЕ ТГМ йэМЕ": ProcDef = False: Exit Function
Else
SyntaxError
ProcDef = False
Exit Function
End If

End Function
Function CheckTwoVal(a, B, c)
CheckTwoVal = a = B Or a = c
End Function
Function MyLink(basestack As basetask, rest$, Lang As Long) As Boolean
MyLink = True
Dim myobject As mStiva, ohere$, s$, ss$, x1 As Long, it As Long, rest1$
ohere$ = here$
Set myobject = basestack.soros
Set basestack.Sorosref = New mStiva
s$ = vbNullString
Do
    If IsLabelSymbolNew(rest$, "исвмг", "WEAK", Lang) Then
        If IsStrExp(basestack, rest$, ss$) Then
            If GetSub(ss$, x1) Then
                If sbf(x1).Extern > 0 Then
                basestack.soros.DataStr "{ call extern" + Str$(sbf(x1).Extern) + "}" + sbf(x1).sbgroup: x1 = 1: GoTo contlink2
                Else
                basestack.soros.DataStr "{" + sbf(x1).sb + "}" + sbf(x1).sbgroup: x1 = 1: GoTo contlink2
                End If
            Else
                basestack.soros.DataStr ss$: x1 = 1: GoTo contlink2
            End If
        End If
        MissStringExpr
        MyLink = False
        Exit Function
    ElseIf IsLabelSymbolNew(rest$, "цомийо", "PARENT", Lang) Then
    
        If Len(basestack.UseGroupname) > 0 Then
            ss$ = Mid$(basestack.UseGroupname, 1, Len(basestack.UseGroupname) - 1)
            
            If GetVar(basestack, ss$, x1) Then
            ss$ = Left$(ss$, Len(ss$) - Len(var(x1).GroupName))
            Dim sss$, sss1$, bck$
           
            Do
            sss$ = GetNextLine(rest$)
            bck$ = sss$
            If sss$ = vbNullString Then x1 = 0: Exit Do
            sss1$ = "&" + ss$ + "." + sss$
            sss$ = "&" + ss$ + "." + ChrW(&HFFBF) + sss$
            basestack.NoError = True
            s$ = vbNullString
            If IsStrExp(basestack, sss1$, s$) Then
                If GetSub(s$, x1) Then
                    basestack.soros.DataStr "{" + sbf(x1).sb + "}": x1 = 1
                Else
                    basestack.soros.DataStr s$: x1 = 1
                End If
                rest$ = sss1$ + rest$
            ElseIf IsStrExp(basestack, sss$, s$) Then
           
                If GetSub(s$, x1) Then
                    basestack.soros.DataStr "{" + sbf(x1).sb + "}": x1 = 1
                Else
                    basestack.soros.DataStr s$: x1 = 1
                End If
                rest$ = sss$ + rest$
            Else
                basestack.NoError = 0
                rest$ = bck$ + rest$
                MyEr "No such variable", "дЕМ УПэЯВЕИ ТщТОИА ЛЕТАБКГТч"
                MyLink = False
                Exit Function
            End If
        
            Loop Until Not FastSymbol(rest$, ",")
        If x1 = 1 Then GoTo contlink2
        basestack.NoError = 0
        MyEr "Parent group problem", "пЯЭБКГЛА ЦОМИЙчР ОЛэДАР"
        MyLink = False
        Exit Function
            End If
    Else

            MyEr "No parent found", "дЕМ БЯчЙА ЦОМИЙЭ"
         MyLink = False
        Exit Function
            End If
    End If
        
         If Len(rest$) < 129 Then
        it = IsLabelDot(ohere$, rest$, ss$)
    Else
        rest1$ = Left$(rest$, 128)
        it = IsLabelDot(ohere$, rest1$, ss$)
        If Len(rest1$) = 0 Then
            it = IsLabelDot(ohere$, rest$, ss$)
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
   
        
        
        
    If it = 2 Then
         If Len(rest$) < 129 Then
        it = IsLabelDot(ohere$, rest$, ss$)
    Else
        rest1$ = Left$(rest$, 128)
        it = IsLabelDot(ohere$, rest1$, ss$)
        If Len(rest1$) = 0 Then
            it = IsLabelDot(ohere$, rest$, ss$)
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
    End If
    If it = 0 Then IsStrExp basestack, rest$, ss$  'Then x1 = 1: basestack.soros.DataStr ss$: GoTo contlink2
    If ss$ <> "" Then
        If Left$(ss$, 1) = "&" Then ss$ = Mid$(ss$, 2)
            If it < 0 Then IsLabel basestack, (ss$), ss$
            If it > 4 Then
                ss$ = ss$ + ")"
                If Not FastSymbol(rest$, ")") Then it = 0
            End If
            x1 = 1
            aheadstatus rest$, False, x1
            basestack.NoError = True
             ss$ = "&" + ss$
            bck$ = ss$
            If IsStrExp(basestack, ss$, s$) Then
                 basestack.soros.DataStr s$
                 GoTo contLoop
            Else
     
            If it > 4 Then
                  it = rinstr(bck$, ".")
                bck$ = Left$(bck$, it) + ChrW(&HFFBF) + Mid$(bck$, it + 1)
       
               If IsStrExp(basestack, bck$, s$) Then
                If basestack.UseGroupname = vbNullString Then
            MyLink = False
            MyEr "Can't make reference, it's hidden", "дЕМ ЛПОЯЧ МА ЖТИэНЫ АМАЖОЯэ, ЕъМАИ ЙЯУЛЛщМО"
            Exit Function
            End If
                 basestack.soros.DataStr s$
                 GoTo contLoop
                 End If
                
            Else
            it = rinstr(bck$, ".")
            
            
                ss$ = Left$(bck$, it) + ChrW(&HFFBF) + Mid$(bck$, it + 1)
                
            End If
            If IsStrExp(basestack, ss$, s$) Then
            
            If basestack.UseGroupname = vbNullString Then
            MyLink = False
            MyEr "Can't make reference, it's hidden", "дЕМ ЛПОЯЧ МА ЖТИэНЫ АМАЖОЯэ, ЕъМАИ ЙЯУЛЛщМО"
            Exit Function
            End If
            End If
            End If
            basestack.NoError = False
            basestack.soros.DataStr s$
            

    End If
contLoop:
Loop While FastSymbol(rest$, ",")
contlink2:
basestack.NoError = False
If basestack.soros.Total = 0 Then
    MyEr "Nothing to link", "тъПОТА ЦИА МА ЕМЧСЫ"
    
ElseIf IsLabelSymbolNew(rest$, "топийа", "LOCAL", Lang) Then
If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
    MyLink = MyRead(8, basestack, rest$, Lang)
ElseIf IsLabelSymbolNew(rest$, "стг", "TO", Lang, True) Then
    MyLink = MyRead(8, basestack, rest$, Lang)
End If
Else
If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
    MyLink = MyRead(2, basestack, rest$, Lang)
ElseIf IsLabelSymbolNew(rest$, "стг", "TO", Lang, True) Then
    MyLink = MyRead(2, basestack, rest$, Lang)
End If
End If
exitlink:
Set basestack.Sorosref = myobject
Set myobject = Nothing
End Function

Function MyDim(basestack As basetask, rest$, Lang As Long, Optional dNew As Boolean) As Boolean
Dim par As Boolean, pppp As mArray, it As Long, k As Long, usehandler As mHandler
Dim p As Variant, w$, s$, X As Variant, i As Long, f As Long, Reverse As Boolean, ss$, uselocalbase As Boolean, usethisbase As Long
Dim oldbase As Long, common As Boolean, rest1$
MyDim = True
Reverse = IsLabelSymbolNew(rest$, "OLE", "OLE", Lang)
If dNew Then
par = True
Else
par = IsLabelSymbolNew(rest$, "мео", "NEW", Lang)
End If
common = IsLabelSymbolNew(rest$, "йоимос", "COMMON", Lang)
If Not common Then common = IsLabelSymbolNew(rest$, "йоимои", "COMMON", Lang)
uselocalbase = IsLabelSymbolNew(rest$, "басг", "BASE", Lang)
If uselocalbase Then
If FastSymbol(rest$, "1") Then
    oldbase = ArrBase
    ArrBase = 1
ElseIf FastSymbol(rest$, "0") Then
    oldbase = ArrBase
    ArrBase = 0
End If
If Not par Then
If IsLabelSymbolNew(rest$, "сто", "TO", Lang) Then
Do
usethisbase = ArrBase

    If Len(rest$) < 129 Then
        it = Abs(IsLabelDIM(basestack, rest$, w$))
    Else
        rest1$ = Left$(rest$, 128)
        it = Abs(IsLabelDIM(basestack, rest1$, w$))
        If Len(rest1$) = 0 Then
            it = Abs(IsLabelDIM(basestack, rest$, w$))
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
    If it = 0 Then MissArrayName: Exit Function
    If basestack.priveflag Then
    w$ = ChrW(&HFFBF) + w$
    End If
    If Not IsSymbol(rest$, ")") Then GoTo ex1
    If neoGetArray(basestack, w$, pppp, here$ <> "") Then
        If Not pppp.Arr Then Set pppp = Nothing: GoTo ex1
        If pppp.IHaveClass And pppp.GroupRef Is Nothing Then Set pppp = Nothing: GoTo ex1
        pppp.SerialItem 0, -usethisbase, 12
        pppp.common = common
   End If
   Loop Until Not FastSymbol(rest$, ",")
   GoTo ex1
End If
End If
If Not FastSymbol(rest$, ",") Then MyDim = True: GoTo ex1
End If
' for security
usethisbase = ArrBase
Do
ArrBase = usethisbase
    If Len(rest$) < 129 Then
        it = Abs(IsLabelDIM(basestack, rest$, w$))
    Else
        rest1$ = Left$(rest$, 128)
        it = Abs(IsLabelDIM(basestack, rest1$, w$))
        If Len(rest1$) = 0 Then
            it = Abs(IsLabelDIM(basestack, rest$, w$))
        Else
            rest$ = Mid$(rest$, 129 - Len(rest1$))
        End If
    End If
    If it = 0 Then MissArrayName: Exit Function
    If basestack.priveflag Then
    w$ = ChrW(&HFFBF) + w$
    ElseIf Len(basestack.UseGroupname) > 0 Then
    If it = 6 Then
        If strfunid.Find(w$, i) Then
            If i > 0 Then strfunid.ItemCreator w$, -i
        End If
    ElseIf it = 5 Then
        If funid.Find(w$, i) Then
            If i > 0 Then funid.ItemCreator w$, -i
        End If
    End If
    End If
    
    k = MyTrimL(rest$)
    If Mid$(rest$, k, 1) = ")" Then Mid$(rest$, k, 1) = ChrW(8)
    ''*********************
    If neoGetArray(basestack, w$, pppp, True) And Not par Then
    If Not pppp.Arr Then
    conflictname
    
    Set pppp = Nothing: GoTo ex1
    End If
    
    If pppp.IHaveClass And pppp.GroupRef Is Nothing Then Set pppp = Nothing: GoTo ex1
    pppp.common = common
   ' If reverse Then pppp.RevOrder = True
   If uselocalbase Then pppp.myarrbase = -ArrBase
    Select Case it
    Case 5, 6, 7
   If Len(here$) = 0 Then
   GlobalArrResize pppp, basestack, basestack.GroupName + w$, rest$, i
   Else
   GlobalArrResize pppp, basestack, w$, rest$, i
   End If
   
   p = i
    If i < 0 Then it = 0
    
    Case Else
    it = 0
    End Select
   Else
    Select Case it
    Case 5, 6, 7
    f = -1
    If Len(here$) = 0 Then
    GlobalArr basestack, basestack.GroupName + w$, rest$, i, f, , Reverse
    Else
    GlobalArr basestack, w$, rest$, i, f, , Reverse
    End If
    
    var(f).common = common
    
    p = i
    If i < 0 Then it = 0
    
    Case Else
    it = 0
    End Select
    End If
    
    Select Case it
    Case 5
    X = 0
    If FastSymbol(rest$, "=") Then
        If IsExp(basestack, rest$, X) Then
        If neoGetArray(basestack, w$, pppp) Then
   
        pppp.common = common
                     If Not basestack.lastobj Is Nothing Then
                            If Typename(basestack.lastobj) = mgroup Then
                            If basestack.lastobj.IamSuperClass Then

                            pppp.CopyGroupObj basestack.lastobj.SuperClassList, pppp.GroupRef
                                Set pppp.GroupRef = basestack.lastobj.SuperClassList
                                Set pppp.GroupRef.SuperClassList = basestack.lastobj.SuperClassList
                            Else
                                Set pppp.GroupRef = basestack.lastobj
                                End If
                                 pppp.IHaveClass = True
                                  Set basestack.lastobj = Nothing
                                 pppp.SerialItem 0, 0, 3
                            ElseIf Typename(basestack.lastobj) = "lambda" Then
                                    pppp.FillLambda basestack
                            ElseIf Typename(basestack.lastobj) = mHdlr Then
                                    Set usehandler = basestack.lastobj
                                    If usehandler.t1 = 4 Then pppp.Fillobj basestack Else Set basestack.lastobj = Nothing
                                    Set usehandler = Nothing
                            Else
                            Set basestack.lastobj = Nothing
                     
                            End If
                            
                    Else
                            pppp.SerialItem X, 0, 3
                    End If
            Else
            it = 0
        End If
        Else
                MissNumExpr
                MyDim = False
                GoTo ex1
                
        End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, w$, pppp) Then
                pppp.common = common
                        For i = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                                        If Not basestack.lastobj Is Nothing Then
                                                 If Typename(basestack.lastobj) = mgroup Then
                                                     Set pppp.GroupRef = Nothing
                                                     pppp.IHaveClass = False
                                                     If basestack.lastobj.IamSuperClass Then
                                                    Dim myobj As Object
                                          pppp.CopyGroupObj basestack.lastobj.SuperClassList, myobj
                        
                                              Set myobj.SuperClassList = basestack.lastobj.SuperClassList
                                              Set pppp.item(i) = myobj
                                              Set myobj = Nothing
                                             
                                               Else
                                                  
                                                       Set pppp.item(i) = basestack.lastobj
                                                       pppp.item(i).ToDelete = False
                                                      End If
                                        ElseIf Typename(basestack.lastobj) = mHdlr Then
                                        Set pppp.item(i) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                        Set pppp.item(i) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = myArray Then
                                        Set pppp.item(i) = basestack.lastobj
                                                    Else
                                                        Set basestack.lastobj = Nothing
                                                        badsupport
                                                        MyDim = False
                                                        GoTo ex1
                                                        Exit For
                                                     End If
                                                     
                                        Else
                                                pppp.item(i) = X
                                        End If
                                        
                        Else
                          Set basestack.lastobj = Nothing
                            MyDim = False
                            MissNumExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next i
                          Set basestack.lastobj = Nothing
            Else
            it = 0
                End If
          End If
     
    
     End If
    Case 7
    X = 0
    If FastSymbol(rest$, "=") Then
    If IsExp(basestack, rest$, X) Then
   If neoGetArray(basestack, w$, pppp) Then ''basestack.GroupName &
   pppp.common = common
    If Typename(basestack.lastobj) = "lambda" Then
                                pppp.FillLambda basestack
                             
   Else
    pppp.SerialItem Int(X), 0, 3
    End If
    End If
    Else
                MissNumExpr
                MyDim = False
                GoTo ex1
    End If
   ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, w$, pppp) Then
                pppp.common = common
                        For i = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                            If Typename(basestack.lastobj) = "lambda" Then
                                    Set pppp.item(i) = basestack.lastobj
                            ElseIf basestack.lastobj Is Nothing Then
                                    pppp.item(i) = Int(X)
                            Else
                                                     Set basestack.lastobj = Nothing
                                                        MyEr "Only Lambda objects here", "лЭМО КэЛДА АМТИЙЕъЛЕМА ЕДЧ"
                                                        MyDim = False
                                                        GoTo ex1
                                                        Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            MyDim = False
                                            MissNumExpr
                            GoTo ex1
                       
                        End If
                        Next i
                        Set basestack.lastobj = Nothing
            Else
            MissNumExpr
            GoTo ex1
                        it = 0
            End If
          End If
     End If
    Case 6
        s$ = vbNullString
    If FastSymbol(rest$, "=") Then
    If IsStrExp(basestack, rest$, s$) Then
   If neoGetArray(basestack, w$, pppp) Then '' basestack.GroupName &
   pppp.common = common
   If Typename(basestack.lastobj) = "lambda" Then
                                pppp.FillLambda basestack
    ElseIf Typename(basestack.lastobj) = mgroup Then
                                   If basestack.lastobj.IamSuperClass Then
                              pppp.CopyGroupObj basestack.lastobj.SuperClassList, pppp.GroupRef
                                Set pppp.GroupRef = basestack.lastobj.SuperClassList
                                Set pppp.GroupRef.SuperClassList = basestack.lastobj.SuperClassList
                            Else
                                Set pppp.GroupRef = basestack.lastobj
                                End If
                                 pppp.IHaveClass = True
                                  Set basestack.lastobj = Nothing
                                 pppp.SerialItem 0, 0, 3
                                         
   Else
    pppp.SerialItem s$, 0, 3
       End If
    End If
    Else
    MissStringExpr
    MyDim = False
    GoTo ex1
    End If
   ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, w$, pppp) Then
                pppp.common = common
                        For i = 0 To pppp.UpperMonoLimit
                        If IsStrExp(basestack, (s$), ss$) Then
                            If Typename(basestack.lastobj) = mgroup Then
                                    Set pppp.GroupRef = Nothing
                                    pppp.IHaveClass = False
                                    Set pppp.item(i) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = "lambda" Then
                                    Set pppp.item(i) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = mHdlr Then
                                        Set pppp.item(i) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                        Set pppp.item(i) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = myArray Then
                                        Set pppp.item(i) = basestack.lastobj
                                    
                            ElseIf basestack.lastobj Is Nothing Then
                                    pppp.item(i) = ss$
                            Else
                                                     Set basestack.lastobj = Nothing
                                                        badsupport
                                                        MyDim = False
                                                        GoTo ex1
                                                        Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            MyDim = False
                            MissStringExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next i
                        Set basestack.lastobj = Nothing
            Else
                it = 0
                MyDim = False
                MissStringExpr
                GoTo ex1
            End If
          End If
     End If
    End Select
    If it = 0 Then
      BadDim

    rest$ = basestack.GroupName & w$ & rest$
    MyDim = False
    GoTo ex1
    End If
    If Not pppp Is Nothing Then
    If basestack.finalFlag Then pppp.Final = True
    ElseIf f > 0 Then
    var(f).Final = basestack.finalFlag
    End If
Loop Until Not FastSymbol(rest$, ",")
ex1:
If uselocalbase Then
ArrBase = oldbase
End If
Set basestack.lastobj = Nothing
Set basestack.lastpointer = Nothing
End Function
Function MySeek(basestack As basetask, rest$) As Boolean
Dim X As Variant, t As Ftypes
MySeek = True
IsSymbol3 rest$, "#"   ' OPTIONAL   ...SEEK #I, 10020  буте
If IsExp(basestack, rest$, X, , True) Then
X = Int(X)
t = Fkind(X)
If t = FnoUse Then
MySeek = False
MyEr "not valid file number", "КэХОР АЯИХЛЭР АЯВЕъОУ"
Exit Function
End If
If t = Frandom Then
MySeek = False
MyEr "not valid file type", "КэХОР тупос АЯВЕъОУ"
Exit Function
End If
If Not FastSymbol(rest$, ",") Then
MissNumExpr
Else
Dim p
If IsExp(basestack, rest$, p, , True) Then
    FileSeek(X) = Int(p)
Else
MissNumExpr
End If
End If
End If

End Function
Function MyClose(basestack As basetask, rest$, Lang As Long) As Boolean
Dim par As Boolean, p As Variant, ss$
MyClose = True
If Not IsLabelSymbolNew(rest$, "басг", "BASE", Lang) Then
    par = False
    Do
        IsSymbol3 rest$, "#" ' optional
        If IsExp(basestack, rest$, p, , True) Then
            If p < 0 Then
            Else
             p = Int(p)
            If Fkind(p) <> FnoUse Then
            CloseHandler p
            End If
            End If
        Else
            If par Then
                MyClose = False
            Else
                closeAll
            End If
        Exit Do
        End If
        par = True
    Loop Until Not FastSymbol(rest$, ",")
Else
Do
If IsStrExp(basestack, rest$, ss$) Then
On Error Resume Next
If (ss$ Like "*.mdb") Or (ss$ Like "*:\*") Then
ss$ = mylcasefILE(ss$)
End If

 RemoveOneConn ss$
End If
Loop Until Not FastSymbol(rest$, ",")
End If

End Function
Function MyVol(basestack As basetask, rest$) As Boolean
Dim p As Variant
If IsExp(basestack, rest$, p, , True) Then
    vol = CLng(MyMod(Abs(p), 101))
    If FastSymbol(rest$, ",") Then
         If IsExp(basestack, rest$, p, , True) Then
            p = CLng(p)
      MediaPlayer1.SetMasterVolume vol, CLng(p)
  Else
      MissParam rest$
      
 End If
Else
 MediaPlayer1.SetMasterVolume vol
End If
End If
MyVol = True
End Function
Function MyClipboard(basestack As basetask, rest$, Lang As Long) As Boolean
Dim s$, photo As cDIBSection, R As Variant
Dim Width As Long, Height As Long
Dim p
      If IsStrExp(basestack, rest$, s$) Then
        If (Left$(s$, 4) = "cDIB" And Len(s$) > 12) Then         ' MAGIC LETTERS cDIB choose the bitmap
            Set photo = New cDIBSection
            If Not cDib(s$, photo) Then  ' copy from string to cDIBSection
                Set photo = Nothing
                MissCdibStr
                Exit Function
            Else
                photo.GetDpi 96, 96
                photo.CopyToClipboard
                Set photo = Nothing
            End If
        Else
            Clipboard.Clear
           SetTextData CF_UNICODETEXT, s$   'set as unicode text
        End If
    ElseIf IsExp(basestack, rest$, R) Then
        If basestack.lastobj Is Nothing Then
            Clipboard.Clear
            If FastSymbol(rest$, ",") Then
                IsExp basestack, rest$, s$
                SetTextData CF_UNICODETEXT, Num2Str(R, s$)
            Else
                SetTextData CF_UNICODETEXT, Num2Str(R, "")
            End If
        Else
        If TypeOf basestack.lastobj Is mHandler Then
            Dim mm As mHandler, mb As MemBlock
            Set mm = basestack.lastobj
            Set basestack.lastobj = Nothing
            If mm.t1 = 2 Then
                Set mb = mm.objref
                If Not IsLabelSymbolNew(rest$, "ыс", "AS", Lang, , , , False) Then
                If mb.SubType = 0 Then
                If mb.IsEmf Then
                    mb.SubType = 2
                ElseIf mb.IsWmf Then
                    mb.SubType = 2
                End If
                End If
                If FastSymbol(rest$, ",") Then
                Dim w, h
                If IsExp(basestack, rest$, w, , True) Then
                    If Not FastSymbol(rest$, ",") Then
                        mb.SentToClipBoard CLng(w), , , True, True
                        MyClipboard = True
                    ElseIf IsExp(basestack, rest$, h, , True) Then
                        mb.SentToClipBoard CLng(w), CLng(h), , True, True
                        MyClipboard = True
                    Else
                        MissParam rest$
                        MyClipboard = False
                        Exit Function
                    End If
                Else
                    MissParam rest$
                    MyClipboard = False
                    
                End If
                Exit Function
                ElseIf mb.SubType <> 2 Then
                    mb.SentToClipBoard , , , , True
                Else
                    If mb.IsWmf Then
                        mb.SentWmfToClipBoard
                    Else
                        mb.SentEmfToClipBoard
                    End If
                End If
                ElseIf IsStrExp(basestack, rest$, s$) Then
                    s$ = UCase(s$)
                Select Case s$
                Case "EMF"
                    If mb.IsWmf Then
                        mb.SubType = 2
                        mb.SentWmfToClipBoard
                    ElseIf mb.SubType = 2 Then
                        mb.SentEmfToClipBoard
                    ElseIf mb.IsEmf Then
                        mb.SubType = 2
                        mb.SentEmfToClipBoard
                    Else
                        MyEr "Not an emf type", "кэХОР ТЩПОР ЕИЙЭМАР"
                    End If
                Case "BMP"
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, R) Then
cont1:
                            Width = -1
                            Height = -1
                            If FastSymbol(rest$, ",") Then
                                If IsExp(basestack, rest$, p) Then Width = Abs(p)
                                If FastSymbol(rest$, ",") Then
                                    If IsExp(basestack, rest$, p) Then
                                    Height = Abs(p)
                                    Else
                                        MissParam rest$
                                        Exit Function
                                        End If
                                End If
                            End If
                            mb.SentToClipBoard Width, Height, mycolor(R), , True
                        Else
                            If MaybeIsSymbol(rest$, ",") Then R = 15: GoTo cont1
                            MissParam rest$
                        End If
                    Else
                        GoTo cont3
                    End If
                Case "EXT"  ' OLD ROUTINE
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, R) Then
cont2:
                            Width = -1
                            Height = -1
                            If FastSymbol(rest$, ",") Then
                                If IsExp(basestack, rest$, p) Then Width = Abs(p)
                                If FastSymbol(rest$, ",") Then
                                    If IsExp(basestack, rest$, p) Then Height = Abs(p)
                                    Else
                                        MissParam rest$
                                        Exit Function
                                End If
                            End If
                            If mm.t1 = 2 Then
                            
                                Set photo = New cDIBSection
                                photo.emfSizeFactor = 1
                                photo.CreateFromPicture mb.GetStdPicture(, , mycolor(R), , True)
                                photo.CopyToClipboard
                             
                            Else
                                    mb.SentToClipBoard Width, Height, mycolor(R), , True
                            End If
                        Else
                            If MaybeIsSymbol(rest$, ",") Then R = 15: GoTo cont2
                            MissParam rest$
                        End If
                    Else
cont3:
                        If mm.t1 = 2 Then
                            mb.SentToClipBoard , , mycolor(R), , True
                        Else
                            mb.SentToClipBoard , , , , True
                        End If
                    End If
                End Select
                End If
            
            End If
        End If
        End If
    End If
    MyClipboard = True
End Function

Private Function MyMod(R1, po) As Variant
MyMod = R1 - Fix(R1 / po) * po
End Function
Function Appfields(basestack As basetask, rest$) As Boolean
Dim s$, p As Variant

If IsExp(basestack, rest$, p) Then
Appfields = AddInventory(basestack, rest$)
ElseIf IsStrExp(basestack, rest$, s$) Then
Appfields = True
append_table basestack, s$, rest$, False
Else
SyntaxError
Appfields = False
End If
Set basestack.lastobj = Nothing
Exit Function
End Function
Function rValue(bstack As basetask, ob As Object) As Variant
    If ob Is Nothing Or TypeOf ob Is Group Then
        Set bstack.lastobj = ob
        rValue = 0
    ElseIf TypeOf ob Is PropReference Then
        rValue = ob.Value
        Set bstack.lastobj = ob.lastobjfinal
        If Not bstack.lastobj Is Nothing Then rValue = 0
    ElseIf TypeOf ob Is mEvent Then
        CopyEvent ob, bstack
        rValue = 0
    ElseIf TypeOf ob Is lambda Then
        CopyLambda ob, bstack
        rValue = 0
    ElseIf TypeOf ob Is mHandler Then
        CopyHandler ob, bstack
        rValue = 0
    ElseIf TypeOf ob Is mArray Then
        Set bstack.lastobj = CopyArray(ob)
        rValue = 0
    ElseIf TypeOf ob Is Document Then
        rValue = ob.textDoc
        Set bstack.lastobj = Nothing
    Else
        Set bstack.lastobj = ob
        rValue = 0
    End If
End Function
Sub refreshGui()
   Dim X As Form
                    For Each X In Forms
             
                    If Typename$(X) = "GuiM2000" Then
                    If X.Enabled Then X.Refresh
                    End If
                    Next
                    Set X = Nothing
End Sub

Sub MouseShow(Yes As Boolean)
Dim k As Long, b1 As Boolean
If Yes Then
k = ShowCursor(True)
k1 = k = -1
If k < 0 Then
k = ShowCursor(True)
Do While k < 0
If k = -1 And k1 Then Exit Sub ' no mouse found
k = ShowCursor(True)
Loop
End If
Else

k = ShowCursor(False)
Do While k >= 0
k = ShowCursor(False)
Loop
End If
End Sub

Function GetAnewEvent() As Variant

Dim aa As New ComShinkEvent, bb As New mHandler
'Set aa.Callback = Form1
Set bb.objref = aa
 bb.t1 = 3
Set GetAnewEvent = bb
End Function
Public Function CallEventFromCOM1(evCom As ComShinkEvent, aString$, what$, NumVar As Long, vrs(), ref() As Long, exclude As Boolean, ItemIndex As Long) As Boolean
Dim tr As Boolean, extr As Boolean, olescok As Boolean
Dim f$, F1$, klm As Long, ohelp As Object
'olescok = escok
'escok = False
CallEventFromCOM1 = True
F1$ = evCom.modulename$
f$ = UCase(F1$ + "_" + aString$ + "()") ' No greek
If Not subHash.Find(f$, klm) Then exclude = True: Exit Function
extr = extreme
extreme = True
tr = trace
trace = False
Dim n$, bb As mStiva, oldbstack As mStiva, nowtotal As Long
Dim bstack As basetask
Set bstack = New basetask
Set bstack.Owner = Form1.DIS
bstack.IamAnEvent = True
Dim i As Long
i = evCom.VarIndex
'F1$ = evCom.modulename$
If Not evCom.StaticCollection Is Nothing Then
If evCom.StaticCollection.ExistKey(aString$) Then
Set bstack.StaticCollection = evCom.StaticCollection.ValueObj
End If
End If
Set oldbstack = bstack.soros
Dim j As Long, k As Long, s1$, s2$
Dim ohere$
ohere$ = here$
here$ = vbNullString

If evCom.Attached Then
Set bb = New mStiva
Set bstack.Sorosref = bb
            PushStage bstack, False
            If ItemIndex > -1 Then
                bb.DataVal CVar(ItemIndex)
            End If
            For k = 1 To NumVar
            'If VariantIsRef(VarPtr(vrs(k))) Then
            If ref(k) Then
            Select Case VarType(vrs(k))
            Case vbString
            globalvarGroup "EV" + CStr(i + k) + "$", vrs(k)
            bb.DataStr "EV" + CStr(i + k) + "$"
            Case Is >= vbArray
            ' make it normal
            globalvarGroup "EV" + CStr(i + k) + "(", RetM2000array(vrs(k))
            bb.DataStr "EV" + CStr(i + k)
            Case Else
            globalvarGroup "EV" + CStr(i + k), vrs(k)
            bb.DataStr "EV" + CStr(i + k)
            End Select
            Else
            Select Case VarType(vrs(k))
            Case vbString
            bb.DataStr CStr(vrs(k))
            Case Is >= vbArray
            ' make it normal
                Set ohelp = RetM2000array(vrs(k))
                bb.DataObj ohelp
                Set ohelp = Nothing
            Case Else
                If MyIsObject(vrs(k)) Then
                    Set ohelp = vrs(k)
                    bb.DataObj ohelp
                    Set ohelp = Nothing
                Else
                    bb.DataVal vrs(k)
                End If
            End Select
            End If
            Next k
            '''bb.DataObj evCom
            '' last is the second name, the class name??
            bb.DataStr (what$)
     
            bb.DataObj MakeitObjectGeneric(evCom.VarIndex)
  
            'f$ = aString$
            
           '' WE ARE GOING TO OUR MODULE
           
            here$ = evCom.modulenameonly

            If FastCallModule(bstack, klm) <> 1 Then
            
            
            
                PopStage bstack
                bb.Flush
                GoTo conthere
            End If
                  here$ = vbNullString
                  If NumVar > 0 Then
       For k = LBound(vrs()) To UBound(vrs()) - 1 + LBound(vrs())
       If ref(k) Then
       Select Case VarType(vrs(k))
       Case vbString
            varhash.Find2 "EV" + CStr(i + k) + "$", j, True
           vrs(k) = var(j)

       Case Is >= vbArray
            varhash.Find2 "EV" + CStr(i + k) + "(", j, True
            RetComArray var(j), vrs(k)
        Case Else
            varhash.Find2 "EV" + CStr(i + k), j, True
             vrs(k) = var(j)
            End Select
           End If
            Next k
            End If
            PopStage bstack

            bb.Flush

End If

conthere:
If Not bstack.StaticCollection Is Nothing Then
        If evCom.StaticCollection Is Nothing Then Set evCom.StaticCollection = New FastCollection
        If Not evCom.StaticCollection.ExistKey(aString$) Then
            evCom.StaticCollection.AddKey aString$, bstack.StaticCollection
        End If
End If


Set bstack.Sorosref = oldbstack
here$ = ohere$
Set oldbstack = Nothing
Set bb = Nothing
extreme = extr
trace = tr

'escok = olescok
End Function
Sub RetComArray(varFrom As Variant, varTo As Variant)
Dim ar As mArray, v()
Set ar = varFrom
ar.CopyBackSerialize v()
varTo = v()
End Sub

Function FastCallModule(bstack As basetask, mod_id As Long) As Long
Dim i As Long, frm$
 If myexit(bstack) Then FastCallModule = 0: Exit Function
 frm$ = Mid$(sbf(mod_id).sb, 1)
 FastCallModule = Execute(bstack, frm$, False, False)
 
 
End Function

Function MakeATypeLib(v As Variant, Optional usetypelib As Boolean = False) As FastCollection
    Dim obj             As Object, vv As FastCollection
    ' create the requested object
    
    Set obj = v
    If usetypelib Then
            ' find typelib and load it
    Set MakeATypeLib = New FastCollection
    Else
    If Not GetAllMembers(vv, obj) Then Err.Raise &H80004002
    Set MakeATypeLib = vv
    Set vv = Nothing
    End If
    Set obj = Nothing
End Function

Function FindPrevOriginal(bstack As basetask) As Long
Dim curparent As basetask, cur As basetask
'If bstack.IamThread Then
'FindPrevOriginal = bstack.Parent.OriginalCode
'Exit Function
'End If
Set cur = bstack
Set curparent = cur.Parent
If curparent Is Nothing Then FindPrevOriginal = cur.OriginalCode: Exit Function
If curparent.OriginalCode = 0 Then FindPrevOriginal = cur.OriginalCode: Exit Function
Do While curparent.OriginalCode = cur.OriginalCode And curparent.OriginalCode <> 0
Set cur = curparent
Set curparent = cur.Parent
If curparent Is Nothing Then FindPrevOriginal = cur.OriginalCode: Exit Function
Loop
FindPrevOriginal = curparent.OriginalCode
End Function
Function iter(bstack As basetask, rest$, Lang As Long) As Boolean
' each( array or inventory, start: 1 by default, or -1 for end of list,  end: -1 to end (optional), or we can set it)
    Dim pppp As mArray, w1 As Long, s$, num As Long, st As Variant, en As Variant, usehandler As mHandler, usehandler1 As mHandler
    
    w1 = Abs(IsLabel(bstack, rest$, s$))
    If w1 > 4 Then
    If neoGetArray(bstack, s$, pppp) Then
        If pppp.Arr Then
            If FastSymbol(rest$, ")") Then
            If Not IsSymbol(rest$, ",") Then
            ' READ KEYWORDS
                st = 1: en = -1
                If IsLabelSymbolNew(rest$, "аявг", "START", Lang) Then
                    st = 1
                ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang, , , , False) Then
                    st = -1
                ElseIf IsExp(bstack, rest$, st, , True) Then
                    st = Int(st)
                Else
                    st = 1
                End If
                If IsLabelSymbolNew(rest$, "еыс", "TO", Lang, , , , False) Then
                    If IsLabelSymbolNew(rest$, "аявг", "START", Lang, , , , False) Then
                        en = 1
                    ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang, , , , False) Then
                        en = -1
                    ElseIf IsExp(bstack, rest$, en, , True) Then
                        en = Int(en)
                    Else
                        MyEr "To where?", "╦ЫР ПОУ;"
                        Exit Function
                    End If
                Else
                    en = -1
                End If
            Else
                If Not IsExp(bstack, rest$, st) Then st = 1
                If Not IsSymbol(rest$, ",") Then
                    en = -1
                ElseIf Not IsExp(bstack, rest$, en) Then
                    MissNumExpr
                    Exit Function
                End If
            End If
          
            Set usehandler = New mHandler
            
           Set usehandler.objref = pppp
           Set bstack.lastobj = usehandler
            PlaceIteratorData bstack, var(0), st, en
            iter = True
            Exit Function
            End If
            
        End If
        End If
    ElseIf GetVar(bstack, s$, w1) Then
        If Typename(var(w1)) = mHdlr Then
conthere111:
         
       If Not IsSymbol(rest$, ",") Then
                st = 1: en = -1
        If IsLabelSymbolNew(rest$, "аявг", "START", Lang, , , , False) Then
                    st = 1
                ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang, , , , False) Then
                    st = -1
                ElseIf IsExp(bstack, rest$, st, , True) Then
                    st = Int(st)
                Else
                    st = 1
                End If
                If IsLabelSymbolNew(rest$, "еыс", "TO", Lang, , , , False) Then
                
                    If IsLabelSymbolNew(rest$, "аявг", "START", Lang, , , , False) Then
                        en = 1
                    ElseIf IsLabelSymbolNew(rest$, "текос", "END", Lang, , , , False) Then
                        en = -1
                    ElseIf IsExp(bstack, rest$, en, , True) Then
                        en = Int(en)
                    Else
                        MyEr "To where?", "╦ЫР ПОУ;"
                        Exit Function
                    End If
                Else
                    en = -1
                End If
            Else
                If Not IsExp(bstack, rest$, st, , True) Then st = 1
                If Not IsSymbol(rest$, ",") Then
                    en = -1
                ElseIf Not IsExp(bstack, rest$, en, , True) Then
                    MissNumExpr
                    Exit Function
                End If
                Set usehandler = New mHandler
                Set bstack.lastobj = usehandler
                Set usehandler1 = var(w1)
                usehandler.t1 = usehandler1.t1
                GoTo con12345
            End If
            
        If Typename(var(w1)) <> mHdlr Then
        On Error GoTo there1
          If Typename(var(w1).objref) <> myArray Then
           
           Set bstack.lastobj = Nothing
           MyEr "Not proper object for iterator", "дЕМ ЕъМАИ СЫСТЭ АМТИЙЕъЛЕМО ЦИА ЕПАМэКГЬГ"
           Exit Function
           End If
          End If
there1:
          Err.Clear
          
           Set bstack.lastobj = New mHandler
con12345:
            PlaceIteratorData bstack, var(w1), st, en
            iter = True
        End If
    End If


End Function
Function ClearLabels()
If sb2used > 0 Then
Dim i As Long
For i = 1 To sb2used
Set sbf(i).subs = Nothing
Next i
End If
End Function
Function MyIsNumericPointer(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
If n < 8 Then MyIsNumericPointer = True: Exit Function
MyIsNumericPointer = (n = 11) Or (n = 17) Or (n = 14)
End Function
Function MyIsNumeric(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
If n < 8 Then MyIsNumeric = True: Exit Function
MyIsNumeric = (n = 11) Or (n = 17) Or (n = 14)
End Function
Function IsNumericPrint(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
If n = 0 Then Exit Function
If n < 8 Then IsNumericPrint = True: Exit Function
IsNumericPrint = (n = 11) Or (n = 17) Or (n = 14)
End Function

Function MyIsObject(v As Variant) As Boolean
Dim n As Byte
GetMem1 VarPtr(v), n
MyIsObject = n = 9
End Function
Function MyVal(v As Variant) As Variant
On Error GoTo there1245
MyVal = v
Exit Function
there1245:
On Error GoTo there1246
MyVal = val(v)
there1246:
End Function
Function ThisPointer(bstack As basetask, w3 As Long) As Boolean ' return var(r)
Dim s1$
    Set bstack.lastobj = Nothing
     If Len(bstack.UseGroupname) > 0 Then
     s1$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
     If GetVar(bstack, s1$, w3) Then
          ThisPointer = True
     ElseIf Len(bstack.fHere) = 0 Then
  
     ElseIf GetVar(bstack, bstack.fHere + "." + s1$, w3) Then
          ThisPointer = True
          ElseIf GetVar(bstack, s1$, w3, True) Then
          ThisPointer = True
    End If
    Else
there:
    's1$ = "."
    s1$ = vbNullString
    If bstack.GetDotNew(s1$, 1) Then
    If Len(s1$) = 0 Then Exit Function
    s1$ = Left$(s1$, Len(s1$) - 1)
        If GetVar(bstack, s1$, w3) Then
            ThisPointer = True
    End If
    End If
    End If
    
    
    

End Function

Function This1(bstack As basetask, original$, R As Variant) As Boolean  ' return a copy
Dim s1$, w3 As Long
    Set bstack.lastobj = Nothing
     If Len(bstack.UseGroupname) > 0 Then
     If bstack.tpointer > 0 Then
     If var(bstack.tpointer).GroupName = bstack.UseGroupname Then
     Set bstack.lastobj = CopyGroupObj(var(bstack.tpointer))
     Else
     GoTo cont1001
     End If
     
     Else
cont1001:
     s1$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
     If GetVar(bstack, s1$, w3) Then
          Set bstack.lastobj = CopyGroupObj(var(w3))
     ElseIf GetVar(bstack, bstack.fHere + "." + s1$, w3) Then
          Set bstack.lastobj = CopyGroupObj(var(w3))
          ElseIf GetVar(bstack, s1$, w3, True) Then
           Set bstack.lastobj = CopyGroupObj(var(w3))
          
    End If
    End If
    Else
there:
    s1$ = vbNullString
    If bstack.GetDotNew(s1$, 1) Then
    If Len(s1$) = 0 Then
        If GetVar(bstack, original$, w3) Then
            If MyIsObject(var(w3)) Then
            Set bstack.lastobj = var(w3)
            R = 0
            Else
            R = var(w3)
            End If
            This1 = True
        Else
        MyEr "Not Defined variable " + original$, "дЕМ щВЕИ ОЯИСТЕъ ЛЕТАБКГТч " + original$
        This1 = False
         End If
    Exit Function
    Else
    s1$ = Left$(s1$, Len(s1$) - 1)
        If GetVar(bstack, s1$, w3) Then
        If MyIsObject(var(w3)) Then
            If TypeOf var(w3) Is Group Then
                Set bstack.lastobj = CopyGroupObj(var(w3))
            Else
                Set bstack.lastobj = var(w3)
            End If
            R = 0
            Else
            R = var(w3)
            End If
            This1 = True
           Exit Function
        
    End If
    End If
    End If
    End If
    
     R = 0
    This1 = True

End Function
Function StackItem(bstack As basetask, a$, SG, R) As Boolean
Dim p As Variant, w3 As Long, anything As Object
w3 = 1
If IsExp(bstack, a$, p) Then
If bstack.lastobj Is Nothing Then
    Set anything = bstack.soros
    w3 = Abs(CLng(Fix(p)))
ElseIf Not CheckStackObj(bstack, anything, w3) Then
    MyEr "Not a stack object", "дЕМ ЕъМАИ АМТИЙЕъЛЕМО СЫЯОЩ"
    Exit Function
ElseIf FastSymbol(a$, ",") Then
If IsExp(bstack, a$, p, , True) Then
    w3 = Abs(CLng(Fix(p)))
End If
End If
    
backitem:
    If anything.Total < w3 Then
    
            MyErMacro a$, "Stack item not found at position " & CStr(w3), "дЕМ УПэЯВЕИ ТИЛч СЫЯОЩ СТГ ХщСГ " & CStr(w3)
        Set bstack.lastobj = Nothing
        StackItem = False: Exit Function

    ElseIf anything.StackItemType(w3) = "N" Then
    
    R = anything.StackItem(w3)
    If SG < 0 Then R = -R
    
    StackItem = FastSymbol(a$, ")", True)
    Exit Function
    ElseIf anything.StackItemType(w3) = "L" Then
    
    R = anything.StackItem(w3)
    If SG < 0 Then R = -R
    
    StackItem = FastSymbol(a$, ")", True)
    Exit Function
    ElseIf anything.StackItemType(w3) = "*" Then
    R = 0
    
    Set bstack.lastobj = anything.StackPickRef(w3).ObjectRef
    
    StackItem = FastSymbol(a$, ")", True)
    Exit Function
    Else
     
            MyErMacro a$, "Stack item isn't number at position " & CStr(w3), "г ТИЛч ТОУ СЫЯОЩ ДЕМ ЕъМАИ АЯИХЛЭР СТГ ХщСГ " & CStr(w3)
  
    StackItem = False
    End If
    Exit Function

Else
w3 = 1
Set anything = bstack.soros
GoTo backitem
End If
End Function
Public Function LambdaList(bstack As basetask) As String
On Error Resume Next
LambdaList = var(-bstack.OriginalCode).code$
End Function
Sub PrepareLabel(bstack As basetask)

   If Not bstack.IamLambda Then
  Dim mmm$


If SecureNames Then
mmm$ = sbf(bstack.OriginalCode).goodname
Else
mmm$ = here$
End If
 mmm$ = CleanStr(mmm$, ChrW(-65))
    If InStr(mmm$, "].") > 0 Then
        mmm$ = Mid$(mmm$, InStr(mmm$, "].") + 2)
    End If
   ' If AscW(MMM$) = 8191 Then MMM$ = Mid$(MMM$, 8)
    If bstack.fHere <> "" And InStr(bstack.fHere, "(") > 0 Then mmm$ = bstack.fHere + "." + mmm$
    End If
    If InStr(mmm$, ChrW(8191)) > 0 Then
    DropLeft ChrW(8191), mmm$
    If InStr(mmm$, ChrW(8191)) > 0 Then
    DropLeft ChrW(8191), mmm$
    End If
    If InStr(mmm$, ".") > 0 Then
    DropLeft ".", mmm$
    GoTo conthere
    Else
    If Right$(mmm$, 2) = "()" Then
        mmm$ = Left$(mmm$, Len(mmm$) - 2)
    End If
    
     If pagio$ = "GREEK" Then
         Form2.Label1prompt(0) = "тЕКЕСТчР "
     Else
            Form2.Label1prompt(0) = "Operator "
     End If
     End If
    Else
conthere:
    If bstack.IamThread Then
  If pagio$ = "GREEK" Then
  Form2.Label1prompt(0) = "мгла(" + CStr(bstack.Process.id) + "): "
  Else
  Form2.Label1prompt(0) = "THREAD(" + CStr(bstack.Process.id) + "): "
  End If
  
    Else
    If pagio$ = "GREEK" Then
        If bstack.fHere <> "" Or Right$(mmm$, 2) = "()" Then
        If bstack.IamLambda Then
        If Right$(here$, 3) = "$()" Then
            Form2.label1(0) = "калда$()"
            Else
            Form2.label1(0) = "калда()"
            End If
            Exit Sub
        Else
            Form2.Label1prompt(0) = "сУМэЯ.: "
        End If
        Else
            Form2.Label1prompt(0) = "тЛчЛА: "
        End If
  Else
        If bstack.fHere <> "" Or Right$(mmm$, 2) = "()" Then
         If bstack.IamLambda Then
         If Right$(here$, 3) = "$()" Then
            Form2.label1(0) = "LAMBDA$()"
            Else
            Form2.label1(0) = "LAMBDA()"
            End If
            Exit Sub
         Else
        Form2.Label1prompt(0) = "Func.: "
        End If
  Else
  Form2.Label1prompt(0) = "Module: "
  End If
  End If
 End If
    
    
    
    End If
    
    Form2.label1(0) = GetName$(mmm$)
     
     
    
    
  
End Sub


Private Function CompareStr2(a$, B$) As Long
On Error GoTo comperr
If UserCodePage = DefCodePage Then
CompareStr2 = StrComp(a$, B$, vbTextCompare)
Else
CompareStr2 = -2 + CompareString(Clid, &H1000, StrPtr(a$), Len(a$), StrPtr(B$), Len(B$))
End If
Exit Function
comperr:
CompareStr2 = -2 + CompareString(0, 0, StrPtr(a$), Len(a$), StrPtr(B$), Len(B$))

End Function
Private Function CompareStr3(a As Variant, B As Variant) As Long
On Error GoTo comperr
If Not mTextCompare Then
CompareStr3 = StrComp(a, B)
ElseIf UserCodePage = DefCodePage Then
CompareStr3 = StrComp(a, B, vbTextCompare)
Else
CompareStr3 = -2 + CompareString(Clid, &H1000, StrPtr(a), Len(a), StrPtr(B), Len(B))
End If
Exit Function
comperr:
Err.Clear


If mTextCompare Then
If MyIsObject(a) Or MyIsObject(B) Then
Else
CompareStr3 = -2 + CompareString(0, 0, StrPtr(a), Len(a), StrPtr(B), Len(B))

Exit Function
End If
End If
MyEr "Not string found", "дЕМ БЯчЙА АКЖАЯИХЛГТИЙЭ"
End Function

Function CheckTwo(v1&, v2&) As Boolean
Dim one As Group, two As Group
If Typename(var(v1&)) <> mgroup Then
    Dim a1 As Variant, b1 As Variant
    If Typename(var(v1&)) = mHdlr Then
        Dim a As Object
        Set a = var(v1&)
        CheckLastHandler a
        If a.indirect >= 0 And a.indirect <= var2used Then
            Set a = var(a.indirect)
        End If
        Set a1 = a
    Else
    If MyIsObject(var(v1&)) Then
        Set a1 = var(v1&)
    Else
        a1 = var(v1&)
    End If
    
    End If
    If Typename(var(v2&)) = mHdlr Then
        Dim B As Object
        Set B = var(v2&)
        CheckLastHandler B
        If B.indirect >= 0 And B.indirect <= var2used Then
            Set B = var(B.indirect)
        End If
        Set b1 = B
    Else
    If MyIsObject(var(v2&)) Then
        Set b1 = var(v2&)
    Else
        b1 = var(v2&)
    End If
    End If
    
    CheckTwo = Typename(a1) = Typename(b1)

ElseIf Typename(var(v2&)) = mgroup Then
Set one = var(v1&)
If one.IamApointer Then
Set one = one.link
End If
Set two = var(v2&)
If two.IamApointer Then
Set two = two.link
End If
If one.IamSuperClass Then
If two.IamSuperClass Then
    CheckTwo = False ' no two superclass as the same, (maybe they have the same kind of members)
    ' because superclass may have unique members, but also have unique values
Else
' check if second is kind of superclass
    CheckTwo = one.SuperClassList Is two.SuperClassList
End If
Else ' check first if has the same superclass
If one.SuperClassList Is two.SuperClassList Then
If two.IamSuperClass Then
    ' so v1& as V2& if v2& is a superclass (same as before)
    CheckTwo = True
Else
' so now we have to check lists
Dim ms As mStiva2, ms2 As mStiva2
Set ms = one.PrepareSorosToCompare(var())
Set ms2 = two.PrepareSorosToCompare(var())
' check ms2 against ms
' every time we found one in ms2 we remove it from both
Dim i As Long, j As Long
again:
For i = 1 To ms2.Total
For j = 1 To ms.Total
If ms.StackItem(j) = ms2.StackItem(i) Then
If i > 1 Then ms2.MakeTopItem i
If j > 1 Then ms.MakeTopItem j
    ms.drop 1
    ms2.drop 1
GoTo again
End If
Next j
Next i
CheckTwo = ms2.Total = 0

End If
End If

End If

End If

End Function

Function ProcessIf(flag As Variant, bstack As basetask, rest$, R As Variant) As Boolean

Dim mode As Boolean, usehandler As mHandler
mode = flag < 1
If bstack.lastobj Is Nothing Then
flag = Int(Abs(flag > 0) * (flag - 1) - (flag <= 0) * (flag + 1) + 1)
Else
If TypeOf bstack.lastobj Is mHandler Then
Set usehandler = bstack.lastobj
If usehandler.t1 = 4 Then
Set bstack.lastobj = Nothing
Set usehandler = Nothing
flag = Int(Abs(flag > 0) * (flag - 1) - (flag <= 0) * (flag + 1) + 1)
End If
Else
flag = 1
End If
End If
Dim nowpos As Double, w1 As Long, s$
nowpos = 1
ProcessIf = True
 If Not FastSymbol(rest$, "->", True, 2) Then Exit Function
Do
    If flag = nowpos Then
        If MaybeIsSymbol(rest$, ",)") Then
            If mode Then
            R = flag = 1
            Else
            R = 0
            End If
        Else
            If Not IsExp(bstack, rest$, R) Then
                MissNumExpr
                ProcessIf = False
                Exit Function
            End If
        End If
        ProcessIf = True
    Else
        If Not MaybeIsSymbol(rest$, ",)") Then
        w1 = 1
        s$ = aheadstatus(rest$, True, w1)
        If s$ = vbNullString Then Exit Do
        Mid$(rest$, 1, w1 - 1) = space$(w1 - 1)
        End If
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
    nowpos = nowpos + 1
    If mode Then If nowpos > 2 Then MyEr "To many expressions", "пОККщР ЕЙЖЯэСЕИР"
Loop
If nowpos = 1 Then MyEr "Need two expressions", "вЯЕИэФОЛАИ ДУО ЕЙЖЯэСЕИР"
If Not FastSymbol(rest$, ")") Then ProcessIf = False
End Function
Function ProcessIfStr(ByVal flag As Double, bstack As basetask, rest$, ss As String) As Boolean
Dim mode As Boolean
mode = flag < 1
flag = Int(Abs(flag > 0) * (flag - 1) - (flag <= 0) * (flag + 1) + 1)
'Set bstack.lastobj = Nothing
Dim nowpos As Double, w1 As Long, s$
nowpos = 1
ProcessIfStr = True
 If Not FastSymbol(rest$, "->", True, 2) Then Exit Function
Do
    If flag = nowpos Then
        If MaybeIsSymbol(rest$, ",)") Then
            ss = vbNullString
        Else
            If Not IsStrExp(bstack, rest$, ss) Then
                MissStringExpr
                ProcessIfStr = False
                Exit Function
            End If
        End If
        ProcessIfStr = True
    Else
        If Not MaybeIsSymbol(rest$, ",)") Then
        w1 = 1
        s$ = aheadstatus(rest$, True, w1)
        If s$ = vbNullString Then Exit Do
        Mid$(rest$, 1, w1 - 1) = space$(w1 - 1)
        End If
    End If
    If Not FastSymbol(rest$, ",") Then Exit Do
    nowpos = nowpos + 1
    If mode Then If nowpos > 2 Then MyEr "To many expressions", "пОККщР ЕЙЖЯэСЕИР"
Loop
If nowpos = 1 Then MyEr "Need two xpressions", "вЯЕИэФОЛАИ ДУО ЕЙЖЯэСЕИР"
If Not FastSymbol(rest$, ")") Then ProcessIfStr = False
End Function
Function GETarrayFROMstr(a$, B$) As mHandler
Dim pppp As mArray, aa() As String
aa = Split(a$, B$)
Set pppp = New mArray
If UBound(aa) = -1 Then

Else
Dim i As Long
pppp.PushDim UBound(aa) + 1
pppp.PushEnd
For i = 0 To UBound(aa)
pppp.item(i) = aa(i)
Next i
End If
Set GETarrayFROMstr = New mHandler
GETarrayFROMstr.t1 = 3
Set GETarrayFROMstr.objref = pppp

End Function
Function CheckThis(bstack As basetask, w$, B$, v As Long, Lang As Long) As Long
Dim bb$
If Len(w$) > 3 Then
    If Lang = 1 Then
        If Left$(w$, 1) = "T" Then
            If Left$(w$, 4) = "THIS" Then
                If Len(w$) = 4 Then
                    bb$ = vbNullString
                    If bstack.GetDotNew(bb$, 1) < 0 Then
                        If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                         If GetGlobalVar(Left$(bb$, Len(bb$) - 1), v) Then w$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetlocalVar(Left$(bb$, Len(bb$) - 1), v) Then w$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetGlobalVar(w$, v) Then GoTo found
                    End If
                ElseIf Mid$(w$, 5, 1) = "." Then
                    If Len(bstack.UseGroupname) > 0 Then
                        bb$ = bstack.UseGroupname + Mid$(w$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings w$, bb$: GoTo found
                        bb$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(w$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings w$, bb$: GoTo found
                        
                    Else
                        bb$ = vbNullString
                        If bstack.GetDotNew(bb$, 1) < 0 Then
                            If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                            w$ = Left$(bb$, Len(bb$) - 1) + Mid$(w$, 5)
                            If GetGlobalVar(w$, v) Then GoTo found
                        End If
                    End If
                End If
            End If
        End If
    Else
        If Left$(w$, 1) = "а" Then
            If Left$(w$, 4) = "ауто" Then
                If Len(w$) = 4 Then
                    If bstack.GetDotNew(bb$, 1) < 0 Then
                        If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                         If GetGlobalVar(Left$(bb$, Len(bb$) - 1), v) Then w$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetlocalVar(Left$(bb$, Len(bb$) - 1), v) Then w$ = Left$(bb$, Len(bb$) - 1): GoTo found
                         If GetGlobalVar(w$, v) Then GoTo found
                    End If
                ElseIf Mid$(w$, 5, 1) = "." Then
                     If Len(bstack.UseGroupname) > 0 Then
                        bb$ = bstack.UseGroupname + Mid$(w$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings w$, bb$: GoTo found
                        bb$ = bstack.UseGroupname + ChrW(&HFFBF) + Mid$(w$, 6)
                        If varhash.Find(bb$, v) Then SwapStrings w$, bb$: GoTo found
                    Else
                        bb$ = vbNullString
                        If bstack.GetDotNew(bb$, 1) < 0 Then
                            If Len(bb$) = 0 Then CheckThis = -1: Exit Function
                            w$ = Left$(bb$, Len(bb$) - 1) + Mid$(w$, 5)
                            If GetGlobalVar(w$, v) Then GoTo found
                        End If
                    End If
                End If
            End If
        End If
    End If
End If
Exit Function
found:
CheckThis = 1
If FastSymbol(B$, "=") Then Exit Function
If FastSymbol(B$, "<=", , 2) Then Exit Function
If FastSymbol(B$, "->", , 2) Then CheckThis = 3: Exit Function
CheckThis = 2
End Function
Function myHwnd(bstack As basetask) As Double
If Typename(bstack.Owner) = "GuiM2000" Then
myHwnd = bstack.Owner.hWnd
Else
If ttl Then
myHwnd = Form3.hWnd
Else
myHwnd = bstack.Owner.hWnd
End If
End If
End Function
Function GetName(ByVal part$) As String
again:
If InStrRev(part$, ChrW(&H1FFF)) > 0 Then
If InStr(part$, ".") > 0 Then
    part$ = Mid$(part$, InStr(part$, ".") + 1)
    GoTo again
End If
End If
If LenB(part$) = 0 Then Exit Function
If InStr(part$, "].") > 0 Then
part$ = Mid$(part$, InStr(part$, "].") + 2)
If InStr(part$, ChrW(&H1FFF)) > 0 Then
If InStr(part$, ".") > 0 Then
    part$ = Mid$(part$, InStr(part$, ".") + 1)
    GoTo again
End If
End If
ElseIf iRVAL22(part$) > 0 Then
If InStr(part$, "][") = 0 Then
GetName = vbNullString 'part$
Exit Function
Else
part$ = sbf(iRVAL22(part$)).goodname
End If
GoTo again
End If

GetName = part$

End Function
Sub FeedArray(pppp As mArray, v As Long, fromthis As Object, Optional convert As Boolean = False)
Dim mm As mStiva, myobject As Object, p As Variant, usehandler As mHandler
Set mm = fromthis
Do While Not mm.IsEmpty
If v >= pppp.count Then Exit Do
If mm.PopType = ">" Then
mm.drop 1
pppp.item(v) = CLng(0)
v = v + 1
ElseIf mm.StackItemTypeIsObject(1) Then
        pppp.item(v) = -1
        Set myobject = mm.PopObj
            
        If Typename$(myobject) = mgroup Then
              If myobject.IamFloatGroup Then
                     Set pppp.item(v) = myobject
              Else
                           BadGroupHandle
                           Set myobject = Nothing
                           Exit Sub
              End If
         ElseIf Typename$(myobject) = "lambda" Then
                  Set pppp.item(v) = myobject
          ElseIf Typename$(myobject) = myArray Then
              If myobject.Arr Then
                      Set pppp.item(v) = CopyArray(myobject)
                  Else
                      Set pppp.item(v) = myobject
                  End If
         ElseIf Typename$(myobject) = mHdlr Then
               If myobject.indirect > -0 Then
                   Set pppp.item(v) = myobject
               Else
                   p = myobject.t1
                   If CheckDeepAny(myobject) Then
                       If TypeOf myobject Is mHandler Then
                           Set pppp.item(v) = myobject
                       Else
                        Set usehandler = New mHandler
                           Set pppp.item(v) = usehandler
                           usehandler.t1 = p
                           Set usehandler.objref = myobject
                       End If
                       
                   End If
              End If
          ElseIf Typename$(myobject) = mProp Then
                  Set pppp.item(v) = myobject
          End If
          Set myobject = Nothing
        '  mm.drop 1
Else
If Typename$(pppp.item(v)) = doc Then
    If mm.PopType = "S" Then
        CheckVar pppp.item(v), mm.PopStr
    Else
    ' ERROR
        Set pppp.item(v) = New Document
        mm.drop 1
    End If
ElseIf Not mm.PopType = "S" Then
If convert Then
pppp.item(v) = MyRound(mm.StackItem(1), 0)
mm.drop 1
Else
pppp.item(v) = mm.StackItem(1)
mm.drop 1
End If
Else
pppp.item(v) = mm.StackItem(1)
mm.drop 1
End If


End If
v = v + 1
Loop
Set fromthis = Nothing

End Sub
Function CurrentStackSize() As Double
'If IsWine Then Exit Function
On Error GoTo 1000
Dim endaddress As Long
ua = startaddress
UB = VarPtr(endaddress)
' IN IDE USING BREAK ON ALL ERROR STOP HERE - THIS IS OK
' CHANGE THE ERROR LEVEL AND AFTER THAT CHANGE IT AGAIN
CurrentStackSize = uintnew(ua) - uintnew(UB) - 300 ' - (1 - m_bInIDE) * 93
Exit Function
1000
Err.Raise 8000
End Function
Function ClaimStack() As Long
If IsWine Then Exit Function
Static once11 As Boolean
ClaimStack = findstack
If once11 Then Exit Function
once11 = True
repeatme
ClaimStack = findstack
End Function
Function repeatme()
On Error GoTo there
findstack = CurrentStackSize()
On Error GoTo there
repeatme
there:
End Function
Function GetModuleName(B As basetask, where$) As String
If SecureNames Then
If B.OriginalCode < 0 Then
    If var2used <= -B.OriginalCode Then Exit Function
    GetModuleName = GetName(var(-B.OriginalCode).Name)
Else
    GetModuleName = GetName(sbf(B.OriginalCode).goodname)
    End If
Else
    GetModuleName = GetName(StripRVAL(where$))
End If
End Function
Private Function compareStr4(a$, B$) As Long   ' here is not byval as in fastcollection
Dim i As Long, j As Long, a1$, b1$, p1 As Variant, p2 As Variant, n$, k As Long, k1 As Long
If CompareString(Clid, &H1000, StrPtr(a$), Len(a$), StrPtr(B$), Len(B$)) = 2 Then Exit Function
n$ = "[-0-9.]"
k = Sgn(Len(a$) - Len(B$))
k1 = k
again:
j = IIf(Len(a$) >= Len(B$), Len(B$), Len(a$))

For i = 1 To j

    If Mid$(a$, i, 1) Like n$ Then
    a1$ = Mid$(a$, i)
    b1$ = Mid$(B$, i)
        IsNumberD2 a1$, p1
       
        If IsNumberD2(b1$, p2) Then
            compareStr4 = Sgn(MyRound(p1, 8) - MyRound(p2, 8))
            If compareStr4 = 0 Then
                If Len(a1$) * Len(b1$) <> 0 Then
                    If Len(n$) > 6 Then n$ = "[-0-9]"
                    k = Sgn(Len(a1$) - Len(b1$))
                     
                    a$ = a1$
                    B$ = b1$
                   
                    GoTo again
                End If
                If Len(a1$) + Len(b1$) = 0 Then
                    compareStr4 = k
                Else
                    compareStr4 = Sgn(Len(a1$) - Len(b1$))
                End If
                Exit Function
             End If
            Exit Function
        Else
        a$ = Mid$(a$, i)
    B$ = Mid$(B$, i)
    IsNumberD2 a$, p1
       
          If Len(a$) > 0 Then
       
            Select Case CompareString(Clid, &H1000, StrPtr(a$), Len(a$), StrPtr(B$), Len(B$))
                Case 1, 3
                compareStr4 = -1
                Case 2
                If k > 0 Then
                compareStr4 = -1
                Else
                compareStr4 = 1
                End If
            End Select
        Else
        compareStr4 = -1
        End If
        End If
        Exit Function
    ElseIf Mid$(B$, i, 1) Like n$ Then
    a$ = Mid$(a$, i)
    B$ = Mid$(B$, i)
    IsNumberD2 B$, p1
    If Len(B$) > 0 Then
       
            Select Case CompareString(Clid, &H1000, StrPtr(a$), Len(a$), StrPtr(B$), Len(B$))
                Case 3
                compareStr4 = 1
                Case 1, 2
                If k < 0 Then
                compareStr4 = 1
                Else
                compareStr4 = -1
                End If
                
                
            End Select
        Else
        compareStr4 = 1
        End If
        Exit Function
    End If
    compareStr4 = -2 + CompareString(Clid, 0, StrPtr(a$) + i * 2 - 2, 1, StrPtr(B$) + i * 2 - 2, 1)
    If compareStr4 <> 0 Then
    Exit Function
    End If
Next i
compareStr4 = Sgn(Len(a$) - Len(B$))
If compareStr4 = 0 Then compareStr4 = k1
End Function


Private Sub checkbreak(bstack As basetask, B$, once As Boolean)
Static Busy As Boolean
If timestamp < 0 Then
If lckfrm > 0 Then Exit Sub
timestamp = timeGetTime + 1000
End If
If Abs(timestamp - timeGetTime) < 1000 Then Exit Sub
timestamp = timeGetTime + 1000
If Forms.count > 5 Then Exit Sub
If Busy Then Exit Sub
If Not bstack.IamAnEvent Then
If bstack.TaskMain Then Exit Sub
If KeyPressed2(&H11, &H43) Then
Busy = True
Form1.EXECSTOP
timestamp = timeGetTime + 1000
Busy = False
Exit Sub
ElseIf KeyPressedLong(&H13) = 0 Then
Exit Sub
End If
Busy = True
ResetBreak
If Form1.mybreak1() Then
    
        Modalid = 0
        If Not TaskMaster Is Nothing Then TaskMaster.Dispose
        NOEXECUTION = True
        MOUT = True
         MKEY$ = "@Start" + Chr$(13)
            B$ = " "
            MyEr "", ""
        
        
        once = False
         Prefresh(GetCode(bstack.Owner)).k1 = 0
        MyDoEvents0 bstack.Owner
        
        End If
    
End If
ResetBreak
timestamp = timeGetTime + 1000
Busy = False
End Sub
Public Sub ClearStr(a$)
Dim i As Long, j As Long
                While FastSymbol(a$, vbCrLf, , 2)
                i = 1
                While FastOperator(a$, vbCrLf, i, 2)
                Wend
                j = Len(a$)
                If j = 0 Then Exit Sub
                i = MyTrimL(a$)
                If i > j Then Exit Sub
                Wend
End Sub
Private Function IsRandom(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
If FastSymbol(a$, "!") Then
If IsExp(bstack, a$, R, , True) Then
'' CHOOSE SEED AND SAVEIT TO BASESTACK
On Error Resume Next
simplestack1 = rndbase
RandomizeIt rndbase, CLng(Int(R))

If Err Then
Err.Clear
R = 0
End If

Else
rndbase = simplestack1
End If
     
ElseIf IsExp(bstack, a$, R, , True) Then
    R = Int(R)
    
        If FastSymbol(a$, ",") Then
        Dim p As Variant
        If Not IsExp(bstack, a$, p, , True) Then IsRandom = False: Exit Function
        p = MyRound(p)
        Dim pp As Variant
        If p > R Then pp = p: p = R: R = pp
        Else
        p = 0
        
        End If
    
    R = Int((R - p + 1) * RndM(rndbase) + p)
    If SG < 0 Then R = -R
     On Error GoTo 0
    IsRandom = True
    Else
      RandomizeIt rndbase, timeGetTime
     R = SG * True
      
    End If
    IsRandom = FastSymbol(a$, ")", True)

End Function
Private Function IsArrayFun(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim s$, w1 As Long, pppp As mArray, anything As Object, p As Variant, ms As mStiva, usehandler As mHandler
If IsStrExp(bstack, a$, s$) Then
        If bstack.lastobj Is Nothing Then
            If Right$("!!" & s$, 2) = "()" Then
                Mid$(s$, Len(s$), 1) = " "
                s$ = RTrim$(s$)
             Else
                w1 = InStr("!" & s$, "(") - 1
                If w1 > 0 And w1 <= Len(s$) Then
                    s$ = Left$(s$, w1)
                ElseIf neoGetArray(bstack, s$, pppp) Then
                GoTo check123678
                Else
                s$ = s$ + "("
                End If
            End If
            If neoGetArray(bstack, s$, pppp) Then
check123678:
                If Not pppp.Arr Then NotArray: Exit Function
                If FastSymbol(a$, ",") Then
                    IsArrayFun = NeoGetArrayItem(pppp, bstack, s$, w1, a$)
                Else
                    IsArrayFun = FastSymbol(a$, ")", True)
                    w1 = 0
                   ' w1 = pppp.index
                End If
checkIterator:
                If Not pppp.IsEmpty Then
                    If MyIsObject(pppp.item(w1)) Then
                        Set anything = pppp.item(w1)
                        If Not anything Is Nothing Then
                        If TypeOf anything Is Group Then
                            bstack.soros.CopyGroupObj pppp.item(w1), anything
                            Set bstack.lastobj = anything
                        Else
                            Set bstack.lastobj = anything
                        End If
                        
                        Else
                            Set bstack.lastobj = Nothing
                        End If
                        R = 0
                    Else
                        Set bstack.lastobj = Nothing
                        
                        R = pppp.itemnumeric(w1)
                        If SG < 0 Then R = -R
                    End If
                Else
                    
                    EmptyArray
                End If
            Else
                 Set bstack.lastobj = Nothing
                NotArray
            End If

                 Exit Function
            
        ElseIf TypeOf bstack.lastobj Is mArray Then
                Set pppp = bstack.lastobj
                GoTo check123678
        Else
            Set bstack.lastobj = Nothing
            SyntaxError
        End If
    ElseIf IsExp(bstack, a$, p) Then
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler = bstack.lastobj
                If usehandler.indirect >= 0 Then
                    Set pppp = var(usehandler.indirect)
                    If usehandler.UseIterator Then
                    pppp.index = usehandler.index_cursor
                    End If
                    GoTo check123678
                ElseIf TypeOf usehandler.objref Is mArray Then
                    Set pppp = usehandler.objref
                    If usehandler.UseIterator Then
                    pppp.index = usehandler.index_cursor
                    End If
                    If usehandler.UseIterator Then
                    If Not pppp.Arr Then NotArray: Exit Function
                    If FastSymbol(a$, ",") Then
                        Set bstack.lastobj = Nothing
                        Set usehandler = Nothing
                        IsArrayFun = IsExp(bstack, a$, R, , True)
                        IsArrayFun = FastSymbol(a$, ")", True)
                        w1 = R
                    Else
                        IsArrayFun = FastSymbol(a$, ")", True)
                        w1 = pppp.index
                    End If
                    If Not IsArrayFun Then Exit Function
                    GoTo checkIterator
                    Else
                    GoTo check123678
                    End If
                ElseIf TypeOf usehandler.objref Is mStiva Then
                    Set ms = usehandler.objref
                    Set bstack.lastobj = Nothing
                    Set usehandler = Nothing
                    If FastSymbol(a$, ",") Then
                    If IsExp(bstack, a$, p, , True) Then
                    Set bstack.lastobj = ms.ExportArray(CLng(MyRound(p)))
                    End If
                    Else
                        Set bstack.lastobj = ms.ExportArray(ms.count)
                        
                    End If
                    Set ms = Nothing
                    IsArrayFun = FastSymbol(a$, ")", True)
                    Exit Function
                Else
                     Set bstack.lastobj = Nothing
                    NotArray
                End If
            ElseIf TypeOf bstack.lastobj Is mArray Then
                Set pppp = bstack.lastobj
                GoTo check123678
            End If
        End If
    Else
        Set bstack.lastobj = New mArray
        IsArrayFun = FastSymbol(a$, ")", True)
    End If
End Function
Private Function IsStackObj(v$, bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim anything As Object, anything2 As Object, p As Variant, usehandler As mHandler, ms As mStiva
    Set usehandler = New mHandler
    Set anything = usehandler
    usehandler.t1 = 3
    
    If FastSymbol(a$, ":=", , 2) Then
        
        If Not GetData(bstack, a$, anything2) Then
            Exit Function
        End If
        Set usehandler.objref = anything2
        Set anything2 = Nothing
    ElseIf IsLabelSymbolNew(a$, "йаты", "DOWN", Abs(AscW(v$) = 83)) Then
    
        If IsExp(bstack, a$, p) Then
            If Not bstack.lastobj Is Nothing Then
                Set anything2 = bstack.lastobj
                If TypeOf anything2 Is mHandler Then
                    Set usehandler = anything2
                    If usehandler.t1 = 3 Then
                        If Not usehandler.objref Is Nothing Then
                            If TypeOf usehandler.objref Is mStiva Then
                                Set ms = New mStiva
                                FastSymbol a$, ","
                                If IsExp(bstack, a$, p, , True) Then
                                    ms.SplitStackBottom anything2, CLng(Fix(p))
                                End If
                                Set usehandler = anything
                                Set usehandler.objref = ms
                                GoTo normalexit
                            End If
                        End If
                    End If
                End If
            End If
        End If
        NoStackObjectFound a$
    ElseIf IsLabelSymbolNew(a$, "амы", "UP", Abs(AscW(v$) = 83)) Then
        If IsExp(bstack, a$, p) Then
            If Not bstack.lastobj Is Nothing Then
                Set anything2 = bstack.lastobj
                If TypeOf anything2 Is mHandler Then
                    Set usehandler = anything2
                    If usehandler.t1 = 3 Then
                        If Not usehandler.objref Is Nothing Then
                            If TypeOf usehandler.objref Is mStiva Then
                                Set ms = New mStiva
                                FastSymbol a$, ","
                                If IsExp(bstack, a$, p, , True) Then
                                    ms.SplitStackTop anything2, CLng(Fix(p))
                                End If
                                Set usehandler = anything
                                Set usehandler.objref = ms
                                GoTo normalexit
                            End If
                        End If
                    End If
                End If
            End If
        End If
        NoStackObjectFound a$
    Else
        Set usehandler.objref = New mStiva
    End If
normalexit:
    Set bstack.lastobj = anything
    R = 0
    IsStackObj = True

End Function
Private Function IsStack(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim anything As Object, pppp As mArray, p As Variant, anything2 As Object, usehandler As mHandler, usestiva As mStiva
If IsExp(bstack, a$, R) Then
    If CheckStackObj(bstack, anything) Then
            If TypeOf anything Is mArray Then
                Set pppp = anything
                Set usestiva = New mStiva
                usestiva.MergeBottomCopyArray pppp
                Set usehandler = New mHandler
                Set bstack.lastobj = usehandler
                usehandler.t1 = 3
                Set usehandler.objref = usestiva
                Set usestiva = Nothing
                Set usehandler = Nothing
                IsStack = FastSymbol(a$, ")", True)
                Exit Function
            End If
            If Not TypeOf anything Is mStiva Then GoTo stack12948
            If FastSymbol(a$, ",") Then
stack99981:
                Set usestiva = anything
                If IsExp(bstack, a$, p) Then
                    If p <> 0 Then
                        Set anything = usestiva.CopyMe2(CLng(Fix(p)))
                    Else
                        If Not bstack.lastobj Is Nothing Then
                            If CheckStackObj(bstack, anything2) Then
                                    Set usestiva = anything2
                                    Set anything2 = usestiva.CopyMe()
                                    Set usestiva = anything
                                    Set anything = usestiva.MergeFromOther(anything2)
                                    If FastSymbol(a$, ",") Then GoTo stack99981
                                    
                                Else
                                    GoTo stack129481
                                End If
                        Else
stack129481:
                         NoStackObjectToMerge
                        End If
                        
                    End If
                Else
                MissParam a$
                Exit Function
                End If
            Else
                Set usestiva = anything
                Set anything = usestiva.CopyMe()
            End If
            Set usehandler = New mHandler
            usehandler.t1 = 3
            Set usehandler.objref = anything
            Set bstack.lastobj = usehandler
            Set anything = Nothing
            Set usehandler = Nothing
            Set usestiva = Nothing
        Else
stack12948:
        MyEr "Not a stack object", "дЕМ БЯчЙА АМТИЙЕъЛЕМО СЫЯОЩ"
        End If
        IsStack = FastSymbol(a$, ")", True)
        Exit Function
Else
        MissParam a$
End If
End Function
Private Function IsCeil(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim pp As Variant
    If IsExp(bstack, a$, R, , True) Then
    ''On Error Resume Next
    If FastSymbol(a$, ")") Then
            R = IIf(Fix(R) = R, R, Int(R) + 1)
            If SG < 0 Then R = -R
            IsCeil = True
    Else
            MissParam a$
    End If
    End If
 
 End Function
Private Function IsFloor(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim pp As Variant
    If IsExp(bstack, a$, R, , True) Then
    ''On Error Resume Next
    If FastSymbol(a$, ")") Then
            R = Int(R)
            If SG < 0 Then R = -R
            IsFloor = True
    Else
            MissParam a$
    End If
    End If
 
 End Function
Private Function IsRound(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim pp As Variant, i As Integer
    If IsExp(bstack, a$, R, , True) Then
    On Error Resume Next
    If FastSymbol(a$, ")") Then
            
            R = MyRound(R, 13)
           If SG < 0 Then R = -R
            IsRound = True
    ElseIf FastSymbol(a$, ",", True) Then
        If IsExp(bstack, a$, pp) Then
        
          R = MyRound(R, pp)
         If SG < 0 Then R = -R
          If Err.Number > 0 Then Err.Clear
     IsRound = FastSymbol(a$, ")", True)
     End If
    Else
                MissParam a$
    End If
    End If
End Function
Private Function IsInt(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
    If IsExp(bstack, a$, R, , True) Then
    On Error Resume Next
    Set bstack.lastobj = Nothing
    R = Int(R)
    If SG < 0 Then R = -R
    If Err.Number > 0 Then
    
    MyErMacro a$, "long conversion failed", "г ЛЕТАТЯОПч СЕ АЙщЯАИО АПщТУВЕ"
    Exit Function
    End If
    On Error GoTo 0
    IsInt = FastSymbol(a$, ")", True)
    Else
                    
                MissParam a$
    
    
    End If
 
End Function
Private Function IsUint(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
If IsExp(bstack, a$, R, , True) Then
 If VarType(R) = vbInteger Then
     On Error Resume Next
    
        R = SG * UINT(R)
     
        On Error GoTo 0
Else
    On Error Resume Next
        If R > 2147483647# Then
         MyErMacro a$, "Overflow long, expect lower than (2147483648)", "уПЕЯВЕъКИСГ АЙЕЯАъОУ, ПЕЯИЛщМЫ ЛИЙЯЭТЕЯО АПЭ (2147483648)"
          
        Exit Function
    ElseIf R < -2147483648# Then
        MyErMacro a$, "Overflow long, expect greater than (-2147483649)", "уПЕЯВЕъКИСГ АЙЕЯАъОУ, ПЕЯИЛщМЫ ЛЕЦАКЩТЕЯО АПЭ (-2147483649)"
         IsUint = False
        Exit Function
    End If
    
    R = SG * uintnew(R)
    If Err.Number > 0 Then
        MyErMacro a$, "Sign to Unsigned long failed", "г ЛЕТАТЯОПч АЙЕЯАъОУ ЛЕ ПЯЭСГЛО СЕ АЙщЯАИО ВЫЯъР ПЯЭСГЛО АПщТУВЕ"
        IsUint = False
        Exit Function
    End If
    On Error GoTo 0
End If
    IsUint = FastSymbol(a$, ")", True)
    Exit Function
       Else
                    
                MissParam a$
    End If
End Function
Private Function IsSint(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim p As Variant, rB As Byte, ri As Integer, dn As Long, rd As Double, usehandler As mHandler
p = 4
 If IsExp(bstack, a$, R) Then
 If Not bstack.lastobj Is Nothing Then
If Not TypeOf bstack.lastobj Is mHandler Then: Exit Function
Set usehandler = bstack.lastobj
 With usehandler
    If .t1 = 4 Then Set bstack.lastobj = Nothing: GoTo conthere
    If .t1 <> 2 Then GoTo err1256
    If Not TypeOf .objref Is MemBlock Then GoTo err1256
    If Not FastSymbol(a$, ",") Then GoTo err1256
    If Not IsExp(bstack, a$, p, , True) Then GoTo err1256

            Select Case .objref.ItemSize
            Case 1
                If .objref.ValidArea2(p, 1) Then
                GetMem1 .objref.GetPtr(p), rB
                R = SG * cUbyte(CDbl(rB))
                Else
                    GoTo err1256
                End If
            Case 2
                If .objref.ValidArea2(p, 2) Then
                GetMem2 .objref.GetPtr(p), ri
                R = SG * cUint(CDbl(UINT(CLng(ri))))
                Else
                    GoTo err1256
                End If
            Case 8
                If .objref.ValidArea2(p, 8) Then
                GetMem8 .objref.GetPtr(p), rd
                R = SG * rd
                Else
                    GoTo err1256
                End If
            Case 4
                If .objref.ValidArea2(p, 4) Then
                GetMem4 .objref.GetPtr(p), dn
                R = SG * dn
                
            Else
err1256:
                Set bstack.lastobj = Nothing
                Set usehandler = Nothing
                MyErMacro a$, "Wrong Size-Position for reading buffer", "кэХОР лщЦЕХОР-ХщСГ, ЦИА ДИэБАСЛА дИэЯХЯЫСГР"
                
                Exit Function
                End If
            End Select
            
 End With
 Set bstack.lastobj = Nothing
 Set usehandler = Nothing
  IsSint = FastSymbol(a$, ")", True)
    Exit Function
 End If
conthere:
 If FastSymbol(a$, ",") Then
 If IsExp(bstack, a$, p, , True) Then
 If p = 4 Then GoTo contsint1
 
 On Error Resume Next
    If R < 0 Then
    
      MyErMacro a$, "Unsigned Integer can't be negative", "о ВЫЯъР ПЯЭСГЛО АЙщЯАИОР ДЕМ ЛПОЯЕъ МА ЕъМАИ АЯМГТИЙЭР"
   
    Exit Function
    End If
    If p = 2 Then
    R = SG * cUint(R)
    Else
    R = SG * cUbyte(R)
    End If
    If Err.Number > 0 Then
    
      MyErMacro a$, "Unsigned Integer to sign failed", "г ЛЕТАТЯОПч ВЫЯъР ПЯЭСГЛОУ АЙщЯАИО СЕ АЙщЯАИО ЛЕ ПЯЭСГЛО, АПщТУВЕ"
    IsSint = False
    Exit Function
    
    End If
    On Error GoTo 0
  IsSint = FastSymbol(a$, ")", True)
    Exit Function
    
 End If
 Else
contsint1:
    On Error Resume Next
    If R < 0 Then
        Unsignlongnegative a$
    Exit Function
    End If
    R = SG * signlong(R)
    If Err.Number > 0 Then
    Unsignlongfailed a$

    IsSint = False
    Exit Function
    End If
    End If
    On Error GoTo 0
  IsSint = FastSymbol(a$, ")", True)
    Exit Function
      Else
                    
                MissParam a$
    End If
End Function
Private Function IsUsgn(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
If IsExp(bstack, a$, R, , True) Then
 
    On Error Resume Next
    If R > Pow2minusOne(32) Then R = Pow2minusOne(32)
    R = Fix(R)
    If R < 0 Then R = 0
    
    If SG < 0 Then R = -R
    On Error GoTo 0
IsUsgn = FastSymbol(a$, ")", True)
    Exit Function
       Else
                    
                MissParam a$
    End If
End Function
Private Function IsLOWORD(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
If IsExp(bstack, a$, R, , True) Then
    On Error Resume Next
    
    R = SG * Int((R - Int(R / 65536#) * 65536#))
    If Err.Number > 0 Then
    
    WrongArgument a$
        Exit Function
    
    End If
    On Error GoTo 0
    
   IsLOWORD = FastSymbol(a$, ")", True)
        Else
                
                MissParam a$
 End If
End Function
Private Function IsHIWORD(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
  If IsExp(bstack, a$, R, , True) Then
    On Error Resume Next
    
    R = SG * Int(Int(R / 256) / 256)
    If Err.Number > 0 Then
    
    WrongArgument a$
  
    IsHIWORD = False
    Exit Function
    End If
    On Error GoTo 0
    
IsHIWORD = FastSymbol(a$, ")", True)
      Else
                
                MissParam a$
    
    End If
End Function
Private Function IsLen(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim anything As Object, p As Variant, s$, usehandler As mHandler
    If IsExp(bstack, a$, p) Then
len1234:
        If Typename(bstack.lastobj) = mHdlr Then
            Set usehandler = bstack.lastobj
            While Typename$(usehandler.objref) = mHdlr
            Set usehandler = bstack.lastobj
            Set bstack.lastobj = usehandler.objref
            Wend
            
            Set bstack.lastobj = Nothing
            With usehandler
                If .indirect < 0 Then
                
                    If .t1 = 1 Then
                            If .objref.StructLen > 0 Then
                                R = SG * .objref.StructLen
                            Else
                                R = SG * .objref.count
                            End If
                            IsLen = FastSymbol(a$, ")", True)
                        Exit Function
                    ElseIf .t1 = 2 Then
                        R = SG * .objref.SizeByte()
                        IsLen = FastSymbol(a$, ")", True)
                        Exit Function
                    ElseIf .t1 = 3 Then
                        ' if CheckDeepAny
                        Set anything = usehandler
                        If CheckDeepAny(anything) Then
                            If Typename(anything) = mHdlr Then
                                Set usehandler = anything
                                R = SG * usehandler.objref.count
                            Else
                                R = SG * anything.count
                            End If
                        Else
                            R = 0
                        End If
                        IsLen = FastSymbol(a$, ")", True)
                        Exit Function
                    ElseIf .t1 = 0 Then
                        R = 0
                        IsLen = FastSymbol(a$, ")", True)
                        Exit Function
                    ElseIf .t1 = 4 Then
                        R = SG * usehandler.index_start
                        IsLen = FastSymbol(a$, ")", True)
                        Exit Function
                    End If
                Else
                    IsLen = FastSymbol(a$, ")", True)
                    R = SG * -1
                End If
            End With
        ElseIf Typename(bstack.lastobj) = myArray Then
                R = SG * bstack.lastobj.count
                IsLen = FastSymbol(a$, ")", True)
                Set bstack.lastobj = Nothing
                Exit Function
        Else
                IsLen = FastSymbol(a$, ")", True)
                R = SG * -1
                Set bstack.lastobj = Nothing
        End If
        MissParam a$
    ElseIf IsStrExp(bstack, a$, s$) Then
        If bstack.lastobj Is Nothing Then
            R = SG * CDbl(Len(s$) - (LenB(s$) Mod 2 = 1) / 2#)
        Else
            GoTo len1234
        End If
        IsLen = FastSymbol(a$, ")", True)
    Else
        MissParam a$
    End If

End Function
Private Function IsLenDisp(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim p As Variant, s$, usehandler As mHandler

    If IsExp(bstack, a$, p) Then
    If Typename(bstack.lastobj) = mHdlr Then
    ' check this please
    Set usehandler = bstack.lastobj
    If usehandler.t1 = 4 Then wronguseofenum a$: Exit Function
    
    With usehandler
    If .indirect < 0 Then
    If TypeOf .objref Is FastCollection Then
        R = SG * .objref.count
        Set bstack.lastobj = Nothing
        IsLenDisp = FastSymbol(a$, ")", True)
        Exit Function
    ElseIf TypeOf .objref Is MemBlock Then
        R = SG * .objref.items
        Set bstack.lastobj = Nothing
        IsLenDisp = FastSymbol(a$, ")", True)
        Exit Function
    End If
    Else
     R = SG * -1
     IsLenDisp = FastSymbol(a$, ")", True)
        Exit Function
    ' length of object???
    End If
    End With
    End If
    
    MissParam a$
    ElseIf IsStrExp(bstack, a$, s$) Then
    R = SG * RealLen(s$)
    
    
    IsLenDisp = FastSymbol(a$, ")", True)
    Else
                    
                MissParam a$
    End If

End Function
Private Function IsDocLen(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, a$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If Typename(var(w1)) = doc Then
                    R = SG * var(w1).SizeCRLF
                Else
                    R = SG * Len(var(w1))
                End If
                
                IsDocLen = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      R = SG * pppp.item(w2).SizeCRLF
                      Else
                      R = SG * Len(pppp.item(w2))
                      End If
                Else
                
                End If
                    
                IsDocLen = FastSymbol(a$, ")", True)
    Else
                    
                MissParam a$
    End If
End Function
Private Function IsDocWords(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, a$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If Typename(var(w1)) = doc Then
                    R = SG * var(w1).WordCount
                Else
                MissFuncParammeterdOCVar a$
               End If
                
                IsDocWords = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      R = SG * pppp.item(w2).WordCount
                      Else
                       MissFuncParammeterdOCVar a$
                
                      End If
                Else
                
                End If
                    
                IsDocWords = FastSymbol(a$, ")", True)
    Else
                    
                MissParam a$
    End If
End Function
Private Function IsDocUniqueWords(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, a$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If Typename(var(w1)) = doc Then
                    R = SG * var(w1).UniqueWords
                Else
                MissFuncParammeterdOCVar a$
               End If
                
                IsDocUniqueWords = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      R = SG * pppp.item(w2).UniqueWords
                      Else
                       MissFuncParammeterdOCVar a$
                
                      End If
                Else
                
                End If
                    
                IsDocUniqueWords = FastSymbol(a$, ")", True)
    Else
                    
                MissParam a$
    End If
End Function

Private Function IsCompMinMax(ByVal dn As Long, bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim s$, w1 As Long, w2 As Long, s1$, dd As Long, w3 As Long, pppp As mArray, pppp1 As mArray
    w1 = Abs(IsLabel(bstack, a$, s$))
    If w1 = 1 Or w1 = 4 Then dd = 1  'WE NEED NUMBERS
    If w1 = 5 Or w1 = 7 Then dd = 2 'WE NEED NUMBERS
    If w1 = 0 Then MissingnumVar:: Exit Function
    If (w1 = 3 Or w1 = 6) And dd > 0 Then SyntaxError:: Exit Function
    If dd = 1 Then
        If GetVar(bstack, s$, w1) Then
                If Not FastSymbol(a$, ",") Then MissingnumVar:: Exit Function
                w3 = Abs(IsLabel(bstack, a$, s1$))
            If w3 = 1 Or w3 = 4 Then
                If GetVar(bstack, s1$, w2) Then
                Select Case dn
                Case 1
                    If var(w1) < var(w2) Then
                    
                        R = var(w1)
                        If SG < 0 Then R = -R
                    Else
                        R = var(w2)
                        If SG < 0 Then R = -R
                    End If
                Case 2
                    If var(w1) > var(w2) Then
                        R = var(w1)
                        If SG < 0 Then R = -R
                    Else
                        R = var(w2)
                        If SG < 0 Then R = -R
                    End If
                Case Else
                    If var(w1) = 0 Then
                    If var(w2) = 0 Then
                    R = 0
                    Else
                    R = Sgn(0 - MyRound(var(w2), 10))
                    If SG < 0 Then R = -R
                    End If
                    Else
                    If MyRound((var(w2) - var(w1)) / var(w1), 10) = 0 Then
                    R = 0
                    ElseIf var(w1) > var(w2) Then
                    R = SG
                    Else
                        R = -SG
                    End If
                    End If
                
                
                  
                End Select
                    
                    IsCompMinMax = FastSymbol(a$, ")", True)
                Exit Function
                Else
                    Nosuchvariable s1$
                    
                    Exit Function
                End If
            ElseIf w3 = 5 Or w3 = 7 Then
                If neoGetArray(bstack, s1$, pppp) Then
                    If Not NeoGetArrayItem(pppp, bstack, s1$, w2, a$) Then Exit Function
                    Select Case dn
                Case 1
                    If var(w1) < pppp.itemnumeric(w2) Then
                        R = var(w1)
                        If SG < 0 Then R = -R
                    Else
                        R = pppp.itemnumeric(w2)
                        If SG < 0 Then R = -R
                    End If
                Case 2
                    If var(w1) > pppp.itemnumeric(w2) Then
                        R = var(w1)
                        If SG < 0 Then R = -R
                    Else
                        R = pppp.itemnumeric(w2)
                        If SG < 0 Then R = -R
                    End If
              Case Else
                   If var(w1) = 0 Then
                            If pppp.itemnumeric(w2) = 0 Then
                            R = 0
                            Else
                            R = Sgn(0 - MyRound(pppp.itemnumeric(w2), 10))
                            If SG < 0 Then R = -R
                            End If
                    Else
                            R = Sgn(MyRound(((var(w1) - pppp.itemnumeric(w2)) / var(w1)), 10))
                            If SG < 0 Then R = -R
                    End If
              
                
                    End Select
                    
                    IsCompMinMax = FastSymbol(a$, ")", True)
                Else
                    Nosuchvariable s1$
                    
                    Exit Function
                End If
            Else
                MissingnumVar
                
                Exit Function
            End If
        Else
            Nosuchvariable s$
            
            Exit Function
        End If
        
    ElseIf dd = 2 Then
        If neoGetArray(bstack, s$, pppp) Then
            If Not NeoGetArrayItem(pppp, bstack, s$, w1, a$) Then Exit Function
            If Not FastSymbol(a$, ",") Then MissingnumVar:: Exit Function
                w3 = Abs(IsLabel(bstack, a$, s1$))
            If w3 = 1 Or w3 = 4 Then
                    If GetVar(bstack, s1$, w2) Then
                    Select Case dn
                    Case 1
                        If pppp.itemnumeric(w1) < var(w2) Then
                            R = pppp.itemnumeric(w1)
                            If SG < 0 Then R = -R
                        Else
                            R = var(w2)
                            If SG < 0 Then R = -R
                        End If
                    Case 2
                        If pppp.itemnumeric(w1) > var(w2) Then
                            R = pppp.itemnumeric(w1)
                            If SG < 0 Then R = -R
                        Else
                            R = var(w2)
                            If SG < 0 Then R = -R
                        End If
                    Case Else
                    
                    
                      If pppp.itemnumeric(w1) = 0 Then
                            If var(w2) = 0 Then
                            R = 0
                            Else
                            R = Sgn(0 - MyRound(var(w2), 10))
                            If SG < 0 Then R = -R
                            End If
                    Else
                            R = Sgn(MyRound(((pppp.item(w1) - var(w2)) / pppp.item(w1)), 10))
                            If SG < 0 Then R = -R
                    End If
                        
                    End Select
                        
                        IsCompMinMax = FastSymbol(a$, ")", True)
                    Else
                        MissingnumVar
                        
                        Exit Function
                    End If
            ElseIf w3 = 5 Or w3 = 7 Then
                    If neoGetArray(bstack, s1$, pppp1) Then
                        If Not NeoGetArrayItem(pppp1, bstack, s1$, w2, a$) Then Exit Function
                    Select Case dn
                    Case 1
                        If pppp.itemnumeric(w1) < pppp1.itemnumeric(w2) Then
                            R = pppp.itemnumeric(w1)
                            If SG < 0 Then R = -R
                        Else
                            R = pppp1.itemnumeric(w2)
                            If SG < 0 Then R = -R
                        End If
                    Case 2
                        If pppp.itemnumeric(w1) > pppp1.itemnumeric(w2) Then
                            R = pppp.itemnumeric(w1)
                            If SG < 0 Then R = -R
                        Else
                            R = pppp1.itemnumeric(w2)
                            If SG < 0 Then R = -R
                        End If
                    Case Else
                        If pppp.itemnumeric(w1) = 0 Then
                            If pppp1.itemnumeric(w2) = 0 Then
                            R = 0
                            Else
                            R = Sgn(0 - MyRound(pppp1.itemnumeric(w2), 10))
                            If SG < 0 Then R = -R
                            End If
                    Else
                            R = Sgn(MyRound(((pppp.itemnumeric(w1) - pppp1.itemnumeric(w2)) / pppp.itemnumeric(w1)), 10))
                            If SG < 0 Then R = -R
                    End If
                    End Select
                        
                        IsCompMinMax = FastSymbol(a$, ")", True)
                    Else
                        MissingnumVar
                        
                        Exit Function
                    End If
            Else
                MissingnumVar
                
                Exit Function
            End If
        Else
            MissingnumVar
            
            Exit Function
        End If
    ElseIf w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
            If Not FastSymbol(a$, ",") Then MissingnumVar:: Exit Function
                w3 = Abs(IsLabel(bstack, a$, s1$))
                If w3 = 6 Then
                    If Not neoGetArray(bstack, s1$, pppp) Then MissingStrVar::   Exit Function
                    If Not NeoGetArrayItem(pppp, bstack, s1$, w2, a$) Then Exit Function

                    R = CompareStr3(var(w1), CStr(pppp.item(w2)))    'StrComp(var(w1), CStr(pppp.item(w2)))
                    If SG < 0 Then R = -R

                ElseIf w3 = 3 Then
                    If Not GetVar(bstack, s1$, w2) Then: Exit Function

                    R = CompareStr3(var(w1), var(w2))  ' StrComp(var(w1), var(w2))
                    If SG < 0 Then R = -R
                            Else
                
                MissFuncParameterStringVarMacro a$
                Exit Function
                End If
                
                IsCompMinMax = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
            End If
    ElseIf w1 = 6 Then
            If neoGetArray(bstack, s$, pppp) Then
                If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                If Not FastSymbol(a$, ",") Then MissingnumVar:: Exit Function
                w3 = Abs(IsLabel(bstack, a$, s1$))
                If w3 = 6 Then
                    If Not neoGetArray(bstack, s1$, pppp1) Then MissingStrVar::   Exit Function
                    If Not NeoGetArrayItem(pppp1, bstack, s1$, w3, a$) Then Exit Function

                    R = CompareStr3(pppp.item(w2), pppp1.item(w3))
                    If SG < 0 Then R = -R
 
                ElseIf w3 = 3 Then
                    If Not GetVar(bstack, s1$, w3) Then: Exit Function

                    R = CompareStr3(pppp.item(w2), var(w3))
                    If SG < 0 Then R = -R
                Else
                
                MissFuncParameterStringVarMacro a$
                Exit Function
                End If
                
                IsCompMinMax = FastSymbol(a$, ")", True)
            Else
                
                MissParam a$
            End If
    Else
                 
                MissParam a$
    End If

End Function
Private Function IsEval(v$, bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim p As Variant, anything As Object, w3 As Long, w2 As Long, w1 As Long, pp As Variant, rB As Byte, ri As Integer, dn As Long, s$, ss$
Dim db As Double, pppp As mArray, IsGroupOnly As Group, ReadAsSingle As Boolean, ds As Single
Dim ThisGroup As Group, t$, usehandler As mHandler, usehandler1 As mHandler
w1 = 1
t$ = aheadstatus(a$, False, w1)
s$ = Left$(a$, w1)
ss$ = s$
    If CheckGroupOrPointer(bstack, s$, IsGroupOnly, pppp, w2) Then
    
            If Not IsGroupOnly Is Nothing Then
               
                If Not pppp Is Nothing And w2 <> -2 Then
                    a$ = Mid$(a$, w1 + 1 - Len(s$))
                    If IsGroupOnly.HasParameters Then
                        If Mid$(a$, 1, 1) <> "," Then
                       
                        IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, w2) = 1
                        R = bstack.LastValue
                        If lookOne(a$, ",") And Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        Exit Function
                        Else
                        Mid$(a$, 1, 1) = "("
                        IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, w2) = 1
                        R = bstack.LastValue
                        End If

                    Else
                        IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, w2) = 1
                        R = bstack.LastValue
                        If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        If lookOne(a$, ",") And Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        IsEval = FastSymbol(a$, ")", True) And IsEval
                    End If
                    
                Else
                    If IsGroupOnly.HasParameters Then
                        If Mid$(a$, w1 - Len(s$) + 1, Len(s$)) <> ")" Then
                            ri = False
                            If Mid$(a$, w1, 1) = "," Then Mid$(a$, w1 - Len(s$) + 1, Len(s$)) = "(" + space$(Len(s$) - 1): ri = True
                            If IsGroupOnly.HasStrValue And Left$(t$, 1) <> "N" Then
                            If IsStr1(bstack, a$, ss$) Then
                                If ri Then
                                    IsEval = IsExp(bstack, ss$, R)
                                ElseIf FastSymbol(a$, ")") Then
                                    IsEval = IsExp(bstack, ss$, R)
                                End If
                            Else
                                Exit Function
                            End If
                        Else
                            If ri Then
                                IsEval = IsNumber(bstack, a$, R)
                            ElseIf IsNumber(bstack, a$, R) Then
                                IsEval = FastSymbol(a$, ")")
                            End If
                            Exit Function
                        End If
                        
                        
                        Else
                        If IsGroupOnly.HasStrValue And Left$(t$, 1) <> "N" Then
                            If IsStr1(bstack, a$, ss$) Then
                                IsEval = IsExp(bstack, ss$, R)
                            Else
                                Exit Function
                            End If
                        Else
                        
                        IsEval = IsNumber(bstack, a$, R)
                        End If
                        If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                        IsEval = FastSymbol(a$, ")", True) And IsEval
                        End If
                    Else
                        If IsGroupOnly.HasStrValue And Left$(t$, 1) <> "N" Then
                            If IsStr1(bstack, a$, ss$) Then
                                If FastSymbol(a$, ")") Then
                                    IsEval = IsExp(bstack, ss$, R)
                                    If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                                End If
                            End If
                            
                        Else
                            IsEval = IsNumber(bstack, a$, R)
                            If Typename(bstack.lastobj) = mHdlr Then GoTo handlehandlers
                            IsEval = FastSymbol(a$, ")", True) And IsEval
                        End If
                    End If
                End If
                If SG < 0 Then R = -R
             '   If Not bstack.lastobj Is Nothing Then GoTo conthere
                Exit Function
            Else
            a$ = Mid$(a$, w1 + 1 - Len(s$))
            GoTo getgroup
            End If
    ElseIf IsExp(bstack, ss$, p) Then
    If Len(ss$) > 0 Then Mid$(a$, w1 + 1 - Len(ss$), Len(ss$)) = ss$
    Mid$(a$, 1, w1 + 1 - Len(ss$)) = space$(w1 - Len(ss$))
handlehandlers:
        w1 = 0
        s$ = vbNullString
        If Typename(bstack.lastobj) = mHdlr Then
            Set anything = bstack.lastobj
            Set usehandler = bstack.lastobj
            If usehandler.IamEnum Then
                     R = usehandler.index_cursor
                     If SG < 0 Then R = -R
                     If usehandler.t1 = 0 Then
                     If IsObject(usehandler.objref) Then
                     Set bstack.lastobj = usehandler.objref
                     Else
                      Set bstack.lastobj = Nothing
                     End If
                     Else
                      Set bstack.lastobj = Nothing
                     End If
                    
                      IsEval = FastSymbol(a$, ")", True)
                     Exit Function
                     ElseIf Not CheckLastHandlerOrIterator(anything, w3) Then
                     InternalError
                     IsEval = False
                     Exit Function
            End If
            Set usehandler = anything
            With usehandler
                If .t1 = 1 Then
                        If FastSymbol(a$, ",") Then
                        If IsExp(bstack, a$, pp, , True) Then
                            w3 = CLng(Int(pp))
                            If w3 < 0 Or w3 >= .objref.count Then
                            indexout a$
                            Exit Function
                            End If
                        w1 = True
                        End If
                        End If
                    On Error GoTo there12
                    If w3 >= 0 Then
                        .objref.index = w3
                        .objref.Done = True
                    End If
                    If .objref.Done Then
                        If w1 Then
                        R = .objref.KeyToNumber
                        If SG < 0 Then R = -R
                        Set bstack.lastobj = Nothing
                        ElseIf FastSymbol(a$, "!") Then
                            R = .objref.index
                            If SG < 0 Then R = -R
                            Set bstack.lastobj = Nothing
                        Else
                            If .objref.IsObj Then
                                R = rValue(bstack, usehandler.objref.ValueObj)
                                
                                '' bstack.lastobj is .objref.ValueObj
                                If SG < 0 Then R = -R
                            Else
                                R = MyVal(.objref.Value)
                                If SG < 0 Then R = -R
                                Set bstack.lastobj = Nothing
                            End If
                        End If
                        
                        IsEval = FastSymbol(a$, ")", True)
                    End If
there12:
                    On Error GoTo 0
                    Set anything = Nothing
                    Exit Function
                ElseIf .t1 = 2 Then
                    ' p is offset for items not bytes
                    If FastSymbol(a$, ",") Then
                        If IsExp(bstack, a$, p, , True) Then
                        
                            w1 = Abs(Asc(v$) < 128)
                            If IsLabelSymbolNew(a$, "ыс", "AS", w1, , , , False) Then
                                If IsLabelSymbolNew(a$, "ьгжио", "BYTE", w1, , , , False) Then
                                    pp = 1
                                ElseIf IsLabelSymbolNew(a$, "айеяаиос", "INTEGER", w1, , , , False) Then
                                    pp = 2
                                ElseIf IsLabelSymbolNew(a$, "лайяус", "LONG", w1, , , , False) Then
                                    pp = 4
                                ElseIf IsLabelSymbolNew(a$, "дипкос", "DOUBLE", w1, , , , False) Then
                                    pp = 8
                                ElseIf IsLabelSymbolNew(a$, "апкос", "SINGLE", w1, , , , False) Then
                                    pp = 4
                                    ReadAsSingle = True
                                Else
                                    SyntaxError
                                    
                                    Exit Function
                                End If
                                ' use another itemsize
                                ' p is byte offset
                                w2 = .objref.GetBytePtr(p)
absolute:
                                If .objref.ValidArea(w2, pp) Then
                                pp = Abs(pp)
                                    Select Case pp
                                    Case 1
                                        GetMem1 w2, rB
                                        R = SG * CDbl(rB)
                                    Case 2
                                        GetMem2 w2, ri
                                        R = SG * CDbl(UINT(CLng(ri)))
                                    Case 4
                                        If ReadAsSingle Then
                                            GetMemS w2, ds
                                            If SG = 1 Then
                                                R = ds
                                            Else
                                                R = -ds
                                            End If
                                        Else
                                            GetMem4 w2, dn
                                            R = SG * CDbl(uintnew(CDbl(dn)))
                                        End If
                                        
                                    Case 8
                                        GetMem8 w2, db
                                        If SG < 0 Then R = -db Else R = db
                                      
                                    Case 16
                                    
                                    End Select
                                Else
                                    GoTo errortext
                                End If
                            
                            Else
firstpram:
                                Set anything = .objref
                                With anything
         
                                 pp = .ItemSize
                                 ReadAsSingle = .WhatIsBasicItem = vbSingle
                                 If FastSymbol(a$, "!") Then
                                     If FastPureLabel(a$, s$) Then
                                                If .structref Is Nothing Then
                                                MyEr "No structure exist for buffer", "дЕМ УПэЯВЕИ ДОЛч ЦИА ТГМ ДИэЯХЯЫСГ"
                                                IsEval = False
                                                Exit Function
                                                End If
                                                If .structref.Find(myUcase(s$, True)) Then
                                                       pp = Abs(.structref.sValue)
                                                       If pp = 4 Then
                                                       If .structref.KeyTypeValue = vbSingle Then
                                                        ReadAsSingle = True
                                                       End If
                                                       End If
                                                       If FastSymbol(a$, "!") Then
                                                           If Not IsExp(bstack, a$, R, , True) Then
                                                                    GoTo errortext1
                                                           ElseIf R >= 0 Then
                                                           
                                                                    w2 = cUlng(uintnew(.GetPtr(p)) + .structref.Value + Int(R) * pp)
                                                                    GoTo absolute
                                                           Else
                                                                    NegativeIindex a$
                                                                   GoTo errortext1
                                                           End If
                                                       Else
                                                           w2 = cUlng(uintnew(.GetPtr(p)) + .structref.Value)
                                                           GoTo absolute
                                                       End If
                                                 Else
                                                    unknownoffset a$, s$
                                                    GoTo errortext1
                                                 End If
                                    End If
                                End If
                                Select Case pp
                                Case 1
                                    If .ValidArea2(p, 1) Then
                                        GetMem1 .GetPtr(p), rB
                                        R = SG * CDbl(rB)
                                    Else
                                        GoTo errortext
                                    End If
                                Case 2
                                    If .ValidArea2(p, 2) Then
                                        GetMem2 .GetPtr(p), ri
                                        R = SG * CDbl(UINT(CLng(ri)))
                                    Else
                                        GoTo errortext
                                    End If
                                Case 8
                                    If .ValidArea2(p, 8) Then
                                        GetMem8 .GetPtr(p), db
                                        R = SG * db
                                    Else
                                        GoTo errortext
                                    End If
                                Case 4
                                    If .ValidArea2(p, 4) Then
                                        If ReadAsSingle Then
                                           GetMemS .GetPtr(p), ds
                                            If SG = 1 Then
                                                R = ds
                                            Else
                                                R = -ds
                                            End If
                                        Else
                                            GetMem4 .GetPtr(p), dn
                                            R = SG * CDbl(uintnew(CDbl(dn)))
                                        End If
                                    Else
errortext:
                                         wrongsizeOrposition a$
errortext1:
                                        Set anything = Nothing
                                        
                                        
                                        Exit Function
                                    End If
                                End Select
                                
               
                                End With
                            End If
                                           IsEval = FastSymbol(a$, ")", True)
                                
                                Set anything = Nothing
                                Exit Function
                        End If
                    Else
                    p = 0
                    GoTo firstpram
                    End If
               ElseIf .t1 = 3 Then
                If CheckDeepAny(anything) Then
                If TypeOf anything Is mStiva Then
                
                End If
                End If
                GoTo there1234459
               ElseIf .t1 = 4 Then
               
               Set usehandler1 = New mHandler
               If w3 = -1 Then
               usehandler1.index_cursor = usehandler.index_cursor
               Set usehandler1.objref = usehandler.objref
               usehandler1.index_start = usehandler.index_start
               usehandler1.sign = usehandler.sign
               R = usehandler1.index_cursor * usehandler1.sign
               Else
               usehandler1.index_cursor = usehandler.objref.Value
               Set usehandler1.objref = usehandler.objref
               usehandler1.index_start = usehandler.objref.index
               R = usehandler1.index_cursor
               End If
               usehandler1.t1 = 4
               If SG < 0 Then R = -R
               Set bstack.lastobj = usehandler1
               
                IsEval = FastSymbol(a$, ")", True)
                       Exit Function
               Else
there1234459:
                    ' eval for objects???
                    R = 0
                       IsEval = FastSymbol(a$, ")", True)
                       Exit Function
               End If
               Set anything = Nothing
            End With
                Set usehandler = Nothing
        ElseIf Not bstack.lastpointer Is Nothing Then
getgroup:
            If Not bstack.lastpointer.IamApointer Then Set bstack.lastpointer = bstack.lastobj
            If bstack.lastpointer.link Is Nothing Then
            If bstack.lastpointer.IamFloatGroup Then
                Set pppp = New mArray
                pppp.PushDim 1
                pppp.PushEnd
                pppp.Arr = True
                Set pppp.item(0) = bstack.lastpointer
                Set bstack.lastpointer = Nothing
                 If pppp.item(0).HasParameters Then
                    FastSymbol a$, ","
                    IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, 0) = 1
                    R = bstack.LastValue
                    Exit Function
                Else
                    FastSymbol a$, ","
                    IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, 0) = 1
                    R = bstack.LastValue
                    GoTo conthere
                End If
                End If
                SyntaxError
                IsEval = False
                Exit Function
            ElseIf bstack.lastpointer.link.IamFloatGroup Then
getgroup2:
            Set pppp = New mArray
            pppp.PushDim 1
            pppp.PushEnd
            pppp.Arr = True
            Set pppp.item(0) = bstack.lastpointer
            Set bstack.lastpointer = Nothing
            If pppp.item(0).link.HasParameters Then
            FastSymbol a$, ","
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, 0) = 1
            R = bstack.LastValue
             Exit Function
            Else
            FastSymbol a$, ","
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, 0) = 1
            R = bstack.LastValue
            GoTo conthere
            End If
                Exit Function
            Else
            'Set bstack.lastpointer = bstack.lastobj
            If lookOne(a$, ",") Then
            Mid$(a$, 1, 1) = Chr(0)
            If IsNumber(bstack, a$, R) Then
            If SG < 0 Then R = -R
                       IsEval = True
                       
                       Exit Function
                       End If
            Else
            If IsNumber(bstack, Chr$(0) + "'", R) Then
                GoTo conthere
            End If
            End If
          End If
        ElseIf Typename(bstack.lastobj) = mgroup Then
        Set ThisGroup = bstack.lastobj
        If ThisGroup.HasValue Then
        Set bstack.lastobj = Nothing
        Set pppp = New mArray
            pppp.PushDim 1
            pppp.PushEnd
            pppp.Arr = True
            Set pppp.item(0) = ThisGroup
        If ThisGroup.HasParameters Then
        
            FastSymbol a$, ","
            
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, 0) = 1
            R = bstack.LastValue
             Exit Function
        Else
        FastSymbol a$, ","
            IsEval = SpeedGroup(bstack, pppp, "VAL", "", a$, 0) = 1
            R = bstack.LastValue
            GoTo conthere
        End If
        Else
                   R = R - R
                   IsEval = FastSymbol(a$, ")")
                    Exit Function
        End If
        End If
        MissParam a$
    ElseIf IsStrExp(bstack, ss$, s$) Then
    If Len(ss$) > 0 Then Mid$(a$, w1 + 1 - Len(ss$), Len(ss$)) = ss$
    Mid$(a$, 1, w1 + 1 - Len(ss$)) = space$(w1 - Len(ss$))
    If FastSymbol(a$, ".") Then
    If lookOne(a$, ")") Then
        
            If Not IsExp(bstack, s$, R) Then
          
            wrongweakref a$
        Else
            If SG < 0 Then R = -R
            
            IsEval = FastSymbol(a$, ")", True)
        End If
            
        Else
        a$ = s$ + "." + a$
        
        If Not IsExp(bstack, a$, R) Then
          
            wrongweakref a$
        Else
        If SG < 0 Then R = -R
            
            IsEval = FastSymbol(a$, ")", True)
        End If
        End If
    Else
    
            If Not IsExp(bstack, s$, R) Then
            
            wrongexprinstring a$
            Else
conthere:
            If SG < 0 Then R = -R
            IsEval = FastSymbol(a$, ")", True)
            End If
    End If
    Else
        MissParam a$
    End If
End Function
Private Function IsVal(bstack As basetask, a$, R As Variant, SG As Variant, Eng As Boolean) As Boolean
Dim s$, ex$, dd As Long, pp As Variant, Lang As Long
    If Eng Then Lang = 1
   If IsStrExp(bstack, a$, s$) Then
    On Error Resume Next
    If FastSymbol(a$, "!", False) Then
    dd = ValidNumberOnly(s$, R, False)
    If SG < 0 Then R = -R
    IsVal = FastSymbol(a$, ")", True)
    Err.Clear
    Exit Function
    ElseIf FastSymbol(a$, ",") Then
      If IsStrExp(bstack, a$, ex$) Then
      If Len(ex$) <> 1 Then
      If Len(ex$) = 0 Then dd = 46 Else dd = AscW(NowDec$)
      Else
          dd = AscW(ex$)
          End If
       If InStr(s$, ".") > 0 And dd <> 46 Then
        s$ = Replace(s$, ".", "*", 1, 1)
        End If
        s$ = Replace(s$, ChrW(dd), ".", 1, 1)
        dd = 46
    ElseIf IsExp(bstack, a$, pp, , True) Then
        pp = Fix(pp)
        dd = AscW(GetlocaleString2(14, CLng(pp)))
        If InStr(s$, ".") > 0 And dd <> 46 Then
        s$ = Replace(s$, ".", "*", 1, 1)
        End If
        s$ = Replace(s$, ChrW(dd), ".", 1, 1)
        dd = 46
    Else
    If lookOne(a$, ",") Then
        s$ = Replace(s$, ChrW(dd), ".", 1, 1)
        dd = 46
    Else
    expecteddecimal a$
    Err.Clear
    Exit Function
    End If
      End If
    Else
    dd = AscW(GetDeflocaleString(14))
    End If
    If MaybeIsSymbol(s$, "аАьЬTtFf") Then
    If CDbl(pp) = 0 Then
    If Fast3NoSpace(s$, "акгхес", 6, "акгхгс", 6, "TRUE", 4, 6) Then
        R = CBool(True)
        If SG < 0 Then R = -R
    ElseIf Fast3NoSpace(s$, "ьеудес", 6, "ьеудгс", 6, "FALSE", 5, 6) Then
       R = CBool(False)
        If SG < 0 Then R = -R
    Else
    R = 0
   End If
    Else
        If pp = 1032 Then
                 If Fast3NoSpace(s$, "акгхес", 6, "акгхгс", 6, vbNullString, 0, 6) Then
                     R = CBool(True)
                     If SG < 0 Then R = -R
                 ElseIf Fast3NoSpace(s$, "ьеудес", 6, "ьеудгс", 6, vbNullString, 0, 6) Then
                    R = CBool(False)
                     If SG < 0 Then R = -R
                 Else
                 R = 0
                End If
        Else
             If Fast3NoSpace(s$, "TRUE", 4, vbNullString, 0, vbNullString, 0, 4) Then
                 R = CBool(True)
                 If SG < 0 Then R = -R
             ElseIf Fast3NoSpace(s$, "FALSE", 5, vbNullString, 0, vbNullString, 0, 5) Then
                R = CBool(False)
                 If SG < 0 Then R = -R
             Else
             R = 0
            End If
     End If
     End If
    ElseIf dd = 46 Then
    R = val(s$)
    If Err.Number = 13 Then
    dd = ValidNumberOnlyClean(s$, R, False)
    ElseIf Abs(R) = 1 Then
    If InStr(UCase(s$), ".#INF") > 0 Then
    dd = ValidNumberOnlyClean(Replace(s$, ChrW(dd), "."), R, False)
    If dd = -1 Then
    Else
    If R < 0 Then
    R = -Infinity
    Else
    R = Infinity
    End If
    End If
    End If
    End If
    If SG < 0 Then R = -R
    
    Else
    R = val(Replace(s$, ChrW(dd), "."))
    If Err.Number = 13 Then
    dd = ValidNumberOnlyClean(Replace(s$, ChrW(dd), "."), R, False)
    ElseIf Abs(R) = 1 Then
    If InStr(UCase(s$), ".#INF") > 0 Then
    dd = ValidNumberOnlyClean(Replace(s$, ChrW(dd), "."), R, False)
    If dd = -1 Then
    Else
    If R < 0 Then
    R = -Infinity
    Else
    R = Infinity
    End If
    End If
    End If
    End If
    If SG < 0 Then R = -R
    End If
    If Err.Number > 0 Then
    Err.Clear
    WrongArgument a$
    Exit Function
    End If
    On Error GoTo a100
    If FastSymbol(a$, ",") Then
    
    Dim mm As mStiva
   Set mm = New mStiva
    Dim oldm As mStiva
    Set oldm = bstack.soros
    Set bstack.Sorosref = mm
    dd = ValidNumberOnlyClean(s$, R, Len(ex$) > 1)
    If dd > 2 And Abs(R) = 1 Then
    If Mid$(s$, dd - 1, 2) = ".#" Then
    If UCase(Mid$(s$, dd + 1, 3)) = "INF" Then
    If R >= 0 Then
    R = Infinity()
    Else
    R = -Infinity()
    End If
    dd = dd + 4
    End If
    End If
    End If
    mm.PushVal dd
    FastSymbol a$, "&"
    If Not MyRead(1, bstack, a$, Lang) Then
    IsVal = False
    Set bstack.Sorosref = oldm
    Exit Function
    End If
    Set bstack.Sorosref = oldm
    End If
    IsVal = FastSymbol(a$, ")", True)
    ElseIf IsExp(bstack, a$, R) Then
    If FastSymbol(a$, "->", False, 2) Then
    Set bstack.lastobj = Nothing
    Set bstack.lastpointer = Nothing
    If FastSymbol(a$, "0@", , 2) Then
        On Error GoTo a500
        R = CDec(R)
        If SG < 0 Then R = -R
        IsVal = FastSymbol(a$, ")", True)
    ElseIf FastSymbol(a$, "0#", , 2) Then
        On Error GoTo a400
        R = CCur(R)
        If SG < 0 Then R = -R
        IsVal = FastSymbol(a$, ")", True)
    ElseIf FastSymbol(a$, "0&", , 2) Then
        On Error GoTo a100
        R = CLng(R)
        If SG < 0 Then R = -R
        IsVal = FastSymbol(a$, ")", True)
    ElseIf FastSymbol(a$, "0~", , 2) Then
        On Error GoTo a200
        R = CSng(R)
        If SG < 0 Then R = -R
        IsVal = FastSymbol(a$, ")", True)
    ElseIf FastSymbol(a$, "0") Then
        On Error GoTo a300
        R = CDbl(R)
        If SG < 0 Then R = -R
        IsVal = FastSymbol(a$, ")", True)
    Else
    
        If IsLabelSymbolNew(a$, "аяихлос", "DECIMAL", Lang, , , , False) Then
            On Error GoTo a500
            R = CDec(R)
            If SG < 0 Then R = -R
            IsVal = FastSymbol(a$, ")", True)
        ElseIf IsLabelSymbolNew(a$, "дипкос", "DOUBLE", Lang, , , , False) Then
            On Error GoTo a300
            R = CDbl(R)
            If SG < 0 Then R = -R
            IsVal = FastSymbol(a$, ")", True)
        ElseIf IsLabelSymbolNew(a$, "апкос", "SINGLE", Lang, , , , False) Then
            R = CSng(R)
            If SG < 0 Then R = -R
            IsVal = FastSymbol(a$, ")", True)
        ElseIf IsLabelSymbolNew(a$, "коцийос", "BOOLEAN", Lang, , , , False) Then
            R = CBool(SG * R)
            IsVal = FastSymbol(a$, ")", True)
        ElseIf IsLabelSymbolNew(a$, "лайяус", "LONG", Lang, , , , False) Then
            On Error GoTo a100
            R = CLng(R)
            If SG < 0 Then R = -R
            IsVal = FastSymbol(a$, ")", True)
         ElseIf IsLabelSymbolNew(a$, "айеяаиос", "INTEGER", Lang, , , , False) Then
            On Error GoTo a150
            R = CInt(R)
            If SG < 0 Then R = -R
            IsVal = FastSymbol(a$, ")", True)
        ElseIf IsLabelSymbolNew(a$, "коцистийо", "CURRENCY", Lang, , , , False) Then
            On Error GoTo a400
            R = CCur(R)
            If SG < 0 Then R = -R
            IsVal = FastSymbol(a$, ")", True)
        Else
    
        CantFind "0@ 0# 0& 0~ 0% 0"
        End If
        Set bstack.lastobj = Nothing
    End If
    Else
        On Error GoTo a300
        R = CDbl(R)
        If SG < 0 Then R = -R
        
        IsVal = FastSymbol(a$, ")", True)
    End If
    
    Else
                MissParam a$
    End If
 Exit Function
a100:
 IsVal = False
 If Err.Number = 6 Then
 
   OverflowLong
 Else
    MyEr Err.Description, Err.Description
 End If
 Err.Clear
 Exit Function
a150:
 IsVal = False
 If Err.Number = 6 Then
 
   OverflowLong True
 Else
    MyEr Err.Description, Err.Description
 End If
 Err.Clear
 Exit Function
 
a200:
 IsVal = False
 If Err.Number = 6 Then
 
    MyEr "Overflow single", "УПЕЯВЕъКИСГ АПКОЩ"
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear
Exit Function
a300:
 IsVal = False
 If Err.Number = 6 Then
 
    MyEr "Overflow double", "УПЕЯВЕъКИСГ ДИПКОЩ"
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear
Exit Function
a400:
 IsVal = False
 If Err.Number = 6 Then
 
    MyEr "Overflow Currency", "УПЕЯВЕъКИСГ кОЦИСТИЙОЩ"
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear
Exit Function
a500:
 IsVal = False
 If Err.Number = 6 Then
 
    MyEr "Overflow Decimal", "УПЕЯВЕъКИСГ дЕЙАДИЙОЩ"
 Else
    MyEr Err.Description, Err.Description
 End If
Err.Clear

End Function
Private Function IsRinstr(bstack As basetask, a$, R As Variant, SG As Variant, Lang As Long) As Boolean
Dim s$, s1$, par As Boolean
    If IsStrExp(bstack, a$, s$) Then
        If FastSymbol(a$, ",") Then
        
            If IsStrExp(bstack, a$, s1$) Then
                If FastSymbol(a$, ",") Then
                    If Not IsExp(bstack, a$, R, , True) Then
                        MissParam a$
                        Exit Function
                    End If
                    par = True
                End If
           
             If IsLabelSymbolNew(a$, "ыс", "AS", Lang, , , , False) Then
        If IsLabelSymbolNew(a$, "ьгжио", "BYTE", Lang, , , , False) Then
                 If par Then
                 If R < 0 Then R = LenB(s$) + R + 1
                If R < 0 Then R = 1
                R = LenB(s$) - R + 1
                If R < 0 Then R = 1
                If R > LenB(s$) Then R = LenB(s$)
        Else
        R = LenB(s$)
        End If
           R = SG * rinstrb(s$, s1$, R)
        Else
           SyntaxError
            Exit Function
        End If
        Else
        If par Then
        If R < 0 Then R = Len(s$) + R + 1
                If R < 0 Then R = 1
                R = Len(s$) - R + 1
                If R < 0 Then R = 1
                If R > Len(s$) Then R = Len(s$)
        Else
        R = Len(s$)
        End If
     R = SG * InStrRev(s$, s1$, R)
    End If
            
            
            IsRinstr = FastSymbol(a$, ")", True)
    Else
        MissParam a$
    End If
        Else
            MissParam a$
    End If
        Else
            MissParam a$
    End If

End Function
Private Function IsInstr(bstack As basetask, a$, R As Variant, SG As Variant, Lang As Long) As Boolean
Dim s$, s1$
    If IsStrExp(bstack, a$, s$) Then
    If FastSymbol(a$, ",") Then
    If IsStrExp(bstack, a$, s1$) Then
        If FastSymbol(a$, ",") Then
        If Not IsExp(bstack, a$, R, , True) Then
          
                MissParam a$
         Exit Function
        End If
        Else
        R = 1
        End If
      If IsLabelSymbolNew(a$, "ыс", "AS", Lang, , , , False) Then
        If IsLabelSymbolNew(a$, "ьгжио", "BYTE", Lang, , , , False) Then
           
           R = InStrB(R, s$, s1$)
        Else
           SyntaxError
            Exit Function
        End If
        Else
    R = InStr(R, s$, s1$)
    End If
    If SG < 0 Then R = -R
    
    IsInstr = FastSymbol(a$, ")", True)
    Else
            MissParam a$
    End If
        Else
            MissParam a$
    End If
        Else
            MissParam a$
    End If
    
End Function

Private Function IsGroupCount(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim s$, w2 As Long, pppp As mArray
Select Case Abs(IsLabelBig(bstack, a$, s$))
Case 1
    If getvar2(bstack, s$, w2) Then
        If Typename(var(w2)) = mgroup Then
            If var(w2).IamApointer Then
            
            Else
                R = var(w2).PrepareSoros(var(), "").Total
                If SG < 0 Then R = -R
            End If
        Else
            MissingGroup
            Exit Function
        End If
        IsGroupCount = FastSymbol(a$, ")", True)
        Exit Function
    Else
        Nosuchvariable s$
    End If
Case 5
    If Not neoGetArray(bstack, s$, pppp) Then Exit Function
    If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
    If pppp.Arr Then
        If pppp.ItemType(w2) = mgroup Then
            R = 0
            If pppp.item(w2).IamApointer Then
            Else
                R = pppp.item(w2).PrepareSoros(var(), "").Total
                If SG < 0 Then R = -R
            End If
        Else
            MissingGroup
            Exit Function
        End If
    End If
    IsGroupCount = FastSymbol(a$, ")")
Case Else
    MissingGroup
End Select
End Function
Private Function IsParIndex(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim s$, w1 As Long, w2 As Long, dn As Long, pppp As mArray
    w1 = Abs(IsLabel(bstack, a$, s$))
                  
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If Typename(var(w1)) = doc Then
                        If Not FastSymbol(a$, ",") Then: MissParam a$: Exit Function
                         w2 = Abs(IsLabel(bstack, a$, s$)) ' ONLY AN ARITHMETIC VAR.
    
                        If w2 = 1 Or w2 = 4 Then
                                If GetVar(bstack, s$, w2) Then
                                dn = var(w2)
                              R = SG * var(w1).ParagraphOrder(dn)           ''
                                 
                            
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsParIndex = False
                                        Exit Function
                                 End If
                         
                        Else
                                        MissingnumVar
                                        
                                        IsParIndex = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsParIndex = False
                                        Exit Function
                End If
                
                IsParIndex = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                                If Not FastSymbol(a$, ",") Then: MissParam a$: Exit Function
                         w1 = Abs(IsLabel(bstack, a$, s$)) ' ONLY AN ARITHMETIC VAR..
                        If w1 = 1 Or w1 = 2 Then
                                If GetVar(bstack, s$, w1) Then
                                dn = var(w1)
                                 R = SG * pppp.item(w2).ParagraphOrder(dn)
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsParIndex = False
                                        Exit Function
                                 End If
                         
                        Else
                                        Nosuchvariable s$
                                        
                                        IsParIndex = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsParIndex = False
                                        Exit Function
                End If
                    
                IsParIndex = FastSymbol(a$, ")", True)
    Else
                    
                MissFuncParameterStringVarMacro a$
    End If

End Function
Private Function IsForwBack(ByVal dd As Long, bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim w1 As Long, w2 As Long, s$, dn As Long, pppp As mArray


w1 = Abs(IsLabel(bstack, a$, s$))
        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If Typename(var(w1)) = doc Then
                        If Not FastSymbol(a$, ",") Then: MissParam a$: Exit Function
                         w2 = Abs(IsLabel(bstack, a$, s$)) ' ONLY AN ARITHMETIC VAR..
                        If w2 = 1 Or w2 = 4 Then
                                If GetVar(bstack, s$, w2) Then
                                dn = var(w2)
                                If dd = 1 Then
                                var(w1).BackStep dn
                                var(w1).BackMove = True
                                Else
                                var(w1).BackMove = False
                                var(w1).Advance dn
                                End If
                                 R = SG * Not var(w1).IsEmpty
                                 '    r = SG * var(w1).ParagraphOrder(dn)          ''
                                 
                                 var(w2) = dn
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsForwBack = False
                                        Exit Function
                                 End If
                         
                        Else
                                        MissingnumVar
                                        
                                        IsForwBack = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsForwBack = False
                                        Exit Function
                End If
                
                IsForwBack = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                                If Not FastSymbol(a$, ",") Then: MissParam a$: Exit Function
                         w1 = Abs(IsLabel(bstack, a$, s$)) ' ONLY AN ARITHMETIC VAR..
                         If w1 = 1 Or w1 = 2 Then
                                If GetVar(bstack, s$, w1) Then
                                dn = var(w1)
                                 If dd = 1 Then
                                pppp.item(w2).BackStep dn
                                pppp.item(w2).BackMove = True
                                Else
                              pppp.item(w2).BackMove = False
                                 pppp.item(w2).Advance dn
                                End If
                                R = SG * Not pppp.item(w2).IsEmpty
                                '' r = SG * pppp.item(w2).ParagraphOrder(dn)
                                
                                 var(w1) = dn
                                 Else
                                        Nosuchvariable s$
                                        
                                        IsForwBack = False
                                        Exit Function
                                 End If
                         
                        Else
                                        Nosuchvariable s$
                                        
                                        IsForwBack = False
                                        Exit Function

                        End If
                Else
                    MissingDoc
                                        
                                        IsForwBack = False
                                        Exit Function
                End If
                    
                IsForwBack = FastSymbol(a$, ")", True)
    Else
                    
                MissFuncParameterStringVarMacro a$
    End If
End Function
Private Function IsDocPar(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim w1 As Long, w2 As Long, s$, pppp As mArray
w1 = Abs(IsLabel(bstack, a$, s$))

        If w1 = 3 Then
            If GetVar(bstack, s$, w1) Then
                If Typename(var(w1)) = doc Then
                    R = SG * var(w1).DocParagraphs
                Else
                    R = 0
                End If
                
                IsDocPar = FastSymbol(a$, ")", True)
            Else
                    
                    MissFuncParameterStringVarMacro a$
                    
            End If
        ElseIf w1 = 6 Then
                If neoGetArray(bstack, s$, pppp) Then
                 If Not NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then Exit Function
                    If pppp.ItemType(w2) = doc Then
                      R = SG * pppp.item(w2).DocParagraphs
                      Else
                      R = 0
                      End If
                Else
                
                End If
                    
                IsDocPar = FastSymbol(a$, ")", True)
    Else
                    
                MissFuncParameterStringVarMacro a$
    End If
End Function
Private Function IsMaxData(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, a$, R, , True) Then
  
  Do While FastSymbol(a$, ",")
  If Not IsExp(bstack, a$, p, , True) Then: MissNumExpr: Exit Function
  If p > R Then R = p
  
  Loop

    If SG < 0 Then R = -R
    IsMaxData = FastSymbol(a$, ")", True)
        Else
            MissNumExpr
        End If
End Function
Private Function IsMinData(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim p As Variant
If IsExp(bstack, a$, R, , True) Then
  
  Do While FastSymbol(a$, ",")
  If Not IsExp(bstack, a$, p, , True) Then: MissNumExpr: Exit Function
  If p < R Then R = p
  
  Loop
  If SG < 0 Then R = -R
    
    IsMinData = FastSymbol(a$, ")", True)
        Else
        MissNumExpr
        End If
End Function
Private Function IsProperty(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim w1 As Long, s$, w2 As Long, pppp As mArray
w1 = Abs(IsLabel(bstack, a$, s$))
If w1 = 1 Or w1 = 5 Then
    If w1 = 5 Then If Not FastSymbol(a$, ")", True) Then Exit Function
    If Not GetVar(bstack, s$, w2) Then GoTo jmp147811
    If w1 = 5 Then
        If Not Typename(var(w2)) = myArray Then GoTo jmp147811
        Set pppp = var(w2)
        If pppp.Arr Then GoTo jmp147811
        If Not pppp.ItemType(-1) = mProp Then GoTo jmp147811
        Set bstack.lastobj = pppp.GroupRef
    Else
        If Not Typename(var(w2)) = mProp Then GoTo jmp147811
        Set bstack.lastobj = var(w2)
    End If
    R = 0
    IsProperty = FastSymbol(a$, ")", True)
    Exit Function
Else
jmp147811:
MyErMacro a$, "Expected a property name", "пЕЯъЛЕМА ЭМОЛА ИДИЭТГТАР"
End If

End Function

Private Function IsGroup(bstack As basetask, a$, R As Variant) As Boolean
Dim w1 As Long, s$, ohere$, w2 As Long, myGroup As Object, mygroup2 As Object, aGroup As Group
w1 = Abs(IsLabel(bstack, a$, s$))
If w1 = 1 Or w1 = 3 Then
If Not GetVar(bstack, s$, w1) Then GoTo jmp1478
If Not Typename(var(w1)) = mgroup Then GoTo jmp1478
If var(w1).IamApointer Then
    If var(w1).link.IamFloatGroup Then
    '  var(w1).link
      Set bstack.lastpointer = Nothing
      If var(w1).link Is NullGroup Then
      Set aGroup = New Group
      aGroup.BeginFloat 0
      aGroup.EndFloat
      Set myGroup = aGroup
      
      Else
     bstack.soros.CopyGroupObj var(w1).link, myGroup
     Set aGroup = myGroup
     End If
     aGroup.ToDelete = True
     Set bstack.lastobj = myGroup
    Else  ' need to make a copy group using
        ohere$ = here$
        here$ = var(w1).lasthere
        If GetVar(bstack, var(w1).GroupName, w2, , , True) Then
            CopyGroup2 var(w2), bstack
        End If
        here$ = ohere$
    End If
Else
    CopyGroup2 var(w1), bstack
    End If
    R = 0
    
    IsGroup = FastSymbol(a$, ")", True)
    Exit Function
ElseIf w1 > 4 Then
If Not GetVar(bstack, s$, w1) Then GoTo jmp1478
Dim p
If ProcessArray(bstack, a$, s$ + ")", var(w1), p) Then
If Typename(p) = mgroup Then
 Set aGroup = p
 
If aGroup.IamApointer Then
    If aGroup.link.IamFloatGroup Then
           Set bstack.lastpointer = Nothing
           If aGroup.link Is NullGroup Then
      Set aGroup = New Group
      aGroup.BeginFloat 0
      aGroup.EndFloat
      Set myGroup = aGroup
      Else
           Set myGroup = aGroup.link
           End If
     bstack.soros.CopyGroupObj myGroup, mygroup2
        Set aGroup = mygroup2
        aGroup.ToDelete = True
        Set bstack.lastobj = mygroup2
    Else  ' need to make a copy group using
        ohere$ = here$
        here$ = aGroup.lasthere
       
        If GetVar(bstack, aGroup.GroupName, w2, , , True) Then
        Set myGroup = aGroup.link
        CopyGroup2 myGroup, bstack
        End If
        here$ = ohere$
    End If

Else
    Set myGroup = aGroup
     Set bstack.lastobj = CopyGroupObj(myGroup)
    End If
    IsGroup = FastSymbol(a$, ")", True)
    Exit Function
End If
    
End If

Else
jmp1478:
MyErMacro a$, "Expected a group name", "пЕЯъЛЕМА ЭМОЛА ОЛэДАР"
End If
Exit Function
End Function
Public Function GetPointer(bstack As basetask, a$) As Boolean
Dim w1 As Long, s$, pppp As mArray, w2 As Long, p, nbstack As basetask, myobj As Object, i As Long
Dim glob As Boolean, rempar As Long, waspointer As Boolean, usehandler As mHandler
If MaybeIsSymbol(a$, ")") Then
p = 0
GoTo checkagain
End If
again:
w1 = Abs(IsLabel(bstack, a$, s$))

If w1 = 1 Or w1 = 3 Then
    w2 = w1
cont11:
    If Not GetVar(bstack, s$, w1, , , , , , glob) Then GoTo jmp1478
    If Not Typename(var(w1)) = mgroup Then GoTo jmp1478
    If var(w1).IamApointer Then
            Set bstack.lastobj = var(w1)
            Set bstack.lastpointer = var(w1)
    Else
                            If var(w1).IamSuperClass Then
                            PushStage bstack, False
                        
                                i = globalvarGroup("_1", 0, , True)
                                Set myobj = var(w1)
                                UnFloatGroup bstack, "_1", i, myobj, True
                                
                            Set p = CopyGroupObj(var(i))
                            PopStage bstack
                                MakeGroupPointer bstack, p
                            ElseIf w2 = 1 Then
                                
                                MakeGroupPointer bstack, var(w1), s$, glob
                            ElseIf w2 = 3 Then
                                MakeGroupPointer bstack, var(w1), Left$(s$, Len(s$) - 1), glob
                            End If
    
    
    
        
    End If
        GetPointer = True
        GoTo exithere
    ElseIf w1 > 4 Then
        If Not GetVar(bstack, s$, w1) Then
            If GetSub(s$ + ")", w2) Then
                Set nbstack = New basetask
                Set nbstack.Parent = bstack
                If bstack.IamThread Then Set nbstack.Process = bstack.Process
                Set nbstack.Owner = bstack.Owner
                nbstack.OriginalCode = w2
                nbstack.UseGroupname = sbf(w2).sbgroup
                nbstack.tpointer = sbf(w2).tpointer
                nbstack.SetV
                If GoFunc(nbstack, s$ + ")", a$, p) Then
                If Not nbstack.StaticCollection Is Nothing Then
                    bstack.SetVarobJ "%_" + nbstack.StaticInUse, nbstack.StaticCollection
                End If
                Set p = bstack.lastobj
                If Not p Is Nothing Then
                    If Typename(p) = mgroup Then
                        If p.IamApointer Then
                            Set bstack.lastpointer = p
                        Else
                            If p.IamSuperClass Then
                                PushStage bstack, False
                                i = globalvarGroup("_1", 0, , True)
                                Set myobj = p
                                UnFloatGroup bstack, "_1", i, myobj, True
                                Set p = CopyGroupObj(var(i))
                                PopStage bstack
                            End If
                            MakeGroupPointer bstack, p
                        End If
                        GetPointer = True
                        GoTo exithere
                        End If
                    End If
                End If
        ElseIf neoGetArray(bstack, s$, pppp) Then
            If Not pppp.Arr Then
                If NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then
                    GoTo conthere
                End If
            End If
        Else  '"", "POINTER("
            If IsLabelSymbolNew(s$, "POINTER(", "POINTER(", 1 - (Asc(s$) < 128)) Then
                rempar = rempar + 1
                GoTo again
            Else
                bstack.tmpstr = s$ + Left$(a$, 1)
                BackPort a$
                If IsNumberNew(bstack, a$, p, (1), False) Then
                    If Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is Group Then
                            Set p = bstack.lastobj
                            If Not p.IamApointer Then
                                MakeGroupPointer bstack, p
                                
                                Else
                               Set bstack.lastpointer = p
                            Set bstack.lastobj = p
                            End If
                            
                            GetPointer = True
                        End If
                    End If
                    Exit Function
                End If
            End If
        End If
        Set nbstack = Nothing
        GoTo jmp1478
    End If
    Set p = var(w1)
again99:
        Set usehandler = Nothing
        If GetArrayReference(bstack, a$, s$ + ")", p, pppp, w2) Then
conthere:
            Set usehandler = Nothing
            If pppp.ItemType(w2) = mgroup Then
                Set p = pppp.item(w2)
                If p.IamApointer Then
                    Set bstack.lastobj = p
                    Set bstack.lastpointer = p
                Else
                    MakeGroupPointer bstack, p
                    Set pppp.item(w2) = bstack.lastpointer  ' this is my idea
                End If
                GetPointer = True
                GoTo exithere
            Else
                If MyIsObject(pppp.item(w2)) Then
                    Set p = pppp.item(w2)
                    If Left$(a$, 1) = "(" Then
                        Mid$(a$, 1, 1) = " "
                        Set usehandler = p
                        With usehandler
                            If Typename(.objref) = myArray Then Set pppp = .objref: Set p = pppp: GoTo again99
                            If FindItem(bstack, p, a$, Typename(p), w2) Then
                                Set pppp = p
                                GoTo conthere
                            End If
                        End With
                    End If
                End If
            End If
        End If
        ElseIf FastSymbol(a$, "(") Then
                                
                If IsExp(bstack, a$, p) Then
                    If Not bstack.lastpointer Is Nothing Then
                    waspointer = bstack.lastobj.IamApointer  ' reverse order if pointer is a reference
                        Set bstack.lastobj = bstack.lastpointer
                        Set bstack.lastpointer = Nothing
                    End If
                    rempar = rempar + 1
checkagain:
                    If bstack.lastobj Is Nothing Then
                        If p = 0 Then
                            Set p = NullGroup
                            If Not p.GroupName = "NULL" Then
                            p.BeginFloat 2
                            NullGroup.GroupName = "NULL"
                            NullGroup.PutIs = "NULL"
                            NullGroup.PutIs = "лгдемийос"
                            End If
                            MakeGroupPointer bstack, p
                            GetPointer = True
                            GoTo exithere
                        Else
                            GoTo jmp1478
                        End If
                    Else
                        If TypeOf bstack.lastobj Is Group Then
getgroup:
                            Set p = bstack.lastobj
                            If p.IamSuperClass Then
                                PushStage bstack, False
                                i = globalvarGroup("_1", 0, , True)
                                Set myobj = p
                                UnFloatGroup bstack, "_1", i, myobj, True
                                Set p = CopyGroupObj(var(i))
                                PopStage bstack
                            ElseIf p.IamApointer Then
                                If Not p.link Is Nothing Then
                                    Set p = p.link
                                Else
                                Set bstack.lastpointer = p
                                End If
                            ElseIf p.IamFloatGroup Then
                               ' Set bstack.lastpointer = p
                               ' bstack.soros.CopyGroupObj bstack.lastpointer, myobj
                                'Set p = myobj
                            ElseIf waspointer Then
                                   Set p = CopyGroupObj(p)
                            End If
                            MakeGroupPointer bstack, p
                            GetPointer = True
                            GoTo exithere
                        End If
                    End If
                                 
                End If
                                
jmp1478:
                If s$ = "THIS" Or s$ = "ауто" Then
                         
                If Len(bstack.UseGroupname) > 0 Then
                    s$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - 1)
                    If GetVar(bstack, s$, w1) Then
                        If IsBadCodePtr(var(w1).PointerPtr) = 0 Then
                        ObjSetAddRef myobj, var(w1).PointerPtr
                        Set p = myobj
                                p.link.lasthere = var(w1).lasthere
                                p.link.LastOpen = var(w1).LastOpen
                                Set bstack.lastobj = myobj
                                Set bstack.lastpointer = myobj
                                GetPointer = True
                            GoTo exithere
                        End If
                        s$ = vbNullString
                        SwapStrings s$, here$
                            If (Len(bstack.UseGroupname) - Len(var(w1).GroupName) - 1) > 0 Then
                                here$ = Left$(bstack.UseGroupname, Len(bstack.UseGroupname) - Len(var(w1).GroupName) - 1)
                            Else
                                here$ = vbNullString
                            End If
                            MakeGroupPointer bstack, var(w1)
                        SwapStrings s$, here$
                            GetPointer = True
                            GoTo exithere
                        End If
                         End If
                       ElseIf s$ = "GROUP" Or s$ = "олада" Then
                       If bstack.soros.Total = 0 Then
                               EmptyStack a$
  
                        GetPointer = False: GoTo exithere

                        ElseIf bstack.soros.StackItemTypeObjectType(1) = mgroup Then
                            Set bstack.lastobj = bstack.soros.PopObj
                            
                            If bstack.lastobj.IamApointer Then
                            GetPointer = True
                            Set bstack.lastpointer = bstack.lastobj
                            GoTo exithere
                            Else
                            GoTo getgroup
                            End If
                              Else
                              StackTopNotGroup a$
                            GetPointer = False: GoTo exithere
                              End If
                       
                       
                        Else
er1234:
                        MyErMacro a$, "Expected a group name", "пЕЯъЛЕМА ЭМОЛА ОЛэДАР"
                        Exit Function
                        End If
    ElseIf IsNumber(bstack, a$, p, False) Then
            GoTo checkagain
End If
exithere:
Do While rempar > 0
If Not FastSymbol(a$, ")", True) Then Exit Do
rempar = rempar - 1
Loop
End Function

Private Function CheckGroupOrPointer(bstack As basetask, a$, IsGroupOnly As Group, pppp As mArray, w2 As Long) As Boolean
Dim w1 As Long, s$, p

w1 = Abs(IsLabel(bstack, a$, s$))
If w1 = 1 Or w1 = 3 Then
        If Not GetVar(bstack, s$, w1) Then Exit Function
        If Not Typename(var(w1)) = mgroup Then Exit Function
        If var(w1).IamApointer Then
                Set bstack.lastobj = var(w1)
                Set bstack.lastpointer = var(w1)
                Else
                Set IsGroupOnly = var(w1)
        End If
        CheckGroupOrPointer = True
        Exit Function
ElseIf w1 > 4 Then
    If Not GetVar(bstack, s$, w1) Then
        
        If neoGetArray(bstack, s$, pppp) Then
            If Not pppp.Arr Then
                If NeoGetArrayItem(pppp, bstack, s$, w2, a$) Then GoTo conthere
            End If
        End If
        Exit Function
    End If
If GetArrayReference(bstack, a$, s$ + ")", var(w1), pppp, w2) Then
conthere:
        If pppp.ItemType(w2) = mgroup Then
            Set p = pppp.item(w2)
            If p.IamApointer Then
                Set bstack.lastobj = p
                Set bstack.lastpointer = p
              Else
              Set IsGroupOnly = p
            End If
            CheckGroupOrPointer = True
            Exit Function
        End If
    End If
Else
    If IsExp(bstack, a$, p) Then
        If bstack.lastobj Is Nothing Then
            Exit Function
        Else
            If TypeOf bstack.lastobj Is Group Then
                If Not bstack.lastobj.IamApointer Then
                    Set IsGroupOnly = bstack.lastobj
                    Set bstack.lastobj = Nothing
                End If
                CheckGroupOrPointer = True
            End If
        End If
    End If
End If
End Function

Private Function IsChrCode(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim s$, w As Long
   If IsStrExp(bstack, a$, s$) Then
    If s$ = vbNullString Then
        R = CInt(-1)
    Else
        w = AscW(s$)
        If w > -10241 And w < -9216 Then
            If Len(s$) > 1 Then
            R = CCur(SG * (&H10000 + (UINT(w) - &HD800&) * &H400 + UINT(AscW(Mid$(s$, 2, 1))) - &HDC00&))
            Else
             R = CInt(w)
                On Error Resume Next
                If SG < 0 Then R = -R
            End If
        Else
        R = CInt(w)
        On Error Resume Next
        If SG < 0 Then R = -R
        End If
        
    End If
    IsChrCode = FastSymbol(a$, ")", True)
    Else
        MissParam a$
    End If
End Function
Private Function IsAsc(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim s$
    If IsStrExp(bstack, a$, s$) Then
    If s$ = vbNullString Then
    R = -1
    Else
    'cLid
    R = SG * Asc(StrConv(StrConv(s$, vbFromUnicode, Clid), vbUnicode))
    End If
        IsAsc = FastSymbol(a$, ")", True)
    Else
        MissParam a$
    End If

End Function
Private Function IsCons(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim anything As Object, pppp As mArray, s$

    If IsExp(bstack, a$, R) Then
        Set anything = bstack.lastobj
        
        If CheckIsmArray(anything) Then
        
a13410:

            Set pppp = anything
            
            If FastSymbol(a$, ",") Then
againcons:
                Set bstack.lastobj = Nothing
                If IsExp(bstack, a$, R) Then
                    Set anything = bstack.lastobj
                    If CheckIsmArray(anything) Then
a13415:
                        pppp.processAppend anything
                       
                        Set pppp = Nothing
                        Set bstack.lastobj = anything
                        R = 0


                    Else
                        Set pppp = Nothing
                        Set anything = Nothing
                        NotArray
                        Exit Function
                    End If
                ElseIf IsStrExp(bstack, a$, s$) Then
                    Set anything = bstack.lastobj
                    If CheckIsmArray(anything) Then GoTo a13415
                Else
                        Set pppp = Nothing
                        Set anything = Nothing
                        Set bstack.lastobj = anything
                        NotArray
                        Exit Function
                End If
            Else
            Dim pppp1 As New mArray
            Set pppp = anything
            pppp.CopyArray pppp1
                Set bstack.lastobj = pppp1
                Set pppp = Nothing
                Set anything = Nothing
                 IsCons = FastSymbol(a$, ")", True)
                Exit Function
            End If
        Else
            Set anything = Nothing
            Set bstack.lastobj = anything
            NotArray
            Exit Function
        End If
        If FastSymbol(a$, ",") Then Set pppp = anything: GoTo againcons
        Set anything = Nothing
        
        IsCons = FastSymbol(a$, ")", True)
    ElseIf IsStrExp(bstack, a$, s$) Then
            Set anything = bstack.lastobj
            If CheckIsmArray(anything) Then GoTo a13410
    Else
        MissParam a$
    End If
End Function
Private Function IsCar(bstack As basetask, a$, R As Variant) As Boolean
Dim anything As Object, pppp As mArray, s$, usehandler As mHandler
    If IsExp(bstack, a$, R) Then
car1023:
        Set anything = bstack.lastobj
        If CheckIsmArray(anything) Then
            Set pppp = anything
            pppp.Car anything
            If TypeOf anything Is mArray Then
                Set pppp = anything
                Set usehandler = New mHandler
                usehandler.t1 = 3
                Set usehandler.objref = pppp
                Set anything = usehandler
                Set usehandler = Nothing
            End If
            Set bstack.lastobj = anything
            Set pppp = Nothing
            Set anything = Nothing
            
        Else
            NotArray
            Exit Function
        End If
        Set anything = Nothing
        IsCar = FastSymbol(a$, ")", True)
    ElseIf IsStrExp(bstack, a$, s$) Then
        GoTo car1023
    Else
        MissParam a$
    End If

End Function
Private Function IsCdr(bstack As basetask, a$, R As Variant) As Boolean
Dim anything As Object, pppp As mArray, s$, usehandler As mHandler
    If IsExp(bstack, a$, R) Then
cdr1022:
        Set anything = bstack.lastobj
        If CheckIsmArray(anything) Then
            Set pppp = anything
            pppp.Cdr anything
            Set pppp = anything
            Set usehandler = New mHandler
            usehandler.t1 = 3
            Set usehandler.objref = pppp
            Set bstack.lastobj = usehandler
            Set pppp = Nothing
            Set anything = Nothing
            Set usehandler = Nothing
        ElseIf IsStrExp(bstack, a$, s$) Then
        GoTo cdr1022
        Else
            NotArray
            Exit Function
        End If
        IsCdr = FastSymbol(a$, ")", True)
    Else
        MissParam a$
    End If

End Function
Private Function IsTest(bstack As basetask, a$, R As Variant, SG As Variant) As Boolean
Dim s$
If IsExp(bstack, a$, R, , True) Then
    If trace Then
        bypassST = R = 0
        STbyST = Not bypassST
         STq = False
        IsTest = FastSymbol(a$, ")", True)
    Else
        R = 0
    End If
    ElseIf IsStrExp(bstack, a$, s$) Then
    If trace Then
    If s$ = vbNullString Then s$ = Chr$(1)
    R = SG * (Mid$(Form2.gList2.HeadLine, 10) Like s$)
        bypassST = R <> 0
    Else
    R = 0
    End If
    IsTest = FastSymbol(a$, ")", True)
    
    Else
    
                MissParam a$
    End If
End Function
' if ExecuteVar=0 then continue
' if ExecuteVar=1 then Exit do (after exit)
' if ExecuteVar=2 then GoTo autogosub (after exit)
' if ExecuteVar=3 then goto loopagain  (after exit)
' if ExecuteVar=4 then GoTo contVarNew (after exit)
' if ExecuteVar=5 then GoTo again3 (after exit)
' if ExecuteVar=6 then GoTo parsecommand (after exit)
' if ExecuteVar=7 then GoTo loopcontinue (after exit)
'if ExecuteVar=8 then  goto exitfunc

Public Function ExecuteVar(Exec1 As Long, ByVal jumpto As Long, bstack As basetask, w$, B$, v As Long, Lang As Long, VarStat As Boolean, NewStat As Boolean, nchr As Integer, ss$, sss As Long, temphere$) As Long
Dim i As Long, p As Variant, myobject As Object, ok As Boolean, sw$, sp As Variant, usetype As Boolean
Dim pppp As mArray, lasttype As Boolean, pppp1 As mArray, isglobal As Boolean, usehandler As mHandler, usehandler1 As mHandler, idx As mIndexes, myProp As PropReference
' VARSTAT MEANS GLOBAL FOR NEW VARIABLES
If Not TaskMaster Is Nothing Then
If TaskMaster.PlayMusic Then
                    TaskMaster.OnlyMusic = True
                        TaskMaster.TimerTick
                        TaskMaster.OnlyMusic = False
End If
End If
On jumpto GoTo Case1, Case2, Case3, Case4, case5, Case6, Case7
Exit Function
Case1:
    Select Case CheckThis(bstack, w$, B$, v, Lang)
    Case 0
    Case 1
    GoTo assignvalue
    Case 2
    GoTo somethingelse
    Case 3
    GoTo assignpointer
    Case -1
    Exec1 = 0: ExecuteVar = 8: Exit Function
    End Select
    i = MyTrimL(B$)

If VarStat Then
     ' MAKE A GLOBAL SO ONLY = ALLOWED
     
          If FastOperator2(B$, "=", i) Then
              GoTo jumpiflocal
          Else
              p = 0#
              If IsLabelSymbolNew(B$, "ыс", "AS", Lang) Then
  
               If IsLabelSymbolNew(B$, "аяихлос", "DECIMAL", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    p = CDec(p)
            ElseIf IsLabelSymbolNew(B$, "дипкос", "DOUBLE", Lang, , , , False) Then
                            If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CDbl(p)
            ElseIf IsLabelSymbolNew(B$, "апкос", "SINGLE", Lang, , , , False) Then
                        If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CSng(p)
            ElseIf IsLabelSymbolNew(B$, "коцийос", "BOOLEAN", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CBool(p)
            ElseIf IsLabelSymbolNew(B$, "лайяус", "LONG", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CLng(p)
            ElseIf IsLabelSymbolNew(B$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CInt(p)
            ElseIf IsLabelSymbolNew(B$, "коцистийо", "CURRENCY", Lang, , , , False) Then
                If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CCur(p)
            Else
                If Not IsEnumAs(bstack, B$, p) Then
                    ExpectedEnumType
                    MyEr "No type found", "ДЕМ БЯчЙА ТЩПО"
                    Exit Function
                End If
            End If
            Else
               If FastSymbol(B$, "->", , 2) Then
               v = globalvar(w$, p, , VarStat, temphere$)
               GoTo assignpointer
               End If
    End If
              v = globalvar(w$, p, , VarStat, temphere$)
            
              ExecuteVar = 7: Exit Function
          End If
            
ElseIf NewStat Then
    ' MAKE A NEW ONE SO ONLY = ALLOWED
        If FastOperator2(B$, "=", i) Then
            GoTo jumpiflocal
        Else
            p = 0#
            If IsLabelSymbolNew(B$, "ыс", "AS", Lang) Then
  
               If IsLabelSymbolNew(B$, "аяихлос", "DECIMAL", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p, True) Then missNumber: Exit Function
                    p = CDec(p)
            ElseIf IsLabelSymbolNew(B$, "дипкос", "DOUBLE", Lang, , , , False) Then
                            If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p, True) Then missNumber: Exit Function
                p = CDbl(p)
            ElseIf IsLabelSymbolNew(B$, "апкос", "SINGLE", Lang, , , , False) Then
                        If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p, True) Then missNumber: Exit Function
                p = CSng(p)
            ElseIf IsLabelSymbolNew(B$, "коцийос", "BOOLEAN", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p, True) Then missNumber: Exit Function
                p = CBool(p)
            ElseIf IsLabelSymbolNew(B$, "лайяус", "LONG", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p, True) Then missNumber: Exit Function
                p = CLng(p)
            ElseIf IsLabelSymbolNew(B$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p, True) Then missNumber: Exit Function
                p = CInt(p)
            ElseIf IsLabelSymbolNew(B$, "коцистийо", "CURRENCY", Lang, , , , False) Then
                If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p, True) Then missNumber: Exit Function
                p = CCur(p)
            Else
                If Not IsEnumAs(bstack, B$, p) Then
                    ExpectedEnumType
                    MyEr "No type found", "ДЕМ БЯчЙА ТЩПО"
                    Exit Function
                End If
            End If
        End If
            v = globalvar(w$, p, , VarStat, temphere$)
            ExecuteVar = 7: Exit Function
        End If
        
ElseIf nchr > 31 Then
If Left$(B$, 1) = "_" Then
        If nchr <> 61 Then
            SyntaxError
            Exit Function
        End If
        If GetVar(bstack, w$, v, True, , , , usetype) Then
        w$ = varhash.lastkey
            Mid$(B$, 1, 1) = " "
            
            GoTo assignvalue
        ElseIf GetlocalVar(w$, v) Then
            If TypeOf var(v) Is Group Then
            If Not var(v).IamRef Then
            w$ = varhash.lastkey
            End If
            Else
            
            w$ = varhash.lastkey
            End If
            
            Mid$(B$, 1, 1) = " "
            GoTo assignvalue
        Else
        Mid$(B$, 1, 1) = "="
        If AscW(Left$(w$, 1)) = &H1FFF Then
        
            If here$ = vbNullString Then
                If varhash.Find(w$, v) Then
                GoTo fromthis
                End If
            Else
                If varhash.Find(here$ + "." + w$, v) Then
                GoTo fromthis
                End If
            End If
        Else
            UnknownVariable w$
        End If
            Exec1 = 0: ExecuteVar = 8
            Exit Function
        End If
ElseIf MaybeIsSymbol(B$, "/*-+=~^&|<") Then
        If Mid$(B$, i, 2) = "<=" Then
        ' LOOK GLOBAL
        If GetVar(bstack, w$, v, True, , , , usetype, isglobal) Then
       
        w$ = varhash.lastkey
            Mid$(B$, i, 2) = "  "
            
            GoTo assignvalue
        ElseIf GetlocalVar(w$, v) Then
            If TypeOf var(v) Is Group Then
            If Not var(v).IamRef Then
            w$ = varhash.lastkey
            End If
            Else
            
            w$ = varhash.lastkey
            End If
            
            Mid$(B$, i, 2) = "  "
            GoTo assignvalue
        Else
        Mid$(B$, i, 1) = " "
        i = i + 1
        If AscW(Left$(w$, 1)) = &H1FFF Then
        
            If here$ = vbNullString Then
                If varhash.Find(w$, v) Then
                GoTo fromthis
                End If
            Else
                If varhash.Find(here$ + "." + w$, v) Then
                GoTo fromthis
                End If
            End If
        Else
            UnknownVariable w$
        End If
            Exec1 = 0: ExecuteVar = 8
            Exit Function
        End If
        ' do something here
        ElseIf varhash.Find2(here$ & "." & myUcase(w$), v, usetype) Then
    '   If TypeOf var(v) Is Group Then w$ = varhash.lastkey
        ' CHECK VAR
fromthis:            If FastOperator(B$, "=", i) Then

assignvalue:
                If MyIsNumeric(var(v)) Then
assignvalue2:
                    
                    If IsExp(bstack, B$, p) Then
assignvalue3:
                        If bstack.lastobj Is Nothing Then
                            If usetype Then
                            If AssignTypeNumeric(p, VarType(var(v))) Then
                                var(v) = p
                            Else
                                Exec1 = 0: ExecuteVar = 8: Exit Function
                            End If
                            Else
                            If VarType(var(v)) = vbLong Then
                                On Error Resume Next
                                    var(v) = CLng(Int(p))
                                    If Err.Number > 0 Then OverflowLong: Exec1 = 0: ExecuteVar = 8: Exit Function
                                    On Error GoTo 0
                            ElseIf VarType(var(v)) = vbInteger Then
                                On Error Resume Next
                                    var(v) = CInt(Int(p))
                                    If Err.Number > 0 Then OverflowLong True: Exec1 = 0: ExecuteVar = 8: Exit Function
                                    On Error GoTo 0
                            Else
                                var(v) = p
                            End If
                        End If
                        Else
checkobject:
                            Set myobject = bstack.lastobj
                            If TypeOf bstack.lastobj Is Group Then ' oh is a group
                                Set bstack.lastobj = Nothing
                                If myobject.IamApointer Then
                                    Set var(v) = myobject
                                Else
                                    myobject.ToDelete = True
                                    UnFloatGroup bstack, w$, v, myobject, VarStat Or isglobal, , Typename(var(v)) = "Empty"       ' global??
                                    If Len(bstack.UseGroupname) <> 0 Then
                                        var(v).IamRef = True
                                        If Not (VarStat Or isglobal) Then
                                            globalvar w$, CVar(v), True, True
                                        End If
                                    End If
                                End If
                                Set myobject = Nothing
                            ElseIf CheckIsmArray(myobject) Then
                                Set usehandler = New mHandler
                                Set var(v) = usehandler
                                usehandler.t1 = 3
                                Set usehandler.objref = myobject
                                If TypeOf bstack.lastobj Is mHandler Then
                                    Set usehandler1 = bstack.lastobj
                                    With usehandler1
                                        If .UseIterator Then
                                            usehandler.UseIterator = True
                                            usehandler.index_start = .index_start
                                            usehandler.index_End = .index_End
                                            usehandler.index_cursor = .index_cursor
                                        End If
                                    End With
                                End If
                                Set usehandler = Nothing
                                Set usehandler1 = Nothing
                            ElseIf TypeOf myobject Is mHandler Then
                                Set usehandler = myobject
                                If usehandler.indirect > -1 Then
                                    If MyIsObject(var(usehandler.indirect)) Then
                                        ' we pass an indirect handler (Static in module)
                                        ' as a non static in var(v), so we can return it, but why???
                                        Set var(v) = var(usehandler.indirect)
                                    Else
                                        BadObjectDecl
                                        Exec1 = 0: ExecuteVar = 8: Exit Function
                                    End If
                                Else
                                    Set var(v) = usehandler
                                    If usehandler.t1 = 4 Then
                                        If usehandler.sign * usehandler.index_cursor <> p Then usehandler.sign = -usehandler.sign
                                    End If
                                End If
                                If TypeOf bstack.lastobj Is mHandler Then
                                    Set usehandler1 = bstack.lastobj
                                    If Typename(var(v)) = mHdlr Then
                                    Set usehandler = var(v)
                                    With usehandler1
                                        If .UseIterator Then
                                            usehandler.UseIterator = True
                                            usehandler.index_start = .index_start
                                            usehandler.index_End = .index_End
                                            usehandler.index_cursor = .index_cursor
                                        End If
                                    End With
                                    Set usehandler = Nothing
                                    End If
                                    Set usehandler1 = Nothing
                                End If
                                Set bstack.lastobj = Nothing
                            ElseIf TypeOf myobject Is lambda Then
                                If funid.Find(w$ + "(", (i)) Then
                                funid.ItemCreator w$ + "(", -2
                                End If
                                If here$ = vbNullString Or VarStat Or NewStat Then
                                        GlobalSub w$ + "()", "", , , v
                                Else
                                        GlobalSub here$ & "." & bstack.GroupName & w$ + "()", "", , , v
                                End If
                                Set var(v) = myobject
                                Set bstack.lastobj = Nothing
                            ElseIf TypeOf myobject Is mEvent Then
                            Set var(v) = myobject
                            CopyEvent var(v), bstack
                            Set var(v) = bstack.lastobj
                            ElseIf VarType(var(v)) = vbEmpty Then
                            Set var(v) = myobject
                            Else
                                Set myobject = Nothing
                                Set bstack.lastobj = Nothing
                                If VarType(var(v)) = vbLong Then
                                    NoObjectpAssignTolong
                                ElseIf VarType(var(v)) = vbInteger Then
                                    NoObjectpAssignToInteger
                                Else
                                    NoObjectAssign
                                    If var(v) = vbEmpty Then var(v) = 0#
                                End If
                                Exec1 = 0: ExecuteVar = 8: Exit Function
                            End If
                            Set bstack.lastpointer = Nothing
                            Set bstack.lastobj = Nothing
                            Set myobject = Nothing
                        End If
                    ElseIf LastErNum1 < 0 Then
                        Exec1 = 0: ExecuteVar = 11
                        Exit Function
                    ElseIf IsStrExp(bstack, B$, ss$, Len(bstack.tmpstr) = 0) Then
                    If bstack.lastobj Is Nothing Then
                    If ss$ = vbNullString Then
                    var(v) = 0#
                    Else
                If IsNumberCheck(ss$, p) Then
                
                     If usetype Then
                            If AssignTypeNumeric(p, VarType(var(v))) Then
                                var(v) = p
                            Else
                                Exec1 = 0: ExecuteVar = 8: Exit Function
                            End If
                            Else
                            If VarType(var(v)) = vbLong Then
                                On Error Resume Next
                                    var(v) = CLng(Int(p))
                                    If Err.Number > 0 Then OverflowLong: Exec1 = 0: ExecuteVar = 8: Exit Function
                                    On Error GoTo 0
                            ElseIf VarType(var(v)) = vbInteger Then
                                On Error Resume Next
                                    var(v) = CInt(Int(p))
                                    If Err.Number > 0 Then OverflowLong True: Exec1 = 0: ExecuteVar = 8: Exit Function
                                    On Error GoTo 0
                            Else
                                var(v) = p
                            End If
                            End If
                    End If
                    End If
                    Else
                    GoTo checkobject
                    End If
                    Else
                    ' if is string then what???
                        If var(v) = vbEmpty Then var(v) = 0#
                        NoValueForVar w$
                        Exec1 = 0: ExecuteVar = 8
                        Exit Function
                    End If
                    ExecuteVar = 7: Exit Function
                Else
assigngroup:
                    If var(v) Is Nothing Then
                        AssigntoNothing  ' Use Declare
                        Exec1 = 0: ExecuteVar = 8
                        Exit Function
                    ElseIf TypeOf var(v) Is Group Then
                        If IsExp(bstack, B$, p) Then

                            If var(v).HasSet Then
                                Set myobject = bstack.soros
                                Set bstack.Sorosref = New mStiva
                                If bstack.lastobj Is Nothing Then
                                    bstack.soros.PushVal p
                                Else
                                If TypeOf bstack.lastobj Is VarItem Then
                                bstack.soros.DataOptional
                                Else
                                bstack.soros.DataObj bstack.lastobj
                                End If
                                    Set bstack.lastobj = Nothing
                                End If
                                NeoCall2 bstack, w$ + "." + ChrW(&H1FFF) + ":=()", ok
                                Set bstack.Sorosref = myobject
                                Set myobject = Nothing
                            ElseIf bstack.lastobj Is Nothing Then
                                NeedAGroupInRightExpression
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            ElseIf TypeOf bstack.lastobj Is Group Then
                                Set myobject = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                ss$ = bstack.GroupName
                                If var(v).HasValue Or var(v).HasSet Then
                                PropCantChange
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                                Else
                                If Len(var(v).GroupName) > Len(w$) Then
                                    If var(v).IamRef Then ' Or Len(bstack.UseGroupname ) > 0
                                
                                     sw$ = here$
                                      here$ = vbNullString
                                    UnFloatGroupReWriteVars bstack, var(v).Patch, v, myobject
                                    here = sw$
                                    Else
                                    
                                    UnFloatGroupReWriteVars bstack, w$, v, myobject
                                    End If
                                    myobject.ToDelete = True
                                Else
                                    bstack.GroupName = Left$(w$, Len(w$) - Len(var(v).GroupName) + 1)
                                    If Len(var(v).GroupName) > 0 Then
                                        w$ = Left$(var(v).GroupName, Len(var(v).GroupName) - 1)
                                        sw$ = here$
                                        here$ = vbNullString
                                        
                                        UnFloatGroupReWriteVars bstack, w$, v, myobject
                                        
                                        here = sw$
                                        myobject.ToDelete = True
                                    ElseIf var(v).IamApointer And myobject.IamApointer Then
                                        Set var(v) = myobject
                                    Else
                                        Set myobject = Nothing
                                        bstack.GroupName = ss$
                                        If var(v).IamApointer Then
                                            MyEr "Use -> to get a pointer to group", "вЯГСИЛОПОъГСЕ ТО -> ЦИА МА ПэЯЕИР ДЕъЙТГ СЕ ОЛэДА"
                                        Else
                                            GroupWrongUse
                                        End If
                                        Exec1 = 0: ExecuteVar = 8
                                        Exit Function
                                    End If
                                End If
                                End If
                                Set myobject = Nothing
                                bstack.GroupName = ss$
                                Set bstack.lastpointer = Nothing
                            Else
                                WrongObject
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            ExecuteVar = 7: Exit Function
                        Else
noexpression:
                        If Left$(B$, 1) = ">" Then
noexpression1:
                        If var(v).IamApointer Then
                            If var(v).link.IamFloatGroup Then
                            ExecuteVar = 10

                            Mid$(B$, 1, 1) = ChrW(3)
                            Else

                            ExecuteVar = 9
                            Mid$(B$, 1, 1) = Chr$(0)

                            End If
                            Set bstack.lastpointer = var(v)
                            
                            
                                Exit Function
                                
                        Else
                        MyEr "No pointer in " + w$, "дЕМ УПэЯВЕИ ДЕъЙТГР СТГМ " + w$
                        
                        
                        End If
                        End If
                            Set myobject = Nothing
                            Set bstack.lastobj = Nothing
                            MissNumExpr
                            Exec1 = 0: ExecuteVar = 8
                            End If
                            Exit Function
                        
                    ElseIf TypeOf var(v) Is PropReference Then
                    If IsExp(bstack, B$, p) Then
                                If FastSymbol(B$, "@") Then
                                    If IsExp(bstack, B$, sp) Then
                                        var(v).index = p: sp = 0
                                    ElseIf IsStrExp(bstack, B$, ss$, Len(bstack.tmpstr) = 0) Then
                                        var(v).index = ss$: ss$ = vbNullString
                                    End If
                                    var(v).UseIndex = True
                                End If
                            var(v).Value = p
                    Else
                    GoTo noexpression
                    End If
                    ExecuteVar = 7: Exit Function
                    ElseIf TypeOf var(v) Is lambda Then
                        ' exist and take something else
                        If IsExp(bstack, B$, p) Then
                            If bstack.lastobj Is Nothing Then
                                Expected "lambda", "КэЛДА"
                            ElseIf TypeOf bstack.lastobj Is lambda Then
                                Set var(v) = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                ExecuteVar = 7: Exit Function
                            Else
                                Expected "lambda", "КэЛДА"
                            End If
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function

                        Else
                            MissNumExpr
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
                        End If
                    ElseIf TypeOf var(v) Is mHandler Then  ' CHECK IF IT IS A HANDLER
                        Set usehandler = var(v)
                        If IsExp(bstack, B$, p) Then
                            If usehandler.ReadOnly Then
                                ReadOnly
                                Exec1 = 0: ExecuteVar = 8: Exit Function
                            End If
jumpbackhere:
                            Set usehandler = var(v)
                            If bstack.lastobj Is Nothing Then
                                If usehandler.t1 = 4 Then
                                    Set myobject = usehandler.objref.SearchValue(p, ok)
                                    If ok Then
                                        Set var(v) = myobject
                                    Else
                                        ExpectedEnumType
                                        Exec1 = 0: ExecuteVar = 8: Exit Function
                                    End If
                                Else
                                    MissingObjReturn
                                    Exec1 = 0: ExecuteVar = 8: Exit Function
                                End If
                            ElseIf Typename(bstack.lastobj) = mHdlr Then
                            
                                Set usehandler1 = New mHandler
                                Set usehandler = bstack.lastobj
                                usehandler.CopyTo usehandler1
                                If usehandler.indirect > 0 Then
                                    Set myobject = usehandler1
                                    CheckDeepAny myobject
                                    usehandler.indirect = -1
                                    Set usehandler.objref = myobject
                                    Set var(v) = usehandler
                                    Set usehandler1 = New mHandler
                                    bstack.lastobj.CopyTo usehandler1
                                    'Set myobject = usehandler1
                                ElseIf usehandler1.t1 = 4 Then
                                    Set usehandler = var(v)
                                    If Not usehandler.objref Is usehandler1.objref Then
                                        If usehandler.objref.EnumName = usehandler1.objref.EnumName Then
                                            If usehandler.objref.ExistFromOther(usehandler1.index_cursor) Then
                                                Set usehandler1.objref = usehandler.objref
                                                'Set var(v) = usehandler1
                                            Else
                                                GoTo contwrong1
                                            End If
                                        Else
contwrong1:
                                            WrongType
                                            Set bstack.lastobj = Nothing
                                            Exec1 = 0: ExecuteVar = 8: Exit Function
                                        End If
                                    End If
                                End If
                                Set var(v) = usehandler1
                                
                            ElseIf Typename(bstack.lastobj) = myArray Then
                                Set usehandler1 = New mHandler
                                usehandler1.t1 = 3
                                Set usehandler1.objref = bstack.lastobj
                                Set var(v) = usehandler1
                                
                            Else
                                
                                Set usehandler1 = var(v)
                                usehandler1.t1 = 0
                                Set usehandler1.objref = bstack.lastobj
                                
                            End If
                            Set usehandler1 = Nothing
                            Set myobject = Nothing
                        Else
                            MissNumExpr
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
                        End If
                        Set bstack.lastobj = Nothing
                        Set myobject = Nothing
                      ElseIf TypeOf var(v) Is Constant Then
          If Typename(var(v).Value) = "Empty" Then
          If IsExp(bstack, B$, p) Then
          If bstack.lastobj Is Nothing Then
                var(v).DefineOnce p
          Else
                CantAssignValue
                              MissNumExpr
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
          End If
            Else
                            MissNumExpr
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
          End If
          Else
                      If InStr(ss$, ".") = 0 Or var(v).flag Then
                      CantAssignValue
                      Else
                      NoOperatorForThatObject "="
                      End If
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
                        End If
                      ElseIf TypeOf var(v) Is mEvent Then
                      If IsExp(bstack, B$, p) Then
                      If Typename$(bstack.lastobj) = "mEvent" Then
                            Set var(v) = bstack.lastobj
                            CopyEvent var(v), bstack
                            Set var(v) = bstack.lastobj
                            Set bstack.lastobj = Nothing
                            End If
                        Else
misnum:                            MissNumExpr
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
                        End If
                    ElseIf MyIsObject(var(v)) Then
                    If IsExp(bstack, B$, p) Then
                    Set p = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    If Typename(p) = Typename(var(v)) Then
                    Set var(v) = p
                    
                    Else
                    WrongObject
                           Exec1 = 0: ExecuteVar = 8
                            Exit Function
                    
                    End If
                    Else
                        GoTo misnum
                    End If
        
                    Else
                        GoTo somethingelse
                    End If
                End If
            Else
                ' or do something else
                
somethingelse:
                i = MyTrimL(B$)
                If InStr("/*-+=~^&|<>", Mid$(B$, i, 1)) > 0 Then
                    If InStr("/*-+=~^&|<>!", Mid$(B$, i + 1, 1)) > 0 Then
                        ss$ = Mid$(B$, i, 2)
                        If ss$ = "=&" Then
                        ss$ = "= "
                        Mid$(B$, i, 1) = " "
                        Else
                        Mid$(B$, i, 2) = "  "
                        End If
                    ElseIf AscW(B$) = 124 Then
                       
                        Mid$(B$, i, 1) = " "
                        If FastPureLabel(B$, ss$, , , , , False) = 1 Then
                            ss$ = "@@"
                        Else
                            WrongOperator
                        End If
                    Else
                        ss$ = Mid$(B$, i, 1)
                        Mid$(B$, i, 1) = " "
                        
                    End If
                Else
                    ExecuteVar = 6: Exit Function
                End If
                
                If MyIsNumeric(var(v)) Then
                On Error GoTo LONGERR
                lasttype = VarType(var(v)) = vbInteger
                If lasttype Then
                   Select Case ss$
                    Case "="
                        v = globalvar(w$, CInt(Int(p)), , VarStat, temphere$)
                        GoTo assignvalue2
                    Case "+="
                        If IsExp(bstack, B$, p) Then
                            var(v) = CInt(Int(p) + var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "-="
                        If IsExp(bstack, B$, p) Then
                            var(v) = CInt(-Int(p) + var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "*="
                        If IsExp(bstack, B$, p) Then
                            var(v) = CInt(Int(p) * var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "/="
                        If IsExp(bstack, B$, p) Then
                            If Int(p) = 0 Then
                                DevZero
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            var(v) = CInt(var(v) \ Int(p))
                        Else
                            GoTo noexpression
                        End If
                    Case "-!"
                        var(v) = CInt(-var(v))
                    Case "++"
                        var(v) = CInt(1 + var(v))
                    Case "--"
                        var(v) = CInt(var(v) - 1)
                    Case "~"
                        var(v) = CInt(Not CBool(var(v)))
                    Case "@@"
                        FastPureLabel B$, ss$, , True
                        If Mid$(B$, 1, 1) = "#" Then ss$ = ss$ + "#": Mid$(B$, 1, 1) = " "
                        If IsExp(bstack, B$, p) Then
                            If Int(p) = 0 Then
                                DevZero
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            Select Case ss$
                            Case "DIV", "диа"
                                var(v) = Fix(var(v) / p)
                            Case "DIV#", "диа#"
                                If p < 0 Then
                                    var(v) = Int((var(v) - Abs(var(v) - Abs(p) * Int(var(v) / Abs(p)))) / p)
                                Else
                                    var(v) = Int(var(v) / p)
                                End If
                            Case "MOD", "упок", "упокоипо"
                                sp = var(v) - Fix(var(v) / p) * p
                                If Abs(sp) >= Abs(p) Then sp = sp - sp
                                var(v) = sp
                            Case "MOD#", "упок#", "упокоипо#"
                                sp = Abs(var(v) - Abs(p) * Int(var(v) / Abs(p)))
                                If Abs(sp) >= Abs(p) Then sp = sp - sp
                                var(v) = sp
                            Case Else
                                WrongOperator
                            End Select
                            var(v) = CInt(var(v))
                        Else
                            GoTo noexpression
                        End If
                       
                    Case Else
                    ExecuteVar = 6: Exit Function
                End Select
                GoTo checksyntax
                ElseIf VarType(var(v)) = vbLong Then
       
                   Select Case ss$
                    Case "="
                        v = globalvar(w$, CLng(Int(p)), , VarStat, temphere$)
                        GoTo assignvalue2
                    Case "+="
                        If IsExp(bstack, B$, p) Then
                            var(v) = CLng(Int(p) + var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "-="
                        If IsExp(bstack, B$, p) Then
                            var(v) = CLng(-Int(p) + var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "*="
                        If IsExp(bstack, B$, p) Then
                            var(v) = CLng(Int(p) * var(v))
                        Else
                            GoTo noexpression
                        End If
                    Case "/="
                        If IsExp(bstack, B$, p) Then
                            If Int(p) = 0 Then
                                DevZero
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            var(v) = CLng(var(v) \ Int(p))
                        Else
                            GoTo noexpression
                        End If
                    Case "-!"
                        var(v) = CLng(-var(v))
                    Case "++"
                        var(v) = CLng(1 + var(v))
                    Case "--"
                        var(v) = CLng(var(v) - 1)
                    Case "~"
                        var(v) = CLng(Not CBool(var(v)))
                    Case "@@"
                        FastPureLabel B$, ss$, , True
                        If Mid$(B$, 1, 1) = "#" Then ss$ = ss$ + "#": Mid$(B$, 1, 1) = " "
                        If IsExp(bstack, B$, p) Then
                            If Int(p) = 0 Then
                                DevZero
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            Select Case ss$
                            Case "DIV", "диа"
                             var(v) = CLng(Fix(var(v) / p))
                            Case "DIV#", "диа#"
                                If p < 0 Then
                                    var(v) = CLng((var(v) - Abs(var(v) - Abs(p) * Int(var(v) / Abs(p)))) / p)
                                Else
                                    var(v) = CLng(var(v) / p)
                                End If
                            Case "MOD", "упок", "упокоипо"
                                sp = var(v) - Fix(var(v) / p) * p
                                If Abs(sp) >= Abs(p) Then sp = sp - sp
                                var(v) = CLng(sp)
                            Case "MOD#", "упок#", "упокоипо#"
                                sp = Abs(var(v) - Abs(p) * Int(var(v) / Abs(p)))
                                If Abs(sp) >= Abs(p) Then sp = sp - sp
                                var(v) = CLng(sp)
                            Case Else
                                WrongOperator
                            End Select
                        Else
                            GoTo noexpression
                        End If
                    Case Else
                    ExecuteVar = 6: Exit Function
                End Select
checksyntax:
                        If NocharsInLine(B$) Then ExecuteVar = 8: Exit Function
                        If MaybeIsSymbol(B$, b12345) Then ExecuteVar = 7: Exit Function
                        SyntaxError
                        Exec1 = 0: ExecuteVar = 8
                        Exit Function
                On Error GoTo 0
                Else
                
                On Error Resume Next
                AssignTypeNumeric sp, VarType(var(v))
                Select Case ss$
                    Case "="
                        v = globalvar(w$, p, , VarStat, temphere$)
                        GoTo assignvalue2
                    Case "+="
                        If IsExp(bstack, B$, p) Then

                            var(v) = p + var(v)
                            
                            If Err.Number = 6 Then
                            Err.Clear
                            var(v) = CDbl(p) + CDbl(var(v))
                            End If
                            If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "-="
                        If IsExp(bstack, B$, p) Then
                            var(v) = -p + var(v)
                            If Err.Number = 6 Then
                            Err.Clear
                            var(v) = CDbl(-p) + CDbl(var(v))
                            End If
                            If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "*="
                        If IsExp(bstack, B$, p) Then
                            sp = p * var(v)
                            If Err.Number = 6 Then
                            Err.Clear
                            var(v) = CDbl(p) * CDbl(var(v))
                            Else
                            var(v) = sp
                            End If
                            If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "/="
                        If IsExp(bstack, B$, p) Then
                            If p = 0# Then
                                DevZero
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            var(v) = var(v) / p
                            
                            If Err.Number = 6 Then
                            Err.Clear
                            var(v) = CDbl(var(v)) / CDbl(p)
                            End If
                            If RoundDouble Then If VarType(var(v)) = vbDouble Then var(v) = MyRound(var(v), 13)
                        Else
                            GoTo noexpression
                        End If
                    Case "-!"
                        var(v) = -var(v)
                    Case "++"
                        var(v) = 1 + var(v)
                    Case "--"
                        var(v) = var(v) - 1
                    Case "~"
                    Select Case VarType(var(v))
                    Case vbBoolean
                        var(v) = Not CBool(var(v))
                    Case vbCurrency
                        var(v) = CCur(Not CBool(var(v)))
                    Case vbDecimal
                        var(v) = CDec(Not CBool(var(v)))
                    Case Else
                        var(v) = CDbl(Not CBool(var(v)))
                        End Select
                    Case "->"
                        GoTo assignpointer
                    Case "@@"
                        FastPureLabel B$, ss$, , True
                        If Mid$(B$, 1, 1) = "#" Then ss$ = ss$ + "#": Mid$(B$, 1, 1) = " "
                        If IsExp(bstack, B$, p) Then
                            If Int(p) = 0 Then
                                DevZero
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            Select Case ss$
                            Case "DIV", "диа"
    
                             var(v) = Fix(var(v) / p)
                            Case "DIV#", "диа#"
                                If p < 0 Then
                                    var(v) = Int((var(v) - Abs(var(v) - Abs(p) * Int(var(v) / Abs(p)))) / p)
                                Else
                                    var(v) = Int(var(v) / p)
                                End If
                            Case "MOD", "упок", "упокоипо"
                                sp = var(v) - Fix(var(v) / p) * p
                                If Abs(sp) >= Abs(p) Then sp = sp - sp
                                var(v) = sp
                             Case "MOD#", "упок#", "упокоипо#"
                                sp = Abs(var(v) - Abs(p) * Int(var(v) / Abs(p)))
                                If Abs(sp) >= Abs(p) Then sp = sp - sp
                                var(v) = sp
                            Case Else
                                WrongOperator
                            End Select
                        Else
                            GoTo noexpression
                        End If
                       
                    Case Else
                    
                    If Err.Number = 8 Then
                        Overflow
                        Err.Clear
                    ElseIf Len(ss$) > 0 Then
                    If GetSub(w$, v) Then
              
                    Mid$(B$, 1, Len(ss$)) = ss$
                    ExecuteVar = 6 ' GoTo autogosub
                    Exit Function
                    Else
                        WrongOperator
                        Exec1 = 0
                        End If
                    Else
                        SyntaxError
                    End If
                    
                    ExecuteVar = 8: Exit Function

                End Select
                If Not VarType(var(v)) = VarType(sp) Then
                If Not AssignTypeNumeric2(var(v), VarType(sp)) Then
                If usetype Then Overflow: Exec1 = 0: ExecuteVar = 8: Exit Function
                End If
                End If
                
                On Error GoTo 0
                GoTo checksyntax
                End If
                ElseIf TypeOf var(v) Is Group Then
                If ss$ = "->" Then
                 GoTo assignpointer
                End If
                If var(v).IamApointer Then
                If var(v).link.IamFloatGroup Then
                    MyPush bstack, B$
                    Set bstack.lastobj = var(v).link
                    ProcessOper bstack, myobject, ss$, (0), 1
                    If Not bstack.lastobj Is Nothing Then
                    Set var(v).LinkRef = bstack.lastobj
                    Set bstack.lastobj = Nothing
                    ExecuteVar = 7: Exit Function
                    Else
                    GoTo here1234
                    End If
                    Else
                    w$ = var(v).lasthere + "." + var(v).GroupName
                End If
                End If
                Set myobject = bstack.soros
comeoper:
                Set bstack.Sorosref = New mStiva
                    If IsExp(bstack, B$, p) Then
                        If bstack.lastobj Is Nothing Then
                            bstack.soros.PushVal p
                        Else
                    If TypeOf bstack.lastobj Is VarItem Then
                    bstack.soros.DataOptional
                    Else
                    bstack.soros.DataObj bstack.lastobj
                    End If
                            Set bstack.lastobj = Nothing
                        End If
                    End If

                    NeoCall2 bstack, w$ + "." + ChrW(&H1FFF) + ss$ + "()", ok
                     Set bstack.Sorosref = myobject
                 Set myobject = Nothing
                    If Not ok Then
here1234:
                        If LastErNum = 0 Then
                            MisOperatror (ss$)
                        End If
                        Exec1 = 0: ExecuteVar = 8
                        Exit Function
                    End If
                Else
                    Set myobject = var(v)
                    
                    If CheckIsmArray(myobject) Then
                    If ss$ = "@@" Then
                            If FastPureLabel(B$, ss$, , True) Then
                                If Mid$(B$, 1, 1) = "#" Then ss$ = ss$ + "#": Mid$(B$, 1, 1) = " "
                              
                           Else
                                WrongOperator
                           End If
                        End If
                    

                        If IsExp(bstack, B$, p) Then
                            If Not bstack.lastobj Is Nothing Then
                                If TypeOf bstack.lastobj Is mArray Then
                                    Set usehandler = New mHandler
                                    usehandler.t1 = 3
                                    Set usehandler.objref = bstack.lastobj
                                    Set var(v) = usehandler
                                Else
                                Set pppp1 = myobject
                                    Set myobject = bstack.lastobj
                                    If CheckIsmArray(myobject) Then
                                        Set usehandler = New mHandler
                                        usehandler.t1 = 3
                                        Set usehandler.objref = myobject
                                        Set var(v) = usehandler
                                    ElseIf TypeOf myobject Is mHandler And ss$ <> vbNullString Then
                                        Set usehandler = myobject
                                        If usehandler.t1 = 4 Then
                                            pppp1.Compute2 p, ss$
                                        End If
                                    Else
NotArray1:
                                    
                                        NotArray
                                        Exec1 = 0: ExecuteVar = 8
                                        Exit Function
                                    End If
                                End If
                            Else
                            
                                myobject.Compute2 p, ss$
                            End If
                            Set usehandler = Nothing
                            Set myobject = Nothing
                            Set bstack.lastobj = Nothing
                        Else
                        
                            myobject.Compute3 ss$
                            Set myobject = Nothing
                            Set bstack.lastobj = Nothing
                        End If
                    ElseIf TypeOf myobject Is mHandler Then
                        Set usehandler = myobject
                        If usehandler.t1 = 4 Then
                            If usehandler.ReadOnly Then
                                    ReadOnly
                                    Exec1 = 0: ExecuteVar = 8: Exit Function
                            ElseIf ss$ = "++" Then
                                If usehandler.index_start < usehandler.objref.count - 1 Then
                                    usehandler.index_start = usehandler.index_start + 1
                                    usehandler.objref.index = usehandler.index_start
                                    usehandler.index_cursor = usehandler.objref.Value
                                End If
                            ElseIf ss$ = "--" Then
                                If usehandler.index_start > 0 Then
                                    usehandler.index_start = usehandler.index_start - 1
                                    usehandler.objref.index = usehandler.index_start
                                    usehandler.index_cursor = usehandler.objref.Value
                                End If
                            ElseIf ss$ = "-!" Then
                                usehandler.sign = -usehandler.sign
                            Else
                                NoOperatorForThatObject ss$
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                            Set usehandler = Nothing
                        Else
                            NoOperatorForThatObject ss$
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
                        End If
                    Else
                        NoOperatorForThatObject ss$
                        Exec1 = 0: ExecuteVar = 8
                        Exit Function
                    End If
                End If
            End If
            ExecuteVar = 7: Exit Function
            

        ElseIf Not bstack.StaticCollection Is Nothing Then
            If bstack.ExistVar(w$, ok) Then
                If FastOperator(B$, "=", i) Then
                
                    If IsExp(bstack, B$, p) Then
checkobject1:
                        Set myobject = bstack.lastobj
                        If CheckIsmArray(myobject) Then
                            Set bstack.lastobj = myobject
                            bstack.SetVarobJ w$, bstack.lastobj
                        ElseIf CheckLastHandler(myobject) Then
                            Set usehandler = myobject
                            If usehandler.t1 = 2 Then
                                bstack.SetVarobJ w$, myobject
                            ElseIf usehandler.t1 = 1 Then
                                Set usehandler = New mHandler
                                usehandler.t1 = 1
                                Set usehandler.objref = myobject
                                Set myobject = usehandler
                                Set usehandler = Nothing
                                bstack.SetVarobJ w$, myobject
                            ElseIf usehandler.t1 = 3 Then
                                bstack.SetVarobJ w$, myobject
                            ElseIf usehandler.t1 = 4 Then
                                bstack.SetVarobJ w$, myobject
                            Else
                               GoTo aproblem1
                            End If
                        
                        ElseIf ok Then
                        bstack.ReadVar w$, sp
                        If TypeOf sp Is mHandler Then
                        Set usehandler = sp
                        If usehandler.t1 = 4 Then
                         Set sp = usehandler.objref.SearchValue(p, ok)
                         
                            If Not ok Then GoTo aproblem1
                           
                            bstack.SetVarobJ w$, sp
                                    Else
                                    GoTo aproblem1
                                    End If
        
                        Else
                        GoTo aproblem1
                        End If
                      
                        
                        Else
                            bstack.SetVar w$, p
                        End If
                        Set myobject = Nothing
                        Set bstack.lastobj = Nothing
                        ExecuteVar = 7: Exit Function
                    ElseIf IsStrExp(bstack, B$, ss$, Len(bstack.tmpstr) = 0) Then
                            If ss$ = vbNullString Then
                            p = 0#
                            Else
                            p = val(ss$)
                            End If
                            GoTo checkobject1
                    Else
                        If ok Then
                        bstack.ReadVar w$, sp
                        
                        If TypeOf sp Is Group Then
                        If Left$(B$, 1) = ">" Then
                        Set bstack.lastpointer = sp
                        Mid$(B$, 1, 1) = Chr$(3)
                         ExecuteVar = 10
                         Exit Function
                        Else
                        GoTo aproblem1
                        End If
                        Else
                        GoTo aproblem1
                        End If
                        Else
                        GoTo aproblem1
                        End If
                    End If
                Else
                    If InStr("/*-+~|", Mid$(B$, i, 1)) > 0 Then
                        If InStr("=+-!", Mid$(B$, i + 1, 1)) > 0 Then
                            ss$ = Mid$(B$, i, 2)
                            Mid$(B$, i, 2) = "  "
                        ElseIf Mid$(B$, i, 1) = "|" Then
                        Mid$(B$, i, 1) = " "
                        If FastPureLabel(B$, ss$, , True) = 1 Then
                            If Mid$(B$, 1, 1) = "#" Then ss$ = ss$ + "#": Mid$(B$, 1, 1) = " "
                        Else
                            WrongOperator
                        End If
                        
                        Else
                            ss$ = Mid$(B$, i, 1)
                            Mid$(B$, i, 1) = " "
                        End If
                    End If
                    If Right$(ss$, 1) = "=" Or Len(ss$) > 2 Then
                    If IsExp(bstack, B$, p) Then
                 If Not bstack.AlterVar(w$, p, ss$, False) Then Exec1 = 0: ExecuteVar = 8: Exit Function
                 Else
                 GoTo aproblem1
                 End If
                 Else
                 If Not bstack.AlterVar(w$, p, ss$, False) Then Exec1 = 0: ExecuteVar = 8: Exit Function
                 End If
                ExecuteVar = 7: Exit Function
                End If
                
                
            End If
            If FastOperator(B$, "=", i) Then ' MAKE A NEW ONE IF FOUND =
                If FastOperator(B$, ">", i + 1) Then
                    If GetVar(bstack, w$, v, True) Then
                        GoTo jumphere1
                    Else
                        SyntaxError
                        Set bstack.lastobj = Nothing
                        Exec1 = 0: ExecuteVar = 8: Exit Function
                    End If
                Else
                v = globalvar(w$, p, , VarStat, temphere$)
                GoTo assignvalue
                End If
            ElseIf FastOperator(B$, "->", i, 2) Then
                GoTo jumpforpointer
            ElseIf GetVar(bstack, w$, v, True) Then
                    GoTo somethingelse
            End If
        ElseIf FastOperator(B$, "=", i) Then ' MAKE A NEW ONE IF FOUND =
jumpiflocal:
            If FastOperator(B$, ">", i) Then
            If GetVar(bstack, w$, v, True) Then
jumphere1:
            If Not var(v) Is Nothing Then
            If TypeOf var(v) Is Group Then
                GoTo noexpression1
                End If
            End If
            End If
            MyEr "Only for Group Pointers", "лЭМО ЦИА ДЕъЙТЕР ОЛэДЫМ"
            Exec1 = 0: ExecuteVar = 8: Exit Function
            ElseIf AscW(w$) = &H1FFF Then
            If GetVar(bstack, w$, v, True) Then GoTo assignvalue
            If GetlocalVar(w$, v) Then GoTo assignvalue
            Else
            v = globalvar(w$, p, , VarStat, temphere$)

            GoTo assignvalue
            End If
        ElseIf FastOperator(B$, "->", i, 2) Then ' MAKE A NEW ONE IF FOUND =
jumpforpointer:
            If AscW(w$) = &H1FFF Then
            If GetVar(bstack, w$, v, True) Then GoTo assignpointer
            If GetlocalVar(w$, v) Then GoTo assignpointer
            Else
            If GetVar(bstack, w$, v, True, , , , , ok) Then
            If ok Then
            v = globalvar(w$, p, , VarStat, temphere$)
            End If
            Else
            v = globalvar(w$, p, , VarStat, temphere$)
            End If
            GoTo assignpointer
            End If
        ElseIf GetVar(bstack, w$, v, True) Then
        ' CHECK FOR GLOBAL
            GoTo somethingelse
        End If
    End If
End If
'***********************
Exit Function
assignpointer:
                    If GetPointer(bstack, B$) Then
                    If MyIsObject(var(v)) Then
                    If var(v).IamApointer Then
                    Set var(v) = bstack.lastpointer
                    ElseIf var(v).soros.count > 0 Or var(v).FuncList <> vbNullString Then
                    MyEr "Can't assign pointer to named group", "дЕМ ЛПОЯЧ МА БэКЫ ДЕъЙТГ СЕ ЕПЧМУЛГ ОЛэДА"
                    Set bstack.lastpointer = Nothing
                        Set bstack.lastobj = Nothing  '???
                     Exec1 = 0: ExecuteVar = 8: Exit Function
                    Else
                     Set var(v) = bstack.lastpointer
                     End If
                     Else
                     Set var(v) = bstack.lastpointer
                     End If
                     Set bstack.lastpointer = Nothing
                        Set bstack.lastobj = Nothing  '???
  
                    
                    Else
                   
                     MyEr "No Pointer Found", "дЕМ БЯчЙА ДЕъЙТГ"
                       Set bstack.lastobj = Nothing
                     Exec1 = 0: ExecuteVar = 8: Exit Function
                    End If
                    
                    ExecuteVar = 7: Exit Function
'***********************
'' Case 2
'' no case 2 here
Case3:
If AscW(w$) = 46 Then
               If Not expanddot(bstack, w$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
                Exec1 = 0: ExecuteVar = 8: Exit Function
               End If
Else
Select Case CheckThis(bstack, w$, B$, v, Lang)
Case 0
Case 1
GoTo assignvaluestr1
Case -1
Exec1 = 0: ExecuteVar = 8: Exit Function
End Select
End If

        ss$ = vbNullString
        If Left$(B$, 1) = "_" Then
        If nchr <> 61 Then
            SyntaxError
            Exit Function
        End If
        ss$ = "g"
        Mid$(B$, 1, 1) = " "
        GoTo again12345
        ElseIf FastSymbol(B$, ".") Then
        If GetVar(bstack, w$, v) Then  'GetlocalVar(w$, V) Then
             If MaybeIsSymbol(B$, "-+*/<~") Then
            If Right$(var(v), 1) = ")" Then
              B$ = var(v) + B$
              Else
             bstack.tmpstr = var(v) + Left$(B$, 1)
               BackPort B$
             End If
             ElseIf lookOne(B$, "=") Then
             If Right$(var(v), 1) = ")" Then
              B$ = var(v) + B$
              sss = Len(B$)
             Else
              bstack.tmpstr = var(v) + "=_"
              BackPort B$
              End If
             Else

             IsLabelDot temphere$, B$, w$
              If lookOne(B$, "=") Then
             w$ = var(v) + "." + w$
              bstack.tmpstr = w$ + "=_"
              BackPort B$
              ElseIf MaybeIsSymbol(B$, "-+*/<~") Then
               bstack.tmpstr = var(v) + "." + w$ + Left$(B$, 1)
               BackPort B$
              ElseIf Len(w$) = 0 Then
               bstack.tmpstr = var(v) + " " + Left$(B$, 1)
               BackPort B$
              Else
               bstack.tmpstr = var(v) + "." + w$ + " " + Left$(B$, 1)
               BackPort B$
               
              End If
             End If
              ExecuteVar = 5: Exit Function
        Else
                UnKnownWeak w
        End If
        End If
        i = MyTrimL(B$)
        If i > Len(B$) Then
        
        ElseIf InStr("/*-+=~^&|<>", Mid$(B$, i, 1)) > 0 Then
        
                    If InStr("/*-+=~^&|<>!", Mid$(B$, i + 1, 1)) > 0 Then
                        ss$ = Mid$(B$, i, 2)
                        If ss$ = "=&" Then
                        ss$ = "="
                        Mid$(B$, i, 1) = " "
                        Else
                        Mid$(B$, i, 2) = "  "
                        End If
                        If ss$ = "<=" Then ss$ = "g"
                        
                    Else
                        ss$ = Mid$(B$, i, 1)
                        Mid$(B$, i, 1) = " "
                    End If
                    
         End If
         

If ss$ <> "" Then
    If ss$ = "=" Then
    If VarStat Then
            If IsStrExp(bstack, B$, ss$) Then

            GoTo cont184575
            
                    
 
            Else
                    NoValueForVar w$
                    Exec1 = 0: ExecuteVar = 8
                    Exit Function
         End If
    Else
            If NewStat Then
                    If IsStrExp(bstack, B$, ss$) Then globalvar w$, ss$, , VarStat, temphere$
            Else
            If AscW(w$) = &H1FFF Then
            If GetVar(bstack, w$, v, True) Then GoTo assignvaluestr1
            If GetlocalVar(w$, v) Then GoTo assignvaluestr1
            ElseIf GetlocalVar(w$, v) Then
assignvaluestr1:
  ''                 If TypeOf var(v) Is Group Then w$ = varhash.lastkey  ' don't know yet
                     If IsStrExp(bstack, B$, ss$) Then
                  If Typename(var(v)) = mProp Then
                        If FastSymbol(B$, "@") Then
                        If IsExp(bstack, B$, sp) Then
                            var(v).index = p: sp = 0
                        ElseIf IsStrExp(bstack, B$, sw$, Len(bstack.tmpstr) = 0) Then
                        var(v).index = sw$: sw$ = vbNullString
                        End If
                         var(v).UseIndex = True
                        End If
                         var(v).Value = ss$
                  ElseIf Typename$(bstack.lastobj) = "lambda" Then
                                If Typename(var(v)) = "lambda" Then
                                                Set var(v) = bstack.lastobj
                                 Else
                               If here$ = vbNullString Or VarStat Or NewStat Then
                                   GlobalSub w$ + "()", "", , , v
                               Else
                                     GlobalSub here$ & "." & bstack.GroupName & w$ + "()", "", , , v
                                End If
                                               Set var(v) = bstack.lastobj
                                        End If
                                         
                                            Set bstack.lastobj = Nothing
                  ElseIf Typename$(var(v)) = mgroup Then

                  If var(v).HasSet Then
                                Set myobject = bstack.soros
                                Set bstack.Sorosref = New mStiva
                                If bstack.lastobj Is Nothing Then
                                    bstack.soros.PushStr ss$
                                Else
                                    If TypeOf bstack.lastobj Is VarItem Then
                                    bstack.soros.DataOptional
                                    Else
                                    bstack.soros.DataObj bstack.lastobj
                                    End If
                                    Set bstack.lastobj = Nothing
                                End If
                                NeoCall2 bstack, Left$(w$, Len(w$) - 1) + "." + ChrW(&H1FFF) + ":=()", ok
                            Set bstack.Sorosref = myobject
                                Set myobject = Nothing
                   Else
                  
                             If bstack.lastobj Is Nothing Then
                                NeedAGroupInRightExpression
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            ElseIf TypeOf bstack.lastobj Is Group Then
                            Set myobject = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                ss$ = bstack.GroupName
                                If var(v).HasValue Or var(v).HasSet Then
                                PropCantChange
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                                Else
                                w$ = Left$(w$, Len(w$) - 1)
                                If Len(var(v).GroupName) > Len(w$) Then
                                    UnFloatGroupReWriteVars bstack, w$, v, myobject
                                Else
                                    bstack.GroupName = Left$(w$, Len(w$) - Len(var(v).GroupName) + 1)
                                    If Len(var(v).GroupName) > 0 Then
                                        w$ = Left$(var(v).GroupName, Len(var(v).GroupName) - 1)
                                        UnFloatGroupReWriteVars bstack, w$, v, myobject
                                    Else
                                        GroupWrongUse
                                        Exec1 = 0: ExecuteVar = 8
                                        Exit Function
                                    End If
                                End If
                                End If
                                Set myobject = Nothing
                                bstack.GroupName = ss$
                            Else
                              GroupCantSetValue
                            End If
                   
                        
                   End If
                  Else
                                  If CheckVarOnlyNo(var(v), ss$) Then
                                  If Typename(var(v)) = "Constant" Then
                                  If Typename(var(v).Value) = "Empty" Then
                                    If bstack.lastobj Is Nothing Then
                                          var(v).DefineOnce ss$
                                          ExecuteVar = 7: Exit Function
                                    Else
                                          NoObjectAssign
                                                        MissNumExpr
                                                      Exec1 = 0: ExecuteVar = 8
                                                      Exit Function
                                    End If
                       
                                Else
                            CantAssignValue
                            End If
                                  Else
                                    ExpectedObj Typename(var(v))
                                    End If
                                    Exec1 = 0: ExecuteVar = 8: Exit Function
                                  End If
                            End If
                        End If
                    ElseIf Not bstack.StaticCollection Is Nothing Then
                        If bstack.ExistVar(w$) Then
                            If IsStrExp(bstack, B$, ss$, Len(bstack.tmpstr) = 0) Then bstack.SetVar w$, ss$ Else GoTo aproblem1
                
                            ElseIf IsStrExp(bstack, B$, ss$, Len(bstack.tmpstr) = 0) Then
                                GoTo cont184575
                            End If
                    ElseIf IsStrExp(bstack, B$, ss$) Then
cont184575:
                        If bstack.lastobj Is Nothing Then
       
                            globalvarStr w$, ss$, , VarStat, temphere$
       
                        Else
                            If Typename$(bstack.lastobj) = "lambda" Then
                                If NewStat Then
                                    NoNewLambda
                                    Exit Function
                                Else
                                    i = 0
                                If strfunid.Find(w$ + "(", (i)) Then
                                strfunid.ItemCreator w$ + "(", -2
                                End If
                                    If VarStat Then
                                        i = globalvar(w$, p, , VarStat, temphere$)
                                    Else
                                        If Not GetVar(bstack, w$, i, True) Then i = globalvar(w$, p, , , temphere$)
                                    End If
                                    If Typename(var(i)) = "Constant" Then
                                    CantAssignValue
                                    Exec1 = 0: ExecuteVar = 8
                                    Exit Function
                                    End If
                                    If here$ = vbNullString Or VarStat Then
                                            GlobalSub w$ + "()", "", , , i
                                    Else
                                            GlobalSub here$ & "." & bstack.GroupName & w$ + "()", "", , , i
                                    End If
                                End If
                                Set myobject = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                If i <> 0 Then
                                    Set var(i) = myobject
                                    Set myobject = Nothing
                                End If
                            ElseIf Typename$(bstack.lastobj) = mgroup Then
                                    If Not ProcGroup(200 + (VarStat Or isglobal), bstack, w$, Lang) Then
                                    Exec1 = 0: ExecuteVar = 8
                                    Exit Function
           

                                    End If
                            Else
                                NoValueForVar w$
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
                            End If
                    End If
                Else
                    NoValueForVar w$
                    Exec1 = 0: ExecuteVar = 8
                    Exit Function
                End If
            End If
        End If
    Else    ' g
again12345:
          If GetVar(bstack, w$, v, ss$ = "g") Then
          sw$ = ss$
          w$ = varhash.lastkey
               If IsStrExp(bstack, B$, ss$) Then
                 If Typename(var(v)) = mProp Then
                        If FastSymbol(B$, "@") Then
                            If IsExp(bstack, B$, sp) Then
                            var(v).index = p: sp = 0
                            ElseIf IsStrExp(bstack, B$, sw$, Len(bstack.tmpstr) = 0) Then
                            var(v).index = sw$: sw$ = vbNullString
                            End If
                             var(v).UseIndex = True
                        End If
                        var(v).Value = ss$
                  ElseIf Typename(var(v)) = "Constant" Then
                  If Typename(var(v).Value) = "Empty" Then
                  var(v).DefineOnce ss$
                  Else
                      CantAssignValue
                  End If
                
                   ElseIf Not bstack.lastobj Is Nothing Then
                            If TypeOf bstack.lastobj Is lambda Then
                             Set var(v) = bstack.lastobj
                             GlobalSub w$ + "()", "", , , v
                             Set bstack.lastobj = Nothing
                   
                    Else
                        NoValueForVar w$
                    End If
                    ElseIf Typename$(var(v)) = mgroup Then
                           If sw$ = "g" Then
                           sw$ = ":="
                           If Not var(v).HasSet Then GroupCantSetValue: Exec1 = 0: ExecuteVar = 8: Exit Function
                           End If
                           Set myobject = bstack.soros
                            Set bstack.Sorosref = New mStiva
                           If bstack.lastobj Is Nothing Then
                                bstack.soros.PushStr ss$
                            Else
                                If TypeOf bstack.lastobj Is VarItem Then
                                bstack.soros.DataOptional
                                Else
                                bstack.soros.DataObj bstack.lastobj
                                End If
                                Set bstack.lastobj = Nothing
                            End If
a325674:
                            
                            NeoCall2 bstack, Left$(w$, Len(w$) - 1) + "." + ChrW(&H1FFF) + sw$ + "()", ok
                             Set bstack.Sorosref = myobject
                            Set myobject = Nothing
                            If Not ok Then GoTo here1234
                                
                Else
                If LenB(sw$) = 0 Or sw$ = "g" Or sw$ = "+=" Then
               CheckVar var(v), ss$, sw$ = "+="
               Else
                            NoValueForVar w$
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
               End If
               
               End If
               Else
               ' check
               If Typename$(var(v)) = mgroup Then
               Set myobject = bstack.soros
                Set bstack.Sorosref = New mStiva
               GoTo a325674
               End If
               NoValueForVar w$
               End If
            Else
            If ss$ = "g" Then ss$ = vbNullString:   GoTo again12345
            Nosuchvariable w$
          End If
    End If
Else
        If VarStat Or NewStat Then
            
            globalvar w$, ss$, , VarStat, temphere$
  
          
                    sss = Len(B$)
                ExecuteVar = 4: Exit Function
                
        End If

                 NoValueForVar w$
                    Exec1 = 0: ExecuteVar = 8
             
End If
Exit Function
Case4:
If AscW(w$) = 46 Then
               If Not expanddot(bstack, w$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
                Exec1 = 0: ExecuteVar = 8: Exit Function
               End If
Else
Select Case CheckThis(bstack, w$, B$, v, Lang)
Case 1
GoTo assignvalue100
Case -1
Exec1 = 0: ExecuteVar = 8: Exit Function
End Select

End If
        If Left$(B$, 1) = "_" Then
        If nchr <> 61 Then
            SyntaxError
            Exit Function
        End If
        ss$ = "g"
        Mid$(B$, 1, 1) = " "
        GoTo again1234567
        ElseIf MaybeIsSymbol(B$, "=-+*/<~") Then
    If FastSymbol(B$, "=") Then
    
    If VarStat Then
    
    If IsExp(bstack, B$, p) Then
                                       
                globalvar w$, p, , VarStat, temphere$
                Else
                      If LastErNum <> -2 Then
                     NoValueForVar w$
                    Exec1 = 0: ExecuteVar = 8
                     Exit Function
                     End If
            
            End If
    Else
        If AscW(w$) = &H1FFF Then
        If GetVar(bstack, w$, v, True) Then GoTo assignvalue100
        If varhash.Find2(here$ & "." & myUcase(w$), v, usetype) Then GoTo assignvalue100
        ElseIf varhash.Find2(here$ & "." & myUcase(w$), v, usetype) Then
assignvalue100:
                If IsExp(bstack, B$, p) Then
                If Typename(var(v)) = mProp Then
                  If FastSymbol(B$, "@") Then
                            If IsExp(bstack, B$, sp) Then
                            var(v).index = p: sp = 0
                        ElseIf IsStrExp(bstack, B$, ss$, Len(bstack.tmpstr) = 0) Then
                        var(v).index = ss$: ss$ = vbNullString
                        End If
                         var(v).UseIndex = True
                        End If
                        var(v).Value = MyRound(p)
                ElseIf Not bstack.lastobj Is Nothing Then
                        If TypeOf bstack.lastobj Is lambda Then
                            If Typename(var(v)) = "lambda" Then
                                 Set var(v) = bstack.lastobj
                            Else
                                GlobalSub w$ + "()", "", , , v
                                Set var(v) = bstack.lastobj
                            End If
                            Set bstack.lastobj = Nothing
                        Else
                            
                            ExpectedObj Typename(var(v))
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
                            End If
               ElseIf MyIsObject(var(v)) Then
                        If TypeOf var(v) Is Constant Then
                              If Typename(var(v).Value) = "Empty" Then
                                    If bstack.lastobj Is Nothing Then
                                          var(v).DefineOnce MyRound(p)
                                          ExecuteVar = 7: Exit Function
                                    Else
                                          NoObjectAssign
                                                        MissNumExpr
                                                      Exec1 = 0: ExecuteVar = 8
                                                      Exit Function
                                    End If
                       
                                Else
                            CantAssignValue
                            End If
                        Else
                           ExpectedObj Typename(var(v))
                           
                        End If
                        Exec1 = 0: ExecuteVar = 8
                                    Exit Function
                Else
                        p = MyRound(p)
                        If usetype Then
                                   If AssignTypeNumeric(p, VarType(var(v))) Then
                                       var(v) = p
                                   Else
                                       Exec1 = 0: ExecuteVar = 8: Exit Function
                                   End If
                       Else
                     var(v) = p
                     End If
                End If
 
                If Err.Number = 6 Then Exec1 = 0: ExecuteVar = 1: Exit Function
                On Error GoTo 0
                End If
            ElseIf Not bstack.StaticCollection Is Nothing Then
            If bstack.ExistVar(w$) Then
            If IsExp(bstack, B$, p) Then bstack.SetVar w$, MyRound(p) Else GoTo aproblem1
            
            ElseIf IsExp(bstack, B$, p) Then
            GoTo abc2345
            End If
            
            ElseIf IsExp(bstack, B$, p) Then
abc2345:
            If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is lambda Then
                            v = globalvar(w$, p, , VarStat, temphere$)
                            If NewStat Then  '' ???
                                            NoNewLambda
                                            Exit Function
                                        Else
                                               If here$ = vbNullString Or VarStat Then
                                                GlobalSub w$ + "()", "", , , v
                                            Else
                                                GlobalSub here$ & "." & bstack.GroupName & w$ + "()", "", , , v
                                            End If
                                        End If
                                Set var(v) = bstack.lastobj
                                Set bstack.lastobj = Nothing
                                Else
                                     NoValueForVar w$
                            Exec1 = 0: ExecuteVar = 8
                            Exit Function
                                End If
           Else
            p = MyRound(p)
            
            globalvar w$, p, , VarStat, temphere$
    End If
          
                Else
                      If LastErNum <> -2 Then
aproblem1:
                     NoValueForVar w$
                    Exec1 = 0: ExecuteVar = 8
                     Exit Function
                     End If
            
            End If
    End If
    Else
        ss$ = vbNullString
        If FastSymbol(B$, "+=", , 2) Then
        ss$ = "+"
        ElseIf FastSymbol(B$, "/=", , 2) Then
        ss$ = "/"
        ElseIf FastSymbol(B$, "-=", , 2) Then
        ss$ = "-"
        ElseIf FastSymbol(B$, "*=", , 2) Then
        ss$ = "*"
        ElseIf IsOperator0(B$, "++", 2) Then
        ss$ = "++"
        ElseIf IsOperator0(B$, "--", 2) Then
        ss$ = "--"
        ElseIf IsOperator0(B$, "-!", 2) Then
        ss$ = "-!"
        ElseIf IsOperator0(B$, "~") Then
        ss$ = "!!"
        ElseIf FastSymbol(B$, "<=", , 2) Then
        ss$ = "g"
        End If
again1234567:
        If GetVar(bstack, w$, v, ss$ = "g") Then
        'NOT YET FOR PropReference
      If MyIsObject(var(v)) Then
            If Typename(var(v)) = mProp Then
                    Exec1 = 0: ExecuteVar = 8: Exit Function
            End If
            If TypeOf var(v) Is Constant Then
                NoOperatorForThatObject ss$
                Exec1 = 0: ExecuteVar = 8
                Exit Function
            End If
            
      End If
            If Len(ss$) = 1 Then
                        If IsExp(bstack, B$, p) Then
                        AssignTypeNumeric sp, VarType(var(v))
                                On Error Resume Next
                                Select Case ss$
                                Case "=", "g"
                                    var(v) = MyRound(p)
                                Case "+"
                                    var(v) = MyRound(p) + var(v)
                                Case "*"
                                    var(v) = MyRound(MyRound(p) * var(v))
                                Case "-"
                                    var(v) = var(v) - MyRound(p)
                                Case "/"
                                    If MyRound(p) = 0 Then Exec1 = 0: ExecuteVar = 1: Exit Function
                                    var(v) = MyRound(var(v) / MyRound(p))
                                    
         
                   
                                End Select
                                If Err.Number = 6 Then Exec1 = 0: ExecuteVar = 1: Exit Function
                                On Error GoTo 0
                                AssignTypeNumeric var(v), VarType(sp)
                                GoTo checksyntax
                        Else
                                Exec1 = 0: ExecuteVar = 1: Exit Function
                        End If
            Else
                If ss$ = "++" Then
                    var(v) = 1 + var(v)
                ElseIf ss$ = "--" Then
                    var(v) = var(v) - 1
                ElseIf ss$ = "-!" Then
                    var(v) = -var(v)
                Else
                Select Case VarType(var(v))
                    Case vbBoolean
                        var(v) = Not CBool(var(v))
                    Case vbCurrency
                        var(v) = CCur(Not CBool(var(v)))
                    Case vbDecimal
                        var(v) = CDec(Not CBool(var(v)))
                    Case Else
                        var(v) = CDbl(Not CBool(var(v)))
                        End Select
                End If
  
            End If
            GoTo checksyntax
     Else
        If v = -1 Then
         If Len(ss$) = 1 Then If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
                    
             If Not bstack.AlterVar(w$, p, ss$, True) Then Exec1 = 0: ExecuteVar = 8: Exit Function
            
     ExecuteVar = 7: Exit Function
    Else
        If ss$ = "g" Then ss$ = "=":   GoTo again1234567
       NoValueForVar w$
       Exec1 = 0: ExecuteVar = 8: Exit Function
       End If
      End If
   
    End If
Else
    If VarStat Or NewStat Then
              p = 0#
              If IsLabelSymbolNew(B$, "ыс", "AS", Lang) Then
  
               If IsLabelSymbolNew(B$, "аяихлос", "DECIMAL", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                    p = CDec(p)
            ElseIf IsLabelSymbolNew(B$, "дипкос", "DOUBLE", Lang, , , , False) Then
                            If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CDbl(p)
            ElseIf IsLabelSymbolNew(B$, "апкос", "SINGLE", Lang, , , , False) Then
                        If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CSng(p)
            ElseIf IsLabelSymbolNew(B$, "коцийос", "BOOLEAN", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CBool(p)
            ElseIf IsLabelSymbolNew(B$, "лайяус", "LONG", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CLng(p)
            ElseIf IsLabelSymbolNew(B$, "айеяаиос", "INTEGER", Lang, , , , False) Then
                    If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CInt(p)
            ElseIf IsLabelSymbolNew(B$, "коцистийо", "CURRENCY", Lang, , , , False) Then
                If FastSymbol(B$, "=") Then If Not IsNumberD2(B$, p) Then missNumber: Exit Function
                p = CCur(p)
            Else
                If Not IsEnumAs(bstack, B$, p) Then
                    ExpectedEnumType
                    MyEr "No type found", "ДЕМ БЯчЙА ТЩПО"
                    Exit Function
                End If
            End If
     
    End If
    
    p = Int(p)
        globalvar w$, p, , VarStat, temphere$
        sss = Len(B$): ExecuteVar = 4: Exit Function
    Else
        NoValueForVar w$
        Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
End If
Exit Function
    

case5:
If AscW(w$) = 46 Then
               If Not expanddot(bstack, w$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
                Exec1 = 0: ExecuteVar = 8: Exit Function
               End If
End If
 If funid.Find(w$, i) Then
    If i > 0 Then funid.ItemCreator w$, -i
      End If
If VarStat Or NewStat Then

MakeArray bstack, w$, 5, B$, pppp, NewStat, VarStat

        sss = Len(B$): ExecuteVar = 4: Exit Function
End If
aheadstatusSkipParam B$, i
i = i + 1
If MaybeIsSymbol3lot(B$, b12345, i) Or i > Len(B$) Then
    If Mid$(B$, i, 2) = ":=" Then GoTo arr1111
    If Mid$(B$, i, 2) = "/=" Then GoTo arr1111
    If GetSub(w$ + ")", i) Then
        Exit Function
    Else
        bstack.tmpstr = ss$
        ExecuteVar = 2  ' GoTo autogosub
        Exit Function
    End If

End If
arr1111:
If neoGetArray(bstack, w$, pppp, , , , True) Then
againarray:
If pppp Is Nothing Then
    Exec1 = 0: ExecuteVar = 8
    Exit Function
End If
If Not pppp.Arr Then
If Not NeoGetArrayItem(pppp, bstack, w$, v, B$, , , , True, idx) Then GoTo errorarr
ElseIf FastSymbol(B$, ")") Then
'need to found an expression
If FastSymbol(B$, "=") Then
    If IsExp(bstack, B$, p) Then
        If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
             If usehandler.indirect >= 0 Then
             ' no copy..just a reference
                Set bstack.lastobj = var(usehandler.indirect)
             Else
                Set bstack.lastobj = usehandler.objref
    
             End If
             Set usehandler = Nothing
            If TypeOf bstack.lastobj Is mArray Then
                    Set pppp1 = bstack.lastobj
                     pppp1.CopyArray pppp
                     pppp.Final = False
             Else
                        GoTo NotArray1
             End If
        Else
        Set pppp1 = bstack.lastobj
         pppp1.CopyArray pppp
          pppp.Final = False
         
        End If
            Set bstack.lastobj = Nothing
            ExecuteVar = 7: Exit Function
            Else
            Set myobject = New mArray: myobject.PushDim (1): myobject.PushEnd
            myobject.SerialItem 0, 2, 9
            myobject.Arr = True
            If bstack.lastobj Is Nothing Then
                myobject.item(0) = p
            Else
                Set myobject.item(0) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
            myobject.CopyArray pppp
            ExecuteVar = 7: Exit Function
        End If
    Else
        SyntaxError
        
    End If
    Exec1 = 0: ExecuteVar = 8
    Exit Function
End If

ElseIf Not NeoGetArrayItem(pppp, bstack, w$, v, B$) Then
''MyEr "Error too", "кэХОР"
errorarr:
If LastErNum = -2 Then

Execute bstack, B$, True
Exec1 = 0: ExecuteVar = 8: Exit Function
Else
Exec1 = 0: ExecuteVar = 8
ExecuteVar = 1
Exit Function
End If
End If
'On Error Resume Next

If MaybeIsSymbol(B$, ":+-*/~|") Or v = -2 Then
here66678:
With pppp
If pppp.Final Then CantAssignValue: Exec1 = 0: ExecuteVar = 8: Exit Function

If MyIsObject(.item(v)) Then

If v = -2 Then

Set myobject = .item(v)

If myobject.HasParametersSet Then


If myobject.HasSet Then

    w$ = Left$(w$, Len(w$) - 1)
    Set myobject = bstack.soros
    Set bstack.Sorosref = New mStiva
    PushParamGeneral bstack, B$
 '   PushParamStraight bstack, b$
    If Not FastSymbol(B$, ")", True) Then
            Set bstack.Sorosref = myobject
            Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
    If FastSymbol(B$, "=") Then
            If IsExp(bstack, B$, p) Then
                If bstack.lastobj Is Nothing Then
                    bstack.soros.DataVal p
                Else
                    If TypeOf bstack.lastobj Is VarItem Then
                    bstack.soros.DataOptional
                    Else
                    bstack.soros.DataObj bstack.lastobj
                    End If
                    Set bstack.lastobj = Nothing
                End If
                NeoCall2 bstack, w$ + "." + ChrW(&H1FFF) + ":=()", ok
                Set bstack.Sorosref = myobject
                Set myobject = Nothing
                ExecuteVar = 7: Exit Function
            Else
                Set bstack.Sorosref = myobject
                 Set myobject = Nothing
                GoTo noexpression
            End If
    End If
    Set bstack.Sorosref = myobject
    SyntaxError
    Exec1 = 0: ExecuteVar = 8
    Exit Function
                               
Else
' ????
End If
 Else
a1297654:
  i = MyTrimL(B$)
       
       If lookTwoSame(B$, "/") Then
       ' error>>>
       Exec1 = 0: ExecuteVar = 7: Exit Function
       ElseIf MaybeIsSymbol(Mid$(B$, i + 1, 1), "/*-+=~^&|<>?") Then
            ss$ = Mid$(B$, i, 2)
            Mid$(B$, 1, i + 1) = space(i + 1)
        Else
            ss$ = Mid$(B$, i, 1)
            Mid$(B$, 1, i) = space(i)
        End If
        Set myobject = Nothing
If ss$ = "->" Then

If GetPointer(bstack, B$) Then
Set .item(v) = bstack.lastpointer
Set bstack.lastpointer = Nothing
Set bstack.lastobj = Nothing
ExecuteVar = 7: Exit Function

End If
ElseIf ss$ = ":=" Then
GoTo contassignhere
Else

If .item(v).IamApointer Then
If .item(v).link.IamFloatGroup Then
MyPush bstack, B$
Set bstack.lastobj = .item(v).link
Else
w$ = .item(v).lasthere + "." + .item(v).GroupName
Set bstack.lastobj = Nothing
Set bstack.lastpointer = Nothing
GoTo comeoper
End If
Else
MyPush bstack, B$
Set bstack.lastobj = .item(v)
End If

    ProcessOper bstack, myobject, ss$, (0), 1
        If Not bstack.lastobj Is Nothing Then
            If TypeOf bstack.lastobj Is Group Then
            If .item(v).IamApointer Then
            Set .item(v).LinkRef = bstack.lastobj
            Else
            Set .item(v) = bstack.lastobj
            End If
            Set bstack.lastobj = Nothing
            ExecuteVar = 7: Exit Function
            End If
        End If
End If
End If
Else
Set myobject = .item(v)
If TypeOf myobject Is Group Then GoTo a1297654
Set myobject = Nothing
End If
End If

AssignTypeNumeric sp, VarType(.item(v))
If IsOperator0(B$, "++", 2) Then
.item(v) = .itemnumeric(v) + 1
ExecuteVar = 7: Exit Function
ElseIf IsOperator0(B$, "--", 2) Then
.item(v) = .itemnumeric(v) - 1
ExecuteVar = 7: Exit Function
ElseIf FastSymbol(B$, "+=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
.item(v) = .itemnumeric(v) + p
ElseIf FastSymbol(B$, "-=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
.item(v) = .itemnumeric(v) - p
ElseIf FastSymbol(B$, "*=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
.item(v) = .itemnumeric(v) * p
ElseIf FastSymbol(B$, "/=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
If p = 0# Then
 DevZero
 Else
 .item(v) = .itemnumeric(v) / p
End If
ElseIf IsOperator0(B$, "-!", 2) Then
.item(v) = -.itemnumeric(v)
ExecuteVar = 7: Exit Function
ElseIf IsOperator0(B$, "~") Then
    Select Case VarType(.itemnumeric(v))
            Case vbBoolean
                .item(v) = Not CBool(.itemnumeric(v))
            Case vbInteger
                .item(v) = CInt(Not CBool(.itemnumeric(v)))
            Case vbLong
                .item(v) = CLng(Not CBool(.itemnumeric(v)))
            Case vbCurrency
                .item(v) = CCur(Not CBool(.itemnumeric(v)))
            Case vbDecimal
                .item(v) = CDec(Not CBool(.itemnumeric(v)))
            Case Else
                .item(v) = CDbl(Not CBool(.itemnumeric(v)))
        End Select
ExecuteVar = 7: Exit Function
ElseIf FastSymbol(B$, ":=", , 2) Then
' new on rev 20
contassignhere:
        If GetData(bstack, B$, myobject) Then
            FeedArray pppp, v, myobject
            ExecuteVar = 7
        Else
            Exec1 = 0
            ExecuteVar = 8
        End If
        Exit Function
ElseIf IsOperator0(B$, "|") Then
    If FastPureLabel(B$, ss$, , True) Then
        If Mid$(B$, 1, 1) = "#" Then ss$ = ss$ + "#": Mid$(B$, 1, 1) = " "
        If IsExp(bstack, B$, p) Then
            If Int(p) = 0 Then
                DevZero
                Exec1 = 0: ExecuteVar = 8
                Exit Function
            End If
            Select Case ss$
            Case "DIV", "диа"
                .item(v) = Fix(.item(v) / p)
            Case "DIV#", "диа#"
                If p < 0 Then
                    .item(v) = Int((.item(v) - Abs(.item(v) - Abs(p) * Int(.item(v) / Abs(p)))) / p)
                Else
                    .item(v) = Int(.item(v) / p)
                End If
            Case "MOD", "упок", "упокоипо"
                sp = .item(v) - Fix(.item(v) / p) * p
                If Abs(sp) >= Abs(p) Then sp = sp - sp
                .item(v) = sp
             Case "MOD#", "упок#", "упокоипо#"
                sp = Abs(.item(v) - Abs(p) * Int(.item(v) / Abs(p)))
                If Abs(sp) >= Abs(p) Then sp = sp - sp
                .item(v) = sp
            Case Else
                WrongOperator
            End Select
            
        Else
            GoTo noexpression
        End If
    Else
        WrongOperator
    End If
ElseIf FastSymbol(B$, "->", , 2) Then
    If Not GetPointer(bstack, B$) Then Exec1 = 0: ExecuteVar = 8: Exit Function
    If Typename(bstack.lastobj) = mgroup Then
        If Typename(.item(v)) <> mgroup Then
        
        If bstack.lastpointer Is Nothing Then
                Set .item(v) = bstack.lastobj
        Else
                Set .item(v) = bstack.lastpointer
        End If
        
        Else
        If .item(v).IamApointer Then
            If bstack.lastpointer Is Nothing Then
                MyEr "Expected pointer", "пЕЯъЛЕМА ДЕъЙТГ"
                   Exec1 = 0: ExecuteVar = 8: Exit Function
            Else
                Set .item(v) = bstack.lastpointer
            End If
        End If
        End If
        Set bstack.lastobj = Nothing
        Set bstack.lastpointer = Nothing
          ExecuteVar = 7: Exit Function
    End If
   Exec1 = 0: ExecuteVar = 8: Exit Function
Else
   Exec1 = 0: ExecuteVar = 8: Exit Function
End If



   

p = .itemnumeric(v)
AssignTypeNumeric p, VarType(sp)
.item(v) = MyRound(p, 28)

End With
ExecuteVar = 7: Exit Function

End If
If IsOperatorNoRemove(B$, ".") Then

    If pppp.ItemType(v) = mgroup Then
        If pppp.item(v).IamApointer Then
        
    
        
    If pppp.item(v).link.IamFloatGroup Then
               
             Mid$(B$, 1, 1) = ChrW(7)
   Exec1 = SpeedGroup(bstack, pppp, "", w$, B$, v)
                            Exit Function
    Else
                Set bstack.lastpointer = pppp.item(v)
                Mid$(B$, 1, 1) = Chr(0)
                        ExecuteVar = 9
                            Exit Function
    End If
    
    
        Else
        
       Mid$(B$, 1, 1) = ChrW(7)
    
        Exec1 = SpeedGroup(bstack, pppp, "", w$, B$, v)
        End If
        If Exec1 = 0 Then ExecuteVar = 8: Exit Function
        ExecuteVar = 7: Exit Function
    End If
ElseIf IsOperator(B$, "(") Then


    If pppp.ItemType(v) = myArray Then
        Set pppp = pppp.item(v)
        GoTo againarray
    ElseIf pppp.ItemType(v) = mgroup Then
again12568:
    Set myobject = bstack.soros
    Set bstack.Sorosref = New mStiva
    PushParamStraight bstack, B$
    If Not FastSymbol(B$, ")", True) Then
            Set bstack.Sorosref = myobject
            Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
    If Not FastSymbol(B$, "=", True) Then
        sss = 0
        ExecuteVar = 3: Exit Function
    End If
    If Not IsExp(bstack, B$, p) Then
        If LastErNum = -2 Then
        Execute bstack, B$, True
        Else
        MissNumExpr
        End If
        Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
   '
                        If bstack.lastobj Is Nothing Then
                    bstack.soros.DataVal p
                Else
                    bstack.soros.DataObj bstack.lastobj
                    Set bstack.lastobj = Nothing
                End If
            Exec1 = SpeedGroup(bstack, pppp, "@READ2", "", B$, v)

If Exec1 = 0 Then ExecuteVar = 8: Exit Function
    ExecuteVar = 7: Exit Function
    
    End If
ElseIf Not FastSymbol(B$, "=") Then
MissingSymbol "="
sss = 0
ExecuteVar = 3: Exit Function

End If
If Left$(B$, 1) = ">" Then
     If MyIsObject(pppp.item(v)) Then
     If TypeOf pppp.itemObject(v) Is Group Then
            If pppp.item(v).IamApointer Then
                            
            Set bstack.lastpointer = pppp.item(v)
            If bstack.lastpointer.link.IamFloatGroup Then
             Mid$(B$, 1, 1) = " "
             If MaybeIsSymbol3(B$, "=", i) Then
                Mid$(B$, i - 1, 2) = "  "
                If IsExp(bstack, B$, p) Then GoTo here12500
                Exec1 = 0: ExecuteVar = 8: Exit Function
            Else
                If FastSymbol(B$, "(") Then
                
      '          b$ = NLtrim(b$)
                
                    GoTo again12568
                   
            End If
            End If
            Mid$(B$, 1, 1) = ChrW(7)
            ExecuteVar = 10
            Else
            Mid$(B$, 1, 1) = " "
            
            If MaybeIsSymbol3(B$, "=", i) Then
            Mid$(B$, i - 1, 2) = "  "
            w$ = pppp.item(v).lasthere + "." + pppp.item(v).GroupName
            If GetVar(bstack, w$, v, True) Then GoTo assigngroup
            Else
            If FastSymbol(B$, "(") Then
            
            w$ = pppp.item(v).lasthere + "." + pppp.item(v).GroupName + "("
            If neoGetArray(bstack, w$, pppp, , True, , True) Then
        
            GoTo againarray
            End If
            Else
            Mid$(B$, 1, 1) = ChrW(0)
            End If
            
            
            End If
            ExecuteVar = 9
            End If
                Exit Function
                End If
        End If
     End If
     
     MyEr "Wrong use of => operator", "йАЙч ВЯчСГ ТОУ ТЕКЕСТч =>"
     Exec1 = 0: ExecuteVar = 8: Exit Function
ElseIf Not IsExp(bstack, B$, p) Then
If LastErNum = -2 Then
Execute bstack, B$, True
Else
MissNumExpr
End If
Exec1 = 0: ExecuteVar = 8: Exit Function
End If
again12569:
     If Not bstack.lastobj Is Nothing Then
     If Typename(bstack.lastobj) = mgroup Then
     If bstack.lastobj.IamApointer Then
     Set pppp.item(v) = bstack.lastobj
     Set bstack.lastobj = Nothing
     Set bstack.lastpointer = Nothing
     ExecuteVar = 7: Exit Function
     End If
     End If
     Set myobject = pppp.GroupRef
     If pppp.IHaveClass Then
   
            Set pppp.item(v) = bstack.lastobj
            
            Set pppp.item(v).LinkRef = myobject
            With pppp.item(v)
                 .HasStrValue = myobject.HasStrValue
                .HasValue = myobject.HasValue
                .HasSet = myobject.HasSet
                .HasParameters = myobject.HasParameters
                .HasParametersSet = myobject.HasParametersSet
                Set .SuperClassList = myobject.SuperClassList
                If .Events Is Nothing Then
                Set .Events = myobject.Events
                End If
                .highpriorityoper = myobject.highpriorityoper
                .HasUnary = myobject.HasUnary
                .HasRemove = myobject.HasRemove
                Set bstack.lastobj = Nothing
                .ToDelete = False
            End With
     Else
            If Typename(bstack.lastobj) = mHdlr Then
                          Set pppp.item(v) = bstack.lastobj
            Else
                   If Not bstack.lastobj Is Nothing Then
                          If TypeOf bstack.lastobj Is mArray Then
                                 If bstack.lastobj.Arr Then
                                         Set pppp.item(v) = CopyArray(bstack.lastobj)

                                 Else
  
   
                                            Set pppp.item(v) = bstack.lastobj
                                         
                                 End If
                          Else
                          
                                  
                               
                                  If TypeOf bstack.lastobj Is Group Then
                                  Set pppp.item(v) = Nothing
                                  bstack.lastobj.ToDelete = False
                                        Set pppp.item(v) = bstack.lastobj
                                      If Not myobject Is Nothing Then
                                       If pppp.item(v).LinkRef Is Nothing Then
                                            Set pppp.item(v).LinkRef = myobject
                                      End If
                                      End If
                                      Set bstack.lastobj = Nothing
                                      
                                  Else
                                  
                                  Set pppp.item(v) = bstack.lastobj
                                  End If
                                  
                          End If
                   Else
                  
                          Set pppp.item(v) = bstack.lastobj
                          If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                   End If
            End If
        End If
     
     Set bstack.lastobj = Nothing
     Else
     If pppp.Arr Then
     If pppp.ItemType(v) = mgroup Then
here12500:
    If pppp.item(v).IamApointer Then
      If pppp.item(v).link.HasSet Then GoTo here65654
     
     End If
      If pppp.item(v).HasSet Then
here65654:
        bstack.soros.PushVal p
            Exec1 = SpeedGroup(bstack, pppp, "@READ", w$, B$, v)
        Else
        If p = 0# Then
        pppp.item(v) = CLng(0)  ' release pointer
        Else
     GroupCantSetValue
     End If
        End If
     Else
        pppp.item(v) = p
     End If
     ElseIf Typename(pppp.GroupRef) = mProp Then
        Set myProp = pppp.GroupRef
        myProp.PushIndexes idx
        myProp.Value = p
        Set myProp = Nothing
     ElseIf pppp.ItemType(v) = mgroup Then
      If pppp.item(v).HasSet Then
        bstack.soros.PushVal p
            Exec1 = SpeedGroup(bstack, pppp, "@READ", w$, B$, v)
        Else
     GroupCantSetValue
        End If
    ElseIf pppp.ItemType(v) = mProp Then
        Set myProp = pppp.itemObject(v)
        myProp.PushIndexes idx
        myProp.Value = p
        Set myProp = Nothing
    ElseIf Not pppp.Arr Then
        NoAssignThere
     End If
     
     
    End If
Do While FastSymbol(B$, ",")
If pppp.UpperMonoLimit > v Then
    v = v + 1

    If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
    If Not bstack.lastobj Is Nothing Then
     Set myobject = pppp.GroupRef
     If pppp.IHaveClass Then
         Set pppp.item(v) = bstack.lastobj
            
            With pppp.item(v)
                 .HasStrValue = myobject.HasStrValue
                .HasValue = myobject.HasValue
                .HasSet = myobject.HasSet
                .HasParameters = myobject.HasParameters
                .HasParametersSet = myobject.HasParametersSet
                    Set .SuperClassList = myobject.SuperClassList
                Set .Events = myobject.Events
                .highpriorityoper = myobject.highpriorityoper
                .HasUnary = myobject.HasUnary
                .HasRemove = myobject.HasRemove
            End With
        
        
     Else
        Set pppp.item(v) = bstack.lastobj
    End If
   If Not myobject Is Nothing Then
    If pppp.ItemType(v) = mgroup Then Set pppp.item(v).LinkRef = myobject
   End If
    Set bstack.lastobj = Nothing
     Else
pppp.item(v) = p
End If
Else
Exit Do
End If
Loop
Else
If LastErNum <> 0 Then Exec1 = 0: ExecuteVar = 8: Exit Function
If GetSub(w$ + ")", i) Then
Else
bstack.tmpstr = ss$
'b$ = ss$ + b$
ExecuteVar = 2  ' GoTo autogosub
Exit Function
    
End If
End If
Exit Function
Case6:
If AscW(w$) = 46 Then
               If Not expanddot(bstack, w$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
                Exec1 = 0: ExecuteVar = 8: Exit Function
               End If
End If
If VarStat Or NewStat Then
 If strfunid.Find(w$, i) Then
    If i > 0 Then strfunid.ItemCreator w$, -i
      End If
MakeArray bstack, w$, 6, B$, pppp, NewStat, VarStat
 'If Not lookone(b$, ",") Then b$ = " :" + b$
        sss = Len(B$): ExecuteVar = 4: Exit Function
End If
If neoGetArray(bstack, w$, pppp) Then
    If Not pppp.Arr Then
If Not NeoGetArrayItem(pppp, bstack, w$, v, B$, , , , , idx) Then Exec1 = 0: ExecuteVar = 8: Exit Function
GoTo there12567
ElseIf FastSymbol(B$, ")") Then
    'need to found an expression - HEREHERE
        If FastSymbol(B$, "=") Then
            If IsStrExp(bstack, B$, w$) Then
                If Not bstack.lastobj Is Nothing Then
                    If TypeOf bstack.lastobj Is mHandler Then
                        Set usehandler = bstack.lastobj
                        
                        If TypeOf usehandler.objref Is mArray Then
                            Set pppp1 = usehandler.objref
                            pppp.Final = False
                            pppp1.CopyArray pppp
                            Set pppp1 = Nothing
                        Else
                        GoTo NotArray1
                        End If
                    ElseIf TypeOf bstack.lastobj Is mArray Then
                        Set pppp1 = bstack.lastobj
                        pppp1.CopyArray pppp
                        pppp.Final = False
                        Set pppp1 = Nothing
                    Else
                        GoTo NotArray1
                    End If
                    Set bstack.lastobj = Nothing
                    ExecuteVar = 7: Exit Function
                End If
            ElseIf IsExp(bstack, B$, p) Then
        If Not bstack.lastobj Is Nothing Then
        If TypeOf bstack.lastobj Is mHandler Then
            Set usehandler = bstack.lastobj
         If usehandler.indirect >= 0 Then
         Set bstack.lastobj = var(usehandler.indirect)
         Else
         Set bstack.lastobj = usehandler.objref
         End If
         Set usehandler = Nothing
        If TypeOf bstack.lastobj Is mArray Then
         bstack.lastobj.CopyArray pppp
         pppp.Final = False
         Else
         GoTo NotArray1
         End If
        Else
            bstack.lastobj.CopyArray pppp
        End If
            Set bstack.lastobj = Nothing
            ExecuteVar = 7: Exit Function
            Else
            Set myobject = New mArray: myobject.PushDim (1): myobject.PushEnd
            myobject.SerialItem 0, 2, 9
            myobject.Arr = True
            If bstack.lastobj Is Nothing Then
                myobject.item(0) = vbNullString
            Else
                Set myobject.item(0) = bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
            myobject.CopyArray pppp
            ExecuteVar = 7: Exit Function
        End If
    Else
                SyntaxError
            End If
            Exec1 = 0: ExecuteVar = 8
            Exit Function
        End If
  
        
        End If
If v = -2 Then GoTo checkpar
againstrarr:
If Not NeoGetArrayItem(pppp, bstack, w$, v, B$) Then Exec1 = 0: ExecuteVar = 8: Exit Function
'On Error Resume Next
' WHY BEFORE WAS : If pppp.itemtype(v) = myArray And Not pppp.Arr Then
there12567:
If pppp.Arr Then
If pppp.ItemType(v) = myArray Then
If FastSymbol(B$, "(") Then
Set pppp = pppp.item(v)
GoTo againstrarr
End If
End If
End If
If v = -2 Then
checkpar:
w$ = Left$(w$, Len(w$) - 1)
Set myobject = bstack.soros
Set bstack.Sorosref = New mStiva
PushParamGeneral bstack, B$
'PushParamStraight bstack, b$
    If Not FastSymbol(B$, ")", True) Then
            Set bstack.Sorosref = myobject
            Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
    If FastSymbol(B$, "=") Then
        If IsStrExp(bstack, B$, ss$) Then
       ' bstack.soros.MakeTopItemBack bstack.soros.Total - v + 1
                                If bstack.lastobj Is Nothing Then
                                    bstack.soros.DataStr ss$
                                Else
                                    If TypeOf bstack.lastobj Is VarItem Then
                                    bstack.soros.DataOptional
                                    Else
                                    bstack.soros.DataObj bstack.lastobj
                                    End If
                                    Set bstack.lastobj = Nothing
                                End If
                                
                                NeoCall2 bstack, Left$(w$, Len(w$) - 1) + "." + ChrW(&H1FFF) + ":=()", ok
                                Set bstack.Sorosref = myobject
                                Set myobject = Nothing
                                ExecuteVar = 7: Exit Function
                                
                                
                                End If
                                
                                
                                End If
                                Set bstack.Sorosref = myobject
                                Set myobject = Nothing
                                SyntaxError
                                Exec1 = 0: ExecuteVar = 8
                                Exit Function
ElseIf Not FastSymbol(B$, "=") Then
  If FastSymbol(B$, ":=", , 2) Then
  
       GoTo contassignhere
  
    ElseIf IsOperator(B$, "+=", 2) Then
    If pppp.IsStringItem(v) Then
    If Not IsStrExp(bstack, B$, ss$) Then Exec1 = 0: ExecuteVar = 8: Exit Function
    If bstack.lastobj Is Nothing Then
        pppp.ItemStr(v) = pppp.item(v) + ss$
    Else
        MyEr "Need a string", "вЯЕИэФОЛАИ щМА АКЖАЯИХЛГТИЙЭ"
        Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
    Else
            MyEr "Not a string item", "дЕМ щВЕИ АКЖАЯИХЛГТИЙЭ О ПъМАЙАР"
            Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
    ElseIf IsOperator(B$, "(") Then
        If pppp.ItemType(v) = myArray Then
            Set pppp = pppp.item(v)
            GoTo againstrarr
        Else ' only group here
   
            Set myobject = bstack.soros
            Set bstack.Sorosref = New mStiva
            PushParamStraight bstack, B$
            If Not FastSymbol(B$, ")", True) Then
                    Set bstack.Sorosref = myobject
                    Exec1 = 0: ExecuteVar = 8: Exit Function
            End If
            If Not FastSymbol(B$, "=", True) Then
                sss = 0
                ExecuteVar = 3: Exit Function
            End If
            If Not IsStrExp(bstack, B$, ss$) Then
                If LastErNum = -2 Then
                Execute bstack, B$, True
                Else
                MissNumExpr
                End If
                Exec1 = 0: ExecuteVar = 8: Exit Function
            End If
   '
            If bstack.lastobj Is Nothing Then
                bstack.soros.DataStr ss$
            Else
                bstack.soros.DataObj bstack.lastobj
                Set bstack.lastobj = Nothing
            End If
            Exec1 = SpeedGroup(bstack, pppp, "@READ2", "", B$, v)
            ExecuteVar = 7: Exit Function
        End If
   ElseIf FastSymbol(B$, "->", , 2) Then
    If Not GetPointer(bstack, B$) Then Exec1 = 0: ExecuteVar = 8: Exit Function
    With pppp
    If Typename(bstack.lastobj) = mgroup Then
        If Typename(.item(v)) <> mgroup Then
        
        If bstack.lastpointer Is Nothing Then
                Set .item(v) = bstack.lastobj
        Else
                Set .item(v) = bstack.lastpointer
        End If
        
        Else
        If .item(v).IamApointer Then
            If bstack.lastpointer Is Nothing Then
                MyEr "Expected pointer", "пЕЯъЛЕМА ДЕъЙТГ"
                   Exec1 = 0: ExecuteVar = 8: Exit Function
            Else
                Set .item(v) = bstack.lastpointer
            End If
        End If
        End If
        
        Set bstack.lastobj = Nothing
        Set bstack.lastpointer = Nothing
          ExecuteVar = 7: Exit Function
    End If
    End With
   Exec1 = 0: ExecuteVar = 8: Exit Function
   ElseIf FastSymbol(B$, "+=", , 2) Then
   If IsStrExp(bstack, B$, ss$) Then
    
          CheckVar pppp.item(v), ss$, True
    
        
  Exit Function
  Else
  Exec1 = 0: ExecuteVar = 8: Exit Function
  End If
    Else
        Exec1 = 0: ExecuteVar = 8: Exit Function
    End If
Else
    If Not IsStrExp(bstack, B$, ss$) Then Exec1 = 0: ExecuteVar = 8: Exit Function
    If Not MyIsObject(pppp.item(v)) Then
    If pppp.Arr Then
    If pppp.count = 0 Then

    pppp.GroupRef.Value = ss$
    ElseIf bstack.lastobj Is Nothing Then
        pppp.ItemStr(v) = ss$
    
    Else
    If Typename(bstack.lastobj) = myArray Then
    If bstack.lastobj.Arr Then
        Set pppp.item(v) = CopyArray(bstack.lastobj)
    Else
        Set pppp.item(v) = bstack.lastobj.GroupRef
    End If
    Else
  
        Set pppp.item(v) = bstack.lastobj
        End If
        Set bstack.lastobj = Nothing
        End If
        Else
        If v < 0 And v <> -2 Then
        NoAssignThere
        Else
        Set myProp = pppp.GroupRef
        myProp.PushIndexes idx
        myProp.Value = ss$
        End If
        End If
    ElseIf pppp.ItemType(v) = mgroup Then
        If pppp.item(v).HasSet Then
        bstack.soros.PushStr ss$
            Exec1 = SpeedGroup(bstack, pppp, "@READ", w$, B$, v)
        Else
        GroupCantSetValue
        End If
    ElseIf pppp.ItemType(v) = mProp Then
        Set myProp = pppp.itemObject(v)
        With myProp
            .PushIndexes idx
            .ValueStr = ss$
        End With
        Set myProp = Nothing
    Else
        CheckVar pppp.item(v), ss$
    End If
        Do While FastSymbol(B$, ",")
        If pppp.UpperMonoLimit > v Then
        v = v + 1
        If Not IsStrExp(bstack, B$, ss$) Then MissStringExpr: Exec1 = 0: ExecuteVar = 8: Exit Function
        
        If Not MyIsObject(pppp.item(v)) Then
          pppp.item(v) = ss$
          Else
                CheckVar pppp.item(v), ss$
        End If
        Else
        Exit Do
        End If
        Loop
End If
Else
Exec1 = 0: ExecuteVar = 8
End If
Exit Function
Case7:
If AscW(w$) = 46 Then
               If Not expanddot(bstack, w$) Then
               MyEr "too many dots", "ПОККщР ТЕКЕъЕР"
                Exec1 = 0: ExecuteVar = 8: Exit Function
               End If
End If
If VarStat Or NewStat Then
MakeArray bstack, w$, 7, B$, pppp, NewStat, VarStat
 'If Not MaybeIsSymbol(b$, ",") Then b$ = " :" + b$
        sss = Len(B$): ExecuteVar = 4: Exit Function
End If
If neoGetArray(bstack, w$, pppp) Then
    If FastSymbol(B$, ")") Then
    'need to found an expression
        If FastSymbol(B$, "=") Then
            If IsExp(bstack, B$, p) Then
                If Not bstack.lastobj Is Nothing Then
                    bstack.lastobj.CopyArray pppp
                    Set bstack.lastobj = Nothing
                    ExecuteVar = 7: Exit Function
                End If
            Else
                SyntaxError
            End If
            Exec1 = 0: ExecuteVar = 8
            Exit Function
        End If
        End If
againintarr:
If Not NeoGetArrayItem(pppp, bstack, w$, v, B$) Then Exec1 = 0: ExecuteVar = 8: Exit Function
'On Error Resume Next
If pppp.ItemType(v) = myArray And pppp.Arr Then
If FastSymbol(B$, "(") Then
Set pppp = pppp.item(v)
GoTo againintarr
End If
End If
If lookTwoSame(B$, "/") Then
Exec1 = 0: ExecuteVar = 8: Exit Function
ElseIf MaybeIsSymbol(B$, "+-*/~|") Then
On Error Resume Next
With pppp
If IsOperator0(B$, "++", 2) Then
.item(v) = .itemnumeric(v) + 1
ElseIf IsOperator0(B$, "--", 2) Then
.item(v) = .itemnumeric(v) - 1
ElseIf FastSymbol(B$, "+=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
.item(v) = .itemnumeric(v) + MyRound(p)
ElseIf FastSymbol(B$, "-=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
.item(v) = .itemnumeric(v) - MyRound(p)
ElseIf FastSymbol(B$, "*=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
.item(v) = MyRound(.itemnumeric(v) * MyRound(p))
ElseIf FastSymbol(B$, "/=", , 2) Then
If Not IsExp(bstack, B$, p) Then Exec1 = 0: ExecuteVar = 8: Exit Function
If MyRound(p) = 0 Then
 DevZero
 Else
 .item(v) = MyRound(.itemnumeric(v) / MyRound(p))
End If
ElseIf IsOperator0(B$, "-!", 2) Then
.item(v) = -.itemnumeric(v)
ElseIf IsOperator0(B$, "~") Then
        Select Case VarType(.itemnumeric(v))
            Case vbBoolean
                .item(v) = Not CBool(.itemnumeric(v))
            Case vbInteger
                .item(v) = CInt(Not CBool(.itemnumeric(v)))
            Case vbLong
                .item(v) = CLng(Not CBool(.itemnumeric(v)))
            Case vbCurrency
                .item(v) = CCur(Not CBool(.itemnumeric(v)))
            Case vbDecimal
                .item(v) = CDec(Not CBool(.itemnumeric(v)))
            Case Else
                .item(v) = CDbl(Not CBool(.itemnumeric(v)))
        End Select
ElseIf IsOperator0(B$, "|") Then
    If FastPureLabel(B$, ss$, , True) Then
        If Mid$(B$, 1, 1) = "#" Then ss$ = ss$ + "#": Mid$(B$, 1, 1) = " "
        If IsExp(bstack, B$, p) Then
            If Int(p) = 0 Then
                DevZero
                Exec1 = 0: ExecuteVar = 8
                Exit Function
            End If
            Select Case ss$
            Case "DIV", "диа"
             .item(v) = Fix(.item(v) / p)
            Case "DIV#", "диа#"
                If p < 0 Then
                    .item(v) = Int((.item(v) - Abs(.item(v) - Abs(p) * Int(.item(v) / Abs(p)))) / p)
                Else
                    .item(v) = Int(.item(v) / p)
                End If
            Case "MOD", "упок", "упокоипо"
                sp = .item(v) - Fix(.item(v) / p) * p
                If Abs(sp) >= Abs(p) Then sp = sp - sp
                .item(v) = sp
            Case "MOD#", "упок#", "упокоипо#"
                sp = Abs(.item(v) - Abs(p) * Int(.item(v) / Abs(p)))
                If Abs(sp) >= Abs(p) Then sp = sp - sp
                .item(v) = sp
            Case Else
                WrongOperator
            End Select
            .item(v) = CInt(.item(v))
        Else
            GoTo noexpression
        End If
    Else
      WrongOperator
    End If
Else
      WrongOperator
End If
End With
On Error GoTo 0
ExecuteVar = 7: Exit Function
End If
If Not FastSymbol(B$, "=") Then
  If FastSymbol(B$, ":=", , 2) Then
  
    GoTo contassignhere
End If
Exec1 = 0: ExecuteVar = 8: Exit Function
End If
If Not IsExp(bstack, B$, p) Then MissNumExpr: Exec1 = 0: ExecuteVar = 8: Exit Function
If Not bstack.lastobj Is Nothing Then
    If TypeOf bstack.lastobj Is mArray Then
                                 If bstack.lastobj.Arr Then
                                         Set pppp.item(v) = CopyArray(bstack.lastobj)

                                 Else
  
   
                                            Set pppp.item(v) = bstack.lastobj
                                            If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                                 End If
                          Else
                          
                                  Set pppp.item(v) = bstack.lastobj
                                  If TypeOf bstack.lastobj Is Group Then Set pppp.item(v).LinkRef = myobject
                          End If
Else
p = MyRound(p)
If Err.Number > 0 Then Exec1 = 0: ExecuteVar = 8: Exit Function
pppp.item(v) = p
Do While FastSymbol(B$, ",")
If pppp.UpperMonoLimit > v Then
v = v + 1
If Not IsExp(bstack, B$, p) Then MissNumExpr: Exec1 = 0: ExecuteVar = 8: Exit Function
If Not bstack.lastobj Is Nothing Then
    MissNumExpr
    Set bstack.lastobj = Nothing
    Exec1 = 0: ExecuteVar = 8
Exit Function
End If
pppp.item(v) = MyRound(p)
Else
Exit Do
End If
Loop
End If
Else
Exec1 = 0: ExecuteVar = 8: Exit Function
End If
        Exit Function
LONGERR:
    If Err.Number = 6 Then
            Exec1 = 0: ExecuteVar = 8
            OverflowLong lasttype
    ElseIf Err.Number = 450 Then
            Exec1 = 0: ExecuteVar = 8
            WrongOperator
            End If

Case2:
End Function

Sub CopyPointerRef(basestack As basetask, thisobj As Object)
            Dim ohere$, w2 As Long
                            
                                    ohere$ = here$
                                        here$ = thisobj.lasthere
                                        If GetVar(basestack, thisobj.GroupName, w2, , , True) Then
                                        
                                        CopyGroup2 var(w2), basestack
                                        End If
                                    here$ = ohere$
End Sub
Sub CallClear(bstack As basetask, what$, z1 As Variant, Optional MinusOne As Long = 0)
Dim myobject As Object, ok As Boolean, z As Group

Set z = z1

   If z.IamApointer Then
   ' compiled has minus one reference ??
   'MsgBox z.refcount1 - MinusOne
   If z.refcount1 - MinusOne > 1 Then Exit Sub
   If z.link Is Nothing Then
   
                    ElseIf z.link.IamFloatGroup Then
                    If MinusOne < 0 Then
                    If z.LinkGroup.refcount1 - 1 = 0 Then Exit Sub
                    Else
                    If z.LinkGroup.refcount1 = 0 Then Exit Sub
                    End If
                        If z.LinkGroup.HasRemove Then
                            Set bstack.lastobj = z.link
                             z.link.ToDelete = True
                             ProcessOper bstack, myobject, "_%", (0), 1, True
                        End If
                        GoTo conthere
                    End If
                
                ElseIf z.IamFloatGroup Then
                Set bstack.lastobj = z
                z.ToDelete = True
                ProcessOper bstack, myobject, "_%", (0), 1
                
                 Set bstack.lastobj = Nothing
                Else
                
                Set myobject = bstack.soros
                Set bstack.Sorosref = New mStiva
                    NeoCall2 bstack, what$ + "." + ChrW(&H1FFF) + "_%()", ok
                     Set bstack.Sorosref = myobject
                 Set myobject = Nothing
                 End If
conthere:
End Sub
Sub SwapStrings(a$, B$)
Dim i As Long, j As Long
GetMem4 VarPtr(a$), i
GetMem4 VarPtr(B$), j
PutMem4 VarPtr(a$), j
PutMem4 VarPtr(B$), i
End Sub

Function FastPureLabel(B$, a$, Optional Pos As Long = 1, Optional convert As Boolean, Optional retdot As Boolean, Optional countdot As Long, Optional trimit As Boolean = True, Optional gr As Boolean) As Long
Dim i&, l As Long, one As Boolean, convat As Boolean, nospace As Boolean, pres As Long
Dim p2 As Long, p1 As Integer, p4 As Long, counter As Long
    a$ = vbNullString
    countdot = 0
    gr = False
    l = Len(B$): If l = 0 Then Exit Function
    If Pos > l Then Exit Function
    p2 = StrPtr(B$) + Pos * 2 - 2: l = l - 1
    p4 = p2 + l * 2
    For i = p2 To p4 Step 2
    GetMem2 i, p1
    Select Case p1
      Case 32, 160, 7, 9
        If nospace Then pres = 0: GoTo exithere
        If counter = 0 Then
            Pos = Pos + 1
        Else
            Exit Function
        End If
      Case Else
      Select Case p1
        Case 38
            Pos = Pos + 1
            FastPureLabel = 2
             GoTo exithere
        Case 46
            pres = 0
            countdot = countdot + 1
            If retdot Then counter = counter + 1
            If Not retdot Then Pos = Pos + 1
            nospace = True

        Case 64
            FastPureLabel = 0
            If retdot Then
            pres = Pos + 1
            counter = counter + 1
            Else
            If countdot > 0 Then pres = 1
             Pos = Pos + 1
            End If
            convat = True
            nospace = True
        Case 65 To 91, 93 To 122, Is > 191
            counter = counter + 1
            If convert Then
                If p1 > 901 And p1 < 975 Then gr = True
            End If
            GoTo aName
        Case Else
            GoTo TrimThis
        End Select
    End Select
    Next i
    Pos = Len(B$) + 1
    Exit Function
TrimThis:
    'If pres = 0 Then
    If countdot > 0 And FastPureLabel = 1 Then
        
        a$ = String$(countdot, ".")
    ElseIf pres = 1 Then
        Pos = Pos - 1
    End If
    GoTo exithere
aName:
    If retdot Then
        If pres = 0 Then countdot = counter - 1
    End If
    p2 = i + 2
    FastPureLabel = 1
    For i = p2 To p4 Step 2
        GetMem2 i, p1
        Select Case p1
            Case 36 ' 3 or 6
                If one Then Exit For
                FastPureLabel = 3
                counter = counter + 1
                one = True
            Case 37  ' 4 or 7
                If one Then Exit For
                FastPureLabel = 4
                counter = counter + 1
                one = True
            Case 40 ' add 3
                If i + 4 <= p4 Then
                    GetMem2 i + 2, p1
                    If p1 = 41 Then
                        GetMem2 i + 4, p1
                        If p1 = 64 Then
                            convat = True
                            If FastPureLabel = 1 Then
                                counter = counter + 4
                                i = i + 6
                                GoTo conthere
                            Else
                                counter = counter + 3
                                l = i + 6
                                For l = l To p4 Step 2
                                    GetMem2 l, p1
                                    If p1 = 64 Then counter = counter + 1 Else Exit For
                                Next l
                                Exit For
                            End If
                        End If
                    End If
                End If
                If FastPureLabel = 1 Then
                    FastPureLabel = 5
                Else
                    FastPureLabel = FastPureLabel + 3
                End If
                counter = counter + 1
                Exit For
conthere:
            Case 902 To 976
                If one Then Exit For
                If Not gr And convert Then gr = True
                counter = counter + 1
            Case 64
                convat = True
                If FastPureLabel = 3 Then
                    counter = counter + 1
                    GetMem2 i + 2, p1
                    Exit For
                End If
                If one Then Exit For
                counter = counter + 1
            Case 46, 48 To 57, 65 To 91, 93 To 122, Is > 191, Is < 0
                If one Then Exit For
                counter = counter + 1
            Case Else
                Exit For
        End Select
    Next i
    If convat Then
        If convert Then
            If gr Then
                a$ = myUcase(Replace$(Mid$(B$, Pos, counter), "@", "."), gr)
            Else
                a$ = UCase(Replace$(Mid$(B$, Pos, counter), "@", "."))
            End If
        Else
            a$ = Replace$(Mid$(B$, Pos, counter), "@", ".")
        End If
    ElseIf convert Then
        If gr Then
            a$ = myUcase(Mid$(B$, Pos, counter), gr)
        Else
            a$ = UCase(Mid$(B$, Pos, counter))
        End If
    Else
        a$ = Mid$(B$, Pos, counter)
    End If
    If retdot Then If pres > 0 Then Mid$(a$, pres - Pos, 1) = "@"
    pres = 0
exithere:
    If trimit Then
        B$ = Mid$(B$, Pos + counter)
        If pres > 0 Then Mid$(B$, 1, 1) = "."
        Pos = 1
    Else
        Pos = Pos + counter
    End If
End Function
Public Sub aheadstatusANY(a$, Pos As Long)
Dim pos2 As Long
If Len(a$) = 0 Then Exit Sub
Dim v1 As Integer
If Pos = 0 Then Pos = 1
Do While Pos <= Len(a$)
    v1 = AscW(Mid$(a$, Pos, 1))
    If Not (v1 > 0 And v1 < 32) Then
    If v1 = 34 Then
        Pos = Pos + 1
        Do While Pos <= Len(a$)
            v1 = AscW(Mid$(a$, Pos, 1))
            If v1 = 34 Then Exit Do
            If v1 > 0 And v1 < 32 And Not v1 = 9 Then Exit Do
            Pos = Pos + 1
        Loop
    ElseIf v1 = 40 Then
again22:
      Pos = Pos + 1
        If Not BlockParam2(a$, Pos) Then Exit Do
        If Mid$(a$, Pos + 1, 1) = "#" Then
            Pos = Pos + 1
            GoTo conthere
        ElseIf Mid$(a$, Pos + 1, 1) = "(" Then
            Pos = Pos + 1: GoTo again22
        End If
    ElseIf v1 = 123 Then
        If Pos <= Len(a$) Then
            Pos = blockLen2(a$, Pos + 1)
            If Pos = 0 Then Pos = Len(a$): Exit Do
        End If
    Else
        Select Case v1
        Case Is < 0
        Case 41, 125, Is < 32, 39, 92
        Exit Do
        End Select
        End If
    Else
        If v1 <> 8 And v1 <> 9 Then Exit Do
    End If
        Pos = Pos + 1
        
  
conthere:
  
Loop

End Sub
Function Funcweak(basestack As basetask, s$, Optional w As Long, Optional lastname As String) As String
' no validation of names
' check for "dot"
Dim ww$, original$, s1$, ww1$, p As Variant, w1 As Long
again:
w = IsLabel(basestack, s$, lastname)
ww$ = lastname$
ww1$ = ww$
If w >= 5 Then
s1$ = "&" + ww$ + ")"
w1 = IsLabel(basestack, s1$, ww$)
If w1 = 2 Then
' IT IS A FUNCTION
 ww1$ = ww1$ + ")"
GetSubFullName ww1$, ww$
If FastSymbol(s$, ")") Then
If here$ = vbNullString Then
Funcweak = ww1$
Else
Funcweak = here$ + "." + ww1$
End If
End If
ElseIf w1 = 0 Then
If ISSTRINGA(s1$, ww$) Then
If FastSymbol(s$, ")") Then
Funcweak = ww$
Else
' check parameters
'ww$ = ww$ + "("
again12:
Do

If IsExp(basestack, s$, p) Then
ww$ = ww$ + CStr(p)
ElseIf IsStrExp(basestack, s$, ww1$) Then
ww$ = ww$ + Chr$(34) + ww1$ + Chr$(34)
End If

If Not FastSymbol(s$, ",") Then Exit Do
ww$ = ww$ + ","
Loop
If FastSymbol(s$, ")") Then ww$ = ww$ + ")"
    If FastSymbol(s$, ".") Then ' ............
        If AscW(s$) > 64 Then
            If FastPureLabel(s$, ww1$) > 3 Then
            ww$ = ww$ + "." + ww1$
            GoTo again12
            Else
             ww$ = ww$ + "." + ww1$
            End If
        End If
    
    End If

Funcweak = ww$
End If
End If
End If
Else

s1$ = "&" + ww$
If IsLabel(basestack, s1$, ww1$) = 0 Then

If s1$ = vbNullString Then

GetSubFullName ww$, ww1$
Funcweak = ww1$
Else

If ISSTRINGA(s1$, ww1$) Then
If FastSymbol(s$, ".") Then

If Right$(ww1$, 1) = "$" Then
If IsStrExp(basestack, ww1$, ww$) Then
s$ = ww$ + "." + s$
GoTo again
End If
End If
End If
Funcweak = ww1$
End If
End If
End If
End If

End Function
Function RevisionPrint(basestack As basetask, rest1$, xa As Long, Lang As Long) As Boolean
Dim Scr As Object, oldcol As Long, oldFTEXT As Long, oldFTXT As String, oldpen As Long
Dim par As Boolean, i As Long, f As Long, p As Variant, w4 As Boolean, pn&, s$, dlen As Long
Dim o As Long, w3 As Long, x1 As Long, y1 As Long, X As Double, ColOffset As Long
Dim work As Boolean, work2 As Long, skiplast As Boolean, ss$, ls As Long, myobject As Object, counter As Long, Counterend As Long, countDir As Long
Dim bck$, clearline As Boolean, ihavecoma As Boolean, isboolean As Boolean, usehandler As mHandler
Set Scr = basestack.Owner
Dim rest$, where As Long, Final As Boolean

w3 = -1
Dim basketcode As Long, prive As basket
basketcode = GetCode(Scr)
prive = players(basketcode)
With prive
    
If .MAXXGRAPH = 0 Then

MyEr "No form to print", "ДЕМ УПэЯВЕИ ЖЭЯЛА ЦИА ЕЙТЩПЫСГ": Exit Function
End If
PlaceBasketPrive Scr, prive
Scr.FontTransparent = True
On Error GoTo 0
Dim opn&
where = 1
aheadstatusANY rest1$, where
If where > 1 Then
rest$ = Left$(rest1$, where - 1)
Else
.lastprint = False
par = True
GoTo JUMPHERE
End If



par = True
If MaybeIsSymbol3(rest$, "#", f) Then
   If Mid$(rest$, f + 1, 6) Like "[0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f]" Then
   
   Else
  Mid$(rest$, 1, f) = space$(f)
        If IsExp(basestack, rest$, p, , True) Then
        If p < 0 Then
        If p < -1 Then
        
                     .lastprint = False
                     par = False
        End If
        f = p
                     If Not FastSymbol(rest$, ",") Then
                     s$ = vbNullString
                     pn& = 2
                     GoTo isAstring
                     End If
        Else
                     f = CLng(p)
                     If Fkind(f) = FnoUse Or Fkind(f) = Finput Or Fkind(f) = Frandom Then MyEr "Wrong File Handler", "кэХОР вЕИЯИСТчР аЯВЕъОУ": RevisionPrint = False: GoTo exit2
                     Dim clearprive As basket
                     prive = clearprive
                     .lastprint = False
                     par = False
                     If Not FastSymbol(rest$, ",") Then
                     s$ = vbNullString
                     pn& = 2
                     GoTo isAstring
                     End If
                     
                     
            End If
             
       Else
       MyEr "expected file number", "ПЕЯъЛЕМА АЯИХЛЭ АЯВЕъОУ"
       End If
    End If
Else
ss$ = Left$(rest$, MyTrimL(rest$) + 5)
ls = Len(ss$)
If Not IsLabelSYMB3(ss$, s$) Then
                    f = 0
                    
Else
Select Case Lang
Case 1
If Len(s$) > 3 Then
If InStr("BOUP", UCase(Left$(s$, 1))) > 0 Then

Select Case UCase(s$)
        Case "BACK"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 4
        Case "OVER"
        f = 1
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        Case "UNDER"
        f = 2
         Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        Case "PART"
        f = 3
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        Case Else
        ''rest$ = s$ + rest$
        f = 0
        End Select
        Else
        f = 0
        End If
        Else
        f = 0
End If
Case 0, 2
If Len(s$) > 2 Then
If InStr("жпул", myUcase(Left$(s$, 1))) > 0 Then
        Select Case myUcase(s$, True)
        Case "жомто"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 4
        Case "памы"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 1
        Case "упо"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 2
        Case "леяос"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 3
        Case Else
        f = 0
        End Select
        Else
        f = 0
        End If
        Else
        f = 0
End If
Case -1   '' this is for ?
If Len(s$) > 2 Then
If InStr("BOUPжпул", myUcase(Left$(s$, 1))) > 0 Then
Select Case myUcase(s$)
        Case "жомто", "BACK"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 4
        Case "памы", "OVER"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 1
        Case "упо", "UNDER"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 2
        Case "леяос", "PART"
        Mid$(rest$, 1, ls - Len(ss$)) = space$(ls - Len(ss$))
        f = 3
        Case Else
        f = 0
        End Select
        Else
        f = 0
        End If
        Else
        f = 0
        End If
        Lang = 0
        End Select
        
        If f > 0 And .lastprint Then
        .lastprint = False
        
        GetXYb Scr, prive, x1&, y1&
        If f <> 2 Then If x1& > 0 Or y1& >= .mx Then crNew basestack, prive
        End If
If f = 1 Then  ''
    work = True
    oldcol = .Column
    If TypeOf Scr Is MetaDc Then
        Scr.Line2 0&, .currow * .Yt, .mx * .Xt, (.currow) * .Yt + .Yt - 2 * DYP, .Paper, True
    Else
        Scr.Line (0&, .currow * .Yt)-((.mx - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 2 * DYP), .Paper, BF
    End If
    LCTbasket Scr, prive, .currow, 0&
    .Column = .mx - 1
    w4 = True
    oldFTEXT = .FTEXT
    oldFTXT = .FTXT
    oldpen = .mypen
    pn& = 2
    .FTEXT = 4
ElseIf f = 2 Then
    work = True
    oldcol = .Column
    If TypeOf Scr Is MetaDc Then
           Scr.Line2 0&, .currow * .Yt + .Yt - DYP, .mx * .Xt, (.currow) * .Yt + .Yt - DYP, .mypen, True
    Else
         Scr.Line (0&, .currow * .Yt + .Yt - DYP)-((.mx - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - DYP), .mypen, BF
    
    End If
    crNew basestack, prive
    LCTbasketCur Scr, prive
    w4 = True
    oldFTEXT = .FTEXT
    oldFTXT = .FTXT
    oldpen = .mypen
    .FTEXT = 4
    pn& = 2
ElseIf f = 3 Then
' we print in a line with lost chars, so controling the start of printing
' we can render text, like from a view port Some columns are hidden because they went out of screen;
work = True
oldcol = .Column
LCTbasket Scr, prive, .currow, 0&
w4 = True
oldFTEXT = .FTEXT
oldFTXT = .FTXT
.FTEXT = 4
oldpen = .mypen
ElseIf f = 4 Then
    work = True
    clearline = True
    ' LCTbasketCur scr, prive
    If .curpos > 0 Then
    crNew basestack, prive
    LCTbasketCur Scr, prive
    End If
    If TypeOf Scr Is MetaDc Then
        Scr.Line2 0&, .currow * .Yt, (.mx - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP, .Paper, True
    Else
    Scr.Line (0&, .currow * .Yt)-((.mx - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP), .Paper, BF
    End If
      LCTbasketCur Scr, prive
    pn& = 2
End If

f = 0
End If

End If
If w4 Then pn& = 2 Else pn& = 0

s$ = vbNullString
If par Then
    If .FTEXT > 3 And .curpos >= .mx And Not w4 Then
    crNew basestack, prive
    w3 = 0
End If
End If
If par Then
If FastSymbol(rest$, ";") Then

            If .lastprint Then
            .lastprint = False
            LCTbasketCur Scr, prive
            crNew basestack, prive
            End If
         
ElseIf .lastprint Then
If .FTEXT > 3 Then pn& = 7: GoTo newntrance

End If
End If


Do
             If Final Then
             If myobject Is Nothing Then GoTo there1
            End If
   If FastSymbol(rest$, "~(", , 2) Then ' means combine
        ' get the color and then look for @( parameters)
        w3 = -1
    If par Then  ' par is false when we print in files, we can't use color;
   
                 If IsExp(basestack, rest$, p, , True) Then .mypen = CLng(mycolor(p))
                 TextColor Scr, .mypen
                 
                     If FastSymbol(rest$, ",") Then
                     
                                If w4 Or Not work Then
                                  If prive.lastprint Then
                                   prive.lastprint = False
                                   GetXYb Scr, prive, .curpos, .currow
                                                   If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                 If w4 Then LCTbasketCur Scr, prive
                       End If
                                  End If
                               
                              LCTbasketCur Scr, prive
                             
                                Else
                                 If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                 If w4 Then LCTbasketCur Scr, prive
                       End If
                               '' LCTbasketCur scr, prive
                                End If
                                
                                
'                                         GetXYb scr, prive, .curpos, .currow
                   ''  LCTbasketCur scr, prive
                x1 = .Column + .curpos + 1
                y1 = .currow + 1
                
                                pn& = 99
                             GoTo pthere   ' background and border and or images
            
            
                 End If
                         If Not FastSymbol(rest$, ")") Then RevisionPrint = False: Set Scr = Nothing: GoTo exit2
                         pn& = 99
    End If
    ElseIf FastSymbol(rest$, "@(", , 2) Then
    clearline = False
    w3 = -1
               'If Not par Then RevisionPrint = False: Set scr = Nothing: Exit Function
                If IsExp(basestack, rest$, p, , True) Then

                If par Then .curpos = CLng(Fix(p))
                End If
                
                If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, , True) Then
                If CLng(Fix(p)) >= .my Then
                If par Then .currow = .my - 1
                Else
                If par Then .currow = CLng(Fix(p))
                End If
                End If
                End If

                If FastSymbol(rest$, ",") Then
                
                If IsExp(basestack, rest$, p, , True) Then x1 = CLng(Fix(p))
                Else
                x1 = 1
                End If
                
                If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, , True) Then y1 = CLng(Fix(p))
                Else
                y1 = 1
                End If

                If FastSymbol(rest$, ",") Then
             '   On Error Resume Next
pthere:
                   
                If par Then LCTbasketCur Scr, prive
                If IsStrExp(basestack, rest$, s$) Then
                p = 0
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, p, , True) Then
                            If p <> 0 Then p = True
                        Else
                        p = True
                        End If
                    End If
             
                    x1 = Abs(x1 - .curpos)
                    y1 = Abs(y1 - .currow)
                    
                    If par Then BoxImage Scr, prive, x1, y1, s$, 0, (p)
                    'If P <> 0 Then .currow = y1 + .currow
                ElseIf IsExp(basestack, rest$, p, , True) Then
         
                    If par Then BoxColorNew Scr, prive, x1 - 1, y1 - 1, (p)
                    If FastSymbol(rest$, ",") Then
                        If IsExp(basestack, rest$, X, , True) Then
                            If par Then BoxBigNew Scr, prive, x1 - 1, y1 - 1, (X)
                            
                            
                            
                        Else
                            RevisionPrint = False
                            Set Scr = Nothing
                            GoTo exit2
                        End If
                    End If
                Else
                    RevisionPrint = False
                    Set Scr = Nothing
                    GoTo exit2
                
                End If

                End If
             If par Then LCTbasket Scr, prive, .currow, .curpos
                
        If Not FastSymbol(rest$, ")") Then
        RevisionPrint = False
        Set Scr = Nothing
        GoTo exit2
        End If
        work = False
        pn& = 99
        ElseIf LastErNum <> 0 Then
      RevisionPrint = LastErNum = -2
      Set Scr = Nothing
    GoTo exit2
    
    ElseIf FastSymbol(rest$, "$(", , 2) Then
conthere:
w3 = -1
        If IsExp(basestack, rest$, p, , True) Then
        If Not par Then p = 0
            .FTEXT = Abs(p) Mod 10
            ' 0 STANDARD LEFT chars before typed beyond the line are directed to the next line
            ' 1  RIGHT
            ' 2 CENTER
            ' 3 LEFT
            ' 4 LEFT PROP....expand to next .Column......
            ' 5 RIGHT PROP
            ' 6 CENTER PROP
            ' 7 LEFT PROP
            ' 8 left and right justify
            ' 9 New in version 8 Left justify(like 7) without word wrap (cut excess)
        ElseIf IsStrExp(basestack, rest$, s$) Then
            .FTXT = s$
        End If
        
        
        If FastSymbol(rest$, ",") Then
                If IsExp(basestack, rest$, p, , True) Then
                    If par Then
                        p = p - 1
                        If Abs(Int(p Mod (.mx + 1))) < 2 Then
                            MyEr ".Column minimum width is 4 chars", "лИЙЯЭТЕЯО ЛщЦЕХОР СТчКГР ЕъМАИ ОИ ТщССЕЯИР ВАЯАЙТчЯЕР"
                        Else
                            If w4 Or Not work Then
                                LCTbasketCur Scr, prive
                            Else
                                GetXYb Scr, prive, .curpos, .currow
                            End If
                            If w4 Then ColOffset = .curpos    ' now we have columns from offset ColOffset
                                .Column = Abs(Int(p Mod (.mx + 1)))
                            End If
                    End If
                    
                Else
                    RevisionPrint = False
                    Set Scr = Nothing
                    GoTo exit2
                End If
         End If
      
            If Not FastSymbol(rest$, ")") Then
            RevisionPrint = False
            Set Scr = Nothing
            GoTo exit2
            End If
        
        
        If par Then pn& = 99
        ElseIf LastErNum <> 0 Then
       RevisionPrint = LastErNum <> -2
       Set Scr = Nothing
    GoTo exit2
    ElseIf Not myobject Is Nothing Then
takeone:
    '' for arrays only
    If countDir >= 0 Then
    
    If counter = myobject.count Or (counter > Counterend And Counterend > -1) Or countDir = 0 Then
        Set myobject = Nothing
              SwapStrings rest$, bck$
            '  rest$ = bck$
            ' bck$ = vbNullString
        GoTo taketwo
    End If
Else
        If counter < 0 Or (counter < Counterend And Counterend > -1) Then
        Set myobject = Nothing
            SwapStrings rest$, bck$
             ' rest$ = bck$
            ' bck$ = vbNullString
        GoTo taketwo
    End If
    End If
    
    myobject.index = counter
    If myobject.IsEmpty Then
        s$ = " "
        counter = counter + countDir
        GoTo isAstring
    Else
            If Not IsNumericPrint(myobject.Value) Then
                If myobject.IsObj Then
                    If myobject.IsEnum(p) Then
                    counter = counter + countDir
                    GoTo isanumber
                    Else
                    s$ = " "
                    End If
                Else
                    s$ = myobject.Value
                End If

                
                counter = counter + countDir
                GoTo isAstring
            Else
                If TypeOf myobject Is Enumeration Then
                p = myobject.Value
                Else
                On Error Resume Next
                If Not myobject.IsEnum(p) Then
                p = myobject.Value
                isboolean = VarType(p) = vbBoolean
                
                End If
                If Err.Number > 0 Then p = myobject.Value
                End If
                counter = counter + countDir
                GoTo isanumber
            End If
    End If

    
    ElseIf IsExp(basestack, rest$, p) Then
            If Not basestack.lastobj Is Nothing Then
                
                If Typename(basestack.lastobj) = myArray Then
                Set myobject = basestack.lastobj
                Set basestack.lastobj = Nothing
                Counterend = -1
                counter = 0
                countDir = 1
                bck$ = vbNullString
                SwapStrings rest$, bck$
                'bck$ = rest$
                'rest$ = vbNullString
                GoTo takeone
                ElseIf Typename(basestack.lastobj) = mHdlr Then
                    Set myobject = basestack.lastobj
                    Set usehandler = myobject
                    Set basestack.lastobj = Nothing
                    With myobject
                    If usehandler.UseIterator Then
                        If TypeOf usehandler.objref Is Enumeration Then
                        p = usehandler.objref.Value
                        Set usehandler = Nothing
                        Set myobject = Nothing
                        GoTo isanumber
                        Else
                        Counterend = usehandler.index_End
                        If Counterend = -1 Then
                        Set usehandler = Nothing
                        Set myobject = Nothing
                        GoTo isAstring
                        Else
                        counter = usehandler.index_start
                        If counter <= Counterend Then countDir = 1 Else countDir = -1
                        End If
                        End If
                    Else
                        Counterend = -1
                        counter = 0
                        countDir = 1
                       If usehandler.t1 = 4 Then
                            Set usehandler = Nothing
                            Set myobject = Nothing
                            GoTo isanumber
                        ElseIf Not CheckIsmArrayOrStackOrCollection(myobject) Then
                            Set myobject = Nothing
                            Set usehandler = Nothing
                        Else
                                SwapStrings rest$, bck$
                                GoTo takeone
                        End If
                        
                    End If
                    End With
                    If Not CheckLastHandler(myobject) Then
                    NoProperObject
                    rest$ = bck$: RevisionPrint = False: GoTo exit2
                    End If
                    Set usehandler = myobject
                    If Typename(usehandler.objref) = "FastCollection" Then
                             Set myobject = usehandler.objref
                             SwapStrings rest$, bck$
                        GoTo takeone
                    ElseIf Typename(usehandler.objref) = "mStiva" Then
                        Set myobject = usehandler.objref
                        SwapStrings rest$, bck$
                        GoTo takeone

                    ElseIf Typename(usehandler.objref) = myArray Then
                        If usehandler.objref.Arr Then
                            Set myobject = usehandler.objref
                            SwapStrings rest$, bck$
                        GoTo takeone
                        End If
                   ElseIf Typename(usehandler.objref) = "Enumeration" Then
                 
                            Set myobject = usehandler.objref
                 
                            SwapStrings rest$, bck$
                       GoTo takeone
                        End If
                ElseIf TypeOf basestack.lastobj Is VarItem Then
                    p = basestack.lastobj.ItemVariant
                End If
                Set basestack.lastobj = Nothing
            ElseIf VarType(p) = vbBoolean Then
            If opn& = 5 Then
                If ShowBooleanAsString Then
                    s$ = Format$(p, DefBooleanString)
                    GoTo isAstring
                Else
                    p = p * 1
                End If
            
            Else
                isboolean = True
            End If
            End If
isanumber:
        If par Then
            If .lastprint Then opn& = 5

            pn& = 1
            If .Column = 1 Then
            
            pn& = 6
            End If
            Else
            .lastprint = False
            pn& = 1
           End If
    ElseIf LastErNum <> 0 Then
            .lastprint = False
            RevisionPrint = LastErNum = -2
            Set Scr = Nothing
            GoTo exit2
    ElseIf IsStrExp(basestack, rest$, s$, Len(basestack.tmpstr) = 0) Then
     If Not basestack.lastobj Is Nothing Then
                If Typename(basestack.lastobj) = myArray Then
                Set myobject = basestack.lastobj
                Set basestack.lastobj = Nothing
                Counterend = -1
                counter = 0
                countDir = 1
                SwapStrings rest$, bck$
                'bck$ = rest$
                'rest$ = vbNullString
                GoTo takeone
                End If
                
            End If
isAstring:
If par Then

    If .lastprint Then opn& = 5
            pn& = 2
            
      If .Column = 1 Then
            
            pn& = 7
            End If
            Else
             .lastprint = False
            pn& = 2
            End If
    ElseIf LastErNum <> 0 Then
             RevisionPrint = LastErNum = -2
             Set Scr = Nothing
                GoTo exit2
    Else
there1:
    If pn& <> 0 And pn& < 5 And Not .lastprint Then
        If par Then
            If Not w4 Then


If Not (.curpos = 0) Then
GetXYb Scr, prive, .curpos, .currow
If pn& = 1 Then
crNew basestack, prive: skiplast = True
ElseIf pn& = 2 Then

If Abs(w3) = 1 And .curpos = 0 And Not (.FTEXT = 9 Or .FTEXT = 5 Or .FTEXT = 6) Then
If .FTEXT = 7 Then
crNew basestack, prive: skiplast = True
End If
Else
crNew basestack, prive: skiplast = True
End If
End If
End If


            End If
        Else
        If f < 0 Then
            crNew basestack, prive
        ElseIf uni(f) Then
            putUniString f, vbCrLf
            Else
            putANSIString f, vbCrLf
            End If
        End If
    End If
 
        Exit Do
    End If
conthere2:
If .lastprint And opn& > 4 Then .lastprint = False
    If FastSymbol(rest$, ";") Then
'' LEAVE W3
If par Then
   If opn& = 0 And (Not work) And (Not .lastprint) Then

   LCTbasket Scr, prive, .currow, .curpos
   End If
  
   ' IF  WORK THEN opn&=5
   opn& = 5
  End If
newntrance:
work = True
.lastprint = True
        
         Do While FastSymbol(rest$, ";")
         Loop
    ElseIf Not FastSymbol(rest$, ",") Then
    
    pn& = pn& + opn&
  opn& = 0
  rest$ = NLtrim$(rest$)
   '  final = True   ERROR - WHEN myobject is an array/inventory to iterate
    Final = myobject Is Nothing
    Else
If par Then
ihavecoma = True ' 'rest$ = "," & rest$
End If
    End If
    pn& = pn& + opn&
    Select Case pn&
    Case 0
    Exit Do
    Case 1
        If .FTXT = vbNullString Then
        If xa Then
        s$ = PACKLNG2$(p)
        Else
If NoUseDec Then
    If isboolean Then
        If ShowBooleanAsString Then
            s$ = Format$(p, DefBooleanString)
            isboolean = False
            GoTo contboolean2
        Else
            p = p * 1
            isboolean = False
            GoTo contboolean
        End If
    Else
        On Error Resume Next
        s$ = CStr(p)
        If Err.Number > 0 Then
                If Typename(p) = "Null" Then
                    s$ = "NULL"
                    Err.Clear
                Else
                    s$ = Typename(p)
                    Err.Clear
                End If
        End If
        On Error GoTo 0
    End If
    
Else

If isboolean Then
    If ShowBooleanAsString Then
        s$ = Format$(p, DefBooleanString)
        isboolean = False
        GoTo contboolean2
    Else
        p = p * 1
        isboolean = False
        GoTo contboolean
    End If
Else
contboolean:
On Error Resume Next
 s$ = LTrim$(Str(p))
 If Err Then s$ = Typename$(p): Err.Clear
    If Left$(s$, 1) = "." Then
    s$ = "0" + s$
    ElseIf Left$(s$, 2) = "-." Then s$ = "-0" + Mid$(s$, 2)
 End If
 If NoUseDec Then

 s$ = Replace$(s$, ".", NowDec$)
 End If
 End If
End If
contboolean2:
      If .FTEXT < 4 Then
            If InStr(s$, ".") > 0 Then
                 If InStr(s$, ".") <= .Column Then
                        If RealLen(s$) > .Column + 1 Then
                                 If .FTEXT > 0 Then s$ = Left$(s$, .Column + 1)
                        End If
                End If
            ElseIf .FTEXT > 0 Then
                 If RealLen(s$) > .Column + 1 Then s$ = String$(.Column, "?")
            End If
          End If
    End If
        Else
        s$ = Format$(p, .FTXT)
        If Not NoUseDec Then
            If mNoUseDec Then
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                s$ = Replace$(s$, Chr(2), NowDec$)
                s$ = Replace$(s$, Chr(3), NowThou$)
            ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                s$ = Replace$(s$, ",", Chr(2))
                s$ = Replace$(s$, ".", ",")
                s$ = Replace$(s$, Chr(2), ".")
            End If
            End If
        End If
     If par Then
        If .Column > 2 Then   ' .Column 3 means 4 chars width
        If opn& < 5 Then
    '                    ensure that we are align in .Column  (.Column is based zero...)
    skiplast = False
            If Not TypeOf Scr Is MetaDc Then
               If .currow >= .my And Not TypeOf Scr Is MetaDc Then
               If Not w4 Then crNew basestack, prive: skiplast = True
               End If
                End If
                        If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                 If w4 Then LCTbasketCur Scr, prive
                       End If
                       work = True
    End If
            If .curpos >= .mx Then
    '' ???
                    Else
            If clearline And .curpos = 0 Then
                If Not TypeOf Scr Is MetaDc Then
                    Scr.Line (0&, .currow * .Yt)-((.mx - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP), .Paper, BF
                End If
            End If
            Select Case .FTEXT
            Case 0
            
                       
                       PlainBaSket Scr, prive, space$(.Column - (RealLen(s$) - 1) Mod (.Column + 1)) + s$, w4, w4, , clearline
                       
            Case 3
                        PlainBaSket Scr, prive, Right$(space$(.Column - (RealLen(s$) - 1) Mod (.Column + 1)) + Left$(s$, .Column + 1), .Column + 1), w4, w4, , clearline
            Case 2
                        If RealLen(s$) > .Column + 1 Then s$ = "????"
                        PlainBaSket Scr, prive, Left$(space$((.Column + 1 - RealLen(s$)) \ 2) + Left$(s$, .Column + 1) & space$(.Column), .Column + 1), w4, w4, , clearline
            Case 1
                        PlainBaSket Scr, prive, Left$(s$ & space$(.Column), .Column + 1), w4, w4, , clearline
            Case 5
                        x1 = .curpos
                        y1 = .currow
                        If Not (.mx - 1 <= .curpos And w4 <> 0) Then
                        LCTbasketCur Scr, prive
                        Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                        wwPlain basestack, prive, s$, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2, 0, , True, 0, , CBool(w4), True, , True
                        .currow = y1
        

                        .curpos = x1 + .Column + 1
                        
                        End If
                     If .curpos >= .mx And Not w4 Then
                   
                         .currow = .currow + 1
                         .curpos = 0
                         End If
              If .lastprint Then
                If Not TypeOf Scr Is MetaDc Then
                 If .curpos = 0 Then
                 If .currow >= .my And Not TypeOf Scr Is MetaDc Then
                 crNew basestack, prive
                 Else
                 LCTbasketCur Scr, prive
                 End If
                 End If
                 End If
                 
     Scr.currentX = .curpos * .Xt
                
                  Scr.currentY = .currow * .Yt + .uMineLineSpace
             
         
                   End If
            Case 4, 7, 8
                         wwPlain basestack, prive, s$ & vbCrLf, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2, 0, , , 1, , , pn& < 5, , True
                        .curpos = .curpos + .Column + 1
                        If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1

                        End If
                        If .lastprint Then
                        
                            If .curpos = 0 Then
                            
                                If .currow >= .my And Not TypeOf Scr Is MetaDc Then
                                crNew basestack, prive
                             
                              
                                Else
                                LCTbasketCur Scr, prive

                                End If
                            
                            End If
                            If .curpos > 0 Then Scr.currentX = .curpos * .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2 Else Scr.currentX = .curpos * .Xt
                            Scr.currentY = .currow * .Yt + .uMineLineSpace
                        End If
            Case 6
                            
                        wwPlain basestack, prive, s$, .Column * .Xt + .Xt, 0, , False, 2, , , pn& < 5, , True
                        .curpos = .curpos + .Column + 1
                        If .curpos >= .mx And Not w4 Then
                            .curpos = 0
                            .currow = .currow + 1
                        End If
                        If .lastprint Then
                            If .curpos = 0 Then
                                If .currow >= .my And Not TypeOf Scr Is MetaDc Then
                                crNew basestack, prive
                                Else
                                LCTbasketCur Scr, prive
                                End If
                            End If
                            Scr.currentX = .curpos * .Xt
                            Scr.currentY = .currow * .Yt + .uMineLineSpace
                        End If
                            
            Case 9
                            LCTbasketCur Scr, prive
                            wPlain Scr, prive, s$, 1000, 0, True
                             GetXYb Scr, prive, .curpos, .currow
                           .curpos = .curpos + 1
                            If (.curpos Mod (.Column + 1)) <> 0 Then
                     .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                             '     .curpos = .curpos + .Column + 1
                            If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                                                               If .lastprint Then
     
                 If .curpos = 0 Then
                 If .currow >= .my And Not TypeOf Scr Is MetaDc Then
                 crNew basestack, prive
                 Else
                 LCTbasketCur Scr, prive
                 End If
                 End If
                If .curpos > 0 Then Scr.currentX = .curpos * .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2 Else Scr.currentX = .curpos * .Xt
                  Scr.currentY = .currow * .Yt + .uMineLineSpace
             
         
                   End If
            End Select
End If
            
            
            
        Else
        ' no way to use this any more...7 rev 20
        PlainBaSket Scr, prive, s$
        End If
 
        Else
          If f < 0 Then
            PlainBaSket Scr, prive, s$
        ElseIf uni(f) Then
            putUniString f, s$
            Else
            putANSIString f, s$
        'Print #f, S$;
        End If
        End If
    Case 2
    '' for string.....................................................................................................................
        If .FTXT <> "" Then
        s$ = Format$(s$, .FTXT)
        End If
        If par Then
        If .Column > 0 Then
                             x1 = .curpos: y1 = .currow
                skiplast = False
                                If .currow >= .my And Not w4 And Not TypeOf Scr Is MetaDc Then
                                crNew basestack, prive
                                skiplast = True
                                End If
                        If work Then
                       .curpos = .curpos - ColOffset
                      If (.curpos Mod (.Column + 1)) <> 0 Then
                      .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                     
                      End If
                      '' LCTbasket scr, prive,   y1, X1
                       If w4 Then LCTbasketCur Scr, prive
                       End If
                       work = True
          If s$ = vbNullString Then s$ = " "
          
                 If .curpos >= .mx Then
                 y1 = 1
                    Else
                               If clearline And .curpos = 0 Then
                               If Not TypeOf Scr Is MetaDc Then
                               Scr.Line (0&, .currow * .Yt)-((.mx - 1) * .Xt + .Xt * 2, (.currow) * .Yt + .Yt - 1 * DYP), .Paper, BF
                               End If
                               End If

            Select Case .FTEXT
                Case 1
                           '' GetXY scr, X1, y1
                          ''  If s$ = VbNullString Then s$ = " "
                          dlen = RealLen(s$)
                          PlainBaSket Scr, prive, Left$(s$ & space$(Len(s$) - dlen + .Column - (dlen - 1) Mod (.Column + 1)), .Column + 1 + Len(s$) - dlen), w4, w4, , clearline
                Case 2
                            dlen = RealLen(s$)
                            If dlen > (.Column + 1 + Len(s$) - dlen) Then s$ = Left$(s$, .Column + 1 + Len(s$) - dlen):  dlen = RealLen(s$)
                            
                            PlainBaSket Scr, prive, Left$(space$((.Column + 1 + Len(s$) - dlen - dlen) \ 2) + s$ & space$(.Column), .Column + 1 + Len(s$) - dlen), w4, w4, , clearline
                Case 3
                            dlen = RealLen(s$)
                            PlainBaSket Scr, prive, Right$(space$(.Column + Len(s$) - dlen - (dlen - 1) Mod (.Column + 1)) & s$, .Column + 1 + Len(s$) - dlen), w4, w4, , clearline
                Case 0
                           '' If s$ = VbNullString Then s$ = " "
                        
                            PlainBaSket Scr, prive, s$ + space$(.Column - (RealLen(s$) - 1) Mod (.Column + 1)), w4, w4, , clearline
                Case 4
                            
                            LCTbasketCur Scr, prive
                            Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                            
                            w3 = 0
                            wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3, True
                            w3 = w3 \ .Xt + 1
                            ' go to next .Column...
                            
                            .curpos = (.Column + 1) * ((w3 + .Column + 1) \ (.Column + 1))
                        If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 5
                           '' GetXY scr, X1, y1
                            LCTbasketCur Scr, prive
                            Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                            wwPlain basestack, prive, s$, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2, 0, , True, 3, , , True
                            .curpos = .curpos + .Column + 1
                            If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 6
                        ''    LCTbasketCur scr, prive
                            wwPlain basestack, prive, s$, .Column * .Xt + .Xt, 0, , False, 2, , , True
                                        .curpos = .curpos + .Column + 1
                            If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                             End If
                Case 7
                            
                            LCTbasketCur Scr, prive
                    work2 = Scr.currentY
                            
                            wwPlain basestack, prive, s$ & vbCrLf, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Right$(s$, 1))) \ 2, 0, , True, 1, , , True, , True
                       Scr.currentY = work2
                            .curpos = .curpos + .Column + 1
                            If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 8
                            LCTbasketCur Scr, prive
                            Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                            If Not (.mx - 1 <= x1 And w4 <> 0) Then
                                    wwPlain basestack, prive, s$, .Column * .Xt + .Xt - (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2, 0, , True, 0, , , True
                            End If
                            .curpos = .curpos + .Column + 1
                            If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                Case 9
                            LCTbasketCur Scr, prive

              wPlain Scr, prive, s$, .Column + 1, 0, True
                GetXYb Scr, prive, .curpos, .currow
                          .curpos = .curpos + 1
                            If (.curpos Mod (.Column + 1)) <> 0 Then
                     .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                      Else
                       .curpos = .curpos + ColOffset
                      End If
                            If .curpos >= .mx And Not w4 Then
                                .curpos = 0
                                .currow = .currow + 1
                            End If
                End Select
                End If
        Else
            PlainBaSket Scr, prive, s$
        
        End If
        Else
              If f < 0 Then
            PlainBaSket Scr, prive, s$, , , , , True
        ElseIf uni(f) Then
            putUniString f, s$
            Else
            putANSIString f, s$
        'Print #f, S$;
        End If
        End If
    Case 6
        If par Then
                If .FTEXT > 3 Then
            w3 = 0
             x1 = .curpos
             y1 = .currow
                        If .FTXT <> "" Then
                                       s$ = Format$(p, .FTXT)
            If Not NoUseDec Then
               If mNoUseDec Then
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                s$ = Replace$(s$, Chr(2), NowDec$)
                s$ = Replace$(s$, Chr(3), NowThou$)
                ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                s$ = Replace$(s$, ",", Chr(2))
                s$ = Replace$(s$, ".", ",")
                s$ = Replace$(s$, Chr(2), ".")
          
                End If
            End If
                               
                                If .FTEXT > 4 And Not work Then Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                                If Scr.currentX < .mx * .Xt Then
                            
                                wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3
                                
                                End If
                                
                        Else
                                 If xa Then
                                        s$ = PACKLNG2$(p)
                                Else
                                If NoUseDec Then
                                       s$ = CStr(p)
                                    Else
                                     s$ = LTrim$(Str(p))
                                      If Left$(s$, 1) = "." Then
                                        s$ = "0" + s$
                                        ElseIf Left$(s$, 2) = "-." Then s$ = "-0" + Mid$(s$, 2)
                                   End If
                                     If mNoUseDec Then s$ = Replace$(s$, ".", NowDec$)
                                    End If
                                End If

                                If .FTEXT > 4 And Not work Then Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                                      If Scr.currentX < 0 Then
                             
                                
                                
                                End If
                                wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3
                                work = True
                                Scr.currentX = w3
                         
                                            
                        End If
                      '' Then LCTbasket scr, prive, y1, W3 \ .Xt + 1
                Else
                        If .FTXT = vbNullString Then
                      
                                If xa Then
                                    PlainBaSket Scr, prive, PACKLNG2$(p)
                                Else
                                  If NoUseDec Then
                                    s$ = CStr(p)
                                        Else
                                            s$ = LTrim$(Str(p))
                                                If Left$(s$, 1) = "." Then
                                                s$ = "0" + s$
                                                ElseIf Left$(s$, 2) = "-." Then s$ = "-0" + Mid$(s$, 2)
                                                End If
                                            If mNoUseDec Then s$ = Replace$(s$, ".", NowDec$)
                                        End If
                                    PlainBaSket Scr, prive, s$
                                End If
                        Else
                      s$ = Format$(p, .FTXT)
            If Not NoUseDec Then
                If mNoUseDec Then
                    s$ = Replace$(s$, GetDeflocaleString(LOCALE_SDECIMAL), Chr(2))
                    s$ = Replace$(s$, GetDeflocaleString(LOCALE_STHOUSAND), Chr(3))
                    s$ = Replace$(s$, Chr(2), NowDec$)
                    s$ = Replace$(s$, Chr(3), NowThou$)
                ElseIf GetDeflocaleString(LOCALE_SDECIMAL) = "," Then
                s$ = Replace$(s$, ",", Chr(2))
                s$ = Replace$(s$, ".", ",")
                s$ = Replace$(s$, Chr(2), ".")
                End If
            End If
      
                            PlainBaSket Scr, prive, s$
                        End If
                End If
        Else
              If f < 0 Then
            PlainBaSket Scr, prive, s$
        ElseIf uni(f) Then
            putUniString f, s$
            Else
            putANSIString f, s$
        ' Print #f, S$;
        End If
        End If
    Case 7
        If par Then
        If s$ <> "" Then
           If .FTEXT > 3 Then
            w3 = 0
             x1 = .curpos
             y1 = .currow
            If Not work Then LCTbasketCur Scr, prive
              If .FTXT <> "" Then s$ = Format$(s$, .FTXT)
                        If .FTEXT > 4 And Not work Then Scr.currentX = Scr.currentX + (.Xt - TextWidth(Scr, Left$(s$, 1))) \ 2
                        wwPlain basestack, prive, s$, Scr.Width, 0, , True, 0, , w3
                        work = True
                       Scr.currentX = w3
            Else
                If .FTXT <> "" Then
                PlainBaSket Scr, prive, Format$(s$, .FTXT), , , , clearline, , True
                Else
                
                
                PlainBaSket Scr, prive, s$, , , , clearline, , True
                End If
                
            End If
        Else

          
        End If
  
            
        Else
              If f < 0 Then
            PlainBaSket Scr, prive, s$
        ElseIf uni(f) Then
            putUniString f, s$
            Else
            putANSIString f, s$
        ' Print #f, S$;
        End If
        End If
    End Select
taketwo:
If ihavecoma Then
ihavecoma = False
GoTo cont12344
    ElseIf FastSymbol(rest$, ",") Then
cont12344:
        w3 = 1
        pn& = 0
      ''  skiplast = False
        If opn& > 4 Then
            Scr.currentX = Scr.currentX + .Xt - dv15
            GetXYb Scr, prive, .curpos, .currow
            If work Then
                .curpos = .curpos - ColOffset
                If (.curpos Mod (.Column + 1)) <> 0 Then
                    .curpos = .curpos + (.Column + 1) - (.curpos Mod (.Column + 1)) + ColOffset
                Else
                    .curpos = .curpos + ColOffset
                End If
                If w4 Then LCTbasketCur Scr, prive
            End If
            work = True
        Else
            work = False
        End If
        opn& = 0
        Do While FastSymbol(rest$, ",")
            If par Then
            ' ok I want that
            If .Column > .mx And .FTEXT < 4 Then
            Else
                If Not w4 Then
                    If Not skiplast Then crNew basestack, prive
                End If
            End If
            Else
                If f < 0 Then
                    crNew basestack, prive
                    
                ElseIf uni(f) Then
                    putUniString f, vbCrLf
                Else
                    putANSIString f, vbCrLf
            'Print #f,
                End If
            End If

        Loop
    End If
If par Or f < 0 Then players(basketcode) = prive

Loop
there:
If w4 <> 0 And par Then
        .FTEXT = oldFTEXT
        .FTXT = oldFTXT
        .Column = oldcol
        If .mypen <> oldpen Then .mypen = oldpen: TextColor Scr, oldpen
        ElseIf par Then
        If pn& > 4 And opn& = 0 Then
        
                 If pn& < 99 Then
                 If work Then
                 .lastprint = False
                 End If
                 If Not skiplast Then crNew basestack, prive
                 End If
        ElseIf (.currow >= .my And Not TypeOf Scr Is MetaDc) Or (w3 < 0 And pn& = 0) Then
JUMPHERE:
              crNew basestack, prive
              LCTbasketCur Scr, prive
        ElseIf pn& > 4 Then
       
        End If

End If
exitnow:
If basestack.IamThread Then
' let thread do the refresh
ElseIf par Or f < 0 Then
    If Not extreme Then
    PrintRefresh basestack, Scr
    End If
End If
RevisionPrint = True
If par Or f < 0 Then
    
    players(basketcode) = prive
    If basketcode > 32 Then
     If .ShowCaret Then
           'nomoveLCTC Scr, prive, .currow, .curpos, 0
            LCTCnew Scr, prive, .currow, .curpos
            ShowCaret Scr.hWnd
            players(basketcode) = prive
     End If
    End If
End If

End With

exit2:
'If Len(rest$) > 0 Then RevisionPrint = False
If Len(rest$) > 0 Then
    If Len(rest$) < where Then
        If where - Len(rest$) = 1 Then
            Mid$(rest1$, 1, Len(rest$)) = rest$
        Else
            Mid$(rest1$, where - Len(rest$), Len(rest$)) = rest$
            rest1$ = Mid$(rest1$, where - Len(rest$))
        End If
    Else
        rest1$ = rest$ + rest1$
    End If
Else
    rest1$ = Mid$(rest1$, where)
End If
If SLOW Then Call myexit(basestack)
End Function


Public Function CheckStackObj(bstack As basetask, anything As Object, Optional counter As Long) As Boolean
Dim usehandler As mHandler
If TypeOf bstack.lastobj Is mHandler Then
        Set usehandler = bstack.lastobj
        If usehandler.t1 <> 3 Then Exit Function
        counter = usehandler.index_cursor + 1
        Set anything = bstack.lastobj
        Set bstack.lastobj = Nothing
        If CheckDeepAny(anything) Then CheckStackObj = True
End If
        
End Function
Function IsEnumAs(bstack As basetask, B$, p, Optional initval As Boolean, Optional part$) As Boolean
initval = False

Dim usehandler0 As mHandler, usehandler As mHandler, ss$, i As Long, that, once As Boolean
    If lookOne(B$, ".") Then
        If IsNumber(bstack, B$, that) Then
            If bstack.lastobj Is Nothing Then GoTo aa2
            If TypeOf bstack.lastobj Is mHandler Then
                Set usehandler0 = bstack.lastobj
                Set bstack.lastobj = Nothing
                GoTo conthere1001
            End If
        End If
        GoTo aa2
    ElseIf FastPureLabel(B$, ss$) = 1 Then
backhere:
        If GetVar(bstack, myUcase(ss$), i) Then
            If MyIsObject(var(i)) Then
                If TypeOf var(i) Is mHandler Then
                    Set usehandler0 = var(i)
conthere1001:
                    If usehandler0.t1 = 4 And usehandler0.IamEnum = False Then
                        Set usehandler = New mHandler
                        usehandler.t1 = 4
                        Set usehandler.objref = usehandler0.objref
                        usehandler.index_start = 0
                        usehandler.index_cursor = usehandler0.objref.ZeroValue
                        If p < 0 Then
                        usehandler.sign = -1
                        Else
                        usehandler.sign = 1
                        End If
                        Set p = usehandler
                        If Len(part$) = 0 Then
                            If FastSymbol(B$, "=") Then
                                If lookOne(B$, ".") Then
                                    If IsNumber(bstack, B$, that) Then
                                        If Not bstack.lastobj Is Nothing Then
                                            If TypeOf bstack.lastobj Is mHandler Then
                                                Set usehandler0 = bstack.lastobj
                                                Set bstack.lastobj = Nothing
                                                GoTo conthere1012
                                            End If
                                        End If
                                    End If
                                ElseIf FastPureLabel(B$, ss$) = 1 Then
                                    If GetVar(bstack, myUcase(ss$), i) Then
                                        If TypeOf var(i) Is mHandler Then
                                            Set usehandler0 = var(i)
conthere1012:
                                            If usehandler0.t1 = 4 Then
                                                If usehandler0.objref.EnumName = usehandler.objref.EnumName Then
                                                    initval = True
                                                    usehandler.index_start = usehandler0.index_start
                                                    usehandler.index_cursor = usehandler0.index_cursor
                                                    usehandler.sign = 1
                                                    IsEnumAs = True
                                                    Exit Function
                                                End If
                                            End If
                                        End If
                                    End If
                                End If
                            Else
                                IsEnumAs = True
                                Exit Function
                            End If
                        ElseIf FastSymbol(part$, "=") Then
                            If lookOne(part$, ".") Then

                                If IsNumber(bstack, part$, that) Then
checknow:
                                    If Not bstack.lastobj Is Nothing Then
                                        If TypeOf bstack.lastobj Is mHandler Then
                                            Set usehandler0 = bstack.lastobj
                                            Set bstack.lastobj = Nothing
                                            GoTo conthere1002
                                        End If
                                    End If
                                End If
                            ElseIf FastPureLabel(part$, ss$) = 1 Then
                                If GetVar(bstack, myUcase(ss$), i) Then
                                    If TypeOf var(i) Is mHandler Then
                                        Set usehandler0 = var(i)
conthere1002:
                                        If usehandler0.t1 = 4 Then
                                            If usehandler0.objref.EnumName = usehandler.objref.EnumName Then
                                                initval = True
                                                usehandler.index_start = usehandler0.index_start
                                                usehandler.index_cursor = usehandler0.index_cursor
                                                usehandler.sign = 1
                                                initval = True
                                                IsEnumAs = True
                                                Exit Function
                                            End If
                                        End If
                                    End If
                                Else
                                If Len(bstack.UseGroupname) > 0 Then
                                    If IsNumber(bstack, "." + ss$, that) Then
                                    GoTo checknow
                                    End If
                                End If
                                End If
                            End If
                        Else
                            IsEnumAs = True
                            Exit Function
                        End If
                    End If
                End If
            End If
        ElseIf once Then
        
        ElseIf Len(bstack.UseGroupname) > 0 Then
        ss$ = bstack.UseGroupname + ss$
        once = True
        GoTo backhere
        End If
    Else
aa2:
        ExpectedEnumType
    End If
End Function

Public Function exeSelect(ExecuteLong, once As Boolean, bstack As basetask, B$, v As Long, Lang As Long) As Boolean
Dim ok As Boolean, x1 As Long, y1 As Long, sp As Variant, st As Variant, sw$, slct As Long, ss$
Dim x2 As Long, y2 As Long, p As Variant, w$, dum As Boolean, i As Long, nd&, lbl$
        exeSelect = True
                x1 = 0 ' mode numbers using p, sp and st
                ' x1=2 using sw$ w$ ss$

            If IsLabelSymbolNew(B$, "ле", "CASE", Lang) Then
            
                        If IsExp(bstack, B$, sp, , True) Then
                        x1 = 1
                        ElseIf IsStrExp(bstack, B$, sw$) Then
                        x1 = 2
                        End If
                    If x1 > 0 Then ' SELECT CASE NUMBER or STRING
                        SetNextLine B$
                        While MaybeIsSymbol(B$, RemChar)
                        SetNextLine B$
                        Wend
                    slct = 1
                       If NocharsInLine(B$) Then
                       ExpectedCaseorElseorEnd
                        ExecuteLong = 0
                            Exit Function
                            End If
                        Do
                        If NocharsInLine(B$) Then
               
                            Exit Do
                        End If
                                IsNumberLabel B$, lbl$
                                If IsLabelSymbolNew(B$, "ле", "CASE", Lang) Then  ' WE HAVE CASE
                                If IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then GoTo case1else
                                If ok Then
                                ExpectedEndSelect
                                ExecuteLong = 0
                                Exit Function
                  
                                    End If
                                If slct > 0 Then         ' WE ARE IN SEARCH
                                Do
                                ' ЕДЧ ЙОИТэЛЕ ТА CASE
                                x2 = 0
                                If x1 = 1 Then
                                If IsExp(bstack, B$, p, , True) Then x2 = 1
                                Else
                                If IsStrExp(bstack, B$, w$) Then x2 = 2
                                End If
                                       If x2 > 0 Then 'WE HAVE NUMBER OR STRING
                                            If IsLabelSymbolNew(B$, "еыс", "TO", Lang) Then   ' range ?
                                            y1 = 0
                                               If x1 = 1 Then
                                                    If IsExp(bstack, B$, st, , True) Then y1 = 1

                                                Else
                                                    If IsStrExp(bstack, B$, ss$) Then y1 = 2
                                                End If
                                                If y1 > 0 Then
                                                y2 = 0
                                                   If x1 = 1 Then
                                                    If (sp >= p And sp <= st) Then y2 = 1

                                                Else
                                                    If sw$ >= w$ And sw$ <= ss$ Then y2 = 2
                                                End If
                                                    If y2 > 0 Or slct = -1 Then 'slct=-1 from break
                                                   If slct = 1 Then slct = 0   ' slct=0 we found
                                                   ' start ExecuteLong command or block

                                            End If
                                                Else
                                                    MyEr "Wrong expression type in To clause in Case", "кэХОР ТЩПОР щЙЖЯАСГР СТГМ ╦ЫР СТГМ лЕ"
                                                    ExecuteLong = 0
                                                    Exit Function
                                                End If
                                            Else
                                            ' NO WE HAVE ONE VALUE...X1 MASTER, X2 ONE VALUE  Y2 FOR LAST CHECK
                                                y2 = 0
                                                If x1 = 1 Then
                                                    If sp = p Then y2 = 1
                                                Else
                                                    If w$ = sw$ Then y2 = 2
                                                End If
                                                If y2 > 0 Or slct = -1 Then ' ONE VALUE
                                                     If slct = 1 Then slct = 0
                                                End If
                                            End If
                                        Else
                                            If x1 = 1 Then
                                                B$ = Str$(sp) & " " & B$
                                            Else
                                                ' HERE............................IS A PROBLEM IF SW$ HAS <3 ASCII CODE
                                                B$ = Sput(sw$) + B$
                                            End If
                                        If IsExp(bstack, B$, p, , True) Then
                                            If p <> 0 Or slct = -1 Then
                                             If slct = 1 Then slct = 0
                                             ' start ExecuteLong command or block
                                             End If
                                        Else
                                        MyEr "Expected logic half expression in Case", "пЕЯъЛЕМА КОЦИЙч ЛИСч щЙЖЯАСГ СТГМ лЕ"
                                        ExecuteLong = 0
                                        Exit Function
                                        End If
                                        End If
                                        If slct = 0 Then
                                            If Left$(B$, 4) = vbCrLf + vbCrLf Then
                                                                ExpectedCaseorElseorEnd
                                                                B$ = Mid$(B$, 3)
                                                                ExecuteLong = 0: Exit Function
                                                                End If
                                                    SetNextLine B$
                                                     '    v = Len(b$)
conthere:
                                                        If FastSymbol(B$, "{") Then  ' block
                                                          ss$ = block(B$)
                                                            dum = False
                                                            i = 1
                                                            ' #3 call a block
                                                            TraceStore bstack, nd&, B$, 0
                                                            Call executeblock(i, bstack, ss$, False, dum, , True)
                                                           TraceRestore bstack, nd&
                                                            
                                                            
                                                            If i = 1 Then
                                                            FastSymbol B$, "}"
                                                            If Not MaybeIsSymbol(B$, RemChar) Then
                                                            If Not Left$(B$, 2) = vbCrLf Then
                                                                ExpectedCommentsOnly
                                                                ExecuteLong = 0: Exit Function
                                                            End If
                                                            End If
                                                            Else
                                                            
                                                            If i = 0 Then
                                                                B$ = ss$ & B$
                                                                ExecuteLong = 0: Exit Function
                                                            ElseIf i = 2 Then
                                                                If Len(ss$) > 0 Then B$ = ss$
                                                                If dum = True And B$ <> "" Then
                                                                slct = -1
                                                                Else
                                                                GoTo ContGoto
                                                                End If
                                                            ElseIf i = 3 Then
                                                                If Len(ss$) > 0 Then B$ = ss$
                                                               If dum = True And B$ <> "" Then slct = 0
                                                            End If
                                                            End If
                                                        Else   ' or line
                                                            dum = True
                                                        
                                                            i = 1
                                                            IsNumberLabel B$, lbl$
                                                            While IsLabelSymbolNew(B$, "ле", "CASE", Lang)
                                                           SetNextLine B$
                                                           IsNumberLabel B$, lbl$
                                                            Wend
                                                            ' #4 call one command
                                                            If lookOne(B$, "{") Then
                                                            GoTo conthere
                                                            End If
                                                            once = True
                                                            
                                                            ss$ = GetNextLine(B$) + vbCrLf + "'"
                                                           
                                                            TraceStore bstack, nd&, B$, 3
                                                            Call executeblock(i, bstack, ss$, once, dum, True, True)
                                                            bstack.addlen = nd&

                                                            If i = 0 Then
                                                                ExecuteLong = 0: Exit Function
                                                            ElseIf i = 1 And ss$ = vbNullString And once Then 'this is an exit ой3
                                                                
                                                                B$ = vbNullString
                                                                ExecuteLong = 1
                                                                Exit Function
                                                            ElseIf i = 2 Then
                                                                If dum = True And Len(ss$) > 0 Then
                                                                    slct = -1
                                                                ElseIf Len(ss$) > 0 Then
                                                                    B$ = ss$
                                                                    ExecuteLong = 2
                                                                    once = False
                                                                    Exit Function
                                                                Else
                                                                    ExecuteLong = i
                                                                    B$ = ss$
                                                                    exeSelect = dum
                                                                End If
                                                            ElseIf i = 3 Then
                                                                If dum = True And ss$ <> "" Then
                                                                    slct = 0
                                                                Else
                                                                    i = 2
                                                                    B$ = vbNullString
                                                                    exeSelect = True
                                                                End If
                                                            ElseIf i = 5 Then
                                                                ExecuteLong = 2
                                                                exeSelect = False
                                                            End If
                                                        End If
                                                        Exit Do
                                        End If
                                    Loop While FastSymbol(B$, ",")
                                    
                                     End If
                                SetNextLine B$
                                                                     If Left$(B$, 2) = vbCrLf Then
                                                                     ExpectedCaseorElseorEnd
                                                                ExecuteLong = 0
                                                                Exit Function
                                                                End If
                                ' drop case
                                IsNumberLabel B$, lbl$
                                If IsLabelSymbolNew(B$, "ле", "CASE", Lang, , , True) Then
         
                                ElseIf IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang, , , True) Then
   
                                ElseIf IsLabelSymbolNew(B$, "текос", "END", Lang, , , True) Then
                             
                                Else
                                    If FastSymbol(B$, "{") Then
                                           If slct >= 0 Then
                                                    ss$ = block(B$) + "}"
                                                    B$ = NLtrim$(Mid$(B$, 2))
                                            Else
                                                    ss$ = block(B$)
                                                    dum = False
                                                    i = 1
                                                    ' #7 call block inside Case (Break) ok
                                                    TraceStore bstack, nd&, B$, 0
                                                            Call executeblock(i, bstack, ss$, False, dum, , True)
                                                            TraceRestore bstack, nd&
                                                            If i = 1 Then
                                                            FastSymbol B$, "}"
                                                            If Not MaybeIsSymbol(B$, RemChar) Then
                                                            If Not Left$(B$, 2) = vbCrLf Then
                                                                ExpectedCommentsOnly
                                                                ExecuteLong = 0: Exit Function
                                                            End If
                                                            End If
                                                                    Else
                                                            
                                                            If i = 0 Then
                                                               B$ = ss$ & B$
                                                                ExecuteLong = 0: Exit Function
                                                            ElseIf i = 2 Then
                                                                    If Len(ss$) > 0 Then B$ = ss$
                                                                    If dum = True And B$ <> "" Then
                                                                    slct = -1
                                                                    Else
                                                                    GoTo ContGoto
                                                                    End If
                                                           
                                                             ElseIf i = 3 Then
                                                                    If Len(ss$) > 0 Then B$ = ss$
                                                                    If dum = True And B$ <> "" Then slct = 0
        
                                                             End If
                                                            End If
                                            End If
                                     
                                        SetNextLine B$
                                      ElseIf slct < 0 Then
                                                        dum = True
                                                   
                                                            i = 1
                                                            ' #8 call one command inside Case (Break) ok
                                                            once = True
                                                            
                                                            ss$ = GetNextLine(B$) + vbCrLf + "'"
                                                           
                                                            TraceStore bstack, nd&, B$, 3
                                                            Call executeblock(i, bstack, ss$, once, dum, True, True)
                                                            bstack.addlen = nd&
                                                            If i = 0 Then
                                                                ExecuteLong = 0: Exit Function
                                                            ElseIf i = 1 And ss$ = vbNullString And once Then  'this is an exit ой3
                                                                B$ = vbNullString
                                                                ExecuteLong = 1
                                                                Exit Function
                                                            ElseIf i = 2 Then
                                                                If dum = True And Len(ss$) > 0 Then
                                                                    slct = -1
                                                                ElseIf Len(ss$) > 0 Then
                                                                    B$ = ss$
                                                                    ExecuteLong = 2
                                                                    once = False
                                                                    Exit Function
                                                                Else
                                                                    ExecuteLong = i
                                                                    B$ = ss$
                                                                    exeSelect = dum
                                                                End If
                                                            ElseIf i = 3 Then
                                                                If dum = True And ss$ <> "" Then
                                                                    slct = 0
                                                                Else
                                                                    i = 2
                                                                    B$ = vbNullString
                                                                    exeSelect = True
                                                                End If
                                                            ElseIf i = 5 Then
                                                                ExecuteLong = 2
                                                                exeSelect = False
                                                            End If
  
        
                                    SetNextLine B$
                                    Else
                                    SetNextLine B$
                                
                                        End If
                                    
                                End If
                                
                                ElseIf IsLabelSymbolNew(B$, "аккиыс", "ELSE", Lang) Then
                                        IsLabelSymbolNew B$, "ле", "CASE", Lang
case1else:
                                
                                           If ok Then
                                ExpectedEndSelect
                                ExecuteLong = 0
                                Exit Function
                                Else
                                    ok = True
                                    End If
                                    SetNextLine B$
                                    If FastSymbol(B$, "{") Then
                                        ss$ = block(B$)
                                    If slct > 0 Then
                                                    dum = False
                                                    i = 1
                                                    ' #9 call block inside Else
                                                    TraceStore bstack, nd&, B$, 0
                                                       Call executeblock(i, bstack, ss$, False, dum, , True)
                                                       TraceRestore bstack, nd&
                                                       If i = 1 Then
                                                            FastSymbol B$, "}"
                                                            If Not MaybeIsSymbol(B$, RemChar) Then
                                                            If Not Left$(B$, 2) = vbCrLf Then
                                                                ExpectedCommentsOnly
                                                                ExecuteLong = 0: Exit Function
                                                            End If
                                                            End If
                                                            Else
                                                              
                                                            If i = 0 Then
                                                                B$ = ss$ & B$
                                                                ExecuteLong = 0: Exit Function
                                                            ElseIf i = 2 Then
                                                                        If Len(ss$) > 0 Then B$ = ss$
                                                                          If dum = True And B$ <> "" Then
                                                                            slct = -1
                                                                          ElseIf B$ <> "" Then
                                                                        GoTo ContGoto
                                                                          Else
                                                                            once = True
                                                                            Exit Function
                                                                        End If
                                                            ElseIf i = 3 Then
                                                            If Len(ss$) > 0 Then B$ = ss$
                                                                If dum = True And B$ <> "" Then slct = 0: B$ = Mid$(B$, 2): GetNextLine (ss$)
                                                            End If
                                                            End If
                                        Else
                                        B$ = NLtrim$(Mid$(B$, 2))
                                        End If
                                    Else
                                    If slct > 0 Then
                                                                       dum = True
                                             
                                                            i = 1
                                                            ' #10 call one command inside ELSE
                                                            once = True
                                                            dum = True
                                                            'TraceStore bstack, nd&, b$, 0
                                                            ss$ = GetNextLine(B$) + vbCrLf + "'"
                                                            TraceStore bstack, nd&, B$, 3
                                                            Call executeblock(i, bstack, ss$, once, dum, True, True)
                                                        
                                                            TraceRestore bstack, nd&
                                                            If i = 0 Then
                                                                    ExecuteLong = 0: Exit Function
                                                            ElseIf i = 1 And ss$ = vbNullString And once Then  'this is an exit
                                                                B$ = vbNullString
                                                                ExecuteLong = 1
                                                                Exit Function
                                                            ElseIf i = 2 Then
                                                              
                                                                          If dum = True And Len(ss$) > 0 Then
                                                                            slct = -1
                                                                          ElseIf Len(ss$) > 0 Then
                                                                            B$ = ss$
                                                                            ExecuteLong = 2
                                                                            once = False
                                                                             Exit Function
                                                                          Else
                                                                            ExecuteLong = i
                                                                            B$ = ss$
                                                                            exeSelect = dum
                                                                            Exit Function
                                                                        End If
                                                            ElseIf i = 3 Then
                                                                If dum = True And ss$ <> "" Then
                                                                    slct = 0
                                                                Else
                                                                    i = 2
                                                                    B$ = vbNullString
                                                                    exeSelect = True
                                                                End If
                                                            ElseIf i = 5 Then
                                                                ExecuteLong = 2
                                                                exeSelect = False
                                              End If
                                    End If
                                End If
                                SetNextLine B$
                                slct = 0
                        ElseIf IsLabelSymbolNew(B$, "текос", "END", Lang) Then
                            If IsLabelSymbolNew(B$, "епикоцгс", "SELECT", Lang) Then
                                slct = 0
                                Exit Do
                            Else
                                ExpectedEndSelect
                                ExecuteLong = 0
                                Exit Function
                            End If
                        Else
                             If ok Then
                             ExpectedEndSelect2
                             Else
                             ExpectedCaseorElseorEnd2
                             End If
                            ExecuteLong = 0
                            Exit Function
                        End If
  
                        Loop
                        If slct > 0 Then
                        ExecuteLong = 0: Exit Function
                        End If
                        
                    '-----------ENDIF ---------------
                       Else
                        ExecuteLong = 0
                        Exit Function
                    End If
        Else
           ExecuteLong = 0
           Exit Function
        End If
     exeSelect = False
     Exit Function
ContGoto:
        If myexit(bstack) Then ExecuteLong = 1: Exit Function
        If MyTrim$(B$) = vbNullString Or FastSymbol(B$, ":") Then
                ExecuteLong = 0
                MissingLabel
                Exit Function
        Else
        ' GET OUT FOR NEXT
    
        
        i = FastPureLabel(B$, w$)

                If i = 1 Then
                
                once = False
                B$ = w$
                ExecuteLong = 2
                Exit Function
                ElseIf i = 0 Then
                If IsNumberLabel(B$, w$) Then
                      once = False
                B$ = w$
                ExecuteLong = 2
                Exit Function
                Else
                 B$ = w$ & B$
                End If
                Else
                B$ = w$ & B$
                
                End If
              End If
End Function

Function GetArrayReference(bstack As basetask, a$, v$, pp, Result As mArray, index As Long) As Boolean
Dim dn As Long, dd As Long, p, w3, w2 As Long, pppp As mArray, usehandler As mHandler
If pp Is Nothing Then Exit Function
If Not TypeOf pp Is mArray Then
If TypeOf pp Is mHandler Then
Set usehandler = pp
With usehandler
If .t1 = 3 Then If Not .objref Is Nothing Then If TypeOf .objref Is mArray Then Set pp = .objref: GoTo cont
End With
End If
Exit Function
End If
cont:
Set usehandler = Nothing
Set pppp = pp

If pppp.Arr Then
dn = 0

pppp.SerialItem (0), dd, 5
dd = dd - 1
If dd < 0 Then If Typename(pppp.GroupRef) = mProp Then Exit Function
            
            
p = 0
    GetArrayReference = True
    w2 = 0



        Do While dn <= dd
                    pppp.SerialItem w3, dn, 6
                    
                        If IsExp(bstack, a$, p, , True) Then
                        If dn < dd Then
                            If Not FastSymbol(a$, ",") Then: MyErMacro a$, "need index for " & v$ & ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " & v$ & ")": GetArrayReference = False: Exit Function
                           
                            Else
                         If FastSymbol(a$, ",") Then
                        GetArrayReference = False
                        MyErMacro a$, "too many indexes for array " & v$ & ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " & v$ & ")"
                        Exit Function
                         
                         End If
                            If Not FastSymbol(a$, ")") Then: MissSymbol ")": GetArrayReference = False: Exit Function
                            
                         
                        End If
                            On Error Resume Next
                            If p < -pppp.myarrbase Then
                            GetArrayReference = False
                              MyErMacro a$, "index too low for array " & v$ & ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " & v$ & ")"
                            Exit Function
                            End If
                            
                        If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
                                GetArrayReference = False
                                MyErMacro a$, "index too high for array " & v$ & ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " & v$ & ")"
                                GetArrayReference = False
                            Exit Function
                            End If
                            On Error GoTo 0
                        Else
                        
                         GetArrayReference = False
                        If LastErNum = -2 Then
                        Else
                        
                        MyErMacro a$, "missing index for array " & v$ & ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " & v$ & ")"
                        End If
                        Exit Function
                        End If
                    dn = dn + 1
                    Loop
                    
                    
                        Set Result = pppp
                        index = w2
    End If
End Function

Function ProcessArray(bstack As basetask, a$, v$, pp, Result) As Boolean
Dim dn As Long, dd As Long, p, w3, w2 As Long, pppp As mArray
If Not Typename$(pp) = myArray Then Exit Function
Set pppp = pp

If pppp.Arr Then
dn = 0

pppp.SerialItem (0), dd, 5
dd = dd - 1
If dd < 0 Then If Typename(pppp.GroupRef) = mProp Then Exit Function
            
            
p = 0
    ProcessArray = True
    w2 = 0



        Do While dn <= dd
                    pppp.SerialItem w3, dn, 6
                    
                        If IsExp(bstack, a$, p, , True) Then
                        If dn < dd Then
                            If Not FastSymbol(a$, ",") Then: MyErMacro a$, "need index for " & v$ & ")", "ВЯЕИэФОЛАИ ДЕъЙТГ ЦИА ТО ПъМАЙА " & v$ & ")": ProcessArray = False: Exit Function
                           
                            Else
                         If FastSymbol(a$, ",") Then
                        ProcessArray = False
                        MyErMacro a$, "too many indexes for array " & v$ & ")", "ПОККОъ ДЕъЙТЕР ЦИА ТО ПъМАЙА " & v$ & ")"
                        Exit Function
                         
                         End If
                            If Not FastSymbol(a$, ")") Then: MissSymbol ")": ProcessArray = False: Exit Function
                            
                         
                        End If
                            On Error Resume Next
                            If p < -pppp.myarrbase Then
                            ProcessArray = False
                              MyErMacro a$, "index too low for array " & v$ & ")", "ВАЛГКЭР ДЕъЙТГР СТО ПъМАЙА " & v$ & ")"
                            Exit Function
                            End If
                            
                        If Not pppp.PushOffset(w2, dn, CLng(Fix(p))) Then
                                ProcessArray = False
                                MyErMacro a$, "index too high for array " & v$ & ")", "ДЕъЙТГР УЬГКЭР ЦИА ТО ПъМАЙА " & v$ & ")"
                                ProcessArray = False
                            Exit Function
                            End If
                            On Error GoTo 0
                        Else
                        
                         ProcessArray = False
                        If LastErNum = -2 Then
                        Else
                        
                        MyErMacro a$, "missing index for array " & v$ & ")", "ВэХГЙЕ ДЕъЙТГР ЦИА ТО ПъМАЙА " & v$ & ")"
                        End If
                        Exit Function
                        End If
                    dn = dn + 1
                    Loop
                    If MyIsObject(pppp.item(w2)) Then
                        Set Result = pppp.item(w2)
                    Else
                        Result = pppp.item(w2)
                    End If
    End If
End Function
Function ReplaceCRLFSPACE(a$) As Boolean
Dim i As Long
For i = 1 To Len(a$)
Select Case AscW(Mid$(a$, i, 1))
Case 13
ReplaceCRLFSPACE = True
Case 32, 10, 160, 9
Case Else
Exit For
End Select
Next i
If i = 1 Then Exit Function
If i > Len(a$) Then a$ = vbNullString: Exit Function
Mid$(a$, 1, i - 1) = String$(i - 1, Chr(7))
End Function
Sub NeoLet(basestackLP As Long, rest$, Lang As Long, resp As Boolean)
resp = MyLet(ObjFromPtr(basestackLP), rest$, Lang)
End Sub
Sub Resettimestamp()
timestamp = -1
End Sub
Function check2(s$, a$, B$) As Boolean
If s$ = a$ Then check2 = True: Exit Function
If s$ = B$ Then check2 = True
End Function
Function FastSymbolNoTrimAfter(a$, c$) As Boolean
Dim i As Long, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then Exit Function  ' this is not good
If j - i < 0 Then Exit Function
If c$ = Mid$(a$, i, 1) Then
a$ = Mid$(a$, i + 1)
FastSymbolNoTrimAfter = True
End If
End Function
Function FastSymbolAt(i As Long, a$, c$, Optional cl As Long = 1) As Boolean
Dim j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimLi(a$, i)
If i > j Then Exit Function
If j - i < cl - 1 Then Exit Function
If c$ = myUcase(Mid$(a$, i, cl)) Then i = i + cl: FastSymbolAt = True
End Function
Function FastSymbolAtNoSpace(i As Long, a$, c$, Optional cl As Long = 1) As Boolean
Dim j As Long
j = Len(a$)
If j = 0 Then Exit Function
If i > j Then Exit Function
If j - i < cl - 1 Then Exit Function
If c$ = myUcase(Mid$(a$, i, cl)) Then i = i + cl: FastSymbolAtNoSpace = True
End Function

Function NocharsInLine(a$) As Boolean
Dim i As Long, j As Long
j = Len(a$)
If j = 0 Then NocharsInLine = True: Exit Function
i = MyTrimL(a$)
If i > j Then NocharsInLine = True: Exit Function

End Function
Sub DropCommentOrLine(a$)
Dim i As Long, j As Long
again:
j = Len(a$)
If j = 0 Then a$ = vbNullString:  Exit Sub
i = MyTrimL(a$)
If i > j Then a$ = vbNullString: Exit Sub
Select Case AscW(Mid$(a$, i, 1))
Case 47
If Mid$(a$, i + 1, 1) = "/" Then i = i + 1: GoTo a1111
Case 39, 92
a1111:
' drop line
i = InStr(i, a$, vbLf)
If i = 0 Then a$ = vbNullString Else a$ = Mid$(a$, i + 1): GoTo again
Case 13
' drop one line
Mid$(a$, 1, i + 1) = space$(i + 1)
GoTo again
Case Else
If i > 1 Then Mid$(a$, 1, i - 1) = space$(i - 1)
End Select


End Sub
Function MaybeIsTwoSymbol(a$, c$, Optional l As Long = 2) As Boolean
Dim i As Long
If a$ = vbNullString Then Exit Function
i = MyTrimL(a$)
If i > Len(a$) Then Exit Function
MaybeIsTwoSymbol = c$ = Mid$(a$, i, 2)

End Function
Sub MakeArray(basestack As basetask, frm$, o As Long, rest$, pppp As mArray, Optional lcl As Boolean = False, Optional globalonly As Boolean = False) 'global
Dim p As Variant, X As Variant, i As Long, f As Long, s$, ss$
    i = MyTrimL(rest$)
    If Mid$(rest$, i, 1) = ")" Then Mid$(rest$, i, 1) = ChrW(8)
    i = 0
    Select Case o
    Case 5, 6, 7
    If lcl Then
    
      GlobalArr basestack, here$ & "." + basestack.GroupName & frm$, rest$, i, f, True
    Else
    GlobalArr basestack, basestack.GroupName & frm$, rest$, i, f, True, , globalonly
    End If
    p = i
    If i < 0 Then o = 0
    Case Else
    o = 0
    End Select

    
    Select Case o
    Case 5
        X = 0
      If FastSymbol(rest$, "=") Then
            If IsExp(basestack, rest$, X) Then
            
                        If neoGetArray(basestack, frm$, pppp, , globalonly, Not lcl) Then   '' basestack.GroupName & f
                             If Not basestack.lastobj Is Nothing Then
                                                    If Typename(basestack.lastobj) = mgroup Then
                                                        If basestack.lastobj.IamSuperClass Then
                                                    Set pppp.GroupRef = basestack.lastobj.SuperClassList
                                                Else
                                                    Set pppp.GroupRef = basestack.lastobj
                                                    End If
                                                     pppp.IHaveClass = True
                                                    Set basestack.lastobj = Nothing
                                                    pppp.SerialItem 0, 0, 3
                                                    End If
                                         Else
                                                pppp.SerialItem X, 0, 3
                                        End If
                        End If
            Else
                o = 0
            End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
    
   f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, frm$, pppp) Then
                      For i = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                                        If Not basestack.lastobj Is Nothing Then
                                                 If Typename(basestack.lastobj) = mgroup Then
                                                     Set pppp.GroupRef = Nothing
                                                     pppp.IHaveClass = False
                                                     If basestack.lastobj.IamSuperClass Then
                                                    Dim myobj As Object
                                          pppp.CopyGroupObj basestack.lastobj.SuperClassList, myobj
                        
                                              Set myobj.SuperClassList = basestack.lastobj.SuperClassList
                                              Set pppp.item(i) = myobj
                                              Set myobj = Nothing
                                             
                                               Else
                                                  
                                                       Set pppp.item(i) = basestack.lastobj
                                                      End If
                                        ElseIf Typename(basestack.lastobj) = mHdlr Then
                                        Set pppp.item(i) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                        Set pppp.item(i) = basestack.lastobj
                                        ElseIf Typename(basestack.lastobj) = myArray Then
                                        Set pppp.item(i) = basestack.lastobj
                                                    Else
                                                        Set basestack.lastobj = Nothing
                                                        badsupport
                                                        GoTo ex1
                                                        Exit For
                                                     End If
                                                     
                                        Else
                                                pppp.item(i) = X
                                        End If
                                        
                        Else
                          Set basestack.lastobj = Nothing

                            MissNumExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next i
                          Set basestack.lastobj = Nothing
            Else
         '   it = 0
                End If
          End If
     
    End If

    Case 7
    X = 0
    If FastSymbol(rest$, "=") Then
    If IsExp(basestack, rest$, X) Then
   If neoGetArray(basestack, frm$, pppp, , Not lcl) Then  '' basestack.GroupName &
    pppp.SerialItem Int(X), 0, 3
    End If
    Else
    o = 0
    End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
         f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, frm$, pppp) Then
                        For i = 0 To pppp.UpperMonoLimit
                        If IsExp(basestack, (s$), X) Then
                            If Typename(basestack.lastobj) = "lambda" Then
                                    Set pppp.item(i) = basestack.lastobj
                            ElseIf basestack.lastobj Is Nothing Then
                                    pppp.item(i) = Int(X)
                            Else
                                Set basestack.lastobj = Nothing
                                   MyEr "Only Lambda objects here", "лЭМО КэЛДА АМТИЙЕъЛЕМА ЕДЧ"
                                   
                                   GoTo ex1
                                   Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            
                                            MissNumExpr
                            GoTo ex1
                       
                        End If
                        Next i
                        Set basestack.lastobj = Nothing
            Else
            MissNumExpr
            GoTo ex1
           End If
          End If
    End If
    Case 6
        s$ = vbNullString
    If FastSymbol(rest$, "=") Then
    If IsStrExp(basestack, rest$, s$) Then
    If neoGetArray(basestack, frm$, pppp, , Not lcl) Then ''basestack.GroupName &
    pppp.SerialItem s$, 0, 3
    End If
    End If
    ElseIf FastSymbol(rest$, "<<", , 2) Then
    f = 1
         s$ = aheadstatus(rest$, True, f)
         If f > 0 Then
                s$ = Left$(rest$, f - 1)
                rest$ = Mid$(rest$, f)
                If neoGetArray(basestack, frm$, pppp) Then
               
                        For i = 0 To pppp.UpperMonoLimit
                        If IsStrExp(basestack, (s$), ss$) Then
                            If Typename(basestack.lastobj) = mgroup Then
                                Set pppp.GroupRef = Nothing
                                pppp.IHaveClass = False
                                Set pppp.item(i) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = "lambda" Then
                                Set pppp.item(i) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = mHdlr Then
                                Set pppp.item(i) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = "mStiva" Then
                                Set pppp.item(i) = basestack.lastobj
                            ElseIf Typename(basestack.lastobj) = myArray Then
                                Set pppp.item(i) = basestack.lastobj
                            ElseIf basestack.lastobj Is Nothing Then
                                pppp.item(i) = ss$
                            Else
                                Set basestack.lastobj = Nothing
                                badsupport
                                GoTo ex1
                                Exit For
                            End If
                        Else
                            Set basestack.lastobj = Nothing
                            MissStringExpr
                            GoTo ex1
                            Exit For
                        End If
                        Next i
                        Set basestack.lastobj = Nothing
            Else

                MissStringExpr
                GoTo ex1
            End If
        End If
    End If
    End Select
    If o = 0 Then
      BadDim
    rest$ = basestack.GroupName & frm$ & rest$
    End If
ex1:
    Set basestack.lastpointer = Nothing
    
End Sub
Sub MarkIf(bstack As basetask, a As Long, B As Boolean)
Dim s As mStiva2
Set s = bstack.RetStack
s.PushVal B
s.PushVal a
s.PushVal -3  ' mark for IF
End Sub

Function lookOne(s, c$) As Boolean
Dim i&, l As Long, cc As Integer
Dim p2 As Long, p1 As Integer
  l = Len(s): If l = 0 Then Exit Function
  p2 = StrPtr(s): l = l - 1: GetMem2 StrPtr(c$), cc

  For i = p2 To p2 + l * 2 Step 2
  GetMem2 i, p1
  Select Case p1
    Case 32, 160, 7, 9
    Case cc
    lookOne = True
    Case Else
   Exit Function
  End Select
  Next i
End Function
Function lookTwoSame(s, c$) As Boolean
Dim i&, l As Long, cc As Integer, cc2 As Integer
Dim p2 As Long, p1 As Integer, n As Integer
    If Len(c$) <> 1 Then Exit Function
  l = Len(s): If l = 0 Then Exit Function
  p2 = StrPtr(s): l = l - 1: GetMem2 StrPtr(c$), cc
  For i = p2 To p2 + l * 2 Step 2
  GetMem2 i, p1
  Select Case p1
    Case 32, 160, 7, 9
        If n <> 0 Then Exit Function
    Case cc
        If n = 1 Then lookTwoSame = True: Exit Function
        If n = 0 Then n = 1
    Case Else
        Exit Function
  End Select
  Next i
End Function
Function MaybeIsSymbol(a$, c$) As Boolean
Dim i As Long
If a$ = vbNullString Then Exit Function
i = MyTrimL(a$)
If i > Len(a$) Then Exit Function
MaybeIsSymbol = InStr(c$, Mid$(a$, i, 1)) > 0
End Function
Function MaybeIsSymbol2(a$, c$, i As Long) As Boolean
'' for isnumber
If a$ = vbNullString Then Exit Function
i = MyTrimL(a$)
If i > Len(a$) Then Exit Function
MaybeIsSymbol2 = InStr(c$, Mid$(a$, i, 1)) > 0
End Function
Function MaybeIsSymbol3lot(a$, c$, i As Long) As Boolean
If a$ = vbNullString Then Exit Function
i = MyTrimLi(a$, IIf(i, i, 1))
If i > Len(a$) Then Exit Function
MaybeIsSymbol3lot = InStr(c$, Mid$(a$, i, 1)) > 0
End Function
Function MaybeIsSymbol3(a$, c$, i As Long) As Boolean
If a$ = vbNullString Then Exit Function
i = MyTrimLi(a$, IIf(i, i, 1))
If i > Len(a$) Then Exit Function
MaybeIsSymbol3 = c$ = Mid$(a$, i, 1)
End Function

Function MaybeIsSymbolNoSpace(a$, c$) As Boolean
MaybeIsSymbolNoSpace = Left$(a$, 1) Like c$
End Function
Function IsLabelSymbolNew(a$, gre$, Eng$, code As Long, Optional mis As Boolean = False, Optional ByVal ByPass As Boolean = False, Optional checkonly As Boolean = False, Optional Free As Boolean = True) As Boolean
' code 2  gre or eng, set new value to code 1 or 0
' 0 for gre
' 1 for eng
' return true if we have label
Dim what As Boolean, drop$
Select Case code
Case 0
IsLabelSymbolNew = IsLabelSymbol3(1032, a$, gre$, drop$, mis, ByPass, checkonly, Free)
Case 1
IsLabelSymbolNew = IsLabelSymbol3(1033, a$, Eng$, drop$, mis, ByPass, checkonly, Free)
Case 2
what = IsLabelSymbol3(1032, a$, gre$, drop$, mis, ByPass, checkonly, Free)
If what Then
code = 0
IsLabelSymbolNew = what
Exit Function
End If
what = IsLabelSymbol3(1033, a$, Eng$, drop$, mis, ByPass, checkonly, Free)
If what Then code = 1
IsLabelSymbolNew = what
End Select
End Function
Function IsLabelSymbol3(ByVal code As Double, a$, c$, useth$, Optional mis As Boolean = False, Optional ByVal ByPass As Boolean = False, Optional checkonly As Boolean = False, Optional needspace As Boolean = False) As Boolean
Dim test$, what$, Pass As Long
If ByPass Then Exit Function

If a$ <> "" And c$ <> "" Then
    test$ = a$
    If Right$(c$, 1) <= "9" Then
        If FastSymbol(test$, c$, , Len(c$)) Then
            If needspace Then
                If test$ = vbNullString Then
                ElseIf AscW(test$) < 36 Then
                ElseIf InStr(":;\',/", Left$(test$, 1)) > 0 Then ' : ; ,
                Else
                    Exit Function
                End If
            End If
            If Not checkonly Then a$ = test$
            IsLabelSymbol3 = True
        Else
            If mis Then MyEr "missing " & c$, "КЕъПЕИ " & c$
        End If
        Exit Function
    Else
        Pass = 1000 ' maximum
        IsLabelSymbol3 = IsLabelSYMB33(test$, what$, Pass)
   
      If Len(what$) <> Len(c$) Then
               If code = 1032 Then
                useth$ = myUcase(what$, True)
            Else
                useth$ = UCase(what$)
            End If
      IsLabelSymbol3 = False
         If mis Then GoTo theremiss
        Exit Function
      End If
    End If
    If what$ = vbNullString Then
    
        If mis Then GoTo theremiss
        Exit Function
    End If
    If code = 1032 Then
        what$ = myUcase(what$, True)
    Else
        what$ = UCase(what$)
    End If
    If what$ = c$ Then
    
        test$ = Mid$(test$, Pass)
        If needspace Then
            If test$ = vbNullString Then
            ElseIf AscW(test$) < 36 Then
            ElseIf InStr(":;\',/", Left$(test$, 1)) > 0 Then
            ' : ; ,
            Else
                IsLabelSymbol3 = False
                Exit Function
            End If
        End If
        If checkonly Then
          '  A$ = what$ & TEST$
          Else
           a$ = test$
        End If
  
       Else
             If mis Then
theremiss:
           ''  MyErMacro a$, "missing " & c$, "КЕъПЕИ " & c$
                 MyEr "missing " & c$, "КЕъПЕИ " & c$
                 Else
                 useth$ = what$
              End If
            IsLabelSymbol3 = False
            End If
Else
If mis Then GoTo theremiss
End If
End Function
Function IsLabelSymbolLatin(a$, c$, Optional mis As Boolean = False, Optional ByVal ByPass As Boolean = False, Optional checkonly As Boolean = False) As Boolean
Dim test$, what$, Pass As Long
If ByPass Then Exit Function

  If a$ <> "" And c$ <> "" Then
test$ = a$
Pass = Len(c$)
IsLabelSymbolLatin = IsLabelSYMB33(test$, what$, Pass)
If Len(what$) <> Len(c$) Then IsLabelSymbolLatin = False
If Not IsLabelSymbolLatin Then
             If mis Then
                 MyEr "missing " & c$, "КЕъПЕИ " & c$
              End If
            Exit Function
End If
        If UCase(what$) = c$ Then
        If checkonly Then
      '  A$ = what$ & " " & TEST$
        Else
                    a$ = Mid$(test$, Pass)
          End If
  
             Else
             If mis Then
                 MyEr "missing " & c$, "КЕъПЕИ " & c$
              End If
            IsLabelSymbolLatin = False
            End If

End If
End Function
Private Function FastSymbol(a$, c$, Optional mis As Boolean = False, Optional cl As Long = 1) As Boolean
Dim i As Long, j As Long
j = Len(a$)
If j = 0 Then Exit Function
i = MyTrimL(a$)
If i > j Then Exit Function  ' this is not good
If j - i < cl - 1 Then
If mis Then MyEr "missing " & c$, "КЕъПЕИ " & c$
Exit Function
End If
If c$ = Mid$(a$, i, cl) Then
a$ = Mid$(a$, MyTrimLi(a$, i + cl))
FastSymbol = True
ElseIf mis Then
MyEr "missing " & c$, "КЕъПЕИ " & c$
End If
End Function

Private Function MyTrimL(s$) As Long
Dim i&, l As Long
Dim p2 As Long, p1 As Integer, p4 As Long
  l = Len(s): If l = 0 Then MyTrimL = 1: Exit Function
  p2 = StrPtr(s): l = l - 1
  p4 = p2 + l * 2
  For i = p2 To p4 Step 2
  GetMem2 i, p1
  Select Case p1
    Case 32, 160, 7, 9
    Case Else
     MyTrimL = (i - p2) \ 2 + 1
   Exit Function
  End Select
  Next i
 MyTrimL = l + 2
End Function
Public Function RealLen(s$, Optional checkone As Boolean = False) As Long
Dim i&, LL As Long, n As Long
LL = Len(s): If LL = 0 Then Exit Function
If checkone Then LL = 1
Dim a1() As Integer, A2() As Integer
ReDim a1(LL + 6)
ReDim A2(LL + 6)
Dim skip As Boolean
skip = GetStringTypeExW(&HB, 4, StrPtr(s$), LL, a1(0)) = 0
skip = GetStringTypeExW(&HB, 2, StrPtr(s$), LL, A2(0)) = 0 Or skip
If skip Then
RealLen = LL
Else
  i& = LL - 1
  LL = LL * 2
  For n = 0 To i&
  If a1(n) = 2048 And A2(n) = 1 Then
    LL = LL - 1
  ElseIf a1(n) = 4096 And A2(n) = 0 Then
     LL = LL - 1
   ElseIf a1(n) = 3 And A2(n) = 11 Then
    LL = LL - 2
   ElseIf a1(n) = 0 And A2(n) = 0 Then
   LL = LL - 2
   ElseIf a1(n) = 1 Then
   LL = LL - 2
   End If
  Next n
RealLen = LL \ 2
End If

End Function
Public Function CheckIsmArray(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.t1 = 3 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If

    End If
    
End If
If Not obj Is Nothing Then
If TypeOf obj Is mArray Then If obj.Arr Then CheckIsmArray = True: Set oldobj = Nothing: Exit Function
End If
Set obj = oldobj
End Function
Public Function CheckIsmStiva(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.t1 = 3 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If

    End If
    
End If
If Not obj Is Nothing Then
If TypeOf obj Is mStiva Then CheckIsmStiva = True: Set oldobj = Nothing: Exit Function
End If
Set obj = oldobj
End Function
Public Function CheckIsmArrayOrStackOrCollection(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.t1 <> 2 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If
   
    End If
    
End If
If Not obj Is Nothing Then
If TypeOf obj Is mArray Then If obj.Arr Then CheckIsmArrayOrStackOrCollection = True: Set oldobj = Nothing: Exit Function
If TypeOf obj Is mStiva Then CheckIsmArrayOrStackOrCollection = True: Set oldobj = Nothing: Exit Function
If TypeOf obj Is FastCollection Then CheckIsmArrayOrStackOrCollection = True: Set oldobj = Nothing: Exit Function
End If
Set obj = oldobj
End Function
Public Function CheckDeepAny(obj As Object) As Boolean
Dim oldobj As Object, usehandler As mHandler
If obj Is Nothing Then Exit Function
Set oldobj = obj

Dim kk As Long
again:
If kk > 20 Then Set obj = oldobj: Exit Function
If TypeOf obj Is mHandler Then
Set usehandler = obj
    If usehandler.t1 = 3 Then
        If usehandler.indirect >= 0 And usehandler.indirect <= var2used Then
                Set obj = var(usehandler.indirect)
                kk = kk + 1
                GoTo again
        Else
                Set obj = usehandler.objref
        End If

    End If
    
End If
If Not obj Is Nothing Then Set oldobj = Nothing: CheckDeepAny = True: Exit Function
Set obj = oldobj
End Function

Function getindexes(bstack As basetask, obj1 As Object, a$) As Boolean
Dim s$, p, idx As New mIndexes, dn As Long, aProp As PropReference
Set aProp = obj1
Do
        If IsExp(bstack, a$, p) Then
        
                idx(dn) = p
                aProp.index = p
            ElseIf IsStrExp(bstack, a$, s$) Then
                idx(dn) = s$
                aProp.index = s$
            ElseIf FastSymbol(a$, "?") Then
                idx.IndexOpt dn
                aProp.IndexOpt
            Else
                If dn = 0 Then
                If MaybeIsSymbol(a$, ")") Then
                    getindexes = True
                End If
                End If
                idx.IndexOpt dn
                aProp.IndexOpt
            End If
            dn = dn + 1
Loop Until Not FastSymbol(a$, ",")
aProp.PushIndexes idx
End Function
Public Sub MyDoEventsNoRefresh()
On Error GoTo there
If TaskMaster Is Nothing Then
    DoEvents
    Exit Sub
ElseIf Not TaskMaster.Processing And TaskMaster.QueueCount = 0 Then
    DoEvents
    Exit Sub
Else
    If TaskMaster.PlayMusic Then
        TaskMaster.OnlyMusic = True
        TaskMaster.TimerTick
        TaskMaster.OnlyMusic = False
    End If
    TaskMaster.StopProcess
    TaskMaster.TimerTick
    DoEvents
    TaskMaster.StartProcess
End If
Exit Sub
there:
If Not TaskMaster Is Nothing Then TaskMaster.RestEnd1
End Sub
Private Function lookB123(s As String, Optional ByVal Pos As Long = 1) As Boolean
Dim i&, l As Long
Dim p2 As Long, p1 As Integer, p4 As Long
  l = Len(s): If l = 0 Then Exit Function
  If Pos > l Then Exit Function
  p2 = StrPtr(s) + (Pos - 1) * 2: l = l - 1
  For i = p2 To p2 + l * 2 Step 2
  GetMem2 i, p1
  Select Case p1
    Case 32, 160, 7, 9
    Case 13, 47, 39, 92
     lookB123 = True
    Case Else
   Exit Function
  End Select
  Next i

End Function
Sub StaticWork(basestack As basetask, mystack As basetask, ByVal where$)
    Dim vvv
    where$ = "%_" + where$
    If basestack.StaticCollection.ExistKey(where$) Then
        basestack.ReadStaticCol2 where$, vvv
        If MyIsObject(vvv) Then Set mystack.StaticCollection = vvv
    End If
End Sub
